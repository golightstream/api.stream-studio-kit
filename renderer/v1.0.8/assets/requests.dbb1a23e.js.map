{"version":3,"file":"requests.dbb1a23e.js","sources":["../../../../src/helpers/sceneless-project.ts","../../../../src/core/requests.ts"],"sourcesContent":["/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\n/**\n * Create and manage a project with a {@link ScenelessProject.Commands simple and opinionated interface}.\n *\n * A ScenelessProject is designed to fulfill all of the requirements of\n * a standard web-based broadcaster. It provides simple\n * management of WebRTC {@link Participant Participants},\n * custom layouts, backgrounds, and overlay content.\n *\n * Internally, any {@link Project} that meets a certain set of preconditions is\n * eligible to act as a ScenelessProject. The simplest way to ensure a project\n * can leverage these commands is by creating one with {@link create ScenelessProject.create()}.\n *\n * ```typescript\n * // Create a project for the user with default settings\n * const project = await ScenelessProject.create({\n *   backgroundImage: 'https://studio.golightstream.com/images/polygons.jpg',\n *   layout: 'Grid',\n * })\n *\n * // Pass the project in to receive a list of commands unique to a ScenelessProject\n * const projectCommands = ScenelessProject.commands(project)\n *\n * // Use the commands to update the project's contents (what participants/overlays will appear in the output stream)\n * projectCommands.addParticipant(participantId)\n * ```\n *\n * ----\n * _Note: When using a project interface such as this, avoid using\n * any {@link Command Commands} that operate on elements inside the project. This\n * includes any command which operates on a node (e.g. {@link Command.updateNode} or {@link Command.reorderNodes})._\n *\n * _This is an alternative to {@link Command.createProject}._\n *\n * @module ScenelessProject\n */\n\nimport * as Layout from '../compositor/html/html-layouts'\nimport { CoreContext } from '../core/context'\nimport { getProjectRoom } from '../core/data'\nimport { SDK, Compositor } from '../core/namespaces'\nimport { Disposable } from '../core/types'\nimport { Track } from 'livekit-client'\n\nimport LayoutName = Layout.LayoutName\nexport type { LayoutName }\n\nexport type ParticipantProps = {\n  volume: number\n  isMuted: boolean\n}\n\n// Local cache to track participants being added\nconst addingCache = {\n  camera: new Set<string>(),\n  screen: new Set<string>(),\n}\n\nexport type ParticipantType = 'camera' | 'screen'\n\ninterface ScenelessProject extends SDK.Project {}\n\n// Note: Assume project is a valid sceneless project\n// Note: In the future commands will be returned by an argument of SceneNode\n\n// TODO: Define defaults\n// TODO: Define emits\n\n/**\n * These commands assist with management of WebRTC {@link Participant Participants},\n * custom layouts, backgrounds, and overlay content.\n *\n * Only a valid {@link ScenelessProject} can leverage these commands.\n */\nexport interface Commands {\n  /**\n   * Get the node that holds the stream's background\n   * @private\n   */\n  getBackground(): Compositor.SceneNode\n  /**\n   * Get the node that holds the stream's content\n   * @private\n   */\n  getContent(): Compositor.SceneNode\n  /**\n   * Get the node that holds the stream's foreground (overlays)\n   * @private\n   */\n  getForeground(): Compositor.SceneNode\n  /**\n   * Get the active layout\n   * @private\n   */\n  getLayout(): string\n  /**\n   * Set the active layout and associated layoutProps\n   */\n  setLayout(layout: LayoutName, layoutProps: LayoutProps): void\n  /**\n   * Get the active background image\n   */\n  getBackgroundImage(): string\n  /**\n   * Set the active background image\n   */\n  setBackgroundImage(src: string): void\n  /**\n   * Set one participant to \"showcase\". This participant will expand to fill\n   * the space of the stream without affecting the underlying layout.\n   */\n  setShowcase(\n    participantId: string,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): ReturnType<typeof CoreContext.Command.updateNode>\n  /**\n   * @hook\n   * Receive information about the showcased participant.\n   * As with other hooks, the callback will be invoked when its value changes.\n   */\n  useShowcase(\n    cb: (state: { participantId: string; type: ParticipantType }) => void,\n  ): Disposable\n  /**\n   * Add a participant to the stream canvas.\n   * Available participants can be gleaned from the WebRTC {@link Room} using\n   * {@link Room.useParticipants}.\n   *\n   * A participant will remain on stream even if there is no active feed, until\n   * it is removed using {@link removeParticipant removeParticipant()} or {@link pruneParticipants pruneParticipants()}.\n   */\n  addParticipant(\n    participantId: string,\n    props: Partial<ParticipantProps>,\n    /**\n     * The type of participant feed to add.\n     * @default `'camera'`\n     */\n    type?: ParticipantType,\n  ): Promise<void>\n  /**\n   * @private\n   * @deprecated Use addParticipant() with parameter `type`\n   */\n  addParticipantScreenshare(\n    participantId: string,\n    props: Partial<ParticipantProps>,\n  ): Promise<void>\n  /**\n   * Remove a stream participant from the stream canvas.\n   */\n  removeParticipant(participantId: string, type: ParticipantType): void\n  /**\n   * @private\n   * @deprecated Use removeParticipant() with parameter `type`\n   */\n  removeParticipantScreenshare(participantId: string): void\n  /** @private */\n  getParticipantNode(\n    id: string,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): Compositor.SceneNode\n  /**\n   * Get {@link ParticipantProps} associated with a participant/type.\n   */\n  getParticipantState(\n    participantId: string,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): ParticipantProps\n  /**\n   * @hook\n   * Receive {@link ParticipantProps} associated with a participant/type\n   * via invoked callback anytime one of the property values changes.\n   */\n  useParticipantState(\n    participantId: string,\n    cb: (state: ParticipantProps) => void,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): Disposable\n  /**\n   * Change a participant's volume.\n   * This does not affect the underlying MediaStreamTrack.\n   */\n  setParticipantVolume(\n    participantId: string,\n    /**\n     * Accepted values from [0 - 1]\n     */\n    volume: number,\n  ): void\n  /**\n   * Mute a participant without changing their volume.\n   * This does not affect the underlying MediaStreamTrack.\n   */\n  setParticipantMuted(participantId: string, isMuted: boolean): void\n  /**\n   * Remove all participants from the stream canvas who are not actively\n   * sending a MediaStreamTrack for display.\n   */\n  pruneParticipants(): void\n}\n\n/**\n * Accepts a Project that was created using {@link ScenelessProject.create ScenelessProject.create()}\n * and returns several commands specialized for a Sceneless broadcasting experience.\n *\n * These commands assist with management of WebRTC {@link Participant Participants},\n * custom layouts, backgrounds, and overlay content.\n */\nexport const commands = (project: ScenelessProject) => {\n  const root = project.scene.getRoot()\n  const { Command } = CoreContext\n\n  const background = root.children.find((x) => x.props.id === 'bg')\n  const content = root.children.find((x) => x.props.id === 'content')\n  const foreground = root.children.find((x) => x.props.id === 'foreground')\n\n  const commands: Commands = {\n    getBackground() {\n      return background\n    },\n    getContent() {\n      return content\n    },\n    getForeground() {\n      return foreground\n    },\n    getLayout() {\n      return content.props.layout\n    },\n    setLayout(layout: LayoutName, layoutProps: LayoutProps = {}) {\n      const showcase = content.props.layoutProps.showcase\n      Command.setNodeLayout({\n        nodeId: content.id,\n        layout,\n        layoutProps: {\n          showcase,\n          ...layoutProps,\n        },\n      })\n    },\n    getBackgroundImage() {\n      return background.props.attributes.src\n    },\n    setBackgroundImage(src: string) {\n      CoreContext.Command.updateNode({\n        nodeId: background.id,\n        props: {\n          attributes: {\n            ...background.props.attributes,\n            src,\n          },\n        },\n      })\n    },\n    setShowcase(participantId: string, type: ParticipantType = 'camera') {\n      const node = commands.getParticipantNode(participantId, type)\n      return CoreContext.Command.updateNode({\n        nodeId: content.id,\n        props: {\n          layoutProps: {\n            ...content.props.layoutProps,\n            showcase: node?.id ?? null,\n          },\n        },\n      })\n    },\n    useShowcase(\n      cb: (state: { participantId: string; type: ParticipantType }) => void,\n    ) {\n      const sendState = () => {\n        const nodeId = content.props.layoutProps.showcase\n        const node = content.children.find((x) => x.id === nodeId)\n        if (!node)\n          return cb({\n            participantId: null,\n            type: null,\n          })\n\n        const { sourceProps } = node.props\n        return cb({\n          participantId: sourceProps.id,\n          type: sourceProps.type,\n        })\n      }\n      sendState()\n\n      // Watch for changes to the parent children\n      return CoreContext.on('NodeChanged', (payload) => {\n        if (payload.nodeId !== content.id) return\n        sendState()\n      })\n    },\n    async addParticipant(\n      participantId: string,\n      props: Partial<ParticipantProps> = {},\n      type: ParticipantType = 'camera',\n    ) {\n      if (addingCache[type].has(participantId)) return\n\n      const { isMuted = false, volume = 1 } = props\n      const existing = content.children.find(\n        (x) =>\n          x.props.sourceProps?.id === participantId &&\n          x.props.sourceProps?.type === type,\n      )\n      if (existing) return\n\n      addingCache[type].add(participantId)\n      await CoreContext.Command.createNode({\n        props: {\n          sourceType: 'RoomParticipant',\n          sourceProps: {\n            type,\n            id: participantId,\n          },\n          volume,\n          isMuted,\n        },\n        parentId: content.id,\n        index: content.children.length,\n      }).finally(() => {\n        addingCache[type].delete(participantId)\n      })\n    },\n    addParticipantScreenshare(\n      participantId: string,\n      props: Partial<ParticipantProps> = {},\n    ) {\n      return commands.addParticipant(participantId, props, 'screen')\n    },\n    removeParticipant(participantId: string, type: ParticipantType = 'camera') {\n      content.children\n        .filter(\n          (x) =>\n            x.props.sourceProps?.id === participantId &&\n            x.props.sourceProps?.type === type &&\n            x.props.sourceType === 'RoomParticipant',\n        )\n        .forEach((x) => {\n          CoreContext.Command.deleteNode({\n            nodeId: x.id,\n          })\n        })\n    },\n    removeParticipantScreenshare(participantId: string) {\n      return commands.removeParticipant(participantId, 'screen')\n    },\n    /** @private */\n    getParticipantNode(id: string, type: ParticipantType = 'camera') {\n      return content.children.find(\n        (x) =>\n          x.props.sourceProps?.id === id && x.props.sourceProps?.type === type,\n      )\n    },\n    getParticipantState(\n      participantId: string,\n      type: ParticipantType = 'camera',\n    ) {\n      return commands.getParticipantNode(participantId, type)\n        ?.props as ParticipantProps\n    },\n    useParticipantState(\n      participantId: string,\n      cb: (state: ParticipantProps) => void,\n      type = 'camera' as ParticipantType,\n    ) {\n      let participantNode = commands.getParticipantNode(participantId, type)\n\n      const sendState = () => {\n        cb(participantNode?.props as ParticipantProps)\n      }\n\n      // Watch for changes to the parent children\n      const childListener = CoreContext.on('NodeChanged', (payload) => {\n        if (payload.nodeId !== content.id) return\n        const previous = participantNode\n        participantNode = commands.getParticipantNode(participantId)\n        if (previous !== participantNode) {\n          sendState()\n        }\n      })\n\n      // Watch for changes to the participant node\n      const participantListener = CoreContext.on('NodeChanged', (payload) => {\n        if (!participantNode || payload.nodeId !== participantNode.id) return\n        sendState()\n      })\n\n      sendState()\n\n      // Return disposable for listener\n      return () => {\n        childListener()\n        participantListener()\n      }\n    },\n    setParticipantMuted(participantId: string, isMuted: boolean) {\n      const node = commands.getParticipantNode(participantId)\n      if (!node) return\n      CoreContext.Command.updateNode({\n        nodeId: node.id,\n        props: {\n          isMuted,\n        },\n      })\n    },\n    setParticipantVolume(participantId: string, volume: number) {\n      const node = commands.getParticipantNode(participantId)\n      if (!node) return\n      CoreContext.Command.updateNode({\n        nodeId: node.id,\n        props: {\n          volume,\n        },\n      })\n    },\n    pruneParticipants() {\n      // Remove all participant nodes that do not have active tracks\n      const room = getProjectRoom(project.id)\n      if (!room) return\n\n      content.children\n        .filter((node) => {\n          if (node.props.sourceType !== 'RoomParticipant') return false\n          const nodeSourceType = node.props.sourceProps?.type\n\n          // Get the participant associated with the node\n          const nodeParticipant = room.getParticipant(\n            node.props.sourceProps?.id,\n          )\n          // If the participant is not in the room, remove the node\n          if (!nodeParticipant) return true\n\n          // Keep \"camera\" nodes around as long as the participant is available.\n          //  This is to facilitate camera switching or other such feed interruptions\n          if (nodeSourceType === 'camera') return false\n\n          // Get all tracks associated with the node's participant\n          const participantTracks = nodeParticipant.trackIds\n            .map((x) => room.getTrack(x))\n            .filter(Boolean)\n\n          // Determine whether there is a track available to the node\n          const hasAvailableTrack = participantTracks.some((track) => {\n            // Get the source type as it corresponds to the track's type\n            const sourceType =\n              track.type === Track.Source.Camera ||\n              track.type === Track.Source.Microphone\n                ? 'camera'\n                : 'screen'\n\n            // Return true if the node source has a matching track\n            return sourceType === nodeSourceType\n          })\n\n          return !hasAvailableTrack\n        })\n        .forEach((x) => {\n          CoreContext.Command.deleteNode({\n            nodeId: x.id,\n          })\n        })\n    },\n  }\n  return commands\n}\n\nexport type LayoutProps = {\n  cover?: boolean\n  /** Valid CSS for justify-content */\n  justifyViewers?: 'flex-end' | 'center' | 'flex-start'\n  /** Percentage */\n  barWidth?: number\n  barPosition?: 'bottom' | 'side'\n  useGrid?: boolean\n}\ntype ScenelessProps = {\n  backgroundImage?: string\n  layout?: string\n  layoutProps?: LayoutProps\n}\n\n/**\n * **An abstraction over {@link Command.createProject Command.createProject()}.**\n *\n * A Project created using this function will be compatible with {@link ScenelessProject.commands ScenelessProject.commands()}\n *\n * **Emits: ProjectAdded**\n */\nexport const create = async (\n  props: ScenelessProps = {},\n  meta: SDK.Metadata = {},\n) => {\n  return CoreContext.Command.createProject({\n    props,\n    meta,\n  }) as Promise<ScenelessProject>\n}\n\n/** @private */\nexport const createCompositor = async (\n  layoutId: string,\n  size: { x: number; y: number },\n  props: ScenelessProps,\n) => {\n  const { backgroundImage, layout, layoutProps = {} } = props\n\n  // TODO: Batch insert\n  const project = await CoreContext.compositor.createProject(\n    {\n      props: {\n        name: 'Root',\n        type: 'sceneless-project',\n        layout: 'Layered',\n        size,\n        isRoot: true,\n      },\n    },\n    layoutId,\n  )\n  const root = project.getRoot()\n\n  // Create the base nodes for sceneless workflow\n  const baseLayers = await Promise.all([\n    project.insert(\n      {\n        name: 'Background',\n        id: 'bg',\n        tagName: 'img',\n        sourceType: 'Element',\n        attributes: {\n          src: backgroundImage,\n        },\n        style: {\n          objectFit: 'cover',\n        },\n      },\n      root.id,\n    ),\n    project.insert(\n      {\n        id: 'content',\n        name: 'Content',\n        layout,\n        layoutProps,\n      },\n      root.id,\n    ),\n    project.insert(\n      {\n        id: 'foreground',\n        name: 'Overlays',\n        layout: 'Free',\n      },\n      root.id,\n    ),\n  ])\n  await project.reorder(root.id, baseLayers)\n  return project\n}\n","/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\nimport { CoreContext } from './context'\nimport { Context } from './namespaces'\nimport { hydrateProject } from './data'\nimport { Helpers } from '.'\nimport { Metadata } from './types'\nimport { LiveApiModel } from '@api.stream/sdk'\n\nexport const updateProject = async (request: {\n  collectionId: string\n  projectId: string\n  props?: Metadata\n}) => {\n  const { projectId, collectionId, props = {} } = request\n  const { project } = await CoreContext.clients.LiveApi().project.getProject({\n    collectionId,\n    projectId,\n  })\n  const metadata = project.metadata\n  const existingProps = metadata.props || {}\n  const newProps = { ...existingProps, ...props }\n  CoreContext.clients.LiveApi().project.updateProject({\n    collectionId: project.collectionId,\n    projectId: project.projectId,\n    updateMask: ['metadata'],\n    metadata: { layoutId: metadata.layoutId, props: newProps },\n  })\n}\n\nexport const createProject = async (request: {\n  collectionId: string\n  props?: { [prop: string]: any }\n  meta?: Metadata // Arbitrary metadata (e.g. 'name')\n  size?: { x: number; y: number }\n  type?: 'sceneless' | 'freeform'\n}) => {\n  const type = request.type || 'sceneless'\n  const size = request.size || {\n    x: 1280,\n    y: 720,\n  }\n  const props = request.props || {}\n\n  // Create a project to go with the collection\n  let createProjectResponse = await CoreContext.clients\n    .LiveApi()\n    .project.createProject({\n      collectionId: request.collectionId,\n      rendering: {\n        video: {\n          width: size.x,\n          height: size.y,\n          framerate: 30,\n        },\n      },\n      composition: {\n        studioSdk: {},\n      },\n      metadata: {},\n      webrtc: {\n        hosted: {},\n      },\n    })\n\n  const layout = await CoreContext.clients.LayoutApi().layout.createLayout({\n    layout: {\n      projectId: createProjectResponse.project.projectId,\n      collectionId: createProjectResponse.project.collectionId,\n    },\n  })\n\n  const { displayName } = CoreContext.clients.getAccessToken()\n\n  // Save the layoutId on the project (no need to await)\n  const metadata = {\n    type,\n    layoutId: layout.id,\n    hostDisplayName: displayName,\n    ...(request.meta || {}),\n  }\n  let projectResponse = await CoreContext.clients\n    .LiveApi()\n    .project.updateProject({\n      collectionId: request.collectionId,\n      projectId: createProjectResponse.project.projectId,\n      updateMask: ['metadata'],\n      metadata,\n    })\n  createProjectResponse.project = projectResponse.project\n  createProjectResponse.project.metadata = metadata\n\n  if (type === 'sceneless') {\n    await Helpers.ScenelessProject.createCompositor(layout.id, size, props)\n  } else {\n    await CoreContext.compositor.createProject(\n      {\n        props: {\n          name: 'Root',\n          layout: 'Free',\n          ...props,\n          isRoot: true,\n          size,\n        },\n      },\n      layout.id,\n    )\n  }\n\n  return createProjectResponse\n}\n\nexport const loadProjects = async () => {\n  const collections = await loadCollections()\n\n  let collection: LiveApiModel.Collection\n\n  const { displayName, serviceUserId } = CoreContext.clients.getAccessToken()\n\n  // Get a single collection, corresponding to a user\n  if (collections.length === 0) {\n    // If the user has no collections, create one\n    const response = await CoreContext.clients\n      .LiveApi()\n      .collection.createCollection({\n        metadata: {\n          serviceUserId,\n          displayName,\n        },\n      })\n    collection = response.collection\n  } else {\n    // only 1 collection per user for studiosdk\n    collection = collections[0]\n  }\n\n  await CoreContext.clients\n    .LiveApi()\n    .subscribeToCollection(collection.collectionId)\n\n  // Take the Vapi Project and hydrate it with Compositor and Lapi project details\n  const projects = await Promise.all(\n    collection.projects.map((project) => hydrateProject(project)),\n  )\n\n  return {\n    collectionId: collection.collectionId,\n    userProps: collection.metadata || {},\n    projects,\n  }\n}\n\nexport const loadCollections = async () => {\n  let result = await CoreContext.clients.LiveApi().collection.getCollections({})\n  return result.collections\n}\n"],"names":["createCompositor","layoutId","size","props","backgroundImage","layout","layoutProps","project","CoreContext","compositor","createProject","name","type","isRoot","root","getRoot","baseLayers","Promise","all","insert","id","tagName","sourceType","attributes","src","style","objectFit","reorder","updateProject","request","projectId","collectionId","clients","LiveApi","getProject","metadata","existingProps","newProps","updateMask","x","y","createProjectResponse","rendering","video","width","height","framerate","composition","studioSdk","webrtc","hosted","LayoutApi","createLayout","displayName","getAccessToken","hostDisplayName","meta","projectResponse","Helpers","loadProjects","collections","loadCollections","collection","serviceUserId","length","response","createCollection","subscribeToCollection","projects","map","hydrateProject","userProps","result","getCollections"],"mappings":"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"}