{"version":3,"file":"requests.e06a3ca2.js","sources":["../../../../src/helpers/database.ts","../../../../src/helpers/sceneless-project.ts","../../../../src/core/requests.ts"],"sourcesContent":["/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\nimport { Compositor } from '../core'\nexport const ForegroundLayers = [\n  {\n    name: 'ImageIframeOverlayContainer',\n    id: 'fg-image-iframe',\n    layout: 'Free',\n  },\n  {\n    name: 'BannerContainer',\n    id: 'fg-banners',\n    layout: 'Column',\n    layoutProps: {\n      cover: true,\n    },\n  },\n  {\n    name: 'VideoOverlayContainer',\n    id: 'fg-video',\n    layout: 'Free',\n  },\n  {\n    name: 'LogoContainer',\n    layout: 'Free',\n    id: 'logo',\n  },\n]\n\nexport const defaultStyles = {\n  custom: {\n    display: 'block',\n  },\n  video: {\n    height: '100%',\n    width: '100%',\n  },\n  image: {\n    height: '100%',\n    width: '100%',\n  },\n  logo: {\n    objectFit: 'contain',\n    position: 'unset',\n  },\n}\n\nexport const validateEachChildren = (\n  children: Compositor.SceneNode[],\n  allowedSourceTypes: string[],\n) => {\n  let isValid = true\n  children.forEach((child) => {\n    if (\n      child.props?.sourceType &&\n      !allowedSourceTypes.includes(child.props?.sourceType)\n    ) {\n      isValid = false\n    } else {\n      if (child.children.length > 0) {\n        isValid =\n          isValid && validateEachChildren(child.children, allowedSourceTypes)\n      }\n    }\n  })\n  return isValid\n}\n\n// TODO : Write migration for updating any conflicting node\n\n// const allowedSourceTypes = [\n//   'Background',\n//   'Banner',\n//   'ChatOverlay',\n//   'Element',\n//   'Overlay',\n//   'Logo',\n//   'Square',\n// ]\n\n// const checkIsBackgroundValid = (root: Compositor.SceneNode) => {\n//   const background = root.children.find(\n//     (node: any) => node.props.id === 'background',\n//   )\n//   if (!background) return false\n//   if (background.children.length) {\n//     return validateEachChildren(background.children)\n//   }\n//   return true\n// }\n\n// const checkIsForegroundValid = (root: Compositor.SceneNode) => {\n//   const foreground = root.children.find(\n//     (node: any) => node.props.id === 'foreground',\n//   )\n//   if (!foreground) return false\n//   if (foreground.children.length) {\n//     return validateEachChildren(foreground.children)\n//   }\n//   return true\n// }\n\n// export const migrateLayout = async (\n//   project: string,\n//   root: Compositor.SceneNode,\n// ): Promise<{ project: SDK.Project; internalProject: InternalProject }> => {\n//   if (root) {\n//     if (!checkIsBackgroundValid(root) || !checkIsForegroundValid(root)) {\n//       return await CoreContext.Command.recreateLayout({ projectId: project })\n//     }\n//   }\n//   return {\n//     project: null,\n//     internalProject: null,\n//   }\n// }\n","/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\n/**\n * Create and manage a project with a {@link ScenelessProject.Commands simple and opinionated interface}.\n *\n * A ScenelessProject is designed to fulfill all of the requirements of\n * a standard web-based broadcaster. It provides simple\n * management of WebRTC {@link Participant Participants},\n * custom layouts, backgrounds, and overlay content.\n *\n * Internally, any {@link Project} that meets a certain set of preconditions is\n * eligible to act as a ScenelessProject. The simplest way to ensure a project\n * can leverage these commands is by creating one with {@link create ScenelessProject.create()}.\n *\n * ```typescript\n * // Create a project for the user with default settings\n * const project = await ScenelessProject.create({\n *   backgroundImage: 'https://studio.golightstream.com/images/polygons.jpg',\n *   layout: 'Grid',\n * })\n *\n * // Pass the project in to receive a list of commands unique to a ScenelessProject\n * const projectCommands = ScenelessProject.commands(project)\n *\n * // Use the commands to update the project's contents (what participants/overlays will appear in the output stream)\n * projectCommands.addParticipant(participantId)\n * ```\n *\n * ----\n * _Note: When using a project interface such as this, avoid using\n * any {@link Command Commands} that operate on elements inside the project. This\n * includes any command which operates on a node (e.g. {@link Command.updateNode} or {@link Command.reorderNodes})._\n *\n * _This is an alternative to {@link Command.createProject}._\n *\n * @module ScenelessProject\n */\nimport { LogoProps } from './../core/transforms/Logo'\nimport { BackgroundProps } from './../core/transforms/Background'\nimport { OverlayProps } from './../core/transforms/Overlay'\nimport { Overlay } from '../core/sources/Overlays'\nimport { CoreContext } from '../core/context'\nimport { getProject, getProjectRoom } from '../core/data'\nimport { SDK, Compositor } from '../core/namespaces'\nimport { Disposable, SceneNode } from '../core/types'\nimport { Track } from 'livekit-client'\nimport { Banner, BannerSource, BannerProps } from '../core/sources/Banners'\nimport { RoomParticipantSource } from '../core/sources/WebRTC'\nimport { generateId, findAll, deepEqual, cloneDeep } from '../logic'\nimport { ChatOverlayProps } from '../core/transforms/ChatOverlay'\nimport LayoutName = Compositor.Layout.LayoutName\nimport {\n  defaultStyles,\n  ForegroundLayers,\n  validateEachChildren,\n} from './database'\n\nexport type { LayoutName }\nexport type { Banner, BannerSource, RoomParticipantSource }\n\nexport type ParticipantProps = {\n  volume: number\n  isMuted: boolean\n  isHidden: boolean\n}\n\nexport type HTMLVideoElementAttributes = {\n  loop?: boolean\n  autoplay?: boolean\n  muted?: boolean\n  playsinline?: boolean\n  disablepictureinpicture?: boolean\n}\n\n// Local cache to track participants being added\nconst addingCache = {\n  camera: new Set<string>(),\n  screen: new Set<string>(),\n  rtmp: new Set<string>(),\n}\n\nexport type ParticipantType = 'camera' | 'screen'\n\ninterface ScenelessProject extends SDK.Project {}\n\n// Note: Assume project is a valid sceneless project\n// Note: In the future commands will be returned by an argument of SceneNode\n\n// TODO: Define defaults\n// TODO: Define emits\n\n/**\n * These commands assist with management of WebRTC {@link Participant Participants},\n * custom layouts, backgrounds, and overlay content.\n *\n * Only a valid {@link ScenelessProject} can leverage these commands.\n */\nexport interface Commands {\n  /**\n   * Get the node that holds the stream's background\n   * @private\n   */\n  getBackground(): Compositor.SceneNode\n  /**\n   * Get the node that holds the stream's content\n   * @private\n   */\n  getContent(): Compositor.SceneNode\n  /**\n   * Get the node that holds the stream's foreground (overlays)\n   * @private\n   */\n  getForeground(): Compositor.SceneNode\n  /**\n   * Get the active layout\n   * @private\n   */\n  getLayout(): string\n  /**\n   * Get all banners stored on the project\n   */\n  getBanners(): Banner[]\n  /**\n   * Get all banners stored on the project\n   */\n  getOverlays(): Overlay[]\n\n  /**\n   * Get all participants in the project\n   * @private\n   */\n  getParticipants(): Compositor.SceneNode[]\n  /**\n   * play video overlay on foreground\n   * @private\n   */\n  autoPlayVideoOverlay(\n    overlayId: string,\n    attributes: HTMLVideoElementAttributes,\n  ): void\n\n  /**\n   * play background Video\n   * @private\n   */\n  autoPlayBackgroundVideo(attributes?: HTMLVideoElementAttributes): void\n\n  /**\n   * Remove logo from stream\n   */\n  removeLogo(): Promise<void>\n\n  /**\n   * Add logo on stream\n   * @param id \n   * @param logo \n   */\n  addLogo(id: string, logo: LogoProps): Promise<void>\n\n  /**\n   * Get active logo\n   */\n  getLogo(): string\n\n  /**\n   * Add an chat comment to the stream.\n   */\n  addChatOverlay(id: string, Options: ChatOverlayProps): void\n\n  /**\n   * Add an any exisiting chat comment from the stream.\n   */\n  removeChatOverlay(id: string): void\n\n  /**\n   * get the active chat comment to the stream.\n   */\n  getChatOverlay(): ChatOverlayProps | null\n\n  /**\n   * Set the active layout and associated layoutProps\n   */\n  setLayout(layout: LayoutName, layoutProps: LayoutProps): void\n\n  /**\n   * Set the active background image\n   */\n  getBackgroundMedia(): string\n\n  /**\n   * Get the active background image\n   */\n  getBackgroundImage(): string\n  /**\n   * Get the active background video\n   */\n  getBackgroundVideo(): string\n\n  /**\n   * remove the active video overlay\n   */\n  removeBackgroundImage(): Promise<void>\n  /**\n   * remove the active image overlay\n   */\n  removeBackgroundVideo(): Promise<void>\n  /**\n     Set the active background image\n   */\n  setBackgroundImage(id: string, props: BackgroundProps): Promise<void>\n\n  /**\n   * Set the active background video\n   */\n  setBackgroundVideo(\n    id: string,\n    props: BackgroundProps & HTMLVideoElementAttributes,\n  ): Promise<void>\n\n  /* Updating the background video props. */\n  updateBackgroundVideoProps(\n    id: string,\n    props: BackgroundProps & HTMLVideoElementAttributes,\n  ): Promise<void>\n\n  getImageOverlay(): string | null\n  /**\n   * Get the active video overlay\n   */\n  getVideoOverlay(): string | null\n  /**\n   * Get the active foreground image overlay\n   */\n  getCustomOverlay(): string | null\n  /**\n   * Set the active foreground image overlay\n   */\n  addImageOverlay(overlayId: string, props: OverlayProps): Promise<void>\n  /**\n   * set image overlay on foreground video layer\n   */\n  addVideoOverlay(\n    overlayId: string,\n    props: OverlayProps & HTMLVideoElementAttributes,\n  ): Promise<void>\n\n  updateVideoOverlayProps(\n    id: string,\n    props: OverlayProps & HTMLVideoElementAttributes,\n  ): Promise<void>\n  /**\n   * add html overlay\n   */\n  addCustomOverlay(id: string, props: OverlayProps): Promise<void>\n  /**\n   * remove video overlay from foreground layer\n   */\n  removeCustomOverlay(): Promise<void>\n  /**\n   * remove the active video overlay\n   */\n  removeVideoOverlay(): Promise<void>\n  /**\n   * remove the active image overlay\n   */\n  removeImageOverlay(): Promise<void>\n\n  /* A generic function that takes a string and a callback function as parameters. The callback\n  function takes a generic type as a parameter. */\n  useLayerState<T>(sourceType: string, cb: (state: T) => void): void\n  /** Set one participant to \"showcase\". This participant will expand to fill\n   * the space of the stream without affecting the underlying layout.\n   */\n  setShowcase(\n    participantId: string,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): ReturnType<typeof CoreContext.Command.updateNode>\n  /**\n   * @hook\n   * Receive information about the showcased participant.\n   * As with other hooks, the callback will be invoked when its value changes.\n   */\n  useShowcase(\n    cb: (state: { participantId: string; type: ParticipantType }) => void,\n  ): Disposable\n\n  /**\n   * Add an RTMP Source to the canvas\n   */\n  addRTMPSource(\n    id: string,\n    props: Partial<ParticipantProps>,\n    type?: ParticipantType,\n  ): Promise<void>\n\n  /**\n   * Remove an RTMP source from the canvas\n   */\n  removeRTMPSource(\n    id: string\n  ): void\n\n  /**\n   * Add a participant camera track to the stream canvas.\n   * Available participants can be gleaned from the WebRTC {@link Room} using\n   * {@link Room.useParticipants}.\n   *\n   * A participant will remain on stream even if there is no active feed, until\n   * it is removed using {@link removeParticipantTrack removeParticipantTrack()} or {@link pruneParticipants pruneParticipants()}.\n   */\n  addParticipantTrack(\n    trackId: string,\n    props: Partial<ParticipantProps>,\n    /**\n     * The type of participant feed to add.\n     * @default `'camera'`\n     */\n    type?: ParticipantType,\n  ): Promise<void>\n  /**\n   * Remove a stream participant from the stream canvas.\n   */\n  removeParticipantTrack(trackId: string, type?: ParticipantType): void\n\n  /**\n   * Add a participant to the stream canvas.\n   * Available participants can be gleaned from the WebRTC {@link Room} using\n   * {@link Room.useParticipants}.\n   *\n   * A participant will remain on stream even if there is no active feed, until\n   * it is removed using {@link removeParticipant removeParticipant()} or {@link pruneParticipants pruneParticipants()}.\n   */\n\n  addParticipant(\n    participantId: string,\n    props: Partial<ParticipantProps>,\n    /**\n     * The type of participant feed to add.\n     * @default `'camera'`\n     */\n    type?: ParticipantType,\n  ): Promise<void>\n  /**\n   * @private\n   * @deprecated Use addParticipant() with parameter `type`\n   */\n  addParticipantScreenshare(\n    participantId: string,\n    props: Partial<ParticipantProps>,\n  ): Promise<void>\n  /**\n   * Remove a stream participant from the stream canvas.\n   */\n  removeParticipant(participantId: string, type: ParticipantType): void\n  /**\n   * @private\n   * @deprecated Use removeParticipant() with parameter `type`\n   */\n  removeParticipantScreenshare(participantId: string): void\n  /**\n   * @private\n   * Get the node associated with a room participant\n   * */\n  getParticipantNode(\n    id: string,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): Compositor.SceneNode\n  /**\n   * Get {@link ParticipantProps} associated with a participant/type.\n   */\n  getParticipantState(\n    participantId: string,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): ParticipantProps\n  /**\n   * @hook\n   * Receive {@link ParticipantProps} associated with a participant/type\n   * via invoked callback anytime one of the property values changes.\n   */\n  useParticipantState(\n    participantId: string,\n    cb: (state: ParticipantProps) => void,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): Disposable\n  /**\n   * Change a participant's volume.\n   * This does not affect the underlying MediaStreamTrack.\n   */\n  setParticipantVolume(\n    participantId: string,\n    /**\n     * Accepted values from [0 - 1]\n     */\n    volume: number,\n  ): void\n  /**\n   * Mute a participant without changing their volume.\n   *  This does not affect the underlying MediaStreamTrack.\n   *\n   * Participants muted in this way will not stop sending\n   *  audio data, but it will not play on the receiving end.\n   *\n   * A host may use this to override a guest's settings\n   *  for the stream output.\n   */\n  setParticipantMuted(participantId: string, isMuted: boolean): void\n  /**\n   * Hide a participant video feed from the stream.\n   *  This does not affect the underlying MediaStreamTrack.\n   *\n   * Participants hidden in this way will not stop sending\n   *  video data, but it will not play on the receiving end.\n   *\n   * A host may use this to override a guest's settings\n   *  for the stream output.\n   */\n  setParticipantHidden(participantId: string, isHidden: boolean): void\n  /**\n   * Remove all participants from the stream canvas who are not actively\n   * sending a MediaStreamTrack for display.\n   */\n  pruneParticipants(): void\n  /**\n   * Create and store a banner on the project.\n   *\n   * Does not add the banner to the stream.\n   */\n  addBanner(props: BannerProps): void\n  /**\n   * Edit a banner on the project.\n   */\n  editBanner(id: string, props: BannerProps): void\n  /**\n   * Remove a banner from the project.\n   */\n  removeBanner(id: string): void\n  /**\n   * Fetch the active banner displayed on stream.\n   */\n  getActiveBanner(): string | null\n  /**\n   * Add an existing banner to the stream.\n   * If no `id` is supplied, existing banners will be removed.\n   */\n  setActiveBanner(id: string): void\n  /**\n   * Get an arbitrary property from the project (`project.props{}`)\n   */\n  getProp(props: string): any\n  /**\n   * Set an arbitrary property on the project (`project.props{}`)\n   */\n  setProp(props: string, val: any): void\n  /**\n   * Use the latest value of an arbitrary property on the project (`project.props{}`)\n   */\n  useProp(props: string, cb: (val: any) => void): void\n  /**\n   * Add a source TEMPORARY\n   */\n  createSource: typeof CoreContext.Command.createSource\n  /**\n   * Remove a source TEMPORARY\n   */\n  deleteSource: typeof CoreContext.Command.deleteSource\n}\n\n/**\n * Accepts a Project that was created using {@link ScenelessProject.create ScenelessProject.create()}\n * and returns several commands specialized for a Sceneless broadcasting experience.\n *\n * These commands assist with management of WebRTC {@link Participant Participants},\n * custom layouts, backgrounds, and overlay content.\n */\nexport const commands = (_project: ScenelessProject) => {\n  const projectId = _project.id\n  const root = _project.scene.getRoot()\n  const { Command } = CoreContext\n\n  const background = root.children.find((x) => x.props.id === 'bg')\n  const content = root.children.find((x) => x.props.id === 'content')\n  const foreground = root.children.find((x) => x.props.id === 'foreground')\n\n  let foregroundImageIframeContainer = foreground?.children?.find(\n    (x) => x.props.id === 'fg-image-iframe',\n  )\n\n  let foregroundLogoContainer = foreground?.children?.find(\n    (x) => x.props.id === 'logo',\n  )\n\n  let foregroundVideoContainer = foreground?.children?.find(\n    (x) => x.props.id === 'fg-video',\n  )\n  const coreProject = getProject(_project.id)\n\n  let bannerContainer = foreground?.children?.find(\n    (x) => x.props.id === 'fg-banners',\n  )\n\n  const ensureRootLayersProps = async () => {\n    if (background?.props?.layout !== 'Layered') {\n      await coreProject.compositor.update(background.id, {\n        name: 'Background',\n        id: 'bg',\n        layout: 'Layered',\n      })\n    }\n    if (foreground?.props?.layout !== 'Layered') {\n      await coreProject.compositor.update(foreground.id, {\n        id: 'foreground',\n        name: 'Overlays',\n        layout: 'Layered',\n      })\n    }\n  }\n\n  const ensureBackgroundChildLayersProps = async () => {\n    if (!validateEachChildren(background.children, ['Background'])) {\n      background.children.forEach(async (child) => {\n        await CoreContext.Command.deleteNode({ nodeId: child.id })\n      })\n    }\n  }\n\n  const ensureForegroundContainers = async () => {\n    const ensureBannerContainer = async () => {\n      if (!bannerContainer) {\n        const nodeId = await coreProject.compositor.insert(\n          {\n            name: 'BannerContainer',\n            id: 'fg-banners',\n            layout: 'Column',\n            layoutProps: {\n              cover: true,\n            },\n          },\n          foreground.id,\n        )\n        bannerContainer = foreground?.children?.find((x) => x.id === nodeId)\n        return nodeId\n      } else {\n        return bannerContainer.id\n      }\n    }\n    const ensureForegroundImageAndIframeContainer = async () => {\n      if (!foregroundImageIframeContainer) {\n        const nodeId = await coreProject.compositor.insert(\n          {\n            name: 'ImageIframeOverlay',\n            id: 'fg-image-iframe',\n            layout: 'Free',\n          },\n          foreground.id,\n        )\n\n        foregroundImageIframeContainer = foreground?.children?.find(\n          (x) => x.id === nodeId,\n        )\n        return nodeId\n      } else {\n        return foregroundImageIframeContainer.id\n      }\n    }\n\n    const ensureForegroundVideoContainer = async () => {\n      if (!foregroundVideoContainer) {\n        const nodeId = await coreProject.compositor.insert(\n          {\n            name: 'VideoOverlay',\n            id: 'fg-video',\n            layout: 'Free',\n          },\n          foreground.id,\n        )\n        foregroundVideoContainer = foreground?.children?.find(\n          (x) => x.id === nodeId,\n        )\n        return nodeId\n      } else {\n        return foregroundVideoContainer.id\n      }\n    }\n\n    const ensureForegroundLogoContainer = async () => {\n      if (!foregroundLogoContainer) {\n        const nodeId = await coreProject.compositor.insert(\n          {\n            name: 'Logo',\n            layout: 'Free',\n            sourceType: 'Logo',\n            id: 'logo',\n            style: {\n              width: '100%',\n              height: '100%',\n              objectFit: 'contain',\n              position: 'unset',\n            },\n          },\n          foreground.id,\n        )\n        foregroundLogoContainer = foreground?.children?.find(\n          (x) => x.id === nodeId,\n        )\n        return nodeId\n      } else {\n        return foregroundLogoContainer.id\n      }\n    }\n\n    try {\n      const baseForegroundLayers = await Promise.all([\n        ensureBannerContainer(),\n        ensureForegroundImageAndIframeContainer(),\n        ensureForegroundVideoContainer(),\n        ensureForegroundLogoContainer(),\n      ])\n\n      await coreProject.compositor.reorder(foreground.id, baseForegroundLayers)\n    } catch (e) {}\n  }\n\n  const commands: Commands = {\n    getBackground() {\n      return background\n    },\n    getContent() {\n      return content\n    },\n    getForeground() {\n      return foreground\n    },\n    getLayout() {\n      return content.props.layout\n    },\n    getBanners() {\n      return (getProject(_project.id).props?.banners || []) as Banner[]\n    },\n\n    getOverlays() {\n      return (getProject(_project.id).props.overlays || []) as Overlay[]\n    },\n\n    getParticipants() {\n      return content.children.filter((node) => {\n        if (node.props.sourceType !== 'RoomParticipant') return false\n        return true\n      })\n    },\n\n    getLogo() {\n      return foregroundLogoContainer?.children[0]?.props?.id\n    },\n\n    async removeLogo() {\n      // find overlay node by id\n      const [existingLogoNode, ...excessLogoNode] =\n        foregroundLogoContainer?.children || ([] as SceneNode[])\n      // if overlay exists, remove it\n      excessLogoNode.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n      if (existingLogoNode) {\n        await CoreContext.Command.deleteNode({\n          nodeId: existingLogoNode.id,\n        })\n      }\n    },\n\n    getImageOverlay(): string | null {\n      const foregroundImage = foregroundImageIframeContainer?.children?.find(\n        (x) => x?.props?.sourceProps?.type === 'image',\n      )\n      return foregroundImage?.props?.id\n    },\n\n    getVideoOverlay(): string | null {\n      const foregroundVideo = foregroundVideoContainer?.children?.find(\n        (x) => x?.props?.sourceProps?.type === 'video',\n      )\n      return foregroundVideo?.props?.id\n    },\n\n    autoPlayBackgroundVideo(\n      attributes: HTMLVideoElementAttributes = {\n        muted: true,\n        autoplay: true,\n      },\n    ) {\n      // find overlay node by id\n      const backgroundVideo = background.children.find(\n        (x) => x.props.id === 'bg-video',\n      )\n      // if overlay is not found, return\n      if (!backgroundVideo) {\n        return\n      }\n      // check if overlay is of type video\n      // autoPlay overlay with muted audio\n      // update overlay node with new attributes\n      CoreContext.Command.updateNode({\n        nodeId: backgroundVideo.id,\n        props: {\n          ...backgroundVideo.props,\n          attributes: {\n            ...backgroundVideo.props.attributes,\n            ...attributes,\n          },\n        },\n      })\n    },\n\n    autoPlayVideoOverlay(\n      overlayId: string,\n      attributes: HTMLVideoElementAttributes = {\n        muted: true,\n        autoplay: true,\n      },\n    ) {\n      // find overlay node by id\n      const overlay = foregroundVideoContainer?.children?.find(\n        (x) => x.props?.sourceProps?.id === overlayId,\n      )\n\n      // if overlay is not found, return\n      if (!overlay) {\n        return\n      }\n\n      // check if overlay is of type video\n      if (overlay.props.sourceProps.type === 'video') {\n        // autoPlay overlay with muted audio\n        // update overlay node with new attributes\n        CoreContext.Command.updateNode({\n          nodeId: overlay.id,\n          props: {\n            ...overlay.props,\n            attributes: {\n              ...overlay.props.attributes,\n              ...attributes,\n            },\n          },\n        })\n      }\n    },\n\n    getBackgroundMedia() {\n      const backgroundChild = background.children.filter((x) => x)\n      return backgroundChild[0]?.props?.id\n    },\n\n    getBackgroundImage() {\n      const backgroundChild = background.children.find(\n        (x) => x.props?.sourceProps?.type === 'image',\n      )\n      return backgroundChild?.props?.id\n    },\n\n    getBackgroundVideo() {\n      const backgroundChild = background.children.find(\n        (x) => x.props?.sourceProps?.type === 'video',\n      )\n      return backgroundChild?.props?.id\n    },\n\n    async addLogo(id: string, props: LogoProps) {\n      const [existingLogoNode, ...excessLogoNodes] =\n        foregroundLogoContainer?.children || ([] as SceneNode[])\n      // Delete all except one banner from the project\n      excessLogoNodes.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n      if (!existingLogoNode) {\n        await CoreContext.Command.createNode({\n          parentId: foregroundLogoContainer?.id,\n          props: {\n            sourceType: 'Logo',\n            id: id,\n            sourceProps: {\n              ...props,\n              meta: {\n                style: { ...defaultStyles['logo'] },\n                ...props.meta,\n              },\n            },\n          },\n        })\n      } else {\n        await CoreContext.Command.updateNode({\n          nodeId: existingLogoNode.id,\n          props: {\n            sourceType: 'Logo',\n            id: id,\n            sourceProps: {\n              ...props,\n              meta: {\n                style: { ...defaultStyles['logo'] },\n                ...props.meta,\n              },\n            },\n          },\n        })\n      }\n    },\n\n    addBanner(props: BannerProps = {}) {\n      const meta = props.meta || {}\n      const banner = {\n        id: generateId(),\n        props: {\n          ...props,\n          meta,\n        },\n      }\n\n      const existingBanners = (getProject(projectId).props?.banners ||\n        []) as Banner[]\n      return Command.updateProjectProps({\n        projectId,\n        props: {\n          banners: [...existingBanners, banner],\n        },\n      })\n    },\n    editBanner(id: string, props: BannerProps = {}) {\n      const existingBanners = commands.getBanners()\n      const banners = existingBanners.map((x) => {\n        if (x.id !== id) return x\n        return {\n          ...x,\n          props,\n        }\n      })\n      return Command.updateProjectProps({\n        projectId,\n        props: {\n          banners,\n        },\n      })\n    },\n    removeBanner(id: string) {\n      const existingBanners = commands.getBanners()\n      // Remove dependent nodes from stream\n      bannerContainer?.children?.forEach((x) => {\n        if (x.props.bannerId !== id) return\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n\n      return Command.updateProjectProps({\n        projectId,\n        props: {\n          banners: existingBanners.filter((x) => x.id !== id),\n        },\n      })\n    },\n    async setActiveBanner(id: string) {\n      const [nodeTocheckForChildren, ...{}] =\n        bannerContainer?.children || ([] as SceneNode[])\n\n      /* Checking if the existingBannerNode has a property called chatOverlayId. If it does, it deletes the\n      node. */\n      if (\n        nodeTocheckForChildren?.props?.sourceType?.toLowerCase() ===\n        'chatoverlay'\n      ) {\n        await CoreContext.Command.deleteNode({\n          nodeId: nodeTocheckForChildren.id,\n        })\n      }\n\n      const [existingBannerNode, ...excessBannerNodes] =\n        bannerContainer?.children || ([] as SceneNode[])\n      // Delete all except one banner from the project\n      excessBannerNodes.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n      if (!existingBannerNode) {\n        return CoreContext.Command.createNode({\n          parentId: bannerContainer?.id,\n          props: {\n            sourceType: 'Banner',\n            bannerId: id,\n          },\n        })\n      } else {\n        CoreContext.Command.updateNode({\n          nodeId: existingBannerNode.id,\n          props: {\n            sourceType: 'Banner',\n            bannerId: id,\n          },\n        })\n      }\n    },\n\n    getActiveBanner(): string | null {\n      return bannerContainer.children?.[0]?.props?.bannerId ?? null\n    },\n\n    async addChatOverlay(id: string, options: ChatOverlayProps) {\n      const [nodeTocheckForChildren, ...{}] =\n        bannerContainer?.children || ([] as SceneNode[])\n\n      /* Deleting the existing banner node if it exists. */\n      if (\n        nodeTocheckForChildren?.props?.sourceType?.toLowerCase() === 'banner'\n      ) {\n        await CoreContext.Command.deleteNode({\n          nodeId: nodeTocheckForChildren.id,\n        })\n      }\n\n      /* Destructuring an array. */\n      const [existingBannerNode, ...excessBannerNodes] =\n        bannerContainer?.children || ([] as SceneNode[])\n\n      // Delete all except one banner from the project\n      excessBannerNodes.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n\n      /* Creating a banner node if it doesn't exist, or updating it if it does. */\n      if (!existingBannerNode) {\n        await CoreContext.Command.createNode({\n          parentId: bannerContainer?.id,\n          props: {\n            sourceType: 'ChatOverlay',\n            chatOverlayId: id,\n            id,\n            ...options,\n          },\n        })\n      } else {\n        await CoreContext.Command.updateNode({\n          nodeId: existingBannerNode.id,\n          props: {\n            sourceType: 'ChatOverlay',\n            chatOverlayId: id,\n            id,\n            ...options,\n          },\n        })\n      }\n    },\n\n    async removeChatOverlay(id: string) {\n      // Remove dependent nodes from stream\n      bannerContainer?.children?.forEach(async (x) => {\n        if (x.props.chatOverlayId !== id) return\n        await CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n    },\n\n    getChatOverlay(): ChatOverlayProps | null {\n      /* Checking if the bannerContainer has a child and if that child has a chatOverlayId property. If it\n        does, it returns the child as an IChatOverlay. If it doesn't, it returns null.\n      */\n      return bannerContainer.children?.[0]?.props?.chatOverlayId\n        ? (bannerContainer.children?.[0]?.props as ChatOverlayProps) || null\n        : null\n    },\n\n    getCustomOverlay(): string | null {\n      const foregroundCustom = foregroundImageIframeContainer?.children?.find(\n        (x) => x?.props?.sourceProps?.type === 'custom',\n      )\n      return foregroundCustom?.props?.id\n    },\n\n    async addImageOverlay(id: string, props: OverlayProps): Promise<void> {\n      const [existingForegroundNode, ...excessForegroundNode] =\n        foregroundImageIframeContainer?.children || ([] as SceneNode[])\n      // Delete all except one banner from the project\n      excessForegroundNode.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n      const extendedDefaultStyles = {\n        ...defaultStyles['image'],\n        ...(foregroundVideoContainer?.children.length && { opacity: 0 }),\n      }\n      if (!existingForegroundNode) {\n        await CoreContext.Command.createNode({\n          parentId: foregroundImageIframeContainer?.id,\n          props: {\n            sourceType: 'Overlay',\n            id: id,\n            sourceProps: {\n              ...props,\n              type: 'image',\n              meta: {\n                style: { ...extendedDefaultStyles },\n              },\n            },\n          },\n        })\n      } else {\n        await CoreContext.Command.updateNode({\n          nodeId: existingForegroundNode?.id,\n          props: {\n            sourceType: 'Overlay',\n            id: id,\n            sourceProps: {\n              ...props,\n              type: 'image',\n              meta: {\n                style: { ...extendedDefaultStyles },\n              },\n            },\n          },\n        })\n      }\n    },\n\n    async addVideoOverlay(\n      id: string,\n      props: OverlayProps & HTMLVideoElementAttributes,\n    ): Promise<void> {\n      const [existingForegroundNode, ...excessForegroundNode] =\n        foregroundVideoContainer?.children || ([] as SceneNode[])\n      // Delete all except one banner from the project\n      excessForegroundNode.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n\n      // get all children of the overlay node and update their opacity attributes\n      foregroundImageIframeContainer.children.forEach(\n        ({ id, props: localProps }) => {\n          if (localProps.sourceProps.meta?.style?.opacity !== 0) {\n            const type = localProps.sourceProps\n              .type as keyof typeof defaultStyles\n            const extendedDefaultStyles = {\n              ...defaultStyles[type],\n              opacity: 0,\n            }\n            CoreContext.Command.updateNode({\n              nodeId: id,\n              props: {\n                ...localProps,\n                sourceProps: {\n                  ...localProps.sourceProps,\n                  meta: {\n                    style: { ...extendedDefaultStyles },\n                  },\n                },\n              },\n            })\n          }\n        },\n      )\n\n      if (!existingForegroundNode) {\n        await CoreContext.Command.createNode({\n          parentId: foregroundVideoContainer?.id,\n          props: {\n            sourceType: 'Overlay',\n            id: id,\n            sourceProps: {\n              ...props,\n              type: 'video',\n              meta: {\n                style: { ...defaultStyles['video'] },\n                ...props.meta,\n              },\n            },\n          },\n        })\n      } else {\n        await CoreContext.Command.updateNode({\n          nodeId: existingForegroundNode?.id,\n          props: {\n            sourceType: 'Overlay',\n            id: id,\n            sourceProps: {\n              ...props,\n              type: 'video',\n              meta: {\n                style: { ...defaultStyles['video'] },\n                ...props.meta,\n              },\n            },\n          },\n        })\n      }\n    },\n\n    async updateVideoOverlayProps(\n      id: string,\n      props: OverlayProps & HTMLVideoElementAttributes,\n    ): Promise<void> {\n      const existingForegroundNode =\n        foregroundVideoContainer?.children?.find((x) => x?.props?.id === id) ||\n        null\n      if (!existingForegroundNode) {\n        return\n      }\n      await CoreContext.Command.updateNode({\n        nodeId: existingForegroundNode?.id,\n        props: {\n          sourceType: 'Overlay',\n          id: id,\n          sourceProps: {\n            ...existingForegroundNode?.props?.sourceProps,\n            ...props,\n            meta: {\n              style: { ...defaultStyles['video'] },\n              ...props.meta,\n            },\n          },\n        },\n      })\n    },\n\n    async addCustomOverlay(id: string, props: OverlayProps): Promise<void> {\n      const [existingForegroundNode, ...excessForegroundNode] =\n        foregroundImageIframeContainer?.children || ([] as SceneNode[])\n      // Delete all except one banner from the project\n      excessForegroundNode.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n      const extendedDefaultStyles = {\n        ...defaultStyles['custom'],\n        ...(foregroundVideoContainer?.children.length && { opacity: 0 }),\n      }\n      if (!existingForegroundNode) {\n        await CoreContext.Command.createNode({\n          parentId: foregroundImageIframeContainer?.id,\n          props: {\n            sourceType: 'Overlay',\n            id: id,\n            sourceProps: {\n              ...props,\n              type: 'custom',\n              meta: {\n                style: { ...extendedDefaultStyles },\n              },\n            },\n          },\n        })\n      } else {\n        await CoreContext.Command.updateNode({\n          nodeId: existingForegroundNode?.id,\n          props: {\n            sourceType: 'Overlay',\n            id: id,\n            sourceProps: {\n              ...props,\n              type: 'custom',\n              meta: {\n                style: { ...extendedDefaultStyles },\n              },\n            },\n          },\n        })\n      }\n    },\n\n    async removeCustomOverlay(): Promise<void> {\n      // find overlay node by id\n      const [existingForegroundNode, ...excessForegroundNode] =\n        foregroundImageIframeContainer?.children || ([] as SceneNode[])\n      // if overlay exists, remove it\n      excessForegroundNode.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n      if (existingForegroundNode) {\n        if (existingForegroundNode?.props?.sourceProps?.type === 'custom') {\n          await CoreContext.Command.deleteNode({\n            nodeId: existingForegroundNode.id,\n          })\n        }\n      }\n    },\n\n    async removeImageOverlay(): Promise<void> {\n      // find overlay node by id\n      const [existingForegroundNode, ...excessForegroundNode] =\n        foregroundImageIframeContainer?.children || ([] as SceneNode[])\n      // if overlay exists, remove it\n      excessForegroundNode.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n      if (existingForegroundNode) {\n        if (existingForegroundNode?.props?.sourceProps?.type === 'image') {\n          await CoreContext.Command.deleteNode({\n            nodeId: existingForegroundNode.id,\n          })\n        }\n      }\n    },\n\n    async removeVideoOverlay(): Promise<void> {\n      // find overlay node by id\n      // find overlay node by id\n      const [existingForegroundNode, ...excessForegroundNode] =\n        foregroundVideoContainer?.children || ([] as SceneNode[])\n\n      // if overlay exists, remove it\n      excessForegroundNode.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n      if (existingForegroundNode) {\n        await CoreContext.Command.deleteNode({\n          nodeId: existingForegroundNode.id,\n        })\n      }\n\n      // get all children of the overlay node and update their opacity attributes\n      foregroundImageIframeContainer?.children.forEach(({ id, props }) => {\n        if (props.sourceProps.meta?.style?.opacity === 0) {\n          const type = props.sourceProps.type as keyof typeof defaultStyles\n          const extendedDefaultStyles = {\n            ...defaultStyles[type],\n            opacity: 1,\n          }\n          CoreContext.Command.updateNode({\n            nodeId: id,\n            props: {\n              ...props,\n              sourceProps: {\n                ...props.sourceProps,\n                meta: {\n                  style: { ...extendedDefaultStyles },\n                },\n              },\n            },\n          })\n        }\n      })\n    },\n\n    setLayout(layout: LayoutName, layoutProps: LayoutProps = {}) {\n      const showcase = content.props.layoutProps.showcase\n      Command.setNodeLayout({\n        nodeId: content.id,\n        layout,\n        layoutProps: {\n          showcase,\n          ...layoutProps,\n        },\n      })\n    },\n\n    async setBackgroundImage(\n      id: string,\n      props: BackgroundProps,\n    ): Promise<void> {\n      const [existingBackgroundNode, ...excessBackgroundNode] =\n        background?.children || ([] as SceneNode[])\n      // Delete all except one banner from the project\n      excessBackgroundNode.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n      if (!existingBackgroundNode) {\n        await CoreContext.Command.createNode({\n          parentId: background?.id,\n          props: {\n            id: id,\n            sourceType: 'Background',\n            sourceProps: {\n              ...props,\n              type: 'image',\n              meta: {\n                style: { ...defaultStyles['image'] },\n                ...props?.meta,\n              },\n            },\n          },\n        })\n      } else {\n        await CoreContext.Command.updateNode({\n          nodeId: existingBackgroundNode.id,\n          props: {\n            id: id,\n            sourceType: 'Background',\n            sourceProps: {\n              ...props,\n              type: 'image',\n              meta: {\n                style: { ...defaultStyles['image'] },\n                ...props?.meta,\n              },\n            },\n          },\n        })\n      }\n    },\n\n    async setBackgroundVideo(\n      id: string,\n      props: BackgroundProps & HTMLVideoElementAttributes,\n    ): Promise<void> {\n      const [existingBackgroundNode, ...excessBackgroundNode] =\n        background?.children || ([] as SceneNode[])\n      // Delete all except one banner from the project\n      excessBackgroundNode.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n      if (!existingBackgroundNode) {\n        await CoreContext.Command.createNode({\n          parentId: background?.id,\n          props: {\n            id: id,\n            sourceType: 'Background',\n            sourceProps: {\n              ...props,\n              type: 'video',\n              meta: {\n                style: { ...defaultStyles['video'] },\n                ...props?.meta,\n              },\n            },\n          },\n        })\n      } else {\n        await CoreContext.Command.updateNode({\n          nodeId: existingBackgroundNode.id,\n          props: {\n            id: id,\n            sourceType: 'Background',\n            sourceProps: {\n              ...props,\n              type: 'video',\n              meta: {\n                style: { ...defaultStyles['video'] },\n                ...props?.meta,\n              },\n            },\n          },\n        })\n      }\n    },\n\n    async updateBackgroundVideoProps(\n      id: string,\n      props: BackgroundProps & HTMLVideoElementAttributes,\n    ): Promise<void> {\n      const existingBackgroundNode =\n        background?.children?.find((x) => x?.props?.id === id) || null\n      if (!existingBackgroundNode) {\n        return\n      }\n      await CoreContext.Command.updateNode({\n        nodeId: existingBackgroundNode?.id,\n        props: {\n          sourceType: 'Background',\n          id: id,\n          sourceProps: {\n            ...existingBackgroundNode?.props?.sourceProps,\n            ...props,\n            meta: {\n              style: { ...defaultStyles['video'] },\n              ...props.meta,\n            },\n          },\n        },\n      })\n    },\n\n    async removeBackgroundImage(): Promise<void> {\n      // find overlay node by id\n      const [existingBackgroundNode, ...excessBackgroundNode] =\n        background?.children || ([] as SceneNode[])\n      // if overlay exists, remove it\n      excessBackgroundNode.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n      if (existingBackgroundNode) {\n        if (existingBackgroundNode.props.sourceProps.type === 'image') {\n          await CoreContext.Command.deleteNode({\n            nodeId: existingBackgroundNode.id,\n          })\n        }\n      }\n    },\n\n    async removeBackgroundVideo(): Promise<void> {\n      const [existingBackgroundNode, ...excessBackgroundNode] =\n        background?.children || ([] as SceneNode[])\n      // if overlay exists, remove it\n      excessBackgroundNode.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n      if (existingBackgroundNode) {\n        if (existingBackgroundNode.props.sourceProps.type === 'video') {\n          await CoreContext.Command.deleteNode({\n            nodeId: existingBackgroundNode.id,\n          })\n        }\n      }\n    },\n\n    /* A function that takes in a sourceType and a callback function. It then creates a shallow copy of\n      the root node and finds all the nodes that have the same sourceType as the one passed in. It then\n      creates a listener for when the node changes, is added, or is removed. When any of these events\n      happen, it will call the callback function with the new state. */\n    useLayerState<T>(sourceType: string, cb: (state: T) => void) {\n      const shallowRoot = cloneDeep(root)\n      let layerNode = findAll(\n        shallowRoot,\n        (x: SceneNode) => x.props.sourceType === sourceType,\n      ) as SceneNode[]\n\n      const sendState = () => {\n        cb((layerNode?.map((l) => l.props) || {}) as T)\n      }\n\n      // Watch for changes to the parent children\n      const layerChangeListener = CoreContext.onInternal(\n        'NodeChanged',\n        (payload) => {\n          const changedLayer = layerNode?.find((l) => l.id === payload.nodeId)\n          if (layerNode?.length && !changedLayer) return\n          const previousLayerNode = layerNode\n          const shallowRoot = cloneDeep(root)\n          layerNode = findAll(\n            shallowRoot,\n            (x: SceneNode) => x?.props?.sourceType === sourceType,\n          )\n          if (!deepEqual(previousLayerNode, layerNode)) {\n            sendState()\n          }\n        },\n      )\n\n      const layerAddListener = CoreContext.onInternal('NodeAdded', (payload) => {\n        const existingLayer = layerNode?.find((l) => l.id === payload.nodeId)\n        if (existingLayer) return\n        const shallowRoot = cloneDeep(root)\n        layerNode = findAll(\n          shallowRoot,\n          (x: SceneNode) => x?.props?.sourceType === sourceType,\n        )\n        const addedLayer = layerNode?.find((l) => l.id === payload.nodeId)\n        if (addedLayer?.props?.sourceType === sourceType) {\n          sendState()\n        }\n      })\n\n      const layerRemoveListener = CoreContext.onInternal(\n        'NodeRemoved',\n        (payload) => {\n          const removedLayer = layerNode?.find((l) => l.id === payload.nodeId)\n          if (!removedLayer) return\n          layerNode = layerNode?.filter((l) => l.id !== payload.nodeId)\n          if (removedLayer?.props?.sourceType === sourceType) {\n            sendState()\n          }\n        },\n      )\n\n      sendState()\n\n      // Return disposable for listener\n      return () => {\n        layerChangeListener()\n        layerAddListener()\n        layerRemoveListener()\n      }\n    },\n    setShowcase(participantId: string, type: ParticipantType = 'camera') {\n      const node = commands.getParticipantNode(participantId, type)\n      return CoreContext.Command.updateNode({\n        nodeId: content.id,\n        props: {\n          layoutProps: {\n            ...content.props.layoutProps,\n            showcase: node?.id ?? null,\n          },\n        },\n      })\n    },\n    useShowcase(\n      cb: (state: { participantId: string; type: ParticipantType }) => void,\n    ) {\n      const sendState = () => {\n        const nodeId = content.props.layoutProps.showcase\n        const node = content.children.find((x) => x.id === nodeId)\n        if (!node)\n          return cb({\n            participantId: null,\n            type: null,\n          })\n\n        const { sourceProps } = node.props\n        return cb({\n          participantId: sourceProps.id,\n          type: sourceProps.type,\n        })\n      }\n      sendState()\n\n      // Watch for changes to the parent children\n      return CoreContext.onInternal('NodeChanged', (payload) => {\n        if (payload.nodeId !== content.id) return\n        sendState()\n      })\n    },\n\n    async addRTMPSource(\n      id: string,\n      props: Partial<ParticipantProps> = {\n        isMuted: true,\n        isHidden: false,\n        volume: 0,\n      },\n    ) {\n      const type = 'rtmp'\n      if (addingCache[type].has(id)) {\n        return\n      }\n      const { isMuted = false, isHidden = false, volume = 1 } = props\n      const existing = content.children.find(\n        (x) =>\n          x.props.sourceProps?.id === id &&\n          x.props.sourceProps?.type === type,\n      )\n      if (existing) return\n\n      addingCache[type].add(id)\n      // Get the participant type in the first position\n      const currentFirst = content.children[0]\n      let index = content.children.length\n\n      await CoreContext.Command.createNode({\n        props: {\n          name: 'RTMP',\n          sourceType: 'RTMP',\n          sourceProps: {\n            type,\n            id,\n          },\n          volume,\n          isMuted,\n          isHidden,\n        },\n        parentId: content.id,\n        index,\n      }).finally(() => {\n        addingCache[type].delete(id)\n      })\n    },\n\n    removeRTMPSource(\n      id: string,\n    ) {\n      const type = 'rtmp'\n      content.children\n        .filter(\n          (x) =>\n            x.props.sourceProps?.id === id &&\n            x.props.sourceProps?.type === type &&\n            x.props.sourceType === 'RTMPSource',\n        )\n        .forEach((x) => {\n          CoreContext.Command.deleteNode({\n            nodeId: x.id,\n          })\n        })\n    },\n\n    async addParticipantTrack(\n      trackId: string,\n      props: Partial<ParticipantProps> = {\n        isMuted: true,\n        isHidden: false,\n        volume: 0,\n      },\n      type: ParticipantType = 'camera',\n    ) {\n      if (addingCache[type].has(trackId)) return\n\n      const { isMuted = false, isHidden = false, volume = 1 } = props\n      const existing = content.children.find(\n        (x) =>\n          x.props.sourceProps?.id === trackId &&\n          x.props.sourceProps?.type === type,\n      )\n      if (existing) return\n\n      addingCache[type].add(trackId)\n      // Get the participant type in the first position\n      const currentFirst = content.children[0]\n      let index = content.children.length\n\n      // If we're adding a screen and the first position is not already\n      //  a screen, then we add it in the first position.\n      if (\n        type === 'screen' &&\n        currentFirst?.props.sourceProps.type !== 'screen'\n      ) {\n        index = 0\n      }\n      await CoreContext.Command.createNode({\n        props: {\n          name: 'Participant',\n          sourceType: 'RoomParticipant',\n          sourceProps: {\n            type,\n            id: trackId,\n          },\n          volume,\n          isMuted,\n          isHidden,\n        },\n        parentId: content.id,\n        index,\n      }).finally(() => {\n        addingCache[type].delete(trackId)\n      })\n    },\n\n    removeParticipantTrack(trackId: string, type: ParticipantType = 'camera') {\n      content.children\n        .filter(\n          (x) =>\n            x.props.sourceProps?.id === trackId &&\n            x.props.sourceProps?.type === type &&\n            x.props.sourceType === 'RoomParticipant',\n        )\n        .forEach((x) => {\n          CoreContext.Command.deleteNode({\n            nodeId: x.id,\n          })\n        })\n    },\n\n    async addParticipant(\n      participantId: string,\n      props: Partial<ParticipantProps> = {},\n      type: ParticipantType = 'camera',\n    ) {\n      if (addingCache[type].has(participantId)) return\n\n      const { isMuted = false, isHidden = false, volume = 1 } = props\n      const existing = content.children.find(\n        (x) =>\n          x.props.sourceProps?.id === participantId &&\n          x.props.sourceProps?.type === type,\n      )\n      if (existing) return\n\n      addingCache[type].add(participantId)\n      // Get the participant type in the first position\n      const currentFirst = content.children[0]\n      let index = content.children.length\n\n      // If we're adding a screen and the first position is not already\n      //  a screen, then we add it in the first position.\n      if (\n        type === 'screen' &&\n        currentFirst?.props.sourceProps.type !== 'screen'\n      ) {\n        index = 0\n      }\n      await CoreContext.Command.createNode({\n        props: {\n          name: 'Participant',\n          sourceType: 'RoomParticipant',\n          sourceProps: {\n            type,\n            id: participantId,\n          },\n          volume,\n          isMuted,\n          isHidden,\n        },\n        parentId: content.id,\n        index,\n      }).finally(() => {\n        addingCache[type].delete(participantId)\n      })\n    },\n    addParticipantScreenshare(\n      participantId: string,\n      props: Partial<ParticipantProps> = {},\n    ) {\n      return commands.addParticipant(participantId, props, 'screen')\n    },\n    removeParticipant(participantId: string, type: ParticipantType = 'camera') {\n      content.children\n        .filter(\n          (x) =>\n            x.props.sourceProps?.id === participantId &&\n            x.props.sourceProps?.type === type &&\n            x.props.sourceType === 'RoomParticipant',\n        )\n        .forEach((x) => {\n          CoreContext.Command.deleteNode({\n            nodeId: x.id,\n          })\n        })\n    },\n    removeParticipantScreenshare(participantId: string) {\n      return commands.removeParticipant(participantId, 'screen')\n    },\n    getParticipantNode(id: string, type: ParticipantType = 'camera') {\n      return content.children.find(\n        (x) =>\n          x.props.sourceProps?.id === id && x.props.sourceProps?.type === type,\n      )\n    },\n    getParticipantState(\n      participantId: string,\n      type: ParticipantType = 'camera',\n    ) {\n      return commands.getParticipantNode(participantId, type)\n        ?.props as ParticipantProps\n    },\n\n    useParticipantState(\n      participantId: string,\n      cb: (state: ParticipantProps) => void,\n      type = 'camera' as ParticipantType,\n    ) {\n      let participantNode = commands.getParticipantNode(participantId, type)\n\n      const sendState = () => {\n        cb(participantNode?.props as ParticipantProps)\n      }\n\n      // Watch for changes to the parent children\n      const childListener = CoreContext.onInternal('NodeChanged', (payload) => {\n        if (payload.nodeId !== content.id) return\n        const previous = participantNode\n        participantNode = commands.getParticipantNode(participantId, type)\n        if (previous !== participantNode) {\n          sendState()\n        }\n      })\n\n      // Watch for changes to the participant node\n      const participantListener = CoreContext.onInternal(\n        'NodeChanged',\n        (payload) => {\n          if (!participantNode || payload.nodeId !== participantNode.id) return\n          sendState()\n        },\n      )\n\n      sendState()\n\n      // Return disposable for listener\n      return () => {\n        childListener()\n        participantListener()\n      }\n    },\n\n    setParticipantVolume(participantId: string, volume: number) {\n      const node = commands.getParticipantNode(participantId)\n      if (!node) return\n      CoreContext.Command.updateNode({\n        nodeId: node.id,\n        props: {\n          volume,\n        },\n      })\n    },\n    setParticipantMuted(participantId: string, isMuted: boolean) {\n      const node = commands.getParticipantNode(participantId)\n      if (!node) return\n      CoreContext.Command.updateNode({\n        nodeId: node.id,\n        props: {\n          isMuted,\n        },\n      })\n    },\n    setParticipantHidden(participantId: string, isHidden: boolean) {\n      const node = commands.getParticipantNode(participantId)\n      if (!node) return\n      CoreContext.Command.updateNode({\n        nodeId: node.id,\n        props: {\n          isHidden,\n        },\n      })\n    },\n    pruneParticipants() {\n      // Remove all participant nodes that do not have active tracks\n      const room = getProjectRoom(projectId)\n      if (!room) return\n\n      content.children\n        .filter((node) => {\n          if (node.props.sourceType !== 'RoomParticipant') return false\n          const nodeSourceType = node.props.sourceProps?.type\n\n          // Get the participant associated with the node\n          const nodeParticipant = room.getParticipant(\n            node.props.sourceProps?.id,\n          )\n\n          // Get the participant track associated with the node\n          const nodeParticipantTrack = room.getTrack(node.props.sourceProps?.id)\n\n          // If the participant is not in the room, remove the node\n          if (!nodeParticipant && !nodeParticipantTrack) return true\n\n          // Keep \"camera\" nodes around as long as the participant is available.\n          //  This is to facilitate camera switching or other such feed interruptions\n          if (nodeSourceType === 'camera') return false\n\n          // Get all tracks associated with the node's participant\n          const participantTracks = nodeParticipant.trackIds\n            .map((x) => room.getTrack(x))\n            .filter(Boolean)\n\n          // Determine whether there is a track available to the node\n          const hasAvailableTrack = participantTracks.some((track) => {\n            // Get the source type as it corresponds to the track's type\n            const sourceType =\n              track.type === Track.Source.Camera ||\n              track.type === Track.Source.Microphone\n                ? 'camera'\n                : 'screen'\n\n            // Return true if the node source has a matching track\n            return sourceType === nodeSourceType\n          })\n\n          return !hasAvailableTrack\n        })\n        .forEach((x) => {\n          CoreContext.Command.deleteNode({\n            nodeId: x.id,\n          })\n        })\n    },\n    getProp(prop) {\n      return getProject(_project.id).props[prop]\n    },\n    setProp(prop, val) {\n      return Command.updateProjectProps({\n        projectId,\n        props: {\n          [prop]: val,\n        },\n      })\n    },\n    useProp(prop, cb) {\n      return CoreContext.on('ProjectChanged', (payload) => {\n        if (projectId === payload.project.id) {\n          cb(payload.project.props[prop])\n        }\n      })\n    },\n    createSource(payload) {\n      return CoreContext.Command.createSource(payload)\n    },\n    deleteSource(payload) {\n      return CoreContext.Command.deleteSource(payload)\n    },\n  }\n  const ensureValid = async () => {\n    await ensureRootLayersProps()\n    await ensureBackgroundChildLayersProps()\n    await ensureForegroundContainers()\n  }\n\n  ensureValid()\n\n  return commands\n}\n\nexport type LayoutProps = {\n  cover?: boolean\n  /** Valid CSS for justify-content */\n  justifyViewers?: 'flex-end' | 'center' | 'flex-start'\n  /** Percentage */\n  barWidth?: number\n  barPosition?: 'bottom' | 'side'\n  useGrid?: boolean\n  reverse?: boolean\n}\ntype ScenelessSettings = {\n  backgroundImage?: string\n  layout?: string\n  layoutProps?: LayoutProps\n}\n\n/**\n * **An abstraction over {@link Command.createProject Command.createProject()}.**\n *\n * A Project created using this function will be compatible with {@link ScenelessProject.commands ScenelessProject.commands()}\n *\n * **Emits: ProjectAdded**\n */\nexport const create = async (\n  settings: ScenelessSettings = {},\n  props: SDK.Props = {},\n  size?: { x: number; y: number },\n) => {\n  return CoreContext.Command.createProject({\n    settings,\n    props,\n    size,\n  }) as Promise<ScenelessProject>\n}\n\n/** @private */\nexport const createCompositor = async (\n  layoutId: string,\n  size: { x: number; y: number },\n  settings: ScenelessSettings,\n) => {\n  const { layout, layoutProps = {} } = settings\n\n  // TODO: Batch insert\n  const project = await CoreContext.compositor.createProject(\n    {\n      props: {\n        name: 'Root',\n        type: 'sceneless-project',\n        sourceType: 'Element',\n        layout: 'Layered',\n        size,\n        isRoot: true,\n        tagName: 'div',\n        version: 'beta',\n        fields: {\n          style: { background: 'black' },\n        },\n      },\n    },\n    layoutId,\n  )\n  const root = project.getRoot()\n\n  // Create the base nodes for sceneless workflow\n  const baseLayers = await Promise.all([\n    project.insert(\n      {\n        name: 'Background',\n        id: 'bg',\n        layout: 'Layered',\n      },\n      root.id,\n    ),\n\n    project.insert(\n      {\n        id: 'content',\n        name: 'Content',\n        layout,\n        layoutProps,\n      },\n      root.id,\n    ),\n    project.insert(\n      {\n        id: 'foreground',\n        name: 'Overlays',\n        layout: 'Layered',\n      },\n      root.id,\n    ),\n  ])\n\n  await project.reorder(root.id, baseLayers)\n\n  const foreground = root.children.find((x) => x.props.id === 'foreground')\n  const foregroundLayerPromises = ForegroundLayers.map((layer) =>\n    project.insert(layer, foreground.id),\n  )\n  const baseForegroundLayers = await Promise.all(foregroundLayerPromises)\n  await project.reorder(foreground.id, baseForegroundLayers)\n\n  return project\n}\n","/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\n/**\n * Requests provide single-concern abstractions\n *  over the various backend APIs (Layout/Live).\n *\n * Not every external request is represented here. In some cases\n *  it is simpler to use the API SDK client interface directly.\n */\nimport {\n  CoreContext,\n  InternalProject,\n  InternalSource,\n  InternalUser,\n} from './context'\nimport { getAccessTokenData, getProject, getUser, hydrateProject } from './data'\nimport { Helpers } from '.'\nimport { Props, Role } from './types'\nimport { LiveApiModel } from '@api.stream/sdk'\n\nexport const createProject = async (request: {\n  settings?: { [prop: string]: any }\n  props?: Props // Arbitrary metadata (e.g. 'name')\n  size?: { x: number; y: number }\n  type?: 'sceneless' | 'freeform'\n}) => {\n  const collectionId = getUser().id\n  const type = request.type || 'sceneless'\n  const size = request.size || {\n    x: 1280,\n    y: 720,\n  }\n  const settings = request.settings || {}\n\n  // Create a project to go with the collection\n  let createProjectResponse = await CoreContext.clients\n    .LiveApi()\n    .project.createProject({\n      collectionId,\n      rendering: {\n        video: {\n          width: size.x,\n          height: size.y,\n          framerate: 30,\n        },\n      },\n      composition: {\n        studioSdk: { version: CoreContext.rendererVersion },\n      },\n      metadata: {},\n      webrtc: {\n        hosted: {},\n      },\n    })\n\n  const layout = await createLayout({\n    projectId: createProjectResponse.project.projectId,\n    collectionId: createProjectResponse.project.collectionId,\n    settings,\n    size,\n    type,\n  })\n\n  const { displayName } = getAccessTokenData()\n\n  // Save the layoutId on the project (no need to await)\n  const metadata = {\n    type,\n    layoutId: layout.id,\n    hostDisplayName: displayName,\n    props: request.props || {},\n  }\n  let projectResponse = await CoreContext.clients\n    .LiveApi()\n    .project.updateProject({\n      collectionId,\n      projectId: createProjectResponse.project.projectId,\n      updateMask: ['metadata'],\n      metadata,\n    })\n  createProjectResponse.project = projectResponse.project\n  createProjectResponse.project.metadata = metadata\n\n  return createProjectResponse\n}\n\nexport const deleteProject = async (request: { projectId: string }) => {\n  const { projectId } = request\n  const project = getProject(projectId)\n  const collectionId = getUser().id\n\n  await Promise.all([\n    CoreContext.clients.LiveApi().project.deleteProject({\n      collectionId,\n      projectId,\n    }),\n    CoreContext.clients.LayoutApi().layout.deleteLayout({\n      layoutId: project.layoutApi.layoutId,\n    }),\n  ])\n}\n\n/**\n * Load the user data from whatever access token has been registered\n *  with the API.\n */\nexport const loadUser = async (size?: {\n  x: number\n  y: number\n}): Promise<{\n  user: InternalUser\n  projects: InternalProject[]\n  sources: InternalSource[]\n}> => {\n  const collections = await loadCollections()\n\n  let collection: LiveApiModel.Collection\n\n  const { displayName, serviceUserId } = getAccessTokenData()\n\n  // Get a single collection, corresponding to a user\n  if (collections.length === 0) {\n    // If the user has no collections, create one\n    const response = await CoreContext.clients\n      .LiveApi()\n      .collection.createCollection({\n        metadata: {\n          serviceUserId,\n          displayName,\n          props: {},\n        },\n      })\n    collection = response.collection\n  } else {\n    // only 1 collection per user for studio-kit\n    collection = collections[0]\n  }\n\n  await CoreContext.clients\n    .LiveApi()\n    .subscribeToCollection(collection.collectionId)\n\n  // Take the Vapi Project and hydrate it with Compositor and Lapi project details\n  const projects = await Promise.all(\n    collection.projects.filter((p) => Boolean(p.metadata?.layoutId)).map((project) =>\n      hydrateProject(project, 'ROLE_HOST' as Role, size),\n    ),\n  )\n\n  return {\n    user: {\n      id: collection.collectionId,\n      metadata: collection.metadata,\n      props: collection.metadata?.props || {},\n      name: displayName,\n    },\n    projects,\n    sources: collection.sources,\n  }\n}\n\nexport const loadCollections = async () => {\n  let result = await CoreContext.clients.LiveApi().collection.getCollections({})\n  return result.collections\n}\n\nexport const createLayout = async (request: {\n  projectId: string\n  collectionId: string\n  settings: { [prop: string]: any }\n  size: { x: number; y: number }\n  type?: string\n}) => {\n  const { settings, size, type, projectId, collectionId } = request\n\n  const layout = await CoreContext.clients.LayoutApi().layout.createLayout({\n    layout: {\n      projectId,\n      collectionId,\n    },\n  })\n\n  if (type === 'sceneless') {\n    await Helpers.ScenelessProject.createCompositor(layout.id, size, settings)\n  } else {\n    await CoreContext.compositor.createProject(\n      {\n        props: {\n          name: 'Root',\n          layout: 'Free',\n          ...settings,\n          isRoot: true,\n          size,\n        },\n      },\n      layout.id,\n    )\n  }\n\n  return layout\n}\n"],"names":["ForegroundLayers","name","id","layout","layoutProps","cover","createCompositor","layoutId","size","settings","project","CoreContext","compositor","createProject","props","type","sourceType","isRoot","tagName","version","fields","style","background","root","getRoot","baseLayers","Promise","all","insert","reorder","foreground","children","find","x","foregroundLayerPromises","map","layer","baseForegroundLayers","request","collectionId","getUser","y","createProjectResponse","clients","LiveApi","rendering","video","width","height","framerate","composition","studioSdk","rendererVersion","metadata","webrtc","hosted","createLayout","projectId","displayName","getAccessTokenData","hostDisplayName","projectResponse","updateProject","updateMask","deleteProject","getProject","LayoutApi","deleteLayout","layoutApi","loadUser","collections","loadCollections","collection","serviceUserId","length","response","createCollection","subscribeToCollection","projects","filter","p","Boolean","hydrateProject","user","sources","result","getCollections","Helpers"],"mappings":"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"}