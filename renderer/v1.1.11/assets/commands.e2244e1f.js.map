{"version":3,"file":"commands.e2244e1f.js","sources":["../../../../src/core/commands.ts"],"sourcesContent":["/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\n/**\n * Commands represent actions that can be taken by a user.\n *\n * Most commands accept a contextual parameter `projectId`.\n * If this parameter is excluded from a function call, the user's\n * active project will be used instead.\n *\n * Upon completion, a command may emit zero or more {@link EventMap Events}. Commands\n * return Promises that will attempt to resolve to the most pertinent value.\n * However, it is good practice to instead rely on events where possible, when\n * updating application state.\n *\n * For example, listening for the event `BroadcastStarted` will indicate\n * the following scenarios:\n *\n *   - The current user has initiated a broadcast\n *   - A collaborator (or host) has initiated a broadcast\n *   - Some external force has initiated a broadcast\n *\n * When depending on the Event rather than the command's return value, we can\n * be sure that our state is updating under all relevant circumstances.\n *\n * ----\n *\n * _Note: Commands marked `internal` are low-level commands that should only be\n * used with caution. Higher-level abstractions should be used to manipulate Nodes\n * (elements on the stream canvas)._\n *\n * @private This module is currently hidden from users of the Studio Kit.\n *  Favor the creation of helpers when supporting developers who require\n *  functionality contained in this module.\n *\n * @module Commands\n */\n\nimport {\n  getProject,\n  getUser,\n  hydrateProject,\n  toBaseDestination,\n  toBaseProject,\n} from './data'\nimport { CoreContext } from './context'\nimport decode from 'jwt-decode'\nimport { Props } from './types'\nimport { SDK } from './namespaces'\nimport { webrtcManager } from './webrtc'\nimport { getRoom } from './webrtc/simple-room'\nimport { trigger, triggerInternal } from './events'\n\nconst { state } = CoreContext\n\n/**\n * Update the current user's metadata with custom data opaque to the SDK.\n * Existing props are not affected unless explicitly overwritten.\n *\n * @category User\n */\nexport const updateUserProps = async (payload: {\n  /** Arbitrary metadata to associate with the user */\n  props?: Props\n}) => {\n  const collection = getUser()\n  if (!collection) return\n\n  const props = {\n    ...collection.props,\n    ...payload.props,\n  }\n  const response = await CoreContext.clients\n    .LiveApi()\n    .collection.updateCollection({\n      collectionId: collection.id,\n      updateMask: ['metadata'],\n      metadata: {\n        ...collection.metadata,\n        props,\n      },\n    })\n\n  // Trigger event to update state\n  await triggerInternal('UserChanged', response.collection)\n  return\n}\n\n/**\n * Create a project with optional metadata.\n *\n * ----\n * _Note: This is a low level function that necessitates careful management\n *  of the nodes within. Consider {@link ScenelessProject.create} instead._\n *\n * @category Project\n */\nexport const createProject = async (\n  payload: {\n    /** @private Settings associated with ScenelessProject (or other such wrapper) */\n    settings?: { [prop: string]: any }\n    /** Arbitrary metadata to associate with this project */\n    props?: Props\n    /** Pixel dimenions of the canvas (default: `{ x: 1280, y: 720 }`) */\n    size?: { x: number; y: number }\n  } = {},\n) => {\n  const { props = {}, size, settings = {} } = payload\n  const response = await CoreContext.Request.createProject({\n    settings,\n    props,\n    size,\n  })\n\n  // Trigger event to update state\n  await triggerInternal('ProjectAdded', response.project)\n\n  // Return the base project directly, for convenience\n  const internalProject = await hydrateProject(response.project, 'ROLE_HOST' as SDK.Role)\n  return toBaseProject(internalProject)\n}\n\n/**\n * Delete a project.\n *\n * @category Project\n */\nexport const deleteProject = async (payload: {\n  projectId: SDK.Project['id']\n}) => {\n  const { projectId } = payload\n  await CoreContext.Request.deleteProject({\n    projectId,\n  })\n\n  // Trigger event to update state\n  await triggerInternal('ProjectRemoved', { projectId })\n  return\n}\n\n/**\n * Update a project's metadata with custom data opaque to the SDK.\n * Existing props are not affected unless explicitly overwritten.\n *\n * @category Project\n */\nexport const updateProjectProps = async (payload: {\n  projectId: SDK.Project['id']\n  /** Arbitrary metadata to associate with this project */\n  props?: Props\n}) => {\n  const { projectId } = payload\n  const collectionId = getUser().id\n  const project = getProject(projectId)\n\n  const props = {\n    ...project.props,\n    ...payload.props,\n  }\n  const response = await CoreContext.clients.LiveApi().project.updateProject({\n    collectionId,\n    projectId,\n    updateMask: ['metadata'],\n    metadata: {\n      ...project.videoApi.project.metadata,\n      props,\n    },\n  })\n\n  // Trigger event to update state\n  await triggerInternal('ProjectChanged', { project: response.project })\n  return\n}\n/**\n * @deprecated Use updateProjectProps\n */\nexport const updateProjectMeta = (payload: {\n  projectId: SDK.Project['id']\n  /** Arbitrary metadata to associate with this project */\n  meta?: Props\n}) => updateProjectProps({ projectId: payload.projectId, props: payload.meta })\n\n/**\n * Set the active project for the user, setting up event handlers and\n *  disposing of event listeners for the previous active project.\n *\n * This project will be used as the default project\n *  for commands that do not specify `payload.projectId`\n *\n * @category Project\n */\nexport const setActiveProject = async (payload: {\n  projectId: SDK.Project['id']\n}): Promise<SDK.Project> => {\n  const project = state.projects.find((x) => x.id === payload.projectId)\n  if (!project) {\n    state.activeProjectId = null\n    triggerInternal('ActiveProjectChanged', { projectId: null })\n    return\n  }\n\n  const currentProject = state.projects.find(\n    (x) => x.id === state.activeProjectId,\n  )\n  if (project === currentProject) return\n  if (currentProject) {\n    // Perform any necessary cleanup\n    Array.from(webrtcManager.rooms.keys()).map(webrtcManager.removeRoom)\n    await CoreContext.clients\n      .LayoutApi()\n      .unsubscribeFromLayout(currentProject.layoutApi.layoutId)\n    await CoreContext.clients\n      .LiveApi()\n      .unsubscribeFromProject(\n        currentProject.videoApi.project.collectionId,\n        currentProject.videoApi.project.projectId,\n      )\n  }\n\n  await CoreContext.clients\n    .LayoutApi()\n    .subscribeToLayout(project.layoutApi.layoutId)\n  await CoreContext.clients\n    .LiveApi()\n    .subscribeToProject(\n      project.videoApi.project.collectionId,\n      project.videoApi.project.projectId,\n    )\n\n  // Asynchronously ensure latest project state\n  CoreContext.clients\n    .LiveApi()\n    .project.getProject({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      status: true,\n    })\n    .then((response) => {\n      triggerInternal('ProjectChanged', {\n        project: response.project,\n        phase: response.status?.phase,\n      })\n    })\n\n  triggerInternal('ActiveProjectChanged', {\n    projectId: project.id,\n  })\n  return toBaseProject(project)\n}\n\n/**\n * Initiate WebRTC connection to the room associated with this project.\n *\n * @category Project\n */\nexport const joinRoom = async (payload: {\n  projectId: SDK.Project['id']\n  /** A public name for other guests will see associated with your {@link Participant} */\n  displayName?: string\n}) => {\n  const { projectId, displayName = 'Guest' } = payload\n  const project = state.projects.find((x) => x.id === projectId)\n\n  // Get the SFU token\n  let token = project.sfuToken\n  if (!token) {\n    let { webrtcAccess } = await CoreContext.clients\n      .LiveApi()\n      .authentication.createWebRtcAccessToken({\n        collectionId: project.videoApi.project.collectionId,\n        projectId: project.videoApi.project.projectId,\n        displayName,\n      })\n    token = webrtcAccess.accessToken\n  }\n  const tokenData = decode(token) as any\n  const roomName = tokenData.video.room\n  const url = new URL(CoreContext.clients.getLiveKitServer())\n  const baseUrl = url.host + url.pathname\n  const roomContext = webrtcManager.ensureRoom(baseUrl, roomName, token)\n  roomContext.bindApiClient(CoreContext.clients)\n  await roomContext.connect()\n\n  project.sfuToken = token\n  project.roomId = roomName\n  const room = getRoom(roomName)\n  trigger('RoomJoined', {\n    projectId: project.id,\n    room,\n  })\n  return room\n}\n\n/**\n * Create a node within the project's scene tree.\n * A node is functionally comparable to a DOM Node - it serves only as a vessel\n * of properties.\n *\n * A node is not inherently useful. It is up to the renderer to interpret the data it holds.\n * If a node is given data the renderer is not aware of, it will accomplish nothing.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const createNode = async (payload: {\n  projectId?: string\n  props?: { [prop: string]: any }\n  parentId: string\n  index?: number\n}) => {\n  let {\n    props = {},\n    parentId,\n    index,\n    projectId = state.activeProjectId,\n  } = payload\n  const project = getProject(projectId)\n  props = { ...props, layoutId: project.layoutApi.layoutId, type: 'child' }\n\n  // Update state\n  const nodeId = await project.compositor.insert(props, parentId, index)\n  triggerInternal('NodeAdded', { projectId, nodeId })\n  triggerInternal('NodeChanged', { projectId, nodeId: parentId })\n  return project.compositor.get(nodeId)\n}\n\n/**\n * Remove a node from the project's scene tree.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const deleteNode = async (payload: {\n  projectId?: string\n  nodeId: string\n}) => {\n  let { nodeId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  const parentId = project.compositor.getParent(nodeId)?.id\n\n  // Update state\n  project.compositor.remove(nodeId)\n  triggerInternal('NodeRemoved', { projectId, nodeId })\n  triggerInternal('NodeChanged', { projectId, nodeId: parentId })\n}\n\n/**\n * Update the properties of a node.\n * `payload.props` will be shallowly merged onto its existing `props`.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const updateNode = async (payload: {\n  projectId?: string\n  nodeId: string\n  props: { [prop: string]: any }\n}) => {\n  let { nodeId, props = {}, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  // Prune protected fields\n  delete props.type\n  delete props.sourceType\n\n  // Update state\n  project.compositor.update(nodeId, props)\n  triggerInternal('NodeChanged', { projectId, nodeId })\n  return project.compositor.get(nodeId)\n}\n\n/**\n * Update the layout of a node.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const setNodeLayout = async (payload: {\n  projectId?: string\n  nodeId: string\n  layout: string\n  layoutProps?: { [prop: string]: any }\n}) => {\n  let {\n    nodeId,\n    layout,\n    projectId = state.activeProjectId,\n    layoutProps = {},\n  } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  project.compositor.update(nodeId, {\n    layout,\n    layoutProps,\n  })\n  triggerInternal('NodeChanged', { projectId, nodeId })\n}\n\n/**\n * Move a node to a different parent node.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const moveNode = async (payload: {\n  projectId?: string\n  nodeId: string\n  parentId: string\n  index?: number\n}) => {\n  const { nodeId, parentId, projectId = state.activeProjectId, index } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  project.compositor.move(nodeId, parentId, index)\n  // TODO: Determine if this is necessary (likely need only the events from Event API)\n  triggerInternal('NodeChanged', { projectId, nodeId })\n}\n\n/**\n * Swap the positions of two nodes, changing parents if necessary.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const swapNodes = async (payload: {\n  projectId?: string\n  nodeAId: string\n  nodeBId: string\n}) => {\n  const { nodeAId, nodeBId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  const parentAId = project.compositor.getParent(nodeAId)?.id\n  const parentBId = project.compositor.getParent(nodeBId)?.id\n\n  // Update state\n  project.compositor.swap(nodeAId, nodeBId)\n  triggerInternal('NodeChanged', { projectId, nodeId: parentAId })\n  triggerInternal('NodeChanged', { projectId, nodeId: parentBId })\n}\n\n/**\n * Change the order of a node's children.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const reorderNodes = async (payload: {\n  projectId?: string\n  parentId: string\n  childIds: string[]\n}) => {\n  const { parentId, childIds, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  project.compositor.reorder(parentId, childIds)\n  triggerInternal('NodeChanged', { projectId, nodeId: parentId })\n}\n\n/**\n * Start broadcasting a project.\n *\n * ----\n * _Note: Destination, encoding, and rendering details will be read from the Project\n * at time of broadcast, so they should be updated ahead of time._\n *\n * @category Broadcast\n */\nexport const startBroadcast = async (payload: { projectId?: string }) => {\n  const { projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  await CoreContext.clients.LiveApi().project.startProjectBroadcast({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n  })\n  // Event is handled on receiving end of VideoAPI\n}\n\n/**\n * Stop broadcasting a project.\n *\n * @category Broadcast\n */\nexport const stopBroadcast = async (payload: { projectId?: string }) => {\n  const { projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  await CoreContext.clients.LiveApi().project.stopProjectBroadcast({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n  })\n  // Event is handled on receiving end of VideoAPI\n}\n\n/**\n * Add a {@link Destination} to a project.\n *\n * @category Destination\n */\nexport const addDestination = async (payload: {\n  projectId?: string\n  rtmpUrl: string\n  rtmpKey: string\n  enabled: boolean\n  props?: Props\n  /** @deprecated Use `props` */\n  metadata?: Props\n}) => {\n  const {\n    rtmpUrl,\n    rtmpKey,\n    enabled,\n    projectId = state.activeProjectId,\n    metadata = {},\n    props = {},\n  } = payload\n  const project = getProject(projectId)\n  const address = {\n    rtmpPush: {\n      key: rtmpKey,\n      url: rtmpUrl,\n    },\n  } as SDK.Destination['address']\n\n  const response = await CoreContext.clients\n    .LiveApi()\n    .destination?.createDestination({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      address,\n      enabled,\n      metadata: {\n        props: {\n          ...metadata,\n          ...props,\n        },\n      },\n    })\n\n  // Trigger event to update state\n  await triggerInternal('DestinationAdded', response.destination)\n  return toBaseDestination(response.destination)\n}\n\n/**\n * Remove a {@link Destination} from the project.\n *\n * @category Destination\n */\nexport const removeDestination = async (payload: {\n  projectId?: string\n  destinationId: string\n}) => {\n  const { destinationId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  await CoreContext.clients.LiveApi().destination?.deleteDestination({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n    destinationId,\n  })\n\n  // Trigger event to update state\n  await triggerInternal('DestinationRemoved', { projectId, destinationId })\n  return\n}\n\n/**\n * Update an existing {@link Destination} on the project.\n *\n * @category Destination\n */\nexport const updateDestination = async (payload: {\n  projectId?: string\n  destinationId: string\n  rtmpUrl: string\n  rtmpKey: string\n}) => {\n  const {\n    rtmpUrl,\n    rtmpKey,\n    destinationId,\n    projectId = state.activeProjectId,\n  } = payload\n  const project = getProject(projectId)\n\n  const rtmpPush = {\n    key: rtmpKey,\n    url: rtmpUrl,\n  }\n\n  const response = await CoreContext.clients\n    .LiveApi()\n    .destination?.updateDestination({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      destinationId,\n      updateMask: ['address.rtmpPush'],\n      address: {\n        rtmpPush,\n      },\n    })\n\n  // Trigger event to update state\n  await triggerInternal('DestinationChanged', response.destination)\n  return\n}\n\n/**\n * Update the metadata of an existing {@link Destination} on the project.\n *\n * @category Destination\n */\nexport const updateDestinationProps = async (payload: {\n  projectId: string\n  destinationId: string\n  props: Props\n}) => {\n  const {\n    projectId = state.activeProjectId,\n    destinationId,\n    props = {},\n  } = payload\n  const project = getProject(projectId)\n  const destination = project.videoApi.project.destinations.find(\n    (x) => x.destinationId === destinationId,\n  )\n  if (!destination) return\n\n  const response = await CoreContext.clients\n    .LiveApi()\n    .destination?.updateDestination({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      destinationId,\n      updateMask: ['metadata'],\n      metadata: {\n        ...(destination.metadata || {}),\n        props: {\n          ...(destination.metadata?.props || {}),\n          ...props,\n        },\n      },\n    })\n\n  // Trigger event to update state\n  await triggerInternal('DestinationChanged', response.destination)\n  return\n}\n/**\n * @deprecated Use updateDestinationProps\n */\nexport const updateDestinationMeta = (payload: {\n  projectId: string\n  destinationId: string\n  metadata?: Props\n}) =>\n  updateDestinationProps({\n    projectId: payload.projectId,\n    destinationId: payload.destinationId,\n    props: payload.metadata,\n  })\n\n/**\n * Enable or disable an existing {@link Destination} on the project.\n *\n * @category Destination\n */\nexport const setDestinationEnabled = async (payload: {\n  projectId?: string\n  destinationId: string\n  enabled: boolean\n}) => {\n  const { enabled, destinationId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  const destination = project.videoApi.project.destinations.find(\n    (x) => destinationId === x.destinationId,\n  )\n  if (destination.enabled === enabled) return\n\n  const response = await CoreContext.clients\n    .LiveApi()\n    .destination?.updateDestination({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      destinationId,\n      updateMask: ['enabled'],\n      enabled,\n    })\n\n  // Trigger event to update state\n  await triggerInternal('DestinationChanged', response.destination)\n\n  const event = enabled ? 'DestinationEnabled' : 'DestinationDisabled'\n  /** @deprecated Use DestinationChanged */\n  trigger(event, {\n    projectId,\n    destinationId,\n  })\n  return\n}\n\n/**\n * Overwrite project's first {@link Destination} with new configuration\n *  If no destination exists, one will be created instead.\n *\n * This is a helper to manage a single-destination project. For greater control,\n *  use {@link addDestination}, {@link removeDestination}, or {@link updateDestination}\n *\n * @category Destination\n */\nexport const setDestination = async (payload: {\n  projectId?: string\n  rtmpUrl: string\n  rtmpKey: string\n}) => {\n  const { rtmpUrl, rtmpKey, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  const rtmpPush = {\n    key: rtmpKey,\n    url: rtmpUrl,\n  }\n  const enabled = true\n\n  if (project.videoApi.project.destinations.length > 0) {\n    // Update existing\n    const response = await CoreContext.clients\n      .LiveApi()\n      .destination?.updateDestination({\n        collectionId: project.videoApi.project.collectionId,\n        projectId: project.videoApi.project.projectId,\n        destinationId: project.videoApi.project.destinations[0].destinationId,\n        updateMask: ['address.rtmpPush'],\n        address: { rtmpPush },\n      })\n\n    // Trigger event to update state\n    await triggerInternal('DestinationChanged', response.destination)\n  } else {\n    // Create new\n    const response = await CoreContext.clients\n      .LiveApi()\n      .destination?.createDestination({\n        collectionId: project.videoApi.project.collectionId,\n        projectId: project.videoApi.project.projectId,\n        address: { rtmpPush },\n        enabled,\n      })\n\n    // Trigger event to update state\n    await triggerInternal('DestinationAdded', response.destination)\n  }\n\n  /** @deprecated */\n  trigger('DestinationSet', {\n    projectId,\n    rtmpUrl,\n    rtmpKey,\n  })\n  return\n}\n"],"names":["state","CoreContext","updateUserProps","payload","collection","getUser","props","response","clients","LiveApi","updateCollection","collectionId","id","updateMask","metadata","triggerInternal","createProject","size","settings","Request","project","internalProject","hydrateProject","toBaseProject","deleteProject","projectId","updateProjectProps","getProject","updateProject","videoApi","updateProjectMeta","meta","setActiveProject","projects","find","x","activeProjectId","currentProject","Array","from","webrtcManager","rooms","keys","map","removeRoom","LayoutApi","unsubscribeFromLayout","layoutApi","layoutId","unsubscribeFromProject","subscribeToLayout","subscribeToProject","status","then","phase","joinRoom","displayName","token","sfuToken","webrtcAccess","authentication","createWebRtcAccessToken","accessToken","roomName","tokenData","decode","video","room","url","URL","getLiveKitServer","baseUrl","host","pathname","roomContext","ensureRoom","bindApiClient","connect","roomId","getRoom","trigger","createNode","parentId","index","type","nodeId","compositor","insert","get","deleteNode","getParent","remove","updateNode","sourceType","update","setNodeLayout","layout","layoutProps","moveNode","move","swapNodes","nodeAId","nodeBId","parentAId","parentBId","swap","reorderNodes","childIds","reorder","startBroadcast","startProjectBroadcast","stopBroadcast","stopProjectBroadcast","addDestination","rtmpUrl","rtmpKey","enabled","address","rtmpPush","key","destination","createDestination","toBaseDestination","removeDestination","destinationId","deleteDestination","updateDestination","updateDestinationProps","destinations","updateDestinationMeta","setDestinationEnabled","setDestination","length"],"mappings":"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"}