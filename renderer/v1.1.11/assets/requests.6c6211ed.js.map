{"version":3,"file":"requests.6c6211ed.js","sources":["../../../../src/helpers/sceneless-project.ts","../../../../src/core/requests.ts"],"sourcesContent":["import { getElementAttributes } from './../logic'\n/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\n/**\n * Create and manage a project with a {@link ScenelessProject.Commands simple and opinionated interface}.\n *\n * A ScenelessProject is designed to fulfill all of the requirements of\n * a standard web-based broadcaster. It provides simple\n * management of WebRTC {@link Participant Participants},\n * custom layouts, backgrounds, and overlay content.\n *\n * Internally, any {@link Project} that meets a certain set of preconditions is\n * eligible to act as a ScenelessProject. The simplest way to ensure a project\n * can leverage these commands is by creating one with {@link create ScenelessProject.create()}.\n *\n * ```typescript\n * // Create a project for the user with default settings\n * const project = await ScenelessProject.create({\n *   backgroundImage: 'https://studio.golightstream.com/images/polygons.jpg',\n *   layout: 'Grid',\n * })\n *\n * // Pass the project in to receive a list of commands unique to a ScenelessProject\n * const projectCommands = ScenelessProject.commands(project)\n *\n * // Use the commands to update the project's contents (what participants/overlays will appear in the output stream)\n * projectCommands.addParticipant(participantId)\n * ```\n *\n * ----\n * _Note: When using a project interface such as this, avoid using\n * any {@link Command Commands} that operate on elements inside the project. This\n * includes any command which operates on a node (e.g. {@link Command.updateNode} or {@link Command.reorderNodes})._\n *\n * _This is an alternative to {@link Command.createProject}._\n *\n * @module ScenelessProject\n */\n\nimport { CoreContext } from '../core/context'\nimport { getProject, getProjectRoom, toBaseProject } from '../core/data'\nimport { SDK, Compositor } from '../core/namespaces'\nimport { Disposable } from '../core/types'\nimport { Track } from 'livekit-client'\n\nimport LayoutName = Compositor.Layout.LayoutName\nimport { Banner, BannerSource, BannerProps } from '../core/sources/Banners'\nimport { generateId } from '../logic'\nexport type { LayoutName }\nexport type { Banner, BannerSource }\n\nexport type ParticipantProps = {\n  volume: number\n  isMuted: boolean\n  isHidden: boolean\n}\n\nexport type HTMLVideoElementAttributes = {\n  loop?: boolean\n  autoplay?: boolean\n  muted?: boolean\n  playsinline?: boolean\n  disablepictureinpicture?: boolean\n}\n\n// Local cache to track participants being added\nconst addingCache = {\n  camera: new Set<string>(),\n  screen: new Set<string>(),\n}\n\nexport type ParticipantType = 'camera' | 'screen'\n\ninterface ScenelessProject extends SDK.Project {}\n\n// Note: Assume project is a valid sceneless project\n// Note: In the future commands will be returned by an argument of SceneNode\n\n// TODO: Define defaults\n// TODO: Define emits\n\n/**\n * These commands assist with management of WebRTC {@link Participant Participants},\n * custom layouts, backgrounds, and overlay content.\n *\n * Only a valid {@link ScenelessProject} can leverage these commands.\n */\nexport interface Commands {\n  /**\n   * Get the node that holds the stream's background\n   * @private\n   */\n  getBackground(): Compositor.SceneNode\n  /**\n   * Get the node that holds the stream's content\n   * @private\n   */\n  getContent(): Compositor.SceneNode\n  /**\n   * Get the node that holds the stream's foreground (overlays)\n   * @private\n   */\n  getForeground(): Compositor.SceneNode\n  /**\n   * Get the active layout\n   * @private\n   */\n  getLayout(): string\n  /**\n   * Get all banners stored on the project\n   */\n  getBanners(): Banner[]\n  /**\n   * Get all participants in the project\n   * @private\n   */\n  getParticipants(room: SDK.Room): Compositor.SceneNode[]\n  /**\n   * play video overlay on foreground\n   * @private\n   */\n  autoPlayVideoOverlay(\n    overlayId: string,\n    attributes: HTMLVideoElementAttributes,\n  ): void\n\n  /**\n   * play background Video\n   * @private\n   */\n  autoPlayBackgroundVideo(attributes?: HTMLVideoElementAttributes): void\n  /**\n   * Set the active layout and associated layoutProps\n   */\n  setLayout(layout: LayoutName, layoutProps: LayoutProps): void\n  /**\n   * Get background media, it can be video or image\n   */\n  getBackgroundMedia(): string\n  /**\n   * Get the active background image\n   */\n  getBackgroundVideo(): string\n  /**\n   * Get the active background image\n   */\n  getBackgroundImage(): string\n  /**\n   * Set the active background image\n   */\n  setBackgroundImage(src: string): void\n\n  /**\n   * Set the active background image\n   */\n  setBackgroundVideo(src: string, attributes?: HTMLVideoElementAttributes): void\n\n  /**\n   * Get the active foreground overlay\n   */\n  getImageOverlay(): string | string[]\n  /**\n   * Get the active foreground overlay\n   */\n  getVideoOverlay(): string | string[]\n  /**\n   * Set the active foreground overlay\n   */\n  addImageOverlay(overlayId: string, src: string): Promise<void>\n  /**\n   * set image overlay on foreground layer\n   */\n  addVideoOverlay(\n    overlayId: string,\n    src: string,\n    attributes?: HTMLVideoElementAttributes,\n  ): Promise<void>\n\n  /**\n   * remove image overlay from foreground layer\n   */\n  removeVideoOverlay(overlayId: string): Promise<void>\n\n  /**\n   * remove image overlay from foreground layer\n   */\n  removeImageOverlay(overlayId: string): Promise<void>\n\n  /** Set one participant to \"showcase\". This participant will expand to fill\n   * the space of the stream without affecting the underlying layout.\n   */\n  setShowcase(\n    participantId: string,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): ReturnType<typeof CoreContext.Command.updateNode>\n  /**\n   * @hook\n   * Receive information about the showcased participant.\n   * As with other hooks, the callback will be invoked when its value changes.\n   */\n  useShowcase(\n    cb: (state: { participantId: string; type: ParticipantType }) => void,\n  ): Disposable\n  /**\n   * Add a participant to the stream canvas.\n   * Available participants can be gleaned from the WebRTC {@link Room} using\n   * {@link Room.useParticipants}.\n   *\n   * A participant will remain on stream even if there is no active feed, until\n   * it is removed using {@link removeParticipant removeParticipant()} or {@link pruneParticipants pruneParticipants()}.\n   */\n  addParticipant(\n    participantId: string,\n    props: Partial<ParticipantProps>,\n    /**\n     * The type of participant feed to add.\n     * @default `'camera'`\n     */\n    type?: ParticipantType,\n  ): Promise<void>\n  /**\n   * @private\n   * @deprecated Use addParticipant() with parameter `type`\n   */\n  addParticipantScreenshare(\n    participantId: string,\n    props: Partial<ParticipantProps>,\n  ): Promise<void>\n  /**\n   * Remove a stream participant from the stream canvas.\n   */\n  removeParticipant(participantId: string, type: ParticipantType): void\n  /**\n   * @private\n   * @deprecated Use removeParticipant() with parameter `type`\n   */\n  removeParticipantScreenshare(participantId: string): void\n  /**\n   * @private\n   * Get the node associated with a room participant\n   * */\n  getParticipantNode(\n    id: string,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): Compositor.SceneNode\n  /**\n   * Get {@link ParticipantProps} associated with a participant/type.\n   */\n  getParticipantState(\n    participantId: string,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): ParticipantProps\n  /**\n   * @hook\n   * Receive {@link ParticipantProps} associated with a participant/type\n   * via invoked callback anytime one of the property values changes.\n   */\n  useParticipantState(\n    participantId: string,\n    cb: (state: ParticipantProps) => void,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): Disposable\n  /**\n   * Change a participant's volume.\n   * This does not affect the underlying MediaStreamTrack.\n   */\n  setParticipantVolume(\n    participantId: string,\n    /**\n     * Accepted values from [0 - 1]\n     */\n    volume: number,\n  ): void\n  /**\n   * Mute a participant without changing their volume.\n   *  This does not affect the underlying MediaStreamTrack.\n   *\n   * Participants muted in this way will not stop sending\n   *  audio data, but it will not play on the receiving end.\n   *\n   * A host may use this to override a guest's settings\n   *  for the stream output.\n   */\n  setParticipantMuted(participantId: string, isMuted: boolean): void\n  /**\n   * Hide a participant video feed from the stream.\n   *  This does not affect the underlying MediaStreamTrack.\n   *\n   * Participants hidden in this way will not stop sending\n   *  video data, but it will not play on the receiving end.\n   *\n   * A host may use this to override a guest's settings\n   *  for the stream output.\n   */\n  setParticipantHidden(participantId: string, isHidden: boolean): void\n  /**\n   * Remove all participants from the stream canvas who are not actively\n   * sending a MediaStreamTrack for display.\n   */\n  pruneParticipants(): void\n  /**\n   * Create and store a banner on the project.\n   *\n   * Does not add the banner to the stream.\n   */\n  addBanner(props: BannerProps): void\n  /**\n   * Edit a banner on the project.\n   */\n  editBanner(id: string, props: BannerProps): void\n  /**\n   * Remove a banner from the project.\n   */\n  removeBanner(id: string): void\n  /**\n   * Add an existing banner to the stream.\n   * If no `id` is supplied, existing banners will be removed.\n   */\n  setActiveBanner(id: string): void\n  /**\n   * Get an arbitrary property from the project (`project.props{}`)\n   */\n  getProp(props: string): any\n  /**\n   * Set an arbitrary property on the project (`project.props{}`)\n   */\n  setProp(props: string, val: any): void\n  /**\n   * Use the latest value of an arbitrary property on the project (`project.props{}`)\n   */\n  useProp(props: string, cb: (val: any) => void): void\n}\n\n/**\n * Accepts a Project that was created using {@link ScenelessProject.create ScenelessProject.create()}\n * and returns several commands specialized for a Sceneless broadcasting experience.\n *\n * These commands assist with management of WebRTC {@link Participant Participants},\n * custom layouts, backgrounds, and overlay content.\n */\nexport const commands = (_project: ScenelessProject) => {\n  const projectId = _project.id\n  const root = _project.scene.getRoot()\n  const { Command } = CoreContext\n\n  const background = root.children.find((x) => x.props.id === 'bg')\n  const content = root.children.find((x) => x.props.id === 'content')\n  const foreground = root.children.find((x) => x.props.id === 'foreground')\n\n  const coreProject = getProject(_project.id)\n\n  let bannerContainer = foreground?.children?.find(\n    (x) => x.props.id === 'fg-banners',\n  )\n\n  let foregroundImageContainer = foreground?.children?.find(\n    (x) => x.props.id === 'fg-image',\n  )\n\n  let foregroundVideoContainer = foreground?.children?.find(\n    (x) => x.props.id === 'fg-video',\n  )\n\n  const ensureForegroundContainers = async () => {\n    const ensureBannerContainer = async () => {\n      if (!bannerContainer) {\n        const nodeId = await coreProject.compositor.insert({\n          name: 'BannerContainer',\n          id: 'fg-banners',\n          layout: 'Column',\n          layoutProps: {\n            cover: true,\n          },\n        }, foreground.id)\n        bannerContainer = foreground?.children?.find(x => x.props.id === nodeId)\n        return nodeId\n      } else {\n        return bannerContainer.id\n      }\n    }\n\n    const ensureForegroundImageContainer = async () => {\n      if (!foregroundImageContainer) {\n        const nodeId = await coreProject.compositor.insert({\n            name: 'ImageOverlay',\n            id: 'fg-image',\n            layout: 'Free',\n          }, foreground.id)\n\n        foregroundImageContainer = foreground?.children?.find(x => x.props.id === nodeId)\n        return nodeId\n      } else {\n        return foregroundImageContainer.id\n      }\n    }\n\n\n    const ensureForegroundVideoContainer = async () => {\n      if (!foregroundVideoContainer) {\n        const nodeId = await coreProject.compositor.insert({\n            name: 'VideoOverlay',\n            id: 'fg-video',\n            layout: 'Free',\n          }, foreground.id)\n        foregroundVideoContainer = foreground?.children?.find(x => x.props.id === nodeId)\n        return nodeId\n      } else {\n        return foregroundVideoContainer.id\n      }\n    }\n\n    const baseForegroundLayers = await Promise.all([\n      ensureBannerContainer(),\n      ensureForegroundImageContainer(),\n      ensureForegroundVideoContainer(),\n    ])\n    await coreProject.compositor.reorder(foreground.id, baseForegroundLayers)\n  }\n\n  \n\n  const commands: Commands = {\n    getBackground() {\n      return background\n    },\n    getContent() {\n      return content\n    },\n    getForeground() {\n      return foreground\n    },\n    getLayout() {\n      return content.props.layout\n    },\n    getBanners() {\n      return (getProject(_project.id).props?.banners || []) as Banner[]\n    },\n\n    getParticipants(room: SDK.Room) {\n      return content.children.filter((node) => {\n        if (node.props.sourceType !== 'RoomParticipant') return false\n        return true\n      })\n    },\n\n    addBanner(props: BannerProps = {}) {\n      const meta = props.meta || {}\n      const banner = {\n        id: generateId(),\n        props: {\n          ...props,\n          meta,\n        },\n      }\n\n      const existingBanners = (getProject(projectId).props?.banners ||\n        []) as Banner[]\n      return Command.updateProjectProps({\n        projectId,\n        props: {\n          banners: [...existingBanners, banner],\n        },\n      })\n    },\n    editBanner(id: string, props: BannerProps = {}) {\n      const existingBanners = commands.getBanners()\n      const banners = existingBanners.map((x) => {\n        if (x.id !== id) return x\n        return {\n          ...x,\n          props,\n        }\n      })\n      return Command.updateProjectProps({\n        projectId,\n        props: {\n          banners,\n        },\n      })\n    },\n    removeBanner(id: string) {\n      const existingBanners = commands.getBanners()\n      // Remove dependent nodes from stream\n      bannerContainer?.children?.forEach((x) => {\n        if (x.id !== id) return\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n\n      return Command.updateProjectProps({\n        projectId,\n        props: {\n          banners: existingBanners.filter((x) => x.id !== id),\n        },\n      })\n    },\n    setActiveBanner(id: string) {\n      const existingBanners = commands.getBanners()\n      const banner = existingBanners?.find((x) => x.id === id)\n      bannerContainer?.children?.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n      if (!banner) return\n      return CoreContext.Command.createNode({\n        parentId: bannerContainer?.id,\n        props: {\n          sourceType: 'Banner',\n          bannerId: banner.id,\n        },\n      })\n    },\n\n    getImageOverlay(): string | string[] {\n      const foregroundImageIds = foregroundImageContainer?.children?.map(\n        (x) => x?.props?.sourceProps?.id,\n      ) ?? []\n      return foregroundImageIds.length > 1\n        ? foregroundImageIds\n        : foregroundImageIds[0]\n    },\n\n    getVideoOverlay(): string | string[] {\n      const foregroundVideoIds = foregroundVideoContainer?.children?.map(\n        (x) => x?.props?.sourceProps?.id,\n      ) ?? []\n      return foregroundVideoIds.length > 1\n        ? foregroundVideoIds\n        : foregroundVideoIds[0]\n    },\n\n    autoPlayBackgroundVideo(\n      attributes: HTMLVideoElementAttributes = {\n        muted: true,\n        autoplay: true,\n      },\n    ) {\n      // find overlay node by id\n      const backgroundVideo = background.children.find(\n        (x) => x.props.id === 'bg-video',\n      )\n      // if overlay is not found, return\n      if (!backgroundVideo) {\n        return\n      }\n      // check if overlay is of type video\n      // autoPlay overlay with muted audio\n      // update overlay node with new attributes\n      CoreContext.Command.updateNode({\n        nodeId: backgroundVideo.id,\n        props: {\n          ...backgroundVideo.props,\n          attributes: {\n            ...backgroundVideo.props.attributes,\n            ...attributes,\n          },\n        },\n      })\n    },\n\n    autoPlayVideoOverlay(\n      overlayId: string,\n      attributes: HTMLVideoElementAttributes = {\n        muted: true,\n        autoplay: true,\n      },\n    ) {\n      // find overlay node by id\n      const overlay = foregroundVideoContainer?.children?.find(\n        (x) => x.props?.sourceProps?.id === overlayId,\n      )\n\n      // if overlay is not found, return\n      if (!overlay) {\n        return\n      }\n\n      // check if overlay is of type video\n      if (overlay.props.sourceProps.type === 'video') {\n        // autoPlay overlay with muted audio\n        // update overlay node with new attributes\n        CoreContext.Command.updateNode({\n          nodeId: overlay.id,\n          props: {\n            ...overlay.props,\n            attributes: {\n              ...overlay.props.attributes,\n              ...attributes,\n            },\n          },\n        })\n      }\n    },\n\n    async removeImageOverlay(overlayId: string) {\n      // find overlay node by id\n      const overlay = foregroundImageContainer.children.find(\n        (x) => x.props?.sourceProps?.id === overlayId,\n      )\n      // if overlay exists, remove it\n      if (overlay) {\n        CoreContext.Command.deleteNode({\n          nodeId: overlay.id,\n        })\n      }\n    },\n\n    async removeVideoOverlay(overlayId: string) {\n      // find overlay node by id\n      const overlay = foregroundVideoContainer?.children?.find(\n        (x) => x.props?.sourceProps?.id === overlayId,\n      )\n\n      // if overlay exists, remove it\n      if (overlay) {\n        CoreContext.Command.deleteNode({\n          nodeId: overlay.id,\n        })\n      }\n\n      // get all children of the overlay node and update their opacity attributes\n      const allForegroundChildrens = foreground.children.filter(\n        (f) => f.props.id !== 'fg-video',\n      )\n      allForegroundChildrens.forEach((nodes) => {\n        nodes.children.forEach((node) => {\n          if (node.props?.fields?.style?.opacity === 0) {\n            node.props.fields.style.opacity = 1\n            CoreContext.Command.updateNode({\n              nodeId: node.id,\n              props: {\n                ...node.props,\n              },\n            })\n          }\n        })\n      })\n    },\n\n    async addImageOverlay(overlayId: string, src: string) {\n      // Get the image overlay node from the foreground layer\n      const imageOverlay = foregroundImageContainer.children.find(\n        (x) => x.props.id === 'img-overlay',\n      )\n\n      // if the overlayid matches the image overlay id passed, return\n      if (imageOverlay && imageOverlay?.props?.sourceProps?.id === overlayId) {\n        return\n      }\n\n      //set the source of the image overlay node to the image src\n      let imageProps = {\n        id: 'img-overlay',\n        sourceType: 'Element',\n        sourceProps: {\n          type: 'image',\n          id: overlayId,\n        },\n        tagName: 'img',\n        attributes: {\n          src,\n        },\n        fields: {\n          style: {\n            transition: 'opacity 300ms ease 0ms, transform, width, height',\n            '-webkit-transition':\n              'opacity 300ms ease 0ms, transform, width, height',\n            opacity: 1,\n            objectFit: 'cover',\n          },\n        },\n      }\n      // get video overlay node from the foreground layer\n      const vidOverlay = foregroundVideoContainer?.children?.find(\n        (x) => x.props.id === 'vid-overlay',\n      )\n\n      // if the video overlay node exists, change the image overlay node to opacity 0\n      if (vidOverlay) {\n        imageProps.fields.style.opacity = 0\n      }\n\n      // If the overlay doesn't exist, create it\n      if (!imageOverlay) {\n        await CoreContext.Command.createNode({\n          props: imageProps,\n          parentId: foregroundImageContainer.id,\n          index: foregroundImageContainer.children.length,\n        })\n      } else {\n        // Otherwise, update the overlay node\n        CoreContext.Command.updateNode({\n          nodeId: imageOverlay.id,\n          props: {\n            ...imageOverlay.props,\n            ...imageProps,\n          },\n        })\n      }\n    },\n\n    async addVideoOverlay(\n      overlayId: string,\n      src: string,\n      attributes: HTMLVideoElementAttributes = {\n        playsinline: true,\n        disablepictureinpicture: true,\n        autoplay: true,\n      },\n    ) {\n      // Get the video overlay node from the foreground layer\n      const videoOverlay = foregroundVideoContainer?.children?.find(\n        (x) => x.props.id === 'vid-overlay',\n      )\n\n      // if the video overlay node exists, and the overlay id matches the overlay id passed in, return\n      if (videoOverlay && videoOverlay?.props?.sourceProps?.id === overlayId) {\n        return\n      }\n\n      //set the source of the video overlay node to the src\n      let videoProps = {\n        id: 'vid-overlay',\n        sourceType: 'LS-Video',\n        sourceProps: {\n          type: 'video',\n          id: overlayId,\n        },\n        tagName: 'video',\n        attributes: {\n          ...attributes,\n          src,\n          id: overlayId,\n        },\n      }\n\n      // get all children of the overlay node and update their opacity attributes\n      const allForegroundChildrens = foreground.children.filter(\n        (f) => f.props.id !== 'fg-video',\n      )\n      allForegroundChildrens.forEach((nodes) => {\n        nodes.children.forEach((node) => {\n          if (node.props?.fields?.style?.opacity === 1) {\n            node.props.fields.style.opacity = 0\n            CoreContext.Command.updateNode({\n              nodeId: node.id,\n              props: {\n                ...node.props,\n              },\n            })\n          }\n        })\n      })\n\n      // If the overlay doesn't exist, create it\n      if (!videoOverlay) {\n        await CoreContext.Command.createNode({\n          props: videoProps,\n          parentId: foregroundVideoContainer.id,\n          index: foregroundVideoContainer.children.length,\n        })\n      } else {\n        // Otherwise, update the overlay node\n        CoreContext.Command.updateNode({\n          nodeId: videoOverlay.id,\n          props: {\n            ...videoOverlay.props,\n            ...videoProps,\n          },\n        })\n      }\n    },\n\n    setLayout(layout: LayoutName, layoutProps: LayoutProps = {}) {\n      const showcase = content.props.layoutProps.showcase\n      Command.setNodeLayout({\n        nodeId: content.id,\n        layout,\n        layoutProps: {\n          showcase,\n          ...layoutProps,\n        },\n      })\n    },\n\n    getBackgroundMedia() {\n      const backgroundChild = background.children.filter((x) => x)\n      return backgroundChild[0]?.props?.attributes?.src\n    },\n\n    getBackgroundImage() {\n      const backgroundChild = background.children.filter(\n        (x) => x.props.id === 'bg-image',\n      )\n      return backgroundChild[0]?.props?.attributes?.src\n    },\n\n    getBackgroundVideo() {\n      const backgroundChild = background.children.filter(\n        (x) => x.props.id === 'bg-video',\n      )\n      return backgroundChild[0]?.props?.attributes?.src\n    },\n\n    async setBackgroundImage(src: string) {\n      const backgroundImage = background.children.find(\n        (x) => x.props.id === 'bg-image',\n      )\n\n      // if the video overlay node exists, and the overlay id matches the overlay id passed in, return\n      if (backgroundImage && backgroundImage?.props?.attributes?.src === src) {\n        return\n      }\n\n      const backgroundVideo = background.children.find(\n        (x) => x.props.id === 'bg-video',\n      )\n\n      if (backgroundVideo) {\n        CoreContext.Command.deleteNode({\n          nodeId: backgroundVideo.id,\n        })\n      }\n\n      if (!backgroundImage) {\n        await CoreContext.Command.createNode({\n          props: {\n            name: 'ImageBackground',\n            id: 'bg-image',\n            tagName: 'img',\n            sourceType: 'Element',\n            attributes: {\n              src,\n            },\n          },\n          parentId: background.id,\n          index: background.children.length,\n        })\n      } else {\n        CoreContext.Command.updateNode({\n          nodeId: backgroundImage.id,\n          props: {\n            attributes: {\n              ...backgroundImage.props.attributes,\n              src,\n            },\n          },\n        })\n      }\n    },\n\n    async setBackgroundVideo(\n      src: string,\n      attributes: HTMLVideoElementAttributes = {\n        loop: true,\n        autoplay: true,\n      },\n    ) {\n      const backgroundVideo = background.children.find(\n        (x) => x.props.id === 'bg-video',\n      )\n\n      // if the video overlay node exists, and the overlay id matches the overlay id passed in, return\n      if (backgroundVideo && backgroundVideo?.props?.attributes?.src === src) {\n        return\n      }\n\n      const backgroundImage = background.children.find(\n        (x) => x.props.id === 'bg-image',\n      )\n\n      if (backgroundImage) {\n        CoreContext.Command.deleteNode({\n          nodeId: backgroundImage.id,\n        })\n      }\n\n      if (!backgroundVideo) {\n        await CoreContext.Command.createNode({\n          props: {\n            name: 'VideoBackground',\n            id: 'bg-video',\n            sourceType: 'LS-Video',\n            attributes: {\n              ...attributes,\n              src,\n            },\n          },\n          parentId: background.id,\n          index: background.children.length,\n        })\n      } else {\n        CoreContext.Command.updateNode({\n          nodeId: backgroundVideo.id,\n          props: {\n            attributes: {\n              ...backgroundVideo.props.attributes,\n              ...attributes,\n              src,\n            },\n          },\n        })\n      }\n    },\n    setShowcase(participantId: string, type: ParticipantType = 'camera') {\n      const node = commands.getParticipantNode(participantId, type)\n      return CoreContext.Command.updateNode({\n        nodeId: content.id,\n        props: {\n          layoutProps: {\n            ...content.props.layoutProps,\n            showcase: node?.id ?? null,\n          },\n        },\n      })\n    },\n    useShowcase(\n      cb: (state: { participantId: string; type: ParticipantType }) => void,\n    ) {\n      const sendState = () => {\n        const nodeId = content.props.layoutProps.showcase\n        const node = content.children.find((x) => x.id === nodeId)\n        if (!node)\n          return cb({\n            participantId: null,\n            type: null,\n          })\n\n        const { sourceProps } = node.props\n        return cb({\n          participantId: sourceProps.id,\n          type: sourceProps.type,\n        })\n      }\n      sendState()\n\n      // Watch for changes to the parent children\n      return CoreContext.onInternal('NodeChanged', (payload) => {\n        if (payload.nodeId !== content.id) return\n        sendState()\n      })\n    },\n    async addParticipant(\n      participantId: string,\n      props: Partial<ParticipantProps> = {},\n      type: ParticipantType = 'camera',\n    ) {\n      if (addingCache[type].has(participantId)) return\n\n      const { isMuted = false, isHidden = false, volume = 1 } = props\n      const existing = content.children.find(\n        (x) =>\n          x.props.sourceProps?.id === participantId &&\n          x.props.sourceProps?.type === type,\n      )\n      if (existing) return\n\n      addingCache[type].add(participantId)\n      // Get the participant type in the first position\n      const currentFirst = content.children[0]\n      let index = content.children.length\n\n      // If we're adding a screen and the first position is not already\n      //  a screen, then we add it in the first position.\n      if (\n        type === 'screen' &&\n        currentFirst?.props.sourceProps.type !== 'screen'\n      ) {\n        index = 0\n      }\n      await CoreContext.Command.createNode({\n        props: {\n          name: 'Participant',\n          sourceType: 'RoomParticipant',\n          sourceProps: {\n            type,\n            id: participantId,\n          },\n          volume,\n          isMuted,\n          isHidden,\n        },\n        parentId: content.id,\n        index,\n      }).finally(() => {\n        addingCache[type].delete(participantId)\n      })\n    },\n    addParticipantScreenshare(\n      participantId: string,\n      props: Partial<ParticipantProps> = {},\n    ) {\n      return commands.addParticipant(participantId, props, 'screen')\n    },\n    removeParticipant(participantId: string, type: ParticipantType = 'camera') {\n      content.children\n        .filter(\n          (x) =>\n            x.props.sourceProps?.id === participantId &&\n            x.props.sourceProps?.type === type &&\n            x.props.sourceType === 'RoomParticipant',\n        )\n        .forEach((x) => {\n          CoreContext.Command.deleteNode({\n            nodeId: x.id,\n          })\n        })\n    },\n    removeParticipantScreenshare(participantId: string) {\n      return commands.removeParticipant(participantId, 'screen')\n    },\n    getParticipantNode(id: string, type: ParticipantType = 'camera') {\n      return content.children.find(\n        (x) =>\n          x.props.sourceProps?.id === id && x.props.sourceProps?.type === type,\n      )\n    },\n    getParticipantState(\n      participantId: string,\n      type: ParticipantType = 'camera',\n    ) {\n      return commands.getParticipantNode(participantId, type)\n        ?.props as ParticipantProps\n    },\n    useParticipantState(\n      participantId: string,\n      cb: (state: ParticipantProps) => void,\n      type = 'camera' as ParticipantType,\n    ) {\n      let participantNode = commands.getParticipantNode(participantId, type)\n\n      const sendState = () => {\n        cb(participantNode?.props as ParticipantProps)\n      }\n\n      // Watch for changes to the parent children\n      const childListener = CoreContext.onInternal('NodeChanged', (payload) => {\n        if (payload.nodeId !== content.id) return\n        const previous = participantNode\n        participantNode = commands.getParticipantNode(participantId, type)\n        if (previous !== participantNode) {\n          sendState()\n        }\n      })\n\n      // Watch for changes to the participant node\n      const participantListener = CoreContext.onInternal(\n        'NodeChanged',\n        (payload) => {\n          if (!participantNode || payload.nodeId !== participantNode.id) return\n          sendState()\n        },\n      )\n\n      sendState()\n\n      // Return disposable for listener\n      return () => {\n        childListener()\n        participantListener()\n      }\n    },\n    setParticipantVolume(participantId: string, volume: number) {\n      const node = commands.getParticipantNode(participantId)\n      if (!node) return\n      CoreContext.Command.updateNode({\n        nodeId: node.id,\n        props: {\n          volume,\n        },\n      })\n    },\n    setParticipantMuted(participantId: string, isMuted: boolean) {\n      const node = commands.getParticipantNode(participantId)\n      if (!node) return\n      CoreContext.Command.updateNode({\n        nodeId: node.id,\n        props: {\n          isMuted,\n        },\n      })\n    },\n    setParticipantHidden(participantId: string, isHidden: boolean) {\n      const node = commands.getParticipantNode(participantId)\n      if (!node) return\n      CoreContext.Command.updateNode({\n        nodeId: node.id,\n        props: {\n          isHidden,\n        },\n      })\n    },\n    pruneParticipants() {\n      // Remove all participant nodes that do not have active tracks\n      const room = getProjectRoom(projectId)\n      if (!room) return\n\n      content.children\n        .filter((node) => {\n          if (node.props.sourceType !== 'RoomParticipant') return false\n          const nodeSourceType = node.props.sourceProps?.type\n\n          // Get the participant associated with the node\n          const nodeParticipant = room.getParticipant(\n            node.props.sourceProps?.id,\n          )\n          // If the participant is not in the room, remove the node\n          if (!nodeParticipant) return true\n\n          // Keep \"camera\" nodes around as long as the participant is available.\n          //  This is to facilitate camera switching or other such feed interruptions\n          if (nodeSourceType === 'camera') return false\n\n          // Get all tracks associated with the node's participant\n          const participantTracks = nodeParticipant.trackIds\n            .map((x) => room.getTrack(x))\n            .filter(Boolean)\n\n          // Determine whether there is a track available to the node\n          const hasAvailableTrack = participantTracks.some((track) => {\n            // Get the source type as it corresponds to the track's type\n            const sourceType =\n              track.type === Track.Source.Camera ||\n              track.type === Track.Source.Microphone\n                ? 'camera'\n                : 'screen'\n\n            // Return true if the node source has a matching track\n            return sourceType === nodeSourceType\n          })\n\n          return !hasAvailableTrack\n        })\n        .forEach((x) => {\n          CoreContext.Command.deleteNode({\n            nodeId: x.id,\n          })\n        })\n    },\n    getProp(prop) {\n      return getProject(_project.id).props[prop]\n    },\n    setProp(prop, val) {\n      return Command.updateProjectProps({\n        projectId,\n        props: {\n          [prop]: val,\n        },\n      })\n    },\n    useProp(prop, cb) {\n      return CoreContext.on('ProjectChanged', (payload) => {\n        if (projectId === payload.project.id) {\n          cb(payload.project.props[prop])\n        }\n      })\n    },\n  }\n\n  const ensureValid = async () => {\n    await ensureForegroundContainers()\n    beforeInit(commands)\n  }\n\n  ensureValid()\n  return commands\n}\n\nexport type LayoutProps = {\n  cover?: boolean\n  /** Valid CSS for justify-content */\n  justifyViewers?: 'flex-end' | 'center' | 'flex-start'\n  /** Percentage */\n  barWidth?: number\n  barPosition?: 'bottom' | 'side'\n  useGrid?: boolean\n  reverse?: boolean\n}\ntype ScenelessSettings = {\n  backgroundImage?: string\n  layout?: string\n  layoutProps?: LayoutProps\n}\n\n/**\n * **An abstraction over {@link Command.createProject Command.createProject()}.**\n *\n * A Project created using this function will be compatible with {@link ScenelessProject.commands ScenelessProject.commands()}\n *\n * **Emits: ProjectAdded**\n */\nexport const create = async (\n  settings: ScenelessSettings = {},\n  props: SDK.Props = {},\n) => {\n  return CoreContext.Command.createProject({\n    settings,\n    props,\n  }) as Promise<ScenelessProject>\n}\n\nexport const beforeInit = (commands: Commands) => {\n  /** autoPlay last applied video overlay on refresh */\n  const videoOverLay = commands.getVideoOverlay() as string\n\n  if (videoOverLay) {\n    commands.autoPlayVideoOverlay(videoOverLay, {\n      muted: true,\n      autoplay: true,\n    })\n  }\n\n  /** autoPlay last applied video background on refresh */\n  const backgroundVideo = commands.getBackgroundVideo()\n  if (backgroundVideo) {\n    commands.autoPlayBackgroundVideo({\n      muted: true,\n      autoplay: true,\n    })\n  }\n}\n/** @private */\nexport const createCompositor = async (\n  layoutId: string,\n  size: { x: number; y: number },\n  settings: ScenelessSettings,\n) => {\n  const { backgroundImage, layout, layoutProps = {} } = settings\n\n  // TODO: Batch insert\n  const project = await CoreContext.compositor.createProject(\n    {\n      props: {\n        name: 'Root',\n        type: 'sceneless-project',\n        sourceType: 'Element',\n        layout: 'Layered',\n        size,\n        isRoot: true,\n        tagName: 'div',\n        fields: {\n          style: { background: 'black' },\n        },\n      },\n    },\n    layoutId,\n  )\n  const root = project.getRoot()\n\n  // Create the base nodes for sceneless workflow\n  const baseLayers = await Promise.all([\n    project.insert(\n      {\n        name: 'Background',\n        id: 'bg',\n        layout: 'Free',\n      },\n      root.id,\n    ),\n\n    project.insert(\n      {\n        id: 'content',\n        name: 'Content',\n        layout,\n        layoutProps,\n      },\n      root.id,\n    ),\n    project.insert(\n      {\n        id: 'foreground',\n        name: 'Overlays',\n        layout: 'Free',\n      },\n      root.id,\n    ),\n  ])\n  await project.reorder(root.id, baseLayers)\n\n  const foreground = root.children.find((x) => x.props.id === 'foreground')\n\n  const baseForegroundLayers = await Promise.all([\n    project.insert(\n      {\n        name: 'ImageOverlay',\n        id: 'fg-image',\n        layout: 'Free',\n      },\n      foreground.id,\n    ),\n    project.insert(\n      {\n        name: 'BannerContainer',\n        id: 'fg-banners',\n        // NOTE: This is not ideal - currently only using layout\n        //  \"Column\" for its built-in animations\n        layout: 'Column',\n        layoutProps: {\n          cover: true,\n        },\n      },\n      foreground.id,\n    ),\n    project.insert(\n      {\n        name: 'VideoOverlay',\n        id: 'fg-video',\n        layout: 'Free',\n      },\n      foreground.id,\n    ),\n  ])\n\n  await project.reorder(foreground.id, baseForegroundLayers)\n\n  const background = root.children.find((x) => x.props.id === 'bg')\n\n  const baseBackgroundLayers = await Promise.all([\n    project.insert(\n      {\n        name: 'ImageBackground',\n        id: 'bg-image',\n        tagName: 'img',\n        sourceType: 'Element',\n        attributes: {\n          src: backgroundImage,\n        },\n      },\n      background.id,\n    ),\n  ])\n\n  await project.reorder(background.id, baseBackgroundLayers)\n\n  return project\n}\n","/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\n/**\n * Requests provide single-concern abstractions\n *  over the various backend APIs (Layout/Live).\n *\n * Not every external request is represented here. In some cases\n *  it is simpler to use the API SDK client interface directly.\n */\nimport {\n  CoreContext,\n  InternalProject,\n  InternalSource,\n  InternalUser,\n} from './context'\nimport { getAccessTokenData, getProject, getUser, hydrateProject } from './data'\nimport { Helpers } from '.'\nimport { Props, Role } from './types'\nimport { LiveApiModel } from '@api.stream/sdk'\n\nexport const createProject = async (request: {\n  settings?: { [prop: string]: any }\n  props?: Props // Arbitrary metadata (e.g. 'name')\n  size?: { x: number; y: number }\n  type?: 'sceneless' | 'freeform'\n}) => {\n  const collectionId = getUser().id\n  const type = request.type || 'sceneless'\n  const size = request.size || {\n    x: 1280,\n    y: 720,\n  }\n  const settings = request.settings || {}\n\n  // Create a project to go with the collection\n  let createProjectResponse = await CoreContext.clients\n    .LiveApi()\n    .project.createProject({\n      collectionId,\n      rendering: {\n        video: {\n          width: size.x,\n          height: size.y,\n          framerate: 30,\n        },\n      },\n      composition: {\n        studioSdk: {},\n      },\n      metadata: {},\n      webrtc: {\n        hosted: {},\n      },\n    })\n\n  const layout = await CoreContext.clients.LayoutApi().layout.createLayout({\n    layout: {\n      projectId: createProjectResponse.project.projectId,\n      collectionId: createProjectResponse.project.collectionId,\n    },\n  })\n\n  const { displayName } = getAccessTokenData()\n\n  // Save the layoutId on the project (no need to await)\n  const metadata = {\n    type,\n    layoutId: layout.id,\n    hostDisplayName: displayName,\n    props: request.props || {},\n  }\n  let projectResponse = await CoreContext.clients\n    .LiveApi()\n    .project.updateProject({\n      collectionId,\n      projectId: createProjectResponse.project.projectId,\n      updateMask: ['metadata'],\n      metadata,\n    })\n  createProjectResponse.project = projectResponse.project\n  createProjectResponse.project.metadata = metadata\n\n  if (type === 'sceneless') {\n    await Helpers.ScenelessProject.createCompositor(layout.id, size, settings)\n  } else {\n    await CoreContext.compositor.createProject(\n      {\n        props: {\n          name: 'Root',\n          layout: 'Free',\n          ...settings,\n          isRoot: true,\n          size,\n        },\n      },\n      layout.id,\n    )\n  }\n\n  return createProjectResponse\n}\n\nexport const deleteProject = async (request: { projectId: string }) => {\n  const { projectId } = request\n  const project = getProject(projectId)\n  const collectionId = getUser().id\n\n  await Promise.all([\n    CoreContext.clients.LiveApi().project.deleteProject({\n      collectionId,\n      projectId,\n    }),\n    CoreContext.clients.LayoutApi().layout.deleteLayout({\n      layoutId: project.layoutApi.layoutId,\n    }),\n  ])\n}\n\n/**\n * Load the user data from whatever access token has been registered\n *  with the API.\n */\nexport const loadUser = async (): Promise<{\n  user: InternalUser\n  projects: InternalProject[]\n  sources: InternalSource[]\n}> => {\n  const collections = await loadCollections()\n\n  let collection: LiveApiModel.Collection\n\n  const { displayName, serviceUserId } = getAccessTokenData()\n\n  // Get a single collection, corresponding to a user\n  if (collections.length === 0) {\n    // If the user has no collections, create one\n    const response = await CoreContext.clients\n      .LiveApi()\n      .collection.createCollection({\n        metadata: {\n          serviceUserId,\n          displayName,\n          props: {},\n        },\n      })\n    collection = response.collection\n  } else {\n    // only 1 collection per user for studio-kit\n    collection = collections[0]\n  }\n\n  await CoreContext.clients\n    .LiveApi()\n    .subscribeToCollection(collection.collectionId)\n\n  // Take the Vapi Project and hydrate it with Compositor and Lapi project details\n  const projects = await Promise.all(\n    collection.projects.map((project) => hydrateProject(project, 'ROLE_HOST' as Role)),\n  )\n\n  return {\n    user: {\n      id: collection.collectionId,\n      metadata: collection.metadata,\n      props: collection.metadata?.props || {},\n      name: displayName,\n    },\n    projects,\n    sources: collection.sources,\n  }\n}\n\nexport const loadCollections = async () => {\n  let result = await CoreContext.clients.LiveApi().collection.getCollections({})\n  return result.collections\n}\n"],"names":["createCompositor","layoutId","size","settings","backgroundImage","layout","layoutProps","project","CoreContext","compositor","createProject","props","name","type","sourceType","isRoot","tagName","fields","style","background","root","getRoot","baseLayers","Promise","all","insert","id","reorder","foreground","children","find","x","baseForegroundLayers","cover","baseBackgroundLayers","attributes","src","request","collectionId","getUser","y","createProjectResponse","clients","LiveApi","rendering","video","width","height","framerate","composition","studioSdk","metadata","webrtc","hosted","LayoutApi","createLayout","projectId","displayName","getAccessTokenData","hostDisplayName","projectResponse","updateProject","updateMask","Helpers","deleteProject","getProject","deleteLayout","layoutApi","loadUser","collections","loadCollections","collection","serviceUserId","length","response","createCollection","subscribeToCollection","projects","map","hydrateProject","user","sources","result","getCollections"],"mappings":"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"}