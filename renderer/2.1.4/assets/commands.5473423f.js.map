{"version":3,"file":"commands.5473423f.js","sources":["../../../../src/core/commands.ts"],"sourcesContent":["/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\n/**\n * Commands represent actions that can be taken by a user.\n *\n * Most commands accept a contextual parameter `projectId`.\n * If this parameter is excluded from a function call, the user's\n * active project will be used instead.\n *\n * Upon completion, a command may emit zero or more {@link EventMap Events}. Commands\n * return Promises that will attempt to resolve to the most pertinent value.\n * However, it is good practice to instead rely on events where possible, when\n * updating application state.\n *\n * For example, listening for the event `BroadcastStarted` will indicate\n * the following scenarios:\n *\n *   - The current user has initiated a broadcast\n *   - A collaborator (or host) has initiated a broadcast\n *   - Some external force has initiated a broadcast\n *\n * When depending on the Event rather than the command's return value, we can\n * be sure that our state is updating under all relevant circumstances.\n *\n * ----\n *\n * _Note: Commands marked `internal` are low-level commands that should only be\n * used with caution. Higher-level abstractions should be used to manipulate Nodes\n * (elements on the stream canvas)._\n *\n * @private This module is currently hidden from users of the Studio Kit.\n *  Favor the creation of helpers when supporting developers who require\n *  functionality contained in this module.\n *\n * @module Commands\n */\n\nimport {\n  getProject,\n  getUser,\n  hydrateProject,\n  toBaseDestination,\n  toBaseProject,\n} from './data'\nimport { CoreContext } from './context'\nimport decode from 'jwt-decode'\nimport { Props } from './types'\nimport { SDK } from './namespaces'\nimport { LiveApiModel } from '@api.stream/sdk'\nimport { webrtcManager } from './webrtc'\nimport { getRoom } from './webrtc/simple-room'\nimport { trigger, triggerInternal } from './events'\n\nconst { state } = CoreContext\n\n/**\n * Update the current user's metadata with custom data opaque to the SDK.\n * Existing props are not affected unless explicitly overwritten.\n *\n * @category User\n */\nexport const updateUserProps = async (payload: {\n  /** Arbitrary metadata to associate with the user */\n  props?: Props\n}) => {\n  const collection = getUser()\n  if (!collection) return\n\n  const props = {\n    ...collection.props,\n    ...payload.props,\n  }\n  const response = await CoreContext.clients\n    .LiveApi()\n    .collection.updateCollection({\n      collectionId: collection.id,\n      updateMask: ['metadata'],\n      metadata: {\n        ...collection.metadata,\n        props,\n      },\n    })\n\n  // Trigger event to update state\n  await triggerInternal('UserChanged', response.collection)\n  return\n}\n\n/**\n * Create a source\n *\n * @category Source\n */\nexport const createSource = async (payload: {\n  projectId: string\n  displayName?: string\n}) => {\n  const collectionId = getUser().id\n\n  const { source } = await CoreContext.clients.LiveApi()\n    .source\n    .createSource({\n      metadata: {},\n      collectionId,\n      address: {\n        rtmpPush: {\n          enabled: true,\n        },\n      },\n      preview: {\n        webrtc: {\n          enabled: true,\n          displayName: payload.displayName || 'RTMP Source',\n        },\n      },\n    })\n\n  // Trigger event to update state\n  await triggerInternal('SourceAdded', source)\n\n  // Add source to project\n\n  const response = await CoreContext.clients.LiveApi()\n    .source\n    .addSourceToProject({\n      collectionId,\n      projectId: payload.projectId,\n      sourceId: source.sourceId,\n    })\n\n  await triggerInternal('ProjectSourceAdded', {\n    projectId: response.project.projectId,\n    source,\n  })\n\n  return source\n}\n\n/**\n * Get all sources in the collection\n *\n * @category Source\n */\nconst getSources = async () => {\n  const collectionId = getUser().id\n\n  const { sources } = await CoreContext.clients.LiveApi()\n    .source\n    .getSources({ collectionId })\n\n  return sources\n}\n\nconst getSource = async (payload: { sourceId: string }) => {\n  const collectionId = getUser().id\n\n  const { source } = await CoreContext.clients.LiveApi()\n    .source\n    .getSource({\n      collectionId,\n      sourceId: payload.sourceId,\n    })\n\n  return source\n}\n\n\n/**\n * Update a source metadata and/or displayName\n *\n * @category Source\n */\nexport const updateSource = async (payload: {\n  sourceId: string\n  metadata?: any\n  displayName?: string\n}) => {\n  const collectionId = getUser().id\n  let updateMask: string[] = []\n  let updateProps: Partial<LiveApiModel.UpdateSourceRequest> = {}\n  if (payload.metadata) {\n    updateMask.push('metadata')\n    updateProps.metadata = payload.metadata\n  }\n  if (payload.displayName) {\n    updateMask.push('preview.webrtc.displayName')\n    updateProps = {\n      ...updateProps,\n      preview: {\n        webrtc: {\n          displayName: payload.displayName,\n        }\n      }\n    }\n  }\n  const { source } = await CoreContext.clients.LiveApi()\n    .source\n    .updateSource({\n      collectionId,\n      updateMask,\n      sourceId: payload.sourceId,\n      ...updateProps,\n    })\n\n  // Trigger event to update state\n  await triggerInternal('SourceChanged', source)\n\n  return source\n}\n\n\n/**\n * Delete a source\n *\n * @category Source\n */\nexport const deleteSource = async (payload: { projectId: string, sourceId: string, force?: boolean }) => {\n  const collectionId = getUser().id\n  const removeRes = await CoreContext.clients.LiveApi()\n    .source\n    .removeSourceFromProject({\n      collectionId,\n      projectId: payload.projectId,\n      sourceId: payload.sourceId,\n    })\n\n  await triggerInternal('ProjectSourceRemoved', {\n    projectId: payload.projectId,\n    sourceId: payload.sourceId,\n  })\n\n  const response = await CoreContext.clients\n    .LiveApi()\n    .source\n    .deleteSource({ sourceId: payload.sourceId, collectionId })\n\n  await triggerInternal('SourceRemoved', payload.sourceId)\n  return response\n}\n\n\n/**\n * Create a project with optional metadata.\n *\n * ----\n * _Note: This is a low level function that necessitates careful management\n *  of the nodes within. Consider {@link ScenelessProject.create} instead._\n *\n * @category Project\n */\nexport const createProject = async (\n  payload: {\n    /** @private Settings associated with ScenelessProject (or other such wrapper) */\n    settings?: { [prop: string]: any }\n    /** Arbitrary metadata to associate with this project */\n    props?: Props\n    /** Pixel dimenions of the canvas (default: `{ x: 1280, y: 720 }`) */\n    size?: { x: number; y: number }\n  } = {},\n) => {\n  const { props = {}, size, settings = {} } = payload\n  const response = await CoreContext.Request.createProject({\n    settings,\n    props,\n    size,\n  })\n\n  // Trigger event to update state\n  await triggerInternal('ProjectAdded', response.project)\n\n  // Return the base project directly, for convenience\n  const internalProject = await hydrateProject(\n    response.project,\n    'ROLE_HOST' as SDK.Role,\n  )\n  return toBaseProject(internalProject)\n}\n\n/**\n * @private\n * Recreate a project's associated layout\n */\nexport const recreateLayout = async (payload: {\n  projectId: string\n  props?: Props\n}) => {\n  const { projectId, props = {} } = payload\n  const collectionId = getUser().id\n\n  // Get the Vapi project\n  const response = await CoreContext.clients.LiveApi().project.getProject({\n    collectionId,\n    projectId,\n    status: true,\n  })\n\n  // Return if the project is actively broadcasting\n  if (\n    [\n      SDK.ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING,\n      SDK.ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STARTING,\n    ].includes(response.status.phase)\n  ) {\n    return\n  }\n\n  const metadata = response.project.metadata || {}\n  const { layoutId } = metadata\n  const { video } = response.project.rendering\n  const { type } = response.project.metadata.props || {}\n\n  // Create the new layout\n  const layout = await CoreContext.Request.createLayout({\n    collectionId,\n    projectId,\n    type: type || 'sceneless',\n    settings: {},\n    size: {\n      x: video.width,\n      y: video.height,\n    },\n  })\n\n  // Set the new layout on the project\n  const updateResponse = await CoreContext.clients\n    .LiveApi()\n    .project.updateProject({\n      collectionId,\n      projectId,\n      updateMask: ['metadata'],\n      metadata: {\n        ...metadata,\n        layoutId: layout.id,\n      },\n    })\n\n  CoreContext.log.debug('New layout assigned to project:', { layout })\n\n  // Trigger event to update state\n  await triggerInternal('ProjectChanged', { project: updateResponse.project })\n\n  // Delete the previous layout\n  await CoreContext.clients.LayoutApi().layout.deleteLayout({\n    layoutId,\n  })\n\n  CoreContext.log.debug('Previous layout deleted:', { layoutId })\n\n  // Return the base project directly, for convenience\n  const internalProject = await hydrateProject(\n    updateResponse.project,\n    'ROLE_HOST' as SDK.Role,\n  )\n\n  // Add props to the root node\n  await internalProject.compositor.update(\n    internalProject.compositor.getRoot().id,\n    props,\n  )\n\n  /** return original project as well as internal project */\n  return { project: toBaseProject(internalProject), internalProject }\n}\n/**\n * Delete a project.\n *\n * @category Project\n */\nexport const deleteProject = async (payload: {\n  projectId: SDK.Project['id']\n}) => {\n  const { projectId } = payload\n  await CoreContext.Request.deleteProject({\n    projectId,\n  })\n\n  // Trigger event to update state\n  await triggerInternal('ProjectRemoved', { projectId })\n  return\n}\n\n/**\n * Update a project's metadata with custom data opaque to the SDK.\n * Existing props are not affected unless explicitly overwritten.\n *\n * @category Project\n */\nexport const updateProjectProps = async (payload: {\n  projectId: SDK.Project['id']\n  /** Arbitrary metadata to associate with this project */\n  props?: Props\n}) => {\n  const { projectId } = payload\n  const collectionId = getUser().id\n  const project = getProject(projectId)\n\n  const props = {\n    ...project.props,\n    ...payload.props,\n  }\n  const response = await CoreContext.clients.LiveApi().project.updateProject({\n    collectionId,\n    projectId,\n    updateMask: ['metadata'],\n    metadata: {\n      ...project.videoApi.project.metadata,\n      props,\n    },\n  })\n\n  // Trigger event to update state\n  await triggerInternal('ProjectChanged', { project: response.project })\n  return\n}\n/**\n * @deprecated Use updateProjectProps\n */\nexport const updateProjectMeta = (payload: {\n  projectId: SDK.Project['id']\n  /** Arbitrary metadata to associate with this project */\n  meta?: Props\n}) => updateProjectProps({ projectId: payload.projectId, props: payload.meta })\n\n/**\n * @private Use updateProjectProps without internaltriggers\n */\nexport const updateProjectPropsWithoutTrigger = async (payload: {\n  projectId: SDK.Project['id']\n  /** Arbitrary metadata to associate with this project */\n  props?: Props\n}) => {\n  const { projectId } = payload\n  const collectionId = getUser().id\n  const project = getProject(projectId)\n\n  const props = {\n    ...project.props,\n    ...payload.props,\n  }\n  const response = await CoreContext.clients.LiveApi().project.updateProject({\n    collectionId,\n    projectId,\n    updateMask: ['metadata'],\n    metadata: {\n      ...project.videoApi.project.metadata,\n      props,\n    },\n  })\n  return\n}\n\n/**\n * Set the active project for the user, setting up event handlers and\n *  disposing of event listeners for the previous active project.\n *\n * This project will be used as the default project\n *  for commands that do not specify `payload.projectId`\n *\n * @category Project\n */\nexport const setActiveProject = async (payload: {\n  projectId: SDK.Project['id']\n}): Promise<SDK.Project> => {\n  const project = state.projects.find((x) => x.id === payload.projectId)\n  if (!project) {\n    state.activeProjectId = null\n    triggerInternal('ActiveProjectChanged', { projectId: null })\n    return\n  }\n\n  const currentProject = state.projects.find(\n    (x) => x.id === state.activeProjectId,\n  )\n  if (project === currentProject) return\n  if (currentProject) {\n    // Perform any necessary cleanup\n    Array.from(webrtcManager.rooms.keys()).map(webrtcManager.removeRoom)\n    await CoreContext.clients\n      .LayoutApi()\n      .unsubscribeFromLayout(currentProject.layoutApi.layoutId)\n    await CoreContext.clients\n      .LiveApi()\n      .unsubscribeFromProject(\n        currentProject.videoApi.project.collectionId,\n        currentProject.videoApi.project.projectId,\n      )\n  }\n\n  await CoreContext.clients\n    .LayoutApi()\n    .subscribeToLayout(project.layoutApi.layoutId)\n  await CoreContext.clients\n    .LiveApi()\n    .subscribeToProject(\n      project.videoApi.project.collectionId,\n      project.videoApi.project.projectId,\n    )\n\n  // Asynchronously ensure latest project state\n  CoreContext.clients\n    .LiveApi()\n    .project.getProject({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      status: true,\n    })\n    .then((response) => {\n      triggerInternal('ProjectChanged', {\n        project: response.project,\n        phase: response.status?.phase,\n        broadcastId: response.status?.broadcastId,\n      })\n    })\n\n  triggerInternal('ActiveProjectChanged', {\n    projectId: project.id,\n  })\n  return toBaseProject(project)\n}\n\n/**\n * Initiate WebRTC connection to the room associated with this project.\n *\n * @category Project\n */\nexport const joinRoom = async (payload: {\n  projectId: SDK.Project['id']\n  /** A public name for other guests will see associated with your {@link Participant} */\n  displayName?: string\n}) => {\n  const { projectId, displayName = 'Guest' } = payload\n  const project = state.projects.find((x) => x.id === projectId)\n\n  // Get the SFU token\n  let token = project.sfuToken\n  if (!token) {\n    let { webrtcAccess } = await CoreContext.clients\n      .LiveApi()\n      .authentication.createWebRtcAccessToken({\n        collectionId: project.videoApi.project.collectionId,\n        projectId: project.videoApi.project.projectId,\n        displayName,\n      })\n    token = webrtcAccess.accessToken\n  }\n  const tokenData = decode(token) as any\n  const roomName = tokenData.video.room\n  const url = new URL(CoreContext.clients.getLiveKitServer())\n  const baseUrl = url.host + url.pathname\n  const roomContext = webrtcManager.ensureRoom(baseUrl, roomName, token)\n  roomContext.bindApiClient(CoreContext.clients)\n  await roomContext.connect()\n\n  project.sfuToken = token\n  project.roomId = roomName\n  const room = getRoom(roomName)\n  trigger('RoomJoined', {\n    projectId: project.id,\n    room,\n  })\n  return room\n}\n\n/**\n * Create a node within the project's scene tree.\n * A node is functionally comparable to a DOM Node - it serves only as a vessel\n * of properties.\n *\n * A node is not inherently useful. It is up to the renderer to interpret the data it holds.\n * If a node is given data the renderer is not aware of, it will accomplish nothing.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const createNode = async (payload: {\n  projectId?: string\n  props?: { [prop: string]: any }\n  parentId: string\n  index?: number\n}) => {\n  let {\n    props = {},\n    parentId,\n    index,\n    projectId = state.activeProjectId,\n  } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  const nodeId = await project.compositor.insert(props, parentId, index)\n  triggerInternal('NodeAdded', { projectId, nodeId })\n  triggerInternal('NodeChanged', { projectId, nodeId: parentId })\n  return project.compositor.get(nodeId)\n}\n\n/**\n * Remove a node from the project's scene tree.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const deleteNode = async (payload: {\n  projectId?: string\n  nodeId: string\n}) => {\n  let { nodeId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  const parentId = project.compositor.getParent(nodeId)?.id\n\n  // Update state\n  project.compositor.remove(nodeId)\n  triggerInternal('NodeRemoved', { projectId, nodeId })\n  triggerInternal('NodeChanged', { projectId, nodeId: parentId })\n}\n\n/**\n * Update the properties of a node.\n * `payload.props` will be shallowly merged onto its existing `props`.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const updateNode = async (payload: {\n  projectId?: string\n  nodeId: string\n  props: { [prop: string]: any }\n}) => {\n  let { nodeId, props = {}, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  // Prune protected fields\n  delete props.type\n  delete props.sourceType\n\n  // Update state\n  project.compositor.update(nodeId, props)\n  triggerInternal('NodeChanged', { projectId, nodeId })\n  return project.compositor.get(nodeId)\n}\n\n/**\n * Update the layout of a node.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const setNodeLayout = async (payload: {\n  projectId?: string\n  nodeId: string\n  layout: string\n  layoutProps?: { [prop: string]: any }\n}) => {\n  let {\n    nodeId,\n    layout,\n    projectId = state.activeProjectId,\n    layoutProps = {},\n  } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  project.compositor.update(nodeId, {\n    layout,\n    layoutProps,\n  })\n  triggerInternal('NodeChanged', { projectId, nodeId })\n}\n\n/**\n * Move a node to a different parent node.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const moveNode = async (payload: {\n  projectId?: string\n  nodeId: string\n  parentId: string\n  index?: number\n}) => {\n  const { nodeId, parentId, projectId = state.activeProjectId, index } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  project.compositor.move(nodeId, parentId, index)\n  // TODO: Determine if this is necessary (likely need only the events from Event API)\n  triggerInternal('NodeChanged', { projectId, nodeId })\n}\n\n/**\n * Swap the positions of two nodes, changing parents if necessary.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const swapNodes = async (payload: {\n  projectId?: string\n  nodeAId: string\n  nodeBId: string\n}) => {\n  const { nodeAId, nodeBId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  const parentAId = project.compositor.getParent(nodeAId)?.id\n  const parentBId = project.compositor.getParent(nodeBId)?.id\n\n  // Update state\n  project.compositor.swap(nodeAId, nodeBId)\n  triggerInternal('NodeChanged', { projectId, nodeId: parentAId })\n  triggerInternal('NodeChanged', { projectId, nodeId: parentBId })\n}\n\n/**\n * Change the order of a node's children.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const reorderNodes = async (payload: {\n  projectId?: string\n  parentId: string\n  childIds: string[]\n}) => {\n  const { parentId, childIds, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  project.compositor.reorder(parentId, childIds)\n  triggerInternal('NodeChanged', { projectId, nodeId: parentId })\n}\n\n/**\n * Start broadcasting a project.\n *\n * ----\n * _Note: Destination, encoding, and rendering details will be read from the Project\n * at time of broadcast, so they should be updated ahead of time._\n *\n * @category Broadcast\n */\nexport const startBroadcast = async (payload: { projectId?: string }) => {\n  const { projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  await CoreContext.clients.LiveApi().project.startProjectBroadcast({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n  })\n  // Event is handled on receiving end of VideoAPI\n}\n\n/**\n * Stop broadcasting a project.\n *\n * @category Broadcast\n */\nexport const stopBroadcast = async (payload: { projectId?: string }) => {\n  const { projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  await CoreContext.clients.LiveApi().project.stopProjectBroadcast({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n  })\n  // Event is handled on receiving end of VideoAPI\n}\n\n/**\n * Add a {@link Destination} to a project.\n *\n * @category Destination\n */\nexport const addDestination = async (payload: {\n  projectId?: string\n  rtmpUrl: string\n  rtmpKey: string\n  enabled: boolean\n  props?: Props\n  /** @deprecated Use `props` */\n  metadata?: Props\n}) => {\n  const {\n    rtmpUrl,\n    rtmpKey,\n    enabled,\n    projectId = state.activeProjectId,\n    metadata = {},\n    props = {},\n  } = payload\n  const project = getProject(projectId)\n  const address = {\n    rtmpPush: {\n      key: rtmpKey,\n      url: rtmpUrl,\n    },\n  } as SDK.Destination['address']\n\n  const response = await CoreContext.clients\n    .LiveApi()\n    .destination?.createDestination({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      address,\n      enabled,\n      metadata: {\n        props: {\n          ...metadata,\n          ...props,\n        },\n      },\n    })\n\n  // Trigger event to update state\n  await triggerInternal('DestinationAdded', response.destination)\n  return toBaseDestination(response.destination)\n}\n\n/**\n * Remove a {@link Destination} from the project.\n *\n * @category Destination\n */\nexport const removeDestination = async (payload: {\n  projectId?: string\n  destinationId: string\n}) => {\n  const { destinationId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  await CoreContext.clients.LiveApi().destination?.deleteDestination({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n    destinationId,\n  })\n\n  // Trigger event to update state\n  await triggerInternal('DestinationRemoved', { projectId, destinationId })\n  return\n}\n\n/**\n * Update an existing {@link Destination} on the project.\n *\n * @category Destination\n */\nexport const updateDestination = async (payload: {\n  projectId?: string\n  destinationId: string\n  rtmpUrl: string\n  rtmpKey: string\n}) => {\n  const {\n    rtmpUrl,\n    rtmpKey,\n    destinationId,\n    projectId = state.activeProjectId,\n  } = payload\n  const project = getProject(projectId)\n\n  const rtmpPush = {\n    key: rtmpKey,\n    url: rtmpUrl,\n  }\n\n  const response = await CoreContext.clients\n    .LiveApi()\n    .destination?.updateDestination({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      destinationId,\n      updateMask: ['address.rtmpPush'],\n      address: {\n        rtmpPush,\n      },\n    })\n\n  // Trigger event to update state\n  await triggerInternal('DestinationChanged', response.destination)\n  return\n}\n\n/**\n * Update the metadata of an existing {@link Destination} on the project.\n *\n * @category Destination\n */\nexport const updateDestinationProps = async (payload: {\n  projectId: string\n  destinationId: string\n  props: Props\n}) => {\n  const {\n    projectId = state.activeProjectId,\n    destinationId,\n    props = {},\n  } = payload\n  const project = getProject(projectId)\n  const destination = project.videoApi.project.destinations.find(\n    (x) => x.destinationId === destinationId,\n  )\n  if (!destination) return\n\n  const response = await CoreContext.clients\n    .LiveApi()\n    .destination?.updateDestination({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      destinationId,\n      updateMask: ['metadata'],\n      metadata: {\n        ...(destination.metadata || {}),\n        props: {\n          ...(destination.metadata?.props || {}),\n          ...props,\n        },\n      },\n    })\n\n  // Trigger event to update state\n  await triggerInternal('DestinationChanged', response.destination)\n  return\n}\n/**\n * @deprecated Use updateDestinationProps\n */\nexport const updateDestinationMeta = (payload: {\n  projectId: string\n  destinationId: string\n  metadata?: Props\n}) =>\n  updateDestinationProps({\n    projectId: payload.projectId,\n    destinationId: payload.destinationId,\n    props: payload.metadata,\n  })\n\n/**\n * Enable or disable an existing {@link Destination} on the project.\n *\n * @category Destination\n */\nexport const setDestinationEnabled = async (payload: {\n  projectId?: string\n  destinationId: string\n  enabled: boolean\n}) => {\n  const { enabled, destinationId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  const destination = project.videoApi.project.destinations.find(\n    (x) => destinationId === x.destinationId,\n  )\n  if (destination.enabled === enabled) return\n\n  const response = await CoreContext.clients\n    .LiveApi()\n    .destination?.updateDestination({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      destinationId,\n      updateMask: ['enabled'],\n      enabled,\n    })\n\n  // Trigger event to update state\n  await triggerInternal('DestinationChanged', response.destination)\n\n  const event = enabled ? 'DestinationEnabled' : 'DestinationDisabled'\n  /** @deprecated Use DestinationChanged */\n  trigger(event, {\n    projectId,\n    destinationId,\n  })\n  return\n}\n\n/**\n * Overwrite project's first {@link Destination} with new configuration\n *  If no destination exists, one will be created instead.\n *\n * This is a helper to manage a single-destination project. For greater control,\n *  use {@link addDestination}, {@link removeDestination}, or {@link updateDestination}\n *\n * @category Destination\n */\nexport const setDestination = async (payload: {\n  projectId?: string\n  rtmpUrl: string\n  rtmpKey: string\n}) => {\n  const { rtmpUrl, rtmpKey, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  const rtmpPush = {\n    key: rtmpKey,\n    url: rtmpUrl,\n  }\n  const enabled = true\n\n  if (project.videoApi.project.destinations.length > 0) {\n    // Update existing\n    const response = await CoreContext.clients\n      .LiveApi()\n      .destination?.updateDestination({\n        collectionId: project.videoApi.project.collectionId,\n        projectId: project.videoApi.project.projectId,\n        destinationId: project.videoApi.project.destinations[0].destinationId,\n        updateMask: ['address.rtmpPush'],\n        address: { rtmpPush },\n      })\n\n    // Trigger event to update state\n    await triggerInternal('DestinationChanged', response.destination)\n  } else {\n    // Create new\n    const response = await CoreContext.clients\n      .LiveApi()\n      .destination?.createDestination({\n        collectionId: project.videoApi.project.collectionId,\n        projectId: project.videoApi.project.projectId,\n        address: { rtmpPush },\n        enabled,\n      })\n\n    // Trigger event to update state\n    await triggerInternal('DestinationAdded', response.destination)\n  }\n\n  /** @deprecated */\n  trigger('DestinationSet', {\n    projectId,\n    rtmpUrl,\n    rtmpKey,\n  })\n  return\n}\n"],"names":["state","CoreContext","updateUserProps","payload","collection","getUser","props","response","clients","LiveApi","updateCollection","collectionId","id","updateMask","metadata","triggerInternal","createSource","source","address","rtmpPush","enabled","preview","webrtc","displayName","addSourceToProject","projectId","sourceId","project","updateSource","updateProps","push","deleteSource","removeSourceFromProject","createProject","size","settings","Request","internalProject","hydrateProject","toBaseProject","recreateLayout","getProject","status","SDK","PROJECT_BROADCAST_PHASE_RUNNING","PROJECT_BROADCAST_PHASE_STARTING","includes","phase","layoutId","video","rendering","type","layout","createLayout","x","width","y","height","updateResponse","updateProject","log","debug","LayoutApi","deleteLayout","compositor","update","getRoot","deleteProject","updateProjectProps","videoApi","updateProjectMeta","meta","updateProjectPropsWithoutTrigger","setActiveProject","projects","find","activeProjectId","currentProject","Array","from","webrtcManager","rooms","keys","map","removeRoom","unsubscribeFromLayout","layoutApi","unsubscribeFromProject","subscribeToLayout","subscribeToProject","then","broadcastId","joinRoom","token","sfuToken","webrtcAccess","authentication","createWebRtcAccessToken","accessToken","roomName","tokenData","decode","room","url","URL","getLiveKitServer","baseUrl","host","pathname","roomContext","ensureRoom","bindApiClient","connect","roomId","getRoom","trigger","createNode","parentId","index","nodeId","insert","get","deleteNode","getParent","remove","updateNode","sourceType","setNodeLayout","layoutProps","moveNode","move","swapNodes","nodeAId","nodeBId","parentAId","parentBId","swap","reorderNodes","childIds","reorder","startBroadcast","startProjectBroadcast","stopBroadcast","stopProjectBroadcast","addDestination","rtmpUrl","rtmpKey","key","destination","createDestination","toBaseDestination","removeDestination","destinationId","deleteDestination","updateDestination","updateDestinationProps","destinations","updateDestinationMeta","setDestinationEnabled","setDestination","length"],"mappings":"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"}