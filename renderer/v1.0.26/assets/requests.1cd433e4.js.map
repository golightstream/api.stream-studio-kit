{"version":3,"file":"requests.1cd433e4.js","sources":["../../../../src/helpers/sceneless-project.ts","../../../../src/core/requests.ts"],"sourcesContent":["/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\n/**\n * Create and manage a project with a {@link ScenelessProject.Commands simple and opinionated interface}.\n *\n * A ScenelessProject is designed to fulfill all of the requirements of\n * a standard web-based broadcaster. It provides simple\n * management of WebRTC {@link Participant Participants},\n * custom layouts, backgrounds, and overlay content.\n *\n * Internally, any {@link Project} that meets a certain set of preconditions is\n * eligible to act as a ScenelessProject. The simplest way to ensure a project\n * can leverage these commands is by creating one with {@link create ScenelessProject.create()}.\n *\n * ```typescript\n * // Create a project for the user with default settings\n * const project = await ScenelessProject.create({\n *   backgroundImage: 'https://studio.golightstream.com/images/polygons.jpg',\n *   layout: 'Grid',\n * })\n *\n * // Pass the project in to receive a list of commands unique to a ScenelessProject\n * const projectCommands = ScenelessProject.commands(project)\n *\n * // Use the commands to update the project's contents (what participants/overlays will appear in the output stream)\n * projectCommands.addParticipant(participantId)\n * ```\n *\n * ----\n * _Note: When using a project interface such as this, avoid using\n * any {@link Command Commands} that operate on elements inside the project. This\n * includes any command which operates on a node (e.g. {@link Command.updateNode} or {@link Command.reorderNodes})._\n *\n * _This is an alternative to {@link Command.createProject}._\n *\n * @module ScenelessProject\n */\n\nimport * as Layout from '../compositor/html/html-layouts'\nimport { CoreContext } from '../core/context'\nimport { getProjectRoom } from '../core/data'\nimport { SDK, Compositor } from '../core/namespaces'\nimport { Disposable } from '../core/types'\nimport { Track } from 'livekit-client'\n\nimport LayoutName = Layout.LayoutName\nexport type { LayoutName }\n\nexport type ParticipantProps = {\n  volume: number\n  isMuted: boolean\n  isHidden: boolean\n}\n\n// Local cache to track participants being added\nconst addingCache = {\n  camera: new Set<string>(),\n  screen: new Set<string>(),\n}\n\nexport type ParticipantType = 'camera' | 'screen'\n\ninterface ScenelessProject extends SDK.Project {}\n\n// Note: Assume project is a valid sceneless project\n// Note: In the future commands will be returned by an argument of SceneNode\n\n// TODO: Define defaults\n// TODO: Define emits\n\n/**\n * These commands assist with management of WebRTC {@link Participant Participants},\n * custom layouts, backgrounds, and overlay content.\n *\n * Only a valid {@link ScenelessProject} can leverage these commands.\n */\nexport interface Commands {\n  /**\n   * Get the node that holds the stream's background\n   * @private\n   */\n  getBackground(): Compositor.SceneNode\n  /**\n   * Get the node that holds the stream's content\n   * @private\n   */\n  getContent(): Compositor.SceneNode\n  /**\n   * Get the node that holds the stream's foreground (overlays)\n   * @private\n   */\n  getForeground(): Compositor.SceneNode\n  /**\n   * Get the active layout\n   * @private\n   */\n  getLayout(): string\n  /**\n   * Set the active layout and associated layoutProps\n   */\n  setLayout(layout: LayoutName, layoutProps: LayoutProps): void\n  /**\n   * Get the active background image\n   */\n  getBackgroundImage(): string\n  /**\n   * Set the active background image\n   */\n  setBackgroundImage(src: string): void\n  /**\n   * Set one participant to \"showcase\". This participant will expand to fill\n   * the space of the stream without affecting the underlying layout.\n   */\n  setShowcase(\n    participantId: string,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): ReturnType<typeof CoreContext.Command.updateNode>\n  /**\n   * @hook\n   * Receive information about the showcased participant.\n   * As with other hooks, the callback will be invoked when its value changes.\n   */\n  useShowcase(\n    cb: (state: { participantId: string; type: ParticipantType }) => void,\n  ): Disposable\n  /**\n   * Add a participant to the stream canvas.\n   * Available participants can be gleaned from the WebRTC {@link Room} using\n   * {@link Room.useParticipants}.\n   *\n   * A participant will remain on stream even if there is no active feed, until\n   * it is removed using {@link removeParticipant removeParticipant()} or {@link pruneParticipants pruneParticipants()}.\n   */\n  addParticipant(\n    participantId: string,\n    props: Partial<ParticipantProps>,\n    /**\n     * The type of participant feed to add.\n     * @default `'camera'`\n     */\n    type?: ParticipantType,\n  ): Promise<void>\n  /**\n   * @private\n   * @deprecated Use addParticipant() with parameter `type`\n   */\n  addParticipantScreenshare(\n    participantId: string,\n    props: Partial<ParticipantProps>,\n  ): Promise<void>\n  /**\n   * Remove a stream participant from the stream canvas.\n   */\n  removeParticipant(participantId: string, type: ParticipantType): void\n  /**\n   * @private\n   * @deprecated Use removeParticipant() with parameter `type`\n   */\n  removeParticipantScreenshare(participantId: string): void\n  /**\n   * @private\n   * Get the node associated with a room participant\n   * */\n  getParticipantNode(\n    id: string,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): Compositor.SceneNode\n  /**\n   * Get {@link ParticipantProps} associated with a participant/type.\n   */\n  getParticipantState(\n    participantId: string,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): ParticipantProps\n  /**\n   * @hook\n   * Receive {@link ParticipantProps} associated with a participant/type\n   * via invoked callback anytime one of the property values changes.\n   */\n  useParticipantState(\n    participantId: string,\n    cb: (state: ParticipantProps) => void,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): Disposable\n  /**\n   * Change a participant's volume.\n   * This does not affect the underlying MediaStreamTrack.\n   */\n  setParticipantVolume(\n    participantId: string,\n    /**\n     * Accepted values from [0 - 1]\n     */\n    volume: number,\n  ): void\n  /**\n   * Mute a participant without changing their volume.\n   *  This does not affect the underlying MediaStreamTrack.\n   *\n   * Participants muted in this way will not stop sending\n   *  audio data, but it will not play on the receiving end.\n   *\n   * A host may use this to override a guest's settings\n   *  for the stream output.\n   */\n  setParticipantMuted(participantId: string, isMuted: boolean): void\n  /**\n   * Hide a participant video feed from the stream.\n   *  This does not affect the underlying MediaStreamTrack.\n   *\n   * Participants hidden in this way will not stop sending\n   *  video data, but it will not play on the receiving end.\n   *\n   * A host may use this to override a guest's settings\n   *  for the stream output.\n   */\n  setParticipantHidden(participantId: string, isHidden: boolean): void\n  /**\n   * Remove all participants from the stream canvas who are not actively\n   * sending a MediaStreamTrack for display.\n   */\n  pruneParticipants(): void\n}\n\n/**\n * Accepts a Project that was created using {@link ScenelessProject.create ScenelessProject.create()}\n * and returns several commands specialized for a Sceneless broadcasting experience.\n *\n * These commands assist with management of WebRTC {@link Participant Participants},\n * custom layouts, backgrounds, and overlay content.\n */\nexport const commands = (project: ScenelessProject) => {\n  const root = project.scene.getRoot()\n  const { Command } = CoreContext\n\n  const background = root.children.find((x) => x.props.id === 'bg')\n  const content = root.children.find((x) => x.props.id === 'content')\n  const foreground = root.children.find((x) => x.props.id === 'foreground')\n\n  const commands: Commands = {\n    getBackground() {\n      return background\n    },\n    getContent() {\n      return content\n    },\n    getForeground() {\n      return foreground\n    },\n    getLayout() {\n      return content.props.layout\n    },\n    setLayout(layout: LayoutName, layoutProps: LayoutProps = {}) {\n      const showcase = content.props.layoutProps.showcase\n      Command.setNodeLayout({\n        nodeId: content.id,\n        layout,\n        layoutProps: {\n          showcase,\n          ...layoutProps,\n        },\n      })\n    },\n    getBackgroundImage() {\n      return background.props.attributes.src\n    },\n    setBackgroundImage(src: string) {\n      CoreContext.Command.updateNode({\n        nodeId: background.id,\n        props: {\n          attributes: {\n            ...background.props.attributes,\n            src,\n          },\n        },\n      })\n    },\n    setShowcase(participantId: string, type: ParticipantType = 'camera') {\n      const node = commands.getParticipantNode(participantId, type)\n      return CoreContext.Command.updateNode({\n        nodeId: content.id,\n        props: {\n          layoutProps: {\n            ...content.props.layoutProps,\n            showcase: node?.id ?? null,\n          },\n        },\n      })\n    },\n    useShowcase(\n      cb: (state: { participantId: string; type: ParticipantType }) => void,\n    ) {\n      const sendState = () => {\n        const nodeId = content.props.layoutProps.showcase\n        const node = content.children.find((x) => x.id === nodeId)\n        if (!node)\n          return cb({\n            participantId: null,\n            type: null,\n          })\n\n        const { sourceProps } = node.props\n        return cb({\n          participantId: sourceProps.id,\n          type: sourceProps.type,\n        })\n      }\n      sendState()\n\n      // Watch for changes to the parent children\n      return CoreContext.onInternal('NodeChanged', (payload) => {\n        if (payload.nodeId !== content.id) return\n        sendState()\n      })\n    },\n    async addParticipant(\n      participantId: string,\n      props: Partial<ParticipantProps> = {},\n      type: ParticipantType = 'camera',\n    ) {\n      if (addingCache[type].has(participantId)) return\n\n      const { isMuted = false, isHidden = false, volume = 1 } = props\n      const existing = content.children.find(\n        (x) =>\n          x.props.sourceProps?.id === participantId &&\n          x.props.sourceProps?.type === type,\n      )\n      if (existing) return\n\n      addingCache[type].add(participantId)\n      await CoreContext.Command.createNode({\n        props: {\n          sourceType: 'RoomParticipant',\n          sourceProps: {\n            type,\n            id: participantId,\n          },\n          volume,\n          isMuted,\n          isHidden,\n        },\n        parentId: content.id,\n        index: content.children.length,\n      }).finally(() => {\n        addingCache[type].delete(participantId)\n      })\n    },\n    addParticipantScreenshare(\n      participantId: string,\n      props: Partial<ParticipantProps> = {},\n    ) {\n      return commands.addParticipant(participantId, props, 'screen')\n    },\n    removeParticipant(participantId: string, type: ParticipantType = 'camera') {\n      content.children\n        .filter(\n          (x) =>\n            x.props.sourceProps?.id === participantId &&\n            x.props.sourceProps?.type === type &&\n            x.props.sourceType === 'RoomParticipant',\n        )\n        .forEach((x) => {\n          CoreContext.Command.deleteNode({\n            nodeId: x.id,\n          })\n        })\n    },\n    removeParticipantScreenshare(participantId: string) {\n      return commands.removeParticipant(participantId, 'screen')\n    },\n    getParticipantNode(id: string, type: ParticipantType = 'camera') {\n      return content.children.find(\n        (x) =>\n          x.props.sourceProps?.id === id && x.props.sourceProps?.type === type,\n      )\n    },\n    getParticipantState(\n      participantId: string,\n      type: ParticipantType = 'camera',\n    ) {\n      return commands.getParticipantNode(participantId, type)\n        ?.props as ParticipantProps\n    },\n    useParticipantState(\n      participantId: string,\n      cb: (state: ParticipantProps) => void,\n      type = 'camera' as ParticipantType,\n    ) {\n      let participantNode = commands.getParticipantNode(participantId, type)\n\n      const sendState = () => {\n        cb(participantNode?.props as ParticipantProps)\n      }\n\n      // Watch for changes to the parent children\n      const childListener = CoreContext.onInternal('NodeChanged', (payload) => {\n        if (payload.nodeId !== content.id) return\n        const previous = participantNode\n        participantNode = commands.getParticipantNode(participantId)\n        if (previous !== participantNode) {\n          sendState()\n        }\n      })\n\n      // Watch for changes to the participant node\n      const participantListener = CoreContext.onInternal(\n        'NodeChanged',\n        (payload) => {\n          if (!participantNode || payload.nodeId !== participantNode.id) return\n          sendState()\n        },\n      )\n\n      sendState()\n\n      // Return disposable for listener\n      return () => {\n        childListener()\n        participantListener()\n      }\n    },\n    setParticipantVolume(participantId: string, volume: number) {\n      const node = commands.getParticipantNode(participantId)\n      if (!node) return\n      CoreContext.Command.updateNode({\n        nodeId: node.id,\n        props: {\n          volume,\n        },\n      })\n    },\n    setParticipantMuted(participantId: string, isMuted: boolean) {\n      const node = commands.getParticipantNode(participantId)\n      if (!node) return\n      CoreContext.Command.updateNode({\n        nodeId: node.id,\n        props: {\n          isMuted,\n        },\n      })\n    },\n    setParticipantHidden(participantId: string, isHidden: boolean) {\n      const node = commands.getParticipantNode(participantId)\n      if (!node) return\n      CoreContext.Command.updateNode({\n        nodeId: node.id,\n        props: {\n          isHidden,\n        },\n      })\n    },\n    pruneParticipants() {\n      // Remove all participant nodes that do not have active tracks\n      const room = getProjectRoom(project.id)\n      if (!room) return\n\n      content.children\n        .filter((node) => {\n          if (node.props.sourceType !== 'RoomParticipant') return false\n          const nodeSourceType = node.props.sourceProps?.type\n\n          // Get the participant associated with the node\n          const nodeParticipant = room.getParticipant(\n            node.props.sourceProps?.id,\n          )\n          // If the participant is not in the room, remove the node\n          if (!nodeParticipant) return true\n\n          // Keep \"camera\" nodes around as long as the participant is available.\n          //  This is to facilitate camera switching or other such feed interruptions\n          if (nodeSourceType === 'camera') return false\n\n          // Get all tracks associated with the node's participant\n          const participantTracks = nodeParticipant.trackIds\n            .map((x) => room.getTrack(x))\n            .filter(Boolean)\n\n          // Determine whether there is a track available to the node\n          const hasAvailableTrack = participantTracks.some((track) => {\n            // Get the source type as it corresponds to the track's type\n            const sourceType =\n              track.type === Track.Source.Camera ||\n              track.type === Track.Source.Microphone\n                ? 'camera'\n                : 'screen'\n\n            // Return true if the node source has a matching track\n            return sourceType === nodeSourceType\n          })\n\n          return !hasAvailableTrack\n        })\n        .forEach((x) => {\n          CoreContext.Command.deleteNode({\n            nodeId: x.id,\n          })\n        })\n    },\n  }\n  return commands\n}\n\nexport type LayoutProps = {\n  cover?: boolean\n  /** Valid CSS for justify-content */\n  justifyViewers?: 'flex-end' | 'center' | 'flex-start'\n  /** Percentage */\n  barWidth?: number\n  barPosition?: 'bottom' | 'side'\n  useGrid?: boolean\n}\ntype ScenelessSettings = {\n  backgroundImage?: string\n  layout?: string\n  layoutProps?: LayoutProps\n}\n\n/**\n * **An abstraction over {@link Command.createProject Command.createProject()}.**\n *\n * A Project created using this function will be compatible with {@link ScenelessProject.commands ScenelessProject.commands()}\n *\n * **Emits: ProjectAdded**\n */\nexport const create = async (\n  settings: ScenelessSettings = {},\n  props: SDK.Props = {},\n) => {\n  return CoreContext.Command.createProject({\n    settings,\n    props,\n  }) as Promise<ScenelessProject>\n}\n\n/** @private */\nexport const createCompositor = async (\n  layoutId: string,\n  size: { x: number; y: number },\n  settings: ScenelessSettings,\n) => {\n  const { backgroundImage, layout, layoutProps = {} } = settings\n\n  // TODO: Batch insert\n  const project = await CoreContext.compositor.createProject(\n    {\n      props: {\n        name: 'Root',\n        type: 'sceneless-project',\n        layout: 'Layered',\n        size,\n        isRoot: true,\n      },\n    },\n    layoutId,\n  )\n  const root = project.getRoot()\n\n  // Create the base nodes for sceneless workflow\n  const baseLayers = await Promise.all([\n    project.insert(\n      {\n        name: 'Background',\n        id: 'bg',\n        tagName: 'img',\n        sourceType: 'Element',\n        attributes: {\n          src: backgroundImage,\n        },\n        style: {\n          objectFit: 'cover',\n        },\n      },\n      root.id,\n    ),\n    project.insert(\n      {\n        id: 'content',\n        name: 'Content',\n        layout,\n        layoutProps,\n      },\n      root.id,\n    ),\n    project.insert(\n      {\n        id: 'foreground',\n        name: 'Overlays',\n        layout: 'Free',\n      },\n      root.id,\n    ),\n  ])\n  await project.reorder(root.id, baseLayers)\n  return project\n}\n","/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\n/**\n * Requests provide single-concern abstractions\n *  over the various backend APIs (Layout/Live).\n *\n * Not every external request is represented here. In some cases\n *  it is simpler to use the API SDK client interface directly.\n */\nimport {\n  CoreContext,\n  InternalProject,\n  InternalSource,\n  InternalUser,\n} from './context'\nimport { getAccessTokenData, getProject, getUser, hydrateProject } from './data'\nimport { Helpers } from '.'\nimport { Props, Role } from './types'\nimport { LiveApiModel } from '@api.stream/sdk'\n\nexport const createProject = async (request: {\n  settings?: { [prop: string]: any }\n  props?: Props // Arbitrary metadata (e.g. 'name')\n  size?: { x: number; y: number }\n  type?: 'sceneless' | 'freeform'\n}) => {\n  const collectionId = getUser().id\n  const type = request.type || 'sceneless'\n  const size = request.size || {\n    x: 1280,\n    y: 720,\n  }\n  const settings = request.settings || {}\n\n  // Create a project to go with the collection\n  let createProjectResponse = await CoreContext.clients\n    .LiveApi()\n    .project.createProject({\n      collectionId,\n      rendering: {\n        video: {\n          width: size.x,\n          height: size.y,\n          framerate: 30,\n        },\n      },\n      composition: {\n        studioSdk: {},\n      },\n      metadata: {},\n      webrtc: {\n        hosted: {},\n      },\n    })\n\n  const layout = await CoreContext.clients.LayoutApi().layout.createLayout({\n    layout: {\n      projectId: createProjectResponse.project.projectId,\n      collectionId: createProjectResponse.project.collectionId,\n    },\n  })\n\n  const { displayName } = getAccessTokenData()\n\n  // Save the layoutId on the project (no need to await)\n  const metadata = {\n    type,\n    layoutId: layout.id,\n    hostDisplayName: displayName,\n    props: request.props || {},\n  }\n  let projectResponse = await CoreContext.clients\n    .LiveApi()\n    .project.updateProject({\n      collectionId,\n      projectId: createProjectResponse.project.projectId,\n      updateMask: ['metadata'],\n      metadata,\n    })\n  createProjectResponse.project = projectResponse.project\n  createProjectResponse.project.metadata = metadata\n\n  if (type === 'sceneless') {\n    await Helpers.ScenelessProject.createCompositor(layout.id, size, settings)\n  } else {\n    await CoreContext.compositor.createProject(\n      {\n        props: {\n          name: 'Root',\n          layout: 'Free',\n          ...settings,\n          isRoot: true,\n          size,\n        },\n      },\n      layout.id,\n    )\n  }\n\n  return createProjectResponse\n}\n\nexport const deleteProject = async (request: { projectId: string }) => {\n  const { projectId } = request\n  const project = getProject(projectId)\n  const collectionId = getUser().id\n\n  await Promise.all([\n    CoreContext.clients.LiveApi().project.deleteProject({\n      collectionId,\n      projectId,\n    }),\n    CoreContext.clients.LayoutApi().layout.deleteLayout({\n      layoutId: project.layoutApi.layoutId,\n    }),\n  ])\n}\n\n/**\n * Load the user data from whatever access token has been registered\n *  with the API.\n */\nexport const loadUser = async (): Promise<{\n  user: InternalUser\n  projects: InternalProject[]\n  sources: InternalSource[]\n}> => {\n  const collections = await loadCollections()\n\n  let collection: LiveApiModel.Collection\n\n  const { displayName, serviceUserId } = getAccessTokenData()\n\n  // Get a single collection, corresponding to a user\n  if (collections.length === 0) {\n    // If the user has no collections, create one\n    const response = await CoreContext.clients\n      .LiveApi()\n      .collection.createCollection({\n        metadata: {\n          serviceUserId,\n          displayName,\n          props: {},\n        },\n      })\n    collection = response.collection\n  } else {\n    // only 1 collection per user for studio-kit\n    collection = collections[0]\n  }\n\n  await CoreContext.clients\n    .LiveApi()\n    .subscribeToCollection(collection.collectionId)\n\n  // Take the Vapi Project and hydrate it with Compositor and Lapi project details\n  const projects = await Promise.all(\n    collection.projects.map((project) => hydrateProject(project, 'ROLE_HOST' as Role)),\n  )\n\n  return {\n    user: {\n      id: collection.collectionId,\n      metadata: collection.metadata,\n      props: collection.metadata?.props || {},\n      name: displayName,\n    },\n    projects,\n    sources: collection.sources,\n  }\n}\n\nexport const loadCollections = async () => {\n  let result = await CoreContext.clients.LiveApi().collection.getCollections({})\n  return result.collections\n}\n"],"names":["createCompositor","layoutId","size","settings","backgroundImage","layout","layoutProps","project","CoreContext","compositor","createProject","props","name","type","isRoot","root","getRoot","baseLayers","Promise","all","insert","id","tagName","sourceType","attributes","src","style","objectFit","reorder","request","collectionId","getUser","x","y","createProjectResponse","clients","LiveApi","rendering","video","width","height","framerate","composition","studioSdk","metadata","webrtc","hosted","LayoutApi","createLayout","projectId","displayName","getAccessTokenData","hostDisplayName","projectResponse","updateProject","updateMask","Helpers","deleteProject","getProject","deleteLayout","layoutApi","loadUser","collections","loadCollections","collection","serviceUserId","length","response","createCollection","subscribeToCollection","projects","map","hydrateProject","user","sources","result","getCollections"],"mappings":"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"}