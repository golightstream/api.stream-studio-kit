{"version":3,"file":"requests.4f1943da.js","sources":["../../../../src/helpers/sceneless-project.ts","../../../../src/core/requests.ts"],"sourcesContent":["/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\n/**\n * Create and manage a project with a {@link ScenelessProject.Commands simple and opinionated interface}.\n *\n * A ScenelessProject is designed to fulfill all of the requirements of\n * a standard web-based broadcaster. It provides simple\n * management of WebRTC {@link Participant Participants},\n * custom layouts, backgrounds, and overlay content.\n *\n * Internally, any {@link Project} that meets a certain set of preconditions is\n * eligible to act as a ScenelessProject. The simplest way to ensure a project\n * can leverage these commands is by creating one with {@link create ScenelessProject.create()}.\n *\n * ```typescript\n * // Create a project for the user with default settings\n * const project = await ScenelessProject.create({\n *   backgroundImage: 'https://studio.golightstream.com/images/polygons.jpg',\n *   layout: 'Grid',\n * })\n *\n * // Pass the project in to receive a list of commands unique to a ScenelessProject\n * const projectCommands = ScenelessProject.commands(project)\n *\n * // Use the commands to update the project's contents (what participants/overlays will appear in the output stream)\n * projectCommands.addParticipant(participantId)\n * ```\n *\n * ----\n * _Note: When using a project interface such as this, avoid using\n * any {@link Command Commands} that operate on elements inside the project. This\n * includes any command which operates on a node (e.g. {@link Command.updateNode} or {@link Command.reorderNodes})._\n *\n * _This is an alternative to {@link Command.createProject}._\n *\n * @module ScenelessProject\n */\nimport { LogoProps } from './../core/sources/Logo'\nimport { Background, BackgroundProps } from './../core/sources/Background'\nimport { Overlay, OverlayProps } from './../core/sources/Overlays'\nimport { CoreContext } from '../core/context'\nimport { getProject, getProjectRoom } from '../core/data'\nimport { SDK, Compositor } from '../core/namespaces'\nimport { Disposable, SceneNode } from '../core/types'\nimport { Track } from 'livekit-client'\nimport { Banner, BannerSource, BannerProps } from '../core/sources/Banners'\nimport { RoomParticipantSource } from '../core/sources/WebRTC'\nimport { generateId } from '../logic'\nimport { ChatOverlayProps } from '../core/transforms/ChatOverlay'\n\nimport LayoutName = Compositor.Layout.LayoutName\n\nexport type { LayoutName }\nexport type { Banner, BannerSource, RoomParticipantSource }\n\nexport type ParticipantProps = {\n  volume: number\n  isMuted: boolean\n  isHidden: boolean\n}\n\nexport type HTMLVideoElementAttributes = {\n  loop?: boolean\n  autoplay?: boolean\n  muted?: boolean\n  playsinline?: boolean\n  disablepictureinpicture?: boolean\n}\n\n// Local cache to track participants being added\nconst addingCache = {\n  camera: new Set<string>(),\n  screen: new Set<string>(),\n}\n\nexport type ParticipantType = 'camera' | 'screen'\n\ninterface ScenelessProject extends SDK.Project {}\n\n// Note: Assume project is a valid sceneless project\n// Note: In the future commands will be returned by an argument of SceneNode\n\n// TODO: Define defaults\n// TODO: Define emits\n\n/**\n * These commands assist with management of WebRTC {@link Participant Participants},\n * custom layouts, backgrounds, and overlay content.\n *\n * Only a valid {@link ScenelessProject} can leverage these commands.\n */\nexport interface Commands {\n  /**\n   * Get the node that holds the stream's background\n   * @private\n   */\n  getBackground(): Compositor.SceneNode\n  /**\n   * Get the node that holds the stream's content\n   * @private\n   */\n  getContent(): Compositor.SceneNode\n  /**\n   * Get the node that holds the stream's foreground (overlays)\n   * @private\n   */\n  getForeground(): Compositor.SceneNode\n  /**\n   * Get the active layout\n   * @private\n   */\n  getLayout(): string\n  /**\n   * Get all banners stored on the project\n   */\n  getBanners(): Banner[]\n  /**\n   * Get all banners stored on the project\n   */\n  getOverlays(): Overlay[]\n\n  /**\n   * Get all participants in the project\n   * @private\n   */\n  getParticipants(): Compositor.SceneNode[]\n  /**\n   * play video overlay on foreground\n   * @private\n   */\n  autoPlayVideoOverlay(\n    overlayId: string,\n    attributes: HTMLVideoElementAttributes,\n  ): void\n\n  /**\n   * play background Video\n   * @private\n   */\n  autoPlayBackgroundVideo(attributes?: HTMLVideoElementAttributes): void\n\n  removeLogo(id: string): void\n\n  addLogo(id: string, logo: LogoProps): Promise<void>\n\n  getLogo(): string\n\n  /**\n   * Add an chat comment to the stream.\n   */\n  addChatOverlay(id: string, Options: ChatOverlayProps): void\n\n  /**\n   * Add an any exisiting chat comment from the stream.\n   */\n  removeChatOverlay(id: string): void\n\n  /**\n   * get the active chat comment to the stream.\n   */\n  getChatOverlay(): ChatOverlayProps | null\n\n  /**\n   * Set the active layout and associated layoutProps\n   */\n  setLayout(layout: LayoutName, layoutProps: LayoutProps): void\n\n  /**\n   * Set the active background image\n   * @deprecated Use getBackgroundMedia2() instead with type\n   */\n  getBackgroundMedia(): string\n  /**\n   * Get the active background image\n   */\n  /**\n   * Set the active background image\n   * @deprecated Use setBackgroundImage2() instead with id\n   */\n  setBackgroundImage(src: string): void\n\n  /**\n   * Set the active background video\n   * @deprecated Use setBackgroundVideo2() instead with id\n   */\n  setBackgroundVideo(src: string, attributes?: HTMLVideoElementAttributes): void\n\n  /**\n   * set image overlay on foreground layer\n   * @deprecated Use addImageOverlay2() instead\n   */\n  addImageOverlay(overlayId: string, src: string): Promise<void>\n  /**\n   * set video overlay on foreground layer\n   * @deprecated Use addVideoOverlay2() instead\n   */\n  addVideoOverlay(\n    overlayId: string,\n    src: string,\n    attributes?: HTMLVideoElementAttributes,\n  ): Promise<void>\n\n  /**\n   * remove the active video overlay\n   * @deprecated Use removeVideoOverlay2() instead\n   */\n  removeVideoOverlay(overlayId: string): Promise<void>\n  /**\n   * remove the active image overlay\n   * @deprecated Use removeImageOverlay2() instead\n   */\n  removeImageOverlay(overlayId: string): Promise<void>\n  /**\n   * Get the active image overlay\n   * @deprecated Use getImageOverlay2() instead\n   */\n  getImageOverlay(): string | string[]\n  /**\n   * Get the active video overlay\n   * @deprecated Use getVideoOverlay2() instead\n   */\n  getVideoOverlay(): string | string[]\n  /**\n   * Get the active background image\n   * @deprecated Use getBackgroundImage2() instead\n   */\n  getBackgroundImage(): string\n  /**\n   * Get the active background video\n   * @deprecated Use getBackgroundVideo2() instead\n   */\n  getBackgroundVideo(): string\n\n  getBackgroundMedia2(type?: string): string\n  /**\n   * Get the active background video\n   */\n  getBackgroundVideo2(): string\n  /**\n   * Get the active background image\n   */\n  getBackgroundImage2(): string\n  /**\n   * Set the active background image\n   */\n  setBackgroundImage2(\n    backgroundId: string,\n    props: BackgroundProps,\n  ): Promise<void>\n\n  /**\n   * Set the active background video\n   */\n  setBackgroundVideo2(\n    backgroundId: string,\n    props: BackgroundProps & HTMLVideoElementAttributes,\n  ): Promise<void>\n\n  /**\n   * Get the active foreground image overlay\n   */\n  getCustomOverlay(): string | string[]\n  /**\n   * Get the active foreground image overlay\n   */\n  getImageOverlay2(): string | string[]\n  /**\n   * Get the active foreground video overlay\n   */\n  getVideoOverlay2(): string | string[]\n  /**\n   * Set the active foreground image overlay\n   */\n  addImageOverlay2(overlayId: string, props: OverlayProps): Promise<void>\n  /**\n   * set image overlay on foreground video layer\n   */\n  addVideoOverlay2(\n    overlayId: string,\n    props: OverlayProps & HTMLVideoElementAttributes,\n  ): Promise<void>\n\n  /**\n   * add html overlay\n   */\n  addCustomOverlay(overlayId: string, props: OverlayProps): Promise<void>\n  /**\n   * remove video overlay from foreground layer\n   */\n  removeCustomOverlay(overlayId: string): Promise<void>\n  /**\n   * remove video overlay from foreground layer\n   */\n  removeVideoOverlay2(overlayId: string): Promise<void>\n\n  /**\n   * remove image overlay from foreground layer\n   */\n  removeImageOverlay2(overlayId: string): Promise<void>\n\n  /** Set one participant to \"showcase\". This participant will expand to fill\n   * the space of the stream without affecting the underlying layout.\n   */\n  setShowcase(\n    participantId: string,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): ReturnType<typeof CoreContext.Command.updateNode>\n  /**\n   * @hook\n   * Receive information about the showcased participant.\n   * As with other hooks, the callback will be invoked when its value changes.\n   */\n  useShowcase(\n    cb: (state: { participantId: string; type: ParticipantType }) => void,\n  ): Disposable\n  /**\n   * Add a participant camera track to the stream canvas.\n   * Available participants can be gleaned from the WebRTC {@link Room} using\n   * {@link Room.useParticipants}.\n   *\n   * A participant will remain on stream even if there is no active feed, until\n   * it is removed using {@link removeParticipantTrack removeParticipantTrack()} or {@link pruneParticipants pruneParticipants()}.\n   */\n  addParticipantTrack(\n    trackId: string,\n    props: Partial<ParticipantProps>,\n    /**\n     * The type of participant feed to add.\n     * @default `'camera'`\n     */\n    type?: ParticipantType,\n  ): Promise<void>\n  /**\n   * Remove a stream participant from the stream canvas.\n   */\n  removeParticipantTrack(trackId: string, type?: ParticipantType): void\n\n  /**\n   * Add a participant to the stream canvas.\n   * Available participants can be gleaned from the WebRTC {@link Room} using\n   * {@link Room.useParticipants}.\n   *\n   * A participant will remain on stream even if there is no active feed, until\n   * it is removed using {@link removeParticipant removeParticipant()} or {@link pruneParticipants pruneParticipants()}.\n   */\n\n  addParticipant(\n    participantId: string,\n    props: Partial<ParticipantProps>,\n    /**\n     * The type of participant feed to add.\n     * @default `'camera'`\n     */\n    type?: ParticipantType,\n  ): Promise<void>\n  /**\n   * @private\n   * @deprecated Use addParticipant() with parameter `type`\n   */\n  addParticipantScreenshare(\n    participantId: string,\n    props: Partial<ParticipantProps>,\n  ): Promise<void>\n  /**\n   * Remove a stream participant from the stream canvas.\n   */\n  removeParticipant(participantId: string, type: ParticipantType): void\n  /**\n   * @private\n   * @deprecated Use removeParticipant() with parameter `type`\n   */\n  removeParticipantScreenshare(participantId: string): void\n  /**\n   * @private\n   * Get the node associated with a room participant\n   * */\n  getParticipantNode(\n    id: string,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): Compositor.SceneNode\n  /**\n   * Get {@link ParticipantProps} associated with a participant/type.\n   */\n  getParticipantState(\n    participantId: string,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): ParticipantProps\n  /**\n   * @hook\n   * Receive {@link ParticipantProps} associated with a participant/type\n   * via invoked callback anytime one of the property values changes.\n   */\n  useParticipantState(\n    participantId: string,\n    cb: (state: ParticipantProps) => void,\n    /** @default `'camera'` */\n    type?: ParticipantType,\n  ): Disposable\n  /**\n   * Change a participant's volume.\n   * This does not affect the underlying MediaStreamTrack.\n   */\n  setParticipantVolume(\n    participantId: string,\n    /**\n     * Accepted values from [0 - 1]\n     */\n    volume: number,\n  ): void\n  /**\n   * Mute a participant without changing their volume.\n   *  This does not affect the underlying MediaStreamTrack.\n   *\n   * Participants muted in this way will not stop sending\n   *  audio data, but it will not play on the receiving end.\n   *\n   * A host may use this to override a guest's settings\n   *  for the stream output.\n   */\n  setParticipantMuted(participantId: string, isMuted: boolean): void\n  /**\n   * Hide a participant video feed from the stream.\n   *  This does not affect the underlying MediaStreamTrack.\n   *\n   * Participants hidden in this way will not stop sending\n   *  video data, but it will not play on the receiving end.\n   *\n   * A host may use this to override a guest's settings\n   *  for the stream output.\n   */\n  setParticipantHidden(participantId: string, isHidden: boolean): void\n  /**\n   * Remove all participants from the stream canvas who are not actively\n   * sending a MediaStreamTrack for display.\n   */\n  pruneParticipants(): void\n  /**\n   * Create and store a banner on the project.\n   *\n   * Does not add the banner to the stream.\n   */\n  addBanner(props: BannerProps): void\n  /**\n   * Edit a banner on the project.\n   */\n  editBanner(id: string, props: BannerProps): void\n  /**\n   * Remove a banner from the project.\n   */\n  removeBanner(id: string): void\n  /**\n   * Fetch the active banner displayed on stream.\n   */\n  getActiveBanner(): string | null\n  /**\n   * Add an existing banner to the stream.\n   * If no `id` is supplied, existing banners will be removed.\n   */\n  setActiveBanner(id: string): void\n  /**\n   * Get an arbitrary property from the project (`project.props{}`)\n   */\n  getProp(props: string): any\n  /**\n   * Set an arbitrary property on the project (`project.props{}`)\n   */\n  setProp(props: string, val: any): void\n  /**\n   * Use the latest value of an arbitrary property on the project (`project.props{}`)\n   */\n  useProp(props: string, cb: (val: any) => void): void\n}\n\n/**\n * Accepts a Project that was created using {@link ScenelessProject.create ScenelessProject.create()}\n * and returns several commands specialized for a Sceneless broadcasting experience.\n *\n * These commands assist with management of WebRTC {@link Participant Participants},\n * custom layouts, backgrounds, and overlay content.\n */\nexport const commands = (_project: ScenelessProject) => {\n  const projectId = _project.id\n  const root = _project.scene.getRoot()\n  const { Command } = CoreContext\n\n  const background = root.children.find((x) => x.props.id === 'bg')\n  const content = root.children.find((x) => x.props.id === 'content')\n  const foreground = root.children.find((x) => x.props.id === 'foreground')\n  let backgroundVideoContainer = background?.children?.find(\n    (x) => x.props.id === 'video-background',\n  )\n\n  let backgroundContainer = background?.children?.find(\n    (x) => x.props.id === 'bg-image',\n  )\n\n  let backgroundImageContainer = background?.children?.find(\n    (x) => x.props.id === 'image-background',\n  )\n  let foregroundImageContainer = foreground?.children?.find(\n    (x) => x.props.id === 'fg-image',\n  )\n\n  let foregroundImageContainer2 = foreground?.children?.find(\n    (x) => x.props.id === 'image-overlay',\n  )\n\n  let foregroundOverlayContainer = foreground?.children?.find(\n    (x) => x.props.id === 'overlay',\n  )\n\n  let foregroundVideoContainer2 = foreground?.children?.find(\n    (x) => x.props.id === 'video-overlay',\n  )\n\n  let foregroundLogoContainer = foreground?.children?.find(\n    (x) => x.props.id === 'logo',\n  )\n\n  let foregroundVideoContainer = foreground?.children?.find(\n    (x) => x.props.id === 'fg-video',\n  )\n  const coreProject = getProject(_project.id)\n\n  let bannerContainer = foreground?.children?.find(\n    (x) => x.props.id === 'fg-banners',\n  )\n\n  const ensureRootLayersProps = async () => {\n    if (background?.props?.layout !== 'Layered') {\n      await coreProject.compositor.update(background.id, {\n        name: 'Background',\n        id: 'bg',\n        layout: 'Layered',\n      })\n    }\n    if (foreground?.props?.layout !== 'Layered') {\n      await coreProject.compositor.update(foreground.id, {\n        id: 'foreground',\n        name: 'Overlays',\n        layout: 'Layered',\n      })\n    }\n  }\n  const ensureForegroundContainers = async () => {\n    const ensureBannerContainer = async () => {\n      if (!bannerContainer) {\n        const nodeId = await coreProject.compositor.insert(\n          {\n            name: 'BannerContainer',\n            id: 'fg-banners',\n            layout: 'Column',\n            layoutProps: {\n              cover: true,\n            },\n          },\n          foreground.id,\n        )\n        bannerContainer = foreground?.children?.find(\n          (x) => x.props.id === nodeId,\n        )\n        return nodeId\n      } else {\n        return bannerContainer.id\n      }\n    }\n    const ensureForegroundImageContainer = async () => {\n      if (!foregroundImageContainer) {\n        const nodeId = await coreProject.compositor.insert(\n          {\n            name: 'ImageOverlay',\n            id: 'fg-image',\n            layout: 'Free',\n          },\n          foreground.id,\n        )\n\n        foregroundImageContainer = foreground?.children?.find(\n          (x) => x.props.id === nodeId,\n        )\n        return nodeId\n      } else {\n        return foregroundImageContainer.id\n      }\n    }\n\n    const ensureForegroundImageContainer2 = async () => {\n      if (!foregroundOverlayContainer) {\n        const nodeId = await coreProject.compositor.insert(\n          {\n            name: 'Overlay',\n            sourceType: 'Overlay',\n            id: 'overlay',\n            layout: 'Free',\n            style: {\n              width: '100%',\n              height: '100%',\n              objectFit: 'cover',\n            },\n          },\n          foreground.id,\n        )\n\n        foregroundOverlayContainer = foreground?.children?.find(\n          (x) => x.props.id === nodeId,\n        )\n        return nodeId\n      } else {\n        return foregroundOverlayContainer.id\n      }\n    }\n\n    const ensureForegroundVideoContainer2 = async () => {\n      if (!foregroundVideoContainer2) {\n        const nodeId = await coreProject.compositor.insert(\n          {\n            name: 'VideoOverlay2',\n            sourceType: 'Video2',\n            // this will enable to register a transfrom on another source\n            // doing so will enable to resume source\n            proxySource: 'Overlay',\n            id: 'video-overlay',\n            layout: 'Free',\n            style: {\n              width: '100%',\n              height: '100%',\n              objectFit: 'cover',\n            },\n          },\n          foreground.id,\n        )\n\n        foregroundVideoContainer2 = foreground?.children?.find(\n          (x) => x.props.id === nodeId,\n        )\n        return nodeId\n      } else {\n        return foregroundVideoContainer2.id\n      }\n    }\n\n    const ensureForegroundVideoContainer = async () => {\n      if (!foregroundVideoContainer) {\n        const nodeId = await coreProject.compositor.insert(\n          {\n            name: 'VideoOverlay',\n            id: 'fg-video',\n            layout: 'Free',\n          },\n          foreground.id,\n        )\n        foregroundVideoContainer = foreground?.children?.find(\n          (x) => x.props.id === nodeId,\n        )\n        return nodeId\n      } else {\n        return foregroundVideoContainer.id\n      }\n    }\n\n    const ensureForegroundLogoContainer = async () => {\n      if (!foregroundLogoContainer) {\n        const nodeId = await coreProject.compositor.insert(\n          {\n            name: 'Logo',\n            layout: 'Free',\n            sourceType: 'Logo',\n            id: 'logo',\n            style: {\n              width: '100%',\n              height: '100%',\n              objectFit: 'contain',\n              position: 'unset',\n            },\n          },\n          foreground.id,\n        )\n        foregroundLogoContainer = foreground?.children?.find(\n          (x) => x.props.id === nodeId,\n        )\n        return nodeId\n      } else {\n        return foregroundLogoContainer.id\n      }\n    }\n\n    const ensureBackgroundContainer = async () => {\n      if (!backgroundContainer) {\n        const nodeId = await coreProject.compositor.insert(\n          {\n            name: 'ImageBackground',\n            id: 'bg-image',\n            tagName: 'img',\n            sourceType: 'Element',\n            attributes: {\n              src: '',\n            },\n            fields: {\n              style: {\n                width: '100%',\n                height: '100%',\n                objectFit: 'cover',\n              },\n            },\n          },\n          background.id,\n        )\n        backgroundContainer = background?.children?.find(\n          (x) => x.props.id === nodeId,\n        )\n        return nodeId\n      } else {\n        return backgroundContainer.id\n      }\n    }\n\n    const ensureBackgroundImageContainer = async () => {\n      if (!backgroundImageContainer) {\n        const nodeId = await coreProject.compositor.insert(\n          {\n            name: 'ImageBackground2',\n            sourceType: 'Image2',\n            proxySource: 'Background',\n            id: 'image-background',\n            layout: 'Free',\n            src: '',\n            style: {\n              width: '100%',\n              height: '100%',\n              objectFit: 'cover',\n            },\n          },\n          background.id,\n        )\n        backgroundImageContainer = background?.children?.find(\n          (x) => x.props.id === nodeId,\n        )\n        return nodeId\n      } else {\n        return backgroundImageContainer.id\n      }\n    }\n\n    const ensureBackgroundVideoContainer = async () => {\n      if (!backgroundVideoContainer) {\n        const nodeId = await coreProject.compositor.insert(\n          {\n            name: 'VideoBackground',\n            sourceType: 'Video2',\n            proxySource: 'Background',\n            id: 'video-background',\n            layout: 'Free',\n            style: {\n              width: '100%',\n              height: '100%',\n              position: 'absolute',\n              objectFit: 'cover',\n            },\n          },\n          background.id,\n        )\n        backgroundVideoContainer = background?.children?.find(\n          (x) => x.props.id === nodeId,\n        )\n        return nodeId\n      } else {\n        return backgroundVideoContainer.id\n      }\n    }\n    try {\n      const baseForegroundLayers = await Promise.all([\n        ensureBannerContainer(),\n        ensureForegroundImageContainer(),\n        ensureForegroundImageContainer2(),\n        ensureForegroundVideoContainer(),\n        ensureForegroundVideoContainer2(),\n        ensureForegroundLogoContainer(),\n      ])\n\n      await coreProject.compositor.reorder(foreground.id, baseForegroundLayers)\n\n      const baseBackgroundLayers = await Promise.all([\n        ensureBackgroundContainer(),\n        ensureBackgroundImageContainer(),\n        ensureBackgroundVideoContainer(),\n      ])\n\n      await coreProject.compositor.reorder(background.id, baseBackgroundLayers)\n    } catch (e) {}\n  }\n\n  const commands: Commands = {\n    getBackground() {\n      return background\n    },\n    getContent() {\n      return content\n    },\n    getForeground() {\n      return foreground\n    },\n    getLayout() {\n      return content.props.layout\n    },\n    getBanners() {\n      return (getProject(_project.id).props?.banners || []) as Banner[]\n    },\n\n    getOverlays() {\n      return (getProject(_project.id).props.overlays || []) as Overlay[]\n    },\n\n    getParticipants() {\n      return content.children.filter((node) => {\n        if (node.props.sourceType !== 'RoomParticipant') return false\n        return true\n      })\n    },\n\n    getLogo() {\n      return commands.getProp('logo')?.id\n    },\n\n    removeLogo() {\n      return commands.setProp('logo', null)\n    },\n\n    getImageOverlay(): string | string[] {\n      const foregroundImageIds =\n        foregroundImageContainer?.children?.map(\n          (x) => x?.props?.sourceProps?.id,\n        ) ?? []\n      return foregroundImageIds.length > 1\n        ? foregroundImageIds\n        : foregroundImageIds[0]\n    },\n\n    getVideoOverlay(): string | string[] {\n      const foregroundVideoIds =\n        foregroundVideoContainer?.children?.map(\n          (x) => x?.props?.sourceProps?.id,\n        ) ?? []\n      return foregroundVideoIds.length > 1\n        ? foregroundVideoIds\n        : foregroundVideoIds[0]\n    },\n    autoPlayBackgroundVideo(\n      attributes: HTMLVideoElementAttributes = {\n        muted: true,\n        autoplay: true,\n      },\n    ) {\n      // find overlay node by id\n      const backgroundVideo = background.children.find(\n        (x) => x.props.id === 'bg-video',\n      )\n      // if overlay is not found, return\n      if (!backgroundVideo) {\n        return\n      }\n      // check if overlay is of type video\n      // autoPlay overlay with muted audio\n      // update overlay node with new attributes\n      CoreContext.Command.updateNode({\n        nodeId: backgroundVideo.id,\n        props: {\n          ...backgroundVideo.props,\n          attributes: {\n            ...backgroundVideo.props.attributes,\n            ...attributes,\n          },\n        },\n      })\n    },\n\n    autoPlayVideoOverlay(\n      overlayId: string,\n      attributes: HTMLVideoElementAttributes = {\n        muted: true,\n        autoplay: true,\n      },\n    ) {\n      // find overlay node by id\n      const overlay = foregroundVideoContainer?.children?.find(\n        (x) => x.props?.sourceProps?.id === overlayId,\n      )\n\n      // if overlay is not found, return\n      if (!overlay) {\n        return\n      }\n\n      // check if overlay is of type video\n      if (overlay.props.sourceProps.type === 'video') {\n        // autoPlay overlay with muted audio\n        // update overlay node with new attributes\n        CoreContext.Command.updateNode({\n          nodeId: overlay.id,\n          props: {\n            ...overlay.props,\n            attributes: {\n              ...overlay.props.attributes,\n              ...attributes,\n            },\n          },\n        })\n      }\n    },\n\n    async removeImageOverlay(overlayId: string) {\n      // find overlay node by id\n      const overlay = foregroundImageContainer.children.find(\n        (x) => x.props?.sourceProps?.id === overlayId,\n      )\n      // if overlay exists, remove it\n      if (overlay) {\n        CoreContext.Command.deleteNode({\n          nodeId: overlay.id,\n        })\n      }\n    },\n\n    async removeVideoOverlay(overlayId: string) {\n      // find overlay node by id\n      const overlay = foregroundVideoContainer?.children?.find(\n        (x) => x.props?.sourceProps?.id === overlayId,\n      )\n\n      // if overlay exists, remove it\n      if (overlay) {\n        CoreContext.Command.deleteNode({\n          nodeId: overlay.id,\n        })\n      }\n\n      // get all children of the overlay node and update their opacity attributes\n      const allForegroundChildrens = foreground.children.filter(\n        (f) => f.props.id !== 'fg-video',\n      )\n      allForegroundChildrens.forEach((nodes) => {\n        nodes.children.forEach((node) => {\n          if (node.props?.fields?.style?.opacity === 0) {\n            node.props.fields.style.opacity = 1\n            CoreContext.Command.updateNode({\n              nodeId: node.id,\n              props: {\n                ...node.props,\n              },\n            })\n          }\n        })\n      })\n    },\n\n    async addImageOverlay(overlayId: string, src: string) {\n      // Get the image overlay node from the foreground layer\n      const imageOverlay = foregroundImageContainer.children.find(\n        (x) => x.props.id === 'img-overlay',\n      )\n\n      // if the overlayid matches the image overlay id passed, return\n      if (imageOverlay && imageOverlay?.props?.sourceProps?.id === overlayId) {\n        return\n      }\n\n      //set the source of the image overlay node to the image src\n      let imageProps = {\n        id: 'img-overlay',\n        sourceType: 'Element',\n        sourceProps: {\n          type: 'image',\n          id: overlayId,\n        },\n        tagName: 'img',\n        attributes: {\n          src,\n        },\n        fields: {\n          style: {\n            transition: 'opacity 300ms ease 0ms, transform, width, height',\n            '-webkit-transition':\n              'opacity 300ms ease 0ms, transform, width, height',\n            opacity: 1,\n            objectFit: 'cover',\n          },\n        },\n      }\n      // get video overlay node from the foreground layer\n      const vidOverlay = foregroundVideoContainer?.children?.find(\n        (x) => x.props.id === 'vid-overlay',\n      )\n\n      // if the video overlay node exists, change the image overlay node to opacity 0\n      if (vidOverlay) {\n        imageProps.fields.style.opacity = 0\n      }\n\n      // If the overlay doesn't exist, create it\n      if (!imageOverlay) {\n        await CoreContext.Command.createNode({\n          props: imageProps,\n          parentId: foregroundImageContainer.id,\n          index: foregroundImageContainer.children.length,\n        })\n      } else {\n        // Otherwise, update the overlay node\n        CoreContext.Command.updateNode({\n          nodeId: imageOverlay.id,\n          props: {\n            ...imageOverlay.props,\n            ...imageProps,\n          },\n        })\n      }\n    },\n\n    async addVideoOverlay(\n      overlayId: string,\n      src: string,\n      attributes: HTMLVideoElementAttributes = {\n        playsinline: true,\n        disablepictureinpicture: true,\n        autoplay: true,\n      },\n    ) {\n      // Get the video overlay node from the foreground layer\n      const videoOverlay = foregroundVideoContainer?.children?.find(\n        (x) => x.props.id === 'vid-overlay',\n      )\n\n      // if the video overlay node exists, and the overlay id matches the overlay id passed in, return\n      if (videoOverlay && videoOverlay?.props?.sourceProps?.id === overlayId) {\n        return\n      }\n\n      //set the source of the video overlay node to the src\n      let videoProps = {\n        id: 'vid-overlay',\n        sourceType: 'LS-Video',\n        sourceProps: {\n          type: 'video',\n          id: overlayId,\n        },\n        tagName: 'video',\n        attributes: {\n          ...attributes,\n          src,\n          id: overlayId,\n        },\n      }\n\n      // get all children of the overlay node and update their opacity attributes\n      const allForegroundChildrens = foreground.children.filter(\n        (f) => f.props.id !== 'fg-video',\n      )\n      allForegroundChildrens.forEach((nodes) => {\n        nodes.children.forEach((node) => {\n          if (node.props?.fields?.style?.opacity === 1) {\n            node.props.fields.style.opacity = 0\n            CoreContext.Command.updateNode({\n              nodeId: node.id,\n              props: {\n                ...node.props,\n              },\n            })\n          }\n        })\n      })\n\n      // If the overlay doesn't exist, create it\n      if (!videoOverlay) {\n        await CoreContext.Command.createNode({\n          props: videoProps,\n          parentId: foregroundVideoContainer.id,\n          index: foregroundVideoContainer.children.length,\n        })\n      } else {\n        // Otherwise, update the overlay node\n        CoreContext.Command.updateNode({\n          nodeId: videoOverlay.id,\n          props: {\n            ...videoOverlay.props,\n            ...videoProps,\n          },\n        })\n      }\n    },\n    getBackgroundMedia() {\n      const backgroundChild = background.children.filter((x) => x)\n      return backgroundChild[0]?.props?.attributes?.src\n    },\n\n    getBackgroundImage() {\n      const backgroundChild = background.children.filter(\n        (x) => x.props.id === 'bg-image',\n      )\n      return backgroundChild[0]?.props?.attributes?.src\n    },\n\n    getBackgroundVideo() {\n      const backgroundChild = background.children.filter(\n        (x) => x.props.id === 'bg-video',\n      )\n      return backgroundChild[0]?.props?.attributes?.src\n    },\n\n    async setBackgroundImage(src: string) {\n      const backgroundImage = background.children.find(\n        (x) => x.props.id === 'bg-image',\n      )\n\n      // if the video overlay node exists, and the overlay id matches the overlay id passed in, return\n      if (backgroundImage && backgroundImage?.props?.attributes?.src === src) {\n        return\n      }\n\n      const backgroundVideo = background.children.find(\n        (x) => x.props.id === 'bg-video',\n      )\n\n      if (backgroundVideo) {\n        CoreContext.Command.deleteNode({\n          nodeId: backgroundVideo.id,\n        })\n      }\n\n      if (!backgroundImage) {\n        await CoreContext.Command.createNode({\n          props: {\n            name: 'ImageBackground',\n            id: 'bg-image',\n            tagName: 'img',\n            sourceType: 'Element',\n            attributes: {\n              src,\n            },\n            fields: {\n              style: {\n                width: '100%',\n                height: '100%',\n                objectFit: 'cover',\n              },\n            },\n          },\n          parentId: background.id,\n          index: background.children.length,\n        })\n      } else {\n        CoreContext.Command.updateNode({\n          nodeId: backgroundImage.id,\n          props: {\n            attributes: {\n              ...backgroundImage.props.attributes,\n              src,\n            },\n          },\n        })\n      }\n    },\n\n    async setBackgroundVideo(\n      src: string,\n      attributes: HTMLVideoElementAttributes = {\n        loop: true,\n        autoplay: true,\n      },\n    ) {\n      const backgroundVideo = background.children.find(\n        (x) => x.props.id === 'bg-video',\n      )\n\n      // if the video overlay node exists, and the overlay id matches the overlay id passed in, return\n      if (backgroundVideo && backgroundVideo?.props?.attributes?.src === src) {\n        return\n      }\n\n      const backgroundImage = background.children.find(\n        (x) => x.props.id === 'bg-image',\n      )\n\n      if (backgroundImage) {\n        CoreContext.Command.deleteNode({\n          nodeId: backgroundImage.id,\n        })\n      }\n\n      if (!backgroundVideo) {\n        await CoreContext.Command.createNode({\n          props: {\n            name: 'VideoBackground',\n            id: 'bg-video',\n            sourceType: 'LS-Video',\n            attributes: {\n              ...attributes,\n              src,\n            },\n            fields: {\n              style: {\n                width: '100%',\n                height: '100%',\n                objectFit: 'cover',\n              },\n            },\n          },\n          parentId: background.id,\n          index: background.children.length,\n        })\n      } else {\n        CoreContext.Command.updateNode({\n          nodeId: backgroundVideo.id,\n          props: {\n            attributes: {\n              ...backgroundVideo.props.attributes,\n              ...attributes,\n              src,\n            },\n          },\n        })\n      }\n    },\n    async addLogo(logoId: string, props: LogoProps) {\n      const exisitingLogo = (getProject(_project.id).props.logo ||\n        null) as Background\n      if (exisitingLogo) {\n        if (exisitingLogo.id === logoId) {\n          return await Command.updateProjectProps({\n            projectId,\n            props: {\n              logo: exisitingLogo,\n            },\n          })\n        }\n      }\n\n      const meta = props.meta || { style: { height: '100%', width: '100%' } }\n\n      const newLogo = {\n        id: logoId,\n        props: {\n          ...props,\n          type: 'logo',\n          meta,\n        },\n      }\n\n      await Command.updateProjectProps({\n        projectId,\n        props: {\n          logo: newLogo,\n        },\n      })\n    },\n\n    addBanner(props: BannerProps = {}) {\n      const meta = props.meta || {}\n      const banner = {\n        id: generateId(),\n        props: {\n          ...props,\n          meta,\n        },\n      }\n\n      const existingBanners = (getProject(projectId).props?.banners ||\n        []) as Banner[]\n      return Command.updateProjectProps({\n        projectId,\n        props: {\n          banners: [...existingBanners, banner],\n        },\n      })\n    },\n    editBanner(id: string, props: BannerProps = {}) {\n      const existingBanners = commands.getBanners()\n      const banners = existingBanners.map((x) => {\n        if (x.id !== id) return x\n        return {\n          ...x,\n          props,\n        }\n      })\n      return Command.updateProjectProps({\n        projectId,\n        props: {\n          banners,\n        },\n      })\n    },\n    removeBanner(id: string) {\n      const existingBanners = commands.getBanners()\n      // Remove dependent nodes from stream\n      bannerContainer?.children?.forEach((x) => {\n        if (x.props.bannerId !== id) return\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n\n      return Command.updateProjectProps({\n        projectId,\n        props: {\n          banners: existingBanners.filter((x) => x.id !== id),\n        },\n      })\n    },\n    async setActiveBanner(id: string) {\n      const [nodeTocheckForChildren, ...{}] =\n        bannerContainer?.children || ([] as SceneNode[])\n\n      /* Checking if the existingBannerNode has a property called chatOverlayId. If it does, it deletes the\n      node. */\n      if (\n        nodeTocheckForChildren?.props?.sourceType?.toLowerCase() ===\n        'chatoverlay'\n      ) {\n        await CoreContext.Command.deleteNode({\n          nodeId: nodeTocheckForChildren.id,\n        })\n      }\n\n      const [existingBannerNode, ...excessBannerNodes] =\n        bannerContainer?.children || ([] as SceneNode[])\n      // Delete all except one banner from the project\n      excessBannerNodes.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n      if (!existingBannerNode) {\n        return CoreContext.Command.createNode({\n          parentId: bannerContainer?.id,\n          props: {\n            sourceType: 'Banner',\n            bannerId: id,\n          },\n        })\n      } else {\n        CoreContext.Command.updateNode({\n          nodeId: existingBannerNode.id,\n          props: {\n            sourceType: 'Banner',\n            bannerId: id,\n          },\n        })\n      }\n    },\n\n    getActiveBanner(): string | null {\n      return bannerContainer.children?.[0]?.props?.bannerId ?? null\n    },\n\n    async addChatOverlay(id: string, options: ChatOverlayProps) {\n      const [nodeTocheckForChildren, ...{}] =\n        bannerContainer?.children || ([] as SceneNode[])\n\n      /* Deleting the existing banner node if it exists. */\n      if (\n        nodeTocheckForChildren?.props?.sourceType?.toLowerCase() === 'banner'\n      ) {\n        await CoreContext.Command.deleteNode({\n          nodeId: nodeTocheckForChildren.id,\n        })\n      }\n\n      /* Destructuring an array. */\n      const [existingBannerNode, ...excessBannerNodes] =\n        bannerContainer?.children || ([] as SceneNode[])\n\n      // Delete all except one banner from the project\n      excessBannerNodes.forEach((x) => {\n        CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n\n      /* Creating a banner node if it doesn't exist, or updating it if it does. */\n      if (!existingBannerNode) {\n        await CoreContext.Command.createNode({\n          parentId: bannerContainer?.id,\n          props: {\n            sourceType: 'ChatOverlay',\n            chatOverlayId: id,\n            id,\n            ...options,\n          },\n        })\n      } else {\n        await CoreContext.Command.updateNode({\n          nodeId: existingBannerNode.id,\n          props: {\n            sourceType: 'ChatOverlay',\n            chatOverlayId: id,\n            id,\n            ...options,\n          },\n        })\n      }\n    },\n\n    async removeChatOverlay(id: string) {\n      // Remove dependent nodes from stream\n      bannerContainer?.children?.forEach(async (x) => {\n        if (x.props.chatOverlayId !== id) return\n        await CoreContext.Command.deleteNode({\n          nodeId: x.id,\n        })\n      })\n    },\n\n    getChatOverlay(): ChatOverlayProps | null {\n      /* Checking if the bannerContainer has a child and if that child has a chatOverlayId property. If it\n        does, it returns the child as an IChatOverlay. If it doesn't, it returns null.\n      */\n      return bannerContainer.children?.[0]?.props?.chatOverlayId\n        ? (bannerContainer.children?.[0]?.props as ChatOverlayProps) || null\n        : null\n    },\n\n    getImageOverlay2(): string | string[] {\n      const existingImageOverlays = CoreContext.compositor\n        .getSources('Overlay')\n        .filter((x) => x.props?.meta?.type === 'image-overlay')\n      const foregroundImageIds = existingImageOverlays.map((f) => f?.id)\n      return foregroundImageIds.length > 1\n        ? foregroundImageIds\n        : foregroundImageIds[0]\n    },\n\n    getVideoOverlay2(): string | string[] {\n      const existingVideoOverlays = CoreContext.compositor\n        .getSources('Overlay')\n        .filter((x) => x.props.type === 'video-overlay')\n      const foregroundVideoIds = existingVideoOverlays.map((f) => f?.id)\n      return foregroundVideoIds.length > 1\n        ? foregroundVideoIds\n        : foregroundVideoIds[0]\n    },\n\n    getCustomOverlay(): string | string[] {\n      const existingCustomOverlays = CoreContext.compositor\n        .getSources('Overlay')\n        .filter((x) => x.props?.meta?.type === 'html-overlay')\n      const foregroundCustomOverlayIds = existingCustomOverlays.map(\n        (f) => f?.id,\n      )\n      return foregroundCustomOverlayIds.length > 1\n        ? foregroundCustomOverlayIds\n        : foregroundCustomOverlayIds[0]\n    },\n\n    async removeCustomOverlay(overlayId: string) {\n      // find overlay node by id\n      const existingOverlays = commands.getOverlays()\n\n      return await Command.updateProjectProps({\n        projectId,\n        props: {\n          overlays: existingOverlays.filter((x) => x.id !== overlayId),\n        },\n      })\n    },\n\n    async removeImageOverlay2(overlayId: string) {\n      // find overlay node by id\n      const existingOverlays = commands.getOverlays()\n\n      return await Command.updateProjectProps({\n        projectId,\n        props: {\n          overlays: existingOverlays.filter((x) => x.id !== overlayId),\n        },\n      })\n    },\n\n    async removeVideoOverlay2(overlayId: string) {\n      // find overlay node by id\n      const existingOverlays = commands.getOverlays()\n      const reamningOverlays = existingOverlays.filter(\n        (x) => x.id !== overlayId,\n      )\n\n      // get all children of the overlay node and update their opacity attributes\n      const allForegroundOverlays = reamningOverlays.filter(\n        (f) => f.props.type !== 'video-overlay',\n      )\n\n      const newForegroundLayers = allForegroundOverlays.map((overlay) => {\n        return {\n          ...overlay,\n          props: {\n            ...overlay.props,\n            meta: {\n              ...overlay.props.meta,\n              style: { opacity: 1 },\n            },\n          },\n        }\n      })\n\n      await Command.updateProjectProps({\n        projectId,\n        props: {\n          overlays: newForegroundLayers,\n        },\n      })\n    },\n\n    async addCustomOverlay(overlayId: string, props: OverlayProps = {}) {\n      const existingOverlays = commands.getOverlays()\n\n      const overlay = existingOverlays.find((x) => x.id === overlayId)\n\n      if (overlay) {\n        const overlayIndex = existingOverlays.findIndex(\n          (x) => x.id === overlayId,\n        )\n        if (overlayIndex > -1) {\n          const shallowOverlays = JSON.parse(JSON.stringify(existingOverlays))\n\n          shallowOverlays.splice(overlayIndex, 1, overlay)\n\n          return await Command.updateProjectProps({\n            projectId,\n            props: {\n              overlays: shallowOverlays,\n            },\n          })\n        }\n      }\n\n      const vidOverlay = existingOverlays.find(\n        (x) => x.props.type === 'video-overlay',\n      )\n      const meta = props.meta || { type: 'html-overlay' }\n\n      const newOverlay = {\n        id: overlayId,\n        props: {\n          ...props,\n          type: 'overlay',\n          meta: {\n            ...meta,\n            ...{ ...(vidOverlay && { style: { opacity: 0 } }) },\n          },\n        },\n      }\n\n      const nonHTMLOverlays = existingOverlays.filter(\n        (x) => x.props.type !== 'overlay',\n      )\n\n      await Command.updateProjectProps({\n        projectId,\n        props: {\n          overlays: [...nonHTMLOverlays, newOverlay],\n        },\n      })\n    },\n\n    async addImageOverlay2(overlayId: string, props: OverlayProps = {}) {\n      const existingOverlays = commands.getOverlays()\n\n      const overlay = existingOverlays.find((x) => x.id === overlayId)\n\n      if (overlay) {\n        const overlayIndex = existingOverlays.findIndex(\n          (x) => x.id === overlayId,\n        )\n        if (overlayIndex > -1) {\n          const shallowOverlays = JSON.parse(JSON.stringify(existingOverlays))\n\n          shallowOverlays.splice(overlayIndex, 1, overlay)\n\n          return await Command.updateProjectProps({\n            projectId,\n            props: {\n              overlays: shallowOverlays,\n            },\n          })\n        }\n      }\n\n      const vidOverlay = existingOverlays.find(\n        (x) => x.props.type === 'video-overlay',\n      )\n      const meta = props.meta || { type: 'image-overlay' }\n\n      const newOverlay = {\n        id: overlayId,\n        props: {\n          ...props,\n          type: 'overlay',\n          meta: {\n            ...meta,\n            ...{ ...(vidOverlay && { style: { opacity: 0 } }) },\n          },\n        },\n      }\n\n      const nonImageOverlays = existingOverlays.filter(\n        (x) => x.props.type !== 'overlay',\n      )\n\n      await Command.updateProjectProps({\n        projectId,\n        props: {\n          overlays: [...nonImageOverlays, newOverlay],\n        },\n      })\n    },\n\n    async addVideoOverlay2(\n      overlayId: string,\n      props: OverlayProps & HTMLVideoElementAttributes = {},\n    ) {\n      const existingOverlays = commands.getOverlays()\n      const overlay = existingOverlays.find((x) => x.id === overlayId)\n\n      if (overlay) {\n        const overlayIndex = existingOverlays.findIndex(\n          (x) => x.id === overlayId,\n        )\n        if (overlayIndex > -1) {\n          const shallowOverlays = JSON.parse(JSON.stringify(existingOverlays))\n\n          shallowOverlays.splice(overlayIndex, 1, overlay)\n\n          return await Command.updateProjectProps({\n            projectId,\n            props: {\n              overlays: shallowOverlays,\n            },\n          })\n        }\n      }\n\n      // get all children of the overlay node and update their opacity attributes\n      const allForegroundOverlays = existingOverlays?.filter(\n        (f) => f.props.type !== 'video-overlay',\n      )\n\n      const newForegroundLayers = allForegroundOverlays?.map((overlay) => {\n        return {\n          ...overlay,\n          props: {\n            ...overlay.props,\n            meta: {\n              ...overlay.props.meta,\n              style: { opacity: 0 },\n            },\n          },\n        }\n      })\n\n      const meta = props.meta || {}\n\n      const newOverlay = {\n        id: overlayId,\n        props: {\n          ...props,\n          type: 'video-overlay',\n          meta,\n        },\n      }\n\n      await Command.updateProjectProps({\n        projectId,\n        props: {\n          overlays: [...newForegroundLayers, newOverlay],\n        },\n      })\n    },\n\n    setLayout(layout: LayoutName, layoutProps: LayoutProps = {}) {\n      const showcase = content.props.layoutProps.showcase\n      Command.setNodeLayout({\n        nodeId: content.id,\n        layout,\n        layoutProps: {\n          showcase,\n          ...layoutProps,\n        },\n      })\n    },\n\n    getBackgroundMedia2(type?: string) {\n      const backgroundMedia = CoreContext.compositor.getSources('Background')\n      const backgroundMediaIds = type\n        ? backgroundMedia.filter((x) => x.props.type === type).map((x) => x.id)\n        : backgroundMedia.map((x) => x.id)\n      return backgroundMediaIds[0]\n    },\n\n    getBackgroundImage2() {\n      return commands.getBackgroundMedia2('image-background')\n    },\n\n    getBackgroundVideo2() {\n      return commands.getBackgroundMedia2('video-background')\n    },\n\n    async setBackgroundImage2(\n      backgroundId: string,\n      props: BackgroundProps = {},\n    ) {\n      const exisitingBackground = (getProject(_project.id).props.background ||\n        null) as Background\n      if (exisitingBackground) {\n        if (exisitingBackground.id === backgroundId) {\n          return Command.updateProjectProps({\n            projectId,\n            props: {\n              background: exisitingBackground,\n            },\n          })\n        }\n      }\n\n      const meta = props.meta || {}\n\n      const newBackground = {\n        id: backgroundId,\n        props: {\n          ...props,\n          type: 'image-background',\n          meta,\n        },\n      }\n\n      await Command.updateProjectProps({\n        projectId,\n        props: {\n          background: newBackground,\n        },\n      })\n    },\n\n    async setBackgroundVideo2(\n      backgroundId: string,\n      props: BackgroundProps & HTMLVideoElementAttributes = {},\n    ) {\n      const exisitingBackground = (getProject(_project.id).props.background ||\n        null) as Background\n      if (exisitingBackground) {\n        if (exisitingBackground.id === backgroundId) {\n          return Command.updateProjectProps({\n            projectId,\n            props: {\n              background: exisitingBackground,\n            },\n          })\n        }\n      }\n\n      const meta = props.meta || {}\n\n      const newBackground = {\n        id: backgroundId,\n        props: {\n          ...props,\n          type: 'video-background',\n          meta,\n        },\n      }\n\n      await Command.updateProjectProps({\n        projectId,\n        props: {\n          background: newBackground,\n        },\n      })\n    },\n    setShowcase(participantId: string, type: ParticipantType = 'camera') {\n      const node = commands.getParticipantNode(participantId, type)\n      return CoreContext.Command.updateNode({\n        nodeId: content.id,\n        props: {\n          layoutProps: {\n            ...content.props.layoutProps,\n            showcase: node?.id ?? null,\n          },\n        },\n      })\n    },\n    useShowcase(\n      cb: (state: { participantId: string; type: ParticipantType }) => void,\n    ) {\n      const sendState = () => {\n        const nodeId = content.props.layoutProps.showcase\n        const node = content.children.find((x) => x.id === nodeId)\n        if (!node)\n          return cb({\n            participantId: null,\n            type: null,\n          })\n\n        const { sourceProps } = node.props\n        return cb({\n          participantId: sourceProps.id,\n          type: sourceProps.type,\n        })\n      }\n      sendState()\n\n      // Watch for changes to the parent children\n      return CoreContext.onInternal('NodeChanged', (payload) => {\n        if (payload.nodeId !== content.id) return\n        sendState()\n      })\n    },\n\n    async addParticipantTrack(\n      trackId: string,\n      props: Partial<ParticipantProps> = {\n        isMuted: true,\n        isHidden: false,\n        volume: 0,\n      },\n      type: ParticipantType = 'camera',\n    ) {\n      if (addingCache[type].has(trackId)) return\n\n      const { isMuted = false, isHidden = false, volume = 1 } = props\n      const existing = content.children.find(\n        (x) =>\n          x.props.sourceProps?.id === trackId &&\n          x.props.sourceProps?.type === type,\n      )\n      if (existing) return\n\n      addingCache[type].add(trackId)\n      // Get the participant type in the first position\n      const currentFirst = content.children[0]\n      let index = content.children.length\n\n      // If we're adding a screen and the first position is not already\n      //  a screen, then we add it in the first position.\n      if (\n        type === 'screen' &&\n        currentFirst?.props.sourceProps.type !== 'screen'\n      ) {\n        index = 0\n      }\n      await CoreContext.Command.createNode({\n        props: {\n          name: 'Participant',\n          sourceType: 'RoomParticipant',\n          sourceProps: {\n            type,\n            id: trackId,\n          },\n          volume,\n          isMuted,\n          isHidden,\n        },\n        parentId: content.id,\n        index,\n      }).finally(() => {\n        addingCache[type].delete(trackId)\n      })\n    },\n\n    removeParticipantTrack(trackId: string, type: ParticipantType = 'camera') {\n      content.children\n        .filter(\n          (x) =>\n            x.props.sourceProps?.id === trackId &&\n            x.props.sourceProps?.type === type &&\n            x.props.sourceType === 'RoomParticipant',\n        )\n        .forEach((x) => {\n          CoreContext.Command.deleteNode({\n            nodeId: x.id,\n          })\n        })\n    },\n\n    async addParticipant(\n      participantId: string,\n      props: Partial<ParticipantProps> = {},\n      type: ParticipantType = 'camera',\n    ) {\n      if (addingCache[type].has(participantId)) return\n\n      const { isMuted = false, isHidden = false, volume = 1 } = props\n      const existing = content.children.find(\n        (x) =>\n          x.props.sourceProps?.id === participantId &&\n          x.props.sourceProps?.type === type,\n      )\n      if (existing) return\n\n      addingCache[type].add(participantId)\n      // Get the participant type in the first position\n      const currentFirst = content.children[0]\n      let index = content.children.length\n\n      // If we're adding a screen and the first position is not already\n      //  a screen, then we add it in the first position.\n      if (\n        type === 'screen' &&\n        currentFirst?.props.sourceProps.type !== 'screen'\n      ) {\n        index = 0\n      }\n      await CoreContext.Command.createNode({\n        props: {\n          name: 'Participant',\n          sourceType: 'RoomParticipant',\n          sourceProps: {\n            type,\n            id: participantId,\n          },\n          volume,\n          isMuted,\n          isHidden,\n        },\n        parentId: content.id,\n        index,\n      }).finally(() => {\n        addingCache[type].delete(participantId)\n      })\n    },\n    addParticipantScreenshare(\n      participantId: string,\n      props: Partial<ParticipantProps> = {},\n    ) {\n      return commands.addParticipant(participantId, props, 'screen')\n    },\n    removeParticipant(participantId: string, type: ParticipantType = 'camera') {\n      content.children\n        .filter(\n          (x) =>\n            x.props.sourceProps?.id === participantId &&\n            x.props.sourceProps?.type === type &&\n            x.props.sourceType === 'RoomParticipant',\n        )\n        .forEach((x) => {\n          CoreContext.Command.deleteNode({\n            nodeId: x.id,\n          })\n        })\n    },\n    removeParticipantScreenshare(participantId: string) {\n      return commands.removeParticipant(participantId, 'screen')\n    },\n    getParticipantNode(id: string, type: ParticipantType = 'camera') {\n      return content.children.find(\n        (x) =>\n          x.props.sourceProps?.id === id && x.props.sourceProps?.type === type,\n      )\n    },\n    getParticipantState(\n      participantId: string,\n      type: ParticipantType = 'camera',\n    ) {\n      return commands.getParticipantNode(participantId, type)\n        ?.props as ParticipantProps\n    },\n    useParticipantState(\n      participantId: string,\n      cb: (state: ParticipantProps) => void,\n      type = 'camera' as ParticipantType,\n    ) {\n      let participantNode = commands.getParticipantNode(participantId, type)\n\n      const sendState = () => {\n        cb(participantNode?.props as ParticipantProps)\n      }\n\n      // Watch for changes to the parent children\n      const childListener = CoreContext.onInternal('NodeChanged', (payload) => {\n        if (payload.nodeId !== content.id) return\n        const previous = participantNode\n        participantNode = commands.getParticipantNode(participantId, type)\n        if (previous !== participantNode) {\n          sendState()\n        }\n      })\n\n      // Watch for changes to the participant node\n      const participantListener = CoreContext.onInternal(\n        'NodeChanged',\n        (payload) => {\n          if (!participantNode || payload.nodeId !== participantNode.id) return\n          sendState()\n        },\n      )\n\n      sendState()\n\n      // Return disposable for listener\n      return () => {\n        childListener()\n        participantListener()\n      }\n    },\n\n    setParticipantVolume(participantId: string, volume: number) {\n      const node = commands.getParticipantNode(participantId)\n      if (!node) return\n      CoreContext.Command.updateNode({\n        nodeId: node.id,\n        props: {\n          volume,\n        },\n      })\n    },\n    setParticipantMuted(participantId: string, isMuted: boolean) {\n      const node = commands.getParticipantNode(participantId)\n      if (!node) return\n      CoreContext.Command.updateNode({\n        nodeId: node.id,\n        props: {\n          isMuted,\n        },\n      })\n    },\n    setParticipantHidden(participantId: string, isHidden: boolean) {\n      const node = commands.getParticipantNode(participantId)\n      if (!node) return\n      CoreContext.Command.updateNode({\n        nodeId: node.id,\n        props: {\n          isHidden,\n        },\n      })\n    },\n    pruneParticipants() {\n      // Remove all participant nodes that do not have active tracks\n      const room = getProjectRoom(projectId)\n      if (!room) return\n\n      content.children\n        .filter((node) => {\n          if (node.props.sourceType !== 'RoomParticipant') return false\n          const nodeSourceType = node.props.sourceProps?.type\n\n          // Get the participant associated with the node\n          const nodeParticipant = room.getParticipant(\n            node.props.sourceProps?.id,\n          )\n\n          // Get the participant track associated with the node\n          const nodeParticipantTrack = room.getTrack(node.props.sourceProps?.id)\n\n          // If the participant is not in the room, remove the node\n          if (!nodeParticipant && !nodeParticipantTrack) return true\n\n          // Keep \"camera\" nodes around as long as the participant is available.\n          //  This is to facilitate camera switching or other such feed interruptions\n          if (nodeSourceType === 'camera') return false\n\n          // Get all tracks associated with the node's participant\n          const participantTracks = nodeParticipant.trackIds\n            .map((x) => room.getTrack(x))\n            .filter(Boolean)\n\n          // Determine whether there is a track available to the node\n          const hasAvailableTrack = participantTracks.some((track) => {\n            // Get the source type as it corresponds to the track's type\n            const sourceType =\n              track.type === Track.Source.Camera ||\n              track.type === Track.Source.Microphone\n                ? 'camera'\n                : 'screen'\n\n            // Return true if the node source has a matching track\n            return sourceType === nodeSourceType\n          })\n\n          return !hasAvailableTrack\n        })\n        .forEach((x) => {\n          CoreContext.Command.deleteNode({\n            nodeId: x.id,\n          })\n        })\n    },\n    getProp(prop) {\n      return getProject(_project.id).props[prop]\n    },\n    setProp(prop, val) {\n      return Command.updateProjectProps({\n        projectId,\n        props: {\n          [prop]: val,\n        },\n      })\n    },\n    useProp(prop, cb) {\n      return CoreContext.on('ProjectChanged', (payload) => {\n        if (projectId === payload.project.id) {\n          cb(payload.project.props[prop])\n        }\n      })\n    },\n  }\n  const ensureValid = async () => {\n    await ensureRootLayersProps()\n    await ensureForegroundContainers()\n    beforeInit(commands)\n  }\n\n  ensureValid()\n\n  return commands\n}\n\nexport type LayoutProps = {\n  cover?: boolean\n  /** Valid CSS for justify-content */\n  justifyViewers?: 'flex-end' | 'center' | 'flex-start'\n  /** Percentage */\n  barWidth?: number\n  barPosition?: 'bottom' | 'side'\n  useGrid?: boolean\n  reverse?: boolean\n}\ntype ScenelessSettings = {\n  backgroundImage?: string\n  layout?: string\n  layoutProps?: LayoutProps\n}\n\n/**\n * **An abstraction over {@link Command.createProject Command.createProject()}.**\n *\n * A Project created using this function will be compatible with {@link ScenelessProject.commands ScenelessProject.commands()}\n *\n * **Emits: ProjectAdded**\n */\nexport const create = async (\n  settings: ScenelessSettings = {},\n  props: SDK.Props = {},\n  size?: { x: number; y: number },\n) => {\n  return CoreContext.Command.createProject({\n    settings,\n    props,\n    size,\n  }) as Promise<ScenelessProject>\n}\n\nexport const beforeInit = (commands: Commands) => {\n  /** autoPlay last applied video overlay on refresh */\n  const videoOverLay = commands.getVideoOverlay() as string\n\n  if (videoOverLay) {\n    commands.autoPlayVideoOverlay(videoOverLay, {\n      muted: true,\n      autoplay: true,\n    })\n  }\n\n  /** autoPlay last applied video background on refresh */\n  const backgroundVideo = commands.getBackgroundVideo()\n  if (backgroundVideo) {\n    commands.autoPlayBackgroundVideo({\n      muted: true,\n      autoplay: true,\n    })\n  }\n}\n/** @private */\nexport const createCompositor = async (\n  layoutId: string,\n  size: { x: number; y: number },\n  settings: ScenelessSettings,\n) => {\n  const { backgroundImage, layout, layoutProps = {} } = settings\n\n  // TODO: Batch insert\n  const project = await CoreContext.compositor.createProject(\n    {\n      props: {\n        name: 'Root',\n        type: 'sceneless-project',\n        sourceType: 'Element',\n        layout: 'Layered',\n        size,\n        isRoot: true,\n        tagName: 'div',\n        version: 'beta',\n        fields: {\n          style: { background: 'black' },\n        },\n      },\n    },\n    layoutId,\n  )\n  const root = project.getRoot()\n\n  // Create the base nodes for sceneless workflow\n  const baseLayers = await Promise.all([\n    project.insert(\n      {\n        name: 'Background',\n        id: 'bg',\n        layout: 'Layered',\n      },\n      root.id,\n    ),\n\n    project.insert(\n      {\n        id: 'content',\n        name: 'Content',\n        layout,\n        layoutProps,\n      },\n      root.id,\n    ),\n    project.insert(\n      {\n        id: 'foreground',\n        name: 'Overlays',\n        layout: 'Layered',\n      },\n      root.id,\n    ),\n  ])\n  await project.reorder(root.id, baseLayers)\n\n  const foreground = root.children.find((x) => x.props.id === 'foreground')\n\n  const baseForegroundLayers = await Promise.all([\n    project.insert(\n      {\n        name: 'ImageOverlay',\n        id: 'fg-image',\n        layout: 'Free',\n      },\n      foreground.id,\n    ),\n    project.insert(\n      {\n        name: 'Overlay',\n        sourceType: 'Overlay',\n        id: 'overlay',\n        layout: 'Free',\n        style: {\n          width: '100%',\n          height: '100%',\n          objectFit: 'cover',\n        },\n      },\n      foreground.id,\n    ),\n    project.insert(\n      {\n        name: 'BannerContainer',\n        id: 'fg-banners',\n        // NOTE: This is not ideal - currently only using layout\n        //  \"Column\" for its built-in animations\n        layout: 'Column',\n        layoutProps: {\n          cover: true,\n        },\n      },\n      foreground.id,\n    ),\n    project.insert(\n      {\n        name: 'VideoOverlay',\n        id: 'fg-video',\n        layout: 'Free',\n      },\n      foreground.id,\n    ),\n    project.insert(\n      {\n        name: 'VideoOverlay2',\n        layout: 'Free',\n        sourceType: 'Video2',\n        // this will enable to register a transfrom on another source\n        // doing so will enable to resume source\n        proxySource: 'Overlay',\n        id: 'video-overlay',\n        style: {\n          width: '100%',\n          height: '100%',\n          objectFit: 'cover',\n        },\n      },\n      foreground.id,\n    ),\n    project.insert(\n      {\n        name: 'Logo',\n        layout: 'Free',\n        sourceType: 'Logo',\n        id: 'logo',\n        style: {\n          width: '100%',\n          height: '100%',\n          objectFit: 'contain',\n          position: 'unset',\n        },\n      },\n      foreground.id,\n    ),\n  ])\n\n  await project.reorder(foreground.id, baseForegroundLayers)\n\n  const background = root.children.find((x) => x.props.id === 'bg')\n\n  const baseBackgroundLayers = await Promise.all([\n    project.insert(\n      {\n        name: 'ImageBackground',\n        id: 'bg-image',\n        tagName: 'img',\n        sourceType: 'Element',\n        attributes: {\n          src: backgroundImage,\n        },\n        fields: {\n          style: {\n            width: '100%',\n            height: '100%',\n            objectFit: 'cover',\n          },\n        },\n      },\n      background.id,\n    ),\n    project.insert(\n      {\n        name: 'ImageBackground2',\n        sourceType: 'Image2',\n        proxySource: 'Background',\n        id: 'image-background',\n        layout: 'Free',\n        src: backgroundImage,\n        style: {\n          width: '100%',\n          height: '100%',\n          objectFit: 'cover',\n        },\n      },\n      background.id,\n    ),\n    project.insert(\n      {\n        name: 'VideoBackground',\n        sourceType: 'Video2',\n        proxySource: 'Background',\n        id: 'video-background',\n        layout: 'Free',\n        style: {\n          width: '100%',\n          height: '100%',\n          objectFit: 'cover',\n        },\n      },\n      background.id,\n    ),\n  ])\n\n  await project.reorder(background.id, baseBackgroundLayers)\n\n  return project\n}\n","/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\n/**\n * Requests provide single-concern abstractions\n *  over the various backend APIs (Layout/Live).\n *\n * Not every external request is represented here. In some cases\n *  it is simpler to use the API SDK client interface directly.\n */\nimport {\n  CoreContext,\n  InternalProject,\n  InternalSource,\n  InternalUser,\n} from './context'\nimport { getAccessTokenData, getProject, getUser, hydrateProject } from './data'\nimport { Helpers } from '.'\nimport { Props, Role } from './types'\nimport { LiveApiModel } from '@api.stream/sdk'\n\nexport const createProject = async (request: {\n  settings?: { [prop: string]: any }\n  props?: Props // Arbitrary metadata (e.g. 'name')\n  size?: { x: number; y: number }\n  type?: 'sceneless' | 'freeform'\n}) => {\n  const collectionId = getUser().id\n  const type = request.type || 'sceneless'\n  const size = request.size || {\n    x: 1280,\n    y: 720,\n  }\n  const settings = request.settings || {}\n\n  // Create a project to go with the collection\n  let createProjectResponse = await CoreContext.clients\n    .LiveApi()\n    .project.createProject({\n      collectionId,\n      rendering: {\n        video: {\n          width: size.x,\n          height: size.y,\n          framerate: 30,\n        },\n      },\n      composition: {\n        studioSdk: { version: CoreContext.rendererVersion },\n      },\n      metadata: {},\n      webrtc: {\n        hosted: {},\n      },\n    })\n\n  const layout = await createLayout({\n    projectId: createProjectResponse.project.projectId,\n    collectionId: createProjectResponse.project.collectionId,\n    settings,\n    size,\n    type,\n  })\n\n  const { displayName } = getAccessTokenData()\n\n  // Save the layoutId on the project (no need to await)\n  const metadata = {\n    type,\n    layoutId: layout.id,\n    hostDisplayName: displayName,\n    props: request.props || {},\n  }\n  let projectResponse = await CoreContext.clients\n    .LiveApi()\n    .project.updateProject({\n      collectionId,\n      projectId: createProjectResponse.project.projectId,\n      updateMask: ['metadata'],\n      metadata,\n    })\n  createProjectResponse.project = projectResponse.project\n  createProjectResponse.project.metadata = metadata\n\n  return createProjectResponse\n}\n\nexport const deleteProject = async (request: { projectId: string }) => {\n  const { projectId } = request\n  const project = getProject(projectId)\n  const collectionId = getUser().id\n\n  await Promise.all([\n    CoreContext.clients.LiveApi().project.deleteProject({\n      collectionId,\n      projectId,\n    }),\n    CoreContext.clients.LayoutApi().layout.deleteLayout({\n      layoutId: project.layoutApi.layoutId,\n    }),\n  ])\n}\n\n/**\n * Load the user data from whatever access token has been registered\n *  with the API.\n */\nexport const loadUser = async (size?: {\n  x: number\n  y: number\n}): Promise<{\n  user: InternalUser\n  projects: InternalProject[]\n  sources: InternalSource[]\n}> => {\n  const collections = await loadCollections()\n\n  let collection: LiveApiModel.Collection\n\n  const { displayName, serviceUserId } = getAccessTokenData()\n\n  // Get a single collection, corresponding to a user\n  if (collections.length === 0) {\n    // If the user has no collections, create one\n    const response = await CoreContext.clients\n      .LiveApi()\n      .collection.createCollection({\n        metadata: {\n          serviceUserId,\n          displayName,\n          props: {},\n        },\n      })\n    collection = response.collection\n  } else {\n    // only 1 collection per user for studio-kit\n    collection = collections[0]\n  }\n\n  await CoreContext.clients\n    .LiveApi()\n    .subscribeToCollection(collection.collectionId)\n\n  // Take the Vapi Project and hydrate it with Compositor and Lapi project details\n  const projects = await Promise.all(\n    collection.projects.filter((p) => Boolean(p.metadata?.layoutId)).map((project) =>\n      hydrateProject(project, 'ROLE_HOST' as Role, size),\n    ),\n  )\n\n  return {\n    user: {\n      id: collection.collectionId,\n      metadata: collection.metadata,\n      props: collection.metadata?.props || {},\n      name: displayName,\n    },\n    projects,\n    sources: collection.sources,\n  }\n}\n\nexport const loadCollections = async () => {\n  let result = await CoreContext.clients.LiveApi().collection.getCollections({})\n  return result.collections\n}\n\nexport const createLayout = async (request: {\n  projectId: string\n  collectionId: string\n  settings: { [prop: string]: any }\n  size: { x: number; y: number }\n  type?: string\n}) => {\n  const { settings, size, type, projectId, collectionId } = request\n\n  const layout = await CoreContext.clients.LayoutApi().layout.createLayout({\n    layout: {\n      projectId,\n      collectionId,\n    },\n  })\n\n  if (type === 'sceneless') {\n    await Helpers.ScenelessProject.createCompositor(layout.id, size, settings)\n  } else {\n    await CoreContext.compositor.createProject(\n      {\n        props: {\n          name: 'Root',\n          layout: 'Free',\n          ...settings,\n          isRoot: true,\n          size,\n        },\n      },\n      layout.id,\n    )\n  }\n\n  return layout\n}\n"],"names":["createCompositor","layoutId","size","settings","backgroundImage","layout","layoutProps","project","CoreContext","compositor","createProject","props","name","type","sourceType","isRoot","tagName","version","fields","style","background","root","getRoot","baseLayers","Promise","all","insert","id","reorder","foreground","children","find","x","baseForegroundLayers","width","height","objectFit","cover","proxySource","position","baseBackgroundLayers","attributes","src","request","collectionId","getUser","y","createProjectResponse","clients","LiveApi","rendering","video","framerate","composition","studioSdk","rendererVersion","metadata","webrtc","hosted","createLayout","projectId","displayName","getAccessTokenData","hostDisplayName","projectResponse","updateProject","updateMask","deleteProject","getProject","LayoutApi","deleteLayout","layoutApi","loadUser","collections","loadCollections","collection","serviceUserId","length","response","createCollection","subscribeToCollection","projects","filter","p","Boolean","map","hydrateProject","user","sources","result","getCollections","Helpers"],"mappings":"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"}