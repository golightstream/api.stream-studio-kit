{"version":3,"file":"commands.16b951b8.js","sources":["../../../../src/core/commands.ts"],"sourcesContent":["/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\n/**\n * Commands represent actions that can be taken by a user.\n *\n * Most commands accept a contextual parameter `projectId`.\n * If this parameter is excluded from a function call, the user's\n * active project will be used instead.\n *\n * Upon completion, a command may emit zero or more {@link EventMap Events}. Commands\n * return Promises that will attempt to resolve to the most pertinent value.\n * However, it is good practice to instead rely on events where possible, when\n * updating application state.\n *\n * For example, listening for the event `BroadcastStarted` will indicate\n * the following scenarios:\n *\n *   - The current user has initiated a broadcast\n *   - A collaborator (or host) has initiated a broadcast\n *   - Some external force has initiated a broadcast\n *\n * When depending on the Event rather than the command's return value, we can\n * be sure that our state is updating under all relevant circumstances.\n *\n * ----\n *\n * _Note: Commands marked `internal` are low-level commands that should only be\n * used with caution. Higher-level abstractions should be used to manipulate Nodes\n * (elements on the stream canvas)._\n * \n * _See: **{@link ScenelessProject.Commands}**_\n *\n * @module Commands\n */\n\nimport { Project } from './context'\nimport {\n  getProject,\n  hydrateProject,\n  toBaseDestination,\n  toBaseProject,\n} from './data'\nimport { CoreContext } from './context'\nimport decode from 'jwt-decode'\nimport { Metadata } from './types'\nimport { SDK, Events, Compositor } from './namespaces'\nimport { webrtcManager } from './webrtc'\nimport { getRoom } from './webrtc/simple-room'\n\nconst { trigger, state } = CoreContext\n\n/**\n * Create a project with optional metadata.\n * \n * ----\n * _Note: This is a low level function that necessitates careful management\n *  of the nodes within. Consider {@link ScenelessProject.create} instead._\n *\n * **Emits {@link ProjectAdded}**\n *\n * @internal _Use with caution_\n * @category Project\n */\nexport const createProject = async (\n  payload: {\n    /** @private Props associated with ScenelessProject (or other such wrapper) */\n    props?: Metadata\n    /** Arbitrary metadata to associate with this project */\n    meta?: Metadata\n    /** Pixel dimenions of the canvas (default: `{ x: 1280, y: 720 }`) */\n    size?: { x: number; y: number }\n  } = {},\n) => {\n  const { props = {}, size, meta = {} } = payload\n  const collectionId = state.collectionId\n  const vapiProject = await CoreContext.Request.createProject({\n    collectionId,\n    props,\n    meta,\n    size,\n  })\n  const project = await hydrateProject(vapiProject.project)\n  const baseProject = toBaseProject(project)\n\n  // Update state\n  state.projects = [...state.projects, project]\n  /** @event ProjectAdded */\n  trigger('ProjectAdded', {\n    project: baseProject,\n  })\n  return baseProject\n}\n\n/**\n * Update a project's metadata with custom data opaque to the SDK.\n * \n * ----\n * **Emits {@link ProjectMetaUpdated}**\n *\n * @category Project\n */\nexport const updateProjectMeta = async (payload: {\n  projectId: Project['id']\n  /** Arbitrary metadata to associate with this project */\n  meta?: Metadata\n}) => {\n  const { projectId, meta = {} } = payload\n  const project = state.projects.find((x) => x.id === payload.projectId)\n  if (!project) {\n    return\n  }\n\n  const metadata = {\n    ...project.props,\n    ...meta,\n  }\n  await CoreContext.clients.LiveApi().project.updateProject({\n    collectionId: project.videoApi.project.collectionId,\n    projectId,\n    updateMask: ['metadata'],\n    metadata,\n  })\n\n  // Update state\n  project.props = metadata\n  trigger('ProjectMetaUpdated', {\n    projectId,\n    meta: project.props,\n  })\n  return metadata\n}\n\n/**\n * Set the active project for the user. This project will be used as the\n *  default project for commands that do not specify `payload.projectId`\n * \n * ----\n * **Emits {@link ActiveProjectChanged}**\n *\n * @category Project\n */\nexport const setActiveProject = async (payload: {\n  projectId: Project['id']\n}) => {\n  const project = state.projects.find((x) => x.id === payload.projectId)\n  if (!project) {\n    state.activeProjectId = null\n    trigger('ActiveProjectChanged', null)\n    return\n  }\n\n  const currentProject = state.projects.find(\n    (x) => x.id === state.activeProjectId,\n  )\n  if (project === currentProject) return\n  if (currentProject) {\n    // Perform any necessary cleanup\n    Array.from(webrtcManager.rooms.keys()).map(webrtcManager.removeRoom)\n    await CoreContext.clients\n      .LayoutApi()\n      .unsubscribeFromLayout(currentProject.layoutApi.layoutId)\n    await CoreContext.clients\n      .LiveApi()\n      .unsubscribeFromProject(\n        currentProject.videoApi.project.collectionId,\n        currentProject.videoApi.project.projectId,\n      )\n  }\n\n  await CoreContext.clients\n    .LayoutApi()\n    .subscribeToLayout(project.layoutApi.layoutId)\n  await CoreContext.clients\n    .LiveApi()\n    .subscribeToProject(\n      project.videoApi.project.collectionId,\n      project.videoApi.project.projectId,\n    )\n\n  // get current project state\n  let response = await CoreContext.clients.LiveApi().project.getProject({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n    status: true,\n  })\n  project.videoApi.phase = response.status.phase\n\n  // Update state\n  state.activeProjectId = project.id\n  trigger('ActiveProjectChanged', {\n    projectId: project.id,\n  })\n  return toBaseProject(project)\n}\n\n/**\n * Initiate WebRTC connection to the room associated with this project.\n * \n * ----\n * **Emits {@link RoomJoined}**\n *\n * @category Project\n */\nexport const joinRoom = async (payload: {\n  projectId: Project['id']\n  /** A public name for other guests will see associated with your {@link Participant} */\n  displayName?: string\n}) => {\n  const { projectId, displayName = 'Guest' } = payload\n  const project = state.projects.find((x) => x.id === projectId)\n\n  // Get the SFU token\n  let token = project.sfuToken\n  if (!token) {\n    let { webrtcAccess } = await CoreContext.clients\n      .LiveApi()\n      .authentication.createWebRtcAccessToken({\n        collectionId: project.videoApi.project.collectionId,\n        projectId: project.videoApi.project.projectId,\n        displayName,\n      })\n    token = webrtcAccess.accessToken\n  }\n  const tokenData = decode(token) as any\n  const roomName = tokenData.video.room\n  const url = new URL(CoreContext.clients.getLiveKitServer())\n  const baseUrl = url.host + url.pathname\n  const roomContext = webrtcManager.ensureRoom(baseUrl, roomName, token)\n  roomContext.bindApiClient(CoreContext.clients)\n  await roomContext.connect()\n\n  project.sfuToken = token\n  project.roomId = roomName\n  const room = getRoom(roomName)\n  trigger('RoomJoined', {\n    projectId: project.id,\n    room,\n  })\n  return room\n}\n\n/**\n * Create a node within the project's scene tree.\n * A node is functionally comparable to a DOM Node - it serves only as a vessel\n * of properties.\n *\n * A node is not inherently useful. It is up to the renderer to interpret the data it holds.\n * If a node is given data the renderer is not aware of, it will accomplish nothing.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject} \n * prevent the need for node manipulations._\n *\n * **Emits {@link NodeAdded}, {@link NodeChanged}**\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const createNode = async (payload: {\n  projectId?: string\n  props: { [prop: string]: any }\n  parentId: string\n  index?: number\n}) => {\n  let {\n    props = {},\n    parentId,\n    index,\n    projectId = state.activeProjectId,\n  } = payload\n  const project = getProject(projectId)\n  props = { ...props, layoutId: project.layoutApi.layoutId, type: 'child' }\n\n  // Update state\n  const nodeId = await project.compositor.insert(props, parentId, index)\n  trigger('NodeAdded', { projectId, nodeId })\n  trigger('NodeChanged', { projectId, nodeId: parentId })\n  return project.compositor.get(nodeId)\n}\n\n/**\n * Remove a node from the project's scene tree.\n * \n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject} \n * prevent the need for node manipulations._\n * \n * **Emits {@link NodeRemoved}, {@link NodeChanged}**\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const deleteNode = async (payload: {\n  projectId?: string\n  nodeId: string\n}) => {\n  let { nodeId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  const parentId = project.compositor.getParent(nodeId)?.id\n\n  // Update state\n  project.compositor.remove(nodeId)\n  trigger('NodeRemoved', { projectId, nodeId })\n  trigger('NodeChanged', { projectId, nodeId: parentId })\n}\n\n/**\n * Update the properties of a node.\n * `payload.props` will be shallowly merged onto its existing `props`.\n * \n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject} \n * prevent the need for node manipulations._\n * \n * **Emits {@link NodeChanged}**\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const updateNode = async (payload: {\n  projectId?: string\n  nodeId: string\n  props: { [prop: string]: any }\n}) => {\n  let { nodeId, props = {}, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  // Prune protected fields\n  delete props.type\n  delete props.sourceType\n\n  // Update state\n  project.compositor.update(nodeId, props)\n  trigger('NodeChanged', { projectId, nodeId })\n  return project.compositor.get(nodeId)\n}\n\n/**\n * Update the layout of a node.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject} \n * prevent the need for node manipulations._\n * \n * **Emits {@link NodeChanged}**\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const setNodeLayout = async (payload: {\n  projectId?: string\n  nodeId: string\n  layout: string\n  layoutProps?: { [prop: string]: any }\n}) => {\n  let {\n    nodeId,\n    layout,\n    projectId = state.activeProjectId,\n    layoutProps = {},\n  } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  project.compositor.update(nodeId, {\n    layout,\n    layoutProps,\n  })\n  trigger('NodeChanged', { projectId, nodeId })\n}\n\n/**\n * Move a node to a different parent node.\n * \n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject} \n * prevent the need for node manipulations._\n * \n * **Emits {@link NodeChanged}**\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const moveNode = async (payload: {\n  projectId?: string\n  nodeId: string\n  parentId: string\n  index?: number\n}) => {\n  const { nodeId, parentId, projectId = state.activeProjectId, index } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  project.compositor.move(nodeId, parentId, index)\n  // TODO: Determine if this is necessary (likely need only the events from Event API)\n  trigger('NodeChanged', { projectId, nodeId })\n}\n\n/**\n * Swap the positions of two nodes, changing parents if necessary.\n * \n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject} \n * prevent the need for node manipulations._\n * \n * **Emits {@link NodeChanged}**\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const swapNodes = async (payload: {\n  projectId?: string\n  nodeAId: string\n  nodeBId: string\n}) => {\n  const { nodeAId, nodeBId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  const parentAId = project.compositor.getParent(nodeAId)?.id\n  const parentBId = project.compositor.getParent(nodeBId)?.id\n\n  // Update state\n  project.compositor.swap(nodeAId, nodeBId)\n  trigger('NodeChanged', { projectId, nodeId: parentAId })\n  trigger('NodeChanged', { projectId, nodeId: parentBId })\n}\n\n/**\n * Change the order of a node's children.\n * \n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject} \n * prevent the need for node manipulations._\n * \n * **Emits {@link NodeChanged}**\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const reorderNodes = async (payload: {\n  projectId?: string\n  parentId: string\n  childIds: string[]\n}) => {\n  const { parentId, childIds, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  project.compositor.reorder(parentId, childIds)\n  trigger('NodeChanged', { projectId, nodeId: parentId })\n}\n\n/**\n * Start broadcasting a project.\n * \n * ----\n * _Note: Destination, encoding, and rendering details will be read from the Project\n * at time of broadcast, so they should be updated ahead of time._\n *\n * **Emits {@link BroadcastStarted}**\n *\n * @category Broadcast\n */\nexport const startBroadcast = async (payload: { projectId?: string }) => {\n  const { projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  await CoreContext.clients.LiveApi().project.startProjectBroadcast({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n  })\n  // Event is handled on receiving end of VideoAPI\n}\n\n/**\n * Stop broadcasting a project.\n * \n * ----\n * **Emits {@link BroadcastStopped}**\n *\n * @category Broadcast\n */\nexport const stopBroadcast = async (payload: { projectId?: string }) => {\n  const { projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  await CoreContext.clients.LiveApi().project.stopProjectBroadcast({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n  })\n  // Event is handled on receiving end of VideoAPI\n}\n\n/**\n * Add a {@link Destination} to a project.\n * \n * ----\n * **Emits {@link DestinationAdded}**\n *\n * @category Destination\n */\nexport const addDestination = async (payload: {\n  projectId?: string\n  rtmpUrl: string\n  rtmpKey: string\n  enabled: boolean\n  metadata?: object\n}) => {\n  const {\n    rtmpUrl,\n    rtmpKey,\n    enabled,\n    projectId = state.activeProjectId,\n    metadata,\n  } = payload\n  const project = getProject(projectId)\n  const address = {\n    rtmpPush: {\n      key: rtmpKey,\n      url: rtmpUrl,\n    },\n  } as SDK.Destination['address']\n\n  const result = await CoreContext.clients\n    .LiveApi()\n    .destination?.createDestination({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      address,\n      enabled,\n      metadata,\n    })\n\n  // Update state\n  project.videoApi.project.destinations.push(result.destination)\n\n  const destination = toBaseDestination(result.destination)\n  trigger('DestinationAdded', {\n    projectId,\n    destination,\n  })\n  return destination\n}\n\n/**\n * Remove a {@link Destination} from the project.\n * \n * ----\n * **Emits {@link DestinationRemoved}**\n *\n * @category Destination\n */\nexport const removeDestination = async (payload: {\n  projectId?: string\n  destinationId: string\n}) => {\n  const { destinationId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  await CoreContext.clients.LiveApi().destination?.deleteDestination({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n    destinationId,\n  })\n\n  // Update state\n  project.videoApi.project.destinations =\n    project.videoApi.project.destinations.filter(\n      (x) => x.destinationId !== destinationId,\n    )\n\n  trigger('DestinationRemoved', {\n    projectId,\n    destinationId,\n  })\n}\n\n/**\n * Update an existing {@link Destination} on the project.\n * \n * ----\n * **Emits {@link DestinationChanged}**\n *\n * @category Destination\n */\nexport const updateDestination = async (payload: {\n  projectId?: string\n  destinationId: string\n  rtmpUrl: string\n  rtmpKey: string\n}) => {\n  const {\n    rtmpUrl,\n    rtmpKey,\n    destinationId,\n    projectId = state.activeProjectId,\n  } = payload\n  const project = getProject(projectId)\n  const rtmpPush = {\n    key: rtmpKey,\n    url: rtmpUrl,\n  }\n\n  await CoreContext.clients.LiveApi().destination?.updateDestination({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n    destinationId,\n    updateMask: ['address.rtmpPush'],\n    address: {\n      rtmpPush,\n    },\n  })\n\n  // Update state\n  const destination = project.videoApi.project.destinations.find(\n    (x) => destinationId === x.destinationId,\n  )\n  destination.address.rtmpPush = rtmpPush\n  trigger('DestinationChanged', {\n    projectId,\n    destination: {\n      id: destination.destinationId,\n      enabled: destination.enabled,\n      address: destination.address,\n      props: destination.metadata,\n    },\n  })\n}\n\n/**\n * Update the metadata of an existing {@link Destination} on the project.\n * \n * ----\n * **Emits {@link DestinationChanged}**\n *\n * @category Destination\n */\nexport const updateDestinationMeta = async (payload: {\n  projectId: string\n  destinationId: string\n  metadata: SDK.Destination['props']\n}) => {\n  const { projectId, destinationId, metadata } = payload\n  const project = getProject(projectId)\n  \n  await CoreContext.clients.LiveApi().destination?.updateDestination({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n    destinationId,\n    updateMask: ['metadata'],\n    metadata,\n  })\n\n  const destination = project.videoApi.project.destinations.find(\n    (x) => destinationId === x.destinationId,\n  )\n  destination.metadata = metadata\n  trigger('DestinationChanged', {\n    projectId,\n    destination: {\n      id: destination.destinationId,\n      enabled: destination.enabled,\n      address: destination.address,\n      props: destination.metadata,\n    },\n  })\n}\n\n/**\n * Enable or disable an existing {@link Destination} on the project.\n * \n * ----\n * **Emits {@link DestinationEnabled}**\n *\n * @category Destination\n */\nexport const setDestinationEnabled = async (payload: {\n  projectId?: string\n  destinationId: string\n  enabled: boolean\n}) => {\n  const { enabled, destinationId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  const destination = project.videoApi.project.destinations.find(\n    (x) => destinationId === x.destinationId,\n  )\n  if (destination.enabled === enabled) return\n\n  await CoreContext.clients.LiveApi().destination?.updateDestination({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n    destinationId,\n    updateMask: ['enabled'],\n    enabled,\n  })\n\n  // Update state\n  destination.enabled = enabled\n\n  const event = enabled ? 'DestinationEnabled' : 'DestinationDisabled'\n  trigger(event, {\n    projectId,\n    destinationId,\n  })\n}\n\n/**\n * Overwrite project's first {@link Destination} with new configuration\n *  If no destination exists, one will be created instead.\n *\n * This is a helper to manage a single-destination project. For greater control,\n *  use {@link addDestination}, {@link removeDestination}, or {@link updateDestination}\n * \n * ----\n * **Emits {@link DestinationSet}**\n *\n * @category Destination\n */\nexport const setDestination = async (payload: {\n  projectId?: string\n  rtmpUrl: string\n  rtmpKey: string\n}) => {\n  const { rtmpUrl, rtmpKey, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  const rtmpPush = {\n    key: rtmpKey,\n    url: rtmpUrl,\n  }\n  const enabled = true\n\n  if (project.videoApi.project.destinations.length > 0) {\n    // Update existing\n    await CoreContext.clients.LiveApi().destination?.updateDestination({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      destinationId: project.videoApi.project.destinations[0].destinationId,\n      updateMask: ['address.rtmpPush'],\n      address: { rtmpPush },\n    })\n\n    // Update state\n    const destination = project.videoApi.project.destinations[0]\n    destination.address.rtmpPush = rtmpPush\n  } else {\n    // Create new\n    const result = await CoreContext.clients\n      .LiveApi()\n      .destination?.createDestination({\n        collectionId: project.videoApi.project.collectionId,\n        projectId: project.videoApi.project.projectId,\n        address: { rtmpPush },\n        enabled,\n      })\n\n    // Update state\n    project.videoApi.project.destinations.push(result.destination)\n  }\n\n  trigger('DestinationSet', {\n    projectId,\n    rtmpUrl,\n    rtmpKey,\n  })\n}\n"],"names":["trigger","state","CoreContext","createProject","payload","props","size","meta","collectionId","vapiProject","Request","project","hydrateProject","baseProject","toBaseProject","projects","updateProjectMeta","projectId","find","x","id","metadata","clients","LiveApi","updateProject","videoApi","updateMask","setActiveProject","activeProjectId","currentProject","Array","from","webrtcManager","rooms","keys","map","removeRoom","LayoutApi","unsubscribeFromLayout","layoutApi","layoutId","unsubscribeFromProject","subscribeToLayout","subscribeToProject","response","getProject","status","phase","joinRoom","displayName","token","sfuToken","webrtcAccess","authentication","createWebRtcAccessToken","accessToken","roomName","tokenData","decode","video","room","url","URL","getLiveKitServer","baseUrl","host","pathname","roomContext","ensureRoom","bindApiClient","connect","roomId","getRoom","createNode","parentId","index","type","nodeId","compositor","insert","get","deleteNode","getParent","remove","updateNode","sourceType","update","setNodeLayout","layout","layoutProps","moveNode","move","swapNodes","nodeAId","nodeBId","parentAId","parentBId","swap","reorderNodes","childIds","reorder","startBroadcast","startProjectBroadcast","stopBroadcast","stopProjectBroadcast","addDestination","rtmpUrl","rtmpKey","enabled","address","rtmpPush","key","result","destination","createDestination","destinations","push","toBaseDestination","removeDestination","destinationId","deleteDestination","filter","updateDestination","updateDestinationMeta","setDestinationEnabled","setDestination","length"],"mappings":"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"}