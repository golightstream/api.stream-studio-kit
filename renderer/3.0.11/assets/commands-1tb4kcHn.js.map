{"version":3,"file":"commands-1tb4kcHn.js","sources":["../../../../src/core/commands.ts"],"sourcesContent":["/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\n/**\n * Commands represent actions that can be taken by a user.\n *\n * Most commands accept a contextual parameter `projectId`.\n * If this parameter is excluded from a function call, the user's\n * active project will be used instead.\n *\n * Upon completion, a command may emit zero or more {@link EventMap Events}. Commands\n * return Promises that will attempt to resolve to the most pertinent value.\n * However, it is good practice to instead rely on events where possible, when\n * updating application state.\n *\n * For example, listening for the event `BroadcastStarted` will indicate\n * the following scenarios:\n *\n *   - The current user has initiated a broadcast\n *   - A collaborator (or host) has initiated a broadcast\n *   - Some external force has initiated a broadcast\n *\n * When depending on the Event rather than the command's return value, we can\n * be sure that our state is updating under all relevant circumstances.\n *\n * ----\n *\n * _Note: Commands marked `internal` are low-level commands that should only be\n * used with caution. Higher-level abstractions should be used to manipulate Nodes\n * (elements on the stream canvas)._\n *\n * @private This module is currently hidden from users of the Studio Kit.\n *  Favor the creation of helpers when supporting developers who require\n *  functionality contained in this module.\n *\n * @module Commands\n */\n\nimport {\n  getProject,\n  getUser,\n  hydrateProject,\n  toBaseDestination,\n  toBaseProject,\n} from './data'\nimport { CoreContext } from './context'\nimport { jwtDecode } from 'jwt-decode'\nimport { Props } from './types'\nimport { SDK } from './namespaces'\nimport { LiveApiModel } from '@api.stream/sdk'\nimport { webrtcManager } from './webrtc'\nimport { getRoom } from './webrtc/simple-room'\nimport { trigger, triggerInternal } from './events'\nimport { DeepPartial } from '../logic'\n\nconst { state } = CoreContext\n\n/**\n * Update the current user's metadata with custom data opaque to the SDK.\n * Existing props are not affected unless explicitly overwritten.\n *\n * @category User\n */\nexport const updateUserProps = async (payload: {\n  /** Arbitrary metadata to associate with the user */\n  props?: Props\n}) => {\n  const collection = getUser()\n  if (!collection) return\n\n  const props = {\n    ...collection.props,\n    ...payload.props,\n  }\n  const response = await CoreContext.clients\n    .LiveApi()\n    .collection.updateCollection({\n      collectionId: collection.id,\n      updateMask: ['metadata'],\n      metadata: {\n        ...collection.metadata,\n        props,\n      },\n    })\n\n  // Trigger event to update state\n  await triggerInternal('UserChanged', response.collection)\n  return\n}\n\n/**\n * Create a source\n *\n * @category Source\n */\nexport const createSource = async (payload: {\n  projectId: string\n  displayName?: string\n  address?: Partial<LiveApiModel.SourceAddress>\n  props?: any\n}) => {\n  const collectionId = getUser().id\n\n  const { source } = await CoreContext.clients.LiveApi().source.createSource({\n    metadata: { props: payload.props || {} },\n    collectionId,\n    address: payload.address,\n    preview: {\n      webrtc: {\n        enabled: true,\n        displayName: payload.displayName || 'RTMP Source',\n      },\n    },\n  })\n\n  // Trigger event to update state\n  await triggerInternal('SourceAdded', source)\n\n  // Add source to project\n\n  const response = await CoreContext.clients\n    .LiveApi()\n    .source.addSourceToProject({\n      collectionId,\n      projectId: payload.projectId,\n      sourceId: source.sourceId,\n    })\n\n  await triggerInternal('ProjectSourceAdded', {\n    projectId: response.project.projectId,\n    source,\n  })\n\n  return source\n}\n\n/**\n * Get all sources in the collection\n *\n * @category Source\n */\nconst getSources = async () => {\n  const collectionId = getUser().id\n\n  const { sources } = await CoreContext.clients\n    .LiveApi()\n    .source.getSources({ collectionId })\n\n  return sources\n}\n\nconst getSource = async (payload: { sourceId: string }) => {\n  const collectionId = getUser().id\n\n  const { source } = await CoreContext.clients.LiveApi().source.getSource({\n    collectionId,\n    sourceId: payload.sourceId,\n  })\n\n  return source\n}\n\n/**\n * Update a source metadata and/or displayName\n *\n * @category Source\n */\nexport const updateSource = async (payload: {\n  sourceId: string\n  metadata?: any\n  displayName?: string\n}) => {\n  const collectionId = getUser().id\n  let updateMask: string[] = []\n  let updateProps: Partial<LiveApiModel.UpdateSourceRequest> = {}\n  if (payload.metadata) {\n    updateMask.push('metadata')\n    updateProps.metadata = payload.metadata\n  }\n  if (payload.displayName) {\n    updateMask.push('preview.webrtc.displayName')\n    updateProps = {\n      ...updateProps,\n      preview: {\n        webrtc: {\n          displayName: payload.displayName,\n        },\n      },\n    }\n  }\n  const { source } = await CoreContext.clients.LiveApi().source.updateSource({\n    collectionId,\n    updateMask,\n    sourceId: payload.sourceId,\n    ...updateProps,\n  })\n\n  // Trigger event to update state\n  await triggerInternal('SourceChanged', source)\n\n  return source\n}\n\n/**\n * Delete a source\n *\n * @category Source\n */\nexport const deleteSource = async (payload: {\n  projectId: string\n  sourceId: string\n  force?: boolean\n}) => {\n  const collectionId = getUser().id\n  const removeRes = await CoreContext.clients\n    .LiveApi()\n    .source.removeSourceFromProject({\n      collectionId,\n      projectId: payload.projectId,\n      sourceId: payload.sourceId,\n    })\n\n  await triggerInternal('ProjectSourceRemoved', {\n    projectId: payload.projectId,\n    sourceId: payload.sourceId,\n  })\n\n  const response = await CoreContext.clients\n    .LiveApi()\n    .source.deleteSource({ sourceId: payload.sourceId, collectionId })\n\n  await triggerInternal('SourceRemoved', payload.sourceId)\n  return response\n}\n\n/**\n * Create a project with optional metadata.\n *\n * ----\n * _Note: This is a low level function that necessitates careful management\n *  of the nodes within. Consider {@link ScenelessProject.create} instead._\n *\n * @category Project\n */\nexport const createProject = async (\n  payload: {\n    /** @private Settings associated with ScenelessProject (or other such wrapper) */\n    settings?: { [prop: string]: any }\n    /** Arbitrary metadata to associate with this project */\n    props?: Props\n    /** Pixel dimenions of the canvas (default: `{ x: 1280, y: 720 }`) */\n    size?: { x: number; y: number }\n    type?: 'sceneless' | 'freeform'\n  } = {},\n) => {\n  const { props = {}, size, settings = {}, type } = payload\n  const response = await CoreContext.Request.createProject({\n    settings,\n    props,\n    size,\n    type,\n  })\n\n  // Trigger event to update state\n  await triggerInternal('ProjectAdded', response.project)\n\n  // Return the base project directly, for convenience\n  const internalProject = await hydrateProject(\n    response.project,\n    'ROLE_HOST' as SDK.Role,\n  )\n  return toBaseProject(internalProject)\n}\n\n/**\n * @private\n * Recreate a project's associated layout\n */\nexport const recreateLayout = async (payload: {\n  projectId: string\n  props?: Props\n}) => {\n  const { projectId, props = {} } = payload\n  const collectionId = getUser().id\n\n  // Get the Vapi project\n  const response = await CoreContext.clients.LiveApi().project.getProject({\n    collectionId,\n    projectId,\n    status: true,\n  })\n\n  // Return if the project is actively broadcasting\n  if (\n    [\n      SDK.ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING,\n      SDK.ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STARTING,\n    ].includes(response.status.phase)\n  ) {\n    return\n  }\n\n  const metadata = response.project.metadata || {}\n  const { layoutId } = metadata\n  const { video } = response.project.rendering\n  const { type } = response.project.metadata.props || {}\n\n  // Create the new layout\n  const layout = await CoreContext.Request.createLayout({\n    collectionId,\n    projectId,\n    type: type || 'sceneless',\n    settings: {},\n    size: {\n      x: video.width,\n      y: video.height,\n    },\n  })\n\n  // Set the new layout on the project\n  const updateResponse = await CoreContext.clients\n    .LiveApi()\n    .project.updateProject({\n      collectionId,\n      projectId,\n      updateMask: ['metadata'],\n      metadata: {\n        ...metadata,\n        layoutId: layout.id,\n      },\n    })\n\n  CoreContext.log.debug('New layout assigned to project:', { layout })\n\n  // Trigger event to update state\n  await triggerInternal('ProjectChanged', { project: updateResponse.project })\n\n  // Delete the previous layout\n  await CoreContext.clients.LayoutApi().layout.deleteLayout({\n    layoutId,\n  })\n\n  CoreContext.log.debug('Previous layout deleted:', { layoutId })\n\n  // Return the base project directly, for convenience\n  const internalProject = await hydrateProject(\n    updateResponse.project,\n    'ROLE_HOST' as SDK.Role,\n  )\n\n  // Add props to the root node\n  await internalProject.compositor.update(\n    internalProject.compositor.getRoot().id,\n    props,\n  )\n\n  /** return original project as well as internal project */\n  return { project: toBaseProject(internalProject), internalProject }\n}\n/**\n * Delete a project.\n *\n * @category Project\n */\nexport const deleteProject = async (payload: {\n  projectId: SDK.Project['id']\n}) => {\n  const { projectId } = payload\n  await CoreContext.Request.deleteProject({\n    projectId,\n  })\n\n  // Trigger event to update state\n  await triggerInternal('ProjectRemoved', { projectId })\n  return\n}\n\n/**\n * Update a project's metadata with custom data opaque to the SDK.\n * Existing props are not affected unless explicitly overwritten.\n *\n * @category Project\n */\nexport const updateProjectProps = async (payload: {\n  projectId: SDK.Project['id']\n  /** Arbitrary metadata to associate with this project */\n  props?: Props\n}) => {\n  const { projectId } = payload\n  const collectionId = getUser().id\n  const project = getProject(projectId)\n\n  const props = {\n    ...project.props,\n    ...payload.props,\n  }\n  const response = await CoreContext.clients.LiveApi().project.updateProject({\n    collectionId,\n    projectId,\n    updateMask: ['metadata'],\n    metadata: {\n      ...project.videoApi.project.metadata,\n      props,\n    },\n  })\n\n  // Trigger event to update state\n  await triggerInternal('ProjectChanged', { project: response.project })\n  return\n}\n\n/**\n * @private Use updateProjectProps without internaltriggers\n */\nexport const updateProjectPropsWithoutTrigger = async (payload: {\n  projectId: SDK.Project['id']\n  /** Arbitrary metadata to associate with this project */\n  props?: Props\n}) => {\n  const { projectId } = payload\n  const collectionId = getUser().id\n  const project = getProject(projectId)\n\n  const props = {\n    ...project.props,\n    ...payload.props,\n  }\n  const response = await CoreContext.clients.LiveApi().project.updateProject({\n    collectionId,\n    projectId,\n    updateMask: ['metadata'],\n    metadata: {\n      ...project.videoApi.project.metadata,\n      props,\n    },\n  })\n  return\n}\n\n/**\n * Set the active project for the user, setting up event handlers and\n *  disposing of event listeners for the previous active project.\n *\n * This project will be used as the default project\n *  for commands that do not specify `payload.projectId`\n *\n * @category Project\n */\nexport const setActiveProject = async (payload: {\n  projectId: SDK.Project['id']\n}): Promise<SDK.Project> => {\n  const project = state.projects.find((x) => x.id === payload.projectId)\n  if (!project) {\n    state.activeProjectId = null\n    triggerInternal('ActiveProjectChanged', { projectId: null })\n    return\n  }\n\n  const currentProject = state.projects.find(\n    (x) => x.id === state.activeProjectId,\n  )\n  if (project === currentProject) return\n  if (currentProject) {\n    // Perform any necessary cleanup\n    Array.from(webrtcManager.rooms.keys()).map(webrtcManager.removeRoom)\n    await CoreContext.clients\n      .LayoutApi()\n      .unsubscribeFromLayout(currentProject.layoutApi.layoutId)\n    await CoreContext.clients\n      .LiveApi()\n      .unsubscribeFromProject(\n        currentProject.videoApi.project.collectionId,\n        currentProject.videoApi.project.projectId,\n      )\n    await CoreContext.clients\n      .LiveApi()\n      .unsubscribeFromCollection(currentProject.videoApi.project.collectionId)\n  }\n\n  await CoreContext.clients\n    .LayoutApi()\n    .subscribeToLayout(project.layoutApi.layoutId)\n\n  await CoreContext.clients\n    .LiveApi()\n    .subscribeToProject(\n      project.videoApi.project.collectionId,\n      project.videoApi.project.projectId,\n    )\n\n  await CoreContext.clients\n    .LiveApi()\n    .subscribeToCollection(project.videoApi.project.collectionId)\n\n  // Asynchronously ensure latest project state\n  CoreContext.clients\n    .LiveApi()\n    .project.getProject({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      status: true,\n    })\n    .then((response) => {\n      triggerInternal('ProjectChanged', {\n        project: response.project,\n        phase: response.status?.phase,\n        broadcastId: response.status?.broadcastId,\n      })\n    })\n\n  triggerInternal('ActiveProjectChanged', {\n    projectId: project.id,\n  })\n  return toBaseProject(project)\n}\n\n/**\n * Initiate WebRTC connection to the room associated with this project.\n *\n * @category Project\n */\nexport const joinRoom = async (payload: {\n  projectId: SDK.Project['id']\n  /** A public name for other guests will see associated with your {@link Participant} */\n  displayName?: string\n}) => {\n  const { projectId, displayName = 'Guest' } = payload\n  const project = state.projects.find((x) => x.id === projectId)\n\n  // Get the SFU token\n  let token = project.sfuToken\n  if (!token) {\n    let { webrtcAccess } = await CoreContext.clients\n      .LiveApi()\n      .authentication.createWebRtcAccessToken({\n        collectionId: project.videoApi.project.collectionId,\n        projectId: project.videoApi.project.projectId,\n        displayName,\n      })\n    token = webrtcAccess.accessToken\n  }\n  const tokenData = jwtDecode(token) as any\n  const roomName = tokenData.video.room\n  const url = new URL(CoreContext.clients.getLiveKitServer())\n  const baseUrl = url.host + url.pathname\n  const roomContext = webrtcManager.ensureRoom(baseUrl, roomName, token)\n  roomContext.bindApiClient(CoreContext.clients)\n  await roomContext.connect()\n\n  project.sfuToken = token\n  project.roomId = roomName\n  const room = getRoom(roomName)\n  trigger('RoomJoined', {\n    projectId: project.id,\n    room,\n  })\n  return room\n}\n\n/**\n * Create a node within the project's scene tree.\n * A node is functionally comparable to a DOM Node - it serves only as a vessel\n * of properties.\n *\n * A node is not inherently useful. It is up to the renderer to interpret the data it holds.\n * If a node is given data the renderer is not aware of, it will accomplish nothing.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const createNode = async (payload: {\n  projectId?: string\n  props?: { [prop: string]: any }\n  parentId: string\n  index?: number\n}) => {\n  let {\n    props = {},\n    parentId,\n    index,\n    projectId = state.activeProjectId,\n  } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  const nodeId = await project.compositor.insert(props, parentId, index)\n  triggerInternal('NodeAdded', { projectId, nodeId })\n  triggerInternal('NodeChanged', { projectId, nodeId: parentId })\n  return project.compositor.get(nodeId)\n}\n\n/**\n * Remove a node from the project's scene tree.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const deleteNode = async (payload: {\n  projectId?: string\n  nodeId: string\n}) => {\n  let { nodeId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  const parentId = project.compositor.getParent(nodeId)?.id\n\n  // Update state\n  project.compositor.remove(nodeId)\n  triggerInternal('NodeRemoved', { projectId, nodeId })\n  triggerInternal('NodeChanged', { projectId, nodeId: parentId })\n}\n\n/**\n * Update the properties of a node.\n * `payload.props` will be shallowly merged onto its existing `props`.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const updateNode = async (payload: {\n  projectId?: string\n  nodeId: string\n  props: { [prop: string]: any }\n}) => {\n  let { nodeId, props = {}, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  // Prune protected fields\n  delete props.type\n  delete props.sourceType\n\n  // Update state\n  project.compositor.update(nodeId, props)\n  triggerInternal('NodeChanged', { projectId, nodeId })\n  return project.compositor.get(nodeId)\n}\n\n/**\n * Update the layout of a node.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const setNodeLayout = async (payload: {\n  projectId?: string\n  nodeId: string\n  layout: string\n  layoutProps?: { [prop: string]: any }\n}) => {\n  let {\n    nodeId,\n    layout,\n    projectId = state.activeProjectId,\n    layoutProps = {},\n  } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  project.compositor.update(nodeId, {\n    layout,\n    layoutProps,\n  })\n  triggerInternal('NodeChanged', { projectId, nodeId })\n}\n\n/**\n * Move a node to a different parent node.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const moveNode = async (payload: {\n  projectId?: string\n  nodeId: string\n  parentId: string\n  index?: number\n}) => {\n  const { nodeId, parentId, projectId = state.activeProjectId, index } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  project.compositor.move(nodeId, parentId, index)\n  // TODO: Determine if this is necessary (likely need only the events from Event API)\n  triggerInternal('NodeChanged', { projectId, nodeId })\n}\n\n/**\n * Swap the positions of two nodes, changing parents if necessary.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const swapNodes = async (payload: {\n  projectId?: string\n  nodeAId: string\n  nodeBId: string\n}) => {\n  const { nodeAId, nodeBId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  const parentAId = project.compositor.getParent(nodeAId)?.id\n  const parentBId = project.compositor.getParent(nodeBId)?.id\n\n  // Update state\n  project.compositor.swap(nodeAId, nodeBId)\n  triggerInternal('NodeChanged', { projectId, nodeId: parentAId })\n  triggerInternal('NodeChanged', { projectId, nodeId: parentBId })\n}\n\n/**\n * Change the order of a node's children.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject}\n * prevent the need for node manipulations._\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const reorderNodes = async (payload: {\n  projectId?: string\n  parentId: string\n  childIds: string[]\n}) => {\n  const { parentId, childIds, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  project.compositor.reorder(parentId, childIds)\n  triggerInternal('NodeChanged', { projectId, nodeId: parentId })\n}\n\n/**\n * Start broadcasting a project.\n *\n * ----\n * _Note: Destination, encoding, and rendering details will be read from the Project\n * at time of broadcast, so they should be updated ahead of time._\n *\n * @category Broadcast\n */\n\nexport const startBroadcast = async (payload: {\n  projectId?: string\n  dynamicSources?: DeepPartial<\n    LiveApiModel.StartProjectBroadcastRequest['dynamicSources']\n  >\n  props?: Props\n}) => {\n  const { projectId = state.activeProjectId, dynamicSources, props } = payload\n  const project = getProject(projectId)\n\n  await CoreContext.clients.LiveApi().project.startProjectBroadcast({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n    ...(dynamicSources && { dynamicSources }),\n    ...(props && { triggerMetadata: { ...props } }),\n  })\n  // Event is handled on receiving end of VideoAPI\n}\n\n/**\n * Stop broadcasting a project.\n *\n * @category Broadcast\n */\nexport const stopBroadcast = async (payload: { projectId?: string }) => {\n  const { projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  await CoreContext.clients.LiveApi().project.stopProjectBroadcast({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n  })\n  // Event is handled on receiving end of VideoAPI\n}\n\n/**\n * Add a {@link Destination} to a project.\n *\n * @category Destination\n */\nexport const addDestination = async (payload: {\n  projectId?: string\n  rtmpUrl: string\n  rtmpKey: string\n  enabled: boolean\n  props?: Props\n}) => {\n  const {\n    rtmpUrl,\n    rtmpKey,\n    enabled,\n    projectId = state.activeProjectId,\n    props = {},\n  } = payload\n  const project = getProject(projectId)\n  const address = {\n    rtmpPush: {\n      key: rtmpKey,\n      url: rtmpUrl,\n    },\n  } as SDK.Destination['address']\n\n  const response = await CoreContext.clients\n    .LiveApi()\n    .destination?.createDestination({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      address,\n      enabled,\n      metadata: {\n        props,\n      },\n    })\n\n  // Trigger event to update state\n  await triggerInternal('DestinationAdded', response.destination)\n  return toBaseDestination(response.destination)\n}\n\n/**\n * Remove a {@link Destination} from the project.\n *\n * @category Destination\n */\nexport const removeDestination = async (payload: {\n  projectId?: string\n  destinationId: string\n}) => {\n  const { destinationId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  await CoreContext.clients.LiveApi().destination?.deleteDestination({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n    destinationId,\n  })\n\n  // Trigger event to update state\n  await triggerInternal('DestinationRemoved', { projectId, destinationId })\n  return\n}\n\n/**\n * Update an existing {@link Destination} on the project.\n *\n * @category Destination\n */\nexport const updateDestination = async (payload: {\n  projectId?: string\n  destinationId: string\n  rtmpUrl: string\n  rtmpKey: string\n}) => {\n  const {\n    rtmpUrl,\n    rtmpKey,\n    destinationId,\n    projectId = state.activeProjectId,\n  } = payload\n  const project = getProject(projectId)\n\n  const rtmpPush = {\n    key: rtmpKey,\n    url: rtmpUrl,\n  }\n\n  const response = await CoreContext.clients\n    .LiveApi()\n    .destination?.updateDestination({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      destinationId,\n      updateMask: ['address.rtmpPush'],\n      address: {\n        rtmpPush,\n      },\n    })\n\n  // Trigger event to update state\n  await triggerInternal('DestinationChanged', response.destination)\n  return\n}\n\n/**\n * Update the metadata of an existing {@link Destination} on the project.\n *\n * @category Destination\n */\nexport const updateDestinationProps = async (payload: {\n  projectId: string\n  destinationId: string\n  props: Props\n}) => {\n  const {\n    projectId = state.activeProjectId,\n    destinationId,\n    props = {},\n  } = payload\n  const project = getProject(projectId)\n  const destination = project.videoApi.project.destinations.find(\n    (x) => x.destinationId === destinationId,\n  )\n  if (!destination) return\n\n  const response = await CoreContext.clients\n    .LiveApi()\n    .destination?.updateDestination({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      destinationId,\n      updateMask: ['metadata'],\n      metadata: {\n        ...(destination.metadata || {}),\n        props: {\n          ...(destination.metadata?.props || {}),\n          ...props,\n        },\n      },\n    })\n\n  // Trigger event to update state\n  await triggerInternal('DestinationChanged', response.destination)\n  return\n}\n\n/**\n * Enable or disable an existing {@link Destination} on the project.\n *\n * @category Destination\n */\nexport const setDestinationEnabled = async (payload: {\n  projectId?: string\n  destinationId: string\n  enabled: boolean\n}) => {\n  const { enabled, destinationId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  const destination = project.videoApi.project.destinations.find(\n    (x) => destinationId === x.destinationId,\n  )\n  if (destination.enabled === enabled) return\n\n  const response = await CoreContext.clients\n    .LiveApi()\n    .destination?.updateDestination({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      destinationId,\n      updateMask: ['enabled'],\n      enabled,\n    })\n\n  // Trigger event to update state\n  await triggerInternal('DestinationChanged', response.destination)\n}\n\n/**\n * Overwrite project's first {@link Destination} with new configuration\n *  If no destination exists, one will be created instead.\n *\n * This is a helper to manage a single-destination project. For greater control,\n *  use {@link addDestination}, {@link removeDestination}, or {@link updateDestination}\n *\n * @category Destination\n */\nexport const setDestination = async (payload: {\n  projectId?: string\n  rtmpUrl: string\n  rtmpKey: string\n}) => {\n  const { rtmpUrl, rtmpKey, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  const rtmpPush = {\n    key: rtmpKey,\n    url: rtmpUrl,\n  }\n  const enabled = true\n\n  if (project.videoApi.project.destinations.length > 0) {\n    // Update existing\n    const response = await CoreContext.clients\n      .LiveApi()\n      .destination?.updateDestination({\n        collectionId: project.videoApi.project.collectionId,\n        projectId: project.videoApi.project.projectId,\n        destinationId: project.videoApi.project.destinations[0].destinationId,\n        updateMask: ['address.rtmpPush'],\n        address: { rtmpPush },\n      })\n\n    // Trigger event to update state\n    await triggerInternal('DestinationChanged', response.destination)\n  } else {\n    // Create new\n    const response = await CoreContext.clients\n      .LiveApi()\n      .destination?.createDestination({\n        collectionId: project.videoApi.project.collectionId,\n        projectId: project.videoApi.project.projectId,\n        address: { rtmpPush },\n        enabled,\n      })\n\n    // Trigger event to update state\n    await triggerInternal('DestinationAdded', response.destination)\n  }\n}\n"],"names":["state","CoreContext","updateUserProps","payload","collection","getUser","props","response","clients","LiveApi","updateCollection","collectionId","id","updateMask","metadata","triggerInternal","createSource","source","address","preview","webrtc","enabled","displayName","addSourceToProject","projectId","sourceId","project","updateSource","updateProps","push","deleteSource","removeSourceFromProject","createProject","size","settings","type","Request","internalProject","hydrateProject","toBaseProject","recreateLayout","getProject","status","SDK","PROJECT_BROADCAST_PHASE_RUNNING","PROJECT_BROADCAST_PHASE_STARTING","includes","phase","layoutId","video","rendering","layout","createLayout","x","width","y","height","updateResponse","updateProject","log","debug","LayoutApi","deleteLayout","compositor","update","getRoot","deleteProject","updateProjectProps","videoApi","updateProjectPropsWithoutTrigger","setActiveProject","projects","find","activeProjectId","currentProject","Array","from","webrtcManager","rooms","keys","map","removeRoom","unsubscribeFromLayout","layoutApi","unsubscribeFromProject","unsubscribeFromCollection","subscribeToLayout","subscribeToProject","subscribeToCollection","then","broadcastId","joinRoom","token","sfuToken","webrtcAccess","authentication","createWebRtcAccessToken","accessToken","roomName","jwtDecode","room","url","URL","getLiveKitServer","baseUrl","host","pathname","roomContext","ensureRoom","bindApiClient","connect","roomId","getRoom","trigger","createNode","parentId","index","nodeId","insert","get","deleteNode","getParent","remove","updateNode","sourceType","setNodeLayout","layoutProps","moveNode","move","swapNodes","nodeAId","nodeBId","parentAId","parentBId","swap","reorderNodes","childIds","reorder","startBroadcast","dynamicSources","startProjectBroadcast","triggerMetadata","stopBroadcast","stopProjectBroadcast","addDestination","rtmpUrl","rtmpKey","rtmpPush","key","destination","createDestination","toBaseDestination","removeDestination","destinationId","deleteDestination","updateDestination","updateDestinationProps","destinations","setDestinationEnabled","setDestination","length"],"mappings":"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"}