{"version":3,"file":"commands.6d5d1093.js","sources":["../../../../src/core/commands.ts"],"sourcesContent":["/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\n/**\n * Commands represent actions that can be taken by a user.\n *\n * Most commands accept a contextual parameter `projectId`.\n * If this parameter is excluded from a function call, the user's\n * active project will be used instead.\n *\n * Upon completion, a command may emit zero or more {@link EventMap Events}. Commands\n * return Promises that will attempt to resolve to the most pertinent value.\n * However, it is good practice to instead rely on events where possible, when\n * updating application state.\n *\n * For example, listening for the event `BroadcastStarted` will indicate\n * the following scenarios:\n *\n *   - The current user has initiated a broadcast\n *   - A collaborator (or host) has initiated a broadcast\n *   - Some external force has initiated a broadcast\n *\n * When depending on the Event rather than the command's return value, we can\n * be sure that our state is updating under all relevant circumstances.\n *\n * ----\n *\n * _Note: Commands marked `internal` are low-level commands that should only be\n * used with caution. Higher-level abstractions should be used to manipulate Nodes\n * (elements on the stream canvas)._\n * \n * _See: **{@link ScenelessProject.Commands}**_\n *\n * @module Commands\n */\n\nimport { Project } from './context'\nimport {\n  getProject,\n  hydrateProject,\n  toBaseDestination,\n  toBaseProject,\n} from './data'\nimport { CoreContext } from './context'\nimport decode from 'jwt-decode'\nimport { Metadata } from './types'\nimport { SDK, Events, Compositor } from './namespaces'\nimport { webrtcManager } from './webrtc'\nimport { getRoom } from './webrtc/simple-room'\n\nconst { trigger, state } = CoreContext\n\n/**\n * Create a project with optional metadata.\n * \n * ----\n * _Note: This is a low level function that necessitates careful management\n *  of the nodes within. Consider {@link ScenelessProject.create} instead._\n *\n * **Emits {@link ProjectAdded}**\n *\n * @internal _Use with caution_\n * @category Project\n */\nexport const createProject = async (\n  payload: {\n    /** @private Props associated with ScenelessProject (or other such wrapper) */\n    props?: Metadata\n    /** Arbitrary metadata to associate with this project */\n    meta?: Metadata\n    /** Pixel dimenions of the canvas (default: `{ x: 1280, y: 720 }`) */\n    size?: { x: number; y: number }\n  } = {},\n) => {\n  const { props = {}, size, meta = {} } = payload\n  const collectionId = state.collectionId\n  const vapiProject = await CoreContext.Request.createProject({\n    collectionId,\n    props,\n    meta,\n    size,\n  })\n  const project = await hydrateProject(vapiProject.project)\n  const baseProject = toBaseProject(project)\n\n  // Update state\n  state.projects = [...state.projects, project]\n  /** @event ProjectAdded */\n  trigger('ProjectAdded', {\n    project: baseProject,\n  })\n  return baseProject\n}\n\n/**\n * Update a project's metadata with custom data opaque to the SDK.\n * \n * ----\n * **Emits {@link ProjectMetaUpdated}**\n *\n * @category Project\n */\nexport const updateProjectMeta = async (payload: {\n  projectId: Project['id']\n  /** Arbitrary metadata to associate with this project */\n  meta?: Metadata\n}) => {\n  const { projectId, meta = {} } = payload\n  const project = state.projects.find((x) => x.id === payload.projectId)\n  if (!project) {\n    return\n  }\n\n  const metadata = {\n    ...project.props,\n    ...meta,\n  }\n  await CoreContext.clients.LiveApi().project.updateProject({\n    collectionId: project.videoApi.project.collectionId,\n    projectId,\n    updateMask: ['metadata'],\n    metadata,\n  })\n\n  // Update state\n  project.props = metadata\n  trigger('ProjectMetaUpdated', {\n    projectId,\n    meta: project.props,\n  })\n  return metadata\n}\n\n/**\n * Set the active project for the user. This project will be used as the\n *  default project for commands that do not specify `payload.projectId`\n * \n * ----\n * **Emits {@link ActiveProjectChanged}**\n *\n * @category Project\n */\nexport const setActiveProject = async (payload: {\n  projectId: Project['id']\n}) => {\n  const project = state.projects.find((x) => x.id === payload.projectId)\n  if (!project) {\n    state.activeProjectId = null\n    trigger('ActiveProjectChanged', null)\n    return\n  }\n\n  const currentProject = state.projects.find(\n    (x) => x.id === state.activeProjectId,\n  )\n  if (project === currentProject) return\n  if (currentProject) {\n    // Perform any necessary cleanup\n    Array.from(webrtcManager.rooms.keys()).map(webrtcManager.removeRoom)\n    await CoreContext.clients\n      .LayoutApi()\n      .unsubscribeFromLayout(currentProject.layoutApi.layoutId)\n    await CoreContext.clients\n      .LiveApi()\n      .unsubscribeFromProject(\n        currentProject.videoApi.project.collectionId,\n        currentProject.videoApi.project.projectId,\n      )\n  }\n\n  await CoreContext.clients\n    .LayoutApi()\n    .subscribeToLayout(project.layoutApi.layoutId)\n  await CoreContext.clients\n    .LiveApi()\n    .subscribeToProject(\n      project.videoApi.project.collectionId,\n      project.videoApi.project.projectId,\n    )\n\n  // get current project state\n  let response = await CoreContext.clients.LiveApi().project.getProject({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n    status: true,\n  })\n  project.videoApi.phase = response.status.phase\n\n  // Update state\n  state.activeProjectId = project.id\n  trigger('ActiveProjectChanged', {\n    projectId: project.id,\n  })\n  return toBaseProject(project)\n}\n\n/**\n * Initiate WebRTC connection to the room associated with this project.\n * \n * ----\n * **Emits {@link RoomJoined}**\n *\n * @category Project\n */\nexport const joinRoom = async (payload: {\n  projectId: Project['id']\n  /** A public name for other guests will see associated with your {@link Participant} */\n  displayName?: string\n}) => {\n  const { projectId, displayName = 'Guest' } = payload\n  const project = state.projects.find((x) => x.id === projectId)\n\n  // Get the SFU token\n  let token = project.sfuToken\n  if (!token) {\n    let { webrtcAccess } = await CoreContext.clients\n      .LiveApi()\n      .authentication.createWebRtcAccessToken({\n        collectionId: project.videoApi.project.collectionId,\n        projectId: project.videoApi.project.projectId,\n        displayName,\n      })\n    token = webrtcAccess.accessToken\n  }\n  const tokenData = decode(token) as any\n  const roomName = tokenData.video.room\n  const url = new URL(CoreContext.clients.getLiveKitServer())\n  const baseUrl = url.host + url.pathname\n  const roomContext = webrtcManager.ensureRoom(baseUrl, roomName, token)\n  roomContext.bindApiClient(CoreContext.clients)\n  await roomContext.connect({\n    logLevel: CoreContext.logLevel as any\n  })\n\n  project.sfuToken = token\n  project.roomId = roomName\n  const room = getRoom(roomName)\n  trigger('RoomJoined', {\n    projectId: project.id,\n    room,\n  })\n  return room\n}\n\n/**\n * Create a node within the project's scene tree.\n * A node is functionally comparable to a DOM Node - it serves only as a vessel\n * of properties.\n *\n * A node is not inherently useful. It is up to the renderer to interpret the data it holds.\n * If a node is given data the renderer is not aware of, it will accomplish nothing.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject} \n * prevent the need for node manipulations._\n *\n * **Emits {@link NodeAdded}, {@link NodeChanged}**\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const createNode = async (payload: {\n  projectId?: string\n  props: { [prop: string]: any }\n  parentId: string\n  index?: number\n}) => {\n  let {\n    props = {},\n    parentId,\n    index,\n    projectId = state.activeProjectId,\n  } = payload\n  const project = getProject(projectId)\n  props = { ...props, layoutId: project.layoutApi.layoutId, type: 'child' }\n\n  // Update state\n  const nodeId = await project.compositor.insert(props, parentId, index)\n  trigger('NodeAdded', { projectId, nodeId })\n  trigger('NodeChanged', { projectId, nodeId: parentId })\n  return project.compositor.get(nodeId)\n}\n\n/**\n * Remove a node from the project's scene tree.\n * \n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject} \n * prevent the need for node manipulations._\n * \n * **Emits {@link NodeRemoved}, {@link NodeChanged}**\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const deleteNode = async (payload: {\n  projectId?: string\n  nodeId: string\n}) => {\n  let { nodeId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  const parentId = project.compositor.getParent(nodeId)?.id\n\n  // Update state\n  project.compositor.remove(nodeId)\n  trigger('NodeRemoved', { projectId, nodeId })\n  trigger('NodeChanged', { projectId, nodeId: parentId })\n}\n\n/**\n * Update the properties of a node.\n * `payload.props` will be shallowly merged onto its existing `props`.\n * \n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject} \n * prevent the need for node manipulations._\n * \n * **Emits {@link NodeChanged}**\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const updateNode = async (payload: {\n  projectId?: string\n  nodeId: string\n  props: { [prop: string]: any }\n}) => {\n  let { nodeId, props = {}, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  // Prune protected fields\n  delete props.type\n  delete props.sourceType\n\n  // Update state\n  project.compositor.update(nodeId, props)\n  trigger('NodeChanged', { projectId, nodeId })\n  return project.compositor.get(nodeId)\n}\n\n/**\n * Update the layout of a node.\n *\n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject} \n * prevent the need for node manipulations._\n * \n * **Emits {@link NodeChanged}**\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const setNodeLayout = async (payload: {\n  projectId?: string\n  nodeId: string\n  layout: string\n  layoutProps?: { [prop: string]: any }\n}) => {\n  let {\n    nodeId,\n    layout,\n    projectId = state.activeProjectId,\n    layoutProps = {},\n  } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  project.compositor.update(nodeId, {\n    layout,\n    layoutProps,\n  })\n  trigger('NodeChanged', { projectId, nodeId })\n}\n\n/**\n * Move a node to a different parent node.\n * \n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject} \n * prevent the need for node manipulations._\n * \n * **Emits {@link NodeChanged}**\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const moveNode = async (payload: {\n  projectId?: string\n  nodeId: string\n  parentId: string\n  index?: number\n}) => {\n  const { nodeId, parentId, projectId = state.activeProjectId, index } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  project.compositor.move(nodeId, parentId, index)\n  // TODO: Determine if this is necessary (likely need only the events from Event API)\n  trigger('NodeChanged', { projectId, nodeId })\n}\n\n/**\n * Swap the positions of two nodes, changing parents if necessary.\n * \n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject} \n * prevent the need for node manipulations._\n * \n * **Emits {@link NodeChanged}**\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const swapNodes = async (payload: {\n  projectId?: string\n  nodeAId: string\n  nodeBId: string\n}) => {\n  const { nodeAId, nodeBId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  const parentAId = project.compositor.getParent(nodeAId)?.id\n  const parentBId = project.compositor.getParent(nodeBId)?.id\n\n  // Update state\n  project.compositor.swap(nodeAId, nodeBId)\n  trigger('NodeChanged', { projectId, nodeId: parentAId })\n  trigger('NodeChanged', { projectId, nodeId: parentBId })\n}\n\n/**\n * Change the order of a node's children.\n * \n * ----\n * _Note: This is a low level interface. Abstractions like {@link ScenelessProject} \n * prevent the need for node manipulations._\n * \n * **Emits {@link NodeChanged}**\n *\n * @internal _Use with caution_\n * @category Node\n */\nexport const reorderNodes = async (payload: {\n  projectId?: string\n  parentId: string\n  childIds: string[]\n}) => {\n  const { parentId, childIds, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  // Update state\n  project.compositor.reorder(parentId, childIds)\n  trigger('NodeChanged', { projectId, nodeId: parentId })\n}\n\n/**\n * Start broadcasting a project.\n * \n * ----\n * _Note: Destination, encoding, and rendering details will be read from the Project\n * at time of broadcast, so they should be updated ahead of time._\n *\n * **Emits {@link BroadcastStarted}**\n *\n * @category Broadcast\n */\nexport const startBroadcast = async (payload: { projectId?: string }) => {\n  const { projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  await CoreContext.clients.LiveApi().project.startProjectBroadcast({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n  })\n  // Event is handled on receiving end of VideoAPI\n}\n\n/**\n * Stop broadcasting a project.\n * \n * ----\n * **Emits {@link BroadcastStopped}**\n *\n * @category Broadcast\n */\nexport const stopBroadcast = async (payload: { projectId?: string }) => {\n  const { projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  await CoreContext.clients.LiveApi().project.stopProjectBroadcast({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n  })\n  // Event is handled on receiving end of VideoAPI\n}\n\n/**\n * Add a {@link Destination} to a project.\n * \n * ----\n * **Emits {@link DestinationAdded}**\n *\n * @category Destination\n */\nexport const addDestination = async (payload: {\n  projectId?: string\n  rtmpUrl: string\n  rtmpKey: string\n  enabled: boolean\n}) => {\n  const {\n    rtmpUrl,\n    rtmpKey,\n    enabled,\n    projectId = state.activeProjectId,\n  } = payload\n  const project = getProject(projectId)\n  const address = {\n    rtmpPush: {\n      key: rtmpKey,\n      url: rtmpUrl,\n    },\n  } as SDK.Destination['address']\n\n  const result = await CoreContext.clients\n    .LiveApi()\n    .destination?.createDestination({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      address,\n      enabled,\n    })\n\n  // Update state\n  project.videoApi.project.destinations.push(result.destination)\n\n  const destination = toBaseDestination(result.destination)\n  trigger('DestinationAdded', {\n    projectId,\n    destination,\n  })\n  return destination\n}\n\n/**\n * Remove a {@link Destination} from the project.\n * \n * ----\n * **Emits {@link DestinationRemoved}**\n *\n * @category Destination\n */\nexport const removeDestination = async (payload: {\n  projectId?: string\n  destinationId: string\n}) => {\n  const { destinationId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n\n  await CoreContext.clients.LiveApi().destination?.deleteDestination({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n    destinationId,\n  })\n\n  // Update state\n  project.videoApi.project.destinations =\n    project.videoApi.project.destinations.filter(\n      (x) => x.destinationId !== destinationId,\n    )\n\n  trigger('DestinationRemoved', {\n    projectId,\n    destinationId,\n  })\n}\n\n/**\n * Update an existing {@link Destination} on the project.\n * \n * ----\n * **Emits {@link DestinationUpdated}**\n *\n * @category Destination\n */\nexport const updateDestination = async (payload: {\n  projectId?: string\n  destinationId: string\n  rtmpUrl: string\n  rtmpKey: string\n}) => {\n  const {\n    rtmpUrl,\n    rtmpKey,\n    destinationId,\n    projectId = state.activeProjectId,\n  } = payload\n  const project = getProject(projectId)\n  const rtmpPush = {\n    key: rtmpKey,\n    url: rtmpUrl,\n  }\n\n  await CoreContext.clients.LiveApi().destination?.updateDestination({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n    destinationId,\n    updateMask: ['address.rtmpPush'],\n    address: {\n      rtmpPush,\n    },\n  })\n\n  // Update state\n  const destination = project.videoApi.project.destinations.find(\n    (x) => destinationId === x.destinationId,\n  )\n  destination.address.rtmpPush = rtmpPush\n\n  trigger('DestinationUpdated', {\n    projectId,\n    destinationId,\n    rtmpKey,\n    rtmpUrl,\n  })\n}\n\n/**\n * Enable or disable an existing {@link Destination} on the project.\n * \n * ----\n * **Emits {@link DestinationUpdated}**\n *\n * @category Destination\n */\nexport const setDestinationEnabled = async (payload: {\n  projectId?: string\n  destinationId: string\n  enabled: boolean\n}) => {\n  const { enabled, destinationId, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  const destination = project.videoApi.project.destinations.find(\n    (x) => destinationId === x.destinationId,\n  )\n  if (destination.enabled === enabled) return\n\n  await CoreContext.clients.LiveApi().destination?.updateDestination({\n    collectionId: project.videoApi.project.collectionId,\n    projectId: project.videoApi.project.projectId,\n    destinationId,\n    updateMask: ['enabled'],\n    enabled,\n  })\n\n  // Update state\n  destination.enabled = enabled\n\n  const event = enabled ? 'DestinationEnabled' : 'DestinationDisabled'\n  trigger(event, {\n    projectId,\n    destinationId,\n  })\n}\n\n/**\n * Overwrite project's first {@link Destination} with new configuration\n *  If no destination exists, one will be created instead.\n *\n * This is a helper to manage a single-destination project. For greater control,\n *  use {@link addDestination}, {@link removeDestination}, or {@link updateDestination}\n * \n * ----\n * **Emits {@link DestinationSet}**\n *\n * @category Destination\n */\nexport const setDestination = async (payload: {\n  projectId?: string\n  rtmpUrl: string\n  rtmpKey: string\n}) => {\n  const { rtmpUrl, rtmpKey, projectId = state.activeProjectId } = payload\n  const project = getProject(projectId)\n  const rtmpPush = {\n    key: rtmpKey,\n    url: rtmpUrl,\n  }\n  const enabled = true\n\n  if (project.videoApi.project.destinations.length > 0) {\n    // Update existing\n    await CoreContext.clients.LiveApi().destination?.updateDestination({\n      collectionId: project.videoApi.project.collectionId,\n      projectId: project.videoApi.project.projectId,\n      destinationId: project.videoApi.project.destinations[0].destinationId,\n      updateMask: ['address.rtmpPush'],\n      address: { rtmpPush },\n    })\n\n    // Update state\n    const destination = project.videoApi.project.destinations[0]\n    destination.address.rtmpPush = rtmpPush\n  } else {\n    // Create new\n    const result = await CoreContext.clients\n      .LiveApi()\n      .destination?.createDestination({\n        collectionId: project.videoApi.project.collectionId,\n        projectId: project.videoApi.project.projectId,\n        address: { rtmpPush },\n        enabled,\n      })\n\n    // Update state\n    project.videoApi.project.destinations.push(result.destination)\n  }\n\n  trigger('DestinationSet', {\n    projectId,\n    rtmpUrl,\n    rtmpKey,\n  })\n}\n"],"names":["trigger","state","CoreContext","createProject","payload","props","size","meta","collectionId","vapiProject","Request","project","hydrateProject","baseProject","toBaseProject","projects","updateProjectMeta","projectId","find","x","id","metadata","clients","LiveApi","updateProject","videoApi","updateMask","setActiveProject","activeProjectId","currentProject","Array","from","webrtcManager","rooms","keys","map","removeRoom","LayoutApi","unsubscribeFromLayout","layoutApi","layoutId","unsubscribeFromProject","subscribeToLayout","subscribeToProject","response","getProject","status","phase","joinRoom","displayName","token","sfuToken","webrtcAccess","authentication","createWebRtcAccessToken","accessToken","roomName","tokenData","decode","video","room","url","URL","getLiveKitServer","baseUrl","host","pathname","roomContext","ensureRoom","bindApiClient","connect","logLevel","roomId","getRoom","createNode","parentId","index","type","nodeId","compositor","insert","get","deleteNode","getParent","remove","updateNode","sourceType","update","setNodeLayout","layout","layoutProps","moveNode","move","swapNodes","nodeAId","nodeBId","parentAId","parentBId","swap","reorderNodes","childIds","reorder","startBroadcast","startProjectBroadcast","stopBroadcast","stopProjectBroadcast","addDestination","rtmpUrl","rtmpKey","enabled","address","rtmpPush","key","result","destination","createDestination","destinations","push","toBaseDestination","removeDestination","destinationId","deleteDestination","filter","updateDestination","setDestinationEnabled","setDestination","length"],"mappings":"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"}