{"version":3,"file":"index-BcprsmUc.js","sources":["../../../../examples/studio-kit-demo/node_modules/object-assign/index.js","../../../../examples/studio-kit-demo/node_modules/react/cjs/react.production.min.js","../../../../examples/studio-kit-demo/node_modules/react/index.js","../../../../examples/studio-kit-demo/node_modules/scheduler/cjs/scheduler.production.min.js","../../../../examples/studio-kit-demo/node_modules/scheduler/index.js","../../../../examples/studio-kit-demo/node_modules/react-dom/cjs/react-dom.production.min.js","../../../../examples/studio-kit-demo/node_modules/react-dom/index.js","../../../../examples/studio-kit-demo/node_modules/react/cjs/react-jsx-runtime.production.min.js","../../../../examples/studio-kit-demo/node_modules/react/jsx-runtime.js","../../../../examples/studio-kit-demo/react/jsx-runtime","../../../../dist/index.js","../../../../examples/studio-kit-demo/src/shared/context.tsx","../../../../examples/studio-kit-demo/src/shared/participant.tsx","../../../../examples/studio-kit-demo/src/shared/control-panel.tsx","../../../../examples/studio-kit-demo/src/shared/chat.tsx","../../../../examples/studio-kit-demo/config.ts","../../../../examples/studio-kit-demo/logo.png"],"sourcesContent":["/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","/** @license React v17.0.2\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var l=require(\"object-assign\"),n=60103,p=60106;exports.Fragment=60107;exports.StrictMode=60108;exports.Profiler=60114;var q=60109,r=60110,t=60112;exports.Suspense=60113;var u=60115,v=60116;\nif(\"function\"===typeof Symbol&&Symbol.for){var w=Symbol.for;n=w(\"react.element\");p=w(\"react.portal\");exports.Fragment=w(\"react.fragment\");exports.StrictMode=w(\"react.strict_mode\");exports.Profiler=w(\"react.profiler\");q=w(\"react.provider\");r=w(\"react.context\");t=w(\"react.forward_ref\");exports.Suspense=w(\"react.suspense\");u=w(\"react.memo\");v=w(\"react.lazy\")}var x=\"function\"===typeof Symbol&&Symbol.iterator;\nfunction y(a){if(null===a||\"object\"!==typeof a)return null;a=x&&a[x]||a[\"@@iterator\"];return\"function\"===typeof a?a:null}function z(a){for(var b=\"https://reactjs.org/docs/error-decoder.html?invariant=\"+a,c=1;c<arguments.length;c++)b+=\"&args[]=\"+encodeURIComponent(arguments[c]);return\"Minified React error #\"+a+\"; visit \"+b+\" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\"}\nvar A={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},B={};function C(a,b,c){this.props=a;this.context=b;this.refs=B;this.updater=c||A}C.prototype.isReactComponent={};C.prototype.setState=function(a,b){if(\"object\"!==typeof a&&\"function\"!==typeof a&&null!=a)throw Error(z(85));this.updater.enqueueSetState(this,a,b,\"setState\")};C.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,\"forceUpdate\")};\nfunction D(){}D.prototype=C.prototype;function E(a,b,c){this.props=a;this.context=b;this.refs=B;this.updater=c||A}var F=E.prototype=new D;F.constructor=E;l(F,C.prototype);F.isPureReactComponent=!0;var G={current:null},H=Object.prototype.hasOwnProperty,I={key:!0,ref:!0,__self:!0,__source:!0};\nfunction J(a,b,c){var e,d={},k=null,h=null;if(null!=b)for(e in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=\"\"+b.key),b)H.call(b,e)&&!I.hasOwnProperty(e)&&(d[e]=b[e]);var g=arguments.length-2;if(1===g)d.children=c;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];d.children=f}if(a&&a.defaultProps)for(e in g=a.defaultProps,g)void 0===d[e]&&(d[e]=g[e]);return{$$typeof:n,type:a,key:k,ref:h,props:d,_owner:G.current}}\nfunction K(a,b){return{$$typeof:n,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function L(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===n}function escape(a){var b={\"=\":\"=0\",\":\":\"=2\"};return\"$\"+a.replace(/[=:]/g,function(a){return b[a]})}var M=/\\/+/g;function N(a,b){return\"object\"===typeof a&&null!==a&&null!=a.key?escape(\"\"+a.key):b.toString(36)}\nfunction O(a,b,c,e,d){var k=typeof a;if(\"undefined\"===k||\"boolean\"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case \"string\":case \"number\":h=!0;break;case \"object\":switch(a.$$typeof){case n:case p:h=!0}}if(h)return h=a,d=d(h),a=\"\"===e?\".\"+N(h,0):e,Array.isArray(d)?(c=\"\",null!=a&&(c=a.replace(M,\"$&/\")+\"/\"),O(d,b,c,\"\",function(a){return a})):null!=d&&(L(d)&&(d=K(d,c+(!d.key||h&&h.key===d.key?\"\":(\"\"+d.key).replace(M,\"$&/\")+\"/\")+a)),b.push(d)),1;h=0;e=\"\"===e?\".\":e+\":\";if(Array.isArray(a))for(var g=\n0;g<a.length;g++){k=a[g];var f=e+N(k,g);h+=O(k,b,c,f,d)}else if(f=y(a),\"function\"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=e+N(k,g++),h+=O(k,b,c,f,d);else if(\"object\"===k)throw b=\"\"+a,Error(z(31,\"[object Object]\"===b?\"object with keys {\"+Object.keys(a).join(\", \")+\"}\":b));return h}function P(a,b,c){if(null==a)return a;var e=[],d=0;O(a,e,\"\",\"\",function(a){return b.call(c,a,d++)});return e}\nfunction Q(a){if(-1===a._status){var b=a._result;b=b();a._status=0;a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}if(1===a._status)return a._result;throw a._result;}var R={current:null};function S(){var a=R.current;if(null===a)throw Error(z(321));return a}var T={ReactCurrentDispatcher:R,ReactCurrentBatchConfig:{transition:0},ReactCurrentOwner:G,IsSomeRendererActing:{current:!1},assign:l};\nexports.Children={map:P,forEach:function(a,b,c){P(a,function(){b.apply(this,arguments)},c)},count:function(a){var b=0;P(a,function(){b++});return b},toArray:function(a){return P(a,function(a){return a})||[]},only:function(a){if(!L(a))throw Error(z(143));return a}};exports.Component=C;exports.PureComponent=E;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=T;\nexports.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(z(267,a));var e=l({},a.props),d=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=G.current);void 0!==b.key&&(d=\"\"+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)H.call(b,f)&&!I.hasOwnProperty(f)&&(e[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)e.children=c;else if(1<f){g=Array(f);for(var m=0;m<f;m++)g[m]=arguments[m+2];e.children=g}return{$$typeof:n,type:a.type,\nkey:d,ref:k,props:e,_owner:h}};exports.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:r,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:q,_context:a};return a.Consumer=a};exports.createElement=J;exports.createFactory=function(a){var b=J.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};exports.forwardRef=function(a){return{$$typeof:t,render:a}};exports.isValidElement=L;\nexports.lazy=function(a){return{$$typeof:v,_payload:{_status:-1,_result:a},_init:Q}};exports.memo=function(a,b){return{$$typeof:u,type:a,compare:void 0===b?null:b}};exports.useCallback=function(a,b){return S().useCallback(a,b)};exports.useContext=function(a,b){return S().useContext(a,b)};exports.useDebugValue=function(){};exports.useEffect=function(a,b){return S().useEffect(a,b)};exports.useImperativeHandle=function(a,b,c){return S().useImperativeHandle(a,b,c)};\nexports.useLayoutEffect=function(a,b){return S().useLayoutEffect(a,b)};exports.useMemo=function(a,b){return S().useMemo(a,b)};exports.useReducer=function(a,b,c){return S().useReducer(a,b,c)};exports.useRef=function(a){return S().useRef(a)};exports.useState=function(a){return S().useState(a)};exports.version=\"17.0.2\";\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n","/** @license React v0.20.2\n * scheduler.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var f,g,h,k;if(\"object\"===typeof performance&&\"function\"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()}}else{var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q}}\nif(\"undefined\"===typeof window||\"function\"!==typeof MessageChannel){var t=null,u=null,w=function(){if(null!==t)try{var a=exports.unstable_now();t(!0,a);t=null}catch(b){throw setTimeout(w,0),b;}};f=function(a){null!==t?setTimeout(f,0,a):(t=a,setTimeout(w,0))};g=function(a,b){u=setTimeout(a,b)};h=function(){clearTimeout(u)};exports.unstable_shouldYield=function(){return!1};k=exports.unstable_forceFrameRate=function(){}}else{var x=window.setTimeout,y=window.clearTimeout;if(\"undefined\"!==typeof console){var z=\nwindow.cancelAnimationFrame;\"function\"!==typeof window.requestAnimationFrame&&console.error(\"This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills\");\"function\"!==typeof z&&console.error(\"This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills\")}var A=!1,B=null,C=-1,D=5,E=0;exports.unstable_shouldYield=function(){return exports.unstable_now()>=\nE};k=function(){};exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error(\"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\"):D=0<a?Math.floor(1E3/a):5};var F=new MessageChannel,G=F.port2;F.port1.onmessage=function(){if(null!==B){var a=exports.unstable_now();E=a+D;try{B(!0,a)?G.postMessage(null):(A=!1,B=null)}catch(b){throw G.postMessage(null),b;}}else A=!1};f=function(a){B=a;A||(A=!0,G.postMessage(null))};g=function(a,b){C=\nx(function(){a(exports.unstable_now())},b)};h=function(){y(C);C=-1}}function H(a,b){var c=a.length;a.push(b);a:for(;;){var d=c-1>>>1,e=a[d];if(void 0!==e&&0<I(e,b))a[d]=b,a[c]=e,c=d;else break a}}function J(a){a=a[0];return void 0===a?null:a}\nfunction K(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length;d<e;){var m=2*(d+1)-1,n=a[m],v=m+1,r=a[v];if(void 0!==n&&0>I(n,c))void 0!==r&&0>I(r,n)?(a[d]=r,a[v]=c,d=v):(a[d]=n,a[m]=c,d=m);else if(void 0!==r&&0>I(r,c))a[d]=r,a[v]=c,d=v;else break a}}return b}return null}function I(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}var L=[],M=[],N=1,O=null,P=3,Q=!1,R=!1,S=!1;\nfunction T(a){for(var b=J(M);null!==b;){if(null===b.callback)K(M);else if(b.startTime<=a)K(M),b.sortIndex=b.expirationTime,H(L,b);else break;b=J(M)}}function U(a){S=!1;T(a);if(!R)if(null!==J(L))R=!0,f(V);else{var b=J(M);null!==b&&g(U,b.startTime-a)}}\nfunction V(a,b){R=!1;S&&(S=!1,h());Q=!0;var c=P;try{T(b);for(O=J(L);null!==O&&(!(O.expirationTime>b)||a&&!exports.unstable_shouldYield());){var d=O.callback;if(\"function\"===typeof d){O.callback=null;P=O.priorityLevel;var e=d(O.expirationTime<=b);b=exports.unstable_now();\"function\"===typeof e?O.callback=e:O===J(L)&&K(L);T(b)}else K(L);O=J(L)}if(null!==O)var m=!0;else{var n=J(M);null!==n&&g(U,n.startTime-b);m=!1}return m}finally{O=null,P=c,Q=!1}}var W=k;exports.unstable_IdlePriority=5;\nexports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){R||Q||(R=!0,f(V))};exports.unstable_getCurrentPriorityLevel=function(){return P};exports.unstable_getFirstCallbackNode=function(){return J(L)};\nexports.unstable_next=function(a){switch(P){case 1:case 2:case 3:var b=3;break;default:b=P}var c=P;P=b;try{return a()}finally{P=c}};exports.unstable_pauseExecution=function(){};exports.unstable_requestPaint=W;exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=P;P=a;try{return b()}finally{P=c}};\nexports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();\"object\"===typeof c&&null!==c?(c=c.delay,c=\"number\"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3}e=c+e;a={id:N++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,H(M,a),null===J(L)&&a===J(M)&&(S?h():S=!0,g(U,c-d))):(a.sortIndex=e,H(L,a),R||Q||(R=!0,f(V)));return a};\nexports.unstable_wrapCallback=function(a){var b=P;return function(){var c=P;P=b;try{return a.apply(this,arguments)}finally{P=c}}};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/scheduler.production.min.js');\n} else {\n  module.exports = require('./cjs/scheduler.development.js');\n}\n","/** @license React v17.0.2\n * react-dom.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/\n'use strict';var aa=require(\"react\"),m=require(\"object-assign\"),r=require(\"scheduler\");function y(a){for(var b=\"https://reactjs.org/docs/error-decoder.html?invariant=\"+a,c=1;c<arguments.length;c++)b+=\"&args[]=\"+encodeURIComponent(arguments[c]);return\"Minified React error #\"+a+\"; visit \"+b+\" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\"}if(!aa)throw Error(y(227));var ba=new Set,ca={};function da(a,b){ea(a,b);ea(a+\"Capture\",b)}\nfunction ea(a,b){ca[a]=b;for(a=0;a<b.length;a++)ba.add(b[a])}\nvar fa=!(\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement),ha=/^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$/,ia=Object.prototype.hasOwnProperty,\nja={},ka={};function la(a){if(ia.call(ka,a))return!0;if(ia.call(ja,a))return!1;if(ha.test(a))return ka[a]=!0;ja[a]=!0;return!1}function ma(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case \"function\":case \"symbol\":return!0;case \"boolean\":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return\"data-\"!==a&&\"aria-\"!==a;default:return!1}}\nfunction na(a,b,c,d){if(null===b||\"undefined\"===typeof b||ma(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function B(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g}var D={};\n\"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style\".split(\" \").forEach(function(a){D[a]=new B(a,0,!1,a,null,!1,!1)});[[\"acceptCharset\",\"accept-charset\"],[\"className\",\"class\"],[\"htmlFor\",\"for\"],[\"httpEquiv\",\"http-equiv\"]].forEach(function(a){var b=a[0];D[b]=new B(b,1,!1,a[1],null,!1,!1)});[\"contentEditable\",\"draggable\",\"spellCheck\",\"value\"].forEach(function(a){D[a]=new B(a,2,!1,a.toLowerCase(),null,!1,!1)});\n[\"autoReverse\",\"externalResourcesRequired\",\"focusable\",\"preserveAlpha\"].forEach(function(a){D[a]=new B(a,2,!1,a,null,!1,!1)});\"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope\".split(\" \").forEach(function(a){D[a]=new B(a,3,!1,a.toLowerCase(),null,!1,!1)});\n[\"checked\",\"multiple\",\"muted\",\"selected\"].forEach(function(a){D[a]=new B(a,3,!0,a,null,!1,!1)});[\"capture\",\"download\"].forEach(function(a){D[a]=new B(a,4,!1,a,null,!1,!1)});[\"cols\",\"rows\",\"size\",\"span\"].forEach(function(a){D[a]=new B(a,6,!1,a,null,!1,!1)});[\"rowSpan\",\"start\"].forEach(function(a){D[a]=new B(a,5,!1,a.toLowerCase(),null,!1,!1)});var oa=/[\\-:]([a-z])/g;function pa(a){return a[1].toUpperCase()}\n\"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height\".split(\" \").forEach(function(a){var b=a.replace(oa,\npa);D[b]=new B(b,1,!1,a,null,!1,!1)});\"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type\".split(\" \").forEach(function(a){var b=a.replace(oa,pa);D[b]=new B(b,1,!1,a,\"http://www.w3.org/1999/xlink\",!1,!1)});[\"xml:base\",\"xml:lang\",\"xml:space\"].forEach(function(a){var b=a.replace(oa,pa);D[b]=new B(b,1,!1,a,\"http://www.w3.org/XML/1998/namespace\",!1,!1)});[\"tabIndex\",\"crossOrigin\"].forEach(function(a){D[a]=new B(a,1,!1,a.toLowerCase(),null,!1,!1)});\nD.xlinkHref=new B(\"xlinkHref\",1,!1,\"xlink:href\",\"http://www.w3.org/1999/xlink\",!0,!1);[\"src\",\"href\",\"action\",\"formAction\"].forEach(function(a){D[a]=new B(a,1,!1,a.toLowerCase(),null,!0,!0)});\nfunction qa(a,b,c,d){var e=D.hasOwnProperty(b)?D[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||\"o\"!==b[0]&&\"O\"!==b[0]||\"n\"!==b[1]&&\"N\"!==b[1]?!1:!0;f||(na(b,c,e,d)&&(c=null),d||null===e?la(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,\"\"+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:\"\":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?\"\":\"\"+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}\nvar ra=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,sa=60103,ta=60106,ua=60107,wa=60108,xa=60114,ya=60109,za=60110,Aa=60112,Ba=60113,Ca=60120,Da=60115,Ea=60116,Fa=60121,Ga=60128,Ha=60129,Ia=60130,Ja=60131;\nif(\"function\"===typeof Symbol&&Symbol.for){var E=Symbol.for;sa=E(\"react.element\");ta=E(\"react.portal\");ua=E(\"react.fragment\");wa=E(\"react.strict_mode\");xa=E(\"react.profiler\");ya=E(\"react.provider\");za=E(\"react.context\");Aa=E(\"react.forward_ref\");Ba=E(\"react.suspense\");Ca=E(\"react.suspense_list\");Da=E(\"react.memo\");Ea=E(\"react.lazy\");Fa=E(\"react.block\");E(\"react.scope\");Ga=E(\"react.opaque.id\");Ha=E(\"react.debug_trace_mode\");Ia=E(\"react.offscreen\");Ja=E(\"react.legacy_hidden\")}\nvar Ka=\"function\"===typeof Symbol&&Symbol.iterator;function La(a){if(null===a||\"object\"!==typeof a)return null;a=Ka&&a[Ka]||a[\"@@iterator\"];return\"function\"===typeof a?a:null}var Ma;function Na(a){if(void 0===Ma)try{throw Error();}catch(c){var b=c.stack.trim().match(/\\n( *(at )?)/);Ma=b&&b[1]||\"\"}return\"\\n\"+Ma+a}var Oa=!1;\nfunction Pa(a,b){if(!a||Oa)return\"\";Oa=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,\"props\",{set:function(){throw Error();}}),\"object\"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(k){var d=k}Reflect.construct(a,[],b)}else{try{b.call()}catch(k){d=k}a.call(b.prototype)}else{try{throw Error();}catch(k){d=k}a()}}catch(k){if(k&&d&&\"string\"===typeof k.stack){for(var e=k.stack.split(\"\\n\"),\nf=d.stack.split(\"\\n\"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h])return\"\\n\"+e[g].replace(\" at new \",\" at \");while(1<=g&&0<=h)}break}}}finally{Oa=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:\"\")?Na(a):\"\"}\nfunction Qa(a){switch(a.tag){case 5:return Na(a.type);case 16:return Na(\"Lazy\");case 13:return Na(\"Suspense\");case 19:return Na(\"SuspenseList\");case 0:case 2:case 15:return a=Pa(a.type,!1),a;case 11:return a=Pa(a.type.render,!1),a;case 22:return a=Pa(a.type._render,!1),a;case 1:return a=Pa(a.type,!0),a;default:return\"\"}}\nfunction Ra(a){if(null==a)return null;if(\"function\"===typeof a)return a.displayName||a.name||null;if(\"string\"===typeof a)return a;switch(a){case ua:return\"Fragment\";case ta:return\"Portal\";case xa:return\"Profiler\";case wa:return\"StrictMode\";case Ba:return\"Suspense\";case Ca:return\"SuspenseList\"}if(\"object\"===typeof a)switch(a.$$typeof){case za:return(a.displayName||\"Context\")+\".Consumer\";case ya:return(a._context.displayName||\"Context\")+\".Provider\";case Aa:var b=a.render;b=b.displayName||b.name||\"\";\nreturn a.displayName||(\"\"!==b?\"ForwardRef(\"+b+\")\":\"ForwardRef\");case Da:return Ra(a.type);case Fa:return Ra(a._render);case Ea:b=a._payload;a=a._init;try{return Ra(a(b))}catch(c){}}return null}function Sa(a){switch(typeof a){case \"boolean\":case \"number\":case \"object\":case \"string\":case \"undefined\":return a;default:return\"\"}}function Ta(a){var b=a.type;return(a=a.nodeName)&&\"input\"===a.toLowerCase()&&(\"checkbox\"===b||\"radio\"===b)}\nfunction Ua(a){var b=Ta(a)?\"checked\":\"value\",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=\"\"+a[b];if(!a.hasOwnProperty(b)&&\"undefined\"!==typeof c&&\"function\"===typeof c.get&&\"function\"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=\"\"+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=\"\"+a},stopTracking:function(){a._valueTracker=\nnull;delete a[b]}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a))}function Wa(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d=\"\";a&&(d=Ta(a)?a.checked?\"true\":\"false\":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Xa(a){a=a||(\"undefined\"!==typeof document?document:void 0);if(\"undefined\"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}\nfunction Ya(a,b){var c=b.checked;return m({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za(a,b){var c=null==b.defaultValue?\"\":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:\"checkbox\"===b.type||\"radio\"===b.type?null!=b.checked:null!=b.value}}function $a(a,b){b=b.checked;null!=b&&qa(a,\"checked\",b,!1)}\nfunction ab(a,b){$a(a,b);var c=Sa(b.value),d=b.type;if(null!=c)if(\"number\"===d){if(0===c&&\"\"===a.value||a.value!=c)a.value=\"\"+c}else a.value!==\"\"+c&&(a.value=\"\"+c);else if(\"submit\"===d||\"reset\"===d){a.removeAttribute(\"value\");return}b.hasOwnProperty(\"value\")?bb(a,b.type,c):b.hasOwnProperty(\"defaultValue\")&&bb(a,b.type,Sa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}\nfunction cb(a,b,c){if(b.hasOwnProperty(\"value\")||b.hasOwnProperty(\"defaultValue\")){var d=b.type;if(!(\"submit\"!==d&&\"reset\"!==d||void 0!==b.value&&null!==b.value))return;b=\"\"+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;\"\"!==c&&(a.name=\"\");a.defaultChecked=!!a._wrapperState.initialChecked;\"\"!==c&&(a.name=c)}\nfunction bb(a,b,c){if(\"number\"!==b||Xa(a.ownerDocument)!==a)null==c?a.defaultValue=\"\"+a._wrapperState.initialValue:a.defaultValue!==\"\"+c&&(a.defaultValue=\"\"+c)}function db(a){var b=\"\";aa.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function eb(a,b){a=m({children:void 0},b);if(b=db(b.children))a.children=b;return a}\nfunction fb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b[\"$\"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty(\"$\"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=\"\"+Sa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}\nfunction gb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(y(91));return m({},b,{value:void 0,defaultValue:void 0,children:\"\"+a._wrapperState.initialValue})}function hb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(y(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(y(93));c=c[0]}b=c}null==b&&(b=\"\");c=b}a._wrapperState={initialValue:Sa(c)}}\nfunction ib(a,b){var c=Sa(b.value),d=Sa(b.defaultValue);null!=c&&(c=\"\"+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=\"\"+d)}function jb(a){var b=a.textContent;b===a._wrapperState.initialValue&&\"\"!==b&&null!==b&&(a.value=b)}var kb={html:\"http://www.w3.org/1999/xhtml\",mathml:\"http://www.w3.org/1998/Math/MathML\",svg:\"http://www.w3.org/2000/svg\"};\nfunction lb(a){switch(a){case \"svg\":return\"http://www.w3.org/2000/svg\";case \"math\":return\"http://www.w3.org/1998/Math/MathML\";default:return\"http://www.w3.org/1999/xhtml\"}}function mb(a,b){return null==a||\"http://www.w3.org/1999/xhtml\"===a?lb(b):\"http://www.w3.org/2000/svg\"===a&&\"foreignObject\"===b?\"http://www.w3.org/1999/xhtml\":a}\nvar nb,ob=function(a){return\"undefined\"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==kb.svg||\"innerHTML\"in a)a.innerHTML=b;else{nb=nb||document.createElement(\"div\");nb.innerHTML=\"<svg>\"+b.valueOf().toString()+\"</svg>\";for(b=nb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});\nfunction pb(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}\nvar qb={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,\nfloodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},rb=[\"Webkit\",\"ms\",\"Moz\",\"O\"];Object.keys(qb).forEach(function(a){rb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);qb[b]=qb[a]})});function sb(a,b,c){return null==b||\"boolean\"===typeof b||\"\"===b?\"\":c||\"number\"!==typeof b||0===b||qb.hasOwnProperty(a)&&qb[a]?(\"\"+b).trim():b+\"px\"}\nfunction tb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf(\"--\"),e=sb(c,b[c],d);\"float\"===c&&(c=\"cssFloat\");d?a.setProperty(c,e):a[c]=e}}var ub=m({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});\nfunction vb(a,b){if(b){if(ub[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(y(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(y(60));if(!(\"object\"===typeof b.dangerouslySetInnerHTML&&\"__html\"in b.dangerouslySetInnerHTML))throw Error(y(61));}if(null!=b.style&&\"object\"!==typeof b.style)throw Error(y(62));}}\nfunction wb(a,b){if(-1===a.indexOf(\"-\"))return\"string\"===typeof b.is;switch(a){case \"annotation-xml\":case \"color-profile\":case \"font-face\":case \"font-face-src\":case \"font-face-uri\":case \"font-face-format\":case \"font-face-name\":case \"missing-glyph\":return!1;default:return!0}}function xb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb=null,zb=null,Ab=null;\nfunction Bb(a){if(a=Cb(a)){if(\"function\"!==typeof yb)throw Error(y(280));var b=a.stateNode;b&&(b=Db(b),yb(a.stateNode,a.type,b))}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a}function Fb(){if(zb){var a=zb,b=Ab;Ab=zb=null;Bb(a);if(b)for(a=0;a<b.length;a++)Bb(b[a])}}function Gb(a,b){return a(b)}function Hb(a,b,c,d,e){return a(b,c,d,e)}function Ib(){}var Jb=Gb,Kb=!1,Lb=!1;function Mb(){if(null!==zb||null!==Ab)Ib(),Fb()}\nfunction Nb(a,b,c){if(Lb)return a(b,c);Lb=!0;try{return Jb(a,b,c)}finally{Lb=!1,Mb()}}\nfunction Ob(a,b){var c=a.stateNode;if(null===c)return null;var d=Db(c);if(null===d)return null;c=d[b];a:switch(b){case \"onClick\":case \"onClickCapture\":case \"onDoubleClick\":case \"onDoubleClickCapture\":case \"onMouseDown\":case \"onMouseDownCapture\":case \"onMouseMove\":case \"onMouseMoveCapture\":case \"onMouseUp\":case \"onMouseUpCapture\":case \"onMouseEnter\":(d=!d.disabled)||(a=a.type,d=!(\"button\"===a||\"input\"===a||\"select\"===a||\"textarea\"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&\"function\"!==\ntypeof c)throw Error(y(231,b,typeof c));return c}var Pb=!1;if(fa)try{var Qb={};Object.defineProperty(Qb,\"passive\",{get:function(){Pb=!0}});window.addEventListener(\"test\",Qb,Qb);window.removeEventListener(\"test\",Qb,Qb)}catch(a){Pb=!1}function Rb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(n){this.onError(n)}}var Sb=!1,Tb=null,Ub=!1,Vb=null,Wb={onError:function(a){Sb=!0;Tb=a}};function Xb(a,b,c,d,e,f,g,h,k){Sb=!1;Tb=null;Rb.apply(Wb,arguments)}\nfunction Yb(a,b,c,d,e,f,g,h,k){Xb.apply(this,arguments);if(Sb){if(Sb){var l=Tb;Sb=!1;Tb=null}else throw Error(y(198));Ub||(Ub=!0,Vb=l)}}function Zb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function $b(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function ac(a){if(Zb(a)!==a)throw Error(y(188));}\nfunction bc(a){var b=a.alternate;if(!b){b=Zb(a);if(null===b)throw Error(y(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return ac(e),a;if(f===d)return ac(e),b;f=f.sibling}throw Error(y(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===\nc){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(y(189));}}if(c.alternate!==d)throw Error(y(190));}if(3!==c.tag)throw Error(y(188));return c.stateNode.current===c?a:b}function cc(a){a=bc(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}\nfunction dc(a,b){for(var c=a.alternate;null!==b;){if(b===a||b===c)return!0;b=b.return}return!1}var ec,fc,gc,hc,ic=!1,jc=[],kc=null,lc=null,mc=null,nc=new Map,oc=new Map,pc=[],qc=\"mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit\".split(\" \");\nfunction rc(a,b,c,d,e){return{blockedOn:a,domEventName:b,eventSystemFlags:c|16,nativeEvent:e,targetContainers:[d]}}function sc(a,b){switch(a){case \"focusin\":case \"focusout\":kc=null;break;case \"dragenter\":case \"dragleave\":lc=null;break;case \"mouseover\":case \"mouseout\":mc=null;break;case \"pointerover\":case \"pointerout\":nc.delete(b.pointerId);break;case \"gotpointercapture\":case \"lostpointercapture\":oc.delete(b.pointerId)}}\nfunction tc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=rc(b,c,d,e,f),null!==b&&(b=Cb(b),null!==b&&fc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}\nfunction uc(a,b,c,d,e){switch(b){case \"focusin\":return kc=tc(kc,a,b,c,d,e),!0;case \"dragenter\":return lc=tc(lc,a,b,c,d,e),!0;case \"mouseover\":return mc=tc(mc,a,b,c,d,e),!0;case \"pointerover\":var f=e.pointerId;nc.set(f,tc(nc.get(f)||null,a,b,c,d,e));return!0;case \"gotpointercapture\":return f=e.pointerId,oc.set(f,tc(oc.get(f)||null,a,b,c,d,e)),!0}return!1}\nfunction vc(a){var b=wc(a.target);if(null!==b){var c=Zb(b);if(null!==c)if(b=c.tag,13===b){if(b=$b(c),null!==b){a.blockedOn=b;hc(a.lanePriority,function(){r.unstable_runWithPriority(a.priority,function(){gc(c)})});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}\nfunction xc(a){if(null!==a.blockedOn)return!1;for(var b=a.targetContainers;0<b.length;){var c=yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null!==c)return b=Cb(c),null!==b&&fc(b),a.blockedOn=c,!1;b.shift()}return!0}function zc(a,b,c){xc(a)&&c.delete(b)}\nfunction Ac(){for(ic=!1;0<jc.length;){var a=jc[0];if(null!==a.blockedOn){a=Cb(a.blockedOn);null!==a&&ec(a);break}for(var b=a.targetContainers;0<b.length;){var c=yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null!==c){a.blockedOn=c;break}b.shift()}null===a.blockedOn&&jc.shift()}null!==kc&&xc(kc)&&(kc=null);null!==lc&&xc(lc)&&(lc=null);null!==mc&&xc(mc)&&(mc=null);nc.forEach(zc);oc.forEach(zc)}\nfunction Bc(a,b){a.blockedOn===b&&(a.blockedOn=null,ic||(ic=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Ac)))}\nfunction Cc(a){function b(b){return Bc(b,a)}if(0<jc.length){Bc(jc[0],a);for(var c=1;c<jc.length;c++){var d=jc[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==kc&&Bc(kc,a);null!==lc&&Bc(lc,a);null!==mc&&Bc(mc,a);nc.forEach(b);oc.forEach(b);for(c=0;c<pc.length;c++)d=pc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<pc.length&&(c=pc[0],null===c.blockedOn);)vc(c),null===c.blockedOn&&pc.shift()}\nfunction Dc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c[\"Webkit\"+a]=\"webkit\"+b;c[\"Moz\"+a]=\"moz\"+b;return c}var Ec={animationend:Dc(\"Animation\",\"AnimationEnd\"),animationiteration:Dc(\"Animation\",\"AnimationIteration\"),animationstart:Dc(\"Animation\",\"AnimationStart\"),transitionend:Dc(\"Transition\",\"TransitionEnd\")},Fc={},Gc={};\nfa&&(Gc=document.createElement(\"div\").style,\"AnimationEvent\"in window||(delete Ec.animationend.animation,delete Ec.animationiteration.animation,delete Ec.animationstart.animation),\"TransitionEvent\"in window||delete Ec.transitionend.transition);function Hc(a){if(Fc[a])return Fc[a];if(!Ec[a])return a;var b=Ec[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Gc)return Fc[a]=b[c];return a}\nvar Ic=Hc(\"animationend\"),Jc=Hc(\"animationiteration\"),Kc=Hc(\"animationstart\"),Lc=Hc(\"transitionend\"),Mc=new Map,Nc=new Map,Oc=[\"abort\",\"abort\",Ic,\"animationEnd\",Jc,\"animationIteration\",Kc,\"animationStart\",\"canplay\",\"canPlay\",\"canplaythrough\",\"canPlayThrough\",\"durationchange\",\"durationChange\",\"emptied\",\"emptied\",\"encrypted\",\"encrypted\",\"ended\",\"ended\",\"error\",\"error\",\"gotpointercapture\",\"gotPointerCapture\",\"load\",\"load\",\"loadeddata\",\"loadedData\",\"loadedmetadata\",\"loadedMetadata\",\"loadstart\",\"loadStart\",\n\"lostpointercapture\",\"lostPointerCapture\",\"playing\",\"playing\",\"progress\",\"progress\",\"seeking\",\"seeking\",\"stalled\",\"stalled\",\"suspend\",\"suspend\",\"timeupdate\",\"timeUpdate\",Lc,\"transitionEnd\",\"waiting\",\"waiting\"];function Pc(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1];e=\"on\"+(e[0].toUpperCase()+e.slice(1));Nc.set(d,b);Mc.set(d,e);da(e,[d])}}var Qc=r.unstable_now;Qc();var F=8;\nfunction Rc(a){if(0!==(1&a))return F=15,1;if(0!==(2&a))return F=14,2;if(0!==(4&a))return F=13,4;var b=24&a;if(0!==b)return F=12,b;if(0!==(a&32))return F=11,32;b=192&a;if(0!==b)return F=10,b;if(0!==(a&256))return F=9,256;b=3584&a;if(0!==b)return F=8,b;if(0!==(a&4096))return F=7,4096;b=4186112&a;if(0!==b)return F=6,b;b=62914560&a;if(0!==b)return F=5,b;if(a&67108864)return F=4,67108864;if(0!==(a&134217728))return F=3,134217728;b=805306368&a;if(0!==b)return F=2,b;if(0!==(1073741824&a))return F=1,1073741824;\nF=8;return a}function Sc(a){switch(a){case 99:return 15;case 98:return 10;case 97:case 96:return 8;case 95:return 2;default:return 0}}function Tc(a){switch(a){case 15:case 14:return 99;case 13:case 12:case 11:case 10:return 98;case 9:case 8:case 7:case 6:case 4:case 5:return 97;case 3:case 2:case 1:return 95;case 0:return 90;default:throw Error(y(358,a));}}\nfunction Uc(a,b){var c=a.pendingLanes;if(0===c)return F=0;var d=0,e=0,f=a.expiredLanes,g=a.suspendedLanes,h=a.pingedLanes;if(0!==f)d=f,e=F=15;else if(f=c&134217727,0!==f){var k=f&~g;0!==k?(d=Rc(k),e=F):(h&=f,0!==h&&(d=Rc(h),e=F))}else f=c&~g,0!==f?(d=Rc(f),e=F):0!==h&&(d=Rc(h),e=F);if(0===d)return 0;d=31-Vc(d);d=c&((0>d?0:1<<d)<<1)-1;if(0!==b&&b!==d&&0===(b&g)){Rc(b);if(e<=F)return b;F=e}b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-Vc(b),e=1<<c,d|=a[c],b&=~e;return d}\nfunction Wc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function Xc(a,b){switch(a){case 15:return 1;case 14:return 2;case 12:return a=Yc(24&~b),0===a?Xc(10,b):a;case 10:return a=Yc(192&~b),0===a?Xc(8,b):a;case 8:return a=Yc(3584&~b),0===a&&(a=Yc(4186112&~b),0===a&&(a=512)),a;case 2:return b=Yc(805306368&~b),0===b&&(b=268435456),b}throw Error(y(358,a));}function Yc(a){return a&-a}function Zc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}\nfunction $c(a,b,c){a.pendingLanes|=b;var d=b-1;a.suspendedLanes&=d;a.pingedLanes&=d;a=a.eventTimes;b=31-Vc(b);a[b]=c}var Vc=Math.clz32?Math.clz32:ad,bd=Math.log,cd=Math.LN2;function ad(a){return 0===a?32:31-(bd(a)/cd|0)|0}var dd=r.unstable_UserBlockingPriority,ed=r.unstable_runWithPriority,fd=!0;function gd(a,b,c,d){Kb||Ib();var e=hd,f=Kb;Kb=!0;try{Hb(e,a,b,c,d)}finally{(Kb=f)||Mb()}}function id(a,b,c,d){ed(dd,hd.bind(null,a,b,c,d))}\nfunction hd(a,b,c,d){if(fd){var e;if((e=0===(b&4))&&0<jc.length&&-1<qc.indexOf(a))a=rc(null,a,b,c,d),jc.push(a);else{var f=yc(a,b,c,d);if(null===f)e&&sc(a,d);else{if(e){if(-1<qc.indexOf(a)){a=rc(f,a,b,c,d);jc.push(a);return}if(uc(f,a,b,c,d))return;sc(a,d)}jd(a,b,d,null,c)}}}}\nfunction yc(a,b,c,d){var e=xb(d);e=wc(e);if(null!==e){var f=Zb(e);if(null===f)e=null;else{var g=f.tag;if(13===g){e=$b(f);if(null!==e)return e;e=null}else if(3===g){if(f.stateNode.hydrate)return 3===f.tag?f.stateNode.containerInfo:null;e=null}else f!==e&&(e=null)}}jd(a,b,d,e,c);return null}var kd=null,ld=null,md=null;\nfunction nd(){if(md)return md;var a,b=ld,c=b.length,d,e=\"value\"in kd?kd.value:kd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md=e.slice(a,1<d?1-d:void 0)}function od(a){var b=a.keyCode;\"charCode\"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd(){return!0}function qd(){return!1}\nfunction rd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?pd:qd;this.isPropagationStopped=qd;return this}m(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():\"unknown\"!==typeof a.returnValue&&\n(a.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():\"unknown\"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd});return b}\nvar sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=m({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=m({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if(\"movementX\"in\na)return a.movementX;a!==yd&&(yd&&\"mousemove\"===a.type?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a);return wd},movementY:function(a){return\"movementY\"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=m({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=m({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=m({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=m({},sd,{clipboardData:function(a){return\"clipboardData\"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=m({},sd,{data:0}),Ld=rd(Kd),Md={Esc:\"Escape\",\nSpacebar:\" \",Left:\"ArrowLeft\",Up:\"ArrowUp\",Right:\"ArrowRight\",Down:\"ArrowDown\",Del:\"Delete\",Win:\"OS\",Menu:\"ContextMenu\",Apps:\"ContextMenu\",Scroll:\"ScrollLock\",MozPrintableKey:\"Unidentified\"},Nd={8:\"Backspace\",9:\"Tab\",12:\"Clear\",13:\"Enter\",16:\"Shift\",17:\"Control\",18:\"Alt\",19:\"Pause\",20:\"CapsLock\",27:\"Escape\",32:\" \",33:\"PageUp\",34:\"PageDown\",35:\"End\",36:\"Home\",37:\"ArrowLeft\",38:\"ArrowUp\",39:\"ArrowRight\",40:\"ArrowDown\",45:\"Insert\",46:\"Delete\",112:\"F1\",113:\"F2\",114:\"F3\",115:\"F4\",116:\"F5\",117:\"F6\",118:\"F7\",\n119:\"F8\",120:\"F9\",121:\"F10\",122:\"F11\",123:\"F12\",144:\"NumLock\",145:\"ScrollLock\",224:\"Meta\"},Od={Alt:\"altKey\",Control:\"ctrlKey\",Meta:\"metaKey\",Shift:\"shiftKey\"};function Pd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od[a])?!!b[a]:!1}function zd(){return Pd}\nvar Qd=m({},ud,{key:function(a){if(a.key){var b=Md[a.key]||a.key;if(\"Unidentified\"!==b)return b}return\"keypress\"===a.type?(a=od(a),13===a?\"Enter\":String.fromCharCode(a)):\"keydown\"===a.type||\"keyup\"===a.type?Nd[a.keyCode]||\"Unidentified\":\"\"},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return\"keypress\"===a.type?od(a):0},keyCode:function(a){return\"keydown\"===a.type||\"keyup\"===a.type?a.keyCode:0},which:function(a){return\"keypress\"===\na.type?od(a):\"keydown\"===a.type||\"keyup\"===a.type?a.keyCode:0}}),Rd=rd(Qd),Sd=m({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=m({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=m({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=m({},Ad,{deltaX:function(a){return\"deltaX\"in a?a.deltaX:\"wheelDeltaX\"in a?-a.wheelDeltaX:0},\ndeltaY:function(a){return\"deltaY\"in a?a.deltaY:\"wheelDeltaY\"in a?-a.wheelDeltaY:\"wheelDelta\"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=fa&&\"CompositionEvent\"in window,be=null;fa&&\"documentMode\"in document&&(be=document.documentMode);var ce=fa&&\"TextEvent\"in window&&!be,de=fa&&(!ae||be&&8<be&&11>=be),ee=String.fromCharCode(32),fe=!1;\nfunction ge(a,b){switch(a){case \"keyup\":return-1!==$d.indexOf(b.keyCode);case \"keydown\":return 229!==b.keyCode;case \"keypress\":case \"mousedown\":case \"focusout\":return!0;default:return!1}}function he(a){a=a.detail;return\"object\"===typeof a&&\"data\"in a?a.data:null}var ie=!1;function je(a,b){switch(a){case \"compositionend\":return he(b);case \"keypress\":if(32!==b.which)return null;fe=!0;return ee;case \"textInput\":return a=b.data,a===ee&&fe?null:a;default:return null}}\nfunction ke(a,b){if(ie)return\"compositionend\"===a||!ae&&ge(a,b)?(a=nd(),md=ld=kd=null,ie=!1,a):null;switch(a){case \"paste\":return null;case \"keypress\":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case \"compositionend\":return de&&\"ko\"!==b.locale?null:b.data;default:return null}}\nvar le={color:!0,date:!0,datetime:!0,\"datetime-local\":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return\"input\"===b?!!le[a.type]:\"textarea\"===b?!0:!1}function ne(a,b,c,d){Eb(d);b=oe(b,\"onChange\");0<b.length&&(c=new td(\"onChange\",\"change\",null,c,d),a.push({event:c,listeners:b}))}var pe=null,qe=null;function re(a){se(a,0)}function te(a){var b=ue(a);if(Wa(b))return a}\nfunction ve(a,b){if(\"change\"===a)return b}var we=!1;if(fa){var xe;if(fa){var ye=\"oninput\"in document;if(!ye){var ze=document.createElement(\"div\");ze.setAttribute(\"oninput\",\"return;\");ye=\"function\"===typeof ze.oninput}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent(\"onpropertychange\",Be),qe=pe=null)}function Be(a){if(\"value\"===a.propertyName&&te(qe)){var b=[];ne(b,qe,a,xb(a));a=re;if(Kb)a(b);else{Kb=!0;try{Gb(a,b)}finally{Kb=!1,Mb()}}}}\nfunction Ce(a,b,c){\"focusin\"===a?(Ae(),pe=b,qe=c,pe.attachEvent(\"onpropertychange\",Be)):\"focusout\"===a&&Ae()}function De(a){if(\"selectionchange\"===a||\"keyup\"===a||\"keydown\"===a)return te(qe)}function Ee(a,b){if(\"click\"===a)return te(b)}function Fe(a,b){if(\"input\"===a||\"change\"===a)return te(b)}function Ge(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He=\"function\"===typeof Object.is?Object.is:Ge,Ie=Object.prototype.hasOwnProperty;\nfunction Je(a,b){if(He(a,b))return!0;if(\"object\"!==typeof a||null===a||\"object\"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!Ie.call(b,c[d])||!He(a[c[d]],b[c[d]]))return!1;return!0}function Ke(a){for(;a&&a.firstChild;)a=a.firstChild;return a}\nfunction Le(a,b){var c=Ke(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Ke(c)}}function Me(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Me(a,b.parentNode):\"contains\"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}\nfunction Ne(){for(var a=window,b=Xa();b instanceof a.HTMLIFrameElement;){try{var c=\"string\"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Xa(a.document)}return b}function Oe(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&(\"input\"===b&&(\"text\"===a.type||\"search\"===a.type||\"tel\"===a.type||\"url\"===a.type||\"password\"===a.type)||\"textarea\"===b||\"true\"===a.contentEditable)}\nvar Pe=fa&&\"documentMode\"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;\nfunction Ue(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te||null==Qe||Qe!==Xa(d)||(d=Qe,\"selectionStart\"in d&&Oe(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se&&Je(Se,d)||(Se=d,d=oe(Re,\"onSelect\"),0<d.length&&(b=new td(\"onSelect\",\"select\",null,b,c),a.push({event:b,listeners:d}),b.target=Qe)))}\nPc(\"cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange\".split(\" \"),\n0);Pc(\"drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel\".split(\" \"),1);Pc(Oc,2);for(var Ve=\"change selectionchange textInput compositionstart compositionend compositionupdate\".split(\" \"),We=0;We<Ve.length;We++)Nc.set(Ve[We],0);ea(\"onMouseEnter\",[\"mouseout\",\"mouseover\"]);\nea(\"onMouseLeave\",[\"mouseout\",\"mouseover\"]);ea(\"onPointerEnter\",[\"pointerout\",\"pointerover\"]);ea(\"onPointerLeave\",[\"pointerout\",\"pointerover\"]);da(\"onChange\",\"change click focusin focusout input keydown keyup selectionchange\".split(\" \"));da(\"onSelect\",\"focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange\".split(\" \"));da(\"onBeforeInput\",[\"compositionend\",\"keypress\",\"textInput\",\"paste\"]);da(\"onCompositionEnd\",\"compositionend focusout keydown keypress keyup mousedown\".split(\" \"));\nda(\"onCompositionStart\",\"compositionstart focusout keydown keypress keyup mousedown\".split(\" \"));da(\"onCompositionUpdate\",\"compositionupdate focusout keydown keypress keyup mousedown\".split(\" \"));var Xe=\"abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting\".split(\" \"),Ye=new Set(\"cancel close invalid load scroll toggle\".split(\" \").concat(Xe));\nfunction Ze(a,b,c){var d=a.type||\"unknown-event\";a.currentTarget=c;Yb(d,b,void 0,a);a.currentTarget=null}\nfunction se(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;Ze(e,h,l);f=k}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;Ze(e,h,l);f=k}}}if(Ub)throw a=Vb,Ub=!1,Vb=null,a;}\nfunction G(a,b){var c=$e(b),d=a+\"__bubble\";c.has(d)||(af(b,a,2,!1),c.add(d))}var bf=\"_reactListening\"+Math.random().toString(36).slice(2);function cf(a){a[bf]||(a[bf]=!0,ba.forEach(function(b){Ye.has(b)||df(b,!1,a,null);df(b,!0,a,null)}))}\nfunction df(a,b,c,d){var e=4<arguments.length&&void 0!==arguments[4]?arguments[4]:0,f=c;\"selectionchange\"===a&&9!==c.nodeType&&(f=c.ownerDocument);if(null!==d&&!b&&Ye.has(a)){if(\"scroll\"!==a)return;e|=2;f=d}var g=$e(f),h=a+\"__\"+(b?\"capture\":\"bubble\");g.has(h)||(b&&(e|=4),af(f,a,e,b),g.add(h))}\nfunction af(a,b,c,d){var e=Nc.get(b);switch(void 0===e?2:e){case 0:e=gd;break;case 1:e=id;break;default:e=hd}c=e.bind(null,b,c,a);e=void 0;!Pb||\"touchstart\"!==b&&\"touchmove\"!==b&&\"wheel\"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1)}\nfunction jd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return}for(;null!==h;){g=wc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode}}d=d.return}Nb(function(){var d=f,e=xb(c),g=[];\na:{var h=Mc.get(a);if(void 0!==h){var k=td,x=a;switch(a){case \"keypress\":if(0===od(c))break a;case \"keydown\":case \"keyup\":k=Rd;break;case \"focusin\":x=\"focus\";k=Fd;break;case \"focusout\":x=\"blur\";k=Fd;break;case \"beforeblur\":case \"afterblur\":k=Fd;break;case \"click\":if(2===c.button)break a;case \"auxclick\":case \"dblclick\":case \"mousedown\":case \"mousemove\":case \"mouseup\":case \"mouseout\":case \"mouseover\":case \"contextmenu\":k=Bd;break;case \"drag\":case \"dragend\":case \"dragenter\":case \"dragexit\":case \"dragleave\":case \"dragover\":case \"dragstart\":case \"drop\":k=\nDd;break;case \"touchcancel\":case \"touchend\":case \"touchmove\":case \"touchstart\":k=Vd;break;case Ic:case Jc:case Kc:k=Hd;break;case Lc:k=Xd;break;case \"scroll\":k=vd;break;case \"wheel\":k=Zd;break;case \"copy\":case \"cut\":case \"paste\":k=Jd;break;case \"gotpointercapture\":case \"lostpointercapture\":case \"pointercancel\":case \"pointerdown\":case \"pointermove\":case \"pointerout\":case \"pointerover\":case \"pointerup\":k=Td}var w=0!==(b&4),z=!w&&\"scroll\"===a,u=w?null!==h?h+\"Capture\":null:h;w=[];for(var t=d,q;null!==\nt;){q=t;var v=q.stateNode;5===q.tag&&null!==v&&(q=v,null!==u&&(v=Ob(t,u),null!=v&&w.push(ef(t,v,q))));if(z)break;t=t.return}0<w.length&&(h=new k(h,x,null,c,e),g.push({event:h,listeners:w}))}}if(0===(b&7)){a:{h=\"mouseover\"===a||\"pointerover\"===a;k=\"mouseout\"===a||\"pointerout\"===a;if(h&&0===(b&16)&&(x=c.relatedTarget||c.fromElement)&&(wc(x)||x[ff]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(x=c.relatedTarget||c.toElement,k=d,x=x?wc(x):null,null!==\nx&&(z=Zb(x),x!==z||5!==x.tag&&6!==x.tag))x=null}else k=null,x=d;if(k!==x){w=Bd;v=\"onMouseLeave\";u=\"onMouseEnter\";t=\"mouse\";if(\"pointerout\"===a||\"pointerover\"===a)w=Td,v=\"onPointerLeave\",u=\"onPointerEnter\",t=\"pointer\";z=null==k?h:ue(k);q=null==x?h:ue(x);h=new w(v,t+\"leave\",k,c,e);h.target=z;h.relatedTarget=q;v=null;wc(e)===d&&(w=new w(u,t+\"enter\",x,c,e),w.target=q,w.relatedTarget=z,v=w);z=v;if(k&&x)b:{w=k;u=x;t=0;for(q=w;q;q=gf(q))t++;q=0;for(v=u;v;v=gf(v))q++;for(;0<t-q;)w=gf(w),t--;for(;0<q-t;)u=\ngf(u),q--;for(;t--;){if(w===u||null!==u&&w===u.alternate)break b;w=gf(w);u=gf(u)}w=null}else w=null;null!==k&&hf(g,h,k,w,!1);null!==x&&null!==z&&hf(g,z,x,w,!0)}}}a:{h=d?ue(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if(\"select\"===k||\"input\"===k&&\"file\"===h.type)var J=ve;else if(me(h))if(we)J=Fe;else{J=De;var K=Ce}else(k=h.nodeName)&&\"input\"===k.toLowerCase()&&(\"checkbox\"===h.type||\"radio\"===h.type)&&(J=Ee);if(J&&(J=J(a,d))){ne(g,J,c,e);break a}K&&K(a,h,d);\"focusout\"===a&&(K=h._wrapperState)&&\nK.controlled&&\"number\"===h.type&&bb(h,\"number\",h.value)}K=d?ue(d):window;switch(a){case \"focusin\":if(me(K)||\"true\"===K.contentEditable)Qe=K,Re=d,Se=null;break;case \"focusout\":Se=Re=Qe=null;break;case \"mousedown\":Te=!0;break;case \"contextmenu\":case \"mouseup\":case \"dragend\":Te=!1;Ue(g,c,e);break;case \"selectionchange\":if(Pe)break;case \"keydown\":case \"keyup\":Ue(g,c,e)}var Q;if(ae)b:{switch(a){case \"compositionstart\":var L=\"onCompositionStart\";break b;case \"compositionend\":L=\"onCompositionEnd\";break b;\ncase \"compositionupdate\":L=\"onCompositionUpdate\";break b}L=void 0}else ie?ge(a,c)&&(L=\"onCompositionEnd\"):\"keydown\"===a&&229===c.keyCode&&(L=\"onCompositionStart\");L&&(de&&\"ko\"!==c.locale&&(ie||\"onCompositionStart\"!==L?\"onCompositionEnd\"===L&&ie&&(Q=nd()):(kd=e,ld=\"value\"in kd?kd.value:kd.textContent,ie=!0)),K=oe(d,L),0<K.length&&(L=new Ld(L,a,null,c,e),g.push({event:L,listeners:K}),Q?L.data=Q:(Q=he(c),null!==Q&&(L.data=Q))));if(Q=ce?je(a,c):ke(a,c))d=oe(d,\"onBeforeInput\"),0<d.length&&(e=new Ld(\"onBeforeInput\",\n\"beforeinput\",null,c,e),g.push({event:e,listeners:d}),e.data=Q)}se(g,b)})}function ef(a,b,c){return{instance:a,listener:b,currentTarget:c}}function oe(a,b){for(var c=b+\"Capture\",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Ob(a,c),null!=f&&d.unshift(ef(a,f,e)),f=Ob(a,b),null!=f&&d.push(ef(a,f,e)));a=a.return}return d}function gf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}\nfunction hf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Ob(c,f),null!=k&&g.unshift(ef(c,k,h))):e||(k=Ob(c,f),null!=k&&g.push(ef(c,k,h))));c=c.return}0!==g.length&&a.push({event:b,listeners:g})}function jf(){}var kf=null,lf=null;function mf(a,b){switch(a){case \"button\":case \"input\":case \"select\":case \"textarea\":return!!b.autoFocus}return!1}\nfunction nf(a,b){return\"textarea\"===a||\"option\"===a||\"noscript\"===a||\"string\"===typeof b.children||\"number\"===typeof b.children||\"object\"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}var of=\"function\"===typeof setTimeout?setTimeout:void 0,pf=\"function\"===typeof clearTimeout?clearTimeout:void 0;function qf(a){1===a.nodeType?a.textContent=\"\":9===a.nodeType&&(a=a.body,null!=a&&(a.textContent=\"\"))}\nfunction rf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function sf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(\"$\"===c||\"$!\"===c||\"$?\"===c){if(0===b)return a;b--}else\"/$\"===c&&b++}a=a.previousSibling}return null}var tf=0;function uf(a){return{$$typeof:Ga,toString:a,valueOf:a}}var vf=Math.random().toString(36).slice(2),wf=\"__reactFiber$\"+vf,xf=\"__reactProps$\"+vf,ff=\"__reactContainer$\"+vf,yf=\"__reactEvents$\"+vf;\nfunction wc(a){var b=a[wf];if(b)return b;for(var c=a.parentNode;c;){if(b=c[ff]||c[wf]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=sf(a);null!==a;){if(c=a[wf])return c;a=sf(a)}return b}a=c;c=a.parentNode}return null}function Cb(a){a=a[wf]||a[ff];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(y(33));}function Db(a){return a[xf]||null}\nfunction $e(a){var b=a[yf];void 0===b&&(b=a[yf]=new Set);return b}var zf=[],Af=-1;function Bf(a){return{current:a}}function H(a){0>Af||(a.current=zf[Af],zf[Af]=null,Af--)}function I(a,b){Af++;zf[Af]=a.current;a.current=b}var Cf={},M=Bf(Cf),N=Bf(!1),Df=Cf;\nfunction Ef(a,b){var c=a.type.contextTypes;if(!c)return Cf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function Ff(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Gf(){H(N);H(M)}function Hf(a,b,c){if(M.current!==Cf)throw Error(y(168));I(M,b);I(N,c)}\nfunction If(a,b,c){var d=a.stateNode;a=b.childContextTypes;if(\"function\"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(y(108,Ra(b)||\"Unknown\",e));return m({},c,d)}function Jf(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Cf;Df=M.current;I(M,a);I(N,N.current);return!0}function Kf(a,b,c){var d=a.stateNode;if(!d)throw Error(y(169));c?(a=If(a,b,Df),d.__reactInternalMemoizedMergedChildContext=a,H(N),H(M),I(M,a)):H(N);I(N,c)}\nvar Lf=null,Mf=null,Nf=r.unstable_runWithPriority,Of=r.unstable_scheduleCallback,Pf=r.unstable_cancelCallback,Qf=r.unstable_shouldYield,Rf=r.unstable_requestPaint,Sf=r.unstable_now,Tf=r.unstable_getCurrentPriorityLevel,Uf=r.unstable_ImmediatePriority,Vf=r.unstable_UserBlockingPriority,Wf=r.unstable_NormalPriority,Xf=r.unstable_LowPriority,Yf=r.unstable_IdlePriority,Zf={},$f=void 0!==Rf?Rf:function(){},ag=null,bg=null,cg=!1,dg=Sf(),O=1E4>dg?Sf:function(){return Sf()-dg};\nfunction eg(){switch(Tf()){case Uf:return 99;case Vf:return 98;case Wf:return 97;case Xf:return 96;case Yf:return 95;default:throw Error(y(332));}}function fg(a){switch(a){case 99:return Uf;case 98:return Vf;case 97:return Wf;case 96:return Xf;case 95:return Yf;default:throw Error(y(332));}}function gg(a,b){a=fg(a);return Nf(a,b)}function hg(a,b,c){a=fg(a);return Of(a,b,c)}function ig(){if(null!==bg){var a=bg;bg=null;Pf(a)}jg()}\nfunction jg(){if(!cg&&null!==ag){cg=!0;var a=0;try{var b=ag;gg(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});ag=null}catch(c){throw null!==ag&&(ag=ag.slice(a+1)),Of(Uf,ig),c;}finally{cg=!1}}}var kg=ra.ReactCurrentBatchConfig;function lg(a,b){if(a&&a.defaultProps){b=m({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}var mg=Bf(null),ng=null,og=null,pg=null;function qg(){pg=og=ng=null}\nfunction rg(a){var b=mg.current;H(mg);a.type._context._currentValue=b}function sg(a,b){for(;null!==a;){var c=a.alternate;if((a.childLanes&b)===b)if(null===c||(c.childLanes&b)===b)break;else c.childLanes|=b;else a.childLanes|=b,null!==c&&(c.childLanes|=b);a=a.return}}function tg(a,b){ng=a;pg=og=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(ug=!0),a.firstContext=null)}\nfunction vg(a,b){if(pg!==a&&!1!==b&&0!==b){if(\"number\"!==typeof b||1073741823===b)pg=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===og){if(null===ng)throw Error(y(308));og=b;ng.dependencies={lanes:0,firstContext:b,responders:null}}else og=og.next=b}return a._currentValue}var wg=!1;function xg(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null},effects:null}}\nfunction yg(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function zg(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}function Ag(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}\nfunction Bg(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=\nb;c.lastBaseUpdate=b}\nfunction Cg(a,b,c,d){var e=a.updateQueue;wg=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var n=a.alternate;if(null!==n){n=n.updateQueue;var A=n.lastBaseUpdate;A!==g&&(null===A?n.firstBaseUpdate=l:A.next=l,n.lastBaseUpdate=k)}}if(null!==f){A=e.baseState;g=0;n=l=k=null;do{h=f.lane;var p=f.eventTime;if((d&h)===h){null!==n&&(n=n.next={eventTime:p,lane:0,tag:f.tag,payload:f.payload,callback:f.callback,\nnext:null});a:{var C=a,x=f;h=b;p=c;switch(x.tag){case 1:C=x.payload;if(\"function\"===typeof C){A=C.call(p,A,h);break a}A=C;break a;case 3:C.flags=C.flags&-4097|64;case 0:C=x.payload;h=\"function\"===typeof C?C.call(p,A,h):C;if(null===h||void 0===h)break a;A=m({},A,h);break a;case 2:wg=!0}}null!==f.callback&&(a.flags|=32,h=e.effects,null===h?e.effects=[f]:h.push(f))}else p={eventTime:p,lane:h,tag:f.tag,payload:f.payload,callback:f.callback,next:null},null===n?(l=n=p,k=A):n=n.next=p,g|=h;f=f.next;if(null===\nf)if(h=e.shared.pending,null===h)break;else f=h.next,h.next=null,e.lastBaseUpdate=h,e.shared.pending=null}while(1);null===n&&(k=A);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=n;Dg|=g;a.lanes=g;a.memoizedState=A}}function Eg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if(\"function\"!==typeof e)throw Error(y(191,e));e.call(d)}}}var Fg=(new aa.Component).refs;\nfunction Gg(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:m({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}\nvar Kg={isMounted:function(a){return(a=a._reactInternals)?Zb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=Hg(),e=Ig(a),f=zg(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);Ag(a,f);Jg(a,e,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=Hg(),e=Ig(a),f=zg(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);Ag(a,f);Jg(a,e,d)},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=Hg(),d=Ig(a),e=zg(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=\nb);Ag(a,e);Jg(a,d,c)}};function Lg(a,b,c,d,e,f,g){a=a.stateNode;return\"function\"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Je(c,d)||!Je(e,f):!0}\nfunction Mg(a,b,c){var d=!1,e=Cf;var f=b.contextType;\"object\"===typeof f&&null!==f?f=vg(f):(e=Ff(b)?Df:M.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Ef(a,e):Cf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Kg;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}\nfunction Ng(a,b,c,d){a=b.state;\"function\"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);\"function\"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Kg.enqueueReplaceState(b,b.state,null)}\nfunction Og(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Fg;xg(a);var f=b.contextType;\"object\"===typeof f&&null!==f?e.context=vg(f):(f=Ff(b)?Df:M.current,e.context=Ef(a,f));Cg(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;\"function\"===typeof f&&(Gg(a,b,f,c),e.state=a.memoizedState);\"function\"===typeof b.getDerivedStateFromProps||\"function\"===typeof e.getSnapshotBeforeUpdate||\"function\"!==typeof e.UNSAFE_componentWillMount&&\"function\"!==typeof e.componentWillMount||\n(b=e.state,\"function\"===typeof e.componentWillMount&&e.componentWillMount(),\"function\"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Kg.enqueueReplaceState(e,e.state,null),Cg(a,c,e,d),e.state=a.memoizedState);\"function\"===typeof e.componentDidMount&&(a.flags|=4)}var Pg=Array.isArray;\nfunction Qg(a,b,c){a=c.ref;if(null!==a&&\"function\"!==typeof a&&\"object\"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(y(309));var d=c.stateNode}if(!d)throw Error(y(147,a));var e=\"\"+a;if(null!==b&&null!==b.ref&&\"function\"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===Fg&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if(\"string\"!==typeof a)throw Error(y(284));if(!c._owner)throw Error(y(290,a));}return a}\nfunction Rg(a,b){if(\"textarea\"!==a.type)throw Error(y(31,\"[object Object]\"===Object.prototype.toString.call(b)?\"object with keys {\"+Object.keys(b).join(\", \")+\"}\":b));}\nfunction Sg(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.flags=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=Tg(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags=2,\nc):d;b.flags=2;return c}function g(b){a&&null===b.alternate&&(b.flags=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Ug(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Qg(a,b,c),d.return=a,d;d=Vg(c.type,c.key,c.props,null,a.mode,d);d.ref=Qg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=\nWg(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function n(a,b,c,d,f){if(null===b||7!==b.tag)return b=Xg(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function A(a,b,c){if(\"string\"===typeof b||\"number\"===typeof b)return b=Ug(\"\"+b,a.mode,c),b.return=a,b;if(\"object\"===typeof b&&null!==b){switch(b.$$typeof){case sa:return c=Vg(b.type,b.key,b.props,null,a.mode,c),c.ref=Qg(a,null,b),c.return=a,c;case ta:return b=Wg(b,a.mode,c),b.return=a,b}if(Pg(b)||La(b))return b=Xg(b,\na.mode,c,null),b.return=a,b;Rg(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if(\"string\"===typeof c||\"number\"===typeof c)return null!==e?null:h(a,b,\"\"+c,d);if(\"object\"===typeof c&&null!==c){switch(c.$$typeof){case sa:return c.key===e?c.type===ua?n(a,b,c.props.children,d,e):k(a,b,c,d):null;case ta:return c.key===e?l(a,b,c,d):null}if(Pg(c)||La(c))return null!==e?null:n(a,b,c,d,null);Rg(a,c)}return null}function C(a,b,c,d,e){if(\"string\"===typeof d||\"number\"===typeof d)return a=a.get(c)||\nnull,h(b,a,\"\"+d,e);if(\"object\"===typeof d&&null!==d){switch(d.$$typeof){case sa:return a=a.get(null===d.key?c:d.key)||null,d.type===ua?n(b,a,d.props.children,e,d.key):k(b,a,d,e);case ta:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e)}if(Pg(d)||La(d))return a=a.get(c)||null,n(b,a,d,e,null);Rg(b,d)}return null}function x(e,g,h,k){for(var l=null,t=null,u=g,z=g=0,q=null;null!==u&&z<h.length;z++){u.index>z?(q=u,u=null):q=u.sibling;var n=p(e,u,h[z],k);if(null===n){null===u&&(u=q);break}a&&u&&null===\nn.alternate&&b(e,u);g=f(n,g,z);null===t?l=n:t.sibling=n;t=n;u=q}if(z===h.length)return c(e,u),l;if(null===u){for(;z<h.length;z++)u=A(e,h[z],k),null!==u&&(g=f(u,g,z),null===t?l=u:t.sibling=u,t=u);return l}for(u=d(e,u);z<h.length;z++)q=C(u,e,z,h[z],k),null!==q&&(a&&null!==q.alternate&&u.delete(null===q.key?z:q.key),g=f(q,g,z),null===t?l=q:t.sibling=q,t=q);a&&u.forEach(function(a){return b(e,a)});return l}function w(e,g,h,k){var l=La(h);if(\"function\"!==typeof l)throw Error(y(150));h=l.call(h);if(null==\nh)throw Error(y(151));for(var t=l=null,u=g,z=g=0,q=null,n=h.next();null!==u&&!n.done;z++,n=h.next()){u.index>z?(q=u,u=null):q=u.sibling;var w=p(e,u,n.value,k);if(null===w){null===u&&(u=q);break}a&&u&&null===w.alternate&&b(e,u);g=f(w,g,z);null===t?l=w:t.sibling=w;t=w;u=q}if(n.done)return c(e,u),l;if(null===u){for(;!n.done;z++,n=h.next())n=A(e,n.value,k),null!==n&&(g=f(n,g,z),null===t?l=n:t.sibling=n,t=n);return l}for(u=d(e,u);!n.done;z++,n=h.next())n=C(u,e,z,n.value,k),null!==n&&(a&&null!==n.alternate&&\nu.delete(null===n.key?z:n.key),g=f(n,g,z),null===t?l=n:t.sibling=n,t=n);a&&u.forEach(function(a){return b(e,a)});return l}return function(a,d,f,h){var k=\"object\"===typeof f&&null!==f&&f.type===ua&&null===f.key;k&&(f=f.props.children);var l=\"object\"===typeof f&&null!==f;if(l)switch(f.$$typeof){case sa:a:{l=f.key;for(k=d;null!==k;){if(k.key===l){switch(k.tag){case 7:if(f.type===ua){c(a,k.sibling);d=e(k,f.props.children);d.return=a;a=d;break a}break;default:if(k.elementType===f.type){c(a,k.sibling);\nd=e(k,f.props);d.ref=Qg(a,k,f);d.return=a;a=d;break a}}c(a,k);break}else b(a,k);k=k.sibling}f.type===ua?(d=Xg(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Vg(f.type,f.key,f.props,null,a.mode,h),h.ref=Qg(a,d,f),h.return=a,a=h)}return g(a);case ta:a:{for(k=f.key;null!==d;){if(d.key===k)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=\nWg(f,a.mode,h);d.return=a;a=d}return g(a)}if(\"string\"===typeof f||\"number\"===typeof f)return f=\"\"+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=Ug(f,a.mode,h),d.return=a,a=d),g(a);if(Pg(f))return x(a,d,f,h);if(La(f))return w(a,d,f,h);l&&Rg(a,f);if(\"undefined\"===typeof f&&!k)switch(a.tag){case 1:case 22:case 0:case 11:case 15:throw Error(y(152,Ra(a.type)||\"Component\"));}return c(a,d)}}var Yg=Sg(!0),Zg=Sg(!1),$g={},ah=Bf($g),bh=Bf($g),ch=Bf($g);\nfunction dh(a){if(a===$g)throw Error(y(174));return a}function eh(a,b){I(ch,b);I(bh,a);I(ah,$g);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:mb(null,\"\");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=mb(b,a)}H(ah);I(ah,b)}function fh(){H(ah);H(bh);H(ch)}function gh(a){dh(ch.current);var b=dh(ah.current);var c=mb(b,a.type);b!==c&&(I(bh,a),I(ah,c))}function hh(a){bh.current===a&&(H(ah),H(bh))}var P=Bf(0);\nfunction ih(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||\"$?\"===c.data||\"$!\"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}var jh=null,kh=null,lh=!1;\nfunction mh(a,b){var c=nh(5,null,null,0);c.elementType=\"DELETED\";c.type=\"DELETED\";c.stateNode=b;c.return=a;c.flags=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function oh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=\"\"===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}\nfunction ph(a){if(lh){var b=kh;if(b){var c=b;if(!oh(a,b)){b=rf(c.nextSibling);if(!b||!oh(a,b)){a.flags=a.flags&-1025|2;lh=!1;jh=a;return}mh(jh,c)}jh=a;kh=rf(b.firstChild)}else a.flags=a.flags&-1025|2,lh=!1,jh=a}}function qh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;jh=a}\nfunction rh(a){if(a!==jh)return!1;if(!lh)return qh(a),lh=!0,!1;var b=a.type;if(5!==a.tag||\"head\"!==b&&\"body\"!==b&&!nf(b,a.memoizedProps))for(b=kh;b;)mh(a,b),b=rf(b.nextSibling);qh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(y(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(\"/$\"===c){if(0===b){kh=rf(a.nextSibling);break a}b--}else\"$\"!==c&&\"$!\"!==c&&\"$?\"!==c||b++}a=a.nextSibling}kh=null}}else kh=jh?rf(a.stateNode.nextSibling):null;return!0}\nfunction sh(){kh=jh=null;lh=!1}var th=[];function uh(){for(var a=0;a<th.length;a++)th[a]._workInProgressVersionPrimary=null;th.length=0}var vh=ra.ReactCurrentDispatcher,wh=ra.ReactCurrentBatchConfig,xh=0,R=null,S=null,T=null,yh=!1,zh=!1;function Ah(){throw Error(y(321));}function Bh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!He(a[c],b[c]))return!1;return!0}\nfunction Ch(a,b,c,d,e,f){xh=f;R=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;vh.current=null===a||null===a.memoizedState?Dh:Eh;a=c(d,e);if(zh){f=0;do{zh=!1;if(!(25>f))throw Error(y(301));f+=1;T=S=null;b.updateQueue=null;vh.current=Fh;a=c(d,e)}while(zh)}vh.current=Gh;b=null!==S&&null!==S.next;xh=0;T=S=R=null;yh=!1;if(b)throw Error(y(300));return a}function Hh(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===T?R.memoizedState=T=a:T=T.next=a;return T}\nfunction Ih(){if(null===S){var a=R.alternate;a=null!==a?a.memoizedState:null}else a=S.next;var b=null===T?R.memoizedState:T.next;if(null!==b)T=b,S=a;else{if(null===a)throw Error(y(310));S=a;a={memoizedState:S.memoizedState,baseState:S.baseState,baseQueue:S.baseQueue,queue:S.queue,next:null};null===T?R.memoizedState=T=a:T=T.next=a}return T}function Jh(a,b){return\"function\"===typeof b?b(a):b}\nfunction Kh(a){var b=Ih(),c=b.queue;if(null===c)throw Error(y(311));c.lastRenderedReducer=a;var d=S,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,k=e;do{var l=k.lane;if((xh&l)===l)null!==h&&(h=h.next={lane:0,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null}),d=k.eagerReducer===a?k.eagerState:a(d,k.action);else{var n={lane:l,action:k.action,eagerReducer:k.eagerReducer,\neagerState:k.eagerState,next:null};null===h?(g=h=n,f=d):h=h.next=n;R.lanes|=l;Dg|=l}k=k.next}while(null!==k&&k!==e);null===h?f=d:h.next=g;He(d,b.memoizedState)||(ug=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,c.dispatch]}\nfunction Lh(a){var b=Ih(),c=b.queue;if(null===c)throw Error(y(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He(f,b.memoizedState)||(ug=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}\nfunction Mh(a,b,c){var d=b._getVersion;d=d(b._source);var e=b._workInProgressVersionPrimary;if(null!==e)a=e===d;else if(a=a.mutableReadLanes,a=(xh&a)===a)b._workInProgressVersionPrimary=d,th.push(b);if(a)return c(b._source);th.push(b);throw Error(y(350));}\nfunction Nh(a,b,c,d){var e=U;if(null===e)throw Error(y(349));var f=b._getVersion,g=f(b._source),h=vh.current,k=h.useState(function(){return Mh(e,b,c)}),l=k[1],n=k[0];k=T;var A=a.memoizedState,p=A.refs,C=p.getSnapshot,x=A.source;A=A.subscribe;var w=R;a.memoizedState={refs:p,source:b,subscribe:d};h.useEffect(function(){p.getSnapshot=c;p.setSnapshot=l;var a=f(b._source);if(!He(g,a)){a=c(b._source);He(n,a)||(l(a),a=Ig(w),e.mutableReadLanes|=a&e.pendingLanes);a=e.mutableReadLanes;e.entangledLanes|=a;for(var d=\ne.entanglements,h=a;0<h;){var k=31-Vc(h),v=1<<k;d[k]|=a;h&=~v}}},[c,b,d]);h.useEffect(function(){return d(b._source,function(){var a=p.getSnapshot,c=p.setSnapshot;try{c(a(b._source));var d=Ig(w);e.mutableReadLanes|=d&e.pendingLanes}catch(q){c(function(){throw q;})}})},[b,d]);He(C,c)&&He(x,b)&&He(A,d)||(a={pending:null,dispatch:null,lastRenderedReducer:Jh,lastRenderedState:n},a.dispatch=l=Oh.bind(null,R,a),k.queue=a,k.baseQueue=null,n=Mh(e,b,c),k.memoizedState=k.baseState=n);return n}\nfunction Ph(a,b,c){var d=Ih();return Nh(d,a,b,c)}function Qh(a){var b=Hh();\"function\"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Jh,lastRenderedState:a};a=a.dispatch=Oh.bind(null,R,a);return[b.memoizedState,a]}\nfunction Rh(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=R.updateQueue;null===b?(b={lastEffect:null},R.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function Sh(a){var b=Hh();a={current:a};return b.memoizedState=a}function Th(){return Ih().memoizedState}function Uh(a,b,c,d){var e=Hh();R.flags|=a;e.memoizedState=Rh(1|b,c,void 0,void 0===d?null:d)}\nfunction Vh(a,b,c,d){var e=Ih();d=void 0===d?null:d;var f=void 0;if(null!==S){var g=S.memoizedState;f=g.destroy;if(null!==d&&Bh(d,g.deps)){Rh(b,c,f,d);return}}R.flags|=a;e.memoizedState=Rh(1|b,c,f,d)}function Wh(a,b){return Uh(516,4,a,b)}function Xh(a,b){return Vh(516,4,a,b)}function Yh(a,b){return Vh(4,2,a,b)}function Zh(a,b){if(\"function\"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}\nfunction $h(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Vh(4,2,Zh.bind(null,b,a),c)}function ai(){}function bi(a,b){var c=Ih();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Bh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function ci(a,b){var c=Ih();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Bh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}\nfunction di(a,b){var c=eg();gg(98>c?98:c,function(){a(!0)});gg(97<c?97:c,function(){var c=wh.transition;wh.transition=1;try{a(!1),b()}finally{wh.transition=c}})}\nfunction Oh(a,b,c){var d=Hg(),e=Ig(a),f={lane:e,action:c,eagerReducer:null,eagerState:null,next:null},g=b.pending;null===g?f.next=f:(f.next=g.next,g.next=f);b.pending=f;g=a.alternate;if(a===R||null!==g&&g===R)zh=yh=!0;else{if(0===a.lanes&&(null===g||0===g.lanes)&&(g=b.lastRenderedReducer,null!==g))try{var h=b.lastRenderedState,k=g(h,c);f.eagerReducer=g;f.eagerState=k;if(He(k,h))return}catch(l){}finally{}Jg(a,e,d)}}\nvar Gh={readContext:vg,useCallback:Ah,useContext:Ah,useEffect:Ah,useImperativeHandle:Ah,useLayoutEffect:Ah,useMemo:Ah,useReducer:Ah,useRef:Ah,useState:Ah,useDebugValue:Ah,useDeferredValue:Ah,useTransition:Ah,useMutableSource:Ah,useOpaqueIdentifier:Ah,unstable_isNewReconciler:!1},Dh={readContext:vg,useCallback:function(a,b){Hh().memoizedState=[a,void 0===b?null:b];return a},useContext:vg,useEffect:Wh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Uh(4,2,Zh.bind(null,\nb,a),c)},useLayoutEffect:function(a,b){return Uh(4,2,a,b)},useMemo:function(a,b){var c=Hh();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=Hh();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=Oh.bind(null,R,a);return[d.memoizedState,a]},useRef:Sh,useState:Qh,useDebugValue:ai,useDeferredValue:function(a){var b=Qh(a),c=b[0],d=b[1];Wh(function(){var b=wh.transition;\nwh.transition=1;try{d(a)}finally{wh.transition=b}},[a]);return c},useTransition:function(){var a=Qh(!1),b=a[0];a=di.bind(null,a[1]);Sh(a);return[a,b]},useMutableSource:function(a,b,c){var d=Hh();d.memoizedState={refs:{getSnapshot:b,setSnapshot:null},source:a,subscribe:c};return Nh(d,a,b,c)},useOpaqueIdentifier:function(){if(lh){var a=!1,b=uf(function(){a||(a=!0,c(\"r:\"+(tf++).toString(36)));throw Error(y(355));}),c=Qh(b)[1];0===(R.mode&2)&&(R.flags|=516,Rh(5,function(){c(\"r:\"+(tf++).toString(36))},\nvoid 0,null));return b}b=\"r:\"+(tf++).toString(36);Qh(b);return b},unstable_isNewReconciler:!1},Eh={readContext:vg,useCallback:bi,useContext:vg,useEffect:Xh,useImperativeHandle:$h,useLayoutEffect:Yh,useMemo:ci,useReducer:Kh,useRef:Th,useState:function(){return Kh(Jh)},useDebugValue:ai,useDeferredValue:function(a){var b=Kh(Jh),c=b[0],d=b[1];Xh(function(){var b=wh.transition;wh.transition=1;try{d(a)}finally{wh.transition=b}},[a]);return c},useTransition:function(){var a=Kh(Jh)[0];return[Th().current,\na]},useMutableSource:Ph,useOpaqueIdentifier:function(){return Kh(Jh)[0]},unstable_isNewReconciler:!1},Fh={readContext:vg,useCallback:bi,useContext:vg,useEffect:Xh,useImperativeHandle:$h,useLayoutEffect:Yh,useMemo:ci,useReducer:Lh,useRef:Th,useState:function(){return Lh(Jh)},useDebugValue:ai,useDeferredValue:function(a){var b=Lh(Jh),c=b[0],d=b[1];Xh(function(){var b=wh.transition;wh.transition=1;try{d(a)}finally{wh.transition=b}},[a]);return c},useTransition:function(){var a=Lh(Jh)[0];return[Th().current,\na]},useMutableSource:Ph,useOpaqueIdentifier:function(){return Lh(Jh)[0]},unstable_isNewReconciler:!1},ei=ra.ReactCurrentOwner,ug=!1;function fi(a,b,c,d){b.child=null===a?Zg(b,null,c,d):Yg(b,a.child,c,d)}function gi(a,b,c,d,e){c=c.render;var f=b.ref;tg(b,e);d=Ch(a,b,c,d,f,e);if(null!==a&&!ug)return b.updateQueue=a.updateQueue,b.flags&=-517,a.lanes&=~e,hi(a,b,e);b.flags|=1;fi(a,b,d,e);return b.child}\nfunction ii(a,b,c,d,e,f){if(null===a){var g=c.type;if(\"function\"===typeof g&&!ji(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ki(a,b,g,d,e,f);a=Vg(c.type,null,d,b,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(0===(e&f)&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Je,c(e,d)&&a.ref===b.ref))return hi(a,b,f);b.flags|=1;a=Tg(g,d);a.ref=b.ref;a.return=b;return b.child=a}\nfunction ki(a,b,c,d,e,f){if(null!==a&&Je(a.memoizedProps,d)&&a.ref===b.ref)if(ug=!1,0!==(f&e))0!==(a.flags&16384)&&(ug=!0);else return b.lanes=a.lanes,hi(a,b,f);return li(a,b,c,d,f)}\nfunction mi(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if(\"hidden\"===d.mode||\"unstable-defer-without-hiding\"===d.mode)if(0===(b.mode&4))b.memoizedState={baseLanes:0},ni(b,c);else if(0!==(c&1073741824))b.memoizedState={baseLanes:0},ni(b,null!==f?f.baseLanes:c);else return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a},ni(b,a),null;else null!==f?(d=f.baseLanes|c,b.memoizedState=null):d=c,ni(b,d);fi(a,b,e,c);return b.child}\nfunction oi(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=128}function li(a,b,c,d,e){var f=Ff(c)?Df:M.current;f=Ef(b,f);tg(b,e);c=Ch(a,b,c,d,f,e);if(null!==a&&!ug)return b.updateQueue=a.updateQueue,b.flags&=-517,a.lanes&=~e,hi(a,b,e);b.flags|=1;fi(a,b,c,e);return b.child}\nfunction pi(a,b,c,d,e){if(Ff(c)){var f=!0;Jf(b)}else f=!1;tg(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2),Mg(b,c,d),Og(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;\"object\"===typeof l&&null!==l?l=vg(l):(l=Ff(c)?Df:M.current,l=Ef(b,l));var n=c.getDerivedStateFromProps,A=\"function\"===typeof n||\"function\"===typeof g.getSnapshotBeforeUpdate;A||\"function\"!==typeof g.UNSAFE_componentWillReceiveProps&&\n\"function\"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Ng(b,g,d,l);wg=!1;var p=b.memoizedState;g.state=p;Cg(b,d,g,e);k=b.memoizedState;h!==d||p!==k||N.current||wg?(\"function\"===typeof n&&(Gg(b,c,n,d),k=b.memoizedState),(h=wg||Lg(b,c,h,d,p,k,l))?(A||\"function\"!==typeof g.UNSAFE_componentWillMount&&\"function\"!==typeof g.componentWillMount||(\"function\"===typeof g.componentWillMount&&g.componentWillMount(),\"function\"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),\"function\"===\ntypeof g.componentDidMount&&(b.flags|=4)):(\"function\"===typeof g.componentDidMount&&(b.flags|=4),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):(\"function\"===typeof g.componentDidMount&&(b.flags|=4),d=!1)}else{g=b.stateNode;yg(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:lg(b.type,h);g.props=l;A=b.pendingProps;p=g.context;k=c.contextType;\"object\"===typeof k&&null!==k?k=vg(k):(k=Ff(c)?Df:M.current,k=Ef(b,k));var C=c.getDerivedStateFromProps;(n=\"function\"===typeof C||\n\"function\"===typeof g.getSnapshotBeforeUpdate)||\"function\"!==typeof g.UNSAFE_componentWillReceiveProps&&\"function\"!==typeof g.componentWillReceiveProps||(h!==A||p!==k)&&Ng(b,g,d,k);wg=!1;p=b.memoizedState;g.state=p;Cg(b,d,g,e);var x=b.memoizedState;h!==A||p!==x||N.current||wg?(\"function\"===typeof C&&(Gg(b,c,C,d),x=b.memoizedState),(l=wg||Lg(b,c,l,d,p,x,k))?(n||\"function\"!==typeof g.UNSAFE_componentWillUpdate&&\"function\"!==typeof g.componentWillUpdate||(\"function\"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,\nx,k),\"function\"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,x,k)),\"function\"===typeof g.componentDidUpdate&&(b.flags|=4),\"function\"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=256)):(\"function\"!==typeof g.componentDidUpdate||h===a.memoizedProps&&p===a.memoizedState||(b.flags|=4),\"function\"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&p===a.memoizedState||(b.flags|=256),b.memoizedProps=d,b.memoizedState=x),g.props=d,g.state=x,g.context=k,d=l):(\"function\"!==typeof g.componentDidUpdate||\nh===a.memoizedProps&&p===a.memoizedState||(b.flags|=4),\"function\"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&p===a.memoizedState||(b.flags|=256),d=!1)}return qi(a,b,c,d,f,e)}\nfunction qi(a,b,c,d,e,f){oi(a,b);var g=0!==(b.flags&64);if(!d&&!g)return e&&Kf(b,c,!1),hi(a,b,f);d=b.stateNode;ei.current=b;var h=g&&\"function\"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Yg(b,a.child,null,f),b.child=Yg(b,null,h,f)):fi(a,b,h,f);b.memoizedState=d.state;e&&Kf(b,c,!0);return b.child}function ri(a){var b=a.stateNode;b.pendingContext?Hf(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Hf(a,b.context,!1);eh(a,b.containerInfo)}\nvar si={dehydrated:null,retryLane:0};\nfunction ti(a,b,c){var d=b.pendingProps,e=P.current,f=!1,g;(g=0!==(b.flags&64))||(g=null!==a&&null===a.memoizedState?!1:0!==(e&2));g?(f=!0,b.flags&=-65):null!==a&&null===a.memoizedState||void 0===d.fallback||!0===d.unstable_avoidThisFallback||(e|=1);I(P,e&1);if(null===a){void 0!==d.fallback&&ph(b);a=d.children;e=d.fallback;if(f)return a=ui(b,a,e,c),b.child.memoizedState={baseLanes:c},b.memoizedState=si,a;if(\"number\"===typeof d.unstable_expectedLoadTime)return a=ui(b,a,e,c),b.child.memoizedState={baseLanes:c},\nb.memoizedState=si,b.lanes=33554432,a;c=vi({mode:\"visible\",children:a},b.mode,c,null);c.return=b;return b.child=c}if(null!==a.memoizedState){if(f)return d=wi(a,b,d.children,d.fallback,c),f=b.child,e=a.child.memoizedState,f.memoizedState=null===e?{baseLanes:c}:{baseLanes:e.baseLanes|c},f.childLanes=a.childLanes&~c,b.memoizedState=si,d;c=xi(a,b,d.children,c);b.memoizedState=null;return c}if(f)return d=wi(a,b,d.children,d.fallback,c),f=b.child,e=a.child.memoizedState,f.memoizedState=null===e?{baseLanes:c}:\n{baseLanes:e.baseLanes|c},f.childLanes=a.childLanes&~c,b.memoizedState=si,d;c=xi(a,b,d.children,c);b.memoizedState=null;return c}function ui(a,b,c,d){var e=a.mode,f=a.child;b={mode:\"hidden\",children:b};0===(e&2)&&null!==f?(f.childLanes=0,f.pendingProps=b):f=vi(b,e,0,null);c=Xg(c,e,d,null);f.return=a;c.return=a;f.sibling=c;a.child=f;return c}\nfunction xi(a,b,c,d){var e=a.child;a=e.sibling;c=Tg(e,{mode:\"visible\",children:c});0===(b.mode&2)&&(c.lanes=d);c.return=b;c.sibling=null;null!==a&&(a.nextEffect=null,a.flags=8,b.firstEffect=b.lastEffect=a);return b.child=c}\nfunction wi(a,b,c,d,e){var f=b.mode,g=a.child;a=g.sibling;var h={mode:\"hidden\",children:c};0===(f&2)&&b.child!==g?(c=b.child,c.childLanes=0,c.pendingProps=h,g=c.lastEffect,null!==g?(b.firstEffect=c.firstEffect,b.lastEffect=g,g.nextEffect=null):b.firstEffect=b.lastEffect=null):c=Tg(g,h);null!==a?d=Tg(a,d):(d=Xg(d,f,e,null),d.flags|=2);d.return=b;c.return=b;c.sibling=d;b.child=c;return d}function yi(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);sg(a.return,b)}\nfunction zi(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e,lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailMode=e,g.lastEffect=f)}\nfunction Ai(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;fi(a,b,d.children,c);d=P.current;if(0!==(d&2))d=d&1|2,b.flags|=64;else{if(null!==a&&0!==(a.flags&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&yi(a,c);else if(19===a.tag)yi(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}I(P,d);if(0===(b.mode&2))b.memoizedState=\nnull;else switch(e){case \"forwards\":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===ih(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);zi(b,!1,e,c,f,b.lastEffect);break;case \"backwards\":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===ih(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}zi(b,!0,c,null,f,b.lastEffect);break;case \"together\":zi(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}\nfunction hi(a,b,c){null!==a&&(b.dependencies=a.dependencies);Dg|=b.lanes;if(0!==(c&b.childLanes)){if(null!==a&&b.child!==a.child)throw Error(y(153));if(null!==b.child){a=b.child;c=Tg(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Tg(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}return null}var Bi,Ci,Di,Ei;\nBi=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Ci=function(){};\nDi=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;dh(ah.current);var f=null;switch(c){case \"input\":e=Ya(a,e);d=Ya(a,d);f=[];break;case \"option\":e=eb(a,e);d=eb(a,d);f=[];break;case \"select\":e=m({},e,{value:void 0});d=m({},d,{value:void 0});f=[];break;case \"textarea\":e=gb(a,e);d=gb(a,d);f=[];break;default:\"function\"!==typeof e.onClick&&\"function\"===typeof d.onClick&&(a.onclick=jf)}vb(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if(\"style\"===\nl){var h=e[l];for(g in h)h.hasOwnProperty(g)&&(c||(c={}),c[g]=\"\")}else\"dangerouslySetInnerHTML\"!==l&&\"children\"!==l&&\"suppressContentEditableWarning\"!==l&&\"suppressHydrationWarning\"!==l&&\"autoFocus\"!==l&&(ca.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if(\"style\"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]=\"\");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||\n(c={}),c[g]=k[g])}else c||(f||(f=[]),f.push(l,c)),c=k;else\"dangerouslySetInnerHTML\"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):\"children\"===l?\"string\"!==typeof k&&\"number\"!==typeof k||(f=f||[]).push(l,\"\"+k):\"suppressContentEditableWarning\"!==l&&\"suppressHydrationWarning\"!==l&&(ca.hasOwnProperty(l)?(null!=k&&\"onScroll\"===l&&G(\"scroll\",a),f||h===k||(f=[])):\"object\"===typeof k&&null!==k&&k.$$typeof===Ga?k.toString():(f=f||[]).push(l,k))}c&&(f=f||[]).push(\"style\",\nc);var l=f;if(b.updateQueue=l)b.flags|=4}};Ei=function(a,b,c,d){c!==d&&(b.flags|=4)};function Fi(a,b){if(!lh)switch(a.tailMode){case \"hidden\":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case \"collapsed\":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}\nfunction Gi(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return Ff(b.type)&&Gf(),null;case 3:fh();H(N);H(M);uh();d=b.stateNode;d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)rh(b)?b.flags|=4:d.hydrate||(b.flags|=256);Ci(b);return null;case 5:hh(b);var e=dh(ch.current);c=b.type;if(null!==a&&null!=b.stateNode)Di(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=128);else{if(!d){if(null===\nb.stateNode)throw Error(y(166));return null}a=dh(ah.current);if(rh(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[wf]=b;d[xf]=f;switch(c){case \"dialog\":G(\"cancel\",d);G(\"close\",d);break;case \"iframe\":case \"object\":case \"embed\":G(\"load\",d);break;case \"video\":case \"audio\":for(a=0;a<Xe.length;a++)G(Xe[a],d);break;case \"source\":G(\"error\",d);break;case \"img\":case \"image\":case \"link\":G(\"error\",d);G(\"load\",d);break;case \"details\":G(\"toggle\",d);break;case \"input\":Za(d,f);G(\"invalid\",d);break;case \"select\":d._wrapperState=\n{wasMultiple:!!f.multiple};G(\"invalid\",d);break;case \"textarea\":hb(d,f),G(\"invalid\",d)}vb(c,f);a=null;for(var g in f)f.hasOwnProperty(g)&&(e=f[g],\"children\"===g?\"string\"===typeof e?d.textContent!==e&&(a=[\"children\",e]):\"number\"===typeof e&&d.textContent!==\"\"+e&&(a=[\"children\",\"\"+e]):ca.hasOwnProperty(g)&&null!=e&&\"onScroll\"===g&&G(\"scroll\",d));switch(c){case \"input\":Va(d);cb(d,f,!0);break;case \"textarea\":Va(d);jb(d);break;case \"select\":case \"option\":break;default:\"function\"===typeof f.onClick&&(d.onclick=\njf)}d=a;b.updateQueue=d;null!==d&&(b.flags|=4)}else{g=9===e.nodeType?e:e.ownerDocument;a===kb.html&&(a=lb(c));a===kb.html?\"script\"===c?(a=g.createElement(\"div\"),a.innerHTML=\"<script>\\x3c/script>\",a=a.removeChild(a.firstChild)):\"string\"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),\"select\"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[wf]=b;a[xf]=d;Bi(a,b,!1,!1);b.stateNode=a;g=wb(c,d);switch(c){case \"dialog\":G(\"cancel\",a);G(\"close\",a);\ne=d;break;case \"iframe\":case \"object\":case \"embed\":G(\"load\",a);e=d;break;case \"video\":case \"audio\":for(e=0;e<Xe.length;e++)G(Xe[e],a);e=d;break;case \"source\":G(\"error\",a);e=d;break;case \"img\":case \"image\":case \"link\":G(\"error\",a);G(\"load\",a);e=d;break;case \"details\":G(\"toggle\",a);e=d;break;case \"input\":Za(a,d);e=Ya(a,d);G(\"invalid\",a);break;case \"option\":e=eb(a,d);break;case \"select\":a._wrapperState={wasMultiple:!!d.multiple};e=m({},d,{value:void 0});G(\"invalid\",a);break;case \"textarea\":hb(a,d);e=\ngb(a,d);G(\"invalid\",a);break;default:e=d}vb(c,e);var h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];\"style\"===f?tb(a,k):\"dangerouslySetInnerHTML\"===f?(k=k?k.__html:void 0,null!=k&&ob(a,k)):\"children\"===f?\"string\"===typeof k?(\"textarea\"!==c||\"\"!==k)&&pb(a,k):\"number\"===typeof k&&pb(a,\"\"+k):\"suppressContentEditableWarning\"!==f&&\"suppressHydrationWarning\"!==f&&\"autoFocus\"!==f&&(ca.hasOwnProperty(f)?null!=k&&\"onScroll\"===f&&G(\"scroll\",a):null!=k&&qa(a,f,k,g))}switch(c){case \"input\":Va(a);cb(a,d,!1);\nbreak;case \"textarea\":Va(a);jb(a);break;case \"option\":null!=d.value&&a.setAttribute(\"value\",\"\"+Sa(d.value));break;case \"select\":a.multiple=!!d.multiple;f=d.value;null!=f?fb(a,!!d.multiple,f,!1):null!=d.defaultValue&&fb(a,!!d.multiple,d.defaultValue,!0);break;default:\"function\"===typeof e.onClick&&(a.onclick=jf)}mf(c,d)&&(b.flags|=4)}null!==b.ref&&(b.flags|=128)}return null;case 6:if(a&&null!=b.stateNode)Ei(a,b,a.memoizedProps,d);else{if(\"string\"!==typeof d&&null===b.stateNode)throw Error(y(166));\nc=dh(ch.current);dh(ah.current);rh(b)?(d=b.stateNode,c=b.memoizedProps,d[wf]=b,d.nodeValue!==c&&(b.flags|=4)):(d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[wf]=b,b.stateNode=d)}return null;case 13:H(P);d=b.memoizedState;if(0!==(b.flags&64))return b.lanes=c,b;d=null!==d;c=!1;null===a?void 0!==b.memoizedProps.fallback&&rh(b):c=null!==a.memoizedState;if(d&&!c&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||0!==(P.current&1))0===V&&(V=3);else{if(0===V||3===V)V=\n4;null===U||0===(Dg&134217727)&&0===(Hi&134217727)||Ii(U,W)}if(d||c)b.flags|=4;return null;case 4:return fh(),Ci(b),null===a&&cf(b.stateNode.containerInfo),null;case 10:return rg(b),null;case 17:return Ff(b.type)&&Gf(),null;case 19:H(P);d=b.memoizedState;if(null===d)return null;f=0!==(b.flags&64);g=d.rendering;if(null===g)if(f)Fi(d,!1);else{if(0!==V||null!==a&&0!==(a.flags&64))for(a=b.child;null!==a;){g=ih(a);if(null!==g){b.flags|=64;Fi(d,!1);f=g.updateQueue;null!==f&&(b.updateQueue=f,b.flags|=4);\nnull===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=2,f.nextEffect=null,f.firstEffect=null,f.lastEffect=null,g=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,\nf.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;I(P,P.current&1|2);return b.child}a=a.sibling}null!==d.tail&&O()>Ji&&(b.flags|=64,f=!0,Fi(d,!1),b.lanes=33554432)}else{if(!f)if(a=ih(g),null!==a){if(b.flags|=64,f=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Fi(d,!0),null===d.tail&&\"hidden\"===d.tailMode&&!g.alternate&&!lh)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*O()-d.renderingStartTime>Ji&&1073741824!==c&&(b.flags|=\n64,f=!0,Fi(d,!1),b.lanes=33554432);d.isBackwards?(g.sibling=b.child,b.child=g):(c=d.last,null!==c?c.sibling=g:b.child=g,d.last=g)}return null!==d.tail?(c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=O(),c.sibling=null,b=P.current,I(P,f?b&1|2:b&1),c):null;case 23:case 24:return Ki(),null!==a&&null!==a.memoizedState!==(null!==b.memoizedState)&&\"unstable-defer-without-hiding\"!==d.mode&&(b.flags|=4),null}throw Error(y(156,b.tag));}\nfunction Li(a){switch(a.tag){case 1:Ff(a.type)&&Gf();var b=a.flags;return b&4096?(a.flags=b&-4097|64,a):null;case 3:fh();H(N);H(M);uh();b=a.flags;if(0!==(b&64))throw Error(y(285));a.flags=b&-4097|64;return a;case 5:return hh(a),null;case 13:return H(P),b=a.flags,b&4096?(a.flags=b&-4097|64,a):null;case 19:return H(P),null;case 4:return fh(),null;case 10:return rg(a),null;case 23:case 24:return Ki(),null;default:return null}}\nfunction Mi(a,b){try{var c=\"\",d=b;do c+=Qa(d),d=d.return;while(d);var e=c}catch(f){e=\"\\nError generating stack: \"+f.message+\"\\n\"+f.stack}return{value:a,source:b,stack:e}}function Ni(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}var Oi=\"function\"===typeof WeakMap?WeakMap:Map;function Pi(a,b,c){c=zg(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Qi||(Qi=!0,Ri=d);Ni(a,b)};return c}\nfunction Si(a,b,c){c=zg(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if(\"function\"===typeof d){var e=b.value;c.payload=function(){Ni(a,b);return d(e)}}var f=a.stateNode;null!==f&&\"function\"===typeof f.componentDidCatch&&(c.callback=function(){\"function\"!==typeof d&&(null===Ti?Ti=new Set([this]):Ti.add(this),Ni(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:\"\"})});return c}var Ui=\"function\"===typeof WeakSet?WeakSet:Set;\nfunction Vi(a){var b=a.ref;if(null!==b)if(\"function\"===typeof b)try{b(null)}catch(c){Wi(a,c)}else b.current=null}function Xi(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.flags&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===b.type?c:lg(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:b.flags&256&&qf(b.stateNode.containerInfo);return;case 5:case 6:case 4:case 17:return}throw Error(y(163));}\nfunction Yi(a,b,c){switch(c.tag){case 0:case 11:case 15:case 22:b=c.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){a=b=b.next;do{if(3===(a.tag&3)){var d=a.create;a.destroy=d()}a=a.next}while(a!==b)}b=c.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){a=b=b.next;do{var e=a;d=e.next;e=e.tag;0!==(e&4)&&0!==(e&1)&&(Zi(c,a),$i(c,a));a=d}while(a!==b)}return;case 1:a=c.stateNode;c.flags&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:lg(c.type,b.memoizedProps),a.componentDidUpdate(d,\nb.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Eg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Eg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.flags&4&&mf(c.type,c.memoizedProps)&&a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&Cc(c))));\nreturn;case 19:case 17:case 20:case 21:case 23:case 24:return}throw Error(y(163));}\nfunction aj(a,b){for(var c=a;;){if(5===c.tag){var d=c.stateNode;if(b)d=d.style,\"function\"===typeof d.setProperty?d.setProperty(\"display\",\"none\",\"important\"):d.display=\"none\";else{d=c.stateNode;var e=c.memoizedProps.style;e=void 0!==e&&null!==e&&e.hasOwnProperty(\"display\")?e.display:null;d.style.display=sb(\"display\",e)}}else if(6===c.tag)c.stateNode.nodeValue=b?\"\":c.memoizedProps;else if((23!==c.tag&&24!==c.tag||null===c.memoizedState||c===a)&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===\na)break;for(;null===c.sibling;){if(null===c.return||c.return===a)return;c=c.return}c.sibling.return=c.return;c=c.sibling}}\nfunction bj(a,b){if(Mf&&\"function\"===typeof Mf.onCommitFiberUnmount)try{Mf.onCommitFiberUnmount(Lf,b)}catch(f){}switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var c=a=a.next;do{var d=c,e=d.destroy;d=d.tag;if(void 0!==e)if(0!==(d&4))Zi(b,c);else{d=b;try{e()}catch(f){Wi(d,f)}}c=c.next}while(c!==a)}break;case 1:Vi(b);a=b.stateNode;if(\"function\"===typeof a.componentWillUnmount)try{a.props=b.memoizedProps,a.state=b.memoizedState,a.componentWillUnmount()}catch(f){Wi(b,\nf)}break;case 5:Vi(b);break;case 4:cj(a,b)}}function dj(a){a.alternate=null;a.child=null;a.dependencies=null;a.firstEffect=null;a.lastEffect=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.return=null;a.updateQueue=null}function ej(a){return 5===a.tag||3===a.tag||4===a.tag}\nfunction fj(a){a:{for(var b=a.return;null!==b;){if(ej(b))break a;b=b.return}throw Error(y(160));}var c=b;b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(y(161));}c.flags&16&&(pb(b,\"\"),c.flags&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||ej(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.flags&2)continue b;if(null===\nc.child||4===c.tag)continue b;else c.child.return=c,c=c.child}if(!(c.flags&2)){c=c.stateNode;break a}}d?gj(a,c,b):hj(a,c,b)}\nfunction gj(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=jf));else if(4!==d&&(a=a.child,null!==a))for(gj(a,b,c),a=a.sibling;null!==a;)gj(a,b,c),a=a.sibling}\nfunction hj(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(hj(a,b,c),a=a.sibling;null!==a;)hj(a,b,c),a=a.sibling}\nfunction cj(a,b){for(var c=b,d=!1,e,f;;){if(!d){d=c.return;a:for(;;){if(null===d)throw Error(y(160));e=d.stateNode;switch(d.tag){case 5:f=!1;break a;case 3:e=e.containerInfo;f=!0;break a;case 4:e=e.containerInfo;f=!0;break a}d=d.return}d=!0}if(5===c.tag||6===c.tag){a:for(var g=a,h=c,k=h;;)if(bj(g,k),null!==k.child&&4!==k.tag)k.child.return=k,k=k.child;else{if(k===h)break a;for(;null===k.sibling;){if(null===k.return||k.return===h)break a;k=k.return}k.sibling.return=k.return;k=k.sibling}f?(g=e,h=c.stateNode,\n8===g.nodeType?g.parentNode.removeChild(h):g.removeChild(h)):e.removeChild(c.stateNode)}else if(4===c.tag){if(null!==c.child){e=c.stateNode.containerInfo;f=!0;c.child.return=c;c=c.child;continue}}else if(bj(a,c),null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return;4===c.tag&&(d=!1)}c.sibling.return=c.return;c=c.sibling}}\nfunction ij(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:var c=b.updateQueue;c=null!==c?c.lastEffect:null;if(null!==c){var d=c=c.next;do 3===(d.tag&3)&&(a=d.destroy,d.destroy=void 0,void 0!==a&&a()),d=d.next;while(d!==c)}return;case 1:return;case 5:c=b.stateNode;if(null!=c){d=b.memoizedProps;var e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[xf]=d;\"input\"===a&&\"radio\"===d.type&&null!=d.name&&$a(c,d);wb(a,e);b=wb(a,d);for(e=0;e<f.length;e+=\n2){var g=f[e],h=f[e+1];\"style\"===g?tb(c,h):\"dangerouslySetInnerHTML\"===g?ob(c,h):\"children\"===g?pb(c,h):qa(c,g,h,b)}switch(a){case \"input\":ab(c,d);break;case \"textarea\":ib(c,d);break;case \"select\":a=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,f=d.value,null!=f?fb(c,!!d.multiple,f,!1):a!==!!d.multiple&&(null!=d.defaultValue?fb(c,!!d.multiple,d.defaultValue,!0):fb(c,!!d.multiple,d.multiple?[]:\"\",!1))}}}return;case 6:if(null===b.stateNode)throw Error(y(162));b.stateNode.nodeValue=\nb.memoizedProps;return;case 3:c=b.stateNode;c.hydrate&&(c.hydrate=!1,Cc(c.containerInfo));return;case 12:return;case 13:null!==b.memoizedState&&(jj=O(),aj(b.child,!0));kj(b);return;case 19:kj(b);return;case 17:return;case 23:case 24:aj(b,null!==b.memoizedState);return}throw Error(y(163));}function kj(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Ui);b.forEach(function(b){var d=lj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}\nfunction mj(a,b){return null!==a&&(a=a.memoizedState,null===a||null!==a.dehydrated)?(b=b.memoizedState,null!==b&&null===b.dehydrated):!1}var nj=Math.ceil,oj=ra.ReactCurrentDispatcher,pj=ra.ReactCurrentOwner,X=0,U=null,Y=null,W=0,qj=0,rj=Bf(0),V=0,sj=null,tj=0,Dg=0,Hi=0,uj=0,vj=null,jj=0,Ji=Infinity;function wj(){Ji=O()+500}var Z=null,Qi=!1,Ri=null,Ti=null,xj=!1,yj=null,zj=90,Aj=[],Bj=[],Cj=null,Dj=0,Ej=null,Fj=-1,Gj=0,Hj=0,Ij=null,Jj=!1;function Hg(){return 0!==(X&48)?O():-1!==Fj?Fj:Fj=O()}\nfunction Ig(a){a=a.mode;if(0===(a&2))return 1;if(0===(a&4))return 99===eg()?1:2;0===Gj&&(Gj=tj);if(0!==kg.transition){0!==Hj&&(Hj=null!==vj?vj.pendingLanes:0);a=Gj;var b=4186112&~Hj;b&=-b;0===b&&(a=4186112&~a,b=a&-a,0===b&&(b=8192));return b}a=eg();0!==(X&4)&&98===a?a=Xc(12,Gj):(a=Sc(a),a=Xc(a,Gj));return a}\nfunction Jg(a,b,c){if(50<Dj)throw Dj=0,Ej=null,Error(y(185));a=Kj(a,b);if(null===a)return null;$c(a,b,c);a===U&&(Hi|=b,4===V&&Ii(a,W));var d=eg();1===b?0!==(X&8)&&0===(X&48)?Lj(a):(Mj(a,c),0===X&&(wj(),ig())):(0===(X&4)||98!==d&&99!==d||(null===Cj?Cj=new Set([a]):Cj.add(a)),Mj(a,c));vj=a}function Kj(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}\nfunction Mj(a,b){for(var c=a.callbackNode,d=a.suspendedLanes,e=a.pingedLanes,f=a.expirationTimes,g=a.pendingLanes;0<g;){var h=31-Vc(g),k=1<<h,l=f[h];if(-1===l){if(0===(k&d)||0!==(k&e)){l=b;Rc(k);var n=F;f[h]=10<=n?l+250:6<=n?l+5E3:-1}}else l<=b&&(a.expiredLanes|=k);g&=~k}d=Uc(a,a===U?W:0);b=F;if(0===d)null!==c&&(c!==Zf&&Pf(c),a.callbackNode=null,a.callbackPriority=0);else{if(null!==c){if(a.callbackPriority===b)return;c!==Zf&&Pf(c)}15===b?(c=Lj.bind(null,a),null===ag?(ag=[c],bg=Of(Uf,jg)):ag.push(c),\nc=Zf):14===b?c=hg(99,Lj.bind(null,a)):(c=Tc(b),c=hg(c,Nj.bind(null,a)));a.callbackPriority=b;a.callbackNode=c}}\nfunction Nj(a){Fj=-1;Hj=Gj=0;if(0!==(X&48))throw Error(y(327));var b=a.callbackNode;if(Oj()&&a.callbackNode!==b)return null;var c=Uc(a,a===U?W:0);if(0===c)return null;var d=c;var e=X;X|=16;var f=Pj();if(U!==a||W!==d)wj(),Qj(a,d);do try{Rj();break}catch(h){Sj(a,h)}while(1);qg();oj.current=f;X=e;null!==Y?d=0:(U=null,W=0,d=V);if(0!==(tj&Hi))Qj(a,0);else if(0!==d){2===d&&(X|=64,a.hydrate&&(a.hydrate=!1,qf(a.containerInfo)),c=Wc(a),0!==c&&(d=Tj(a,c)));if(1===d)throw b=sj,Qj(a,0),Ii(a,c),Mj(a,O()),b;a.finishedWork=\na.current.alternate;a.finishedLanes=c;switch(d){case 0:case 1:throw Error(y(345));case 2:Uj(a);break;case 3:Ii(a,c);if((c&62914560)===c&&(d=jj+500-O(),10<d)){if(0!==Uc(a,0))break;e=a.suspendedLanes;if((e&c)!==c){Hg();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=of(Uj.bind(null,a),d);break}Uj(a);break;case 4:Ii(a,c);if((c&4186112)===c)break;d=a.eventTimes;for(e=-1;0<c;){var g=31-Vc(c);f=1<<g;g=d[g];g>e&&(e=g);c&=~f}c=e;c=O()-c;c=(120>c?120:480>c?480:1080>c?1080:1920>c?1920:3E3>c?3E3:4320>\nc?4320:1960*nj(c/1960))-c;if(10<c){a.timeoutHandle=of(Uj.bind(null,a),c);break}Uj(a);break;case 5:Uj(a);break;default:throw Error(y(329));}}Mj(a,O());return a.callbackNode===b?Nj.bind(null,a):null}function Ii(a,b){b&=~uj;b&=~Hi;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-Vc(b),d=1<<c;a[c]=-1;b&=~d}}\nfunction Lj(a){if(0!==(X&48))throw Error(y(327));Oj();if(a===U&&0!==(a.expiredLanes&W)){var b=W;var c=Tj(a,b);0!==(tj&Hi)&&(b=Uc(a,b),c=Tj(a,b))}else b=Uc(a,0),c=Tj(a,b);0!==a.tag&&2===c&&(X|=64,a.hydrate&&(a.hydrate=!1,qf(a.containerInfo)),b=Wc(a),0!==b&&(c=Tj(a,b)));if(1===c)throw c=sj,Qj(a,0),Ii(a,b),Mj(a,O()),c;a.finishedWork=a.current.alternate;a.finishedLanes=b;Uj(a);Mj(a,O());return null}\nfunction Vj(){if(null!==Cj){var a=Cj;Cj=null;a.forEach(function(a){a.expiredLanes|=24&a.pendingLanes;Mj(a,O())})}ig()}function Wj(a,b){var c=X;X|=1;try{return a(b)}finally{X=c,0===X&&(wj(),ig())}}function Xj(a,b){var c=X;X&=-2;X|=8;try{return a(b)}finally{X=c,0===X&&(wj(),ig())}}function ni(a,b){I(rj,qj);qj|=b;tj|=b}function Ki(){qj=rj.current;H(rj)}\nfunction Qj(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,pf(c));if(null!==Y)for(c=Y.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&Gf();break;case 3:fh();H(N);H(M);uh();break;case 5:hh(d);break;case 4:fh();break;case 13:H(P);break;case 19:H(P);break;case 10:rg(d);break;case 23:case 24:Ki()}c=c.return}U=a;Y=Tg(a.current,null);W=qj=tj=b;V=0;sj=null;uj=Hi=Dg=0}\nfunction Sj(a,b){do{var c=Y;try{qg();vh.current=Gh;if(yh){for(var d=R.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}yh=!1}xh=0;T=S=R=null;zh=!1;pj.current=null;if(null===c||null===c.return){V=1;sj=b;Y=null;break}a:{var f=a,g=c.return,h=c,k=b;b=W;h.flags|=2048;h.firstEffect=h.lastEffect=null;if(null!==k&&\"object\"===typeof k&&\"function\"===typeof k.then){var l=k;if(0===(h.mode&2)){var n=h.alternate;n?(h.updateQueue=n.updateQueue,h.memoizedState=n.memoizedState,h.lanes=n.lanes):\n(h.updateQueue=null,h.memoizedState=null)}var A=0!==(P.current&1),p=g;do{var C;if(C=13===p.tag){var x=p.memoizedState;if(null!==x)C=null!==x.dehydrated?!0:!1;else{var w=p.memoizedProps;C=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:A?!1:!0}}if(C){var z=p.updateQueue;if(null===z){var u=new Set;u.add(l);p.updateQueue=u}else z.add(l);if(0===(p.mode&2)){p.flags|=64;h.flags|=16384;h.flags&=-2981;if(1===h.tag)if(null===h.alternate)h.tag=17;else{var t=zg(-1,1);t.tag=2;Ag(h,t)}h.lanes|=1;break a}k=\nvoid 0;h=b;var q=f.pingCache;null===q?(q=f.pingCache=new Oi,k=new Set,q.set(l,k)):(k=q.get(l),void 0===k&&(k=new Set,q.set(l,k)));if(!k.has(h)){k.add(h);var v=Yj.bind(null,f,l,h);l.then(v,v)}p.flags|=4096;p.lanes=b;break a}p=p.return}while(null!==p);k=Error((Ra(h.type)||\"A React component\")+\" suspended while rendering, but no fallback UI was specified.\\n\\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.\")}5!==V&&(V=2);k=Mi(k,h);p=\ng;do{switch(p.tag){case 3:f=k;p.flags|=4096;b&=-b;p.lanes|=b;var J=Pi(p,f,b);Bg(p,J);break a;case 1:f=k;var K=p.type,Q=p.stateNode;if(0===(p.flags&64)&&(\"function\"===typeof K.getDerivedStateFromError||null!==Q&&\"function\"===typeof Q.componentDidCatch&&(null===Ti||!Ti.has(Q)))){p.flags|=4096;b&=-b;p.lanes|=b;var L=Si(p,f,b);Bg(p,L);break a}}p=p.return}while(null!==p)}Zj(c)}catch(va){b=va;Y===c&&null!==c&&(Y=c=c.return);continue}break}while(1)}\nfunction Pj(){var a=oj.current;oj.current=Gh;return null===a?Gh:a}function Tj(a,b){var c=X;X|=16;var d=Pj();U===a&&W===b||Qj(a,b);do try{ak();break}catch(e){Sj(a,e)}while(1);qg();X=c;oj.current=d;if(null!==Y)throw Error(y(261));U=null;W=0;return V}function ak(){for(;null!==Y;)bk(Y)}function Rj(){for(;null!==Y&&!Qf();)bk(Y)}function bk(a){var b=ck(a.alternate,a,qj);a.memoizedProps=a.pendingProps;null===b?Zj(a):Y=b;pj.current=null}\nfunction Zj(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&2048)){c=Gi(c,b,qj);if(null!==c){Y=c;return}c=b;if(24!==c.tag&&23!==c.tag||null===c.memoizedState||0!==(qj&1073741824)||0===(c.mode&4)){for(var d=0,e=c.child;null!==e;)d|=e.lanes|e.childLanes,e=e.sibling;c.childLanes=d}null!==a&&0===(a.flags&2048)&&(null===a.firstEffect&&(a.firstEffect=b.firstEffect),null!==b.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=b.firstEffect),a.lastEffect=b.lastEffect),1<b.flags&&(null!==\na.lastEffect?a.lastEffect.nextEffect=b:a.firstEffect=b,a.lastEffect=b))}else{c=Li(b);if(null!==c){c.flags&=2047;Y=c;return}null!==a&&(a.firstEffect=a.lastEffect=null,a.flags|=2048)}b=b.sibling;if(null!==b){Y=b;return}Y=b=a}while(null!==b);0===V&&(V=5)}function Uj(a){var b=eg();gg(99,dk.bind(null,a,b));return null}\nfunction dk(a,b){do Oj();while(null!==yj);if(0!==(X&48))throw Error(y(327));var c=a.finishedWork;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(y(177));a.callbackNode=null;var d=c.lanes|c.childLanes,e=d,f=a.pendingLanes&~e;a.pendingLanes=e;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=e;a.mutableReadLanes&=e;a.entangledLanes&=e;e=a.entanglements;for(var g=a.eventTimes,h=a.expirationTimes;0<f;){var k=31-Vc(f),l=1<<k;e[k]=0;g[k]=-1;h[k]=-1;f&=~l}null!==\nCj&&0===(d&24)&&Cj.has(a)&&Cj.delete(a);a===U&&(Y=U=null,W=0);1<c.flags?null!==c.lastEffect?(c.lastEffect.nextEffect=c,d=c.firstEffect):d=c:d=c.firstEffect;if(null!==d){e=X;X|=32;pj.current=null;kf=fd;g=Ne();if(Oe(g)){if(\"selectionStart\"in g)h={start:g.selectionStart,end:g.selectionEnd};else a:if(h=(h=g.ownerDocument)&&h.defaultView||window,(l=h.getSelection&&h.getSelection())&&0!==l.rangeCount){h=l.anchorNode;f=l.anchorOffset;k=l.focusNode;l=l.focusOffset;try{h.nodeType,k.nodeType}catch(va){h=null;\nbreak a}var n=0,A=-1,p=-1,C=0,x=0,w=g,z=null;b:for(;;){for(var u;;){w!==h||0!==f&&3!==w.nodeType||(A=n+f);w!==k||0!==l&&3!==w.nodeType||(p=n+l);3===w.nodeType&&(n+=w.nodeValue.length);if(null===(u=w.firstChild))break;z=w;w=u}for(;;){if(w===g)break b;z===h&&++C===f&&(A=n);z===k&&++x===l&&(p=n);if(null!==(u=w.nextSibling))break;w=z;z=w.parentNode}w=u}h=-1===A||-1===p?null:{start:A,end:p}}else h=null;h=h||{start:0,end:0}}else h=null;lf={focusedElem:g,selectionRange:h};fd=!1;Ij=null;Jj=!1;Z=d;do try{ek()}catch(va){if(null===\nZ)throw Error(y(330));Wi(Z,va);Z=Z.nextEffect}while(null!==Z);Ij=null;Z=d;do try{for(g=a;null!==Z;){var t=Z.flags;t&16&&pb(Z.stateNode,\"\");if(t&128){var q=Z.alternate;if(null!==q){var v=q.ref;null!==v&&(\"function\"===typeof v?v(null):v.current=null)}}switch(t&1038){case 2:fj(Z);Z.flags&=-3;break;case 6:fj(Z);Z.flags&=-3;ij(Z.alternate,Z);break;case 1024:Z.flags&=-1025;break;case 1028:Z.flags&=-1025;ij(Z.alternate,Z);break;case 4:ij(Z.alternate,Z);break;case 8:h=Z;cj(g,h);var J=h.alternate;dj(h);null!==\nJ&&dj(J)}Z=Z.nextEffect}}catch(va){if(null===Z)throw Error(y(330));Wi(Z,va);Z=Z.nextEffect}while(null!==Z);v=lf;q=Ne();t=v.focusedElem;g=v.selectionRange;if(q!==t&&t&&t.ownerDocument&&Me(t.ownerDocument.documentElement,t)){null!==g&&Oe(t)&&(q=g.start,v=g.end,void 0===v&&(v=q),\"selectionStart\"in t?(t.selectionStart=q,t.selectionEnd=Math.min(v,t.value.length)):(v=(q=t.ownerDocument||document)&&q.defaultView||window,v.getSelection&&(v=v.getSelection(),h=t.textContent.length,J=Math.min(g.start,h),g=void 0===\ng.end?J:Math.min(g.end,h),!v.extend&&J>g&&(h=g,g=J,J=h),h=Le(t,J),f=Le(t,g),h&&f&&(1!==v.rangeCount||v.anchorNode!==h.node||v.anchorOffset!==h.offset||v.focusNode!==f.node||v.focusOffset!==f.offset)&&(q=q.createRange(),q.setStart(h.node,h.offset),v.removeAllRanges(),J>g?(v.addRange(q),v.extend(f.node,f.offset)):(q.setEnd(f.node,f.offset),v.addRange(q))))));q=[];for(v=t;v=v.parentNode;)1===v.nodeType&&q.push({element:v,left:v.scrollLeft,top:v.scrollTop});\"function\"===typeof t.focus&&t.focus();for(t=\n0;t<q.length;t++)v=q[t],v.element.scrollLeft=v.left,v.element.scrollTop=v.top}fd=!!kf;lf=kf=null;a.current=c;Z=d;do try{for(t=a;null!==Z;){var K=Z.flags;K&36&&Yi(t,Z.alternate,Z);if(K&128){q=void 0;var Q=Z.ref;if(null!==Q){var L=Z.stateNode;switch(Z.tag){case 5:q=L;break;default:q=L}\"function\"===typeof Q?Q(q):Q.current=q}}Z=Z.nextEffect}}catch(va){if(null===Z)throw Error(y(330));Wi(Z,va);Z=Z.nextEffect}while(null!==Z);Z=null;$f();X=e}else a.current=c;if(xj)xj=!1,yj=a,zj=b;else for(Z=d;null!==Z;)b=\nZ.nextEffect,Z.nextEffect=null,Z.flags&8&&(K=Z,K.sibling=null,K.stateNode=null),Z=b;d=a.pendingLanes;0===d&&(Ti=null);1===d?a===Ej?Dj++:(Dj=0,Ej=a):Dj=0;c=c.stateNode;if(Mf&&\"function\"===typeof Mf.onCommitFiberRoot)try{Mf.onCommitFiberRoot(Lf,c,void 0,64===(c.current.flags&64))}catch(va){}Mj(a,O());if(Qi)throw Qi=!1,a=Ri,Ri=null,a;if(0!==(X&8))return null;ig();return null}\nfunction ek(){for(;null!==Z;){var a=Z.alternate;Jj||null===Ij||(0!==(Z.flags&8)?dc(Z,Ij)&&(Jj=!0):13===Z.tag&&mj(a,Z)&&dc(Z,Ij)&&(Jj=!0));var b=Z.flags;0!==(b&256)&&Xi(a,Z);0===(b&512)||xj||(xj=!0,hg(97,function(){Oj();return null}));Z=Z.nextEffect}}function Oj(){if(90!==zj){var a=97<zj?97:zj;zj=90;return gg(a,fk)}return!1}function $i(a,b){Aj.push(b,a);xj||(xj=!0,hg(97,function(){Oj();return null}))}function Zi(a,b){Bj.push(b,a);xj||(xj=!0,hg(97,function(){Oj();return null}))}\nfunction fk(){if(null===yj)return!1;var a=yj;yj=null;if(0!==(X&48))throw Error(y(331));var b=X;X|=32;var c=Bj;Bj=[];for(var d=0;d<c.length;d+=2){var e=c[d],f=c[d+1],g=e.destroy;e.destroy=void 0;if(\"function\"===typeof g)try{g()}catch(k){if(null===f)throw Error(y(330));Wi(f,k)}}c=Aj;Aj=[];for(d=0;d<c.length;d+=2){e=c[d];f=c[d+1];try{var h=e.create;e.destroy=h()}catch(k){if(null===f)throw Error(y(330));Wi(f,k)}}for(h=a.current.firstEffect;null!==h;)a=h.nextEffect,h.nextEffect=null,h.flags&8&&(h.sibling=\nnull,h.stateNode=null),h=a;X=b;ig();return!0}function gk(a,b,c){b=Mi(c,b);b=Pi(a,b,1);Ag(a,b);b=Hg();a=Kj(a,1);null!==a&&($c(a,1,b),Mj(a,b))}\nfunction Wi(a,b){if(3===a.tag)gk(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){gk(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if(\"function\"===typeof c.type.getDerivedStateFromError||\"function\"===typeof d.componentDidCatch&&(null===Ti||!Ti.has(d))){a=Mi(b,a);var e=Si(c,a,1);Ag(c,e);e=Hg();c=Kj(c,1);if(null!==c)$c(c,1,e),Mj(c,e);else if(\"function\"===typeof d.componentDidCatch&&(null===Ti||!Ti.has(d)))try{d.componentDidCatch(b,a)}catch(f){}break}}c=c.return}}\nfunction Yj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=Hg();a.pingedLanes|=a.suspendedLanes&c;U===a&&(W&c)===c&&(4===V||3===V&&(W&62914560)===W&&500>O()-jj?Qj(a,0):uj|=c);Mj(a,b)}function lj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=a.mode,0===(b&2)?b=1:0===(b&4)?b=99===eg()?1:2:(0===Gj&&(Gj=tj),b=Yc(62914560&~Gj),0===b&&(b=4194304)));c=Hg();a=Kj(a,b);null!==a&&($c(a,b,c),Mj(a,c))}var ck;\nck=function(a,b,c){var d=b.lanes;if(null!==a)if(a.memoizedProps!==b.pendingProps||N.current)ug=!0;else if(0!==(c&d))ug=0!==(a.flags&16384)?!0:!1;else{ug=!1;switch(b.tag){case 3:ri(b);sh();break;case 5:gh(b);break;case 1:Ff(b.type)&&Jf(b);break;case 4:eh(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;var e=b.type._context;I(mg,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){if(0!==(c&b.child.childLanes))return ti(a,b,c);I(P,P.current&1);b=hi(a,b,c);return null!==\nb?b.sibling:null}I(P,P.current&1);break;case 19:d=0!==(c&b.childLanes);if(0!==(a.flags&64)){if(d)return Ai(a,b,c);b.flags|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);I(P,P.current);if(d)break;else return null;case 23:case 24:return b.lanes=0,mi(a,b,c)}return hi(a,b,c)}else ug=!1;b.lanes=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);a=b.pendingProps;e=Ef(b,M.current);tg(b,c);e=Ch(null,b,d,a,e,c);b.flags|=1;if(\"object\"===\ntypeof e&&null!==e&&\"function\"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(Ff(d)){var f=!0;Jf(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;xg(b);var g=d.getDerivedStateFromProps;\"function\"===typeof g&&Gg(b,d,g,a);e.updater=Kg;b.stateNode=e;e._reactInternals=b;Og(b,d,a,c);b=qi(null,b,d,!0,f,c)}else b.tag=0,fi(null,b,e,c),b=b.child;return b;case 16:e=b.elementType;a:{null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);\na=b.pendingProps;f=e._init;e=f(e._payload);b.type=e;f=b.tag=hk(e);a=lg(e,a);switch(f){case 0:b=li(null,b,e,a,c);break a;case 1:b=pi(null,b,e,a,c);break a;case 11:b=gi(null,b,e,a,c);break a;case 14:b=ii(null,b,e,lg(e.type,a),d,c);break a}throw Error(y(306,e,\"\"));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),li(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),pi(a,b,d,e,c);case 3:ri(b);d=b.updateQueue;if(null===a||null===d)throw Error(y(282));\nd=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;yg(a,b);Cg(b,d,null,c);d=b.memoizedState.element;if(d===e)sh(),b=hi(a,b,c);else{e=b.stateNode;if(f=e.hydrate)kh=rf(b.stateNode.containerInfo.firstChild),jh=b,f=lh=!0;if(f){a=e.mutableSourceEagerHydrationData;if(null!=a)for(e=0;e<a.length;e+=2)f=a[e],f._workInProgressVersionPrimary=a[e+1],th.push(f);c=Zg(b,null,d,c);for(b.child=c;c;)c.flags=c.flags&-3|1024,c=c.sibling}else fi(a,b,d,c),sh();b=b.child}return b;case 5:return gh(b),null===a&&\nph(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,nf(d,e)?g=null:null!==f&&nf(d,f)&&(b.flags|=16),oi(a,b),fi(a,b,g,c),b.child;case 6:return null===a&&ph(b),null;case 13:return ti(a,b,c);case 4:return eh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Yg(b,null,d,c):fi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),gi(a,b,d,e,c);case 7:return fi(a,b,b.pendingProps,c),b.child;case 8:return fi(a,b,b.pendingProps.children,\nc),b.child;case 12:return fi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;I(mg,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=He(h,f)?0:(\"function\"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!N.current){b=hi(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var k=h.dependencies;if(null!==k){g=h.child;for(var l=\nk.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=zg(-1,c&-c),l.tag=2,Ag(h,l));h.lanes|=c;l=h.alternate;null!==l&&(l.lanes|=c);sg(h.return,c);k.lanes|=c;break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=g}fi(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,tg(b,c),e=vg(e,\nf.unstable_observedBits),d=d(e),b.flags|=1,fi(a,b,d,c),b.child;case 14:return e=b.type,f=lg(e,b.pendingProps),f=lg(e.type,f),ii(a,b,e,f,d,c);case 15:return ki(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2),b.tag=1,Ff(d)?(a=!0,Jf(b)):a=!1,tg(b,c),Mg(b,d,e),Og(b,d,e,c),qi(null,b,d,!0,a,c);case 19:return Ai(a,b,c);case 23:return mi(a,b,c);case 24:return mi(a,b,c)}throw Error(y(156,b.tag));\n};function ik(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.flags=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childLanes=this.lanes=0;this.alternate=null}function nh(a,b,c,d){return new ik(a,b,c,d)}function ji(a){a=a.prototype;return!(!a||!a.isReactComponent)}\nfunction hk(a){if(\"function\"===typeof a)return ji(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Aa)return 11;if(a===Da)return 14}return 2}\nfunction Tg(a,b){var c=a.alternate;null===c?(c=nh(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};\nc.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}\nfunction Vg(a,b,c,d,e,f){var g=2;d=a;if(\"function\"===typeof a)ji(a)&&(g=1);else if(\"string\"===typeof a)g=5;else a:switch(a){case ua:return Xg(c.children,e,f,b);case Ha:g=8;e|=16;break;case wa:g=8;e|=1;break;case xa:return a=nh(12,c,b,e|8),a.elementType=xa,a.type=xa,a.lanes=f,a;case Ba:return a=nh(13,c,b,e),a.type=Ba,a.elementType=Ba,a.lanes=f,a;case Ca:return a=nh(19,c,b,e),a.elementType=Ca,a.lanes=f,a;case Ia:return vi(c,e,f,b);case Ja:return a=nh(24,c,b,e),a.elementType=Ja,a.lanes=f,a;default:if(\"object\"===\ntypeof a&&null!==a)switch(a.$$typeof){case ya:g=10;break a;case za:g=9;break a;case Aa:g=11;break a;case Da:g=14;break a;case Ea:g=16;d=null;break a;case Fa:g=22;break a}throw Error(y(130,null==a?a:typeof a,\"\"));}b=nh(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Xg(a,b,c,d){a=nh(7,a,d,b);a.lanes=c;return a}function vi(a,b,c,d){a=nh(23,a,d,b);a.elementType=Ia;a.lanes=c;return a}function Ug(a,b,c){a=nh(6,a,null,b);a.lanes=c;return a}\nfunction Wg(a,b,c){b=nh(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}\nfunction jk(a,b,c){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=0;this.eventTimes=Zc(0);this.expirationTimes=Zc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=Zc(0);this.mutableSourceEagerHydrationData=null}\nfunction kk(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:ta,key:null==d?null:\"\"+d,children:a,containerInfo:b,implementation:c}}\nfunction lk(a,b,c,d){var e=b.current,f=Hg(),g=Ig(e);a:if(c){c=c._reactInternals;b:{if(Zb(c)!==c||1!==c.tag)throw Error(y(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(Ff(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(y(171));}if(1===c.tag){var k=c.type;if(Ff(k)){c=If(c,k,h);break a}}c=h}else c=Cf;null===b.context?b.context=c:b.pendingContext=c;b=zg(f,g);b.payload={element:a};d=void 0===d?null:d;null!==\nd&&(b.callback=d);Ag(e,b);Jg(e,g,f);return g}function mk(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function nk(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function ok(a,b){nk(a,b);(a=a.alternate)&&nk(a,b)}function pk(){return null}\nfunction qk(a,b,c){var d=null!=c&&null!=c.hydrationOptions&&c.hydrationOptions.mutableSources||null;c=new jk(a,b,null!=c&&!0===c.hydrate);b=nh(3,null,null,2===b?7:1===b?3:0);c.current=b;b.stateNode=c;xg(b);a[ff]=c.current;cf(8===a.nodeType?a.parentNode:a);if(d)for(a=0;a<d.length;a++){b=d[a];var e=b._getVersion;e=e(b._source);null==c.mutableSourceEagerHydrationData?c.mutableSourceEagerHydrationData=[b,e]:c.mutableSourceEagerHydrationData.push(b,e)}this._internalRoot=c}\nqk.prototype.render=function(a){lk(a,this._internalRoot,null,null)};qk.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;lk(null,a,null,function(){b[ff]=null})};function rk(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||\" react-mount-point-unstable \"!==a.nodeValue))}\nfunction sk(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute(\"data-reactroot\")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new qk(a,0,b?{hydrate:!0}:void 0)}\nfunction tk(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;if(\"function\"===typeof e){var h=e;e=function(){var a=mk(g);h.call(a)}}lk(b,g,a,e)}else{f=c._reactRootContainer=sk(c,d);g=f._internalRoot;if(\"function\"===typeof e){var k=e;e=function(){var a=mk(g);k.call(a)}}Xj(function(){lk(b,g,a,e)})}return mk(g)}ec=function(a){if(13===a.tag){var b=Hg();Jg(a,4,b);ok(a,4)}};fc=function(a){if(13===a.tag){var b=Hg();Jg(a,67108864,b);ok(a,67108864)}};\ngc=function(a){if(13===a.tag){var b=Hg(),c=Ig(a);Jg(a,c,b);ok(a,c)}};hc=function(a,b){return b()};\nyb=function(a,b,c){switch(b){case \"input\":ab(a,c);b=c.name;if(\"radio\"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll(\"input[name=\"+JSON.stringify(\"\"+b)+'][type=\"radio\"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db(d);if(!e)throw Error(y(90));Wa(d);ab(d,e)}}}break;case \"textarea\":ib(a,c);break;case \"select\":b=c.value,null!=b&&fb(a,!!c.multiple,b,!1)}};Gb=Wj;\nHb=function(a,b,c,d,e){var f=X;X|=4;try{return gg(98,a.bind(null,b,c,d,e))}finally{X=f,0===X&&(wj(),ig())}};Ib=function(){0===(X&49)&&(Vj(),Oj())};Jb=function(a,b){var c=X;X|=2;try{return a(b)}finally{X=c,0===X&&(wj(),ig())}};function uk(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!rk(b))throw Error(y(200));return kk(a,b,null,c)}var vk={Events:[Cb,ue,Db,Eb,Fb,Oj,{current:!1}]},wk={findFiberByHostInstance:wc,bundleType:0,version:\"17.0.2\",rendererPackageName:\"react-dom\"};\nvar xk={bundleType:wk.bundleType,version:wk.version,rendererPackageName:wk.rendererPackageName,rendererConfig:wk.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ra.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=cc(a);return null===a?null:a.stateNode},findFiberByHostInstance:wk.findFiberByHostInstance||\npk,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null};if(\"undefined\"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var yk=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!yk.isDisabled&&yk.supportsFiber)try{Lf=yk.inject(xk),Mf=yk}catch(a){}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=vk;exports.createPortal=uk;\nexports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if(\"function\"===typeof a.render)throw Error(y(188));throw Error(y(268,Object.keys(a)));}a=cc(b);a=null===a?null:a.stateNode;return a};exports.flushSync=function(a,b){var c=X;if(0!==(c&48))return a(b);X|=1;try{if(a)return gg(99,a.bind(null,b))}finally{X=c,ig()}};exports.hydrate=function(a,b,c){if(!rk(b))throw Error(y(200));return tk(null,a,b,!0,c)};\nexports.render=function(a,b,c){if(!rk(b))throw Error(y(200));return tk(null,a,b,!1,c)};exports.unmountComponentAtNode=function(a){if(!rk(a))throw Error(y(40));return a._reactRootContainer?(Xj(function(){tk(null,null,a,!1,function(){a._reactRootContainer=null;a[ff]=null})}),!0):!1};exports.unstable_batchedUpdates=Wj;exports.unstable_createPortal=function(a,b){return uk(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};\nexports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!rk(c))throw Error(y(200));if(null==a||void 0===a._reactInternals)throw Error(y(38));return tk(a,b,c,!1,d)};exports.version=\"17.0.2\";\n","'use strict';\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (process.env.NODE_ENV === 'production') {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = require('./cjs/react-dom.production.min.js');\n} else {\n  module.exports = require('./cjs/react-dom.development.js');\n}\n","/** @license React v17.0.2\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';require(\"object-assign\");var f=require(\"react\"),g=60103;exports.Fragment=60107;if(\"function\"===typeof Symbol&&Symbol.for){var h=Symbol.for;g=h(\"react.element\");exports.Fragment=h(\"react.fragment\")}var m=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,n=Object.prototype.hasOwnProperty,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,k){var b,d={},e=null,l=null;void 0!==k&&(e=\"\"+k);void 0!==a.key&&(e=\"\"+a.key);void 0!==a.ref&&(l=a.ref);for(b in a)n.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:g,type:c,key:e,ref:l,props:d,_owner:m.current}}exports.jsx=q;exports.jsxs=q;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.min.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","import * as jsxRuntime from \"/home/runner/work/api.stream-studio-kit/api.stream-studio-kit/examples/studio-kit-demo/node_modules/react/jsx-runtime.js\"\nexport const jsx = jsxRuntime.jsx\nexport const jsxs = jsxRuntime.jsxs\nexport const Fragment = jsxRuntime.Fragment","var qr = Object.defineProperty;\nvar Gr = (a, u, c) => u in a ? qr(a, u, { enumerable: !0, configurable: !0, writable: !0, value: c }) : a[u] = c;\nvar ht = (a, u, c) => (Gr(a, typeof u != \"symbol\" ? u + \"\" : u, c), c);\nimport ReactDOM from \"react-dom\";\nimport React, { useRef, useState, useEffect, useLayoutEffect, useContext, useMemo } from \"react\";\nlet currentSubId = 0;\nconst subscribers = /* @__PURE__ */ new Map(), subscribersInternal = /* @__PURE__ */ new Map();\nfunction createSubscribe(a = {}) {\n  return function(u) {\n    if (typeof u != \"function\")\n      return;\n    const c = a.internal ? subscribersInternal : subscribers, l = ++currentSubId;\n    return c.set(l, u), () => {\n      c.delete(l);\n    };\n  };\n}\nfunction createOn(a = {}) {\n  return function(u, c) {\n    return (a.internal ? subscribeInternal : subscribe)((v, S) => {\n      if (u === v)\n        return c(S);\n    });\n  };\n}\nfunction createTrigger(a = {}) {\n  const u = a.internal ? subscribersInternal : subscribers;\n  return async function(c, ...l) {\n    let v = {\n      type: c,\n      payload: l[0]\n    };\n    const S = a.internal ? \"Internal\" : \"External\";\n    log$1.info(`${S} Event:`, v), await Promise.all(Array.from(u.values()).map((g) => g(v.type, v.payload)));\n  };\n}\nconst trigger$1 = createTrigger(), subscribe = createSubscribe(), on = createOn(), triggerInternal$1 = createTrigger({\n  internal: !0\n}), subscribeInternal = createSubscribe({\n  internal: !0\n}), onInternal = createOn({\n  internal: !0\n}), events$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  on,\n  onInternal,\n  subscribe,\n  subscribeInternal,\n  trigger: trigger$1,\n  triggerInternal: triggerInternal$1\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar commonjsGlobal$1 = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction getDefaultExportFromCjs$1(a) {\n  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, \"default\") ? a.default : a;\n}\nfunction getAugmentedNamespace(a) {\n  if (a.__esModule)\n    return a;\n  var u = a.default;\n  if (typeof u == \"function\") {\n    var c = function l() {\n      return this instanceof l ? Reflect.construct(u, arguments, this.constructor) : u.apply(this, arguments);\n    };\n    c.prototype = u.prototype;\n  } else\n    c = {};\n  return Object.defineProperty(c, \"__esModule\", { value: !0 }), Object.keys(a).forEach(function(l) {\n    var v = Object.getOwnPropertyDescriptor(a, l);\n    Object.defineProperty(c, l, v.get ? v : {\n      enumerable: !0,\n      get: function() {\n        return a[l];\n      }\n    });\n  }), c;\n}\nvar loglevel$1 = { exports: {} };\n(function(a) {\n  (function(u, c) {\n    a.exports ? a.exports = c() : u.log = c();\n  })(commonjsGlobal$1, function() {\n    var u = function() {\n    }, c = \"undefined\", l = typeof window !== c && typeof window.navigator !== c && /Trident\\/|MSIE /.test(window.navigator.userAgent), v = [\n      \"trace\",\n      \"debug\",\n      \"info\",\n      \"warn\",\n      \"error\"\n    ], S = {}, g = null;\n    function E(q, G) {\n      var H = q[G];\n      if (typeof H.bind == \"function\")\n        return H.bind(q);\n      try {\n        return Function.prototype.bind.call(H, q);\n      } catch {\n        return function() {\n          return Function.prototype.apply.apply(H, [q, arguments]);\n        };\n      }\n    }\n    function _() {\n      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();\n    }\n    function k(q) {\n      return q === \"debug\" && (q = \"log\"), typeof console === c ? !1 : q === \"trace\" && l ? _ : console[q] !== void 0 ? E(console, q) : console.log !== void 0 ? E(console, \"log\") : u;\n    }\n    function L() {\n      for (var q = this.getLevel(), G = 0; G < v.length; G++) {\n        var H = v[G];\n        this[H] = G < q ? u : this.methodFactory(H, q, this.name);\n      }\n      if (this.log = this.debug, typeof console === c && q < this.levels.SILENT)\n        return \"No console available for logging\";\n    }\n    function M(q) {\n      return function() {\n        typeof console !== c && (L.call(this), this[q].apply(this, arguments));\n      };\n    }\n    function $(q, G, H) {\n      return k(q) || M.apply(this, arguments);\n    }\n    function J(q, G) {\n      var H = this, B, Y, ne, Z = \"loglevel\";\n      typeof q == \"string\" ? Z += \":\" + q : typeof q == \"symbol\" && (Z = void 0);\n      function re(D) {\n        var W = (v[D] || \"silent\").toUpperCase();\n        if (!(typeof window === c || !Z)) {\n          try {\n            window.localStorage[Z] = W;\n            return;\n          } catch {\n          }\n          try {\n            window.document.cookie = encodeURIComponent(Z) + \"=\" + W + \";\";\n          } catch {\n          }\n        }\n      }\n      function oe() {\n        var D;\n        if (!(typeof window === c || !Z)) {\n          try {\n            D = window.localStorage[Z];\n          } catch {\n          }\n          if (typeof D === c)\n            try {\n              var W = window.document.cookie, ee = encodeURIComponent(Z), ae = W.indexOf(ee + \"=\");\n              ae !== -1 && (D = /^([^;]+)/.exec(\n                W.slice(ae + ee.length + 1)\n              )[1]);\n            } catch {\n            }\n          return H.levels[D] === void 0 && (D = void 0), D;\n        }\n      }\n      function de() {\n        if (!(typeof window === c || !Z)) {\n          try {\n            window.localStorage.removeItem(Z);\n          } catch {\n          }\n          try {\n            window.document.cookie = encodeURIComponent(Z) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch {\n          }\n        }\n      }\n      function A(D) {\n        var W = D;\n        if (typeof W == \"string\" && H.levels[W.toUpperCase()] !== void 0 && (W = H.levels[W.toUpperCase()]), typeof W == \"number\" && W >= 0 && W <= H.levels.SILENT)\n          return W;\n        throw new TypeError(\"log.setLevel() called with invalid level: \" + D);\n      }\n      H.name = q, H.levels = {\n        TRACE: 0,\n        DEBUG: 1,\n        INFO: 2,\n        WARN: 3,\n        ERROR: 4,\n        SILENT: 5\n      }, H.methodFactory = G || $, H.getLevel = function() {\n        return ne ?? Y ?? B;\n      }, H.setLevel = function(D, W) {\n        return ne = A(D), W !== !1 && re(ne), L.call(H);\n      }, H.setDefaultLevel = function(D) {\n        Y = A(D), oe() || H.setLevel(D, !1);\n      }, H.resetLevel = function() {\n        ne = null, de(), L.call(H);\n      }, H.enableAll = function(D) {\n        H.setLevel(H.levels.TRACE, D);\n      }, H.disableAll = function(D) {\n        H.setLevel(H.levels.SILENT, D);\n      }, H.rebuild = function() {\n        if (g !== H && (B = A(g.getLevel())), L.call(H), g === H)\n          for (var D in S)\n            S[D].rebuild();\n      }, B = A(\n        g ? g.getLevel() : \"WARN\"\n      );\n      var N = oe();\n      N != null && (ne = A(N)), L.call(H);\n    }\n    g = new J(), g.getLogger = function(G) {\n      if (typeof G != \"symbol\" && typeof G != \"string\" || G === \"\")\n        throw new TypeError(\"You must supply a name when creating a logger.\");\n      var H = S[G];\n      return H || (H = S[G] = new J(\n        G,\n        g.methodFactory\n      )), H;\n    };\n    var V = typeof window !== c ? window.log : void 0;\n    return g.noConflict = function() {\n      return typeof window !== c && window.log === g && (window.log = V), g;\n    }, g.getLoggers = function() {\n      return S;\n    }, g.default = g, g;\n  });\n})(loglevel$1);\nvar loglevelExports$1 = loglevel$1.exports;\nconst log$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(loglevelExports$1), connectionId$1 = (Math.random() * 1e20).toString(36), version$5 = \"3.0.3\", CoreContext = {\n  config: null,\n  // TODO: Rename to client\n  clients: null,\n  Request: {},\n  Command: {},\n  on,\n  subscribe,\n  /** @private @internal */\n  onInternal,\n  /** @private @internal */\n  subscribeInternal,\n  /** @private @internal */\n  trigger: trigger$1,\n  /** @private @internal */\n  triggerInternal: triggerInternal$1,\n  /** @private @internal */\n  state: {},\n  compositor: {},\n  connectionId: connectionId$1,\n  version: version$5,\n  /** @private @internal */\n  rendererVersion: version$5,\n  log: log$1,\n  logLevel: null\n}, setAppState = (a) => {\n  Object.keys(a).forEach((u) => {\n    CoreContext.state[u] = a[u];\n  });\n}, context = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  CoreContext,\n  default: CoreContext,\n  log: log$1,\n  setAppState\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar freeGlobal = typeof global == \"object\" && global && global.Object === Object && global, freeSelf = typeof self == \"object\" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function(\"return this\")(), Symbol$1 = root.Symbol, objectProto$m = Object.prototype, hasOwnProperty$f = objectProto$m.hasOwnProperty, nativeObjectToString$1 = objectProto$m.toString, symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;\nfunction getRawTag(a) {\n  var u = hasOwnProperty$f.call(a, symToStringTag$1), c = a[symToStringTag$1];\n  try {\n    a[symToStringTag$1] = void 0;\n    var l = !0;\n  } catch {\n  }\n  var v = nativeObjectToString$1.call(a);\n  return l && (u ? a[symToStringTag$1] = c : delete a[symToStringTag$1]), v;\n}\nvar objectProto$l = Object.prototype, nativeObjectToString = objectProto$l.toString;\nfunction objectToString$7(a) {\n  return nativeObjectToString.call(a);\n}\nvar nullTag = \"[object Null]\", undefinedTag = \"[object Undefined]\", symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;\nfunction baseGetTag(a) {\n  return a == null ? a === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(a) ? getRawTag(a) : objectToString$7(a);\n}\nfunction isObjectLike$7(a) {\n  return a != null && typeof a == \"object\";\n}\nvar symbolTag$6 = \"[object Symbol]\";\nfunction isSymbol$3(a) {\n  return typeof a == \"symbol\" || isObjectLike$7(a) && baseGetTag(a) == symbolTag$6;\n}\nfunction arrayMap$1(a, u) {\n  for (var c = -1, l = a == null ? 0 : a.length, v = Array(l); ++c < l; )\n    v[c] = u(a[c], c, a);\n  return v;\n}\nvar isArray$5 = Array.isArray, INFINITY$4 = 1 / 0, symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;\nfunction baseToString(a) {\n  if (typeof a == \"string\")\n    return a;\n  if (isArray$5(a))\n    return arrayMap$1(a, baseToString) + \"\";\n  if (isSymbol$3(a))\n    return symbolToString ? symbolToString.call(a) : \"\";\n  var u = a + \"\";\n  return u == \"0\" && 1 / a == -INFINITY$4 ? \"-0\" : u;\n}\nvar reWhitespace = /\\s/;\nfunction trimmedEndIndex(a) {\n  for (var u = a.length; u-- && reWhitespace.test(a.charAt(u)); )\n    ;\n  return u;\n}\nvar reTrimStart = /^\\s+/;\nfunction baseTrim(a) {\n  return a && a.slice(0, trimmedEndIndex(a) + 1).replace(reTrimStart, \"\");\n}\nfunction isObject$9(a) {\n  var u = typeof a;\n  return a != null && (u == \"object\" || u == \"function\");\n}\nvar NAN$3 = NaN, reIsBadHex$3 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$3 = /^0b[01]+$/i, reIsOctal$3 = /^0o[0-7]+$/i, freeParseInt$3 = parseInt;\nfunction toNumber$3(a) {\n  if (typeof a == \"number\")\n    return a;\n  if (isSymbol$3(a))\n    return NAN$3;\n  if (isObject$9(a)) {\n    var u = typeof a.valueOf == \"function\" ? a.valueOf() : a;\n    a = isObject$9(u) ? u + \"\" : u;\n  }\n  if (typeof a != \"string\")\n    return a === 0 ? a : +a;\n  a = baseTrim(a);\n  var c = reIsBinary$3.test(a);\n  return c || reIsOctal$3.test(a) ? freeParseInt$3(a.slice(2), c ? 2 : 8) : reIsBadHex$3.test(a) ? NAN$3 : +a;\n}\nfunction identity$1(a) {\n  return a;\n}\nvar asyncTag = \"[object AsyncFunction]\", funcTag$3 = \"[object Function]\", genTag$2 = \"[object GeneratorFunction]\", proxyTag = \"[object Proxy]\";\nfunction isFunction$4(a) {\n  if (!isObject$9(a))\n    return !1;\n  var u = baseGetTag(a);\n  return u == funcTag$3 || u == genTag$2 || u == asyncTag || u == proxyTag;\n}\nvar coreJsData = root[\"__core-js_shared__\"], maskSrcKey = function() {\n  var a = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || \"\");\n  return a ? \"Symbol(src)_1.\" + a : \"\";\n}();\nfunction isMasked(a) {\n  return !!maskSrcKey && maskSrcKey in a;\n}\nvar funcProto$3 = Function.prototype, funcToString$3 = funcProto$3.toString;\nfunction toSource(a) {\n  if (a != null) {\n    try {\n      return funcToString$3.call(a);\n    } catch {\n    }\n    try {\n      return a + \"\";\n    } catch {\n    }\n  }\n  return \"\";\n}\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g, reIsHostCtor = /^\\[object .+?Constructor\\]$/, funcProto$2 = Function.prototype, objectProto$k = Object.prototype, funcToString$2 = funcProto$2.toString, hasOwnProperty$e = objectProto$k.hasOwnProperty, reIsNative = RegExp(\n  \"^\" + funcToString$2.call(hasOwnProperty$e).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n);\nfunction baseIsNative(a) {\n  if (!isObject$9(a) || isMasked(a))\n    return !1;\n  var u = isFunction$4(a) ? reIsNative : reIsHostCtor;\n  return u.test(toSource(a));\n}\nfunction getValue(a, u) {\n  return a == null ? void 0 : a[u];\n}\nfunction getNative(a, u) {\n  var c = getValue(a, u);\n  return baseIsNative(c) ? c : void 0;\n}\nvar WeakMap$2 = getNative(root, \"WeakMap\"), objectCreate$1 = Object.create, baseCreate = /* @__PURE__ */ function() {\n  function a() {\n  }\n  return function(u) {\n    if (!isObject$9(u))\n      return {};\n    if (objectCreate$1)\n      return objectCreate$1(u);\n    a.prototype = u;\n    var c = new a();\n    return a.prototype = void 0, c;\n  };\n}();\nfunction apply(a, u, c) {\n  switch (c.length) {\n    case 0:\n      return a.call(u);\n    case 1:\n      return a.call(u, c[0]);\n    case 2:\n      return a.call(u, c[0], c[1]);\n    case 3:\n      return a.call(u, c[0], c[1], c[2]);\n  }\n  return a.apply(u, c);\n}\nfunction copyArray(a, u) {\n  var c = -1, l = a.length;\n  for (u || (u = Array(l)); ++c < l; )\n    u[c] = a[c];\n  return u;\n}\nvar HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now;\nfunction shortOut(a) {\n  var u = 0, c = 0;\n  return function() {\n    var l = nativeNow(), v = HOT_SPAN - (l - c);\n    if (c = l, v > 0) {\n      if (++u >= HOT_COUNT)\n        return arguments[0];\n    } else\n      u = 0;\n    return a.apply(void 0, arguments);\n  };\n}\nfunction constant(a) {\n  return function() {\n    return a;\n  };\n}\nvar defineProperty$1 = function() {\n  try {\n    var a = getNative(Object, \"defineProperty\");\n    return a({}, \"\", {}), a;\n  } catch {\n  }\n}(), baseSetToString = defineProperty$1 ? function(a, u) {\n  return defineProperty$1(a, \"toString\", {\n    configurable: !0,\n    enumerable: !1,\n    value: constant(u),\n    writable: !0\n  });\n} : identity$1;\nconst baseSetToString$1 = baseSetToString;\nvar setToString = shortOut(baseSetToString$1);\nfunction arrayEach(a, u) {\n  for (var c = -1, l = a == null ? 0 : a.length; ++c < l && u(a[c], c, a) !== !1; )\n    ;\n  return a;\n}\nfunction baseFindIndex$1(a, u, c, l) {\n  for (var v = a.length, S = c + (l ? 1 : -1); l ? S-- : ++S < v; )\n    if (u(a[S], S, a))\n      return S;\n  return -1;\n}\nfunction baseIsNaN$1(a) {\n  return a !== a;\n}\nfunction strictIndexOf(a, u, c) {\n  for (var l = c - 1, v = a.length; ++l < v; )\n    if (a[l] === u)\n      return l;\n  return -1;\n}\nfunction baseIndexOf$1(a, u, c) {\n  return u === u ? strictIndexOf(a, u, c) : baseFindIndex$1(a, baseIsNaN$1, c);\n}\nvar MAX_SAFE_INTEGER$2 = 9007199254740991, reIsUint$1 = /^(?:0|[1-9]\\d*)$/;\nfunction isIndex$1(a, u) {\n  var c = typeof a;\n  return u = u ?? MAX_SAFE_INTEGER$2, !!u && (c == \"number\" || c != \"symbol\" && reIsUint$1.test(a)) && a > -1 && a % 1 == 0 && a < u;\n}\nfunction baseAssignValue(a, u, c) {\n  u == \"__proto__\" && defineProperty$1 ? defineProperty$1(a, u, {\n    configurable: !0,\n    enumerable: !0,\n    value: c,\n    writable: !0\n  }) : a[u] = c;\n}\nfunction eq(a, u) {\n  return a === u || a !== a && u !== u;\n}\nvar objectProto$j = Object.prototype, hasOwnProperty$d = objectProto$j.hasOwnProperty;\nfunction assignValue(a, u, c) {\n  var l = a[u];\n  (!(hasOwnProperty$d.call(a, u) && eq(l, c)) || c === void 0 && !(u in a)) && baseAssignValue(a, u, c);\n}\nfunction copyObject(a, u, c, l) {\n  var v = !c;\n  c || (c = {});\n  for (var S = -1, g = u.length; ++S < g; ) {\n    var E = u[S], _ = l ? l(c[E], a[E], E, c, a) : void 0;\n    _ === void 0 && (_ = a[E]), v ? baseAssignValue(c, E, _) : assignValue(c, E, _);\n  }\n  return c;\n}\nvar nativeMax$2 = Math.max;\nfunction overRest(a, u, c) {\n  return u = nativeMax$2(u === void 0 ? a.length - 1 : u, 0), function() {\n    for (var l = arguments, v = -1, S = nativeMax$2(l.length - u, 0), g = Array(S); ++v < S; )\n      g[v] = l[u + v];\n    v = -1;\n    for (var E = Array(u + 1); ++v < u; )\n      E[v] = l[v];\n    return E[u] = c(g), apply(a, this, E);\n  };\n}\nfunction baseRest(a, u) {\n  return setToString(overRest(a, u, identity$1), a + \"\");\n}\nvar MAX_SAFE_INTEGER$1 = 9007199254740991;\nfunction isLength$1(a) {\n  return typeof a == \"number\" && a > -1 && a % 1 == 0 && a <= MAX_SAFE_INTEGER$1;\n}\nfunction isArrayLike$2(a) {\n  return a != null && isLength$1(a.length) && !isFunction$4(a);\n}\nfunction isIterateeCall(a, u, c) {\n  if (!isObject$9(c))\n    return !1;\n  var l = typeof u;\n  return (l == \"number\" ? isArrayLike$2(c) && isIndex$1(u, c.length) : l == \"string\" && u in c) ? eq(c[u], a) : !1;\n}\nvar objectProto$i = Object.prototype;\nfunction isPrototype$1(a) {\n  var u = a && a.constructor, c = typeof u == \"function\" && u.prototype || objectProto$i;\n  return a === c;\n}\nfunction baseTimes$1(a, u) {\n  for (var c = -1, l = Array(a); ++c < a; )\n    l[c] = u(c);\n  return l;\n}\nvar argsTag$4 = \"[object Arguments]\";\nfunction baseIsArguments(a) {\n  return isObjectLike$7(a) && baseGetTag(a) == argsTag$4;\n}\nvar objectProto$h = Object.prototype, hasOwnProperty$c = objectProto$h.hasOwnProperty, propertyIsEnumerable$2 = objectProto$h.propertyIsEnumerable, isArguments$1 = baseIsArguments(/* @__PURE__ */ function() {\n  return arguments;\n}()) ? baseIsArguments : function(a) {\n  return isObjectLike$7(a) && hasOwnProperty$c.call(a, \"callee\") && !propertyIsEnumerable$2.call(a, \"callee\");\n};\nfunction stubFalse() {\n  return !1;\n}\nvar freeExports$2 = typeof exports == \"object\" && exports && !exports.nodeType && exports, freeModule$2 = freeExports$2 && typeof module == \"object\" && module && !module.nodeType && module, moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2, Buffer$9 = moduleExports$2 ? root.Buffer : void 0, nativeIsBuffer = Buffer$9 ? Buffer$9.isBuffer : void 0, isBuffer$1 = nativeIsBuffer || stubFalse, argsTag$3 = \"[object Arguments]\", arrayTag$2 = \"[object Array]\", boolTag$4 = \"[object Boolean]\", dateTag$3 = \"[object Date]\", errorTag$2 = \"[object Error]\", funcTag$2 = \"[object Function]\", mapTag$5 = \"[object Map]\", numberTag$4 = \"[object Number]\", objectTag$5 = \"[object Object]\", regexpTag$3 = \"[object RegExp]\", setTag$5 = \"[object Set]\", stringTag$5 = \"[object String]\", weakMapTag$2 = \"[object WeakMap]\", arrayBufferTag$3 = \"[object ArrayBuffer]\", dataViewTag$4 = \"[object DataView]\", float32Tag$2 = \"[object Float32Array]\", float64Tag$2 = \"[object Float64Array]\", int8Tag$2 = \"[object Int8Array]\", int16Tag$2 = \"[object Int16Array]\", int32Tag$2 = \"[object Int32Array]\", uint8Tag$2 = \"[object Uint8Array]\", uint8ClampedTag$2 = \"[object Uint8ClampedArray]\", uint16Tag$2 = \"[object Uint16Array]\", uint32Tag$2 = \"[object Uint32Array]\", typedArrayTags = {};\ntypedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = !0;\ntypedArrayTags[argsTag$3] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$4] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$2] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$4] = typedArrayTags[objectTag$5] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$5] = typedArrayTags[weakMapTag$2] = !1;\nfunction baseIsTypedArray(a) {\n  return isObjectLike$7(a) && isLength$1(a.length) && !!typedArrayTags[baseGetTag(a)];\n}\nfunction baseUnary(a) {\n  return function(u) {\n    return a(u);\n  };\n}\nvar freeExports$1 = typeof exports == \"object\" && exports && !exports.nodeType && exports, freeModule$1 = freeExports$1 && typeof module == \"object\" && module && !module.nodeType && module, moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1, freeProcess = moduleExports$1 && freeGlobal.process, nodeUtil = function() {\n  try {\n    var a = freeModule$1 && freeModule$1.require && freeModule$1.require(\"util\").types;\n    return a || freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n  } catch {\n  }\n}(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray, objectProto$g = Object.prototype, hasOwnProperty$b = objectProto$g.hasOwnProperty;\nfunction arrayLikeKeys$1(a, u) {\n  var c = isArray$5(a), l = !c && isArguments$1(a), v = !c && !l && isBuffer$1(a), S = !c && !l && !v && isTypedArray(a), g = c || l || v || S, E = g ? baseTimes$1(a.length, String) : [], _ = E.length;\n  for (var k in a)\n    (u || hasOwnProperty$b.call(a, k)) && !(g && // Safari 9 has enumerable `arguments.length` in strict mode.\n    (k == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n    v && (k == \"offset\" || k == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n    S && (k == \"buffer\" || k == \"byteLength\" || k == \"byteOffset\") || // Skip index properties.\n    isIndex$1(k, _))) && E.push(k);\n  return E;\n}\nfunction overArg$2(a, u) {\n  return function(c) {\n    return a(u(c));\n  };\n}\nvar nativeKeys$1 = overArg$2(Object.keys, Object), objectProto$f = Object.prototype, hasOwnProperty$a = objectProto$f.hasOwnProperty;\nfunction baseKeys$1(a) {\n  if (!isPrototype$1(a))\n    return nativeKeys$1(a);\n  var u = [];\n  for (var c in Object(a))\n    hasOwnProperty$a.call(a, c) && c != \"constructor\" && u.push(c);\n  return u;\n}\nfunction keys$2(a) {\n  return isArrayLike$2(a) ? arrayLikeKeys$1(a) : baseKeys$1(a);\n}\nfunction nativeKeysIn(a) {\n  var u = [];\n  if (a != null)\n    for (var c in Object(a))\n      u.push(c);\n  return u;\n}\nvar objectProto$e = Object.prototype, hasOwnProperty$9 = objectProto$e.hasOwnProperty;\nfunction baseKeysIn(a) {\n  if (!isObject$9(a))\n    return nativeKeysIn(a);\n  var u = isPrototype$1(a), c = [];\n  for (var l in a)\n    l == \"constructor\" && (u || !hasOwnProperty$9.call(a, l)) || c.push(l);\n  return c;\n}\nfunction keysIn(a) {\n  return isArrayLike$2(a) ? arrayLikeKeys$1(a, !0) : baseKeysIn(a);\n}\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, reIsPlainProp = /^\\w*$/;\nfunction isKey(a, u) {\n  if (isArray$5(a))\n    return !1;\n  var c = typeof a;\n  return c == \"number\" || c == \"symbol\" || c == \"boolean\" || a == null || isSymbol$3(a) ? !0 : reIsPlainProp.test(a) || !reIsDeepProp.test(a) || u != null && a in Object(u);\n}\nvar nativeCreate = getNative(Object, \"create\");\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;\n}\nfunction hashDelete(a) {\n  var u = this.has(a) && delete this.__data__[a];\n  return this.size -= u ? 1 : 0, u;\n}\nvar HASH_UNDEFINED$2 = \"__lodash_hash_undefined__\", objectProto$d = Object.prototype, hasOwnProperty$8 = objectProto$d.hasOwnProperty;\nfunction hashGet(a) {\n  var u = this.__data__;\n  if (nativeCreate) {\n    var c = u[a];\n    return c === HASH_UNDEFINED$2 ? void 0 : c;\n  }\n  return hasOwnProperty$8.call(u, a) ? u[a] : void 0;\n}\nvar objectProto$c = Object.prototype, hasOwnProperty$7 = objectProto$c.hasOwnProperty;\nfunction hashHas(a) {\n  var u = this.__data__;\n  return nativeCreate ? u[a] !== void 0 : hasOwnProperty$7.call(u, a);\n}\nvar HASH_UNDEFINED$1 = \"__lodash_hash_undefined__\";\nfunction hashSet(a, u) {\n  var c = this.__data__;\n  return this.size += this.has(a) ? 0 : 1, c[a] = nativeCreate && u === void 0 ? HASH_UNDEFINED$1 : u, this;\n}\nfunction Hash(a) {\n  var u = -1, c = a == null ? 0 : a.length;\n  for (this.clear(); ++u < c; ) {\n    var l = a[u];\n    this.set(l[0], l[1]);\n  }\n}\nHash.prototype.clear = hashClear;\nHash.prototype.delete = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\nfunction listCacheClear() {\n  this.__data__ = [], this.size = 0;\n}\nfunction assocIndexOf(a, u) {\n  for (var c = a.length; c--; )\n    if (eq(a[c][0], u))\n      return c;\n  return -1;\n}\nvar arrayProto$1 = Array.prototype, splice$1 = arrayProto$1.splice;\nfunction listCacheDelete(a) {\n  var u = this.__data__, c = assocIndexOf(u, a);\n  if (c < 0)\n    return !1;\n  var l = u.length - 1;\n  return c == l ? u.pop() : splice$1.call(u, c, 1), --this.size, !0;\n}\nfunction listCacheGet(a) {\n  var u = this.__data__, c = assocIndexOf(u, a);\n  return c < 0 ? void 0 : u[c][1];\n}\nfunction listCacheHas(a) {\n  return assocIndexOf(this.__data__, a) > -1;\n}\nfunction listCacheSet(a, u) {\n  var c = this.__data__, l = assocIndexOf(c, a);\n  return l < 0 ? (++this.size, c.push([a, u])) : c[l][1] = u, this;\n}\nfunction ListCache(a) {\n  var u = -1, c = a == null ? 0 : a.length;\n  for (this.clear(); ++u < c; ) {\n    var l = a[u];\n    this.set(l[0], l[1]);\n  }\n}\nListCache.prototype.clear = listCacheClear;\nListCache.prototype.delete = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\nvar Map$1 = getNative(root, \"Map\");\nfunction mapCacheClear() {\n  this.size = 0, this.__data__ = {\n    hash: new Hash(),\n    map: new (Map$1 || ListCache)(),\n    string: new Hash()\n  };\n}\nfunction isKeyable(a) {\n  var u = typeof a;\n  return u == \"string\" || u == \"number\" || u == \"symbol\" || u == \"boolean\" ? a !== \"__proto__\" : a === null;\n}\nfunction getMapData(a, u) {\n  var c = a.__data__;\n  return isKeyable(u) ? c[typeof u == \"string\" ? \"string\" : \"hash\"] : c.map;\n}\nfunction mapCacheDelete(a) {\n  var u = getMapData(this, a).delete(a);\n  return this.size -= u ? 1 : 0, u;\n}\nfunction mapCacheGet(a) {\n  return getMapData(this, a).get(a);\n}\nfunction mapCacheHas(a) {\n  return getMapData(this, a).has(a);\n}\nfunction mapCacheSet(a, u) {\n  var c = getMapData(this, a), l = c.size;\n  return c.set(a, u), this.size += c.size == l ? 0 : 1, this;\n}\nfunction MapCache(a) {\n  var u = -1, c = a == null ? 0 : a.length;\n  for (this.clear(); ++u < c; ) {\n    var l = a[u];\n    this.set(l[0], l[1]);\n  }\n}\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype.delete = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\nvar FUNC_ERROR_TEXT$2 = \"Expected a function\";\nfunction memoize(a, u) {\n  if (typeof a != \"function\" || u != null && typeof u != \"function\")\n    throw new TypeError(FUNC_ERROR_TEXT$2);\n  var c = function() {\n    var l = arguments, v = u ? u.apply(this, l) : l[0], S = c.cache;\n    if (S.has(v))\n      return S.get(v);\n    var g = a.apply(this, l);\n    return c.cache = S.set(v, g) || S, g;\n  };\n  return c.cache = new (memoize.Cache || MapCache)(), c;\n}\nmemoize.Cache = MapCache;\nvar MAX_MEMOIZE_SIZE = 500;\nfunction memoizeCapped(a) {\n  var u = memoize(a, function(l) {\n    return c.size === MAX_MEMOIZE_SIZE && c.clear(), l;\n  }), c = u.cache;\n  return u;\n}\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, reEscapeChar = /\\\\(\\\\)?/g, stringToPath = memoizeCapped(function(a) {\n  var u = [];\n  return a.charCodeAt(0) === 46 && u.push(\"\"), a.replace(rePropName, function(c, l, v, S) {\n    u.push(v ? S.replace(reEscapeChar, \"$1\") : l || c);\n  }), u;\n});\nfunction toString$3(a) {\n  return a == null ? \"\" : baseToString(a);\n}\nfunction castPath(a, u) {\n  return isArray$5(a) ? a : isKey(a, u) ? [a] : stringToPath(toString$3(a));\n}\nvar INFINITY$3 = 1 / 0;\nfunction toKey(a) {\n  if (typeof a == \"string\" || isSymbol$3(a))\n    return a;\n  var u = a + \"\";\n  return u == \"0\" && 1 / a == -INFINITY$3 ? \"-0\" : u;\n}\nfunction baseGet(a, u) {\n  u = castPath(u, a);\n  for (var c = 0, l = u.length; a != null && c < l; )\n    a = a[toKey(u[c++])];\n  return c && c == l ? a : void 0;\n}\nfunction get(a, u, c) {\n  var l = a == null ? void 0 : baseGet(a, u);\n  return l === void 0 ? c : l;\n}\nfunction arrayPush(a, u) {\n  for (var c = -1, l = u.length, v = a.length; ++c < l; )\n    a[v + c] = u[c];\n  return a;\n}\nvar spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;\nfunction isFlattenable(a) {\n  return isArray$5(a) || isArguments$1(a) || !!(spreadableSymbol && a && a[spreadableSymbol]);\n}\nfunction baseFlatten(a, u, c, l, v) {\n  var S = -1, g = a.length;\n  for (c || (c = isFlattenable), v || (v = []); ++S < g; ) {\n    var E = a[S];\n    u > 0 && c(E) ? u > 1 ? baseFlatten(E, u - 1, c, l, v) : arrayPush(v, E) : l || (v[v.length] = E);\n  }\n  return v;\n}\nfunction flatten(a) {\n  var u = a == null ? 0 : a.length;\n  return u ? baseFlatten(a, 1) : [];\n}\nfunction flatRest(a) {\n  return setToString(overRest(a, void 0, flatten), a + \"\");\n}\nvar getPrototype$1 = overArg$2(Object.getPrototypeOf, Object);\nconst getPrototype$2 = getPrototype$1;\nvar objectTag$4 = \"[object Object]\", funcProto$1 = Function.prototype, objectProto$b = Object.prototype, funcToString$1 = funcProto$1.toString, hasOwnProperty$6 = objectProto$b.hasOwnProperty, objectCtorString$1 = funcToString$1.call(Object);\nfunction isPlainObject$3(a) {\n  if (!isObjectLike$7(a) || baseGetTag(a) != objectTag$4)\n    return !1;\n  var u = getPrototype$2(a);\n  if (u === null)\n    return !0;\n  var c = hasOwnProperty$6.call(u, \"constructor\") && u.constructor;\n  return typeof c == \"function\" && c instanceof c && funcToString$1.call(c) == objectCtorString$1;\n}\nfunction baseSlice(a, u, c) {\n  var l = -1, v = a.length;\n  u < 0 && (u = -u > v ? 0 : v + u), c = c > v ? v : c, c < 0 && (c += v), v = u > c ? 0 : c - u >>> 0, u >>>= 0;\n  for (var S = Array(v); ++l < v; )\n    S[l] = a[l + u];\n  return S;\n}\nfunction castSlice(a, u, c) {\n  var l = a.length;\n  return c = c === void 0 ? l : c, !u && c >= l ? a : baseSlice(a, u, c);\n}\nvar rsAstralRange$2 = \"\\\\ud800-\\\\udfff\", rsComboMarksRange$3 = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange$3 = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange$3 = \"\\\\u20d0-\\\\u20ff\", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = \"\\\\ufe0e\\\\ufe0f\", rsZWJ$2 = \"\\\\u200d\", reHasUnicode = RegExp(\"[\" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + \"]\");\nfunction hasUnicode(a) {\n  return reHasUnicode.test(a);\n}\nfunction asciiToArray(a) {\n  return a.split(\"\");\n}\nvar rsAstralRange$1 = \"\\\\ud800-\\\\udfff\", rsComboMarksRange$2 = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange$2 = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange$2 = \"\\\\u20d0-\\\\u20ff\", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = \"\\\\ufe0e\\\\ufe0f\", rsAstral = \"[\" + rsAstralRange$1 + \"]\", rsCombo$2 = \"[\" + rsComboRange$2 + \"]\", rsFitz$1 = \"\\\\ud83c[\\\\udffb-\\\\udfff]\", rsModifier$1 = \"(?:\" + rsCombo$2 + \"|\" + rsFitz$1 + \")\", rsNonAstral$1 = \"[^\" + rsAstralRange$1 + \"]\", rsRegional$1 = \"(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}\", rsSurrPair$1 = \"[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]\", rsZWJ$1 = \"\\\\u200d\", reOptMod$1 = rsModifier$1 + \"?\", rsOptVar$1 = \"[\" + rsVarRange$1 + \"]?\", rsOptJoin$1 = \"(?:\" + rsZWJ$1 + \"(?:\" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join(\"|\") + \")\" + rsOptVar$1 + reOptMod$1 + \")*\", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = \"(?:\" + [rsNonAstral$1 + rsCombo$2 + \"?\", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join(\"|\") + \")\", reUnicode = RegExp(rsFitz$1 + \"(?=\" + rsFitz$1 + \")|\" + rsSymbol + rsSeq$1, \"g\");\nfunction unicodeToArray(a) {\n  return a.match(reUnicode) || [];\n}\nfunction stringToArray(a) {\n  return hasUnicode(a) ? unicodeToArray(a) : asciiToArray(a);\n}\nfunction createCaseFirst(a) {\n  return function(u) {\n    u = toString$3(u);\n    var c = hasUnicode(u) ? stringToArray(u) : void 0, l = c ? c[0] : u.charAt(0), v = c ? castSlice(c, 1).join(\"\") : u.slice(1);\n    return l[a]() + v;\n  };\n}\nvar upperFirst = createCaseFirst(\"toUpperCase\");\nfunction capitalize(a) {\n  return upperFirst(toString$3(a).toLowerCase());\n}\nfunction arrayReduce(a, u, c, l) {\n  var v = -1, S = a == null ? 0 : a.length;\n  for (l && S && (c = a[++v]); ++v < S; )\n    c = u(c, a[v], v, a);\n  return c;\n}\nfunction basePropertyOf(a) {\n  return function(u) {\n    return a == null ? void 0 : a[u];\n  };\n}\nvar deburredLetters = {\n  // Latin-1 Supplement block.\n  À: \"A\",\n  Á: \"A\",\n  Â: \"A\",\n  Ã: \"A\",\n  Ä: \"A\",\n  Å: \"A\",\n  à: \"a\",\n  á: \"a\",\n  â: \"a\",\n  ã: \"a\",\n  ä: \"a\",\n  å: \"a\",\n  Ç: \"C\",\n  ç: \"c\",\n  Ð: \"D\",\n  ð: \"d\",\n  È: \"E\",\n  É: \"E\",\n  Ê: \"E\",\n  Ë: \"E\",\n  è: \"e\",\n  é: \"e\",\n  ê: \"e\",\n  ë: \"e\",\n  Ì: \"I\",\n  Í: \"I\",\n  Î: \"I\",\n  Ï: \"I\",\n  ì: \"i\",\n  í: \"i\",\n  î: \"i\",\n  ï: \"i\",\n  Ñ: \"N\",\n  ñ: \"n\",\n  Ò: \"O\",\n  Ó: \"O\",\n  Ô: \"O\",\n  Õ: \"O\",\n  Ö: \"O\",\n  Ø: \"O\",\n  ò: \"o\",\n  ó: \"o\",\n  ô: \"o\",\n  õ: \"o\",\n  ö: \"o\",\n  ø: \"o\",\n  Ù: \"U\",\n  Ú: \"U\",\n  Û: \"U\",\n  Ü: \"U\",\n  ù: \"u\",\n  ú: \"u\",\n  û: \"u\",\n  ü: \"u\",\n  Ý: \"Y\",\n  ý: \"y\",\n  ÿ: \"y\",\n  Æ: \"Ae\",\n  æ: \"ae\",\n  Þ: \"Th\",\n  þ: \"th\",\n  ß: \"ss\",\n  // Latin Extended-A block.\n  Ā: \"A\",\n  Ă: \"A\",\n  Ą: \"A\",\n  ā: \"a\",\n  ă: \"a\",\n  ą: \"a\",\n  Ć: \"C\",\n  Ĉ: \"C\",\n  Ċ: \"C\",\n  Č: \"C\",\n  ć: \"c\",\n  ĉ: \"c\",\n  ċ: \"c\",\n  č: \"c\",\n  Ď: \"D\",\n  Đ: \"D\",\n  ď: \"d\",\n  đ: \"d\",\n  Ē: \"E\",\n  Ĕ: \"E\",\n  Ė: \"E\",\n  Ę: \"E\",\n  Ě: \"E\",\n  ē: \"e\",\n  ĕ: \"e\",\n  ė: \"e\",\n  ę: \"e\",\n  ě: \"e\",\n  Ĝ: \"G\",\n  Ğ: \"G\",\n  Ġ: \"G\",\n  Ģ: \"G\",\n  ĝ: \"g\",\n  ğ: \"g\",\n  ġ: \"g\",\n  ģ: \"g\",\n  Ĥ: \"H\",\n  Ħ: \"H\",\n  ĥ: \"h\",\n  ħ: \"h\",\n  Ĩ: \"I\",\n  Ī: \"I\",\n  Ĭ: \"I\",\n  Į: \"I\",\n  İ: \"I\",\n  ĩ: \"i\",\n  ī: \"i\",\n  ĭ: \"i\",\n  į: \"i\",\n  ı: \"i\",\n  Ĵ: \"J\",\n  ĵ: \"j\",\n  Ķ: \"K\",\n  ķ: \"k\",\n  ĸ: \"k\",\n  Ĺ: \"L\",\n  Ļ: \"L\",\n  Ľ: \"L\",\n  Ŀ: \"L\",\n  Ł: \"L\",\n  ĺ: \"l\",\n  ļ: \"l\",\n  ľ: \"l\",\n  ŀ: \"l\",\n  ł: \"l\",\n  Ń: \"N\",\n  Ņ: \"N\",\n  Ň: \"N\",\n  Ŋ: \"N\",\n  ń: \"n\",\n  ņ: \"n\",\n  ň: \"n\",\n  ŋ: \"n\",\n  Ō: \"O\",\n  Ŏ: \"O\",\n  Ő: \"O\",\n  ō: \"o\",\n  ŏ: \"o\",\n  ő: \"o\",\n  Ŕ: \"R\",\n  Ŗ: \"R\",\n  Ř: \"R\",\n  ŕ: \"r\",\n  ŗ: \"r\",\n  ř: \"r\",\n  Ś: \"S\",\n  Ŝ: \"S\",\n  Ş: \"S\",\n  Š: \"S\",\n  ś: \"s\",\n  ŝ: \"s\",\n  ş: \"s\",\n  š: \"s\",\n  Ţ: \"T\",\n  Ť: \"T\",\n  Ŧ: \"T\",\n  ţ: \"t\",\n  ť: \"t\",\n  ŧ: \"t\",\n  Ũ: \"U\",\n  Ū: \"U\",\n  Ŭ: \"U\",\n  Ů: \"U\",\n  Ű: \"U\",\n  Ų: \"U\",\n  ũ: \"u\",\n  ū: \"u\",\n  ŭ: \"u\",\n  ů: \"u\",\n  ű: \"u\",\n  ų: \"u\",\n  Ŵ: \"W\",\n  ŵ: \"w\",\n  Ŷ: \"Y\",\n  ŷ: \"y\",\n  Ÿ: \"Y\",\n  Ź: \"Z\",\n  Ż: \"Z\",\n  Ž: \"Z\",\n  ź: \"z\",\n  ż: \"z\",\n  ž: \"z\",\n  Ĳ: \"IJ\",\n  ĳ: \"ij\",\n  Œ: \"Oe\",\n  œ: \"oe\",\n  ŉ: \"'n\",\n  ſ: \"s\"\n}, deburrLetter = basePropertyOf(deburredLetters);\nconst deburrLetter$1 = deburrLetter;\nvar reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g, rsComboMarksRange$1 = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange$1 = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange$1 = \"\\\\u20d0-\\\\u20ff\", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsCombo$1 = \"[\" + rsComboRange$1 + \"]\", reComboMark = RegExp(rsCombo$1, \"g\");\nfunction deburr(a) {\n  return a = toString$3(a), a && a.replace(reLatin, deburrLetter$1).replace(reComboMark, \"\");\n}\nvar reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\nfunction asciiWords(a) {\n  return a.match(reAsciiWord) || [];\n}\nvar reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\nfunction hasUnicodeWord(a) {\n  return reHasUnicodeWord.test(a);\n}\nvar rsAstralRange = \"\\\\ud800-\\\\udfff\", rsComboMarksRange = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange = \"\\\\u20d0-\\\\u20ff\", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = \"\\\\u2700-\\\\u27bf\", rsLowerRange = \"a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff\", rsMathOpRange = \"\\\\xac\\\\xb1\\\\xd7\\\\xf7\", rsNonCharRange = \"\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\", rsPunctuationRange = \"\\\\u2000-\\\\u206f\", rsSpaceRange = \" \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000\", rsUpperRange = \"A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde\", rsVarRange = \"\\\\ufe0e\\\\ufe0f\", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange, rsApos$1 = \"['’]\", rsBreak = \"[\" + rsBreakRange + \"]\", rsCombo = \"[\" + rsComboRange + \"]\", rsDigits = \"\\\\d+\", rsDingbat = \"[\" + rsDingbatRange + \"]\", rsLower = \"[\" + rsLowerRange + \"]\", rsMisc = \"[^\" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + \"]\", rsFitz = \"\\\\ud83c[\\\\udffb-\\\\udfff]\", rsModifier = \"(?:\" + rsCombo + \"|\" + rsFitz + \")\", rsNonAstral = \"[^\" + rsAstralRange + \"]\", rsRegional = \"(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}\", rsSurrPair = \"[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]\", rsUpper = \"[\" + rsUpperRange + \"]\", rsZWJ = \"\\\\u200d\", rsMiscLower = \"(?:\" + rsLower + \"|\" + rsMisc + \")\", rsMiscUpper = \"(?:\" + rsUpper + \"|\" + rsMisc + \")\", rsOptContrLower = \"(?:\" + rsApos$1 + \"(?:d|ll|m|re|s|t|ve))?\", rsOptContrUpper = \"(?:\" + rsApos$1 + \"(?:D|LL|M|RE|S|T|VE))?\", reOptMod = rsModifier + \"?\", rsOptVar = \"[\" + rsVarRange + \"]?\", rsOptJoin = \"(?:\" + rsZWJ + \"(?:\" + [rsNonAstral, rsRegional, rsSurrPair].join(\"|\") + \")\" + rsOptVar + reOptMod + \")*\", rsOrdLower = \"\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])\", rsOrdUpper = \"\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])\", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = \"(?:\" + [rsDingbat, rsRegional, rsSurrPair].join(\"|\") + \")\" + rsSeq, reUnicodeWord = RegExp([\n  rsUpper + \"?\" + rsLower + \"+\" + rsOptContrLower + \"(?=\" + [rsBreak, rsUpper, \"$\"].join(\"|\") + \")\",\n  rsMiscUpper + \"+\" + rsOptContrUpper + \"(?=\" + [rsBreak, rsUpper + rsMiscLower, \"$\"].join(\"|\") + \")\",\n  rsUpper + \"?\" + rsMiscLower + \"+\" + rsOptContrLower,\n  rsUpper + \"+\" + rsOptContrUpper,\n  rsOrdUpper,\n  rsOrdLower,\n  rsDigits,\n  rsEmoji\n].join(\"|\"), \"g\");\nfunction unicodeWords(a) {\n  return a.match(reUnicodeWord) || [];\n}\nfunction words(a, u, c) {\n  return a = toString$3(a), u = c ? void 0 : u, u === void 0 ? hasUnicodeWord(a) ? unicodeWords(a) : asciiWords(a) : a.match(u) || [];\n}\nvar rsApos = \"['’]\", reApos = RegExp(rsApos, \"g\");\nfunction createCompounder(a) {\n  return function(u) {\n    return arrayReduce(words(deburr(u).replace(reApos, \"\")), a, \"\");\n  };\n}\nvar camelCase$2 = createCompounder(function(a, u, c) {\n  return u = u.toLowerCase(), a + (c ? capitalize(u) : u);\n});\nconst camelCase$3 = camelCase$2;\nfunction stackClear() {\n  this.__data__ = new ListCache(), this.size = 0;\n}\nfunction stackDelete(a) {\n  var u = this.__data__, c = u.delete(a);\n  return this.size = u.size, c;\n}\nfunction stackGet(a) {\n  return this.__data__.get(a);\n}\nfunction stackHas(a) {\n  return this.__data__.has(a);\n}\nvar LARGE_ARRAY_SIZE = 200;\nfunction stackSet(a, u) {\n  var c = this.__data__;\n  if (c instanceof ListCache) {\n    var l = c.__data__;\n    if (!Map$1 || l.length < LARGE_ARRAY_SIZE - 1)\n      return l.push([a, u]), this.size = ++c.size, this;\n    c = this.__data__ = new MapCache(l);\n  }\n  return c.set(a, u), this.size = c.size, this;\n}\nfunction Stack(a) {\n  var u = this.__data__ = new ListCache(a);\n  this.size = u.size;\n}\nStack.prototype.clear = stackClear;\nStack.prototype.delete = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\nfunction baseAssign(a, u) {\n  return a && copyObject(u, keys$2(u), a);\n}\nfunction baseAssignIn(a, u) {\n  return a && copyObject(u, keysIn(u), a);\n}\nvar freeExports = typeof exports == \"object\" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module == \"object\" && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, Buffer$8 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer$8 ? Buffer$8.allocUnsafe : void 0;\nfunction cloneBuffer(a, u) {\n  if (u)\n    return a.slice();\n  var c = a.length, l = allocUnsafe ? allocUnsafe(c) : new a.constructor(c);\n  return a.copy(l), l;\n}\nfunction arrayFilter(a, u) {\n  for (var c = -1, l = a == null ? 0 : a.length, v = 0, S = []; ++c < l; ) {\n    var g = a[c];\n    u(g, c, a) && (S[v++] = g);\n  }\n  return S;\n}\nfunction stubArray() {\n  return [];\n}\nvar objectProto$a = Object.prototype, propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable, nativeGetSymbols$1 = Object.getOwnPropertySymbols, getSymbols = nativeGetSymbols$1 ? function(a) {\n  return a == null ? [] : (a = Object(a), arrayFilter(nativeGetSymbols$1(a), function(u) {\n    return propertyIsEnumerable$1.call(a, u);\n  }));\n} : stubArray;\nfunction copySymbols(a, u) {\n  return copyObject(a, getSymbols(a), u);\n}\nvar nativeGetSymbols = Object.getOwnPropertySymbols, getSymbolsIn = nativeGetSymbols ? function(a) {\n  for (var u = []; a; )\n    arrayPush(u, getSymbols(a)), a = getPrototype$2(a);\n  return u;\n} : stubArray;\nfunction copySymbolsIn(a, u) {\n  return copyObject(a, getSymbolsIn(a), u);\n}\nfunction baseGetAllKeys(a, u, c) {\n  var l = u(a);\n  return isArray$5(a) ? l : arrayPush(l, c(a));\n}\nfunction getAllKeys(a) {\n  return baseGetAllKeys(a, keys$2, getSymbols);\n}\nfunction getAllKeysIn(a) {\n  return baseGetAllKeys(a, keysIn, getSymbolsIn);\n}\nvar DataView$1 = getNative(root, \"DataView\"), Promise$1 = getNative(root, \"Promise\"), Set$1 = getNative(root, \"Set\"), mapTag$4 = \"[object Map]\", objectTag$3 = \"[object Object]\", promiseTag = \"[object Promise]\", setTag$4 = \"[object Set]\", weakMapTag$1 = \"[object WeakMap]\", dataViewTag$3 = \"[object DataView]\", dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$2), getTag = baseGetTag;\n(DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) && (getTag = function(a) {\n  var u = baseGetTag(a), c = u == objectTag$3 ? a.constructor : void 0, l = c ? toSource(c) : \"\";\n  if (l)\n    switch (l) {\n      case dataViewCtorString:\n        return dataViewTag$3;\n      case mapCtorString:\n        return mapTag$4;\n      case promiseCtorString:\n        return promiseTag;\n      case setCtorString:\n        return setTag$4;\n      case weakMapCtorString:\n        return weakMapTag$1;\n    }\n  return u;\n});\nconst getTag$1 = getTag;\nvar objectProto$9 = Object.prototype, hasOwnProperty$5 = objectProto$9.hasOwnProperty;\nfunction initCloneArray(a) {\n  var u = a.length, c = new a.constructor(u);\n  return u && typeof a[0] == \"string\" && hasOwnProperty$5.call(a, \"index\") && (c.index = a.index, c.input = a.input), c;\n}\nvar Uint8Array$1 = root.Uint8Array;\nfunction cloneArrayBuffer(a) {\n  var u = new a.constructor(a.byteLength);\n  return new Uint8Array$1(u).set(new Uint8Array$1(a)), u;\n}\nfunction cloneDataView(a, u) {\n  var c = u ? cloneArrayBuffer(a.buffer) : a.buffer;\n  return new a.constructor(c, a.byteOffset, a.byteLength);\n}\nvar reFlags = /\\w*$/;\nfunction cloneRegExp(a) {\n  var u = new a.constructor(a.source, reFlags.exec(a));\n  return u.lastIndex = a.lastIndex, u;\n}\nvar symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;\nfunction cloneSymbol(a) {\n  return symbolValueOf$1 ? Object(symbolValueOf$1.call(a)) : {};\n}\nfunction cloneTypedArray(a, u) {\n  var c = u ? cloneArrayBuffer(a.buffer) : a.buffer;\n  return new a.constructor(c, a.byteOffset, a.length);\n}\nvar boolTag$3 = \"[object Boolean]\", dateTag$2 = \"[object Date]\", mapTag$3 = \"[object Map]\", numberTag$3 = \"[object Number]\", regexpTag$2 = \"[object RegExp]\", setTag$3 = \"[object Set]\", stringTag$4 = \"[object String]\", symbolTag$5 = \"[object Symbol]\", arrayBufferTag$2 = \"[object ArrayBuffer]\", dataViewTag$2 = \"[object DataView]\", float32Tag$1 = \"[object Float32Array]\", float64Tag$1 = \"[object Float64Array]\", int8Tag$1 = \"[object Int8Array]\", int16Tag$1 = \"[object Int16Array]\", int32Tag$1 = \"[object Int32Array]\", uint8Tag$1 = \"[object Uint8Array]\", uint8ClampedTag$1 = \"[object Uint8ClampedArray]\", uint16Tag$1 = \"[object Uint16Array]\", uint32Tag$1 = \"[object Uint32Array]\";\nfunction initCloneByTag(a, u, c) {\n  var l = a.constructor;\n  switch (u) {\n    case arrayBufferTag$2:\n      return cloneArrayBuffer(a);\n    case boolTag$3:\n    case dateTag$2:\n      return new l(+a);\n    case dataViewTag$2:\n      return cloneDataView(a, c);\n    case float32Tag$1:\n    case float64Tag$1:\n    case int8Tag$1:\n    case int16Tag$1:\n    case int32Tag$1:\n    case uint8Tag$1:\n    case uint8ClampedTag$1:\n    case uint16Tag$1:\n    case uint32Tag$1:\n      return cloneTypedArray(a, c);\n    case mapTag$3:\n      return new l();\n    case numberTag$3:\n    case stringTag$4:\n      return new l(a);\n    case regexpTag$2:\n      return cloneRegExp(a);\n    case setTag$3:\n      return new l();\n    case symbolTag$5:\n      return cloneSymbol(a);\n  }\n}\nfunction initCloneObject(a) {\n  return typeof a.constructor == \"function\" && !isPrototype$1(a) ? baseCreate(getPrototype$2(a)) : {};\n}\nvar mapTag$2 = \"[object Map]\";\nfunction baseIsMap(a) {\n  return isObjectLike$7(a) && getTag$1(a) == mapTag$2;\n}\nvar nodeIsMap = nodeUtil && nodeUtil.isMap, isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap, setTag$2 = \"[object Set]\";\nfunction baseIsSet(a) {\n  return isObjectLike$7(a) && getTag$1(a) == setTag$2;\n}\nvar nodeIsSet = nodeUtil && nodeUtil.isSet, isSet$5 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet, CLONE_DEEP_FLAG$3 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4, argsTag$2 = \"[object Arguments]\", arrayTag$1 = \"[object Array]\", boolTag$2 = \"[object Boolean]\", dateTag$1 = \"[object Date]\", errorTag$1 = \"[object Error]\", funcTag$1 = \"[object Function]\", genTag$1 = \"[object GeneratorFunction]\", mapTag$1 = \"[object Map]\", numberTag$2 = \"[object Number]\", objectTag$2 = \"[object Object]\", regexpTag$1 = \"[object RegExp]\", setTag$1 = \"[object Set]\", stringTag$3 = \"[object String]\", symbolTag$4 = \"[object Symbol]\", weakMapTag = \"[object WeakMap]\", arrayBufferTag$1 = \"[object ArrayBuffer]\", dataViewTag$1 = \"[object DataView]\", float32Tag = \"[object Float32Array]\", float64Tag = \"[object Float64Array]\", int8Tag = \"[object Int8Array]\", int16Tag = \"[object Int16Array]\", int32Tag = \"[object Int32Array]\", uint8Tag = \"[object Uint8Array]\", uint8ClampedTag = \"[object Uint8ClampedArray]\", uint16Tag = \"[object Uint16Array]\", uint32Tag = \"[object Uint32Array]\", cloneableTags = {};\ncloneableTags[argsTag$2] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$2] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$2] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$3] = cloneableTags[symbolTag$4] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0;\ncloneableTags[errorTag$1] = cloneableTags[funcTag$1] = cloneableTags[weakMapTag] = !1;\nfunction baseClone(a, u, c, l, v, S) {\n  var g, E = u & CLONE_DEEP_FLAG$3, _ = u & CLONE_FLAT_FLAG$1, k = u & CLONE_SYMBOLS_FLAG$2;\n  if (c && (g = v ? c(a, l, v, S) : c(a)), g !== void 0)\n    return g;\n  if (!isObject$9(a))\n    return a;\n  var L = isArray$5(a);\n  if (L) {\n    if (g = initCloneArray(a), !E)\n      return copyArray(a, g);\n  } else {\n    var M = getTag$1(a), $ = M == funcTag$1 || M == genTag$1;\n    if (isBuffer$1(a))\n      return cloneBuffer(a, E);\n    if (M == objectTag$2 || M == argsTag$2 || $ && !v) {\n      if (g = _ || $ ? {} : initCloneObject(a), !E)\n        return _ ? copySymbolsIn(a, baseAssignIn(g, a)) : copySymbols(a, baseAssign(g, a));\n    } else {\n      if (!cloneableTags[M])\n        return v ? a : {};\n      g = initCloneByTag(a, M, E);\n    }\n  }\n  S || (S = new Stack());\n  var J = S.get(a);\n  if (J)\n    return J;\n  S.set(a, g), isSet$5(a) ? a.forEach(function(G) {\n    g.add(baseClone(G, u, c, G, a, S));\n  }) : isMap(a) && a.forEach(function(G, H) {\n    g.set(H, baseClone(G, u, c, H, a, S));\n  });\n  var V = k ? _ ? getAllKeysIn : getAllKeys : _ ? keysIn : keys$2, q = L ? void 0 : V(a);\n  return arrayEach(q || a, function(G, H) {\n    q && (H = G, G = a[H]), assignValue(g, H, baseClone(G, u, c, H, a, S));\n  }), g;\n}\nvar CLONE_DEEP_FLAG$2 = 1, CLONE_SYMBOLS_FLAG$1 = 4;\nfunction cloneDeep$1(a) {\n  return baseClone(a, CLONE_DEEP_FLAG$2 | CLONE_SYMBOLS_FLAG$1);\n}\nvar HASH_UNDEFINED = \"__lodash_hash_undefined__\";\nfunction setCacheAdd(a) {\n  return this.__data__.set(a, HASH_UNDEFINED), this;\n}\nfunction setCacheHas(a) {\n  return this.__data__.has(a);\n}\nfunction SetCache(a) {\n  var u = -1, c = a == null ? 0 : a.length;\n  for (this.__data__ = new MapCache(); ++u < c; )\n    this.add(a[u]);\n}\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\nfunction arraySome(a, u) {\n  for (var c = -1, l = a == null ? 0 : a.length; ++c < l; )\n    if (u(a[c], c, a))\n      return !0;\n  return !1;\n}\nfunction cacheHas(a, u) {\n  return a.has(u);\n}\nvar COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;\nfunction equalArrays(a, u, c, l, v, S) {\n  var g = c & COMPARE_PARTIAL_FLAG$5, E = a.length, _ = u.length;\n  if (E != _ && !(g && _ > E))\n    return !1;\n  var k = S.get(a), L = S.get(u);\n  if (k && L)\n    return k == u && L == a;\n  var M = -1, $ = !0, J = c & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;\n  for (S.set(a, u), S.set(u, a); ++M < E; ) {\n    var V = a[M], q = u[M];\n    if (l)\n      var G = g ? l(q, V, M, u, a, S) : l(V, q, M, a, u, S);\n    if (G !== void 0) {\n      if (G)\n        continue;\n      $ = !1;\n      break;\n    }\n    if (J) {\n      if (!arraySome(u, function(H, B) {\n        if (!cacheHas(J, B) && (V === H || v(V, H, c, l, S)))\n          return J.push(B);\n      })) {\n        $ = !1;\n        break;\n      }\n    } else if (!(V === q || v(V, q, c, l, S))) {\n      $ = !1;\n      break;\n    }\n  }\n  return S.delete(a), S.delete(u), $;\n}\nfunction mapToArray(a) {\n  var u = -1, c = Array(a.size);\n  return a.forEach(function(l, v) {\n    c[++u] = [v, l];\n  }), c;\n}\nfunction setToArray(a) {\n  var u = -1, c = Array(a.size);\n  return a.forEach(function(l) {\n    c[++u] = l;\n  }), c;\n}\nvar COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2, boolTag$1 = \"[object Boolean]\", dateTag = \"[object Date]\", errorTag = \"[object Error]\", mapTag = \"[object Map]\", numberTag$1 = \"[object Number]\", regexpTag = \"[object RegExp]\", setTag = \"[object Set]\", stringTag$2 = \"[object String]\", symbolTag$3 = \"[object Symbol]\", arrayBufferTag = \"[object ArrayBuffer]\", dataViewTag = \"[object DataView]\", symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;\nfunction equalByTag(a, u, c, l, v, S, g) {\n  switch (c) {\n    case dataViewTag:\n      if (a.byteLength != u.byteLength || a.byteOffset != u.byteOffset)\n        return !1;\n      a = a.buffer, u = u.buffer;\n    case arrayBufferTag:\n      return !(a.byteLength != u.byteLength || !S(new Uint8Array$1(a), new Uint8Array$1(u)));\n    case boolTag$1:\n    case dateTag:\n    case numberTag$1:\n      return eq(+a, +u);\n    case errorTag:\n      return a.name == u.name && a.message == u.message;\n    case regexpTag:\n    case stringTag$2:\n      return a == u + \"\";\n    case mapTag:\n      var E = mapToArray;\n    case setTag:\n      var _ = l & COMPARE_PARTIAL_FLAG$4;\n      if (E || (E = setToArray), a.size != u.size && !_)\n        return !1;\n      var k = g.get(a);\n      if (k)\n        return k == u;\n      l |= COMPARE_UNORDERED_FLAG$2, g.set(a, u);\n      var L = equalArrays(E(a), E(u), l, v, S, g);\n      return g.delete(a), L;\n    case symbolTag$3:\n      if (symbolValueOf)\n        return symbolValueOf.call(a) == symbolValueOf.call(u);\n  }\n  return !1;\n}\nvar COMPARE_PARTIAL_FLAG$3 = 1, objectProto$8 = Object.prototype, hasOwnProperty$4 = objectProto$8.hasOwnProperty;\nfunction equalObjects(a, u, c, l, v, S) {\n  var g = c & COMPARE_PARTIAL_FLAG$3, E = getAllKeys(a), _ = E.length, k = getAllKeys(u), L = k.length;\n  if (_ != L && !g)\n    return !1;\n  for (var M = _; M--; ) {\n    var $ = E[M];\n    if (!(g ? $ in u : hasOwnProperty$4.call(u, $)))\n      return !1;\n  }\n  var J = S.get(a), V = S.get(u);\n  if (J && V)\n    return J == u && V == a;\n  var q = !0;\n  S.set(a, u), S.set(u, a);\n  for (var G = g; ++M < _; ) {\n    $ = E[M];\n    var H = a[$], B = u[$];\n    if (l)\n      var Y = g ? l(B, H, $, u, a, S) : l(H, B, $, a, u, S);\n    if (!(Y === void 0 ? H === B || v(H, B, c, l, S) : Y)) {\n      q = !1;\n      break;\n    }\n    G || (G = $ == \"constructor\");\n  }\n  if (q && !G) {\n    var ne = a.constructor, Z = u.constructor;\n    ne != Z && \"constructor\" in a && \"constructor\" in u && !(typeof ne == \"function\" && ne instanceof ne && typeof Z == \"function\" && Z instanceof Z) && (q = !1);\n  }\n  return S.delete(a), S.delete(u), q;\n}\nvar COMPARE_PARTIAL_FLAG$2 = 1, argsTag$1 = \"[object Arguments]\", arrayTag = \"[object Array]\", objectTag$1 = \"[object Object]\", objectProto$7 = Object.prototype, hasOwnProperty$3 = objectProto$7.hasOwnProperty;\nfunction baseIsEqualDeep(a, u, c, l, v, S) {\n  var g = isArray$5(a), E = isArray$5(u), _ = g ? arrayTag : getTag$1(a), k = E ? arrayTag : getTag$1(u);\n  _ = _ == argsTag$1 ? objectTag$1 : _, k = k == argsTag$1 ? objectTag$1 : k;\n  var L = _ == objectTag$1, M = k == objectTag$1, $ = _ == k;\n  if ($ && isBuffer$1(a)) {\n    if (!isBuffer$1(u))\n      return !1;\n    g = !0, L = !1;\n  }\n  if ($ && !L)\n    return S || (S = new Stack()), g || isTypedArray(a) ? equalArrays(a, u, c, l, v, S) : equalByTag(a, u, _, c, l, v, S);\n  if (!(c & COMPARE_PARTIAL_FLAG$2)) {\n    var J = L && hasOwnProperty$3.call(a, \"__wrapped__\"), V = M && hasOwnProperty$3.call(u, \"__wrapped__\");\n    if (J || V) {\n      var q = J ? a.value() : a, G = V ? u.value() : u;\n      return S || (S = new Stack()), v(q, G, c, l, S);\n    }\n  }\n  return $ ? (S || (S = new Stack()), equalObjects(a, u, c, l, v, S)) : !1;\n}\nfunction baseIsEqual(a, u, c, l, v) {\n  return a === u ? !0 : a == null || u == null || !isObjectLike$7(a) && !isObjectLike$7(u) ? a !== a && u !== u : baseIsEqualDeep(a, u, c, l, baseIsEqual, v);\n}\nvar COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;\nfunction baseIsMatch(a, u, c, l) {\n  var v = c.length, S = v, g = !l;\n  if (a == null)\n    return !S;\n  for (a = Object(a); v--; ) {\n    var E = c[v];\n    if (g && E[2] ? E[1] !== a[E[0]] : !(E[0] in a))\n      return !1;\n  }\n  for (; ++v < S; ) {\n    E = c[v];\n    var _ = E[0], k = a[_], L = E[1];\n    if (g && E[2]) {\n      if (k === void 0 && !(_ in a))\n        return !1;\n    } else {\n      var M = new Stack();\n      if (l)\n        var $ = l(k, L, _, a, u, M);\n      if (!($ === void 0 ? baseIsEqual(L, k, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, l, M) : $))\n        return !1;\n    }\n  }\n  return !0;\n}\nfunction isStrictComparable(a) {\n  return a === a && !isObject$9(a);\n}\nfunction getMatchData(a) {\n  for (var u = keys$2(a), c = u.length; c--; ) {\n    var l = u[c], v = a[l];\n    u[c] = [l, v, isStrictComparable(v)];\n  }\n  return u;\n}\nfunction matchesStrictComparable(a, u) {\n  return function(c) {\n    return c == null ? !1 : c[a] === u && (u !== void 0 || a in Object(c));\n  };\n}\nfunction baseMatches(a) {\n  var u = getMatchData(a);\n  return u.length == 1 && u[0][2] ? matchesStrictComparable(u[0][0], u[0][1]) : function(c) {\n    return c === a || baseIsMatch(c, a, u);\n  };\n}\nfunction baseHasIn(a, u) {\n  return a != null && u in Object(a);\n}\nfunction hasPath(a, u, c) {\n  u = castPath(u, a);\n  for (var l = -1, v = u.length, S = !1; ++l < v; ) {\n    var g = toKey(u[l]);\n    if (!(S = a != null && c(a, g)))\n      break;\n    a = a[g];\n  }\n  return S || ++l != v ? S : (v = a == null ? 0 : a.length, !!v && isLength$1(v) && isIndex$1(g, v) && (isArray$5(a) || isArguments$1(a)));\n}\nfunction hasIn(a, u) {\n  return a != null && hasPath(a, u, baseHasIn);\n}\nvar COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;\nfunction baseMatchesProperty(a, u) {\n  return isKey(a) && isStrictComparable(u) ? matchesStrictComparable(toKey(a), u) : function(c) {\n    var l = get(c, a);\n    return l === void 0 && l === u ? hasIn(c, a) : baseIsEqual(u, l, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\nfunction baseProperty(a) {\n  return function(u) {\n    return u == null ? void 0 : u[a];\n  };\n}\nfunction basePropertyDeep(a) {\n  return function(u) {\n    return baseGet(u, a);\n  };\n}\nfunction property(a) {\n  return isKey(a) ? baseProperty(toKey(a)) : basePropertyDeep(a);\n}\nfunction baseIteratee(a) {\n  return typeof a == \"function\" ? a : a == null ? identity$1 : typeof a == \"object\" ? isArray$5(a) ? baseMatchesProperty(a[0], a[1]) : baseMatches(a) : property(a);\n}\nfunction createBaseFor(a) {\n  return function(u, c, l) {\n    for (var v = -1, S = Object(u), g = l(u), E = g.length; E--; ) {\n      var _ = g[a ? E : ++v];\n      if (c(S[_], _, S) === !1)\n        break;\n    }\n    return u;\n  };\n}\nvar baseFor = createBaseFor();\nconst baseFor$1 = baseFor;\nfunction baseForOwn(a, u) {\n  return a && baseFor$1(a, u, keys$2);\n}\nfunction createBaseEach(a, u) {\n  return function(c, l) {\n    if (c == null)\n      return c;\n    if (!isArrayLike$2(c))\n      return a(c, l);\n    for (var v = c.length, S = u ? v : -1, g = Object(c); (u ? S-- : ++S < v) && l(g[S], S, g) !== !1; )\n      ;\n    return c;\n  };\n}\nvar baseEach = createBaseEach(baseForOwn), now = function() {\n  return root.Date.now();\n}, FUNC_ERROR_TEXT$1 = \"Expected a function\", nativeMax$1 = Math.max, nativeMin = Math.min;\nfunction debounce$1(a, u, c) {\n  var l, v, S, g, E, _, k = 0, L = !1, M = !1, $ = !0;\n  if (typeof a != \"function\")\n    throw new TypeError(FUNC_ERROR_TEXT$1);\n  u = toNumber$3(u) || 0, isObject$9(c) && (L = !!c.leading, M = \"maxWait\" in c, S = M ? nativeMax$1(toNumber$3(c.maxWait) || 0, u) : S, $ = \"trailing\" in c ? !!c.trailing : $);\n  function J(re) {\n    var oe = l, de = v;\n    return l = v = void 0, k = re, g = a.apply(de, oe), g;\n  }\n  function V(re) {\n    return k = re, E = setTimeout(H, u), L ? J(re) : g;\n  }\n  function q(re) {\n    var oe = re - _, de = re - k, A = u - oe;\n    return M ? nativeMin(A, S - de) : A;\n  }\n  function G(re) {\n    var oe = re - _, de = re - k;\n    return _ === void 0 || oe >= u || oe < 0 || M && de >= S;\n  }\n  function H() {\n    var re = now();\n    if (G(re))\n      return B(re);\n    E = setTimeout(H, q(re));\n  }\n  function B(re) {\n    return E = void 0, $ && l ? J(re) : (l = v = void 0, g);\n  }\n  function Y() {\n    E !== void 0 && clearTimeout(E), k = 0, l = _ = v = E = void 0;\n  }\n  function ne() {\n    return E === void 0 ? g : B(now());\n  }\n  function Z() {\n    var re = now(), oe = G(re);\n    if (l = arguments, v = this, _ = re, oe) {\n      if (E === void 0)\n        return V(_);\n      if (M)\n        return clearTimeout(E), E = setTimeout(H, u), J(_);\n    }\n    return E === void 0 && (E = setTimeout(H, u)), g;\n  }\n  return Z.cancel = Y, Z.flush = ne, Z;\n}\nfunction last$1(a) {\n  var u = a == null ? 0 : a.length;\n  return u ? a[u - 1] : void 0;\n}\nfunction arrayEvery(a, u) {\n  for (var c = -1, l = a == null ? 0 : a.length; ++c < l; )\n    if (!u(a[c], c, a))\n      return !1;\n  return !0;\n}\nfunction baseEvery(a, u) {\n  var c = !0;\n  return baseEach(a, function(l, v, S) {\n    return c = !!u(l, v, S), c;\n  }), c;\n}\nfunction every$1(a, u, c) {\n  var l = isArray$5(a) ? arrayEvery : baseEvery;\n  return c && isIterateeCall(a, u, c) && (u = void 0), l(a, baseIteratee(u));\n}\nfunction baseMap(a, u) {\n  var c = -1, l = isArrayLike$2(a) ? Array(a.length) : [];\n  return baseEach(a, function(v, S, g) {\n    l[++c] = u(v, S, g);\n  }), l;\n}\nfunction parent(a, u) {\n  return u.length < 2 ? a : baseGet(a, baseSlice(u, 0, -1));\n}\nfunction isEqual(a, u) {\n  return baseIsEqual(a, u);\n}\nfunction isMatch(a, u) {\n  return a === u || baseIsMatch(a, u, getMatchData(u));\n}\nvar CLONE_DEEP_FLAG$1 = 1;\nfunction iteratee(a) {\n  return baseIteratee(typeof a == \"function\" ? a : baseClone(a, CLONE_DEEP_FLAG$1));\n}\nvar kebabCase = createCompounder(function(a, u, c) {\n  return a + (c ? \"-\" : \"\") + u.toLowerCase();\n});\nconst kebabCase$1 = kebabCase;\nfunction baseUnset(a, u) {\n  return u = castPath(u, a), a = parent(a, u), a == null || delete a[toKey(last$1(u))];\n}\nfunction customOmitClone(a) {\n  return isPlainObject$3(a) ? void 0 : a;\n}\nvar CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, omit = flatRest(function(a, u) {\n  var c = {};\n  if (a == null)\n    return c;\n  var l = !1;\n  u = arrayMap$1(u, function(S) {\n    return S = castPath(S, a), l || (l = S.length > 1), S;\n  }), copyObject(a, getAllKeysIn(a), c), l && (c = baseClone(c, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));\n  for (var v = u.length; v--; )\n    baseUnset(c, u[v]);\n  return c;\n});\nfunction baseSet(a, u, c, l) {\n  if (!isObject$9(a))\n    return a;\n  u = castPath(u, a);\n  for (var v = -1, S = u.length, g = S - 1, E = a; E != null && ++v < S; ) {\n    var _ = toKey(u[v]), k = c;\n    if (_ === \"__proto__\" || _ === \"constructor\" || _ === \"prototype\")\n      return a;\n    if (v != g) {\n      var L = E[_];\n      k = l ? l(L, _, E) : void 0, k === void 0 && (k = isObject$9(L) ? L : isIndex$1(u[v + 1]) ? [] : {});\n    }\n    assignValue(E, _, k), E = E[_];\n  }\n  return a;\n}\nfunction basePickBy(a, u, c) {\n  for (var l = -1, v = u.length, S = {}; ++l < v; ) {\n    var g = u[l], E = baseGet(a, g);\n    c(E, g) && baseSet(S, castPath(g, a), E);\n  }\n  return S;\n}\nfunction baseSortBy(a, u) {\n  var c = a.length;\n  for (a.sort(u); c--; )\n    a[c] = a[c].value;\n  return a;\n}\nfunction compareAscending(a, u) {\n  if (a !== u) {\n    var c = a !== void 0, l = a === null, v = a === a, S = isSymbol$3(a), g = u !== void 0, E = u === null, _ = u === u, k = isSymbol$3(u);\n    if (!E && !k && !S && a > u || S && g && _ && !E && !k || l && g && _ || !c && _ || !v)\n      return 1;\n    if (!l && !S && !k && a < u || k && c && v && !l && !S || E && c && v || !g && v || !_)\n      return -1;\n  }\n  return 0;\n}\nfunction compareMultiple(a, u, c) {\n  for (var l = -1, v = a.criteria, S = u.criteria, g = v.length, E = c.length; ++l < g; ) {\n    var _ = compareAscending(v[l], S[l]);\n    if (_) {\n      if (l >= E)\n        return _;\n      var k = c[l];\n      return _ * (k == \"desc\" ? -1 : 1);\n    }\n  }\n  return a.index - u.index;\n}\nfunction baseOrderBy(a, u, c) {\n  u.length ? u = arrayMap$1(u, function(S) {\n    return isArray$5(S) ? function(g) {\n      return baseGet(g, S.length === 1 ? S[0] : S);\n    } : S;\n  }) : u = [identity$1];\n  var l = -1;\n  u = arrayMap$1(u, baseUnary(baseIteratee));\n  var v = baseMap(a, function(S, g, E) {\n    var _ = arrayMap$1(u, function(k) {\n      return k(S);\n    });\n    return { criteria: _, index: ++l, value: S };\n  });\n  return baseSortBy(v, function(S, g) {\n    return compareMultiple(S, g, c);\n  });\n}\nfunction basePick(a, u) {\n  return basePickBy(a, u, function(c, l) {\n    return hasIn(a, l);\n  });\n}\nvar pick = flatRest(function(a, u) {\n  return a == null ? {} : basePick(a, u);\n});\nconst pick$1 = pick;\nfunction baseIndexOfWith(a, u, c, l) {\n  for (var v = c - 1, S = a.length; ++v < S; )\n    if (l(a[v], u))\n      return v;\n  return -1;\n}\nvar arrayProto = Array.prototype, splice = arrayProto.splice;\nfunction basePullAll(a, u, c, l) {\n  var v = l ? baseIndexOfWith : baseIndexOf$1, S = -1, g = u.length, E = a;\n  for (a === u && (u = copyArray(u)), c && (E = arrayMap$1(a, baseUnary(c))); ++S < g; )\n    for (var _ = 0, k = u[S], L = c ? c(k) : k; (_ = v(E, L, _, l)) > -1; )\n      E !== a && splice.call(E, _, 1), splice.call(a, _, 1);\n  return a;\n}\nfunction pullAll(a, u) {\n  return a && a.length && u && u.length ? basePullAll(a, u) : a;\n}\nvar pull$1 = baseRest(pullAll), sortBy = baseRest(function(a, u) {\n  if (a == null)\n    return [];\n  var c = u.length;\n  return c > 1 && isIterateeCall(a, u[0], u[1]) ? u = [] : c > 2 && isIterateeCall(u[0], u[1], u[2]) && (u = [u[0]]), baseOrderBy(a, baseFlatten(u, 1), []);\n});\nconst sortBy$1 = sortBy, convert = (\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  /**\n   * @param {Test} [test]\n   * @returns {Check}\n   */\n  function(a) {\n    if (a == null)\n      return ok;\n    if (typeof a == \"function\")\n      return castFactory(a);\n    if (typeof a == \"object\")\n      return Array.isArray(a) ? anyFactory(a) : propsFactory(a);\n    if (typeof a == \"string\")\n      return typeFactory(a);\n    throw new Error(\"Expected function, string, or object as test\");\n  }\n);\nfunction anyFactory(a) {\n  const u = [];\n  let c = -1;\n  for (; ++c < a.length; )\n    u[c] = convert(a[c]);\n  return castFactory(l);\n  function l(...v) {\n    let S = -1;\n    for (; ++S < u.length; )\n      if (u[S].apply(this, v))\n        return !0;\n    return !1;\n  }\n}\nfunction propsFactory(a) {\n  const u = (\n    /** @type {Record<string, unknown>} */\n    a\n  );\n  return castFactory(c);\n  function c(l) {\n    const v = (\n      /** @type {Record<string, unknown>} */\n      /** @type {unknown} */\n      l\n    );\n    let S;\n    for (S in a)\n      if (v[S] !== u[S])\n        return !1;\n    return !0;\n  }\n}\nfunction typeFactory(a) {\n  return castFactory(u);\n  function u(c) {\n    return c && c.type === a;\n  }\n}\nfunction castFactory(a) {\n  return u;\n  function u(c, l, v) {\n    return !!(looksLikeANode(c) && a.call(\n      this,\n      c,\n      typeof l == \"number\" ? l : void 0,\n      v || void 0\n    ));\n  }\n}\nfunction ok() {\n  return !0;\n}\nfunction looksLikeANode(a) {\n  return a !== null && typeof a == \"object\" && \"type\" in a;\n}\nfunction color$1(a) {\n  return a;\n}\nconst empty$3 = [], CONTINUE = !0, EXIT = !1, SKIP = \"skip\";\nfunction visitParents(a, u, c, l) {\n  let v;\n  typeof u == \"function\" && typeof c != \"function\" ? (l = c, c = u) : v = u;\n  const S = convert(v), g = l ? -1 : 1;\n  E(a, void 0, [])();\n  function E(_, k, L) {\n    const M = (\n      /** @type {Record<string, unknown>} */\n      _ && typeof _ == \"object\" ? _ : {}\n    );\n    if (typeof M.type == \"string\") {\n      const J = (\n        // `hast`\n        typeof M.tagName == \"string\" ? M.tagName : (\n          // `xast`\n          typeof M.name == \"string\" ? M.name : void 0\n        )\n      );\n      Object.defineProperty($, \"name\", {\n        value: \"node (\" + (_.type + (J ? \"<\" + J + \">\" : \"\")) + \")\"\n      });\n    }\n    return $;\n    function $() {\n      let J = empty$3, V, q, G;\n      if ((!u || S(_, k, L[L.length - 1] || void 0)) && (J = toResult(c(_, L)), J[0] === EXIT))\n        return J;\n      if (\"children\" in _ && _.children) {\n        const H = (\n          /** @type {UnistParent} */\n          _\n        );\n        if (H.children && J[0] !== SKIP)\n          for (q = (l ? H.children.length : -1) + g, G = L.concat(H); q > -1 && q < H.children.length; ) {\n            const B = H.children[q];\n            if (V = E(B, q, G)(), V[0] === EXIT)\n              return V;\n            q = typeof V[1] == \"number\" ? V[1] : q + g;\n          }\n      }\n      return J;\n    }\n  }\n}\nfunction toResult(a) {\n  return Array.isArray(a) ? a : typeof a == \"number\" ? [CONTINUE, a] : a == null ? empty$3 : [a];\n}\nfunction visit(a, u, c, l) {\n  let v, S, g;\n  typeof u == \"function\" && typeof c != \"function\" ? (S = void 0, g = u, v = c) : (S = u, g = c, v = l), visitParents(a, S, E, v);\n  function E(_, k) {\n    const L = k[k.length - 1], M = L ? L.children.indexOf(_) : void 0;\n    return g(_, M, L);\n  }\n}\nvar fastDeepEqual = function a(u, c) {\n  if (u === c)\n    return !0;\n  if (u && c && typeof u == \"object\" && typeof c == \"object\") {\n    if (u.constructor !== c.constructor)\n      return !1;\n    var l, v, S;\n    if (Array.isArray(u)) {\n      if (l = u.length, l != c.length)\n        return !1;\n      for (v = l; v-- !== 0; )\n        if (!a(u[v], c[v]))\n          return !1;\n      return !0;\n    }\n    if (u.constructor === RegExp)\n      return u.source === c.source && u.flags === c.flags;\n    if (u.valueOf !== Object.prototype.valueOf)\n      return u.valueOf() === c.valueOf();\n    if (u.toString !== Object.prototype.toString)\n      return u.toString() === c.toString();\n    if (S = Object.keys(u), l = S.length, l !== Object.keys(c).length)\n      return !1;\n    for (v = l; v-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(c, S[v]))\n        return !1;\n    for (v = l; v-- !== 0; ) {\n      var g = S[v];\n      if (!a(u[g], c[g]))\n        return !1;\n    }\n    return !0;\n  }\n  return u !== u && c !== c;\n};\nconst deepEqual = /* @__PURE__ */ getDefaultExportFromCjs$1(fastDeepEqual), generateId = () => (Math.random() * 1e20).toString(36), insertAt$1 = (a = 0, u, c, l = !1) => [...c.slice(0, a), ...[u].flat(), ...c.slice(l ? a + 1 : a)], replaceItem$1 = (a, u, c) => {\n  a = typeof a == \"function\" ? a : (v) => v === a;\n  const l = c.findIndex(a);\n  return l < 0 ? c : insertAt$1(l, u, c, !0);\n}, swapIndex = (a, u, c) => {\n  if (!c[a] || !c[u])\n    return c;\n  c = [...c];\n  const l = c[a];\n  return c[a] = c[u], c[u] = l, c;\n}, swapItems = (a, u, c) => {\n  const l = c.findIndex((S) => S === a), v = c.findIndex((S) => S === u);\n  return l < 0 || v < 0 ? c : swapIndex(l, v, c);\n}, toDataNode$1 = (a) => a ? {\n  id: a.id,\n  props: a.props,\n  childIds: (a.children || []).map((u) => u.id)\n} : null, toSceneNode = (a) => ({\n  id: a.id,\n  props: a.props,\n  children: []\n}), toSceneTree = (a, u) => {\n  const c = a.find((v) => v.id === u);\n  if (!c)\n    return null;\n  const l = c.childIds;\n  return {\n    id: c.id,\n    props: c.props,\n    children: l.map((v) => toSceneTree(a, v)).filter(Boolean)\n  };\n}, forEachDown$1 = (a, u) => {\n  u(a), (a.children || []).forEach((l) => forEachDown$1(l, (v, S) => {\n    u(v, S || a);\n  }));\n}, mapDown = (a, u) => {\n  const c = u(a);\n  return {\n    ...c,\n    children: ((c == null ? void 0 : c.children) || (a == null ? void 0 : a.children) || []).map((l) => mapDown(l, u))\n  };\n}, mapDownAsync = async (a, u) => {\n  const c = (a == null ? void 0 : a.children) ?? [];\n  return {\n    ...await u(a),\n    children: await Promise.all(c.map((l) => mapDownAsync(l, u)))\n  };\n}, getElementAttributes = (a) => Object.values(a.attributes).reduce((u, c) => ({\n  ...u,\n  [c.name]: c.value\n}), {}), asArray = (a) => isArray$5(a) ? a : [a], sizeToNum = (a, u) => typeof a == \"number\" ? a : typeof a == \"string\" ? a.indexOf(\"%\") > -1 ? parseFloat(a) / 100 * u : parseFloat(a) : 0, asSize = (a) => typeof a == \"number\" ? a + \"px\" : typeof a == \"string\" ? a.indexOf(\"%\") > -1 ? parseFloat(a) + \"%\" : a : \"0px\", asDuration = (a) => typeof a == \"string\" ? a : typeof a == \"number\" ? a + \"ms\" : \"0ms\", find$2 = (a, u) => {\n  if (!a)\n    throw new Error(\"requires a tree to search\");\n  if (!u)\n    throw new Error(\"requires a condition\");\n  const c = iteratee(u);\n  let l;\n  return visit(a, function(v) {\n    if (c(v))\n      return l = v, !1;\n  }), l;\n}, findAll = (a, u) => {\n  if (!a)\n    throw new Error(\"requires a tree to search\");\n  if (!u)\n    throw new Error(\"requires a condition\");\n  const c = iteratee(u);\n  let l = [];\n  return visit(a, function(v) {\n    c(v) && l.push(v);\n  }), l;\n}, values$1 = (a) => Array.from(a.values()), Logic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  asArray,\n  asDuration,\n  asSize,\n  camelCase: camelCase$3,\n  cloneDeep: cloneDeep$1,\n  debounce: debounce$1,\n  deepEqual,\n  every: every$1,\n  find: find$2,\n  findAll,\n  forEachDown: forEachDown$1,\n  generateId,\n  getElementAttributes,\n  insertAt: insertAt$1,\n  isArray: isArray$5,\n  isEqual,\n  kebabCase: kebabCase$1,\n  mapDown,\n  mapDownAsync,\n  omit,\n  pick: pick$1,\n  pull: pull$1,\n  replaceItem: replaceItem$1,\n  sizeToNum,\n  sortBy: sortBy$1,\n  swapIndex,\n  swapItems,\n  toDataNode: toDataNode$1,\n  toSceneNode,\n  toSceneTree,\n  values: values$1\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar lib$2 = {};\nfunction e(a) {\n  this.message = a;\n}\ne.prototype = new Error(), e.prototype.name = \"InvalidCharacterError\";\nvar r$1 = typeof window < \"u\" && window.atob && window.atob.bind(window) || function(a) {\n  var u = String(a).replace(/=+$/, \"\");\n  if (u.length % 4 == 1)\n    throw new e(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n  for (var c, l, v = 0, S = 0, g = \"\"; l = u.charAt(S++); ~l && (c = v % 4 ? 64 * c + l : l, v++ % 4) ? g += String.fromCharCode(255 & c >> (-2 * v & 6)) : 0)\n    l = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(l);\n  return g;\n};\nfunction t(a) {\n  var u = a.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  switch (u.length % 4) {\n    case 0:\n      break;\n    case 2:\n      u += \"==\";\n      break;\n    case 3:\n      u += \"=\";\n      break;\n    default:\n      throw \"Illegal base64url string!\";\n  }\n  try {\n    return function(c) {\n      return decodeURIComponent(r$1(c).replace(/(.)/g, function(l, v) {\n        var S = v.charCodeAt(0).toString(16).toUpperCase();\n        return S.length < 2 && (S = \"0\" + S), \"%\" + S;\n      }));\n    }(u);\n  } catch {\n    return r$1(u);\n  }\n}\nfunction n(a) {\n  this.message = a;\n}\nfunction o(a, u) {\n  if (typeof a != \"string\")\n    throw new n(\"Invalid token specified\");\n  var c = (u = u || {}).header === !0 ? 0 : 1;\n  try {\n    return JSON.parse(t(a.split(\".\")[c]));\n  } catch (l) {\n    throw new n(\"Invalid token specified: \" + l.message);\n  }\n}\nn.prototype = new Error(), n.prototype.name = \"InvalidTokenError\";\nconst jwtDecode_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  InvalidTokenError: n,\n  default: o\n}, Symbol.toStringTag, { value: \"Module\" })), require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(jwtDecode_esm);\nvar getRandomValues, rnds8 = new Uint8Array(16);\nfunction rng() {\n  if (!getRandomValues && (getRandomValues = typeof crypto < \"u\" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < \"u\" && typeof msCrypto.getRandomValues == \"function\" && msCrypto.getRandomValues.bind(msCrypto), !getRandomValues))\n    throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n  return getRandomValues(rnds8);\n}\nconst REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nfunction validate$2(a) {\n  return typeof a == \"string\" && REGEX.test(a);\n}\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i)\n  byteToHex.push((i + 256).toString(16).substr(1));\nfunction stringify(a) {\n  var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, c = (byteToHex[a[u + 0]] + byteToHex[a[u + 1]] + byteToHex[a[u + 2]] + byteToHex[a[u + 3]] + \"-\" + byteToHex[a[u + 4]] + byteToHex[a[u + 5]] + \"-\" + byteToHex[a[u + 6]] + byteToHex[a[u + 7]] + \"-\" + byteToHex[a[u + 8]] + byteToHex[a[u + 9]] + \"-\" + byteToHex[a[u + 10]] + byteToHex[a[u + 11]] + byteToHex[a[u + 12]] + byteToHex[a[u + 13]] + byteToHex[a[u + 14]] + byteToHex[a[u + 15]]).toLowerCase();\n  if (!validate$2(c))\n    throw TypeError(\"Stringified UUID is invalid\");\n  return c;\n}\nvar _nodeId, _clockseq, _lastMSecs = 0, _lastNSecs = 0;\nfunction v1(a, u, c) {\n  var l = u && c || 0, v = u || new Array(16);\n  a = a || {};\n  var S = a.node || _nodeId, g = a.clockseq !== void 0 ? a.clockseq : _clockseq;\n  if (S == null || g == null) {\n    var E = a.random || (a.rng || rng)();\n    S == null && (S = _nodeId = [E[0] | 1, E[1], E[2], E[3], E[4], E[5]]), g == null && (g = _clockseq = (E[6] << 8 | E[7]) & 16383);\n  }\n  var _ = a.msecs !== void 0 ? a.msecs : Date.now(), k = a.nsecs !== void 0 ? a.nsecs : _lastNSecs + 1, L = _ - _lastMSecs + (k - _lastNSecs) / 1e4;\n  if (L < 0 && a.clockseq === void 0 && (g = g + 1 & 16383), (L < 0 || _ > _lastMSecs) && a.nsecs === void 0 && (k = 0), k >= 1e4)\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  _lastMSecs = _, _lastNSecs = k, _clockseq = g, _ += 122192928e5;\n  var M = ((_ & 268435455) * 1e4 + k) % 4294967296;\n  v[l++] = M >>> 24 & 255, v[l++] = M >>> 16 & 255, v[l++] = M >>> 8 & 255, v[l++] = M & 255;\n  var $ = _ / 4294967296 * 1e4 & 268435455;\n  v[l++] = $ >>> 8 & 255, v[l++] = $ & 255, v[l++] = $ >>> 24 & 15 | 16, v[l++] = $ >>> 16 & 255, v[l++] = g >>> 8 | 128, v[l++] = g & 255;\n  for (var J = 0; J < 6; ++J)\n    v[l + J] = S[J];\n  return u || stringify(v);\n}\nfunction parse$3(a) {\n  if (!validate$2(a))\n    throw TypeError(\"Invalid UUID\");\n  var u, c = new Uint8Array(16);\n  return c[0] = (u = parseInt(a.slice(0, 8), 16)) >>> 24, c[1] = u >>> 16 & 255, c[2] = u >>> 8 & 255, c[3] = u & 255, c[4] = (u = parseInt(a.slice(9, 13), 16)) >>> 8, c[5] = u & 255, c[6] = (u = parseInt(a.slice(14, 18), 16)) >>> 8, c[7] = u & 255, c[8] = (u = parseInt(a.slice(19, 23), 16)) >>> 8, c[9] = u & 255, c[10] = (u = parseInt(a.slice(24, 36), 16)) / 1099511627776 & 255, c[11] = u / 4294967296 & 255, c[12] = u >>> 24 & 255, c[13] = u >>> 16 & 255, c[14] = u >>> 8 & 255, c[15] = u & 255, c;\n}\nfunction stringToBytes(a) {\n  a = unescape(encodeURIComponent(a));\n  for (var u = [], c = 0; c < a.length; ++c)\n    u.push(a.charCodeAt(c));\n  return u;\n}\nvar DNS = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\", URL$1 = \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\";\nfunction v35(a, u, c) {\n  function l(v, S, g, E) {\n    if (typeof v == \"string\" && (v = stringToBytes(v)), typeof S == \"string\" && (S = parse$3(S)), S.length !== 16)\n      throw TypeError(\"Namespace must be array-like (16 iterable integer values, 0-255)\");\n    var _ = new Uint8Array(16 + v.length);\n    if (_.set(S), _.set(v, S.length), _ = c(_), _[6] = _[6] & 15 | u, _[8] = _[8] & 63 | 128, g) {\n      E = E || 0;\n      for (var k = 0; k < 16; ++k)\n        g[E + k] = _[k];\n      return g;\n    }\n    return stringify(_);\n  }\n  try {\n    l.name = a;\n  } catch {\n  }\n  return l.DNS = DNS, l.URL = URL$1, l;\n}\nfunction md5(a) {\n  if (typeof a == \"string\") {\n    var u = unescape(encodeURIComponent(a));\n    a = new Uint8Array(u.length);\n    for (var c = 0; c < u.length; ++c)\n      a[c] = u.charCodeAt(c);\n  }\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(a), a.length * 8));\n}\nfunction md5ToHexEncodedArray(a) {\n  for (var u = [], c = a.length * 32, l = \"0123456789abcdef\", v = 0; v < c; v += 8) {\n    var S = a[v >> 5] >>> v % 32 & 255, g = parseInt(l.charAt(S >>> 4 & 15) + l.charAt(S & 15), 16);\n    u.push(g);\n  }\n  return u;\n}\nfunction getOutputLength(a) {\n  return (a + 64 >>> 9 << 4) + 14 + 1;\n}\nfunction wordsToMd5(a, u) {\n  a[u >> 5] |= 128 << u % 32, a[getOutputLength(u) - 1] = u;\n  for (var c = 1732584193, l = -271733879, v = -1732584194, S = 271733878, g = 0; g < a.length; g += 16) {\n    var E = c, _ = l, k = v, L = S;\n    c = md5ff(c, l, v, S, a[g], 7, -680876936), S = md5ff(S, c, l, v, a[g + 1], 12, -389564586), v = md5ff(v, S, c, l, a[g + 2], 17, 606105819), l = md5ff(l, v, S, c, a[g + 3], 22, -1044525330), c = md5ff(c, l, v, S, a[g + 4], 7, -176418897), S = md5ff(S, c, l, v, a[g + 5], 12, 1200080426), v = md5ff(v, S, c, l, a[g + 6], 17, -1473231341), l = md5ff(l, v, S, c, a[g + 7], 22, -45705983), c = md5ff(c, l, v, S, a[g + 8], 7, 1770035416), S = md5ff(S, c, l, v, a[g + 9], 12, -1958414417), v = md5ff(v, S, c, l, a[g + 10], 17, -42063), l = md5ff(l, v, S, c, a[g + 11], 22, -1990404162), c = md5ff(c, l, v, S, a[g + 12], 7, 1804603682), S = md5ff(S, c, l, v, a[g + 13], 12, -40341101), v = md5ff(v, S, c, l, a[g + 14], 17, -1502002290), l = md5ff(l, v, S, c, a[g + 15], 22, 1236535329), c = md5gg(c, l, v, S, a[g + 1], 5, -165796510), S = md5gg(S, c, l, v, a[g + 6], 9, -1069501632), v = md5gg(v, S, c, l, a[g + 11], 14, 643717713), l = md5gg(l, v, S, c, a[g], 20, -373897302), c = md5gg(c, l, v, S, a[g + 5], 5, -701558691), S = md5gg(S, c, l, v, a[g + 10], 9, 38016083), v = md5gg(v, S, c, l, a[g + 15], 14, -660478335), l = md5gg(l, v, S, c, a[g + 4], 20, -405537848), c = md5gg(c, l, v, S, a[g + 9], 5, 568446438), S = md5gg(S, c, l, v, a[g + 14], 9, -1019803690), v = md5gg(v, S, c, l, a[g + 3], 14, -187363961), l = md5gg(l, v, S, c, a[g + 8], 20, 1163531501), c = md5gg(c, l, v, S, a[g + 13], 5, -1444681467), S = md5gg(S, c, l, v, a[g + 2], 9, -51403784), v = md5gg(v, S, c, l, a[g + 7], 14, 1735328473), l = md5gg(l, v, S, c, a[g + 12], 20, -1926607734), c = md5hh(c, l, v, S, a[g + 5], 4, -378558), S = md5hh(S, c, l, v, a[g + 8], 11, -2022574463), v = md5hh(v, S, c, l, a[g + 11], 16, 1839030562), l = md5hh(l, v, S, c, a[g + 14], 23, -35309556), c = md5hh(c, l, v, S, a[g + 1], 4, -1530992060), S = md5hh(S, c, l, v, a[g + 4], 11, 1272893353), v = md5hh(v, S, c, l, a[g + 7], 16, -155497632), l = md5hh(l, v, S, c, a[g + 10], 23, -1094730640), c = md5hh(c, l, v, S, a[g + 13], 4, 681279174), S = md5hh(S, c, l, v, a[g], 11, -358537222), v = md5hh(v, S, c, l, a[g + 3], 16, -722521979), l = md5hh(l, v, S, c, a[g + 6], 23, 76029189), c = md5hh(c, l, v, S, a[g + 9], 4, -640364487), S = md5hh(S, c, l, v, a[g + 12], 11, -421815835), v = md5hh(v, S, c, l, a[g + 15], 16, 530742520), l = md5hh(l, v, S, c, a[g + 2], 23, -995338651), c = md5ii(c, l, v, S, a[g], 6, -198630844), S = md5ii(S, c, l, v, a[g + 7], 10, 1126891415), v = md5ii(v, S, c, l, a[g + 14], 15, -1416354905), l = md5ii(l, v, S, c, a[g + 5], 21, -57434055), c = md5ii(c, l, v, S, a[g + 12], 6, 1700485571), S = md5ii(S, c, l, v, a[g + 3], 10, -1894986606), v = md5ii(v, S, c, l, a[g + 10], 15, -1051523), l = md5ii(l, v, S, c, a[g + 1], 21, -2054922799), c = md5ii(c, l, v, S, a[g + 8], 6, 1873313359), S = md5ii(S, c, l, v, a[g + 15], 10, -30611744), v = md5ii(v, S, c, l, a[g + 6], 15, -1560198380), l = md5ii(l, v, S, c, a[g + 13], 21, 1309151649), c = md5ii(c, l, v, S, a[g + 4], 6, -145523070), S = md5ii(S, c, l, v, a[g + 11], 10, -1120210379), v = md5ii(v, S, c, l, a[g + 2], 15, 718787259), l = md5ii(l, v, S, c, a[g + 9], 21, -343485551), c = safeAdd(c, E), l = safeAdd(l, _), v = safeAdd(v, k), S = safeAdd(S, L);\n  }\n  return [c, l, v, S];\n}\nfunction bytesToWords(a) {\n  if (a.length === 0)\n    return [];\n  for (var u = a.length * 8, c = new Uint32Array(getOutputLength(u)), l = 0; l < u; l += 8)\n    c[l >> 5] |= (a[l / 8] & 255) << l % 32;\n  return c;\n}\nfunction safeAdd(a, u) {\n  var c = (a & 65535) + (u & 65535), l = (a >> 16) + (u >> 16) + (c >> 16);\n  return l << 16 | c & 65535;\n}\nfunction bitRotateLeft(a, u) {\n  return a << u | a >>> 32 - u;\n}\nfunction md5cmn(a, u, c, l, v, S) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(u, a), safeAdd(l, S)), v), c);\n}\nfunction md5ff(a, u, c, l, v, S, g) {\n  return md5cmn(u & c | ~u & l, a, u, v, S, g);\n}\nfunction md5gg(a, u, c, l, v, S, g) {\n  return md5cmn(u & l | c & ~l, a, u, v, S, g);\n}\nfunction md5hh(a, u, c, l, v, S, g) {\n  return md5cmn(u ^ c ^ l, a, u, v, S, g);\n}\nfunction md5ii(a, u, c, l, v, S, g) {\n  return md5cmn(c ^ (u | ~l), a, u, v, S, g);\n}\nvar v3 = v35(\"v3\", 48, md5);\nconst v3$1 = v3;\nfunction v4(a, u, c) {\n  a = a || {};\n  var l = a.random || (a.rng || rng)();\n  if (l[6] = l[6] & 15 | 64, l[8] = l[8] & 63 | 128, u) {\n    c = c || 0;\n    for (var v = 0; v < 16; ++v)\n      u[c + v] = l[v];\n    return u;\n  }\n  return stringify(l);\n}\nfunction f(a, u, c, l) {\n  switch (a) {\n    case 0:\n      return u & c ^ ~u & l;\n    case 1:\n      return u ^ c ^ l;\n    case 2:\n      return u & c ^ u & l ^ c & l;\n    case 3:\n      return u ^ c ^ l;\n  }\n}\nfunction ROTL(a, u) {\n  return a << u | a >>> 32 - u;\n}\nfunction sha1(a) {\n  var u = [1518500249, 1859775393, 2400959708, 3395469782], c = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];\n  if (typeof a == \"string\") {\n    var l = unescape(encodeURIComponent(a));\n    a = [];\n    for (var v = 0; v < l.length; ++v)\n      a.push(l.charCodeAt(v));\n  } else\n    Array.isArray(a) || (a = Array.prototype.slice.call(a));\n  a.push(128);\n  for (var S = a.length / 4 + 2, g = Math.ceil(S / 16), E = new Array(g), _ = 0; _ < g; ++_) {\n    for (var k = new Uint32Array(16), L = 0; L < 16; ++L)\n      k[L] = a[_ * 64 + L * 4] << 24 | a[_ * 64 + L * 4 + 1] << 16 | a[_ * 64 + L * 4 + 2] << 8 | a[_ * 64 + L * 4 + 3];\n    E[_] = k;\n  }\n  E[g - 1][14] = (a.length - 1) * 8 / Math.pow(2, 32), E[g - 1][14] = Math.floor(E[g - 1][14]), E[g - 1][15] = (a.length - 1) * 8 & 4294967295;\n  for (var M = 0; M < g; ++M) {\n    for (var $ = new Uint32Array(80), J = 0; J < 16; ++J)\n      $[J] = E[M][J];\n    for (var V = 16; V < 80; ++V)\n      $[V] = ROTL($[V - 3] ^ $[V - 8] ^ $[V - 14] ^ $[V - 16], 1);\n    for (var q = c[0], G = c[1], H = c[2], B = c[3], Y = c[4], ne = 0; ne < 80; ++ne) {\n      var Z = Math.floor(ne / 20), re = ROTL(q, 5) + f(Z, G, H, B) + Y + u[Z] + $[ne] >>> 0;\n      Y = B, B = H, H = ROTL(G, 30) >>> 0, G = q, q = re;\n    }\n    c[0] = c[0] + q >>> 0, c[1] = c[1] + G >>> 0, c[2] = c[2] + H >>> 0, c[3] = c[3] + B >>> 0, c[4] = c[4] + Y >>> 0;\n  }\n  return [c[0] >> 24 & 255, c[0] >> 16 & 255, c[0] >> 8 & 255, c[0] & 255, c[1] >> 24 & 255, c[1] >> 16 & 255, c[1] >> 8 & 255, c[1] & 255, c[2] >> 24 & 255, c[2] >> 16 & 255, c[2] >> 8 & 255, c[2] & 255, c[3] >> 24 & 255, c[3] >> 16 & 255, c[3] >> 8 & 255, c[3] & 255, c[4] >> 24 & 255, c[4] >> 16 & 255, c[4] >> 8 & 255, c[4] & 255];\n}\nvar v5 = v35(\"v5\", 80, sha1);\nconst v5$1 = v5, nil = \"00000000-0000-0000-0000-000000000000\";\nfunction version$4(a) {\n  if (!validate$2(a))\n    throw TypeError(\"Invalid UUID\");\n  return parseInt(a.substr(14, 1), 16);\n}\nconst esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  NIL: nil,\n  parse: parse$3,\n  stringify,\n  v1,\n  v3: v3$1,\n  v4,\n  v5: v5$1,\n  validate: validate$2,\n  version: version$4\n}, Symbol.toStringTag, { value: \"Module\" })), require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser);\nlet EnhancedMap$1 = class extends Map {\n  /**\n   * If key has a mapping already returns the currently associated value. If\n   * there is no mapping, calls the computer which must return a value V.\n   * The value is then stored for given key and returned.\n   * @param key Key\n   * @param computer Computer which is called only if key has no mapping yet.\n   * @return Existing value if the key already existed, or the newly computed value.\n   */\n  computeIfAbsent(u, c) {\n    if (this.has(u))\n      return this.get(u);\n    const l = c(u);\n    return this.set(u, l), l;\n  }\n  /**\n   * If the key exists already calls given computer, if the key does not exist\n   * this method does nothing.\n   *\n   * The computer is called with current key and current value associated. The\n   * computer can return a (new) value V or undefined. When undefined is returned\n   * the key is removed from this map, when a V is returned the key is updated\n   * with the new value V.\n   * @param key Key\n   * @param computer Computer which is called only if the key has a mapping already\n   * @return Undefined if the key has no mapping, otherwise the value returned from computer\n   */\n  computeIfPresent(u, c) {\n    const l = this.get(u);\n    if (l === void 0)\n      return;\n    const v = c(u, l);\n    return v !== void 0 ? this.set(u, v) : this.delete(u), v;\n  }\n  /**\n   * Computes a value for given key, the computer can return a value V (in which case the map\n   * will set the value for given key), if it returns undefined the mapping for key K will be\n   * removed.\n   * @param key Key to compute\n   * @param computer Computer which is called, note that the currentValue argument contains the existing\n   *                 value or is undefined when no mapping exists for the key.\n   * @return The newly computed value\n   */\n  compute(u, c) {\n    const l = this.get(u), v = c(u, l);\n    return v ? this.set(u, v) : this.delete(u), v;\n  }\n};\nvar InternalLogLevel$1;\n(function(a) {\n  a[a.Trace = 0] = \"Trace\", a[a.Debug = 1] = \"Debug\", a[a.Info = 2] = \"Info\", a[a.Warn = 3] = \"Warn\", a[a.Error = 4] = \"Error\";\n})(InternalLogLevel$1 || (InternalLogLevel$1 = {}));\nfunction getInternalLogger$1(a) {\n  return provider$1.getLogger(a);\n}\nconst INTERNAL_LOGGING_SETTINGS$1 = {\n  /**\n   * Changes the log level for the internal logging (for all new and existing loggers)\n   * @param level New log level\n   */\n  setInternalLogLevel: (a) => provider$1.changeLogLevel(a),\n  /**\n   * Changes where messages are written to for all new and existing loggers),\n   * by default they are written to the console.\n   * @param fnOutput Function to write messages to\n   */\n  setOutput: (a) => provider$1.changeOutput(a),\n  /**\n   * Resets the log level and output back to defaults (level to error and writing to console)\n   * for all new and existing loggers.\n   */\n  reset: () => provider$1.reset()\n};\nlet InternalLoggerImpl$1 = class {\n  constructor(u, c, l) {\n    this._name = u, this._level = c, this._fnOutput = l;\n  }\n  trace(u) {\n    this.log(InternalLogLevel$1.Trace, u);\n  }\n  debug(u) {\n    this.log(InternalLogLevel$1.Debug, u);\n  }\n  error(u, c) {\n    this.log(InternalLogLevel$1.Error, u, c);\n  }\n  info(u) {\n    this.log(InternalLogLevel$1.Info, u);\n  }\n  warn(u, c) {\n    this.log(InternalLogLevel$1.Warn, u, c);\n  }\n  setLevel(u) {\n    this._level = u;\n  }\n  setOutput(u) {\n    this._fnOutput = u;\n  }\n  log(u, c, l) {\n    this._level > u || this._fnOutput(`${InternalLogLevel$1[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${c()}${l ? `\n` + l.stack : \"\"}`);\n  }\n}, InternalProviderImpl$1 = class Bt {\n  constructor() {\n    this._loggers = new EnhancedMap$1(), this._logLevel = InternalLogLevel$1.Error, this._fnOutput = Bt.logConsole;\n  }\n  getLogger(u) {\n    return this._loggers.computeIfAbsent(u, (c) => new InternalLoggerImpl$1(c, this._logLevel, this._fnOutput));\n  }\n  changeLogLevel(u) {\n    this._logLevel = u, this._loggers.forEach((c) => c.setLevel(u));\n  }\n  changeOutput(u) {\n    this._fnOutput = u, this._loggers.forEach((c) => c.setOutput(this._fnOutput));\n  }\n  reset() {\n    this.changeLogLevel(InternalLogLevel$1.Error), this._fnOutput = Bt.logConsole, this._loggers.forEach((u) => u.setOutput(this._fnOutput));\n  }\n  static logConsole(u) {\n    console && console.log && console.log(u);\n  }\n};\nconst provider$1 = new InternalProviderImpl$1();\nvar InternalLogger$1 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  get InternalLogLevel() {\n    return InternalLogLevel$1;\n  },\n  getInternalLogger: getInternalLogger$1,\n  INTERNAL_LOGGING_SETTINGS: INTERNAL_LOGGING_SETTINGS$1\n}), LogLevel$2;\n(function(a) {\n  a[a.Trace = 0] = \"Trace\", a[a.Debug = 1] = \"Debug\", a[a.Info = 2] = \"Info\", a[a.Warn = 3] = \"Warn\", a[a.Error = 4] = \"Error\", a[a.Fatal = 5] = \"Fatal\";\n})(LogLevel$2 || (LogLevel$2 = {}));\n(function(a) {\n  function u(c) {\n    switch (c.toLowerCase()) {\n      case \"trace\":\n        return a.Trace;\n      case \"debug\":\n        return a.Debug;\n      case \"info\":\n        return a.Info;\n      case \"warn\":\n        return a.Warn;\n      case \"error\":\n        return a.Error;\n      case \"fatal\":\n        return a.Fatal;\n      default:\n        return;\n    }\n  }\n  a.toLogLevel = u;\n})(LogLevel$2 || (LogLevel$2 = {}));\nlet CoreLoggerImpl$1 = class Ar {\n  constructor(u) {\n    this._runtime = u;\n  }\n  get id() {\n    return this._runtime.id;\n  }\n  get logLevel() {\n    return this._runtime.level;\n  }\n  get runtimeSettings() {\n    return Object.assign({}, this._runtime);\n  }\n  set runtimeSettings(u) {\n    this._runtime = u;\n  }\n  trace(u, ...c) {\n    this.logMessage(LogLevel$2.Trace, u, c);\n  }\n  debug(u, ...c) {\n    this.logMessage(LogLevel$2.Debug, u, c);\n  }\n  info(u, ...c) {\n    this.logMessage(LogLevel$2.Info, u, c);\n  }\n  warn(u, ...c) {\n    this.logMessage(LogLevel$2.Warn, u, c);\n  }\n  error(u, ...c) {\n    this.logMessage(LogLevel$2.Error, u, c);\n  }\n  fatal(u, ...c) {\n    this.logMessage(LogLevel$2.Fatal, u, c);\n  }\n  logMessage(u, c, l) {\n    if (this._runtime.level > u)\n      return;\n    const v = Date.now(), S = typeof c == \"string\" ? c : c(), g = Ar.getErrorAndArgs(l);\n    switch (this._runtime.channel.type) {\n      case \"RawLogChannel\":\n        this._runtime.channel.write({\n          message: S,\n          exception: g.error,\n          args: g.args,\n          timeInMillis: v,\n          level: u,\n          logNames: this._runtime.name\n        }, this._runtime.argumentFormatter);\n        return;\n      case \"LogChannel\":\n        this._runtime.channel.write(this.createLogMessage(S, u, g, v));\n        break;\n    }\n  }\n  formatArgValue(u) {\n    try {\n      return this._runtime.argumentFormatter(u);\n    } catch {\n      return `>>ARG CONVERT FAILED: '${u !== void 0 ? u.toString() : \"undefined\"}'<<`;\n    }\n  }\n  createLogMessage(u, c, l, v) {\n    let S;\n    const g = l.error, E = l.args;\n    g && (S = `${g.name}: ${g.message}`, g.stack && (S += `@\n${g.stack}`));\n    const _ = this._runtime.dateFormatter(v);\n    let k = LogLevel$2[c].toUpperCase();\n    k.length < 5 && (k += \" \");\n    const L = typeof this._runtime.name == \"string\" ? this._runtime.name : this._runtime.name.join(\", \"), M = typeof E < \"u\" && E.length > 0 ? \" [\" + E.map((J) => this.formatArgValue(J)).join(\", \") + \"]\" : \"\";\n    return {\n      message: _ + \" \" + k + \" [\" + L + \"] \" + u + M,\n      error: S\n    };\n  }\n  static getErrorAndArgs(u) {\n    if (u.length === 0)\n      return {};\n    let c, l;\n    const v = u[0];\n    if (v instanceof Error)\n      return c = v, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l };\n    if (typeof v == \"function\") {\n      const S = v();\n      return S instanceof Error ? (c = S, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l }) : u.length === 1 ? Array.isArray(S) ? { args: S.length > 0 ? S : void 0 } : { args: S } : Array.isArray(S) ? { args: [...S, ...u.slice(1)] } : { args: [S, ...u.slice(1)] };\n    }\n    return { args: u };\n  }\n};\nfunction padStart$1(a, u, c = \" \") {\n  return padInternal$1(a, u, \"start\", c);\n}\nfunction padEnd$1(a, u, c = \" \") {\n  return padInternal$1(a, u, \"end\", c);\n}\nfunction maxLengthStringValueInArray$1(a) {\n  return a.map((u) => u.length).reduce((u, c) => c > u ? c : u, 0);\n}\nfunction padInternal$1(a, u, c, l = \" \") {\n  if (u <= a.length)\n    return a;\n  if (l.length > 1)\n    throw new Error(`Fill char must be one char exactly, it is: ${l.length}`);\n  const v = u - a.length;\n  let S = \"\";\n  for (let g = 0; g < v; g++)\n    S += l;\n  return c === \"start\" ? S + a : a + S;\n}\nfunction formatArgument$1(a) {\n  return a === void 0 ? \"undefined\" : JSON.stringify(a);\n}\nfunction formatDate$1(a) {\n  const u = new Date(a), c = u.getFullYear(), l = padStart$1((u.getMonth() + 1).toString(), 2, \"0\"), v = padStart$1(u.getDate().toString(), 2, \"0\"), S = padStart$1(u.getHours().toString(), 2, \"0\"), g = padStart$1(u.getMinutes().toString(), 2, \"0\"), E = padStart$1(u.getSeconds().toString(), 2, \"0\"), _ = padStart$1(u.getMilliseconds().toString(), 2, \"0\");\n  return `${c}-${l}-${v} ${S}:${g}:${E},${_}`;\n}\nlet ConsoleLogChannel$1 = class {\n  constructor() {\n    this.type = \"LogChannel\";\n  }\n  write(u) {\n    console && console.log && console.log(u.message + (u.error ? `\n${u.error}` : \"\"));\n  }\n};\nvar DefaultChannels$1;\n(function(a) {\n  function u() {\n    return new ConsoleLogChannel$1();\n  }\n  a.createConsoleChannel = u;\n})(DefaultChannels$1 || (DefaultChannels$1 = {}));\nlet LogProviderImpl$1 = class Mt {\n  constructor(u, c) {\n    this._log = getInternalLogger$1(\"core.impl.LogProviderImpl\"), this._name = u, this._settings = c, this._loggers = new EnhancedMap$1(), this._idToKeyMap = new EnhancedMap$1(), this._globalRuntimeSettings = { level: c.level, channel: c.channel }, this._nextLoggerId = 1, this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);\n  }\n  get runtimeSettings() {\n    return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });\n  }\n  getLogger(u) {\n    return this.getOrCreateLogger(u);\n  }\n  updateLoggerRuntime(u, c) {\n    this._log.debug(() => `Updating logger ${u.id} runtime settings using: '${JSON.stringify(c)}'`);\n    const l = this._idToKeyMap.get(u.id);\n    return l === void 0 ? (this._log.warn(() => `Cannot update logger with id: ${u.id}, it was not found.`), !1) : (this._loggers.computeIfPresent(l, (v, S) => (S.runtimeSettings = Mt.mergeRuntimeSettingsIntoLogRuntime(S.runtimeSettings, c), S)), !0);\n  }\n  updateRuntimeSettings(u) {\n    this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(u)}'`), this._globalRuntimeSettings = {\n      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */\n      level: u.level !== void 0 ? u.level : this._globalRuntimeSettings.level,\n      channel: u.channel !== void 0 ? u.channel : this._globalRuntimeSettings.channel\n    }, this._loggers.forEach((c) => c.runtimeSettings = Mt.mergeRuntimeSettingsIntoLogRuntime(c.runtimeSettings, u));\n  }\n  /**\n   * Removes all state and loggers, it reverts back to as it was after initial construction.\n   */\n  clear() {\n    this._loggers.clear(), this._idToKeyMap.clear(), this._globalRuntimeSettings = Object.assign({}, this._settings), this._nextLoggerId = 1;\n  }\n  getOrCreateLogger(u) {\n    const c = Mt.createKey(u), l = this._loggers.computeIfAbsent(c, () => {\n      const v = {\n        level: this._globalRuntimeSettings.level,\n        channel: this._globalRuntimeSettings.channel,\n        id: this.nextLoggerId(),\n        name: u,\n        argumentFormatter: this._settings.argumentFormatter,\n        dateFormatter: this._settings.dateFormatter\n      };\n      return new CoreLoggerImpl$1(v);\n    });\n    return this._idToKeyMap.computeIfAbsent(l.id, () => c), l;\n  }\n  nextLoggerId() {\n    const u = this._name + \"_\" + this._nextLoggerId;\n    return this._nextLoggerId++, u;\n  }\n  static mergeRuntimeSettingsIntoLogRuntime(u, c) {\n    return Object.assign(Object.assign({}, u), {\n      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */\n      level: c.level !== void 0 ? c.level : u.level,\n      channel: c.channel !== void 0 ? c.channel : u.channel\n    });\n  }\n  static createKey(u) {\n    return typeof u == \"string\" ? u : u.join(\",\");\n  }\n};\nfunction createLogProvider$1(a, u) {\n  return new LogProviderImpl$1(a, u);\n}\nvar index$4 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  EnhancedMap: EnhancedMap$1,\n  padStart: padStart$1,\n  padEnd: padEnd$1,\n  maxLengthStringValueInArray: maxLengthStringValueInArray$1\n});\nclass ArrayLogChannel {\n  constructor() {\n    this._buffer = [], this.type = \"LogChannel\";\n  }\n  write(u) {\n    this._buffer.push(u);\n  }\n  get logMessages() {\n    return this._buffer;\n  }\n  get messages() {\n    return this._buffer.map((u) => u.message);\n  }\n}\nclass ArrayRawLogChannel {\n  constructor() {\n    this._buffer = [], this.type = \"RawLogChannel\";\n  }\n  write(u, c) {\n    this._buffer.push(u);\n  }\n  get messages() {\n    return this._buffer.map((u) => u.message);\n  }\n  get errors() {\n    return this._buffer.map((u) => u.exception);\n  }\n  get size() {\n    return this._buffer.length;\n  }\n  get rawMessages() {\n    return this._buffer;\n  }\n  clear() {\n    this._buffer = [];\n  }\n}\nclass TestControlMessage {\n  constructor() {\n    this._messages = [], this.write = this.write.bind(this);\n  }\n  get messages() {\n    return this._messages;\n  }\n  write(u) {\n    this._messages.push(u);\n  }\n  clear() {\n    this._messages = [];\n  }\n}\nvar TestClasses = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  ArrayLogChannel,\n  ArrayRawLogChannel,\n  TestControlMessage\n});\nconst typescriptLogging_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  $internal: InternalLogger$1,\n  $test: TestClasses,\n  get DefaultChannels() {\n    return DefaultChannels$1;\n  },\n  get LogLevel() {\n    return LogLevel$2;\n  },\n  createLogProvider: createLogProvider$1,\n  formatArgument: formatArgument$1,\n  formatDate: formatDate$1,\n  util: index$4\n}, Symbol.toStringTag, { value: \"Module\" })), require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(typescriptLogging_esm);\nvar layoutapi = {}, lib$1 = {}, lib = {}, Metadata = {};\nObject.defineProperty(Metadata, \"__esModule\", { value: !0 });\nMetadata.Metadata = void 0;\nMetadata.Metadata = function(u) {\n  const c = /* @__PURE__ */ new Map(), l = {\n    set(v, S) {\n      if (v = normalizeKey(v), Array.isArray(S))\n        if (S.length === 0)\n          c.delete(v);\n        else {\n          for (const g of S)\n            validate$1(v, g);\n          c.set(v, v.endsWith(\"-bin\") ? S : [S.join(\", \")]);\n        }\n      else\n        validate$1(v, S), c.set(v, [S]);\n      return l;\n    },\n    append(v, S) {\n      v = normalizeKey(v), validate$1(v, S);\n      let g = c.get(v);\n      return g == null && (g = [], c.set(v, g)), g.push(S), v.endsWith(\"-bin\") || c.set(v, [g.join(\", \")]), l;\n    },\n    delete(v) {\n      v = normalizeKey(v), c.delete(v);\n    },\n    get(v) {\n      var S;\n      return v = normalizeKey(v), (S = c.get(v)) === null || S === void 0 ? void 0 : S[0];\n    },\n    getAll(v) {\n      var S;\n      return v = normalizeKey(v), (S = c.get(v)) !== null && S !== void 0 ? S : [];\n    },\n    has(v) {\n      return v = normalizeKey(v), c.has(v);\n    },\n    [Symbol.iterator]() {\n      return c[Symbol.iterator]();\n    }\n  };\n  if (u != null) {\n    const v = isIterable$1(u) ? u : Object.entries(u);\n    for (const [S, g] of v)\n      l.set(S, g);\n  }\n  return l;\n};\nfunction normalizeKey(a) {\n  return a.toLowerCase();\n}\nfunction validate$1(a, u) {\n  if (!/^[0-9a-z_.-]+$/.test(a))\n    throw new Error(`Metadata key '${a}' contains illegal characters`);\n  if (a.endsWith(\"-bin\")) {\n    if (!(u instanceof Uint8Array))\n      throw new Error(`Metadata key '${a}' ends with '-bin', thus it must have binary value`);\n  } else {\n    if (typeof u != \"string\")\n      throw new Error(`Metadata key '${a}' doesn't end with '-bin', thus it must have string value`);\n    if (!/^[ -~]*$/.test(u))\n      throw new Error(`Metadata value '${u}' of key '${a}' contains illegal characters`);\n  }\n}\nfunction isIterable$1(a) {\n  return Symbol.iterator in a;\n}\nvar Status = {};\n(function(a) {\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.Status = void 0, function(u) {\n    u[u.OK = 0] = \"OK\", u[u.CANCELLED = 1] = \"CANCELLED\", u[u.UNKNOWN = 2] = \"UNKNOWN\", u[u.INVALID_ARGUMENT = 3] = \"INVALID_ARGUMENT\", u[u.DEADLINE_EXCEEDED = 4] = \"DEADLINE_EXCEEDED\", u[u.NOT_FOUND = 5] = \"NOT_FOUND\", u[u.ALREADY_EXISTS = 6] = \"ALREADY_EXISTS\", u[u.PERMISSION_DENIED = 7] = \"PERMISSION_DENIED\", u[u.RESOURCE_EXHAUSTED = 8] = \"RESOURCE_EXHAUSTED\", u[u.FAILED_PRECONDITION = 9] = \"FAILED_PRECONDITION\", u[u.ABORTED = 10] = \"ABORTED\", u[u.OUT_OF_RANGE = 11] = \"OUT_OF_RANGE\", u[u.UNIMPLEMENTED = 12] = \"UNIMPLEMENTED\", u[u.INTERNAL = 13] = \"INTERNAL\", u[u.UNAVAILABLE = 14] = \"UNAVAILABLE\", u[u.DATA_LOSS = 15] = \"DATA_LOSS\", u[u.UNAUTHENTICATED = 16] = \"UNAUTHENTICATED\";\n  }(a.Status || (a.Status = {}));\n})(Status);\nvar MethodDescriptor = {};\nObject.defineProperty(MethodDescriptor, \"__esModule\", { value: !0 });\nvar CallOptions = {};\nObject.defineProperty(CallOptions, \"__esModule\", { value: !0 });\nvar ClientMiddleware = {};\nObject.defineProperty(ClientMiddleware, \"__esModule\", { value: !0 });\nvar composeClientMiddleware$1 = {};\nObject.defineProperty(composeClientMiddleware$1, \"__esModule\", { value: !0 });\ncomposeClientMiddleware$1.composeClientMiddleware = void 0;\nfunction composeClientMiddleware(a, u) {\n  return (c, l) => u({\n    ...c,\n    next: (v, S) => a({ ...c, request: v }, S)\n  }, l);\n}\ncomposeClientMiddleware$1.composeClientMiddleware = composeClientMiddleware;\nvar ClientError$1 = {}, cjs = {}, helpers = {};\nhelpers.__esModule = void 0;\nhelpers.__esModule = !0;\nvar objectSetPrototypeOfIsDefined = typeof Object.setPrototypeOf == \"function\", objectGetPrototypeOfIsDefined = typeof Object.getPrototypeOf == \"function\", objectDefinePropertyIsDefined = typeof Object.defineProperty == \"function\", objectCreateIsDefined = typeof Object.create == \"function\", objectHasOwnPropertyIsDefined = typeof Object.prototype.hasOwnProperty == \"function\", setPrototypeOf = function(u, c) {\n  objectSetPrototypeOfIsDefined ? Object.setPrototypeOf(u, c) : u.__proto__ = c;\n};\nhelpers.setPrototypeOf = setPrototypeOf;\nvar getPrototypeOf = function(u) {\n  return objectGetPrototypeOfIsDefined ? Object.getPrototypeOf(u) : u.__proto__ || u.prototype;\n};\nhelpers.getPrototypeOf = getPrototypeOf;\nvar ie8ObjectDefinePropertyBug = !1, defineProperty = function a(u, c, l) {\n  if (objectDefinePropertyIsDefined && !ie8ObjectDefinePropertyBug)\n    try {\n      Object.defineProperty(u, c, l);\n    } catch {\n      ie8ObjectDefinePropertyBug = !0, a(u, c, l);\n    }\n  else\n    u[c] = l.value;\n};\nhelpers.defineProperty = defineProperty;\nvar hasOwnProperty$2 = function(u, c) {\n  return objectHasOwnPropertyIsDefined ? u.hasOwnProperty(u, c) : u[c] === void 0;\n};\nhelpers.hasOwnProperty = hasOwnProperty$2;\nvar objectCreate = function(u, c) {\n  if (objectCreateIsDefined)\n    return Object.create(u, c);\n  var l = function() {\n  };\n  l.prototype = u;\n  var v = new l();\n  if (typeof c > \"u\")\n    return v;\n  if (typeof c == \"null\")\n    throw new Error(\"PropertyDescriptors must not be null.\");\n  if (typeof c == \"object\")\n    for (var S in c)\n      hasOwnProperty$2(c, S) && (v[S] = c[S].value);\n  return v;\n};\nhelpers.objectCreate = objectCreate;\n(function(a) {\n  a.__esModule = void 0, a.__esModule = !0;\n  var u = helpers, c = u.setPrototypeOf, l = u.getPrototypeOf, v = u.defineProperty, S = u.objectCreate, g = new Error().toString() === \"[object Error]\", E = \"\";\n  function _(k) {\n    var L = this.constructor, M = L.name || function() {\n      var G = L.toString().match(/^function\\s*([^\\s(]+)/);\n      return G === null ? E || \"Error\" : G[1];\n    }(), $ = M === \"Error\", J = $ ? E : M, V = Error.apply(this, arguments);\n    if (c(V, l(this)), !(V instanceof L) || !(V instanceof _)) {\n      var V = this;\n      Error.apply(this, arguments), v(V, \"message\", {\n        configurable: !0,\n        enumerable: !1,\n        value: k,\n        writable: !0\n      });\n    }\n    if (v(V, \"name\", {\n      configurable: !0,\n      enumerable: !1,\n      value: J,\n      writable: !0\n    }), Error.captureStackTrace && Error.captureStackTrace(\n      V,\n      $ ? _ : L\n    ), V.stack === void 0) {\n      var q = new Error(k);\n      q.name = V.name, V.stack = q.stack;\n    }\n    return g && v(V, \"toString\", {\n      configurable: !0,\n      enumerable: !1,\n      value: function() {\n        return (this.name || \"Error\") + (typeof this.message > \"u\" ? \"\" : \": \" + this.message);\n      },\n      writable: !0\n    }), V;\n  }\n  E = _.name || \"ExtendableError\", _.prototype = S(Error.prototype, {\n    constructor: {\n      value: Error,\n      enumerable: !1,\n      writable: !0,\n      configurable: !0\n    }\n  }), a.ExtendableError = _, a.default = a.ExtendableError;\n})(cjs);\nObject.defineProperty(ClientError$1, \"__esModule\", { value: !0 });\nClientError$1.ClientError = void 0;\nconst ts_error_1$1 = cjs, Status_1$1 = Status;\nclass ClientError extends ts_error_1$1.ExtendableError {\n  constructor(u, c, l) {\n    super(`${u} ${Status_1$1.Status[c]}: ${l}`), this.path = u, this.code = c, this.details = l, this.name = \"ClientError\", Object.defineProperty(this, \"@@nice-grpc\", {\n      value: !0\n    }), Object.defineProperty(this, \"@@nice-grpc:ClientError\", {\n      value: !0\n    });\n  }\n  static [Symbol.hasInstance](u) {\n    return this !== ClientError ? this.prototype.isPrototypeOf(u) : typeof u == \"object\" && u !== null && (u.constructor === ClientError || u[\"@@nice-grpc:ClientError\"] === !0 || u.name === \"ClientError\" && u[\"@@nice-grpc\"] === !0);\n  }\n}\nClientError$1.ClientError = ClientError;\nvar CallContext = {};\nObject.defineProperty(CallContext, \"__esModule\", { value: !0 });\nvar ServerMiddleware = {};\nObject.defineProperty(ServerMiddleware, \"__esModule\", { value: !0 });\nvar composeServerMiddleware$1 = {};\nObject.defineProperty(composeServerMiddleware$1, \"__esModule\", { value: !0 });\ncomposeServerMiddleware$1.composeServerMiddleware = void 0;\nfunction composeServerMiddleware(a, u) {\n  return (c, l) => a({\n    ...c,\n    next: (v, S) => u({ ...c, request: v }, S)\n  }, l);\n}\ncomposeServerMiddleware$1.composeServerMiddleware = composeServerMiddleware;\nvar ServerError$1 = {};\nObject.defineProperty(ServerError$1, \"__esModule\", { value: !0 });\nServerError$1.ServerError = void 0;\nconst ts_error_1 = cjs, Status_1 = Status;\nclass ServerError extends ts_error_1.ExtendableError {\n  constructor(u, c) {\n    super(`${Status_1.Status[u]}: ${c}`), this.code = u, this.details = c, this.name = \"ServerError\", Object.defineProperty(this, \"@@nice-grpc\", {\n      value: !0\n    }), Object.defineProperty(this, \"@@nice-grpc:ServerError\", {\n      value: !0\n    });\n  }\n  static [Symbol.hasInstance](u) {\n    return this !== ServerError ? this.prototype.isPrototypeOf(u) : typeof u == \"object\" && u !== null && (u.constructor === ServerError || u[\"@@nice-grpc:ServerError\"] === !0 || u.name === \"ServerError\" && u[\"@@nice-grpc\"] === !0);\n  }\n}\nServerError$1.ServerError = ServerError;\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(l, v, S, g) {\n    g === void 0 && (g = S);\n    var E = Object.getOwnPropertyDescriptor(v, S);\n    (!E || (\"get\" in E ? !v.__esModule : E.writable || E.configurable)) && (E = { enumerable: !0, get: function() {\n      return v[S];\n    } }), Object.defineProperty(l, g, E);\n  } : function(l, v, S, g) {\n    g === void 0 && (g = S), l[g] = v[S];\n  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(l, v) {\n    for (var S in l)\n      S !== \"default\" && !Object.prototype.hasOwnProperty.call(v, S) && u(v, l, S);\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), c(Metadata, a), c(Status, a), c(MethodDescriptor, a), c(CallOptions, a), c(ClientMiddleware, a), c(composeClientMiddleware$1, a), c(ClientError$1, a), c(CallContext, a), c(ServerMiddleware, a), c(composeServerMiddleware$1, a), c(ServerError$1, a);\n})(lib);\nvar serviceDefinitions = {}, grpcWeb = {};\nObject.defineProperty(grpcWeb, \"__esModule\", { value: !0 });\ngrpcWeb.isGrpcWebServiceDefinition = grpcWeb.fromGrpcWebServiceDefinition = void 0;\nfunction fromGrpcWebServiceDefinition(a) {\n  const u = {};\n  for (const [c, l] of Object.entries(a)) {\n    if (c === \"serviceName\")\n      continue;\n    const v = l;\n    u[uncapitalize(c)] = {\n      path: `/${a.serviceName}/${c}`,\n      requestStream: v.requestStream,\n      responseStream: v.responseStream,\n      requestDeserialize: v.requestType.deserializeBinary,\n      requestSerialize: (S) => S.serializeBinary(),\n      responseDeserialize: v.responseType.deserializeBinary,\n      responseSerialize: (S) => S.serializeBinary(),\n      options: {}\n    };\n  }\n  return u;\n}\ngrpcWeb.fromGrpcWebServiceDefinition = fromGrpcWebServiceDefinition;\nfunction isGrpcWebServiceDefinition(a) {\n  return \"prototype\" in a;\n}\ngrpcWeb.isGrpcWebServiceDefinition = isGrpcWebServiceDefinition;\nfunction uncapitalize(a) {\n  return a.length === 0 ? a : a[0].toLowerCase() + a.slice(1);\n}\nvar tsProto = {};\nObject.defineProperty(tsProto, \"__esModule\", { value: !0 });\ntsProto.isTsProtoServiceDefinition = tsProto.fromTsProtoServiceDefinition = void 0;\nfunction fromTsProtoServiceDefinition(a) {\n  const u = {};\n  for (const [c, l] of Object.entries(a.methods)) {\n    const v = l.requestType.encode, S = l.requestType.fromPartial, g = l.responseType.encode, E = l.responseType.fromPartial;\n    u[c] = {\n      path: `/${a.fullName}/${l.name}`,\n      requestStream: l.requestStream,\n      responseStream: l.responseStream,\n      requestDeserialize: l.requestType.decode,\n      requestSerialize: S != null ? (_) => v(S(_)).finish() : (_) => v(_).finish(),\n      responseDeserialize: l.responseType.decode,\n      responseSerialize: E != null ? (_) => g(E(_)).finish() : (_) => g(_).finish(),\n      options: l.options\n    };\n  }\n  return u;\n}\ntsProto.fromTsProtoServiceDefinition = fromTsProtoServiceDefinition;\nfunction isTsProtoServiceDefinition(a) {\n  return \"name\" in a && \"fullName\" in a && \"methods\" in a;\n}\ntsProto.isTsProtoServiceDefinition = isTsProtoServiceDefinition;\nObject.defineProperty(serviceDefinitions, \"__esModule\", { value: !0 });\nserviceDefinitions.toGrpcWebMethodDefinition = serviceDefinitions.normalizeServiceDefinition = void 0;\nconst grpc_web_1$5 = grpcWeb, ts_proto_1 = tsProto;\nfunction normalizeServiceDefinition(a) {\n  return (0, grpc_web_1$5.isGrpcWebServiceDefinition)(a) ? (0, grpc_web_1$5.fromGrpcWebServiceDefinition)(a) : (0, ts_proto_1.isTsProtoServiceDefinition)(a) ? (0, ts_proto_1.fromTsProtoServiceDefinition)(a) : a;\n}\nserviceDefinitions.normalizeServiceDefinition = normalizeServiceDefinition;\nfunction toGrpcWebMethodDefinition(a) {\n  const [, u, c] = a.path.split(\"/\");\n  return {\n    service: {\n      serviceName: u\n    },\n    methodName: c,\n    requestStream: a.requestStream,\n    responseStream: a.responseStream,\n    requestType: class {\n      constructor() {\n        throw new Error(\"Unexpected instantiation\");\n      }\n      static deserializeBinary(l) {\n        return a.requestDeserialize(l);\n      }\n    },\n    responseType: class {\n      constructor() {\n        throw new Error(\"Unexpected instantiation\");\n      }\n      static deserializeBinary(l) {\n        return a.responseDeserialize(l);\n      }\n    }\n  };\n}\nserviceDefinitions.toGrpcWebMethodDefinition = toGrpcWebMethodDefinition;\nvar channel = {};\nObject.defineProperty(channel, \"__esModule\", { value: !0 });\nchannel.createChannel = void 0;\nfunction createChannel(a, u) {\n  return { address: a, transport: u };\n}\nchannel.createChannel = createChannel;\nvar ClientFactory = {}, createBidiStreamingMethod$1 = {}, grpcWebClient_umd = { exports: {} };\n(function(a, u) {\n  (function(c, l) {\n    a.exports = l();\n  })(commonjsGlobal$1, function() {\n    return c = { 418: function(v, S) {\n      (function(g, E) {\n        for (var _ in E)\n          g[_] = E[_];\n      })(S, function(g) {\n        var E = {};\n        function _(k) {\n          if (E[k])\n            return E[k].exports;\n          var L = E[k] = { i: k, l: !1, exports: {} };\n          return g[k].call(L.exports, L, L.exports, _), L.l = !0, L.exports;\n        }\n        return _.m = g, _.c = E, _.i = function(k) {\n          return k;\n        }, _.d = function(k, L, M) {\n          _.o(k, L) || Object.defineProperty(k, L, { configurable: !1, enumerable: !0, get: M });\n        }, _.n = function(k) {\n          var L = k && k.__esModule ? function() {\n            return k.default;\n          } : function() {\n            return k;\n          };\n          return _.d(L, \"a\", L), L;\n        }, _.o = function(k, L) {\n          return Object.prototype.hasOwnProperty.call(k, L);\n        }, _.p = \"\", _(_.s = 1);\n      }([function(g, E, _) {\n        Object.defineProperty(E, \"__esModule\", { value: !0 });\n        var k = _(3), L = function() {\n          function M($, J) {\n            $ === void 0 && ($ = {}), J === void 0 && (J = { splitValues: !1 });\n            var V, q = this;\n            this.headersMap = {}, $ && (typeof Headers < \"u\" && $ instanceof Headers ? k.getHeaderKeys($).forEach(function(G) {\n              k.getHeaderValues($, G).forEach(function(H) {\n                J.splitValues ? q.append(G, k.splitHeaderValue(H)) : q.append(G, H);\n              });\n            }) : typeof (V = $) == \"object\" && typeof V.headersMap == \"object\" && typeof V.forEach == \"function\" ? $.forEach(function(G, H) {\n              q.append(G, H);\n            }) : typeof Map < \"u\" && $ instanceof Map ? $.forEach(function(G, H) {\n              q.append(H, G);\n            }) : typeof $ == \"string\" ? this.appendFromString($) : typeof $ == \"object\" && Object.getOwnPropertyNames($).forEach(function(G) {\n              var H = $[G];\n              Array.isArray(H) ? H.forEach(function(B) {\n                q.append(G, B);\n              }) : q.append(G, H);\n            }));\n          }\n          return M.prototype.appendFromString = function($) {\n            for (var J = $.split(`\\r\n`), V = 0; V < J.length; V++) {\n              var q = J[V], G = q.indexOf(\":\");\n              if (G > 0) {\n                var H = q.substring(0, G).trim(), B = q.substring(G + 1).trim();\n                this.append(H, B);\n              }\n            }\n          }, M.prototype.delete = function($, J) {\n            var V = k.normalizeName($);\n            if (J === void 0)\n              delete this.headersMap[V];\n            else {\n              var q = this.headersMap[V];\n              if (q) {\n                var G = q.indexOf(J);\n                G >= 0 && q.splice(G, 1), q.length === 0 && delete this.headersMap[V];\n              }\n            }\n          }, M.prototype.append = function($, J) {\n            var V = this, q = k.normalizeName($);\n            Array.isArray(this.headersMap[q]) || (this.headersMap[q] = []), Array.isArray(J) ? J.forEach(function(G) {\n              V.headersMap[q].push(k.normalizeValue(G));\n            }) : this.headersMap[q].push(k.normalizeValue(J));\n          }, M.prototype.set = function($, J) {\n            var V = k.normalizeName($);\n            if (Array.isArray(J)) {\n              var q = [];\n              J.forEach(function(G) {\n                q.push(k.normalizeValue(G));\n              }), this.headersMap[V] = q;\n            } else\n              this.headersMap[V] = [k.normalizeValue(J)];\n          }, M.prototype.has = function($, J) {\n            var V = this.headersMap[k.normalizeName($)];\n            if (!Array.isArray(V))\n              return !1;\n            if (J !== void 0) {\n              var q = k.normalizeValue(J);\n              return V.indexOf(q) >= 0;\n            }\n            return !0;\n          }, M.prototype.get = function($) {\n            var J = this.headersMap[k.normalizeName($)];\n            return J !== void 0 ? J.concat() : [];\n          }, M.prototype.forEach = function($) {\n            var J = this;\n            Object.getOwnPropertyNames(this.headersMap).forEach(function(V) {\n              $(V, J.headersMap[V]);\n            }, this);\n          }, M.prototype.toHeaders = function() {\n            if (typeof Headers < \"u\") {\n              var $ = new Headers();\n              return this.forEach(function(J, V) {\n                V.forEach(function(q) {\n                  $.append(J, q);\n                });\n              }), $;\n            }\n            throw new Error(\"Headers class is not defined\");\n          }, M;\n        }();\n        E.BrowserHeaders = L;\n      }, function(g, E, _) {\n        Object.defineProperty(E, \"__esModule\", { value: !0 });\n        var k = _(0);\n        E.BrowserHeaders = k.BrowserHeaders;\n      }, function(g, E, _) {\n        Object.defineProperty(E, \"__esModule\", { value: !0 }), E.iterateHeaders = function(k, L) {\n          for (var M = k[Symbol.iterator](), $ = M.next(); !$.done; )\n            L($.value[0]), $ = M.next();\n        }, E.iterateHeadersKeys = function(k, L) {\n          for (var M = k.keys(), $ = M.next(); !$.done; )\n            L($.value), $ = M.next();\n        };\n      }, function(g, E, _) {\n        Object.defineProperty(E, \"__esModule\", { value: !0 });\n        var k = _(2);\n        E.normalizeName = function(L) {\n          if (typeof L != \"string\" && (L = String(L)), /[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(L))\n            throw new TypeError(\"Invalid character in header field name\");\n          return L.toLowerCase();\n        }, E.normalizeValue = function(L) {\n          return typeof L != \"string\" && (L = String(L)), L;\n        }, E.getHeaderValues = function(L, M) {\n          var $ = L;\n          if ($ instanceof Headers && $.getAll)\n            return $.getAll(M);\n          var J = $.get(M);\n          return J && typeof J == \"string\" ? [J] : J;\n        }, E.getHeaderKeys = function(L) {\n          var M = L, $ = {}, J = [];\n          return M.keys ? k.iterateHeadersKeys(M, function(V) {\n            $[V] || ($[V] = !0, J.push(V));\n          }) : M.forEach ? M.forEach(function(V, q) {\n            $[q] || ($[q] = !0, J.push(q));\n          }) : k.iterateHeaders(M, function(V) {\n            var q = V[0];\n            $[q] || ($[q] = !0, J.push(q));\n          }), J;\n        }, E.splitHeaderValue = function(L) {\n          var M = [];\n          return L.split(\", \").forEach(function($) {\n            $.split(\",\").forEach(function(J) {\n              M.push(J);\n            });\n          }), M;\n        };\n      }]));\n    }, 617: function(v, S, g) {\n      Object.defineProperty(S, \"__esModule\", { value: !0 }), S.ChunkParser = S.ChunkType = S.encodeASCII = S.decodeASCII = void 0;\n      var E, _ = g(65);\n      function k(G) {\n        return (H = G) === 9 || H === 10 || H === 13 || G >= 32 && G <= 126;\n        var H;\n      }\n      function L(G) {\n        for (var H = 0; H !== G.length; ++H)\n          if (!k(G[H]))\n            throw new Error(\"Metadata is not valid (printable) ASCII\");\n        return String.fromCharCode.apply(String, Array.prototype.slice.call(G));\n      }\n      function M(G) {\n        return (128 & G.getUint8(0)) == 128;\n      }\n      function $(G) {\n        return G.getUint32(1, !1);\n      }\n      function J(G, H, B) {\n        return G.byteLength - H >= B;\n      }\n      function V(G, H, B) {\n        if (G.slice)\n          return G.slice(H, B);\n        var Y = G.length;\n        B !== void 0 && (Y = B);\n        for (var ne = new Uint8Array(Y - H), Z = 0, re = H; re < Y; re++)\n          ne[Z++] = G[re];\n        return ne;\n      }\n      S.decodeASCII = L, S.encodeASCII = function(G) {\n        for (var H = new Uint8Array(G.length), B = 0; B !== G.length; ++B) {\n          var Y = G.charCodeAt(B);\n          if (!k(Y))\n            throw new Error(\"Metadata contains invalid ASCII\");\n          H[B] = Y;\n        }\n        return H;\n      }, function(G) {\n        G[G.MESSAGE = 1] = \"MESSAGE\", G[G.TRAILERS = 2] = \"TRAILERS\";\n      }(E = S.ChunkType || (S.ChunkType = {}));\n      var q = function() {\n        function G() {\n          this.buffer = null, this.position = 0;\n        }\n        return G.prototype.parse = function(H, B) {\n          if (H.length === 0 && B)\n            return [];\n          var Y, ne = [];\n          if (this.buffer == null)\n            this.buffer = H, this.position = 0;\n          else if (this.position === this.buffer.byteLength)\n            this.buffer = H, this.position = 0;\n          else {\n            var Z = this.buffer.byteLength - this.position, re = new Uint8Array(Z + H.byteLength), oe = V(this.buffer, this.position);\n            re.set(oe, 0);\n            var de = new Uint8Array(H);\n            re.set(de, Z), this.buffer = re, this.position = 0;\n          }\n          for (; ; ) {\n            if (!J(this.buffer, this.position, 5))\n              return ne;\n            var A = V(this.buffer, this.position, this.position + 5), N = new DataView(A.buffer, A.byteOffset, A.byteLength), D = $(N);\n            if (!J(this.buffer, this.position, 5 + D))\n              return ne;\n            var W = V(this.buffer, this.position + 5, this.position + 5 + D);\n            if (this.position += 5 + D, M(N))\n              return ne.push({ chunkType: E.TRAILERS, trailers: (Y = W, new _.Metadata(L(Y))) }), ne;\n            ne.push({ chunkType: E.MESSAGE, data: W });\n          }\n        }, G;\n      }();\n      S.ChunkParser = q;\n    }, 8: function(v, S) {\n      var g;\n      Object.defineProperty(S, \"__esModule\", { value: !0 }), S.httpStatusToCode = S.Code = void 0, function(E) {\n        E[E.OK = 0] = \"OK\", E[E.Canceled = 1] = \"Canceled\", E[E.Unknown = 2] = \"Unknown\", E[E.InvalidArgument = 3] = \"InvalidArgument\", E[E.DeadlineExceeded = 4] = \"DeadlineExceeded\", E[E.NotFound = 5] = \"NotFound\", E[E.AlreadyExists = 6] = \"AlreadyExists\", E[E.PermissionDenied = 7] = \"PermissionDenied\", E[E.ResourceExhausted = 8] = \"ResourceExhausted\", E[E.FailedPrecondition = 9] = \"FailedPrecondition\", E[E.Aborted = 10] = \"Aborted\", E[E.OutOfRange = 11] = \"OutOfRange\", E[E.Unimplemented = 12] = \"Unimplemented\", E[E.Internal = 13] = \"Internal\", E[E.Unavailable = 14] = \"Unavailable\", E[E.DataLoss = 15] = \"DataLoss\", E[E.Unauthenticated = 16] = \"Unauthenticated\";\n      }(g = S.Code || (S.Code = {})), S.httpStatusToCode = function(E) {\n        switch (E) {\n          case 0:\n            return g.Internal;\n          case 200:\n            return g.OK;\n          case 400:\n            return g.InvalidArgument;\n          case 401:\n            return g.Unauthenticated;\n          case 403:\n            return g.PermissionDenied;\n          case 404:\n            return g.NotFound;\n          case 409:\n            return g.Aborted;\n          case 412:\n            return g.FailedPrecondition;\n          case 429:\n            return g.ResourceExhausted;\n          case 499:\n            return g.Canceled;\n          case 500:\n            return g.Unknown;\n          case 501:\n            return g.Unimplemented;\n          case 503:\n            return g.Unavailable;\n          case 504:\n            return g.DeadlineExceeded;\n          default:\n            return g.Unknown;\n        }\n      };\n    }, 934: function(v, S, g) {\n      Object.defineProperty(S, \"__esModule\", { value: !0 }), S.client = void 0;\n      var E = g(65), _ = g(617), k = g(8), L = g(346), M = g(57), $ = g(882);\n      S.client = function(q, G) {\n        return new J(q, G);\n      };\n      var J = function() {\n        function q(G, H) {\n          this.started = !1, this.sentFirstMessage = !1, this.completed = !1, this.closed = !1, this.finishedSending = !1, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new _.ChunkParser(), this.methodDefinition = G, this.props = H, this.createTransport();\n        }\n        return q.prototype.createTransport = function() {\n          var G = this.props.host + \"/\" + this.methodDefinition.service.serviceName + \"/\" + this.methodDefinition.methodName, H = { methodDefinition: this.methodDefinition, debug: this.props.debug || !1, url: G, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };\n          this.props.transport ? this.transport = this.props.transport(H) : this.transport = M.makeDefaultTransport(H);\n        }, q.prototype.onTransportHeaders = function(G, H) {\n          if (this.props.debug && L.debug(\"onHeaders\", G, H), this.closed)\n            this.props.debug && L.debug(\"grpc.onHeaders received after request was closed - ignoring\");\n          else if (H !== 0) {\n            this.responseHeaders = G, this.props.debug && L.debug(\"onHeaders.responseHeaders\", JSON.stringify(this.responseHeaders, null, 2));\n            var B = V(G);\n            this.props.debug && L.debug(\"onHeaders.gRPCStatus\", B);\n            var Y = B && B >= 0 ? B : k.httpStatusToCode(H);\n            this.props.debug && L.debug(\"onHeaders.code\", Y);\n            var ne = G.get(\"grpc-message\") || [];\n            if (this.props.debug && L.debug(\"onHeaders.gRPCMessage\", ne), this.rawOnHeaders(G), Y !== k.Code.OK) {\n              var Z = this.decodeGRPCStatus(ne[0]);\n              this.rawOnError(Y, Z, G);\n            }\n          }\n        }, q.prototype.onTransportChunk = function(G) {\n          var H = this;\n          if (this.closed)\n            this.props.debug && L.debug(\"grpc.onChunk received after request was closed - ignoring\");\n          else {\n            var B = [];\n            try {\n              B = this.parser.parse(G);\n            } catch (Y) {\n              return this.props.debug && L.debug(\"onChunk.parsing error\", Y, Y.message), void this.rawOnError(k.Code.Internal, \"parsing error: \" + Y.message);\n            }\n            B.forEach(function(Y) {\n              if (Y.chunkType === _.ChunkType.MESSAGE) {\n                var ne = H.methodDefinition.responseType.deserializeBinary(Y.data);\n                H.rawOnMessage(ne);\n              } else\n                Y.chunkType === _.ChunkType.TRAILERS && (H.responseHeaders ? (H.responseTrailers = new E.Metadata(Y.trailers), H.props.debug && L.debug(\"onChunk.trailers\", H.responseTrailers)) : (H.responseHeaders = new E.Metadata(Y.trailers), H.rawOnHeaders(H.responseHeaders)));\n            });\n          }\n        }, q.prototype.onTransportEnd = function() {\n          if (this.props.debug && L.debug(\"grpc.onEnd\"), this.closed)\n            this.props.debug && L.debug(\"grpc.onEnd received after request was closed - ignoring\");\n          else if (this.responseTrailers !== void 0) {\n            var G = V(this.responseTrailers);\n            if (G !== null) {\n              var H = this.responseTrailers.get(\"grpc-message\"), B = this.decodeGRPCStatus(H[0]);\n              this.rawOnEnd(G, B, this.responseTrailers);\n            } else\n              this.rawOnError(k.Code.Internal, \"Response closed without grpc-status (Trailers provided)\");\n          } else {\n            if (this.responseHeaders === void 0)\n              return void this.rawOnError(k.Code.Unknown, \"Response closed without headers\");\n            var Y = V(this.responseHeaders), ne = this.responseHeaders.get(\"grpc-message\");\n            if (this.props.debug && L.debug(\"grpc.headers only response \", Y, ne), Y === null)\n              return void this.rawOnEnd(k.Code.Unknown, \"Response closed without grpc-status (Headers only)\", this.responseHeaders);\n            var Z = this.decodeGRPCStatus(ne[0]);\n            this.rawOnEnd(Y, Z, this.responseHeaders);\n          }\n        }, q.prototype.decodeGRPCStatus = function(G) {\n          if (!G)\n            return \"\";\n          try {\n            return decodeURIComponent(G);\n          } catch {\n            return G;\n          }\n        }, q.prototype.rawOnEnd = function(G, H, B) {\n          var Y = this;\n          this.props.debug && L.debug(\"rawOnEnd\", G, H, B), this.completed || (this.completed = !0, this.onEndCallbacks.forEach(function(ne) {\n            if (!Y.closed)\n              try {\n                ne(G, H, B);\n              } catch (Z) {\n                setTimeout(function() {\n                  throw Z;\n                }, 0);\n              }\n          }));\n        }, q.prototype.rawOnHeaders = function(G) {\n          this.props.debug && L.debug(\"rawOnHeaders\", G), this.completed || this.onHeadersCallbacks.forEach(function(H) {\n            try {\n              H(G);\n            } catch (B) {\n              setTimeout(function() {\n                throw B;\n              }, 0);\n            }\n          });\n        }, q.prototype.rawOnError = function(G, H, B) {\n          var Y = this;\n          B === void 0 && (B = new E.Metadata()), this.props.debug && L.debug(\"rawOnError\", G, H), this.completed || (this.completed = !0, this.onEndCallbacks.forEach(function(ne) {\n            if (!Y.closed)\n              try {\n                ne(G, H, B);\n              } catch (Z) {\n                setTimeout(function() {\n                  throw Z;\n                }, 0);\n              }\n          }));\n        }, q.prototype.rawOnMessage = function(G) {\n          var H = this;\n          this.props.debug && L.debug(\"rawOnMessage\", G.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach(function(B) {\n            if (!H.closed)\n              try {\n                B(G);\n              } catch (Y) {\n                setTimeout(function() {\n                  throw Y;\n                }, 0);\n              }\n          });\n        }, q.prototype.onHeaders = function(G) {\n          this.onHeadersCallbacks.push(G);\n        }, q.prototype.onMessage = function(G) {\n          this.onMessageCallbacks.push(G);\n        }, q.prototype.onEnd = function(G) {\n          this.onEndCallbacks.push(G);\n        }, q.prototype.start = function(G) {\n          if (this.started)\n            throw new Error(\"Client already started - cannot .start()\");\n          this.started = !0;\n          var H = new E.Metadata(G || {});\n          H.set(\"content-type\", \"application/grpc-web+proto\"), H.set(\"x-grpc-web\", \"1\"), this.transport.start(H);\n        }, q.prototype.send = function(G) {\n          if (!this.started)\n            throw new Error(\"Client not started - .start() must be called before .send()\");\n          if (this.closed)\n            throw new Error(\"Client already closed - cannot .send()\");\n          if (this.finishedSending)\n            throw new Error(\"Client already finished sending - cannot .send()\");\n          if (!this.methodDefinition.requestStream && this.sentFirstMessage)\n            throw new Error(\"Message already sent for non-client-streaming method - cannot .send()\");\n          this.sentFirstMessage = !0;\n          var H = $.frameRequest(G);\n          this.transport.sendMessage(H);\n        }, q.prototype.finishSend = function() {\n          if (!this.started)\n            throw new Error(\"Client not started - .finishSend() must be called before .close()\");\n          if (this.closed)\n            throw new Error(\"Client already closed - cannot .send()\");\n          if (this.finishedSending)\n            throw new Error(\"Client already finished sending - cannot .finishSend()\");\n          this.finishedSending = !0, this.transport.finishSend();\n        }, q.prototype.close = function() {\n          if (!this.started)\n            throw new Error(\"Client not started - .start() must be called before .close()\");\n          if (this.closed)\n            throw new Error(\"Client already closed - cannot .close()\");\n          this.closed = !0, this.props.debug && L.debug(\"request.abort aborting request\"), this.transport.cancel();\n        }, q;\n      }();\n      function V(q) {\n        var G = q.get(\"grpc-status\") || [];\n        if (G.length > 0)\n          try {\n            var H = G[0];\n            return parseInt(H, 10);\n          } catch {\n            return null;\n          }\n        return null;\n      }\n    }, 346: function(v, S) {\n      Object.defineProperty(S, \"__esModule\", { value: !0 }), S.debug = void 0, S.debug = function() {\n        for (var g = [], E = 0; E < arguments.length; E++)\n          g[E] = arguments[E];\n        console.debug ? console.debug.apply(null, g) : console.log.apply(null, g);\n      };\n    }, 607: function(v, S, g) {\n      Object.defineProperty(S, \"__esModule\", { value: !0 }), S.grpc = void 0;\n      var E, _ = g(418), k = g(57), L = g(229), M = g(540), $ = g(210), J = g(859), V = g(8), q = g(938), G = g(35), H = g(934);\n      (E = S.grpc || (S.grpc = {})).setDefaultTransport = k.setDefaultTransportFactory, E.CrossBrowserHttpTransport = J.CrossBrowserHttpTransport, E.FetchReadableStreamTransport = L.FetchReadableStreamTransport, E.XhrTransport = $.XhrTransport, E.WebsocketTransport = M.WebsocketTransport, E.Code = V.Code, E.Metadata = _.BrowserHeaders, E.client = function(B, Y) {\n        return H.client(B, Y);\n      }, E.invoke = q.invoke, E.unary = G.unary;\n    }, 938: function(v, S, g) {\n      Object.defineProperty(S, \"__esModule\", { value: !0 }), S.invoke = void 0;\n      var E = g(934);\n      S.invoke = function(_, k) {\n        if (_.requestStream)\n          throw new Error(\".invoke cannot be used with client-streaming methods. Use .client instead.\");\n        var L = E.client(_, { host: k.host, transport: k.transport, debug: k.debug });\n        return k.onHeaders && L.onHeaders(k.onHeaders), k.onMessage && L.onMessage(k.onMessage), k.onEnd && L.onEnd(k.onEnd), L.start(k.metadata), L.send(k.request), L.finishSend(), { close: function() {\n          L.close();\n        } };\n      };\n    }, 65: function(v, S, g) {\n      Object.defineProperty(S, \"__esModule\", { value: !0 }), S.Metadata = void 0;\n      var E = g(418);\n      Object.defineProperty(S, \"Metadata\", { enumerable: !0, get: function() {\n        return E.BrowserHeaders;\n      } });\n    }, 57: function(v, S, g) {\n      Object.defineProperty(S, \"__esModule\", { value: !0 }), S.makeDefaultTransport = S.setDefaultTransportFactory = void 0;\n      var E = g(859), _ = function(k) {\n        return E.CrossBrowserHttpTransport({ withCredentials: !1 })(k);\n      };\n      S.setDefaultTransportFactory = function(k) {\n        _ = k;\n      }, S.makeDefaultTransport = function(k) {\n        return _(k);\n      };\n    }, 229: function(v, S, g) {\n      var E = this && this.__assign || function() {\n        return (E = Object.assign || function(M) {\n          for (var $, J = 1, V = arguments.length; J < V; J++)\n            for (var q in $ = arguments[J])\n              Object.prototype.hasOwnProperty.call($, q) && (M[q] = $[q]);\n          return M;\n        }).apply(this, arguments);\n      };\n      Object.defineProperty(S, \"__esModule\", { value: !0 }), S.detectFetchSupport = S.FetchReadableStreamTransport = void 0;\n      var _ = g(65), k = g(346);\n      S.FetchReadableStreamTransport = function(M) {\n        return function($) {\n          return function(J, V) {\n            return J.debug && k.debug(\"fetchRequest\", J), new L(J, V);\n          }($, M);\n        };\n      };\n      var L = function() {\n        function M($, J) {\n          this.cancelled = !1, this.controller = self.AbortController && new AbortController(), this.options = $, this.init = J;\n        }\n        return M.prototype.pump = function($, J) {\n          var V = this;\n          if (this.reader = $, this.cancelled)\n            return this.options.debug && k.debug(\"Fetch.pump.cancel at first pump\"), void this.reader.cancel().catch(function(q) {\n              V.options.debug && k.debug(\"Fetch.pump.reader.cancel exception\", q);\n            });\n          this.reader.read().then(function(q) {\n            if (q.done)\n              return V.options.onEnd(), J;\n            V.options.onChunk(q.value), V.pump(V.reader, J);\n          }).catch(function(q) {\n            V.cancelled ? V.options.debug && k.debug(\"Fetch.catch - request cancelled\") : (V.cancelled = !0, V.options.debug && k.debug(\"Fetch.catch\", q.message), V.options.onEnd(q));\n          });\n        }, M.prototype.send = function($) {\n          var J = this;\n          fetch(this.options.url, E(E({}, this.init), { headers: this.metadata.toHeaders(), method: \"POST\", body: $, signal: this.controller && this.controller.signal })).then(function(V) {\n            if (J.options.debug && k.debug(\"Fetch.response\", V), J.options.onHeaders(new _.Metadata(V.headers), V.status), !V.body)\n              return V;\n            J.pump(V.body.getReader(), V);\n          }).catch(function(V) {\n            J.cancelled ? J.options.debug && k.debug(\"Fetch.catch - request cancelled\") : (J.cancelled = !0, J.options.debug && k.debug(\"Fetch.catch\", V.message), J.options.onEnd(V));\n          });\n        }, M.prototype.sendMessage = function($) {\n          this.send($);\n        }, M.prototype.finishSend = function() {\n        }, M.prototype.start = function($) {\n          this.metadata = $;\n        }, M.prototype.cancel = function() {\n          var $ = this;\n          this.cancelled ? this.options.debug && k.debug(\"Fetch.cancel already cancelled\") : (this.cancelled = !0, this.controller ? (this.options.debug && k.debug(\"Fetch.cancel.controller.abort\"), this.controller.abort()) : this.options.debug && k.debug(\"Fetch.cancel.missing abort controller\"), this.reader ? (this.options.debug && k.debug(\"Fetch.cancel.reader.cancel\"), this.reader.cancel().catch(function(J) {\n            $.options.debug && k.debug(\"Fetch.cancel.reader.cancel exception\", J);\n          })) : this.options.debug && k.debug(\"Fetch.cancel before reader\"));\n        }, M;\n      }();\n      S.detectFetchSupport = function() {\n        return typeof Response < \"u\" && Response.prototype.hasOwnProperty(\"body\") && typeof Headers == \"function\";\n      };\n    }, 859: function(v, S, g) {\n      Object.defineProperty(S, \"__esModule\", { value: !0 }), S.CrossBrowserHttpTransport = void 0;\n      var E = g(229), _ = g(210);\n      S.CrossBrowserHttpTransport = function(k) {\n        if (E.detectFetchSupport()) {\n          var L = { credentials: k.withCredentials ? \"include\" : \"same-origin\" };\n          return E.FetchReadableStreamTransport(L);\n        }\n        return _.XhrTransport({ withCredentials: k.withCredentials });\n      };\n    }, 210: function(v, S, g) {\n      var E, _ = this && this.__extends || (E = function(G, H) {\n        return (E = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(B, Y) {\n          B.__proto__ = Y;\n        } || function(B, Y) {\n          for (var ne in Y)\n            Object.prototype.hasOwnProperty.call(Y, ne) && (B[ne] = Y[ne]);\n        })(G, H);\n      }, function(G, H) {\n        function B() {\n          this.constructor = G;\n        }\n        E(G, H), G.prototype = H === null ? Object.create(H) : (B.prototype = H.prototype, new B());\n      });\n      Object.defineProperty(S, \"__esModule\", { value: !0 }), S.stringToArrayBuffer = S.MozChunkedArrayBufferXHR = S.XHR = S.XhrTransport = void 0;\n      var k = g(65), L = g(346), M = g(849);\n      S.XhrTransport = function(G) {\n        return function(H) {\n          if (M.detectMozXHRSupport())\n            return new J(H, G);\n          if (M.detectXHROverrideMimeTypeSupport())\n            return new $(H, G);\n          throw new Error(\"This environment's XHR implementation cannot support binary transfer.\");\n        };\n      };\n      var $ = function() {\n        function G(H, B) {\n          this.options = H, this.init = B;\n        }\n        return G.prototype.onProgressEvent = function() {\n          this.options.debug && L.debug(\"XHR.onProgressEvent.length: \", this.xhr.response.length);\n          var H = this.xhr.response.substr(this.index);\n          this.index = this.xhr.response.length;\n          var B = q(H);\n          this.options.onChunk(B);\n        }, G.prototype.onLoadEvent = function() {\n          this.options.debug && L.debug(\"XHR.onLoadEvent\"), this.options.onEnd();\n        }, G.prototype.onStateChange = function() {\n          this.options.debug && L.debug(\"XHR.onStateChange\", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new k.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);\n        }, G.prototype.sendMessage = function(H) {\n          this.xhr.send(H);\n        }, G.prototype.finishSend = function() {\n        }, G.prototype.start = function(H) {\n          var B = this;\n          this.metadata = H;\n          var Y = new XMLHttpRequest();\n          this.xhr = Y, Y.open(\"POST\", this.options.url), this.configureXhr(), this.metadata.forEach(function(ne, Z) {\n            Y.setRequestHeader(ne, Z.join(\", \"));\n          }), Y.withCredentials = !!this.init.withCredentials, Y.addEventListener(\"readystatechange\", this.onStateChange.bind(this)), Y.addEventListener(\"progress\", this.onProgressEvent.bind(this)), Y.addEventListener(\"loadend\", this.onLoadEvent.bind(this)), Y.addEventListener(\"error\", function(ne) {\n            B.options.debug && L.debug(\"XHR.error\", ne), B.options.onEnd(ne.error);\n          });\n        }, G.prototype.configureXhr = function() {\n          this.xhr.responseType = \"text\", this.xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n        }, G.prototype.cancel = function() {\n          this.options.debug && L.debug(\"XHR.abort\"), this.xhr.abort();\n        }, G;\n      }();\n      S.XHR = $;\n      var J = function(G) {\n        function H() {\n          return G !== null && G.apply(this, arguments) || this;\n        }\n        return _(H, G), H.prototype.configureXhr = function() {\n          this.options.debug && L.debug(\"MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'\"), this.xhr.responseType = \"moz-chunked-arraybuffer\";\n        }, H.prototype.onProgressEvent = function() {\n          var B = this.xhr.response;\n          this.options.debug && L.debug(\"MozXHR.onProgressEvent: \", new Uint8Array(B)), this.options.onChunk(new Uint8Array(B));\n        }, H;\n      }($);\n      function V(G, H) {\n        var B = G.charCodeAt(H);\n        if (B >= 55296 && B <= 56319) {\n          var Y = G.charCodeAt(H + 1);\n          Y >= 56320 && Y <= 57343 && (B = 65536 + (B - 55296 << 10) + (Y - 56320));\n        }\n        return B;\n      }\n      function q(G) {\n        for (var H = new Uint8Array(G.length), B = 0, Y = 0; Y < G.length; Y++) {\n          var ne = String.prototype.codePointAt ? G.codePointAt(Y) : V(G, Y);\n          H[B++] = 255 & ne;\n        }\n        return H;\n      }\n      S.MozChunkedArrayBufferXHR = J, S.stringToArrayBuffer = q;\n    }, 849: function(v, S) {\n      var g;\n      function E() {\n        if (g !== void 0)\n          return g;\n        if (XMLHttpRequest) {\n          g = new XMLHttpRequest();\n          try {\n            g.open(\"GET\", \"https://localhost\");\n          } catch {\n          }\n        }\n        return g;\n      }\n      function _(k) {\n        var L = E();\n        if (!L)\n          return !1;\n        try {\n          return L.responseType = k, L.responseType === k;\n        } catch {\n        }\n        return !1;\n      }\n      Object.defineProperty(S, \"__esModule\", { value: !0 }), S.detectXHROverrideMimeTypeSupport = S.detectMozXHRSupport = S.xhrSupportsResponseType = void 0, S.xhrSupportsResponseType = _, S.detectMozXHRSupport = function() {\n        return typeof XMLHttpRequest < \"u\" && _(\"moz-chunked-arraybuffer\");\n      }, S.detectXHROverrideMimeTypeSupport = function() {\n        return typeof XMLHttpRequest < \"u\" && XMLHttpRequest.prototype.hasOwnProperty(\"overrideMimeType\");\n      };\n    }, 540: function(v, S, g) {\n      Object.defineProperty(S, \"__esModule\", { value: !0 }), S.WebsocketTransport = void 0;\n      var E, _ = g(346), k = g(617);\n      (function(M) {\n        M[M.FINISH_SEND = 1] = \"FINISH_SEND\";\n      })(E || (E = {}));\n      var L = new Uint8Array([1]);\n      S.WebsocketTransport = function() {\n        return function(M) {\n          return function($) {\n            $.debug && _.debug(\"websocketRequest\", $);\n            var J, V = function(H) {\n              if (H.substr(0, 8) === \"https://\")\n                return \"wss://\" + H.substr(8);\n              if (H.substr(0, 7) === \"http://\")\n                return \"ws://\" + H.substr(7);\n              throw new Error(\"Websocket transport constructed with non-https:// or http:// host.\");\n            }($.url), q = [];\n            function G(H) {\n              if (H === E.FINISH_SEND)\n                J.send(L);\n              else {\n                var B = H, Y = new Int8Array(B.byteLength + 1);\n                Y.set(new Uint8Array([0])), Y.set(B, 1), J.send(Y);\n              }\n            }\n            return { sendMessage: function(H) {\n              J && J.readyState !== J.CONNECTING ? G(H) : q.push(H);\n            }, finishSend: function() {\n              J && J.readyState !== J.CONNECTING ? G(E.FINISH_SEND) : q.push(E.FINISH_SEND);\n            }, start: function(H) {\n              (J = new WebSocket(V, [\"grpc-websockets\"])).binaryType = \"arraybuffer\", J.onopen = function() {\n                var B;\n                $.debug && _.debug(\"websocketRequest.onopen\"), J.send((B = \"\", H.forEach(function(Y, ne) {\n                  B += Y + \": \" + ne.join(\", \") + `\\r\n`;\n                }), k.encodeASCII(B))), q.forEach(function(Y) {\n                  G(Y);\n                });\n              }, J.onclose = function(B) {\n                $.debug && _.debug(\"websocketRequest.onclose\", B), $.onEnd();\n              }, J.onerror = function(B) {\n                $.debug && _.debug(\"websocketRequest.onerror\", B);\n              }, J.onmessage = function(B) {\n                $.onChunk(new Uint8Array(B.data));\n              };\n            }, cancel: function() {\n              $.debug && _.debug(\"websocket.abort\"), J.close();\n            } };\n          }(M);\n        };\n      };\n    }, 35: function(v, S, g) {\n      Object.defineProperty(S, \"__esModule\", { value: !0 }), S.unary = void 0;\n      var E = g(65), _ = g(934);\n      S.unary = function(k, L) {\n        if (k.responseStream)\n          throw new Error(\".unary cannot be used with server-streaming methods. Use .invoke or .client instead.\");\n        if (k.requestStream)\n          throw new Error(\".unary cannot be used with client-streaming methods. Use .client instead.\");\n        var M = null, $ = null, J = _.client(k, { host: L.host, transport: L.transport, debug: L.debug });\n        return J.onHeaders(function(V) {\n          M = V;\n        }), J.onMessage(function(V) {\n          $ = V;\n        }), J.onEnd(function(V, q, G) {\n          L.onEnd({ status: V, statusMessage: q, headers: M || new E.Metadata(), message: $, trailers: G });\n        }), J.start(L.metadata), J.send(L.request), J.finishSend(), { close: function() {\n          J.close();\n        } };\n      };\n    }, 882: function(v, S) {\n      Object.defineProperty(S, \"__esModule\", { value: !0 }), S.frameRequest = void 0, S.frameRequest = function(g) {\n        var E = g.serializeBinary(), _ = new ArrayBuffer(E.byteLength + 5);\n        return new DataView(_, 1, 4).setUint32(0, E.length, !1), new Uint8Array(_, 5).set(E), new Uint8Array(_);\n      };\n    } }, l = {}, function v(S) {\n      if (l[S])\n        return l[S].exports;\n      var g = l[S] = { exports: {} };\n      return c[S].call(g.exports, g, g.exports, v), g.exports;\n    }(607);\n    var c, l;\n  });\n})(grpcWebClient_umd);\nvar grpcWebClient_umdExports = grpcWebClient_umd.exports;\nclass AbortError extends Error {\n  constructor() {\n    super(\"The operation has been aborted\"), this.message = \"The operation has been aborted\", this.name = \"AbortError\", typeof Error.captureStackTrace == \"function\" && Error.captureStackTrace(this, this.constructor);\n  }\n}\nfunction isAbortError(a) {\n  return typeof a == \"object\" && a !== null && a.name === \"AbortError\";\n}\nfunction throwIfAborted(a) {\n  if (a.aborted)\n    throw new AbortError();\n}\nfunction rethrowAbortError(a) {\n  if (isAbortError(a))\n    throw a;\n}\nfunction catchAbortError(a) {\n  if (!isAbortError(a))\n    throw a;\n}\nfunction execute(a, u) {\n  return new Promise((c, l) => {\n    if (a.aborted) {\n      l(new AbortError());\n      return;\n    }\n    let v, S = !1;\n    function g() {\n      S || (S = !0, v != null && v());\n    }\n    const E = u((_) => {\n      c(_), g();\n    }, (_) => {\n      l(_), g();\n    });\n    if (!S) {\n      const _ = () => {\n        const k = E();\n        k == null ? l(new AbortError()) : k.then(() => {\n          l(new AbortError());\n        }, (L) => {\n          l(L);\n        }), g();\n      };\n      a.addEventListener(\"abort\", _), v = () => {\n        a.removeEventListener(\"abort\", _);\n      };\n    }\n  });\n}\nfunction abortable(a, u) {\n  if (a.aborted) {\n    const c = () => {\n    };\n    u.then(c, c);\n  }\n  return execute(a, (c, l) => (u.then(c, l), () => {\n  }));\n}\nfunction delay$1(a, u) {\n  return execute(a, (c) => {\n    const l = typeof u == \"number\" ? u : u.getTime() - Date.now(), v = setTimeout(c, l);\n    return () => {\n      clearTimeout(v);\n    };\n  });\n}\nfunction forever(a) {\n  return execute(a, () => () => {\n  });\n}\nfunction waitForEvent(a, u, c, l) {\n  return execute(a, (v) => {\n    let S, g = !1;\n    return S = listen(u, c, (..._) => {\n      v(_.length > 1 ? _ : _[0]), g = !0, S != null && S();\n    }, l), g && S(), () => {\n      g = !0, S != null && S();\n    };\n  });\n}\nfunction listen(a, u, c, l) {\n  if (isEventTarget(a))\n    return a.addEventListener(u, c, l), () => a.removeEventListener(u, c, l);\n  if (isJQueryStyleEventEmitter(a))\n    return a.on(u, c), () => a.off(u, c);\n  if (isNodeStyleEventEmitter(a))\n    return a.addListener(u, c), () => a.removeListener(u, c);\n  throw new Error(\"Invalid event target\");\n}\nfunction isNodeStyleEventEmitter(a) {\n  return isFunction$3(a.addListener) && isFunction$3(a.removeListener);\n}\nfunction isJQueryStyleEventEmitter(a) {\n  return isFunction$3(a.on) && isFunction$3(a.off);\n}\nfunction isEventTarget(a) {\n  return isFunction$3(a.addEventListener) && isFunction$3(a.removeEventListener);\n}\nconst isFunction$3 = (a) => typeof a == \"function\";\nvar browser$3 = { exports: {} };\nconst _global = typeof self < \"u\" ? self : typeof window < \"u\" ? window : (\n  /* otherwise */\n  void 0\n);\nif (!_global)\n  throw new Error(\n    \"Unable to find global scope. Are you sure this is running in the browser?\"\n  );\nif (!_global.AbortController)\n  throw new Error(\n    'Could not find \"AbortController\" in the global scope. You need to polyfill it first'\n  );\nbrowser$3.exports = _global.AbortController;\nbrowser$3.exports.default = _global.AbortController;\nvar browserExports = browser$3.exports;\nconst AbortController$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports);\nfunction all(a, u) {\n  return new Promise((c, l) => {\n    if (a.aborted) {\n      l(new AbortError());\n      return;\n    }\n    const v = new AbortController$1(), S = u(v.signal);\n    if (S.length === 0) {\n      c([]);\n      return;\n    }\n    const g = () => {\n      v.abort();\n    };\n    a.addEventListener(\"abort\", g);\n    let E;\n    const _ = new Array(S.length);\n    let k = 0;\n    function L() {\n      k += 1, k === S.length && (a.removeEventListener(\"abort\", g), E != null ? l(E.reason) : c(_));\n    }\n    for (const [M, $] of S.entries())\n      $.then((J) => {\n        _[M] = J, L();\n      }, (J) => {\n        v.abort(), (E == null || !isAbortError(J) && isAbortError(E.reason)) && (E = { reason: J }), L();\n      });\n  });\n}\nfunction race$2(a, u) {\n  return new Promise((c, l) => {\n    if (a.aborted) {\n      l(new AbortError());\n      return;\n    }\n    const v = new AbortController$1(), S = u(v.signal), g = () => {\n      v.abort();\n    };\n    a.addEventListener(\"abort\", g);\n    let E = 0;\n    function _(L) {\n      v.abort(), E += 1, E === S.length && (a.removeEventListener(\"abort\", g), L.status === \"fulfilled\" ? c(L.value) : l(L.reason));\n    }\n    let k;\n    for (const L of S)\n      L.then((M) => {\n        k == null && (k = { status: \"fulfilled\", value: M }), _(k);\n      }, (M) => {\n        (k == null || !isAbortError(M) && (k.status === \"fulfilled\" || isAbortError(k.reason))) && (k = { status: \"rejected\", reason: M }), _(k);\n      });\n  });\n}\nasync function retry$1(a, u, c = {}) {\n  const { baseMs: l = 1e3, maxDelayMs: v = 15e3, onError: S, maxAttempts: g = 1 / 0 } = c;\n  let E = 0;\n  const _ = () => {\n    E = -1;\n  };\n  for (; ; )\n    try {\n      return await u(a, E, _);\n    } catch (k) {\n      if (rethrowAbortError(k), E >= g)\n        throw k;\n      let L;\n      if (E === -1)\n        L = 0;\n      else {\n        const M = Math.min(v, Math.pow(2, E) * l);\n        L = Math.round(M * (1 + Math.random()) / 2);\n      }\n      S && S(k, E, L), L !== 0 && await delay$1(a, L), E += 1;\n    }\n}\nfunction spawn(a, u) {\n  if (a.aborted)\n    return Promise.reject(new AbortError());\n  const c = [], l = new AbortController$1(), v = l.signal, S = () => {\n    l.abort();\n  };\n  a.addEventListener(\"abort\", S);\n  const g = () => {\n    a.removeEventListener(\"abort\", S);\n  }, E = /* @__PURE__ */ new Set(), _ = () => {\n    for (const M of E)\n      M.abort();\n  };\n  v.addEventListener(\"abort\", _);\n  const k = () => {\n    v.removeEventListener(\"abort\", _);\n  };\n  let L = new Promise((M, $) => {\n    let J, V;\n    q((G) => u(G, {\n      defer(H) {\n        c.push(H);\n      },\n      fork: q\n    })).join().then((G) => {\n      l.abort(), J = { value: G };\n    }, (G) => {\n      l.abort(), (!isAbortError(G) || V == null) && (V = { error: G });\n    });\n    function q(G) {\n      if (v.aborted)\n        return {\n          abort() {\n          },\n          async join() {\n            throw new AbortError();\n          }\n        };\n      const H = new AbortController$1(), B = H.signal, Y = G(B), ne = {\n        abort() {\n          H.abort();\n        },\n        join: () => Y\n      };\n      return E.add(ne), Y.catch(catchAbortError).catch((Z) => {\n        V = { error: Z }, l.abort();\n      }).finally(() => {\n        E.delete(ne), E.size === 0 && (V != null ? $(V.error) : M(J.value));\n      }), ne;\n    }\n  });\n  return L = L.finally(() => {\n    g(), k();\n    let M = Promise.resolve();\n    for (let $ = c.length - 1; $ >= 0; $--)\n      M = M.finally(c[$]);\n    return M;\n  }), L;\n}\nfunction run(a) {\n  const u = new AbortController$1(), c = a(u.signal).catch(catchAbortError);\n  return () => (u.abort(), c);\n}\nconst es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  AbortError,\n  abortable,\n  all,\n  catchAbortError,\n  delay: delay$1,\n  execute,\n  forever,\n  isAbortError,\n  race: race$2,\n  rethrowAbortError,\n  retry: retry$1,\n  run,\n  spawn,\n  throwIfAborted,\n  waitForEvent\n}, Symbol.toStringTag, { value: \"Module\" })), require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(es);\nvar AsyncSink$1 = {};\nObject.defineProperty(AsyncSink$1, \"__esModule\", { value: !0 });\nAsyncSink$1.AsyncSink = void 0;\nconst ARRAY_VALUE = \"value\", ARRAY_ERROR = \"error\";\nclass AsyncSink {\n  constructor() {\n    this._ended = !1, this._values = [], this._resolvers = [];\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  write(u) {\n    this._push({ type: ARRAY_VALUE, value: u });\n  }\n  error(u) {\n    this._push({ type: ARRAY_ERROR, error: u });\n  }\n  _push(u) {\n    if (this._ended)\n      throw new Error(\"AsyncSink already ended\");\n    if (this._resolvers.length > 0) {\n      const { resolve: c, reject: l } = this._resolvers.shift();\n      u.type === ARRAY_ERROR ? l(u.error) : c({ done: !1, value: u.value });\n    } else\n      this._values.push(u);\n  }\n  next() {\n    if (this._values.length > 0) {\n      const { type: u, value: c, error: l } = this._values.shift();\n      return u === ARRAY_ERROR ? Promise.reject(l) : Promise.resolve({ done: !1, value: c });\n    }\n    return this._ended ? Promise.resolve({ done: !0 }) : new Promise((u, c) => {\n      this._resolvers.push({ resolve: u, reject: c });\n    });\n  }\n  end() {\n    for (; this._resolvers.length > 0; )\n      this._resolvers.shift().resolve({ done: !0 });\n    this._ended = !0;\n  }\n}\nAsyncSink$1.AsyncSink = AsyncSink;\nvar isAsyncIterable$1 = {};\nObject.defineProperty(isAsyncIterable$1, \"__esModule\", { value: !0 });\nisAsyncIterable$1.isAsyncIterable = void 0;\nfunction isAsyncIterable(a) {\n  return a != null && Symbol.asyncIterator in a;\n}\nisAsyncIterable$1.isAsyncIterable = isAsyncIterable;\nvar convertMetadata = {}, base64$2 = { exports: {} };\n(function(a, u) {\n  (function(c, l) {\n    a.exports = l();\n  })(typeof self < \"u\" ? self : typeof window < \"u\" ? window : commonjsGlobal$1, function() {\n    var c = \"3.7.2\", l = c, v = typeof atob == \"function\", S = typeof btoa == \"function\", g = typeof Buffer == \"function\", E = typeof TextDecoder == \"function\" ? new TextDecoder() : void 0, _ = typeof TextEncoder == \"function\" ? new TextEncoder() : void 0, k = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\", L = Array.prototype.slice.call(k), M = function(be) {\n      var Ae = {};\n      return be.forEach(function(qe, xe) {\n        return Ae[qe] = xe;\n      }), Ae;\n    }(L), $ = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/, J = String.fromCharCode.bind(String), V = typeof Uint8Array.from == \"function\" ? Uint8Array.from.bind(Uint8Array) : function(be, Ae) {\n      return Ae === void 0 && (Ae = function(qe) {\n        return qe;\n      }), new Uint8Array(Array.prototype.slice.call(be, 0).map(Ae));\n    }, q = function(be) {\n      return be.replace(/=/g, \"\").replace(/[+\\/]/g, function(Ae) {\n        return Ae == \"+\" ? \"-\" : \"_\";\n      });\n    }, G = function(be) {\n      return be.replace(/[^A-Za-z0-9\\+\\/]/g, \"\");\n    }, H = function(be) {\n      for (var Ae, qe, xe, Pe, C = \"\", x = be.length % 3, Q = 0; Q < be.length; ) {\n        if ((qe = be.charCodeAt(Q++)) > 255 || (xe = be.charCodeAt(Q++)) > 255 || (Pe = be.charCodeAt(Q++)) > 255)\n          throw new TypeError(\"invalid character found\");\n        Ae = qe << 16 | xe << 8 | Pe, C += L[Ae >> 18 & 63] + L[Ae >> 12 & 63] + L[Ae >> 6 & 63] + L[Ae & 63];\n      }\n      return x ? C.slice(0, x - 3) + \"===\".substring(x) : C;\n    }, B = S ? function(be) {\n      return btoa(be);\n    } : g ? function(be) {\n      return Buffer.from(be, \"binary\").toString(\"base64\");\n    } : H, Y = g ? function(be) {\n      return Buffer.from(be).toString(\"base64\");\n    } : function(be) {\n      for (var Ae = 4096, qe = [], xe = 0, Pe = be.length; xe < Pe; xe += Ae)\n        qe.push(J.apply(null, be.subarray(xe, xe + Ae)));\n      return B(qe.join(\"\"));\n    }, ne = function(be, Ae) {\n      return Ae === void 0 && (Ae = !1), Ae ? q(Y(be)) : Y(be);\n    }, Z = function(be) {\n      if (be.length < 2) {\n        var Ae = be.charCodeAt(0);\n        return Ae < 128 ? be : Ae < 2048 ? J(192 | Ae >>> 6) + J(128 | Ae & 63) : J(224 | Ae >>> 12 & 15) + J(128 | Ae >>> 6 & 63) + J(128 | Ae & 63);\n      } else {\n        var Ae = 65536 + (be.charCodeAt(0) - 55296) * 1024 + (be.charCodeAt(1) - 56320);\n        return J(240 | Ae >>> 18 & 7) + J(128 | Ae >>> 12 & 63) + J(128 | Ae >>> 6 & 63) + J(128 | Ae & 63);\n      }\n    }, re = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g, oe = function(be) {\n      return be.replace(re, Z);\n    }, de = g ? function(be) {\n      return Buffer.from(be, \"utf8\").toString(\"base64\");\n    } : _ ? function(be) {\n      return Y(_.encode(be));\n    } : function(be) {\n      return B(oe(be));\n    }, A = function(be, Ae) {\n      return Ae === void 0 && (Ae = !1), Ae ? q(de(be)) : de(be);\n    }, N = function(be) {\n      return A(be, !0);\n    }, D = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g, W = function(be) {\n      switch (be.length) {\n        case 4:\n          var Ae = (7 & be.charCodeAt(0)) << 18 | (63 & be.charCodeAt(1)) << 12 | (63 & be.charCodeAt(2)) << 6 | 63 & be.charCodeAt(3), qe = Ae - 65536;\n          return J((qe >>> 10) + 55296) + J((qe & 1023) + 56320);\n        case 3:\n          return J((15 & be.charCodeAt(0)) << 12 | (63 & be.charCodeAt(1)) << 6 | 63 & be.charCodeAt(2));\n        default:\n          return J((31 & be.charCodeAt(0)) << 6 | 63 & be.charCodeAt(1));\n      }\n    }, ee = function(be) {\n      return be.replace(D, W);\n    }, ae = function(be) {\n      if (be = be.replace(/\\s+/g, \"\"), !$.test(be))\n        throw new TypeError(\"malformed base64.\");\n      be += \"==\".slice(2 - (be.length & 3));\n      for (var Ae, qe = \"\", xe, Pe, C = 0; C < be.length; )\n        Ae = M[be.charAt(C++)] << 18 | M[be.charAt(C++)] << 12 | (xe = M[be.charAt(C++)]) << 6 | (Pe = M[be.charAt(C++)]), qe += xe === 64 ? J(Ae >> 16 & 255) : Pe === 64 ? J(Ae >> 16 & 255, Ae >> 8 & 255) : J(Ae >> 16 & 255, Ae >> 8 & 255, Ae & 255);\n      return qe;\n    }, ye = v ? function(be) {\n      return atob(G(be));\n    } : g ? function(be) {\n      return Buffer.from(be, \"base64\").toString(\"binary\");\n    } : ae, he = g ? function(be) {\n      return V(Buffer.from(be, \"base64\"));\n    } : function(be) {\n      return V(ye(be), function(Ae) {\n        return Ae.charCodeAt(0);\n      });\n    }, le = function(be) {\n      return he(Be(be));\n    }, we = g ? function(be) {\n      return Buffer.from(be, \"base64\").toString(\"utf8\");\n    } : E ? function(be) {\n      return E.decode(he(be));\n    } : function(be) {\n      return ee(ye(be));\n    }, Be = function(be) {\n      return G(be.replace(/[-_]/g, function(Ae) {\n        return Ae == \"-\" ? \"+\" : \"/\";\n      }));\n    }, Ne = function(be) {\n      return we(Be(be));\n    }, Le = function(be) {\n      if (typeof be != \"string\")\n        return !1;\n      var Ae = be.replace(/\\s+/g, \"\").replace(/={0,2}$/, \"\");\n      return !/[^\\s0-9a-zA-Z\\+/]/.test(Ae) || !/[^\\s0-9a-zA-Z\\-_]/.test(Ae);\n    }, $e = function(be) {\n      return {\n        value: be,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      };\n    }, Ue = function() {\n      var be = function(Ae, qe) {\n        return Object.defineProperty(String.prototype, Ae, $e(qe));\n      };\n      be(\"fromBase64\", function() {\n        return Ne(this);\n      }), be(\"toBase64\", function(Ae) {\n        return A(this, Ae);\n      }), be(\"toBase64URI\", function() {\n        return A(this, !0);\n      }), be(\"toBase64URL\", function() {\n        return A(this, !0);\n      }), be(\"toUint8Array\", function() {\n        return le(this);\n      });\n    }, Ge = function() {\n      var be = function(Ae, qe) {\n        return Object.defineProperty(Uint8Array.prototype, Ae, $e(qe));\n      };\n      be(\"toBase64\", function(Ae) {\n        return ne(this, Ae);\n      }), be(\"toBase64URI\", function() {\n        return ne(this, !0);\n      }), be(\"toBase64URL\", function() {\n        return ne(this, !0);\n      });\n    }, He = function() {\n      Ue(), Ge();\n    }, Ve = {\n      version: c,\n      VERSION: l,\n      atob: ye,\n      atobPolyfill: ae,\n      btoa: B,\n      btoaPolyfill: H,\n      fromBase64: Ne,\n      toBase64: A,\n      encode: A,\n      encodeURI: N,\n      encodeURL: N,\n      utob: oe,\n      btou: ee,\n      decode: Ne,\n      isValid: Le,\n      fromUint8Array: ne,\n      toUint8Array: le,\n      extendString: Ue,\n      extendUint8Array: Ge,\n      extendBuiltins: He\n    };\n    return Ve.Base64 = {}, Object.keys(Ve).forEach(function(be) {\n      return Ve.Base64[be] = Ve[be];\n    }), Ve;\n  });\n})(base64$2);\nvar base64Exports = base64$2.exports;\nObject.defineProperty(convertMetadata, \"__esModule\", { value: !0 });\nconvertMetadata.convertMetadataFromGrpcWeb = convertMetadata.convertMetadataToGrpcWeb = void 0;\nconst grpc_web_1$4 = grpcWebClient_umdExports, nice_grpc_common_1$5 = lib, js_base64_1 = base64Exports;\nfunction convertMetadataToGrpcWeb(a) {\n  const u = new grpc_web_1$4.grpc.Metadata();\n  for (const [c, l] of a)\n    for (const v of l)\n      u.append(c, typeof v == \"string\" ? v : js_base64_1.Base64.fromUint8Array(v));\n  return u;\n}\nconvertMetadata.convertMetadataToGrpcWeb = convertMetadataToGrpcWeb;\nfunction convertMetadataFromGrpcWeb(a) {\n  const u = (0, nice_grpc_common_1$5.Metadata)();\n  for (const [c, l] of Object.entries(a.headersMap))\n    u.set(c, c.endsWith(\"-bin\") ? l.map((v) => js_base64_1.Base64.toUint8Array(v)) : l);\n  return u;\n}\nconvertMetadata.convertMetadataFromGrpcWeb = convertMetadataFromGrpcWeb;\nvar __importDefault$h = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(createBidiStreamingMethod$1, \"__esModule\", { value: !0 });\ncreateBidiStreamingMethod$1.createBidiStreamingMethod = void 0;\nconst nice_grpc_common_1$4 = lib, grpc_web_1$3 = grpcWebClient_umdExports, abort_controller_x_1$4 = require$$1$1, node_abort_controller_1$3 = __importDefault$h(browserExports), AsyncSink_1$1 = AsyncSink$1, service_definitions_1$4 = serviceDefinitions, isAsyncIterable_1$3 = isAsyncIterable$1, convertMetadata_1$3 = convertMetadata;\nfunction createBidiStreamingMethod(a, u, c, l) {\n  const v = (0, service_definitions_1$4.toGrpcWebMethodDefinition)(a), S = {\n    path: a.path,\n    requestStream: a.requestStream,\n    responseStream: a.responseStream,\n    options: a.options\n  };\n  async function* g(_, k) {\n    if (!(0, isAsyncIterable_1$3.isAsyncIterable)(_))\n      throw new Error(\"A middleware passed invalid request to next(): expected a single message for bidirectional streaming method\");\n    const { metadata: L = (0, nice_grpc_common_1$4.Metadata)(), signal: M = new node_abort_controller_1$3.default().signal, onHeader: $, onTrailer: J } = k, V = new node_abort_controller_1$3.default(), q = new AsyncSink_1$1.AsyncSink(), G = grpc_web_1$3.grpc.client(v, {\n      host: u.address,\n      transport: u.transport\n    });\n    G.onHeaders((Y) => {\n      $ == null || $((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(Y));\n    }), G.onMessage((Y) => {\n      q.write(Y);\n    }), G.onEnd((Y, ne, Z) => {\n      J == null || J((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(Z)), Y === grpc_web_1$3.grpc.Code.OK ? q.end() : q.error(new nice_grpc_common_1$4.ClientError(a.path, +Y, ne));\n    }), G.start((0, convertMetadata_1$3.convertMetadataToGrpcWeb)(L));\n    let H;\n    pipeRequest$1(V.signal, _, G, a).then(() => {\n      G.finishSend();\n    }, (Y) => {\n      (0, abort_controller_x_1$4.isAbortError)(Y) || (H = Y, G.close(), q.end());\n    });\n    const B = () => {\n      q.error(new abort_controller_x_1$4.AbortError()), V.abort(), G.close();\n    };\n    M.addEventListener(\"abort\", B);\n    try {\n      yield* q;\n    } finally {\n      if (V.abort(), M.removeEventListener(\"abort\", B), (0, abort_controller_x_1$4.throwIfAborted)(M), H)\n        throw H;\n    }\n  }\n  const E = c == null ? g : (_, k) => c({\n    method: S,\n    requestStream: !0,\n    request: _,\n    responseStream: !0,\n    next: g\n  }, k);\n  return (_, k) => {\n    const M = E(_, {\n      ...l,\n      ...k\n    })[Symbol.asyncIterator]();\n    return {\n      [Symbol.asyncIterator]() {\n        return {\n          async next() {\n            const $ = await M.next();\n            return $.done && $.value != null ? await M.throw(new Error(\"A middleware returned a message, but expected to return void for bidirectional streaming method\")) : $;\n          },\n          return() {\n            return M.return();\n          },\n          throw($) {\n            return M.throw($);\n          }\n        };\n      }\n    };\n  };\n}\ncreateBidiStreamingMethod$1.createBidiStreamingMethod = createBidiStreamingMethod;\nasync function pipeRequest$1(a, u, c, l) {\n  for await (const v of u)\n    (0, abort_controller_x_1$4.throwIfAborted)(a), c.send({\n      serializeBinary: () => l.requestSerialize(v)\n    });\n}\nvar createClientStreamingMethod$1 = {}, __importDefault$g = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(createClientStreamingMethod$1, \"__esModule\", { value: !0 });\ncreateClientStreamingMethod$1.createClientStreamingMethod = void 0;\nconst nice_grpc_common_1$3 = lib, grpc_web_1$2 = grpcWebClient_umdExports, abort_controller_x_1$3 = require$$1$1, node_abort_controller_1$2 = __importDefault$g(browserExports), service_definitions_1$3 = serviceDefinitions, isAsyncIterable_1$2 = isAsyncIterable$1, convertMetadata_1$2 = convertMetadata;\nfunction createClientStreamingMethod(a, u, c, l) {\n  const v = (0, service_definitions_1$3.toGrpcWebMethodDefinition)(a), S = {\n    path: a.path,\n    requestStream: a.requestStream,\n    responseStream: a.responseStream,\n    options: a.options\n  };\n  async function* g(_, k) {\n    if (!(0, isAsyncIterable_1$2.isAsyncIterable)(_))\n      throw new Error(\"A middleware passed invalid request to next(): expected a single message for client streaming method\");\n    const { metadata: L = (0, nice_grpc_common_1$3.Metadata)(), signal: M = new node_abort_controller_1$2.default().signal, onHeader: $, onTrailer: J } = k;\n    return await (0, abort_controller_x_1$3.execute)(M, (V, q) => {\n      const G = new node_abort_controller_1$2.default();\n      let H;\n      const B = grpc_web_1$2.grpc.client(v, {\n        host: u.address,\n        transport: u.transport\n      });\n      return B.onHeaders((Y) => {\n        $ == null || $((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(Y));\n      }), B.onMessage((Y) => {\n        H = Y;\n      }), B.onEnd((Y, ne, Z) => {\n        J == null || J((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(Z)), G.abort(), Y === grpc_web_1$2.grpc.Code.OK ? V(H) : q(new nice_grpc_common_1$3.ClientError(a.path, +Y, ne));\n      }), B.start((0, convertMetadata_1$2.convertMetadataToGrpcWeb)(L)), pipeRequest(G.signal, _, B, a).then(() => {\n        B.finishSend();\n      }, (Y) => {\n        (0, abort_controller_x_1$3.isAbortError)(Y) || (q(Y), B.close());\n      }), () => {\n        G.abort(), B.close();\n      };\n    });\n  }\n  const E = c == null ? g : (_, k) => c({\n    method: S,\n    requestStream: !0,\n    request: _,\n    responseStream: !1,\n    next: g\n  }, k);\n  return async (_, k) => {\n    const M = E(_, {\n      ...l,\n      ...k\n    })[Symbol.asyncIterator]();\n    let $ = await M.next();\n    for (; ; ) {\n      if (!$.done) {\n        $ = await M.throw(new Error(\"A middleware yielded a message, but expected to only return a message for client streaming method\"));\n        continue;\n      }\n      if ($.value == null) {\n        $ = await M.throw(new Error(\"A middleware returned void, but expected to return a message for client streaming method\"));\n        continue;\n      }\n      return $.value;\n    }\n  };\n}\ncreateClientStreamingMethod$1.createClientStreamingMethod = createClientStreamingMethod;\nasync function pipeRequest(a, u, c, l) {\n  for await (const v of u)\n    (0, abort_controller_x_1$3.throwIfAborted)(a), c.send({\n      serializeBinary: () => l.requestSerialize(v)\n    });\n}\nvar createServerStreamingMethod$1 = {}, __importDefault$f = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(createServerStreamingMethod$1, \"__esModule\", { value: !0 });\ncreateServerStreamingMethod$1.createServerStreamingMethod = void 0;\nconst grpc_web_1$1 = grpcWebClient_umdExports, abort_controller_x_1$2 = require$$1$1, AsyncSink_1 = AsyncSink$1, nice_grpc_common_1$2 = lib, node_abort_controller_1$1 = __importDefault$f(browserExports), service_definitions_1$2 = serviceDefinitions, convertMetadata_1$1 = convertMetadata, isAsyncIterable_1$1 = isAsyncIterable$1;\nfunction createServerStreamingMethod(a, u, c, l) {\n  const v = (0, service_definitions_1$2.toGrpcWebMethodDefinition)(a), S = {\n    path: a.path,\n    requestStream: a.requestStream,\n    responseStream: a.responseStream,\n    options: a.options\n  };\n  async function* g(_, k) {\n    if ((0, isAsyncIterable_1$1.isAsyncIterable)(_))\n      throw new Error(\"A middleware passed invalid request to next(): expected a single message for server streaming method\");\n    const { metadata: L = (0, nice_grpc_common_1$2.Metadata)(), signal: M = new node_abort_controller_1$1.default().signal, onHeader: $, onTrailer: J } = k, V = new AsyncSink_1.AsyncSink(), q = grpc_web_1$1.grpc.client(v, {\n      host: u.address,\n      transport: u.transport\n    });\n    q.onHeaders((H) => {\n      $ == null || $((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(H));\n    }), q.onMessage((H) => {\n      V.write(H);\n    }), q.onEnd((H, B, Y) => {\n      J == null || J((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(Y)), H === grpc_web_1$1.grpc.Code.OK ? V.end() : V.error(new nice_grpc_common_1$2.ClientError(a.path, +H, B));\n    }), q.start((0, convertMetadata_1$1.convertMetadataToGrpcWeb)(L)), q.send({\n      serializeBinary: () => a.requestSerialize(_)\n    }), q.finishSend();\n    const G = () => {\n      V.error(new abort_controller_x_1$2.AbortError()), q.close();\n    };\n    M.addEventListener(\"abort\", G);\n    try {\n      yield* V;\n    } finally {\n      M.removeEventListener(\"abort\", G), (0, abort_controller_x_1$2.throwIfAborted)(M);\n    }\n  }\n  const E = c == null ? g : (_, k) => c({\n    method: S,\n    requestStream: !1,\n    request: _,\n    responseStream: !0,\n    next: g\n  }, k);\n  return (_, k) => {\n    const M = E(_, {\n      ...l,\n      ...k\n    })[Symbol.asyncIterator]();\n    return {\n      [Symbol.asyncIterator]() {\n        return {\n          async next() {\n            const $ = await M.next();\n            return $.done && $.value != null ? await M.throw(new Error(\"A middleware returned a message, but expected to return void for server streaming method\")) : $;\n          },\n          return() {\n            return M.return();\n          },\n          throw($) {\n            return M.throw($);\n          }\n        };\n      }\n    };\n  };\n}\ncreateServerStreamingMethod$1.createServerStreamingMethod = createServerStreamingMethod;\nvar createUnaryMethod$1 = {}, __importDefault$e = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(createUnaryMethod$1, \"__esModule\", { value: !0 });\ncreateUnaryMethod$1.createUnaryMethod = void 0;\nconst nice_grpc_common_1$1 = lib, grpc_web_1 = grpcWebClient_umdExports, abort_controller_x_1$1 = require$$1$1, node_abort_controller_1 = __importDefault$e(browserExports), service_definitions_1$1 = serviceDefinitions, isAsyncIterable_1 = isAsyncIterable$1, convertMetadata_1 = convertMetadata;\nfunction createUnaryMethod(a, u, c, l) {\n  const v = (0, service_definitions_1$1.toGrpcWebMethodDefinition)(a), S = {\n    path: a.path,\n    requestStream: a.requestStream,\n    responseStream: a.responseStream,\n    options: a.options\n  };\n  async function* g(_, k) {\n    if ((0, isAsyncIterable_1.isAsyncIterable)(_))\n      throw new Error(\"A middleware passed invalid request to next(): expected a single message for unary method\");\n    const { metadata: L = (0, nice_grpc_common_1$1.Metadata)(), signal: M = new node_abort_controller_1.default().signal, onHeader: $, onTrailer: J } = k;\n    return await (0, abort_controller_x_1$1.execute)(M, (V, q) => {\n      let G;\n      const H = grpc_web_1.grpc.client(v, {\n        host: u.address,\n        transport: u.transport\n      });\n      return H.onHeaders((B) => {\n        $ == null || $((0, convertMetadata_1.convertMetadataFromGrpcWeb)(B));\n      }), H.onMessage((B) => {\n        G = B;\n      }), H.onEnd((B, Y, ne) => {\n        J == null || J((0, convertMetadata_1.convertMetadataFromGrpcWeb)(ne)), B === grpc_web_1.grpc.Code.OK ? V(G) : q(new nice_grpc_common_1$1.ClientError(a.path, +B, Y));\n      }), H.start((0, convertMetadata_1.convertMetadataToGrpcWeb)(L)), H.send({\n        serializeBinary: () => a.requestSerialize(_)\n      }), H.finishSend(), () => {\n        H.close();\n      };\n    });\n  }\n  const E = c == null ? g : (_, k) => c({\n    method: S,\n    requestStream: !1,\n    request: _,\n    responseStream: !1,\n    next: g\n  }, k);\n  return async (_, k) => {\n    const M = E(_, {\n      ...l,\n      ...k\n    })[Symbol.asyncIterator]();\n    let $ = await M.next();\n    for (; ; ) {\n      if (!$.done) {\n        $ = await M.throw(new Error(\"A middleware yielded a message, but expected to only return a message for unary method\"));\n        continue;\n      }\n      if ($.value == null) {\n        $ = await M.throw(new Error(\"A middleware returned void, but expected to return a message for unary method\"));\n        continue;\n      }\n      return $.value;\n    }\n  };\n}\ncreateUnaryMethod$1.createUnaryMethod = createUnaryMethod;\nObject.defineProperty(ClientFactory, \"__esModule\", { value: !0 });\nClientFactory.createClient = ClientFactory.createClientFactory = void 0;\nconst nice_grpc_common_1 = lib, service_definitions_1 = serviceDefinitions, createBidiStreamingMethod_1 = createBidiStreamingMethod$1, createClientStreamingMethod_1 = createClientStreamingMethod$1, createServerStreamingMethod_1 = createServerStreamingMethod$1, createUnaryMethod_1 = createUnaryMethod$1;\nfunction createClientFactory() {\n  return createClientFactoryWithMiddleware();\n}\nClientFactory.createClientFactory = createClientFactory;\nfunction createClient(a, u, c) {\n  return createClientFactory().create(a, u, c);\n}\nClientFactory.createClient = createClient;\nfunction createClientFactoryWithMiddleware(a) {\n  return {\n    use(u) {\n      return createClientFactoryWithMiddleware(a == null ? u : (0, nice_grpc_common_1.composeClientMiddleware)(a, u));\n    },\n    create(u, c, l = {}) {\n      const v = {}, S = Object.entries((0, service_definitions_1.normalizeServiceDefinition)(u));\n      for (const [g, E] of S) {\n        const _ = {\n          ...l[\"*\"],\n          ...l[g]\n        };\n        E.requestStream ? E.responseStream ? v[g] = (0, createBidiStreamingMethod_1.createBidiStreamingMethod)(E, c, a, _) : v[g] = (0, createClientStreamingMethod_1.createClientStreamingMethod)(E, c, a, _) : E.responseStream ? v[g] = (0, createServerStreamingMethod_1.createServerStreamingMethod)(E, c, a, _) : v[g] = (0, createUnaryMethod_1.createUnaryMethod)(E, c, a, _);\n      }\n      return v;\n    }\n  };\n}\nvar Client = {};\nObject.defineProperty(Client, \"__esModule\", { value: !0 });\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(v, S, g, E) {\n    E === void 0 && (E = g);\n    var _ = Object.getOwnPropertyDescriptor(S, g);\n    (!_ || (\"get\" in _ ? !S.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {\n      return S[g];\n    } }), Object.defineProperty(v, E, _);\n  } : function(v, S, g, E) {\n    E === void 0 && (E = g), v[E] = S[g];\n  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(v, S) {\n    for (var g in v)\n      g !== \"default\" && !Object.prototype.hasOwnProperty.call(S, g) && u(S, v, g);\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.Status = a.Metadata = a.composeClientMiddleware = a.ClientError = void 0;\n  var l = lib;\n  Object.defineProperty(a, \"ClientError\", { enumerable: !0, get: function() {\n    return l.ClientError;\n  } }), Object.defineProperty(a, \"composeClientMiddleware\", { enumerable: !0, get: function() {\n    return l.composeClientMiddleware;\n  } }), Object.defineProperty(a, \"Metadata\", { enumerable: !0, get: function() {\n    return l.Metadata;\n  } }), Object.defineProperty(a, \"Status\", { enumerable: !0, get: function() {\n    return l.Status;\n  } }), c(serviceDefinitions, a), c(channel, a), c(ClientFactory, a), c(Client, a);\n})(lib$1);\nvar dist$2 = {}, api$3 = {}, umd = { exports: {} };\n(function(a, u) {\n  var c = function(l) {\n    Object.defineProperty(l, \"__esModule\", {\n      value: !0\n    }), l.default = void 0;\n    /**\n     * @license\n     * Copyright 2009 The Closure Library Authors\n     * Copyright 2020 Daniel Wirtz / The long.js Authors.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     *\n     * SPDX-License-Identifier: Apache-2.0\n     */\n    var v = null;\n    try {\n      v = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n    } catch {\n    }\n    function S(he, le, we) {\n      this.low = he | 0, this.high = le | 0, this.unsigned = !!we;\n    }\n    S.prototype.__isLong__, Object.defineProperty(S.prototype, \"__isLong__\", {\n      value: !0\n    });\n    function g(he) {\n      return (he && he.__isLong__) === !0;\n    }\n    function E(he) {\n      var le = Math.clz32(he & -he);\n      return he ? 31 - le : le;\n    }\n    S.isLong = g;\n    var _ = {}, k = {};\n    function L(he, le) {\n      var we, Be, Ne;\n      return le ? (he >>>= 0, (Ne = 0 <= he && he < 256) && (Be = k[he], Be) ? Be : (we = $(he, 0, !0), Ne && (k[he] = we), we)) : (he |= 0, (Ne = -128 <= he && he < 128) && (Be = _[he], Be) ? Be : (we = $(he, he < 0 ? -1 : 0, !1), Ne && (_[he] = we), we));\n    }\n    S.fromInt = L;\n    function M(he, le) {\n      if (isNaN(he))\n        return le ? oe : re;\n      if (le) {\n        if (he < 0)\n          return oe;\n        if (he >= Y)\n          return W;\n      } else {\n        if (he <= -ne)\n          return ee;\n        if (he + 1 >= ne)\n          return D;\n      }\n      return he < 0 ? M(-he, le).neg() : $(he % B | 0, he / B | 0, le);\n    }\n    S.fromNumber = M;\n    function $(he, le, we) {\n      return new S(he, le, we);\n    }\n    S.fromBits = $;\n    var J = Math.pow;\n    function V(he, le, we) {\n      if (he.length === 0)\n        throw Error(\"empty string\");\n      if (typeof le == \"number\" ? (we = le, le = !1) : le = !!le, he === \"NaN\" || he === \"Infinity\" || he === \"+Infinity\" || he === \"-Infinity\")\n        return le ? oe : re;\n      if (we = we || 10, we < 2 || 36 < we)\n        throw RangeError(\"radix\");\n      var Be;\n      if ((Be = he.indexOf(\"-\")) > 0)\n        throw Error(\"interior hyphen\");\n      if (Be === 0)\n        return V(he.substring(1), le, we).neg();\n      for (var Ne = M(J(we, 8)), Le = re, $e = 0; $e < he.length; $e += 8) {\n        var Ue = Math.min(8, he.length - $e), Ge = parseInt(he.substring($e, $e + Ue), we);\n        if (Ue < 8) {\n          var He = M(J(we, Ue));\n          Le = Le.mul(He).add(M(Ge));\n        } else\n          Le = Le.mul(Ne), Le = Le.add(M(Ge));\n      }\n      return Le.unsigned = le, Le;\n    }\n    S.fromString = V;\n    function q(he, le) {\n      return typeof he == \"number\" ? M(he, le) : typeof he == \"string\" ? V(he, le) : $(he.low, he.high, typeof le == \"boolean\" ? le : he.unsigned);\n    }\n    S.fromValue = q;\n    var G = 65536, H = 1 << 24, B = G * G, Y = B * B, ne = Y / 2, Z = L(H), re = L(0);\n    S.ZERO = re;\n    var oe = L(0, !0);\n    S.UZERO = oe;\n    var de = L(1);\n    S.ONE = de;\n    var A = L(1, !0);\n    S.UONE = A;\n    var N = L(-1);\n    S.NEG_ONE = N;\n    var D = $(-1, 2147483647, !1);\n    S.MAX_VALUE = D;\n    var W = $(-1, -1, !0);\n    S.MAX_UNSIGNED_VALUE = W;\n    var ee = $(0, -2147483648, !1);\n    S.MIN_VALUE = ee;\n    var ae = S.prototype;\n    ae.toInt = function() {\n      return this.unsigned ? this.low >>> 0 : this.low;\n    }, ae.toNumber = function() {\n      return this.unsigned ? (this.high >>> 0) * B + (this.low >>> 0) : this.high * B + (this.low >>> 0);\n    }, ae.toString = function(le) {\n      if (le = le || 10, le < 2 || 36 < le)\n        throw RangeError(\"radix\");\n      if (this.isZero())\n        return \"0\";\n      if (this.isNegative())\n        if (this.eq(ee)) {\n          var we = M(le), Be = this.div(we), Ne = Be.mul(we).sub(this);\n          return Be.toString(le) + Ne.toInt().toString(le);\n        } else\n          return \"-\" + this.neg().toString(le);\n      for (var Le = M(J(le, 6), this.unsigned), $e = this, Ue = \"\"; ; ) {\n        var Ge = $e.div(Le), He = $e.sub(Ge.mul(Le)).toInt() >>> 0, Ve = He.toString(le);\n        if ($e = Ge, $e.isZero())\n          return Ve + Ue;\n        for (; Ve.length < 6; )\n          Ve = \"0\" + Ve;\n        Ue = \"\" + Ve + Ue;\n      }\n    }, ae.getHighBits = function() {\n      return this.high;\n    }, ae.getHighBitsUnsigned = function() {\n      return this.high >>> 0;\n    }, ae.getLowBits = function() {\n      return this.low;\n    }, ae.getLowBitsUnsigned = function() {\n      return this.low >>> 0;\n    }, ae.getNumBitsAbs = function() {\n      if (this.isNegative())\n        return this.eq(ee) ? 64 : this.neg().getNumBitsAbs();\n      for (var le = this.high != 0 ? this.high : this.low, we = 31; we > 0 && !(le & 1 << we); we--)\n        ;\n      return this.high != 0 ? we + 33 : we + 1;\n    }, ae.isZero = function() {\n      return this.high === 0 && this.low === 0;\n    }, ae.eqz = ae.isZero, ae.isNegative = function() {\n      return !this.unsigned && this.high < 0;\n    }, ae.isPositive = function() {\n      return this.unsigned || this.high >= 0;\n    }, ae.isOdd = function() {\n      return (this.low & 1) === 1;\n    }, ae.isEven = function() {\n      return (this.low & 1) === 0;\n    }, ae.equals = function(le) {\n      return g(le) || (le = q(le)), this.unsigned !== le.unsigned && this.high >>> 31 === 1 && le.high >>> 31 === 1 ? !1 : this.high === le.high && this.low === le.low;\n    }, ae.eq = ae.equals, ae.notEquals = function(le) {\n      return !this.eq(\n        /* validates */\n        le\n      );\n    }, ae.neq = ae.notEquals, ae.ne = ae.notEquals, ae.lessThan = function(le) {\n      return this.comp(\n        /* validates */\n        le\n      ) < 0;\n    }, ae.lt = ae.lessThan, ae.lessThanOrEqual = function(le) {\n      return this.comp(\n        /* validates */\n        le\n      ) <= 0;\n    }, ae.lte = ae.lessThanOrEqual, ae.le = ae.lessThanOrEqual, ae.greaterThan = function(le) {\n      return this.comp(\n        /* validates */\n        le\n      ) > 0;\n    }, ae.gt = ae.greaterThan, ae.greaterThanOrEqual = function(le) {\n      return this.comp(\n        /* validates */\n        le\n      ) >= 0;\n    }, ae.gte = ae.greaterThanOrEqual, ae.ge = ae.greaterThanOrEqual, ae.compare = function(le) {\n      if (g(le) || (le = q(le)), this.eq(le))\n        return 0;\n      var we = this.isNegative(), Be = le.isNegative();\n      return we && !Be ? -1 : !we && Be ? 1 : this.unsigned ? le.high >>> 0 > this.high >>> 0 || le.high === this.high && le.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(le).isNegative() ? -1 : 1;\n    }, ae.comp = ae.compare, ae.negate = function() {\n      return !this.unsigned && this.eq(ee) ? ee : this.not().add(de);\n    }, ae.neg = ae.negate, ae.add = function(le) {\n      g(le) || (le = q(le));\n      var we = this.high >>> 16, Be = this.high & 65535, Ne = this.low >>> 16, Le = this.low & 65535, $e = le.high >>> 16, Ue = le.high & 65535, Ge = le.low >>> 16, He = le.low & 65535, Ve = 0, be = 0, Ae = 0, qe = 0;\n      return qe += Le + He, Ae += qe >>> 16, qe &= 65535, Ae += Ne + Ge, be += Ae >>> 16, Ae &= 65535, be += Be + Ue, Ve += be >>> 16, be &= 65535, Ve += we + $e, Ve &= 65535, $(Ae << 16 | qe, Ve << 16 | be, this.unsigned);\n    }, ae.subtract = function(le) {\n      return g(le) || (le = q(le)), this.add(le.neg());\n    }, ae.sub = ae.subtract, ae.multiply = function(le) {\n      if (this.isZero())\n        return this;\n      if (g(le) || (le = q(le)), v) {\n        var we = v.mul(this.low, this.high, le.low, le.high);\n        return $(we, v.get_high(), this.unsigned);\n      }\n      if (le.isZero())\n        return this.unsigned ? oe : re;\n      if (this.eq(ee))\n        return le.isOdd() ? ee : re;\n      if (le.eq(ee))\n        return this.isOdd() ? ee : re;\n      if (this.isNegative())\n        return le.isNegative() ? this.neg().mul(le.neg()) : this.neg().mul(le).neg();\n      if (le.isNegative())\n        return this.mul(le.neg()).neg();\n      if (this.lt(Z) && le.lt(Z))\n        return M(this.toNumber() * le.toNumber(), this.unsigned);\n      var Be = this.high >>> 16, Ne = this.high & 65535, Le = this.low >>> 16, $e = this.low & 65535, Ue = le.high >>> 16, Ge = le.high & 65535, He = le.low >>> 16, Ve = le.low & 65535, be = 0, Ae = 0, qe = 0, xe = 0;\n      return xe += $e * Ve, qe += xe >>> 16, xe &= 65535, qe += Le * Ve, Ae += qe >>> 16, qe &= 65535, qe += $e * He, Ae += qe >>> 16, qe &= 65535, Ae += Ne * Ve, be += Ae >>> 16, Ae &= 65535, Ae += Le * He, be += Ae >>> 16, Ae &= 65535, Ae += $e * Ge, be += Ae >>> 16, Ae &= 65535, be += Be * Ve + Ne * He + Le * Ge + $e * Ue, be &= 65535, $(qe << 16 | xe, be << 16 | Ae, this.unsigned);\n    }, ae.mul = ae.multiply, ae.divide = function(le) {\n      if (g(le) || (le = q(le)), le.isZero())\n        throw Error(\"division by zero\");\n      if (v) {\n        if (!this.unsigned && this.high === -2147483648 && le.low === -1 && le.high === -1)\n          return this;\n        var we = (this.unsigned ? v.div_u : v.div_s)(this.low, this.high, le.low, le.high);\n        return $(we, v.get_high(), this.unsigned);\n      }\n      if (this.isZero())\n        return this.unsigned ? oe : re;\n      var Be, Ne, Le;\n      if (this.unsigned) {\n        if (le.unsigned || (le = le.toUnsigned()), le.gt(this))\n          return oe;\n        if (le.gt(this.shru(1)))\n          return A;\n        Le = oe;\n      } else {\n        if (this.eq(ee)) {\n          if (le.eq(de) || le.eq(N))\n            return ee;\n          if (le.eq(ee))\n            return de;\n          var $e = this.shr(1);\n          return Be = $e.div(le).shl(1), Be.eq(re) ? le.isNegative() ? de : N : (Ne = this.sub(le.mul(Be)), Le = Be.add(Ne.div(le)), Le);\n        } else if (le.eq(ee))\n          return this.unsigned ? oe : re;\n        if (this.isNegative())\n          return le.isNegative() ? this.neg().div(le.neg()) : this.neg().div(le).neg();\n        if (le.isNegative())\n          return this.div(le.neg()).neg();\n        Le = re;\n      }\n      for (Ne = this; Ne.gte(le); ) {\n        Be = Math.max(1, Math.floor(Ne.toNumber() / le.toNumber()));\n        for (var Ue = Math.ceil(Math.log(Be) / Math.LN2), Ge = Ue <= 48 ? 1 : J(2, Ue - 48), He = M(Be), Ve = He.mul(le); Ve.isNegative() || Ve.gt(Ne); )\n          Be -= Ge, He = M(Be, this.unsigned), Ve = He.mul(le);\n        He.isZero() && (He = de), Le = Le.add(He), Ne = Ne.sub(Ve);\n      }\n      return Le;\n    }, ae.div = ae.divide, ae.modulo = function(le) {\n      if (g(le) || (le = q(le)), v) {\n        var we = (this.unsigned ? v.rem_u : v.rem_s)(this.low, this.high, le.low, le.high);\n        return $(we, v.get_high(), this.unsigned);\n      }\n      return this.sub(this.div(le).mul(le));\n    }, ae.mod = ae.modulo, ae.rem = ae.modulo, ae.not = function() {\n      return $(~this.low, ~this.high, this.unsigned);\n    }, ae.countLeadingZeros = function() {\n      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n    }, ae.clz = ae.countLeadingZeros, ae.countTrailingZeros = function() {\n      return this.low ? E(this.low) : E(this.high) + 32;\n    }, ae.ctz = ae.countTrailingZeros, ae.and = function(le) {\n      return g(le) || (le = q(le)), $(this.low & le.low, this.high & le.high, this.unsigned);\n    }, ae.or = function(le) {\n      return g(le) || (le = q(le)), $(this.low | le.low, this.high | le.high, this.unsigned);\n    }, ae.xor = function(le) {\n      return g(le) || (le = q(le)), $(this.low ^ le.low, this.high ^ le.high, this.unsigned);\n    }, ae.shiftLeft = function(le) {\n      return g(le) && (le = le.toInt()), (le &= 63) === 0 ? this : le < 32 ? $(this.low << le, this.high << le | this.low >>> 32 - le, this.unsigned) : $(0, this.low << le - 32, this.unsigned);\n    }, ae.shl = ae.shiftLeft, ae.shiftRight = function(le) {\n      return g(le) && (le = le.toInt()), (le &= 63) === 0 ? this : le < 32 ? $(this.low >>> le | this.high << 32 - le, this.high >> le, this.unsigned) : $(this.high >> le - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    }, ae.shr = ae.shiftRight, ae.shiftRightUnsigned = function(le) {\n      return g(le) && (le = le.toInt()), (le &= 63) === 0 ? this : le < 32 ? $(this.low >>> le | this.high << 32 - le, this.high >>> le, this.unsigned) : le === 32 ? $(this.high, 0, this.unsigned) : $(this.high >>> le - 32, 0, this.unsigned);\n    }, ae.shru = ae.shiftRightUnsigned, ae.shr_u = ae.shiftRightUnsigned, ae.rotateLeft = function(le) {\n      var we;\n      return g(le) && (le = le.toInt()), (le &= 63) === 0 ? this : le === 32 ? $(this.high, this.low, this.unsigned) : le < 32 ? (we = 32 - le, $(this.low << le | this.high >>> we, this.high << le | this.low >>> we, this.unsigned)) : (le -= 32, we = 32 - le, $(this.high << le | this.low >>> we, this.low << le | this.high >>> we, this.unsigned));\n    }, ae.rotl = ae.rotateLeft, ae.rotateRight = function(le) {\n      var we;\n      return g(le) && (le = le.toInt()), (le &= 63) === 0 ? this : le === 32 ? $(this.high, this.low, this.unsigned) : le < 32 ? (we = 32 - le, $(this.high << we | this.low >>> le, this.low << we | this.high >>> le, this.unsigned)) : (le -= 32, we = 32 - le, $(this.low << we | this.high >>> le, this.high << we | this.low >>> le, this.unsigned));\n    }, ae.rotr = ae.rotateRight, ae.toSigned = function() {\n      return this.unsigned ? $(this.low, this.high, !1) : this;\n    }, ae.toUnsigned = function() {\n      return this.unsigned ? this : $(this.low, this.high, !0);\n    }, ae.toBytes = function(le) {\n      return le ? this.toBytesLE() : this.toBytesBE();\n    }, ae.toBytesLE = function() {\n      var le = this.high, we = this.low;\n      return [we & 255, we >>> 8 & 255, we >>> 16 & 255, we >>> 24, le & 255, le >>> 8 & 255, le >>> 16 & 255, le >>> 24];\n    }, ae.toBytesBE = function() {\n      var le = this.high, we = this.low;\n      return [le >>> 24, le >>> 16 & 255, le >>> 8 & 255, le & 255, we >>> 24, we >>> 16 & 255, we >>> 8 & 255, we & 255];\n    }, S.fromBytes = function(le, we, Be) {\n      return Be ? S.fromBytesLE(le, we) : S.fromBytesBE(le, we);\n    }, S.fromBytesLE = function(le, we) {\n      return new S(le[0] | le[1] << 8 | le[2] << 16 | le[3] << 24, le[4] | le[5] << 8 | le[6] << 16 | le[7] << 24, we);\n    }, S.fromBytesBE = function(le, we) {\n      return new S(le[4] << 24 | le[5] << 16 | le[6] << 8 | le[7], le[0] << 24 | le[1] << 16 | le[2] << 8 | le[3], we);\n    };\n    var ye = S;\n    return l.default = ye, \"default\" in l ? l.default : l;\n  }({});\n  a.exports = c;\n})(umd);\nvar umdExports = umd.exports, indexMinimal = {}, minimal$1 = {}, aspromise = asPromise;\nfunction asPromise(a, u) {\n  for (var c = new Array(arguments.length - 1), l = 0, v = 2, S = !0; v < arguments.length; )\n    c[l++] = arguments[v++];\n  return new Promise(function(E, _) {\n    c[l] = function(L) {\n      if (S)\n        if (S = !1, L)\n          _(L);\n        else {\n          for (var M = new Array(arguments.length - 1), $ = 0; $ < M.length; )\n            M[$++] = arguments[$];\n          E.apply(null, M);\n        }\n    };\n    try {\n      a.apply(u || null, c);\n    } catch (k) {\n      S && (S = !1, _(k));\n    }\n  });\n}\nvar base64$1 = {};\n(function(a) {\n  var u = a;\n  u.length = function(E) {\n    var _ = E.length;\n    if (!_)\n      return 0;\n    for (var k = 0; --_ % 4 > 1 && E.charAt(_) === \"=\"; )\n      ++k;\n    return Math.ceil(E.length * 3) / 4 - k;\n  };\n  for (var c = new Array(64), l = new Array(123), v = 0; v < 64; )\n    l[c[v] = v < 26 ? v + 65 : v < 52 ? v + 71 : v < 62 ? v - 4 : v - 59 | 43] = v++;\n  u.encode = function(E, _, k) {\n    for (var L = null, M = [], $ = 0, J = 0, V; _ < k; ) {\n      var q = E[_++];\n      switch (J) {\n        case 0:\n          M[$++] = c[q >> 2], V = (q & 3) << 4, J = 1;\n          break;\n        case 1:\n          M[$++] = c[V | q >> 4], V = (q & 15) << 2, J = 2;\n          break;\n        case 2:\n          M[$++] = c[V | q >> 6], M[$++] = c[q & 63], J = 0;\n          break;\n      }\n      $ > 8191 && ((L || (L = [])).push(String.fromCharCode.apply(String, M)), $ = 0);\n    }\n    return J && (M[$++] = c[V], M[$++] = 61, J === 1 && (M[$++] = 61)), L ? ($ && L.push(String.fromCharCode.apply(String, M.slice(0, $))), L.join(\"\")) : String.fromCharCode.apply(String, M.slice(0, $));\n  };\n  var S = \"invalid encoding\";\n  u.decode = function(E, _, k) {\n    for (var L = k, M = 0, $, J = 0; J < E.length; ) {\n      var V = E.charCodeAt(J++);\n      if (V === 61 && M > 1)\n        break;\n      if ((V = l[V]) === void 0)\n        throw Error(S);\n      switch (M) {\n        case 0:\n          $ = V, M = 1;\n          break;\n        case 1:\n          _[k++] = $ << 2 | (V & 48) >> 4, $ = V, M = 2;\n          break;\n        case 2:\n          _[k++] = ($ & 15) << 4 | (V & 60) >> 2, $ = V, M = 3;\n          break;\n        case 3:\n          _[k++] = ($ & 3) << 6 | V, M = 0;\n          break;\n      }\n    }\n    if (M === 1)\n      throw Error(S);\n    return k - L;\n  }, u.test = function(E) {\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(E);\n  };\n})(base64$1);\nvar eventemitter = EventEmitter$1;\nfunction EventEmitter$1() {\n  this._listeners = {};\n}\nEventEmitter$1.prototype.on = function(u, c, l) {\n  return (this._listeners[u] || (this._listeners[u] = [])).push({\n    fn: c,\n    ctx: l || this\n  }), this;\n};\nEventEmitter$1.prototype.off = function(u, c) {\n  if (u === void 0)\n    this._listeners = {};\n  else if (c === void 0)\n    this._listeners[u] = [];\n  else\n    for (var l = this._listeners[u], v = 0; v < l.length; )\n      l[v].fn === c ? l.splice(v, 1) : ++v;\n  return this;\n};\nEventEmitter$1.prototype.emit = function(u) {\n  var c = this._listeners[u];\n  if (c) {\n    for (var l = [], v = 1; v < arguments.length; )\n      l.push(arguments[v++]);\n    for (v = 0; v < c.length; )\n      c[v].fn.apply(c[v++].ctx, l);\n  }\n  return this;\n};\nvar float = factory(factory);\nfunction factory(a) {\n  return typeof Float32Array < \"u\" ? function() {\n    var u = new Float32Array([-0]), c = new Uint8Array(u.buffer), l = c[3] === 128;\n    function v(_, k, L) {\n      u[0] = _, k[L] = c[0], k[L + 1] = c[1], k[L + 2] = c[2], k[L + 3] = c[3];\n    }\n    function S(_, k, L) {\n      u[0] = _, k[L] = c[3], k[L + 1] = c[2], k[L + 2] = c[1], k[L + 3] = c[0];\n    }\n    a.writeFloatLE = l ? v : S, a.writeFloatBE = l ? S : v;\n    function g(_, k) {\n      return c[0] = _[k], c[1] = _[k + 1], c[2] = _[k + 2], c[3] = _[k + 3], u[0];\n    }\n    function E(_, k) {\n      return c[3] = _[k], c[2] = _[k + 1], c[1] = _[k + 2], c[0] = _[k + 3], u[0];\n    }\n    a.readFloatLE = l ? g : E, a.readFloatBE = l ? E : g;\n  }() : function() {\n    function u(l, v, S, g) {\n      var E = v < 0 ? 1 : 0;\n      if (E && (v = -v), v === 0)\n        l(1 / v > 0 ? (\n          /* positive */\n          0\n        ) : (\n          /* negative 0 */\n          2147483648\n        ), S, g);\n      else if (isNaN(v))\n        l(2143289344, S, g);\n      else if (v > 34028234663852886e22)\n        l((E << 31 | 2139095040) >>> 0, S, g);\n      else if (v < 11754943508222875e-54)\n        l((E << 31 | Math.round(v / 1401298464324817e-60)) >>> 0, S, g);\n      else {\n        var _ = Math.floor(Math.log(v) / Math.LN2), k = Math.round(v * Math.pow(2, -_) * 8388608) & 8388607;\n        l((E << 31 | _ + 127 << 23 | k) >>> 0, S, g);\n      }\n    }\n    a.writeFloatLE = u.bind(null, writeUintLE), a.writeFloatBE = u.bind(null, writeUintBE);\n    function c(l, v, S) {\n      var g = l(v, S), E = (g >> 31) * 2 + 1, _ = g >>> 23 & 255, k = g & 8388607;\n      return _ === 255 ? k ? NaN : E * (1 / 0) : _ === 0 ? E * 1401298464324817e-60 * k : E * Math.pow(2, _ - 150) * (k + 8388608);\n    }\n    a.readFloatLE = c.bind(null, readUintLE), a.readFloatBE = c.bind(null, readUintBE);\n  }(), typeof Float64Array < \"u\" ? function() {\n    var u = new Float64Array([-0]), c = new Uint8Array(u.buffer), l = c[7] === 128;\n    function v(_, k, L) {\n      u[0] = _, k[L] = c[0], k[L + 1] = c[1], k[L + 2] = c[2], k[L + 3] = c[3], k[L + 4] = c[4], k[L + 5] = c[5], k[L + 6] = c[6], k[L + 7] = c[7];\n    }\n    function S(_, k, L) {\n      u[0] = _, k[L] = c[7], k[L + 1] = c[6], k[L + 2] = c[5], k[L + 3] = c[4], k[L + 4] = c[3], k[L + 5] = c[2], k[L + 6] = c[1], k[L + 7] = c[0];\n    }\n    a.writeDoubleLE = l ? v : S, a.writeDoubleBE = l ? S : v;\n    function g(_, k) {\n      return c[0] = _[k], c[1] = _[k + 1], c[2] = _[k + 2], c[3] = _[k + 3], c[4] = _[k + 4], c[5] = _[k + 5], c[6] = _[k + 6], c[7] = _[k + 7], u[0];\n    }\n    function E(_, k) {\n      return c[7] = _[k], c[6] = _[k + 1], c[5] = _[k + 2], c[4] = _[k + 3], c[3] = _[k + 4], c[2] = _[k + 5], c[1] = _[k + 6], c[0] = _[k + 7], u[0];\n    }\n    a.readDoubleLE = l ? g : E, a.readDoubleBE = l ? E : g;\n  }() : function() {\n    function u(l, v, S, g, E, _) {\n      var k = g < 0 ? 1 : 0;\n      if (k && (g = -g), g === 0)\n        l(0, E, _ + v), l(1 / g > 0 ? (\n          /* positive */\n          0\n        ) : (\n          /* negative 0 */\n          2147483648\n        ), E, _ + S);\n      else if (isNaN(g))\n        l(0, E, _ + v), l(2146959360, E, _ + S);\n      else if (g > 17976931348623157e292)\n        l(0, E, _ + v), l((k << 31 | 2146435072) >>> 0, E, _ + S);\n      else {\n        var L;\n        if (g < 22250738585072014e-324)\n          L = g / 5e-324, l(L >>> 0, E, _ + v), l((k << 31 | L / 4294967296) >>> 0, E, _ + S);\n        else {\n          var M = Math.floor(Math.log(g) / Math.LN2);\n          M === 1024 && (M = 1023), L = g * Math.pow(2, -M), l(L * 4503599627370496 >>> 0, E, _ + v), l((k << 31 | M + 1023 << 20 | L * 1048576 & 1048575) >>> 0, E, _ + S);\n        }\n      }\n    }\n    a.writeDoubleLE = u.bind(null, writeUintLE, 0, 4), a.writeDoubleBE = u.bind(null, writeUintBE, 4, 0);\n    function c(l, v, S, g, E) {\n      var _ = l(g, E + v), k = l(g, E + S), L = (k >> 31) * 2 + 1, M = k >>> 20 & 2047, $ = 4294967296 * (k & 1048575) + _;\n      return M === 2047 ? $ ? NaN : L * (1 / 0) : M === 0 ? L * 5e-324 * $ : L * Math.pow(2, M - 1075) * ($ + 4503599627370496);\n    }\n    a.readDoubleLE = c.bind(null, readUintLE, 0, 4), a.readDoubleBE = c.bind(null, readUintBE, 4, 0);\n  }(), a;\n}\nfunction writeUintLE(a, u, c) {\n  u[c] = a & 255, u[c + 1] = a >>> 8 & 255, u[c + 2] = a >>> 16 & 255, u[c + 3] = a >>> 24;\n}\nfunction writeUintBE(a, u, c) {\n  u[c] = a >>> 24, u[c + 1] = a >>> 16 & 255, u[c + 2] = a >>> 8 & 255, u[c + 3] = a & 255;\n}\nfunction readUintLE(a, u) {\n  return (a[u] | a[u + 1] << 8 | a[u + 2] << 16 | a[u + 3] << 24) >>> 0;\n}\nfunction readUintBE(a, u) {\n  return (a[u] << 24 | a[u + 1] << 16 | a[u + 2] << 8 | a[u + 3]) >>> 0;\n}\nvar inquire_1 = inquire;\nfunction inquire(moduleName) {\n  try {\n    var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);\n    if (mod && (mod.length || Object.keys(mod).length))\n      return mod;\n  } catch (a) {\n  }\n  return null;\n}\nvar utf8$2 = {};\n(function(a) {\n  var u = a;\n  u.length = function(l) {\n    for (var v = 0, S = 0, g = 0; g < l.length; ++g)\n      S = l.charCodeAt(g), S < 128 ? v += 1 : S < 2048 ? v += 2 : (S & 64512) === 55296 && (l.charCodeAt(g + 1) & 64512) === 56320 ? (++g, v += 4) : v += 3;\n    return v;\n  }, u.read = function(l, v, S) {\n    var g = S - v;\n    if (g < 1)\n      return \"\";\n    for (var E = null, _ = [], k = 0, L; v < S; )\n      L = l[v++], L < 128 ? _[k++] = L : L > 191 && L < 224 ? _[k++] = (L & 31) << 6 | l[v++] & 63 : L > 239 && L < 365 ? (L = ((L & 7) << 18 | (l[v++] & 63) << 12 | (l[v++] & 63) << 6 | l[v++] & 63) - 65536, _[k++] = 55296 + (L >> 10), _[k++] = 56320 + (L & 1023)) : _[k++] = (L & 15) << 12 | (l[v++] & 63) << 6 | l[v++] & 63, k > 8191 && ((E || (E = [])).push(String.fromCharCode.apply(String, _)), k = 0);\n    return E ? (k && E.push(String.fromCharCode.apply(String, _.slice(0, k))), E.join(\"\")) : String.fromCharCode.apply(String, _.slice(0, k));\n  }, u.write = function(l, v, S) {\n    for (var g = S, E, _, k = 0; k < l.length; ++k)\n      E = l.charCodeAt(k), E < 128 ? v[S++] = E : E < 2048 ? (v[S++] = E >> 6 | 192, v[S++] = E & 63 | 128) : (E & 64512) === 55296 && ((_ = l.charCodeAt(k + 1)) & 64512) === 56320 ? (E = 65536 + ((E & 1023) << 10) + (_ & 1023), ++k, v[S++] = E >> 18 | 240, v[S++] = E >> 12 & 63 | 128, v[S++] = E >> 6 & 63 | 128, v[S++] = E & 63 | 128) : (v[S++] = E >> 12 | 224, v[S++] = E >> 6 & 63 | 128, v[S++] = E & 63 | 128);\n    return S - g;\n  };\n})(utf8$2);\nvar pool_1 = pool;\nfunction pool(a, u, c) {\n  var l = c || 8192, v = l >>> 1, S = null, g = l;\n  return function(_) {\n    if (_ < 1 || _ > v)\n      return a(_);\n    g + _ > l && (S = a(l), g = 0);\n    var k = u.call(S, g, g += _);\n    return g & 7 && (g = (g | 7) + 1), k;\n  };\n}\nvar longbits, hasRequiredLongbits;\nfunction requireLongbits() {\n  if (hasRequiredLongbits)\n    return longbits;\n  hasRequiredLongbits = 1, longbits = u;\n  var a = requireMinimal();\n  function u(S, g) {\n    this.lo = S >>> 0, this.hi = g >>> 0;\n  }\n  var c = u.zero = new u(0, 0);\n  c.toNumber = function() {\n    return 0;\n  }, c.zzEncode = c.zzDecode = function() {\n    return this;\n  }, c.length = function() {\n    return 1;\n  };\n  var l = u.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n  u.fromNumber = function(g) {\n    if (g === 0)\n      return c;\n    var E = g < 0;\n    E && (g = -g);\n    var _ = g >>> 0, k = (g - _) / 4294967296 >>> 0;\n    return E && (k = ~k >>> 0, _ = ~_ >>> 0, ++_ > 4294967295 && (_ = 0, ++k > 4294967295 && (k = 0))), new u(_, k);\n  }, u.from = function(g) {\n    if (typeof g == \"number\")\n      return u.fromNumber(g);\n    if (a.isString(g))\n      if (a.Long)\n        g = a.Long.fromString(g);\n      else\n        return u.fromNumber(parseInt(g, 10));\n    return g.low || g.high ? new u(g.low >>> 0, g.high >>> 0) : c;\n  }, u.prototype.toNumber = function(g) {\n    if (!g && this.hi >>> 31) {\n      var E = ~this.lo + 1 >>> 0, _ = ~this.hi >>> 0;\n      return E || (_ = _ + 1 >>> 0), -(E + _ * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n  }, u.prototype.toLong = function(g) {\n    return a.Long ? new a.Long(this.lo | 0, this.hi | 0, !!g) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!g };\n  };\n  var v = String.prototype.charCodeAt;\n  return u.fromHash = function(g) {\n    return g === l ? c : new u(\n      (v.call(g, 0) | v.call(g, 1) << 8 | v.call(g, 2) << 16 | v.call(g, 3) << 24) >>> 0,\n      (v.call(g, 4) | v.call(g, 5) << 8 | v.call(g, 6) << 16 | v.call(g, 7) << 24) >>> 0\n    );\n  }, u.prototype.toHash = function() {\n    return String.fromCharCode(\n      this.lo & 255,\n      this.lo >>> 8 & 255,\n      this.lo >>> 16 & 255,\n      this.lo >>> 24,\n      this.hi & 255,\n      this.hi >>> 8 & 255,\n      this.hi >>> 16 & 255,\n      this.hi >>> 24\n    );\n  }, u.prototype.zzEncode = function() {\n    var g = this.hi >> 31;\n    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ g) >>> 0, this.lo = (this.lo << 1 ^ g) >>> 0, this;\n  }, u.prototype.zzDecode = function() {\n    var g = -(this.lo & 1);\n    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ g) >>> 0, this.hi = (this.hi >>> 1 ^ g) >>> 0, this;\n  }, u.prototype.length = function() {\n    var g = this.lo, E = (this.lo >>> 28 | this.hi << 4) >>> 0, _ = this.hi >>> 24;\n    return _ === 0 ? E === 0 ? g < 16384 ? g < 128 ? 1 : 2 : g < 2097152 ? 3 : 4 : E < 16384 ? E < 128 ? 5 : 6 : E < 2097152 ? 7 : 8 : _ < 128 ? 9 : 10;\n  }, longbits;\n}\nvar hasRequiredMinimal;\nfunction requireMinimal() {\n  return hasRequiredMinimal || (hasRequiredMinimal = 1, function(a) {\n    var u = a;\n    u.asPromise = aspromise, u.base64 = base64$1, u.EventEmitter = eventemitter, u.float = float, u.inquire = inquire_1, u.utf8 = utf8$2, u.pool = pool_1, u.LongBits = requireLongbits(), u.isNode = !!(typeof commonjsGlobal$1 < \"u\" && commonjsGlobal$1 && commonjsGlobal$1.process && commonjsGlobal$1.process.versions && commonjsGlobal$1.process.versions.node), u.global = u.isNode && commonjsGlobal$1 || typeof window < \"u\" && window || typeof self < \"u\" && self || commonjsGlobal$1, u.emptyArray = Object.freeze ? Object.freeze([]) : (\n      /* istanbul ignore next */\n      []\n    ), u.emptyObject = Object.freeze ? Object.freeze({}) : (\n      /* istanbul ignore next */\n      {}\n    ), u.isInteger = Number.isInteger || /* istanbul ignore next */\n    function(S) {\n      return typeof S == \"number\" && isFinite(S) && Math.floor(S) === S;\n    }, u.isString = function(S) {\n      return typeof S == \"string\" || S instanceof String;\n    }, u.isObject = function(S) {\n      return S && typeof S == \"object\";\n    }, u.isset = /**\n     * Checks if a property on a message is considered to be present.\n     * @param {Object} obj Plain object or message instance\n     * @param {string} prop Property name\n     * @returns {boolean} `true` if considered to be present, otherwise `false`\n     */\n    u.isSet = function(S, g) {\n      var E = S[g];\n      return E != null && S.hasOwnProperty(g) ? typeof E != \"object\" || (Array.isArray(E) ? E.length : Object.keys(E).length) > 0 : !1;\n    }, u.Buffer = function() {\n      try {\n        var v = u.inquire(\"buffer\").Buffer;\n        return v.prototype.utf8Write ? v : (\n          /* istanbul ignore next */\n          null\n        );\n      } catch {\n        return null;\n      }\n    }(), u._Buffer_from = null, u._Buffer_allocUnsafe = null, u.newBuffer = function(S) {\n      return typeof S == \"number\" ? u.Buffer ? u._Buffer_allocUnsafe(S) : new u.Array(S) : u.Buffer ? u._Buffer_from(S) : typeof Uint8Array > \"u\" ? S : new Uint8Array(S);\n    }, u.Array = typeof Uint8Array < \"u\" ? Uint8Array : Array, u.Long = /* istanbul ignore next */\n    u.global.dcodeIO && /* istanbul ignore next */\n    u.global.dcodeIO.Long || /* istanbul ignore next */\n    u.global.Long || u.inquire(\"long\"), u.key2Re = /^true|false|0|1$/, u.key32Re = /^-?(?:0|[1-9][0-9]*)$/, u.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, u.longToHash = function(S) {\n      return S ? u.LongBits.from(S).toHash() : u.LongBits.zeroHash;\n    }, u.longFromHash = function(S, g) {\n      var E = u.LongBits.fromHash(S);\n      return u.Long ? u.Long.fromBits(E.lo, E.hi, g) : E.toNumber(!!g);\n    };\n    function c(v, S, g) {\n      for (var E = Object.keys(S), _ = 0; _ < E.length; ++_)\n        (v[E[_]] === void 0 || !g) && (v[E[_]] = S[E[_]]);\n      return v;\n    }\n    u.merge = c, u.lcFirst = function(S) {\n      return S.charAt(0).toLowerCase() + S.substring(1);\n    };\n    function l(v) {\n      function S(g, E) {\n        if (!(this instanceof S))\n          return new S(g, E);\n        Object.defineProperty(this, \"message\", { get: function() {\n          return g;\n        } }), Error.captureStackTrace ? Error.captureStackTrace(this, S) : Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" }), E && c(this, E);\n      }\n      return (S.prototype = Object.create(Error.prototype)).constructor = S, Object.defineProperty(S.prototype, \"name\", { get: function() {\n        return v;\n      } }), S.prototype.toString = function() {\n        return this.name + \": \" + this.message;\n      }, S;\n    }\n    u.newError = l, u.ProtocolError = l(\"ProtocolError\"), u.oneOfGetter = function(S) {\n      for (var g = {}, E = 0; E < S.length; ++E)\n        g[S[E]] = 1;\n      return function() {\n        for (var _ = Object.keys(this), k = _.length - 1; k > -1; --k)\n          if (g[_[k]] === 1 && this[_[k]] !== void 0 && this[_[k]] !== null)\n            return _[k];\n      };\n    }, u.oneOfSetter = function(S) {\n      return function(g) {\n        for (var E = 0; E < S.length; ++E)\n          S[E] !== g && delete this[S[E]];\n      };\n    }, u.toJSONOptions = {\n      longs: String,\n      enums: String,\n      bytes: String,\n      json: !0\n    }, u._configure = function() {\n      var v = u.Buffer;\n      if (!v) {\n        u._Buffer_from = u._Buffer_allocUnsafe = null;\n        return;\n      }\n      u._Buffer_from = v.from !== Uint8Array.from && v.from || /* istanbul ignore next */\n      function(g, E) {\n        return new v(g, E);\n      }, u._Buffer_allocUnsafe = v.allocUnsafe || /* istanbul ignore next */\n      function(g) {\n        return new v(g);\n      };\n    };\n  }(minimal$1)), minimal$1;\n}\nvar writer$2 = Writer$1, util$8 = requireMinimal(), BufferWriter$1, LongBits$1 = util$8.LongBits, base64 = util$8.base64, utf8$1 = util$8.utf8;\nfunction Op(a, u, c) {\n  this.fn = a, this.len = u, this.next = void 0, this.val = c;\n}\nfunction noop$2() {\n}\nfunction State(a) {\n  this.head = a.head, this.tail = a.tail, this.len = a.len, this.next = a.states;\n}\nfunction Writer$1() {\n  this.len = 0, this.head = new Op(noop$2, 0, 0), this.tail = this.head, this.states = null;\n}\nvar create$3 = function a() {\n  return util$8.Buffer ? function() {\n    return (Writer$1.create = function() {\n      return new BufferWriter$1();\n    })();\n  } : function() {\n    return new Writer$1();\n  };\n};\nWriter$1.create = create$3();\nWriter$1.alloc = function a(u) {\n  return new util$8.Array(u);\n};\nutil$8.Array !== Array && (Writer$1.alloc = util$8.pool(Writer$1.alloc, util$8.Array.prototype.subarray));\nWriter$1.prototype._push = function a(u, c, l) {\n  return this.tail = this.tail.next = new Op(u, c, l), this.len += c, this;\n};\nfunction writeByte(a, u, c) {\n  u[c] = a & 255;\n}\nfunction writeVarint32(a, u, c) {\n  for (; a > 127; )\n    u[c++] = a & 127 | 128, a >>>= 7;\n  u[c] = a;\n}\nfunction VarintOp(a, u) {\n  this.len = a, this.next = void 0, this.val = u;\n}\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\nWriter$1.prototype.uint32 = function a(u) {\n  return this.len += (this.tail = this.tail.next = new VarintOp(\n    (u = u >>> 0) < 128 ? 1 : u < 16384 ? 2 : u < 2097152 ? 3 : u < 268435456 ? 4 : 5,\n    u\n  )).len, this;\n};\nWriter$1.prototype.int32 = function a(u) {\n  return u < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(u)) : this.uint32(u);\n};\nWriter$1.prototype.sint32 = function a(u) {\n  return this.uint32((u << 1 ^ u >> 31) >>> 0);\n};\nfunction writeVarint64(a, u, c) {\n  for (; a.hi; )\n    u[c++] = a.lo & 127 | 128, a.lo = (a.lo >>> 7 | a.hi << 25) >>> 0, a.hi >>>= 7;\n  for (; a.lo > 127; )\n    u[c++] = a.lo & 127 | 128, a.lo = a.lo >>> 7;\n  u[c++] = a.lo;\n}\nWriter$1.prototype.uint64 = function a(u) {\n  var c = LongBits$1.from(u);\n  return this._push(writeVarint64, c.length(), c);\n};\nWriter$1.prototype.int64 = Writer$1.prototype.uint64;\nWriter$1.prototype.sint64 = function a(u) {\n  var c = LongBits$1.from(u).zzEncode();\n  return this._push(writeVarint64, c.length(), c);\n};\nWriter$1.prototype.bool = function a(u) {\n  return this._push(writeByte, 1, u ? 1 : 0);\n};\nfunction writeFixed32(a, u, c) {\n  u[c] = a & 255, u[c + 1] = a >>> 8 & 255, u[c + 2] = a >>> 16 & 255, u[c + 3] = a >>> 24;\n}\nWriter$1.prototype.fixed32 = function a(u) {\n  return this._push(writeFixed32, 4, u >>> 0);\n};\nWriter$1.prototype.sfixed32 = Writer$1.prototype.fixed32;\nWriter$1.prototype.fixed64 = function a(u) {\n  var c = LongBits$1.from(u);\n  return this._push(writeFixed32, 4, c.lo)._push(writeFixed32, 4, c.hi);\n};\nWriter$1.prototype.sfixed64 = Writer$1.prototype.fixed64;\nWriter$1.prototype.float = function a(u) {\n  return this._push(util$8.float.writeFloatLE, 4, u);\n};\nWriter$1.prototype.double = function a(u) {\n  return this._push(util$8.float.writeDoubleLE, 8, u);\n};\nvar writeBytes = util$8.Array.prototype.set ? function a(u, c, l) {\n  c.set(u, l);\n} : function a(u, c, l) {\n  for (var v = 0; v < u.length; ++v)\n    c[l + v] = u[v];\n};\nWriter$1.prototype.bytes = function a(u) {\n  var c = u.length >>> 0;\n  if (!c)\n    return this._push(writeByte, 1, 0);\n  if (util$8.isString(u)) {\n    var l = Writer$1.alloc(c = base64.length(u));\n    base64.decode(u, l, 0), u = l;\n  }\n  return this.uint32(c)._push(writeBytes, c, u);\n};\nWriter$1.prototype.string = function a(u) {\n  var c = utf8$1.length(u);\n  return c ? this.uint32(c)._push(utf8$1.write, c, u) : this._push(writeByte, 1, 0);\n};\nWriter$1.prototype.fork = function a() {\n  return this.states = new State(this), this.head = this.tail = new Op(noop$2, 0, 0), this.len = 0, this;\n};\nWriter$1.prototype.reset = function a() {\n  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop$2, 0, 0), this.len = 0), this;\n};\nWriter$1.prototype.ldelim = function a() {\n  var u = this.head, c = this.tail, l = this.len;\n  return this.reset().uint32(l), l && (this.tail.next = u.next, this.tail = c, this.len += l), this;\n};\nWriter$1.prototype.finish = function a() {\n  for (var u = this.head.next, c = this.constructor.alloc(this.len), l = 0; u; )\n    u.fn(u.val, c, l), l += u.len, u = u.next;\n  return c;\n};\nWriter$1._configure = function(a) {\n  BufferWriter$1 = a, Writer$1.create = create$3(), BufferWriter$1._configure();\n};\nvar writer_buffer = BufferWriter, Writer = writer$2;\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\nvar util$7 = requireMinimal();\nfunction BufferWriter() {\n  Writer.call(this);\n}\nBufferWriter._configure = function() {\n  BufferWriter.alloc = util$7._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$7.Buffer && util$7.Buffer.prototype instanceof Uint8Array && util$7.Buffer.prototype.set.name === \"set\" ? function(u, c, l) {\n    c.set(u, l);\n  } : function(u, c, l) {\n    if (u.copy)\n      u.copy(c, l, 0, u.length);\n    else\n      for (var v = 0; v < u.length; )\n        c[l++] = u[v++];\n  };\n};\nBufferWriter.prototype.bytes = function a(u) {\n  util$7.isString(u) && (u = util$7._Buffer_from(u, \"base64\"));\n  var c = u.length >>> 0;\n  return this.uint32(c), c && this._push(BufferWriter.writeBytesBuffer, c, u), this;\n};\nfunction writeStringBuffer(a, u, c) {\n  a.length < 40 ? util$7.utf8.write(a, u, c) : u.utf8Write ? u.utf8Write(a, c) : u.write(a, c);\n}\nBufferWriter.prototype.string = function a(u) {\n  var c = util$7.Buffer.byteLength(u);\n  return this.uint32(c), c && this._push(writeStringBuffer, c, u), this;\n};\nBufferWriter._configure();\nvar reader = Reader$1, util$6 = requireMinimal(), BufferReader$1, LongBits = util$6.LongBits, utf8 = util$6.utf8;\nfunction indexOutOfRange(a, u) {\n  return RangeError(\"index out of range: \" + a.pos + \" + \" + (u || 1) + \" > \" + a.len);\n}\nfunction Reader$1(a) {\n  this.buf = a, this.pos = 0, this.len = a.length;\n}\nvar create_array = typeof Uint8Array < \"u\" ? function a(u) {\n  if (u instanceof Uint8Array || Array.isArray(u))\n    return new Reader$1(u);\n  throw Error(\"illegal buffer\");\n} : function a(u) {\n  if (Array.isArray(u))\n    return new Reader$1(u);\n  throw Error(\"illegal buffer\");\n}, create$2 = function a() {\n  return util$6.Buffer ? function(c) {\n    return (Reader$1.create = function(v) {\n      return util$6.Buffer.isBuffer(v) ? new BufferReader$1(v) : create_array(v);\n    })(c);\n  } : create_array;\n};\nReader$1.create = create$2();\nReader$1.prototype._slice = util$6.Array.prototype.subarray || /* istanbul ignore next */\nutil$6.Array.prototype.slice;\nReader$1.prototype.uint32 = /* @__PURE__ */ function a() {\n  var u = 4294967295;\n  return function() {\n    if (u = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (u = (u | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))\n      return u;\n    if ((this.pos += 5) > this.len)\n      throw this.pos = this.len, indexOutOfRange(this, 10);\n    return u;\n  };\n}();\nReader$1.prototype.int32 = function a() {\n  return this.uint32() | 0;\n};\nReader$1.prototype.sint32 = function a() {\n  var u = this.uint32();\n  return u >>> 1 ^ -(u & 1) | 0;\n};\nfunction readLongVarint() {\n  var a = new LongBits(0, 0), u = 0;\n  if (this.len - this.pos > 4) {\n    for (; u < 4; ++u)\n      if (a.lo = (a.lo | (this.buf[this.pos] & 127) << u * 7) >>> 0, this.buf[this.pos++] < 128)\n        return a;\n    if (a.lo = (a.lo | (this.buf[this.pos] & 127) << 28) >>> 0, a.hi = (a.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)\n      return a;\n    u = 0;\n  } else {\n    for (; u < 3; ++u) {\n      if (this.pos >= this.len)\n        throw indexOutOfRange(this);\n      if (a.lo = (a.lo | (this.buf[this.pos] & 127) << u * 7) >>> 0, this.buf[this.pos++] < 128)\n        return a;\n    }\n    return a.lo = (a.lo | (this.buf[this.pos++] & 127) << u * 7) >>> 0, a;\n  }\n  if (this.len - this.pos > 4) {\n    for (; u < 5; ++u)\n      if (a.hi = (a.hi | (this.buf[this.pos] & 127) << u * 7 + 3) >>> 0, this.buf[this.pos++] < 128)\n        return a;\n  } else\n    for (; u < 5; ++u) {\n      if (this.pos >= this.len)\n        throw indexOutOfRange(this);\n      if (a.hi = (a.hi | (this.buf[this.pos] & 127) << u * 7 + 3) >>> 0, this.buf[this.pos++] < 128)\n        return a;\n    }\n  throw Error(\"invalid varint encoding\");\n}\nReader$1.prototype.bool = function a() {\n  return this.uint32() !== 0;\n};\nfunction readFixed32_end(a, u) {\n  return (a[u - 4] | a[u - 3] << 8 | a[u - 2] << 16 | a[u - 1] << 24) >>> 0;\n}\nReader$1.prototype.fixed32 = function a() {\n  if (this.pos + 4 > this.len)\n    throw indexOutOfRange(this, 4);\n  return readFixed32_end(this.buf, this.pos += 4);\n};\nReader$1.prototype.sfixed32 = function a() {\n  if (this.pos + 4 > this.len)\n    throw indexOutOfRange(this, 4);\n  return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\nfunction readFixed64() {\n  if (this.pos + 8 > this.len)\n    throw indexOutOfRange(this, 8);\n  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\nReader$1.prototype.float = function a() {\n  if (this.pos + 4 > this.len)\n    throw indexOutOfRange(this, 4);\n  var u = util$6.float.readFloatLE(this.buf, this.pos);\n  return this.pos += 4, u;\n};\nReader$1.prototype.double = function a() {\n  if (this.pos + 8 > this.len)\n    throw indexOutOfRange(this, 4);\n  var u = util$6.float.readDoubleLE(this.buf, this.pos);\n  return this.pos += 8, u;\n};\nReader$1.prototype.bytes = function a() {\n  var u = this.uint32(), c = this.pos, l = this.pos + u;\n  if (l > this.len)\n    throw indexOutOfRange(this, u);\n  return this.pos += u, Array.isArray(this.buf) ? this.buf.slice(c, l) : c === l ? new this.buf.constructor(0) : this._slice.call(this.buf, c, l);\n};\nReader$1.prototype.string = function a() {\n  var u = this.bytes();\n  return utf8.read(u, 0, u.length);\n};\nReader$1.prototype.skip = function a(u) {\n  if (typeof u == \"number\") {\n    if (this.pos + u > this.len)\n      throw indexOutOfRange(this, u);\n    this.pos += u;\n  } else\n    do\n      if (this.pos >= this.len)\n        throw indexOutOfRange(this);\n    while (this.buf[this.pos++] & 128);\n  return this;\n};\nReader$1.prototype.skipType = function(a) {\n  switch (a) {\n    case 0:\n      this.skip();\n      break;\n    case 1:\n      this.skip(8);\n      break;\n    case 2:\n      this.skip(this.uint32());\n      break;\n    case 3:\n      for (; (a = this.uint32() & 7) !== 4; )\n        this.skipType(a);\n      break;\n    case 5:\n      this.skip(4);\n      break;\n    default:\n      throw Error(\"invalid wire type \" + a + \" at offset \" + this.pos);\n  }\n  return this;\n};\nReader$1._configure = function(a) {\n  BufferReader$1 = a, Reader$1.create = create$2(), BufferReader$1._configure();\n  var u = util$6.Long ? \"toLong\" : (\n    /* istanbul ignore next */\n    \"toNumber\"\n  );\n  util$6.merge(Reader$1.prototype, {\n    int64: function() {\n      return readLongVarint.call(this)[u](!1);\n    },\n    uint64: function() {\n      return readLongVarint.call(this)[u](!0);\n    },\n    sint64: function() {\n      return readLongVarint.call(this).zzDecode()[u](!1);\n    },\n    fixed64: function() {\n      return readFixed64.call(this)[u](!0);\n    },\n    sfixed64: function() {\n      return readFixed64.call(this)[u](!1);\n    }\n  });\n};\nvar reader_buffer = BufferReader, Reader = reader;\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\nvar util$5 = requireMinimal();\nfunction BufferReader(a) {\n  Reader.call(this, a);\n}\nBufferReader._configure = function() {\n  util$5.Buffer && (BufferReader.prototype._slice = util$5.Buffer.prototype.slice);\n};\nBufferReader.prototype.string = function a() {\n  var u = this.uint32();\n  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + u, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + u, this.len));\n};\nBufferReader._configure();\nvar rpc = {}, service = Service, util$4 = requireMinimal();\n(Service.prototype = Object.create(util$4.EventEmitter.prototype)).constructor = Service;\nfunction Service(a, u, c) {\n  if (typeof a != \"function\")\n    throw TypeError(\"rpcImpl must be a function\");\n  util$4.EventEmitter.call(this), this.rpcImpl = a, this.requestDelimited = !!u, this.responseDelimited = !!c;\n}\nService.prototype.rpcCall = function a(u, c, l, v, S) {\n  if (!v)\n    throw TypeError(\"request must be specified\");\n  var g = this;\n  if (!S)\n    return util$4.asPromise(a, g, u, c, l, v);\n  if (!g.rpcImpl) {\n    setTimeout(function() {\n      S(Error(\"already ended\"));\n    }, 0);\n    return;\n  }\n  try {\n    return g.rpcImpl(\n      u,\n      c[g.requestDelimited ? \"encodeDelimited\" : \"encode\"](v).finish(),\n      function(_, k) {\n        if (_)\n          return g.emit(\"error\", _, u), S(_);\n        if (k === null) {\n          g.end(\n            /* endedByRPC */\n            !0\n          );\n          return;\n        }\n        if (!(k instanceof l))\n          try {\n            k = l[g.responseDelimited ? \"decodeDelimited\" : \"decode\"](k);\n          } catch (L) {\n            return g.emit(\"error\", L, u), S(L);\n          }\n        return g.emit(\"data\", k, u), S(null, k);\n      }\n    );\n  } catch (E) {\n    g.emit(\"error\", E, u), setTimeout(function() {\n      S(E);\n    }, 0);\n    return;\n  }\n};\nService.prototype.end = function a(u) {\n  return this.rpcImpl && (u || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit(\"end\").off()), this;\n};\n(function(a) {\n  var u = a;\n  u.Service = service;\n})(rpc);\nvar roots = {};\n(function(a) {\n  var u = a;\n  u.build = \"minimal\", u.Writer = writer$2, u.BufferWriter = writer_buffer, u.Reader = reader, u.BufferReader = reader_buffer, u.util = requireMinimal(), u.rpc = rpc, u.roots = roots, u.configure = c;\n  function c() {\n    u.util._configure(), u.Writer._configure(u.BufferWriter), u.Reader._configure(u.BufferReader);\n  }\n  c();\n})(indexMinimal);\nvar minimal = indexMinimal, struct$2 = {};\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(B, Y, ne, Z) {\n    Z === void 0 && (Z = ne), Object.defineProperty(B, Z, { enumerable: !0, get: function() {\n      return Y[ne];\n    } });\n  } : function(B, Y, ne, Z) {\n    Z === void 0 && (Z = ne), B[Z] = Y[ne];\n  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(B, Y) {\n    Object.defineProperty(B, \"default\", { enumerable: !0, value: Y });\n  } : function(B, Y) {\n    B.default = Y;\n  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(B) {\n    if (B && B.__esModule)\n      return B;\n    var Y = {};\n    if (B != null)\n      for (var ne in B)\n        ne !== \"default\" && Object.hasOwnProperty.call(B, ne) && u(Y, B, ne);\n    return c(Y, B), Y;\n  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(B) {\n    return B && B.__esModule ? B : { default: B };\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;\n  const S = v(umdExports), g = l(minimal);\n  a.protobufPackage = \"google.protobuf\";\n  var E;\n  (function(B) {\n    B.NULL_VALUE = \"NULL_VALUE\";\n  })(E = a.NullValue || (a.NullValue = {}));\n  function _(B) {\n    switch (B) {\n      case 0:\n      case \"NULL_VALUE\":\n        return E.NULL_VALUE;\n      default:\n        throw new q.Error(\"Unrecognized enum value \" + B + \" for enum NullValue\");\n    }\n  }\n  a.nullValueFromJSON = _;\n  function k(B) {\n    switch (B) {\n      case E.NULL_VALUE:\n        return \"NULL_VALUE\";\n      default:\n        return \"UNKNOWN\";\n    }\n  }\n  a.nullValueToJSON = k;\n  function L(B) {\n    switch (B) {\n      case E.NULL_VALUE:\n        return 0;\n      default:\n        return 0;\n    }\n  }\n  a.nullValueToNumber = L;\n  function M() {\n    return { fields: {} };\n  }\n  a.Struct = {\n    encode(B, Y = g.Writer.create()) {\n      return Object.entries(B.fields).forEach(([ne, Z]) => {\n        Z !== void 0 && a.Struct_FieldsEntry.encode({ key: ne, value: Z }, Y.uint32(10).fork()).ldelim();\n      }), Y;\n    },\n    decode(B, Y) {\n      const ne = B instanceof g.Reader ? B : new g.Reader(B);\n      let Z = Y === void 0 ? ne.len : ne.pos + Y;\n      const re = M();\n      for (; ne.pos < Z; ) {\n        const oe = ne.uint32();\n        switch (oe >>> 3) {\n          case 1:\n            const de = a.Struct_FieldsEntry.decode(ne, ne.uint32());\n            de.value !== void 0 && (re.fields[de.key] = de.value);\n            break;\n          default:\n            ne.skipType(oe & 7);\n            break;\n        }\n      }\n      return re;\n    },\n    fromJSON(B) {\n      return {\n        fields: G(B.fields) ? Object.entries(B.fields).reduce((Y, [ne, Z]) => (Y[ne] = Z, Y), {}) : {}\n      };\n    },\n    toJSON(B) {\n      const Y = {};\n      return Y.fields = {}, B.fields && Object.entries(B.fields).forEach(([ne, Z]) => {\n        Y.fields[ne] = Z;\n      }), Y;\n    },\n    fromPartial(B) {\n      var Y;\n      const ne = M();\n      return ne.fields = Object.entries((Y = B.fields) !== null && Y !== void 0 ? Y : {}).reduce((Z, [re, oe]) => (oe !== void 0 && (Z[re] = oe), Z), {}), ne;\n    },\n    wrap(B) {\n      const Y = M();\n      return B !== void 0 && Object.keys(B).forEach((ne) => {\n        Y.fields[ne] = B[ne];\n      }), Y;\n    },\n    unwrap(B) {\n      const Y = {};\n      return Object.keys(B.fields).forEach((ne) => {\n        Y[ne] = B.fields[ne];\n      }), Y;\n    }\n  };\n  function $() {\n    return { key: \"\", value: void 0 };\n  }\n  a.Struct_FieldsEntry = {\n    encode(B, Y = g.Writer.create()) {\n      return B.key !== \"\" && Y.uint32(10).string(B.key), B.value !== void 0 && a.Value.encode(a.Value.wrap(B.value), Y.uint32(18).fork()).ldelim(), Y;\n    },\n    decode(B, Y) {\n      const ne = B instanceof g.Reader ? B : new g.Reader(B);\n      let Z = Y === void 0 ? ne.len : ne.pos + Y;\n      const re = $();\n      for (; ne.pos < Z; ) {\n        const oe = ne.uint32();\n        switch (oe >>> 3) {\n          case 1:\n            re.key = ne.string();\n            break;\n          case 2:\n            re.value = a.Value.unwrap(a.Value.decode(ne, ne.uint32()));\n            break;\n          default:\n            ne.skipType(oe & 7);\n            break;\n        }\n      }\n      return re;\n    },\n    fromJSON(B) {\n      return {\n        key: H(B.key) ? String(B.key) : \"\",\n        value: H(B == null ? void 0 : B.value) ? B.value : void 0\n      };\n    },\n    toJSON(B) {\n      const Y = {};\n      return B.key !== void 0 && (Y.key = B.key), B.value !== void 0 && (Y.value = B.value), Y;\n    },\n    fromPartial(B) {\n      var Y, ne;\n      const Z = $();\n      return Z.key = (Y = B.key) !== null && Y !== void 0 ? Y : \"\", Z.value = (ne = B.value) !== null && ne !== void 0 ? ne : void 0, Z;\n    }\n  };\n  function J() {\n    return {\n      nullValue: void 0,\n      numberValue: void 0,\n      stringValue: void 0,\n      boolValue: void 0,\n      structValue: void 0,\n      listValue: void 0\n    };\n  }\n  a.Value = {\n    encode(B, Y = g.Writer.create()) {\n      return B.nullValue !== void 0 && Y.uint32(8).int32(L(B.nullValue)), B.numberValue !== void 0 && Y.uint32(17).double(B.numberValue), B.stringValue !== void 0 && Y.uint32(26).string(B.stringValue), B.boolValue !== void 0 && Y.uint32(32).bool(B.boolValue), B.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(B.structValue), Y.uint32(42).fork()).ldelim(), B.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(B.listValue), Y.uint32(50).fork()).ldelim(), Y;\n    },\n    decode(B, Y) {\n      const ne = B instanceof g.Reader ? B : new g.Reader(B);\n      let Z = Y === void 0 ? ne.len : ne.pos + Y;\n      const re = J();\n      for (; ne.pos < Z; ) {\n        const oe = ne.uint32();\n        switch (oe >>> 3) {\n          case 1:\n            re.nullValue = _(ne.int32());\n            break;\n          case 2:\n            re.numberValue = ne.double();\n            break;\n          case 3:\n            re.stringValue = ne.string();\n            break;\n          case 4:\n            re.boolValue = ne.bool();\n            break;\n          case 5:\n            re.structValue = a.Struct.unwrap(a.Struct.decode(ne, ne.uint32()));\n            break;\n          case 6:\n            re.listValue = a.ListValue.unwrap(a.ListValue.decode(ne, ne.uint32()));\n            break;\n          default:\n            ne.skipType(oe & 7);\n            break;\n        }\n      }\n      return re;\n    },\n    fromJSON(B) {\n      return {\n        nullValue: H(B.nullValue) ? _(B.nullValue) : void 0,\n        numberValue: H(B.numberValue) ? Number(B.numberValue) : void 0,\n        stringValue: H(B.stringValue) ? String(B.stringValue) : void 0,\n        boolValue: H(B.boolValue) ? !!B.boolValue : void 0,\n        structValue: G(B.structValue) ? B.structValue : void 0,\n        listValue: Array.isArray(B.listValue) ? [...B.listValue] : void 0\n      };\n    },\n    toJSON(B) {\n      const Y = {};\n      return B.nullValue !== void 0 && (Y.nullValue = B.nullValue !== void 0 ? k(B.nullValue) : void 0), B.numberValue !== void 0 && (Y.numberValue = B.numberValue), B.stringValue !== void 0 && (Y.stringValue = B.stringValue), B.boolValue !== void 0 && (Y.boolValue = B.boolValue), B.structValue !== void 0 && (Y.structValue = B.structValue), B.listValue !== void 0 && (Y.listValue = B.listValue), Y;\n    },\n    fromPartial(B) {\n      var Y, ne, Z, re, oe, de;\n      const A = J();\n      return A.nullValue = (Y = B.nullValue) !== null && Y !== void 0 ? Y : void 0, A.numberValue = (ne = B.numberValue) !== null && ne !== void 0 ? ne : void 0, A.stringValue = (Z = B.stringValue) !== null && Z !== void 0 ? Z : void 0, A.boolValue = (re = B.boolValue) !== null && re !== void 0 ? re : void 0, A.structValue = (oe = B.structValue) !== null && oe !== void 0 ? oe : void 0, A.listValue = (de = B.listValue) !== null && de !== void 0 ? de : void 0, A;\n    },\n    wrap(B) {\n      const Y = J();\n      if (B === null)\n        Y.nullValue = E.NULL_VALUE;\n      else if (typeof B == \"boolean\")\n        Y.boolValue = B;\n      else if (typeof B == \"number\")\n        Y.numberValue = B;\n      else if (typeof B == \"string\")\n        Y.stringValue = B;\n      else if (Array.isArray(B))\n        Y.listValue = B;\n      else if (typeof B == \"object\")\n        Y.structValue = B;\n      else if (typeof B < \"u\")\n        throw new Error(\"Unsupported any value type: \" + typeof B);\n      return Y;\n    },\n    unwrap(B) {\n      if ((B == null ? void 0 : B.stringValue) !== void 0)\n        return B.stringValue;\n      if ((B == null ? void 0 : B.numberValue) !== void 0)\n        return B.numberValue;\n      if ((B == null ? void 0 : B.boolValue) !== void 0)\n        return B.boolValue;\n      if ((B == null ? void 0 : B.structValue) !== void 0)\n        return B.structValue;\n      if ((B == null ? void 0 : B.listValue) !== void 0)\n        return B.listValue;\n      if ((B == null ? void 0 : B.nullValue) !== void 0)\n        return null;\n    }\n  };\n  function V() {\n    return { values: [] };\n  }\n  a.ListValue = {\n    encode(B, Y = g.Writer.create()) {\n      for (const ne of B.values)\n        a.Value.encode(a.Value.wrap(ne), Y.uint32(10).fork()).ldelim();\n      return Y;\n    },\n    decode(B, Y) {\n      const ne = B instanceof g.Reader ? B : new g.Reader(B);\n      let Z = Y === void 0 ? ne.len : ne.pos + Y;\n      const re = V();\n      for (; ne.pos < Z; ) {\n        const oe = ne.uint32();\n        switch (oe >>> 3) {\n          case 1:\n            re.values.push(a.Value.unwrap(a.Value.decode(ne, ne.uint32())));\n            break;\n          default:\n            ne.skipType(oe & 7);\n            break;\n        }\n      }\n      return re;\n    },\n    fromJSON(B) {\n      return {\n        values: Array.isArray(B == null ? void 0 : B.values) ? [...B.values] : []\n      };\n    },\n    toJSON(B) {\n      const Y = {};\n      return B.values ? Y.values = B.values.map((ne) => ne) : Y.values = [], Y;\n    },\n    fromPartial(B) {\n      var Y;\n      const ne = V();\n      return ne.values = ((Y = B.values) === null || Y === void 0 ? void 0 : Y.map((Z) => Z)) || [], ne;\n    },\n    wrap(B) {\n      const Y = V();\n      return Y.values = B ?? [], Y;\n    },\n    unwrap(B) {\n      return B.values;\n    }\n  };\n  var q = (() => {\n    if (typeof q < \"u\")\n      return q;\n    if (typeof self < \"u\")\n      return self;\n    if (typeof window < \"u\")\n      return window;\n    if (typeof commonjsGlobal$1 < \"u\")\n      return commonjsGlobal$1;\n    throw \"Unable to locate global object\";\n  })();\n  g.util.Long !== S.default && (g.util.Long = S.default, g.configure());\n  function G(B) {\n    return typeof B == \"object\" && B !== null;\n  }\n  function H(B) {\n    return B != null;\n  }\n})(struct$2);\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(I, F, z, Te) {\n    Te === void 0 && (Te = z), Object.defineProperty(I, Te, { enumerable: !0, get: function() {\n      return F[z];\n    } });\n  } : function(I, F, z, Te) {\n    Te === void 0 && (Te = z), I[Te] = F[z];\n  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(I, F) {\n    Object.defineProperty(I, \"default\", { enumerable: !0, value: F });\n  } : function(I, F) {\n    I.default = F;\n  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(I) {\n    if (I && I.__esModule)\n      return I;\n    var F = {};\n    if (I != null)\n      for (var z in I)\n        z !== \"default\" && Object.hasOwnProperty.call(I, z) && u(F, I, z);\n    return c(F, I), F;\n  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(I) {\n    return I && I.__esModule ? I : { default: I };\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.LayoutServiceDefinition = a.LayoutServiceClientImpl = a.LayerServiceDefinition = a.LayerServiceClientImpl = a.Event = a.LayerEvent = a.LayoutEvent = a.BatchLayerRequest_BatchItem = a.BatchLayerRequest = a.BatchDeleteLayerRequest = a.DeleteLayerPayload = a.UpdateLayerRequest = a.GetLayerRequest = a.CreateLayerRequest = a.ListLayersResponse = a.ListLayersRequest = a.PartialLayerWithID = a.PartialLayer = a.LayerAnimation = a.DeleteLayoutResponse = a.DeleteLayoutRequest = a.DeleteLayoutPayload = a.UpdateLayoutRequest = a.GetLayoutRequest = a.CreateLayoutRequest = a.ListLayoutsResponse = a.ListLayoutsRequest = a.PartialLayout = a.BatchLayerResponse_BatchLayerItem = a.BatchLayerResponse = a.DeleteLayerResponse = a.DeleteLayerRequest = a.Layer = a.Layout = a.Transition_TransitionStinger = a.Transition_TransitionStingerCut = a.Transition_TransitionSwipe = a.Transition_TransitionCrossfade = a.Transition_TransitionFadeToColor = a.Transition_TransitionCut = a.Transition_TransitionMediaType = a.Transition = a.transition_TransitionSwipeTypeToNumber = a.transition_TransitionSwipeTypeToJSON = a.transition_TransitionSwipeTypeFromJSON = a.Transition_TransitionSwipeType = a.transition_TransitionDirectionToNumber = a.transition_TransitionDirectionToJSON = a.transition_TransitionDirectionFromJSON = a.Transition_TransitionDirection = a.eventTypeToNumber = a.eventTypeToJSON = a.eventTypeFromJSON = a.EventType = a.eventSubTypeToNumber = a.eventSubTypeToJSON = a.eventSubTypeFromJSON = a.EventSubType = a.requestAnimationModeToNumber = a.requestAnimationModeToJSON = a.requestAnimationModeFromJSON = a.RequestAnimationMode = a.layoutTypeToNumber = a.layoutTypeToJSON = a.layoutTypeFromJSON = a.LayoutType = a.protobufPackage = void 0;\n  const S = v(umdExports), g = l(minimal), E = struct$2;\n  a.protobufPackage = \"apis.layout.v2\";\n  var _;\n  (function(I) {\n    I.LAYOUT_TYPE_UNSPECIFIED = \"LAYOUT_TYPE_UNSPECIFIED\", I.LAYOUT_TYPE_SCENELESS = \"LAYOUT_TYPE_SCENELESS\", I.LAYOUT_TYPE_SCENE = \"LAYOUT_TYPE_SCENE\";\n  })(_ = a.LayoutType || (a.LayoutType = {}));\n  function k(I) {\n    switch (I) {\n      case 0:\n      case \"LAYOUT_TYPE_UNSPECIFIED\":\n        return _.LAYOUT_TYPE_UNSPECIFIED;\n      case 1:\n      case \"LAYOUT_TYPE_SCENELESS\":\n        return _.LAYOUT_TYPE_SCENELESS;\n      case 2:\n      case \"LAYOUT_TYPE_SCENE\":\n        return _.LAYOUT_TYPE_SCENE;\n      default:\n        throw new ot.Error(\"Unrecognized enum value \" + I + \" for enum LayoutType\");\n    }\n  }\n  a.layoutTypeFromJSON = k;\n  function L(I) {\n    switch (I) {\n      case _.LAYOUT_TYPE_UNSPECIFIED:\n        return \"LAYOUT_TYPE_UNSPECIFIED\";\n      case _.LAYOUT_TYPE_SCENELESS:\n        return \"LAYOUT_TYPE_SCENELESS\";\n      case _.LAYOUT_TYPE_SCENE:\n        return \"LAYOUT_TYPE_SCENE\";\n      default:\n        return \"UNKNOWN\";\n    }\n  }\n  a.layoutTypeToJSON = L;\n  function M(I) {\n    switch (I) {\n      case _.LAYOUT_TYPE_UNSPECIFIED:\n        return 0;\n      case _.LAYOUT_TYPE_SCENELESS:\n        return 1;\n      case _.LAYOUT_TYPE_SCENE:\n        return 2;\n      default:\n        return 0;\n    }\n  }\n  a.layoutTypeToNumber = M;\n  var $;\n  (function(I) {\n    I.REQUEST_ANIMATION_MODE_UNSPECIFIED = \"REQUEST_ANIMATION_MODE_UNSPECIFIED\", I.REQUEST_ANIMATION_MODE_PARALLEL = \"REQUEST_ANIMATION_MODE_PARALLEL\", I.REQUEST_ANIMATION_MODE_SERIES = \"REQUEST_ANIMATION_MODE_SERIES\";\n  })($ = a.RequestAnimationMode || (a.RequestAnimationMode = {}));\n  function J(I) {\n    switch (I) {\n      case 0:\n      case \"REQUEST_ANIMATION_MODE_UNSPECIFIED\":\n        return $.REQUEST_ANIMATION_MODE_UNSPECIFIED;\n      case 1:\n      case \"REQUEST_ANIMATION_MODE_PARALLEL\":\n        return $.REQUEST_ANIMATION_MODE_PARALLEL;\n      case 2:\n      case \"REQUEST_ANIMATION_MODE_SERIES\":\n        return $.REQUEST_ANIMATION_MODE_SERIES;\n      default:\n        throw new ot.Error(\"Unrecognized enum value \" + I + \" for enum RequestAnimationMode\");\n    }\n  }\n  a.requestAnimationModeFromJSON = J;\n  function V(I) {\n    switch (I) {\n      case $.REQUEST_ANIMATION_MODE_UNSPECIFIED:\n        return \"REQUEST_ANIMATION_MODE_UNSPECIFIED\";\n      case $.REQUEST_ANIMATION_MODE_PARALLEL:\n        return \"REQUEST_ANIMATION_MODE_PARALLEL\";\n      case $.REQUEST_ANIMATION_MODE_SERIES:\n        return \"REQUEST_ANIMATION_MODE_SERIES\";\n      default:\n        return \"UNKNOWN\";\n    }\n  }\n  a.requestAnimationModeToJSON = V;\n  function q(I) {\n    switch (I) {\n      case $.REQUEST_ANIMATION_MODE_UNSPECIFIED:\n        return 0;\n      case $.REQUEST_ANIMATION_MODE_PARALLEL:\n        return 1;\n      case $.REQUEST_ANIMATION_MODE_SERIES:\n        return 2;\n      default:\n        return 0;\n    }\n  }\n  a.requestAnimationModeToNumber = q;\n  var G;\n  (function(I) {\n    I.EVENT_SUB_TYPE_UNSPECIFIED = \"EVENT_SUB_TYPE_UNSPECIFIED\", I.EVENT_SUB_TYPE_CREATE = \"EVENT_SUB_TYPE_CREATE\", I.EVENT_SUB_TYPE_UPDATE = \"EVENT_SUB_TYPE_UPDATE\", I.EVENT_SUB_TYPE_DELETE = \"EVENT_SUB_TYPE_DELETE\", I.EVENT_SUB_TYPE_BATCH = \"EVENT_SUB_TYPE_BATCH\";\n  })(G = a.EventSubType || (a.EventSubType = {}));\n  function H(I) {\n    switch (I) {\n      case 0:\n      case \"EVENT_SUB_TYPE_UNSPECIFIED\":\n        return G.EVENT_SUB_TYPE_UNSPECIFIED;\n      case 1:\n      case \"EVENT_SUB_TYPE_CREATE\":\n        return G.EVENT_SUB_TYPE_CREATE;\n      case 2:\n      case \"EVENT_SUB_TYPE_UPDATE\":\n        return G.EVENT_SUB_TYPE_UPDATE;\n      case 3:\n      case \"EVENT_SUB_TYPE_DELETE\":\n        return G.EVENT_SUB_TYPE_DELETE;\n      case 4:\n      case \"EVENT_SUB_TYPE_BATCH\":\n        return G.EVENT_SUB_TYPE_BATCH;\n      default:\n        throw new ot.Error(\"Unrecognized enum value \" + I + \" for enum EventSubType\");\n    }\n  }\n  a.eventSubTypeFromJSON = H;\n  function B(I) {\n    switch (I) {\n      case G.EVENT_SUB_TYPE_UNSPECIFIED:\n        return \"EVENT_SUB_TYPE_UNSPECIFIED\";\n      case G.EVENT_SUB_TYPE_CREATE:\n        return \"EVENT_SUB_TYPE_CREATE\";\n      case G.EVENT_SUB_TYPE_UPDATE:\n        return \"EVENT_SUB_TYPE_UPDATE\";\n      case G.EVENT_SUB_TYPE_DELETE:\n        return \"EVENT_SUB_TYPE_DELETE\";\n      case G.EVENT_SUB_TYPE_BATCH:\n        return \"EVENT_SUB_TYPE_BATCH\";\n      default:\n        return \"UNKNOWN\";\n    }\n  }\n  a.eventSubTypeToJSON = B;\n  function Y(I) {\n    switch (I) {\n      case G.EVENT_SUB_TYPE_UNSPECIFIED:\n        return 0;\n      case G.EVENT_SUB_TYPE_CREATE:\n        return 1;\n      case G.EVENT_SUB_TYPE_UPDATE:\n        return 2;\n      case G.EVENT_SUB_TYPE_DELETE:\n        return 3;\n      case G.EVENT_SUB_TYPE_BATCH:\n        return 4;\n      default:\n        return 0;\n    }\n  }\n  a.eventSubTypeToNumber = Y;\n  var ne;\n  (function(I) {\n    I.EVENT_TYPE_UNSPECIFIED = \"EVENT_TYPE_UNSPECIFIED\", I.EVENT_TYPE_LAYOUT = \"EVENT_TYPE_LAYOUT\", I.EVENT_TYPE_LAYER = \"EVENT_TYPE_LAYER\";\n  })(ne = a.EventType || (a.EventType = {}));\n  function Z(I) {\n    switch (I) {\n      case 0:\n      case \"EVENT_TYPE_UNSPECIFIED\":\n        return ne.EVENT_TYPE_UNSPECIFIED;\n      case 1:\n      case \"EVENT_TYPE_LAYOUT\":\n        return ne.EVENT_TYPE_LAYOUT;\n      case 2:\n      case \"EVENT_TYPE_LAYER\":\n        return ne.EVENT_TYPE_LAYER;\n      default:\n        throw new ot.Error(\"Unrecognized enum value \" + I + \" for enum EventType\");\n    }\n  }\n  a.eventTypeFromJSON = Z;\n  function re(I) {\n    switch (I) {\n      case ne.EVENT_TYPE_UNSPECIFIED:\n        return \"EVENT_TYPE_UNSPECIFIED\";\n      case ne.EVENT_TYPE_LAYOUT:\n        return \"EVENT_TYPE_LAYOUT\";\n      case ne.EVENT_TYPE_LAYER:\n        return \"EVENT_TYPE_LAYER\";\n      default:\n        return \"UNKNOWN\";\n    }\n  }\n  a.eventTypeToJSON = re;\n  function oe(I) {\n    switch (I) {\n      case ne.EVENT_TYPE_UNSPECIFIED:\n        return 0;\n      case ne.EVENT_TYPE_LAYOUT:\n        return 1;\n      case ne.EVENT_TYPE_LAYER:\n        return 2;\n      default:\n        return 0;\n    }\n  }\n  a.eventTypeToNumber = oe;\n  var de;\n  (function(I) {\n    I.TRANSITION_DIRECTION_UNSPECIFIED = \"TRANSITION_DIRECTION_UNSPECIFIED\", I.TRANSITION_DIRECTION_LEFT = \"TRANSITION_DIRECTION_LEFT\", I.TRANSITION_DIRECTION_RIGHT = \"TRANSITION_DIRECTION_RIGHT\", I.TRANSITION_DIRECTION_UP = \"TRANSITION_DIRECTION_UP\", I.TRANSITION_DIRECTION_DOWN = \"TRANSITION_DIRECTION_DOWN\";\n  })(de = a.Transition_TransitionDirection || (a.Transition_TransitionDirection = {}));\n  function A(I) {\n    switch (I) {\n      case 0:\n      case \"TRANSITION_DIRECTION_UNSPECIFIED\":\n        return de.TRANSITION_DIRECTION_UNSPECIFIED;\n      case 1:\n      case \"TRANSITION_DIRECTION_LEFT\":\n        return de.TRANSITION_DIRECTION_LEFT;\n      case 2:\n      case \"TRANSITION_DIRECTION_RIGHT\":\n        return de.TRANSITION_DIRECTION_RIGHT;\n      case 3:\n      case \"TRANSITION_DIRECTION_UP\":\n        return de.TRANSITION_DIRECTION_UP;\n      case 4:\n      case \"TRANSITION_DIRECTION_DOWN\":\n        return de.TRANSITION_DIRECTION_DOWN;\n      default:\n        throw new ot.Error(\"Unrecognized enum value \" + I + \" for enum Transition_TransitionDirection\");\n    }\n  }\n  a.transition_TransitionDirectionFromJSON = A;\n  function N(I) {\n    switch (I) {\n      case de.TRANSITION_DIRECTION_UNSPECIFIED:\n        return \"TRANSITION_DIRECTION_UNSPECIFIED\";\n      case de.TRANSITION_DIRECTION_LEFT:\n        return \"TRANSITION_DIRECTION_LEFT\";\n      case de.TRANSITION_DIRECTION_RIGHT:\n        return \"TRANSITION_DIRECTION_RIGHT\";\n      case de.TRANSITION_DIRECTION_UP:\n        return \"TRANSITION_DIRECTION_UP\";\n      case de.TRANSITION_DIRECTION_DOWN:\n        return \"TRANSITION_DIRECTION_DOWN\";\n      default:\n        return \"UNKNOWN\";\n    }\n  }\n  a.transition_TransitionDirectionToJSON = N;\n  function D(I) {\n    switch (I) {\n      case de.TRANSITION_DIRECTION_UNSPECIFIED:\n        return 0;\n      case de.TRANSITION_DIRECTION_LEFT:\n        return 1;\n      case de.TRANSITION_DIRECTION_RIGHT:\n        return 2;\n      case de.TRANSITION_DIRECTION_UP:\n        return 3;\n      case de.TRANSITION_DIRECTION_DOWN:\n        return 4;\n      default:\n        return 0;\n    }\n  }\n  a.transition_TransitionDirectionToNumber = D;\n  var W;\n  (function(I) {\n    I.TRANSITION_SWIPE_TYPE_UNSPECIFIED = \"TRANSITION_SWIPE_TYPE_UNSPECIFIED\", I.TRANSITION_SWIPE_TYPE_COMBINED = \"TRANSITION_SWIPE_TYPE_COMBINED\", I.TRANSITION_SWIPE_TYPE_SOURCE = \"TRANSITION_SWIPE_TYPE_SOURCE\", I.TRANSITION_SWIPE_TYPE_DESTINATION = \"TRANSITION_SWIPE_TYPE_DESTINATION\";\n  })(W = a.Transition_TransitionSwipeType || (a.Transition_TransitionSwipeType = {}));\n  function ee(I) {\n    switch (I) {\n      case 0:\n      case \"TRANSITION_SWIPE_TYPE_UNSPECIFIED\":\n        return W.TRANSITION_SWIPE_TYPE_UNSPECIFIED;\n      case 1:\n      case \"TRANSITION_SWIPE_TYPE_COMBINED\":\n        return W.TRANSITION_SWIPE_TYPE_COMBINED;\n      case 2:\n      case \"TRANSITION_SWIPE_TYPE_SOURCE\":\n        return W.TRANSITION_SWIPE_TYPE_SOURCE;\n      case 3:\n      case \"TRANSITION_SWIPE_TYPE_DESTINATION\":\n        return W.TRANSITION_SWIPE_TYPE_DESTINATION;\n      default:\n        throw new ot.Error(\"Unrecognized enum value \" + I + \" for enum Transition_TransitionSwipeType\");\n    }\n  }\n  a.transition_TransitionSwipeTypeFromJSON = ee;\n  function ae(I) {\n    switch (I) {\n      case W.TRANSITION_SWIPE_TYPE_UNSPECIFIED:\n        return \"TRANSITION_SWIPE_TYPE_UNSPECIFIED\";\n      case W.TRANSITION_SWIPE_TYPE_COMBINED:\n        return \"TRANSITION_SWIPE_TYPE_COMBINED\";\n      case W.TRANSITION_SWIPE_TYPE_SOURCE:\n        return \"TRANSITION_SWIPE_TYPE_SOURCE\";\n      case W.TRANSITION_SWIPE_TYPE_DESTINATION:\n        return \"TRANSITION_SWIPE_TYPE_DESTINATION\";\n      default:\n        return \"UNKNOWN\";\n    }\n  }\n  a.transition_TransitionSwipeTypeToJSON = ae;\n  function ye(I) {\n    switch (I) {\n      case W.TRANSITION_SWIPE_TYPE_UNSPECIFIED:\n        return 0;\n      case W.TRANSITION_SWIPE_TYPE_COMBINED:\n        return 1;\n      case W.TRANSITION_SWIPE_TYPE_SOURCE:\n        return 2;\n      case W.TRANSITION_SWIPE_TYPE_DESTINATION:\n        return 3;\n      default:\n        return 0;\n    }\n  }\n  a.transition_TransitionSwipeTypeToNumber = ye;\n  function he() {\n    return {\n      fromLayoutIds: [],\n      cut: void 0,\n      crossfade: void 0,\n      fadeToColor: void 0,\n      swipe: void 0,\n      stinger: void 0\n    };\n  }\n  a.Transition = {\n    encode(I, F = g.Writer.create()) {\n      for (const z of I.fromLayoutIds)\n        F.uint32(10).string(z);\n      return I.cut !== void 0 && a.Transition_TransitionCut.encode(I.cut, F.uint32(82).fork()).ldelim(), I.crossfade !== void 0 && a.Transition_TransitionCrossfade.encode(I.crossfade, F.uint32(90).fork()).ldelim(), I.fadeToColor !== void 0 && a.Transition_TransitionFadeToColor.encode(I.fadeToColor, F.uint32(98).fork()).ldelim(), I.swipe !== void 0 && a.Transition_TransitionSwipe.encode(I.swipe, F.uint32(106).fork()).ldelim(), I.stinger !== void 0 && a.Transition_TransitionStinger.encode(I.stinger, F.uint32(114).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = he();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.fromLayoutIds.push(z.string());\n            break;\n          case 10:\n            fe.cut = a.Transition_TransitionCut.decode(z, z.uint32());\n            break;\n          case 11:\n            fe.crossfade = a.Transition_TransitionCrossfade.decode(z, z.uint32());\n            break;\n          case 12:\n            fe.fadeToColor = a.Transition_TransitionFadeToColor.decode(z, z.uint32());\n            break;\n          case 13:\n            fe.swipe = a.Transition_TransitionSwipe.decode(z, z.uint32());\n            break;\n          case 14:\n            fe.stinger = a.Transition_TransitionStinger.decode(z, z.uint32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        fromLayoutIds: Array.isArray(I == null ? void 0 : I.fromLayoutIds) ? I.fromLayoutIds.map((F) => String(F)) : [],\n        cut: Ce(I.cut) ? a.Transition_TransitionCut.fromJSON(I.cut) : void 0,\n        crossfade: Ce(I.crossfade) ? a.Transition_TransitionCrossfade.fromJSON(I.crossfade) : void 0,\n        fadeToColor: Ce(I.fadeToColor) ? a.Transition_TransitionFadeToColor.fromJSON(I.fadeToColor) : void 0,\n        swipe: Ce(I.swipe) ? a.Transition_TransitionSwipe.fromJSON(I.swipe) : void 0,\n        stinger: Ce(I.stinger) ? a.Transition_TransitionStinger.fromJSON(I.stinger) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.fromLayoutIds ? F.fromLayoutIds = I.fromLayoutIds.map((z) => z) : F.fromLayoutIds = [], I.cut !== void 0 && (F.cut = I.cut ? a.Transition_TransitionCut.toJSON(I.cut) : void 0), I.crossfade !== void 0 && (F.crossfade = I.crossfade ? a.Transition_TransitionCrossfade.toJSON(I.crossfade) : void 0), I.fadeToColor !== void 0 && (F.fadeToColor = I.fadeToColor ? a.Transition_TransitionFadeToColor.toJSON(I.fadeToColor) : void 0), I.swipe !== void 0 && (F.swipe = I.swipe ? a.Transition_TransitionSwipe.toJSON(I.swipe) : void 0), I.stinger !== void 0 && (F.stinger = I.stinger ? a.Transition_TransitionStinger.toJSON(I.stinger) : void 0), F;\n    },\n    fromPartial(I) {\n      var F;\n      const z = he();\n      return z.fromLayoutIds = ((F = I.fromLayoutIds) === null || F === void 0 ? void 0 : F.map((Te) => Te)) || [], z.cut = I.cut !== void 0 && I.cut !== null ? a.Transition_TransitionCut.fromPartial(I.cut) : void 0, z.crossfade = I.crossfade !== void 0 && I.crossfade !== null ? a.Transition_TransitionCrossfade.fromPartial(I.crossfade) : void 0, z.fadeToColor = I.fadeToColor !== void 0 && I.fadeToColor !== null ? a.Transition_TransitionFadeToColor.fromPartial(I.fadeToColor) : void 0, z.swipe = I.swipe !== void 0 && I.swipe !== null ? a.Transition_TransitionSwipe.fromPartial(I.swipe) : void 0, z.stinger = I.stinger !== void 0 && I.stinger !== null ? a.Transition_TransitionStinger.fromPartial(I.stinger) : void 0, z;\n    }\n  };\n  function le() {\n    return { url: \"\", volume: 0 };\n  }\n  a.Transition_TransitionMediaType = {\n    encode(I, F = g.Writer.create()) {\n      return I.url !== \"\" && F.uint32(10).string(I.url), I.volume !== 0 && F.uint32(17).double(I.volume), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = le();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.url = z.string();\n            break;\n          case 2:\n            fe.volume = z.double();\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        url: Ce(I.url) ? String(I.url) : \"\",\n        volume: Ce(I.volume) ? Number(I.volume) : 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.url !== void 0 && (F.url = I.url), I.volume !== void 0 && (F.volume = I.volume), F;\n    },\n    fromPartial(I) {\n      var F, z;\n      const Te = le();\n      return Te.url = (F = I.url) !== null && F !== void 0 ? F : \"\", Te.volume = (z = I.volume) !== null && z !== void 0 ? z : 0, Te;\n    }\n  };\n  function we() {\n    return {};\n  }\n  a.Transition_TransitionCut = {\n    encode(I, F = g.Writer.create()) {\n      return F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = we();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {};\n    },\n    toJSON(I) {\n      return {};\n    },\n    fromPartial(I) {\n      return we();\n    }\n  };\n  function Be() {\n    return { durationMs: 0, backgroundColor: \"\" };\n  }\n  a.Transition_TransitionFadeToColor = {\n    encode(I, F = g.Writer.create()) {\n      return I.durationMs !== 0 && F.uint32(8).int32(I.durationMs), I.backgroundColor !== \"\" && F.uint32(18).string(I.backgroundColor), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = Be();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.durationMs = z.int32();\n            break;\n          case 2:\n            fe.backgroundColor = z.string();\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        durationMs: Ce(I.durationMs) ? Number(I.durationMs) : 0,\n        backgroundColor: Ce(I.backgroundColor) ? String(I.backgroundColor) : \"\"\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.durationMs !== void 0 && (F.durationMs = Math.round(I.durationMs)), I.backgroundColor !== void 0 && (F.backgroundColor = I.backgroundColor), F;\n    },\n    fromPartial(I) {\n      var F, z;\n      const Te = Be();\n      return Te.durationMs = (F = I.durationMs) !== null && F !== void 0 ? F : 0, Te.backgroundColor = (z = I.backgroundColor) !== null && z !== void 0 ? z : \"\", Te;\n    }\n  };\n  function Ne() {\n    return { durationMs: 0 };\n  }\n  a.Transition_TransitionCrossfade = {\n    encode(I, F = g.Writer.create()) {\n      return I.durationMs !== 0 && F.uint32(8).int32(I.durationMs), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = Ne();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.durationMs = z.int32();\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        durationMs: Ce(I.durationMs) ? Number(I.durationMs) : 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.durationMs !== void 0 && (F.durationMs = Math.round(I.durationMs)), F;\n    },\n    fromPartial(I) {\n      var F;\n      const z = Ne();\n      return z.durationMs = (F = I.durationMs) !== null && F !== void 0 ? F : 0, z;\n    }\n  };\n  function Le() {\n    return {\n      durationMs: 0,\n      direction: de.TRANSITION_DIRECTION_UNSPECIFIED,\n      combinedAnimation: W.TRANSITION_SWIPE_TYPE_UNSPECIFIED\n    };\n  }\n  a.Transition_TransitionSwipe = {\n    encode(I, F = g.Writer.create()) {\n      return I.durationMs !== 0 && F.uint32(8).int32(I.durationMs), I.direction !== de.TRANSITION_DIRECTION_UNSPECIFIED && F.uint32(16).int32(D(I.direction)), I.combinedAnimation !== W.TRANSITION_SWIPE_TYPE_UNSPECIFIED && F.uint32(24).int32(ye(I.combinedAnimation)), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = Le();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.durationMs = z.int32();\n            break;\n          case 2:\n            fe.direction = A(z.int32());\n            break;\n          case 3:\n            fe.combinedAnimation = ee(z.int32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        durationMs: Ce(I.durationMs) ? Number(I.durationMs) : 0,\n        direction: Ce(I.direction) ? A(I.direction) : de.TRANSITION_DIRECTION_UNSPECIFIED,\n        combinedAnimation: Ce(I.combinedAnimation) ? ee(I.combinedAnimation) : W.TRANSITION_SWIPE_TYPE_UNSPECIFIED\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.durationMs !== void 0 && (F.durationMs = Math.round(I.durationMs)), I.direction !== void 0 && (F.direction = N(I.direction)), I.combinedAnimation !== void 0 && (F.combinedAnimation = ae(I.combinedAnimation)), F;\n    },\n    fromPartial(I) {\n      var F, z, Te;\n      const fe = Le();\n      return fe.durationMs = (F = I.durationMs) !== null && F !== void 0 ? F : 0, fe.direction = (z = I.direction) !== null && z !== void 0 ? z : de.TRANSITION_DIRECTION_UNSPECIFIED, fe.combinedAnimation = (Te = I.combinedAnimation) !== null && Te !== void 0 ? Te : W.TRANSITION_SWIPE_TYPE_UNSPECIFIED, fe;\n    }\n  };\n  function $e() {\n    return { cutPointMs: 0, media: void 0 };\n  }\n  a.Transition_TransitionStingerCut = {\n    encode(I, F = g.Writer.create()) {\n      return I.cutPointMs !== 0 && F.uint32(8).int32(I.cutPointMs), I.media !== void 0 && a.Transition_TransitionMediaType.encode(I.media, F.uint32(18).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = $e();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.cutPointMs = z.int32();\n            break;\n          case 2:\n            fe.media = a.Transition_TransitionMediaType.decode(z, z.uint32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        cutPointMs: Ce(I.cutPointMs) ? Number(I.cutPointMs) : 0,\n        media: Ce(I.media) ? a.Transition_TransitionMediaType.fromJSON(I.media) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.cutPointMs !== void 0 && (F.cutPointMs = Math.round(I.cutPointMs)), I.media !== void 0 && (F.media = I.media ? a.Transition_TransitionMediaType.toJSON(I.media) : void 0), F;\n    },\n    fromPartial(I) {\n      var F;\n      const z = $e();\n      return z.cutPointMs = (F = I.cutPointMs) !== null && F !== void 0 ? F : 0, z.media = I.media !== void 0 && I.media !== null ? a.Transition_TransitionMediaType.fromPartial(I.media) : void 0, z;\n    }\n  };\n  function Ue() {\n    return { cut: void 0 };\n  }\n  a.Transition_TransitionStinger = {\n    encode(I, F = g.Writer.create()) {\n      return I.cut !== void 0 && a.Transition_TransitionStingerCut.encode(I.cut, F.uint32(10).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = Ue();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.cut = a.Transition_TransitionStingerCut.decode(z, z.uint32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        cut: Ce(I.cut) ? a.Transition_TransitionStingerCut.fromJSON(I.cut) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.cut !== void 0 && (F.cut = I.cut ? a.Transition_TransitionStingerCut.toJSON(I.cut) : void 0), F;\n    },\n    fromPartial(I) {\n      const F = Ue();\n      return F.cut = I.cut !== void 0 && I.cut !== null ? a.Transition_TransitionStingerCut.fromPartial(I.cut) : void 0, F;\n    }\n  };\n  function Ge() {\n    return {\n      id: \"\",\n      width: 0,\n      height: 0,\n      metadata: void 0,\n      projectId: void 0,\n      collectionId: void 0,\n      type: void 0,\n      transitions: [],\n      requestMetadata: void 0\n    };\n  }\n  a.Layout = {\n    encode(I, F = g.Writer.create()) {\n      I.id !== \"\" && F.uint32(10).string(I.id), I.width !== 0 && F.uint32(16).int32(I.width), I.height !== 0 && F.uint32(24).int32(I.height), I.metadata !== void 0 && E.Value.encode(E.Value.wrap(I.metadata), F.uint32(50).fork()).ldelim(), I.projectId !== void 0 && F.uint32(58).string(I.projectId), I.collectionId !== void 0 && F.uint32(66).string(I.collectionId), I.type !== void 0 && F.uint32(72).int32(M(I.type));\n      for (const z of I.transitions)\n        a.Transition.encode(z, F.uint32(82).fork()).ldelim();\n      return I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(810).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = Ge();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.id = z.string();\n            break;\n          case 2:\n            fe.width = z.int32();\n            break;\n          case 3:\n            fe.height = z.int32();\n            break;\n          case 6:\n            fe.metadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 7:\n            fe.projectId = z.string();\n            break;\n          case 8:\n            fe.collectionId = z.string();\n            break;\n          case 9:\n            fe.type = k(z.int32());\n            break;\n          case 10:\n            fe.transitions.push(a.Transition.decode(z, z.uint32()));\n            break;\n          case 101:\n            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        id: Ce(I.id) ? String(I.id) : \"\",\n        width: Ce(I.width) ? Number(I.width) : 0,\n        height: Ce(I.height) ? Number(I.height) : 0,\n        metadata: Ce(I == null ? void 0 : I.metadata) ? I.metadata : void 0,\n        projectId: Ce(I.projectId) ? String(I.projectId) : void 0,\n        collectionId: Ce(I.collectionId) ? String(I.collectionId) : void 0,\n        type: Ce(I.type) ? k(I.type) : void 0,\n        transitions: Array.isArray(I == null ? void 0 : I.transitions) ? I.transitions.map((F) => a.Transition.fromJSON(F)) : [],\n        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.id !== void 0 && (F.id = I.id), I.width !== void 0 && (F.width = Math.round(I.width)), I.height !== void 0 && (F.height = Math.round(I.height)), I.metadata !== void 0 && (F.metadata = I.metadata), I.projectId !== void 0 && (F.projectId = I.projectId), I.collectionId !== void 0 && (F.collectionId = I.collectionId), I.type !== void 0 && (F.type = I.type !== void 0 ? L(I.type) : void 0), I.transitions ? F.transitions = I.transitions.map((z) => z ? a.Transition.toJSON(z) : void 0) : F.transitions = [], I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), F;\n    },\n    fromPartial(I) {\n      var F, z, Te, fe, ke, it, mt, vt, st;\n      const ut = Ge();\n      return ut.id = (F = I.id) !== null && F !== void 0 ? F : \"\", ut.width = (z = I.width) !== null && z !== void 0 ? z : 0, ut.height = (Te = I.height) !== null && Te !== void 0 ? Te : 0, ut.metadata = (fe = I.metadata) !== null && fe !== void 0 ? fe : void 0, ut.projectId = (ke = I.projectId) !== null && ke !== void 0 ? ke : void 0, ut.collectionId = (it = I.collectionId) !== null && it !== void 0 ? it : void 0, ut.type = (mt = I.type) !== null && mt !== void 0 ? mt : void 0, ut.transitions = ((vt = I.transitions) === null || vt === void 0 ? void 0 : vt.map((yt) => a.Transition.fromPartial(yt))) || [], ut.requestMetadata = (st = I.requestMetadata) !== null && st !== void 0 ? st : void 0, ut;\n    }\n  };\n  function He() {\n    return {\n      type: \"\",\n      data: void 0,\n      x: void 0,\n      y: void 0,\n      width: void 0,\n      height: void 0,\n      rotation: 0,\n      opacity: 0,\n      scale: 0,\n      hidden: !1,\n      children: void 0,\n      metadata: void 0,\n      id: \"\",\n      layoutId: \"\",\n      requestMetadata: void 0,\n      requestAnimation: []\n    };\n  }\n  a.Layer = {\n    encode(I, F = g.Writer.create()) {\n      I.type !== \"\" && F.uint32(10).string(I.type), I.data !== void 0 && E.Struct.encode(E.Struct.wrap(I.data), F.uint32(18).fork()).ldelim(), I.x !== void 0 && E.Value.encode(E.Value.wrap(I.x), F.uint32(26).fork()).ldelim(), I.y !== void 0 && E.Value.encode(E.Value.wrap(I.y), F.uint32(34).fork()).ldelim(), I.width !== void 0 && E.Value.encode(E.Value.wrap(I.width), F.uint32(42).fork()).ldelim(), I.height !== void 0 && E.Value.encode(E.Value.wrap(I.height), F.uint32(50).fork()).ldelim(), I.rotation !== 0 && F.uint32(57).double(I.rotation), I.opacity !== 0 && F.uint32(65).double(I.opacity), I.scale !== 0 && F.uint32(73).double(I.scale), I.hidden === !0 && F.uint32(80).bool(I.hidden), I.children !== void 0 && E.ListValue.encode(E.ListValue.wrap(I.children), F.uint32(98).fork()).ldelim(), I.metadata !== void 0 && E.Value.encode(E.Value.wrap(I.metadata), F.uint32(114).fork()).ldelim(), I.id !== \"\" && F.uint32(802).string(I.id), I.layoutId !== \"\" && F.uint32(818).string(I.layoutId), I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(810).fork()).ldelim();\n      for (const z of I.requestAnimation)\n        a.LayerAnimation.encode(z, F.uint32(826).fork()).ldelim();\n      return F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = He();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.type = z.string();\n            break;\n          case 2:\n            fe.data = E.Struct.unwrap(E.Struct.decode(z, z.uint32()));\n            break;\n          case 3:\n            fe.x = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 4:\n            fe.y = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 5:\n            fe.width = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 6:\n            fe.height = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 7:\n            fe.rotation = z.double();\n            break;\n          case 8:\n            fe.opacity = z.double();\n            break;\n          case 9:\n            fe.scale = z.double();\n            break;\n          case 10:\n            fe.hidden = z.bool();\n            break;\n          case 12:\n            fe.children = E.ListValue.unwrap(E.ListValue.decode(z, z.uint32()));\n            break;\n          case 14:\n            fe.metadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 100:\n            fe.id = z.string();\n            break;\n          case 102:\n            fe.layoutId = z.string();\n            break;\n          case 101:\n            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 103:\n            fe.requestAnimation.push(a.LayerAnimation.decode(z, z.uint32()));\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        type: Ce(I.type) ? String(I.type) : \"\",\n        data: ft(I.data) ? I.data : void 0,\n        x: Ce(I == null ? void 0 : I.x) ? I.x : void 0,\n        y: Ce(I == null ? void 0 : I.y) ? I.y : void 0,\n        width: Ce(I == null ? void 0 : I.width) ? I.width : void 0,\n        height: Ce(I == null ? void 0 : I.height) ? I.height : void 0,\n        rotation: Ce(I.rotation) ? Number(I.rotation) : 0,\n        opacity: Ce(I.opacity) ? Number(I.opacity) : 0,\n        scale: Ce(I.scale) ? Number(I.scale) : 0,\n        hidden: Ce(I.hidden) ? !!I.hidden : !1,\n        children: Array.isArray(I.children) ? [...I.children] : void 0,\n        metadata: Ce(I == null ? void 0 : I.metadata) ? I.metadata : void 0,\n        id: Ce(I.id) ? String(I.id) : \"\",\n        layoutId: Ce(I.layoutId) ? String(I.layoutId) : \"\",\n        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0,\n        requestAnimation: Array.isArray(I == null ? void 0 : I.requestAnimation) ? I.requestAnimation.map((F) => a.LayerAnimation.fromJSON(F)) : []\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.type !== void 0 && (F.type = I.type), I.data !== void 0 && (F.data = I.data), I.x !== void 0 && (F.x = I.x), I.y !== void 0 && (F.y = I.y), I.width !== void 0 && (F.width = I.width), I.height !== void 0 && (F.height = I.height), I.rotation !== void 0 && (F.rotation = I.rotation), I.opacity !== void 0 && (F.opacity = I.opacity), I.scale !== void 0 && (F.scale = I.scale), I.hidden !== void 0 && (F.hidden = I.hidden), I.children !== void 0 && (F.children = I.children), I.metadata !== void 0 && (F.metadata = I.metadata), I.id !== void 0 && (F.id = I.id), I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), I.requestAnimation ? F.requestAnimation = I.requestAnimation.map((z) => z ? a.LayerAnimation.toJSON(z) : void 0) : F.requestAnimation = [], F;\n    },\n    fromPartial(I) {\n      var F, z, Te, fe, ke, it, mt, vt, st, ut, yt, gt, bt, St, Et, ct;\n      const Xe = He();\n      return Xe.type = (F = I.type) !== null && F !== void 0 ? F : \"\", Xe.data = (z = I.data) !== null && z !== void 0 ? z : void 0, Xe.x = (Te = I.x) !== null && Te !== void 0 ? Te : void 0, Xe.y = (fe = I.y) !== null && fe !== void 0 ? fe : void 0, Xe.width = (ke = I.width) !== null && ke !== void 0 ? ke : void 0, Xe.height = (it = I.height) !== null && it !== void 0 ? it : void 0, Xe.rotation = (mt = I.rotation) !== null && mt !== void 0 ? mt : 0, Xe.opacity = (vt = I.opacity) !== null && vt !== void 0 ? vt : 0, Xe.scale = (st = I.scale) !== null && st !== void 0 ? st : 0, Xe.hidden = (ut = I.hidden) !== null && ut !== void 0 ? ut : !1, Xe.children = (yt = I.children) !== null && yt !== void 0 ? yt : void 0, Xe.metadata = (gt = I.metadata) !== null && gt !== void 0 ? gt : void 0, Xe.id = (bt = I.id) !== null && bt !== void 0 ? bt : \"\", Xe.layoutId = (St = I.layoutId) !== null && St !== void 0 ? St : \"\", Xe.requestMetadata = (Et = I.requestMetadata) !== null && Et !== void 0 ? Et : void 0, Xe.requestAnimation = ((ct = I.requestAnimation) === null || ct === void 0 ? void 0 : ct.map((Ct) => a.LayerAnimation.fromPartial(Ct))) || [], Xe;\n    }\n  };\n  function Ve() {\n    return { layoutId: \"\", layerId: \"\", payload: void 0 };\n  }\n  a.DeleteLayerRequest = {\n    encode(I, F = g.Writer.create()) {\n      return I.layoutId !== \"\" && F.uint32(10).string(I.layoutId), I.layerId !== \"\" && F.uint32(18).string(I.layerId), I.payload !== void 0 && a.DeleteLayerPayload.encode(I.payload, F.uint32(26).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = Ve();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.layoutId = z.string();\n            break;\n          case 2:\n            fe.layerId = z.string();\n            break;\n          case 3:\n            fe.payload = a.DeleteLayerPayload.decode(z, z.uint32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        layoutId: Ce(I.layoutId) ? String(I.layoutId) : \"\",\n        layerId: Ce(I.layerId) ? String(I.layerId) : \"\",\n        payload: Ce(I.payload) ? a.DeleteLayerPayload.fromJSON(I.payload) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.layerId !== void 0 && (F.layerId = I.layerId), I.payload !== void 0 && (F.payload = I.payload ? a.DeleteLayerPayload.toJSON(I.payload) : void 0), F;\n    },\n    fromPartial(I) {\n      var F, z;\n      const Te = Ve();\n      return Te.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : \"\", Te.layerId = (z = I.layerId) !== null && z !== void 0 ? z : \"\", Te.payload = I.payload !== void 0 && I.payload !== null ? a.DeleteLayerPayload.fromPartial(I.payload) : void 0, Te;\n    }\n  };\n  function be() {\n    return { id: \"\", layoutId: \"\", requestMetadata: void 0 };\n  }\n  a.DeleteLayerResponse = {\n    encode(I, F = g.Writer.create()) {\n      return I.id !== \"\" && F.uint32(10).string(I.id), I.layoutId !== \"\" && F.uint32(18).string(I.layoutId), I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = be();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.id = z.string();\n            break;\n          case 2:\n            fe.layoutId = z.string();\n            break;\n          case 100:\n            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        id: Ce(I.id) ? String(I.id) : \"\",\n        layoutId: Ce(I.layoutId) ? String(I.layoutId) : \"\",\n        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.id !== void 0 && (F.id = I.id), I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), F;\n    },\n    fromPartial(I) {\n      var F, z, Te;\n      const fe = be();\n      return fe.id = (F = I.id) !== null && F !== void 0 ? F : \"\", fe.layoutId = (z = I.layoutId) !== null && z !== void 0 ? z : \"\", fe.requestMetadata = (Te = I.requestMetadata) !== null && Te !== void 0 ? Te : void 0, fe;\n    }\n  };\n  function Ae() {\n    return {\n      layers: [],\n      layoutId: \"\",\n      requestMetadata: void 0,\n      requestAnimationMode: $.REQUEST_ANIMATION_MODE_UNSPECIFIED\n    };\n  }\n  a.BatchLayerResponse = {\n    encode(I, F = g.Writer.create()) {\n      for (const z of I.layers)\n        a.BatchLayerResponse_BatchLayerItem.encode(z, F.uint32(18).fork()).ldelim();\n      return I.layoutId !== \"\" && F.uint32(26).string(I.layoutId), I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim(), I.requestAnimationMode !== $.REQUEST_ANIMATION_MODE_UNSPECIFIED && F.uint32(808).int32(q(I.requestAnimationMode)), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = Ae();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 2:\n            fe.layers.push(a.BatchLayerResponse_BatchLayerItem.decode(z, z.uint32()));\n            break;\n          case 3:\n            fe.layoutId = z.string();\n            break;\n          case 100:\n            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 101:\n            fe.requestAnimationMode = J(z.int32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        layers: Array.isArray(I == null ? void 0 : I.layers) ? I.layers.map((F) => a.BatchLayerResponse_BatchLayerItem.fromJSON(F)) : [],\n        layoutId: Ce(I.layoutId) ? String(I.layoutId) : \"\",\n        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0,\n        requestAnimationMode: Ce(I.requestAnimationMode) ? J(I.requestAnimationMode) : $.REQUEST_ANIMATION_MODE_UNSPECIFIED\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.layers ? F.layers = I.layers.map((z) => z ? a.BatchLayerResponse_BatchLayerItem.toJSON(z) : void 0) : F.layers = [], I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), I.requestAnimationMode !== void 0 && (F.requestAnimationMode = V(I.requestAnimationMode)), F;\n    },\n    fromPartial(I) {\n      var F, z, Te, fe;\n      const ke = Ae();\n      return ke.layers = ((F = I.layers) === null || F === void 0 ? void 0 : F.map((it) => a.BatchLayerResponse_BatchLayerItem.fromPartial(it))) || [], ke.layoutId = (z = I.layoutId) !== null && z !== void 0 ? z : \"\", ke.requestMetadata = (Te = I.requestMetadata) !== null && Te !== void 0 ? Te : void 0, ke.requestAnimationMode = (fe = I.requestAnimationMode) !== null && fe !== void 0 ? fe : $.REQUEST_ANIMATION_MODE_UNSPECIFIED, ke;\n    }\n  };\n  function qe() {\n    return { create: void 0, update: void 0, delete: void 0 };\n  }\n  a.BatchLayerResponse_BatchLayerItem = {\n    encode(I, F = g.Writer.create()) {\n      return I.create !== void 0 && a.Layer.encode(I.create, F.uint32(10).fork()).ldelim(), I.update !== void 0 && a.Layer.encode(I.update, F.uint32(18).fork()).ldelim(), I.delete !== void 0 && a.DeleteLayerResponse.encode(I.delete, F.uint32(26).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = qe();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.create = a.Layer.decode(z, z.uint32());\n            break;\n          case 2:\n            fe.update = a.Layer.decode(z, z.uint32());\n            break;\n          case 3:\n            fe.delete = a.DeleteLayerResponse.decode(z, z.uint32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        create: Ce(I.create) ? a.Layer.fromJSON(I.create) : void 0,\n        update: Ce(I.update) ? a.Layer.fromJSON(I.update) : void 0,\n        delete: Ce(I.delete) ? a.DeleteLayerResponse.fromJSON(I.delete) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.create !== void 0 && (F.create = I.create ? a.Layer.toJSON(I.create) : void 0), I.update !== void 0 && (F.update = I.update ? a.Layer.toJSON(I.update) : void 0), I.delete !== void 0 && (F.delete = I.delete ? a.DeleteLayerResponse.toJSON(I.delete) : void 0), F;\n    },\n    fromPartial(I) {\n      const F = qe();\n      return F.create = I.create !== void 0 && I.create !== null ? a.Layer.fromPartial(I.create) : void 0, F.update = I.update !== void 0 && I.update !== null ? a.Layer.fromPartial(I.update) : void 0, F.delete = I.delete !== void 0 && I.delete !== null ? a.DeleteLayerResponse.fromPartial(I.delete) : void 0, F;\n    }\n  };\n  function xe() {\n    return {\n      width: void 0,\n      height: void 0,\n      metadata: void 0,\n      projectId: void 0,\n      collectionId: void 0,\n      type: void 0,\n      transitions: [],\n      requestMetadata: void 0\n    };\n  }\n  a.PartialLayout = {\n    encode(I, F = g.Writer.create()) {\n      I.width !== void 0 && F.uint32(16).int32(I.width), I.height !== void 0 && F.uint32(24).int32(I.height), I.metadata !== void 0 && E.Value.encode(E.Value.wrap(I.metadata), F.uint32(50).fork()).ldelim(), I.projectId !== void 0 && F.uint32(58).string(I.projectId), I.collectionId !== void 0 && F.uint32(66).string(I.collectionId), I.type !== void 0 && F.uint32(72).int32(M(I.type));\n      for (const z of I.transitions)\n        a.Transition.encode(z, F.uint32(82).fork()).ldelim();\n      return I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(810).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = xe();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 2:\n            fe.width = z.int32();\n            break;\n          case 3:\n            fe.height = z.int32();\n            break;\n          case 6:\n            fe.metadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 7:\n            fe.projectId = z.string();\n            break;\n          case 8:\n            fe.collectionId = z.string();\n            break;\n          case 9:\n            fe.type = k(z.int32());\n            break;\n          case 10:\n            fe.transitions.push(a.Transition.decode(z, z.uint32()));\n            break;\n          case 101:\n            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        width: Ce(I.width) ? Number(I.width) : void 0,\n        height: Ce(I.height) ? Number(I.height) : void 0,\n        metadata: Ce(I == null ? void 0 : I.metadata) ? I.metadata : void 0,\n        projectId: Ce(I.projectId) ? String(I.projectId) : void 0,\n        collectionId: Ce(I.collectionId) ? String(I.collectionId) : void 0,\n        type: Ce(I.type) ? k(I.type) : void 0,\n        transitions: Array.isArray(I == null ? void 0 : I.transitions) ? I.transitions.map((F) => a.Transition.fromJSON(F)) : [],\n        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.width !== void 0 && (F.width = Math.round(I.width)), I.height !== void 0 && (F.height = Math.round(I.height)), I.metadata !== void 0 && (F.metadata = I.metadata), I.projectId !== void 0 && (F.projectId = I.projectId), I.collectionId !== void 0 && (F.collectionId = I.collectionId), I.type !== void 0 && (F.type = I.type !== void 0 ? L(I.type) : void 0), I.transitions ? F.transitions = I.transitions.map((z) => z ? a.Transition.toJSON(z) : void 0) : F.transitions = [], I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), F;\n    },\n    fromPartial(I) {\n      var F, z, Te, fe, ke, it, mt, vt;\n      const st = xe();\n      return st.width = (F = I.width) !== null && F !== void 0 ? F : void 0, st.height = (z = I.height) !== null && z !== void 0 ? z : void 0, st.metadata = (Te = I.metadata) !== null && Te !== void 0 ? Te : void 0, st.projectId = (fe = I.projectId) !== null && fe !== void 0 ? fe : void 0, st.collectionId = (ke = I.collectionId) !== null && ke !== void 0 ? ke : void 0, st.type = (it = I.type) !== null && it !== void 0 ? it : void 0, st.transitions = ((mt = I.transitions) === null || mt === void 0 ? void 0 : mt.map((ut) => a.Transition.fromPartial(ut))) || [], st.requestMetadata = (vt = I.requestMetadata) !== null && vt !== void 0 ? vt : void 0, st;\n    }\n  };\n  function Pe() {\n    return { projectId: void 0, collectionId: void 0, type: void 0 };\n  }\n  a.ListLayoutsRequest = {\n    encode(I, F = g.Writer.create()) {\n      return I.projectId !== void 0 && F.uint32(10).string(I.projectId), I.collectionId !== void 0 && F.uint32(18).string(I.collectionId), I.type !== void 0 && F.uint32(24).int32(M(I.type)), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = Pe();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.projectId = z.string();\n            break;\n          case 2:\n            fe.collectionId = z.string();\n            break;\n          case 3:\n            fe.type = k(z.int32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        projectId: Ce(I.projectId) ? String(I.projectId) : void 0,\n        collectionId: Ce(I.collectionId) ? String(I.collectionId) : void 0,\n        type: Ce(I.type) ? k(I.type) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.projectId !== void 0 && (F.projectId = I.projectId), I.collectionId !== void 0 && (F.collectionId = I.collectionId), I.type !== void 0 && (F.type = I.type !== void 0 ? L(I.type) : void 0), F;\n    },\n    fromPartial(I) {\n      var F, z, Te;\n      const fe = Pe();\n      return fe.projectId = (F = I.projectId) !== null && F !== void 0 ? F : void 0, fe.collectionId = (z = I.collectionId) !== null && z !== void 0 ? z : void 0, fe.type = (Te = I.type) !== null && Te !== void 0 ? Te : void 0, fe;\n    }\n  };\n  function C() {\n    return { layouts: [] };\n  }\n  a.ListLayoutsResponse = {\n    encode(I, F = g.Writer.create()) {\n      for (const z of I.layouts)\n        a.Layout.encode(z, F.uint32(10).fork()).ldelim();\n      return F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = C();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.layouts.push(a.Layout.decode(z, z.uint32()));\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        layouts: Array.isArray(I == null ? void 0 : I.layouts) ? I.layouts.map((F) => a.Layout.fromJSON(F)) : []\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.layouts ? F.layouts = I.layouts.map((z) => z ? a.Layout.toJSON(z) : void 0) : F.layouts = [], F;\n    },\n    fromPartial(I) {\n      var F;\n      const z = C();\n      return z.layouts = ((F = I.layouts) === null || F === void 0 ? void 0 : F.map((Te) => a.Layout.fromPartial(Te))) || [], z;\n    }\n  };\n  function x() {\n    return { layout: void 0 };\n  }\n  a.CreateLayoutRequest = {\n    encode(I, F = g.Writer.create()) {\n      return I.layout !== void 0 && a.PartialLayout.encode(I.layout, F.uint32(18).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = x();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 2:\n            fe.layout = a.PartialLayout.decode(z, z.uint32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        layout: Ce(I.layout) ? a.PartialLayout.fromJSON(I.layout) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.layout !== void 0 && (F.layout = I.layout ? a.PartialLayout.toJSON(I.layout) : void 0), F;\n    },\n    fromPartial(I) {\n      const F = x();\n      return F.layout = I.layout !== void 0 && I.layout !== null ? a.PartialLayout.fromPartial(I.layout) : void 0, F;\n    }\n  };\n  function Q() {\n    return { layoutId: \"\" };\n  }\n  a.GetLayoutRequest = {\n    encode(I, F = g.Writer.create()) {\n      return I.layoutId !== \"\" && F.uint32(10).string(I.layoutId), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = Q();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.layoutId = z.string();\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        layoutId: Ce(I.layoutId) ? String(I.layoutId) : \"\"\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), F;\n    },\n    fromPartial(I) {\n      var F;\n      const z = Q();\n      return z.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : \"\", z;\n    }\n  };\n  function Se() {\n    return { layoutId: \"\", layout: void 0 };\n  }\n  a.UpdateLayoutRequest = {\n    encode(I, F = g.Writer.create()) {\n      return I.layoutId !== \"\" && F.uint32(10).string(I.layoutId), I.layout !== void 0 && a.PartialLayout.encode(I.layout, F.uint32(26).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = Se();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.layoutId = z.string();\n            break;\n          case 3:\n            fe.layout = a.PartialLayout.decode(z, z.uint32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        layoutId: Ce(I.layoutId) ? String(I.layoutId) : \"\",\n        layout: Ce(I.layout) ? a.PartialLayout.fromJSON(I.layout) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.layout !== void 0 && (F.layout = I.layout ? a.PartialLayout.toJSON(I.layout) : void 0), F;\n    },\n    fromPartial(I) {\n      var F;\n      const z = Se();\n      return z.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : \"\", z.layout = I.layout !== void 0 && I.layout !== null ? a.PartialLayout.fromPartial(I.layout) : void 0, z;\n    }\n  };\n  function me() {\n    return { requestMetadata: void 0 };\n  }\n  a.DeleteLayoutPayload = {\n    encode(I, F = g.Writer.create()) {\n      return I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = me();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 100:\n            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), F;\n    },\n    fromPartial(I) {\n      var F;\n      const z = me();\n      return z.requestMetadata = (F = I.requestMetadata) !== null && F !== void 0 ? F : void 0, z;\n    }\n  };\n  function Ie() {\n    return { layoutId: \"\", payload: void 0 };\n  }\n  a.DeleteLayoutRequest = {\n    encode(I, F = g.Writer.create()) {\n      return I.layoutId !== \"\" && F.uint32(10).string(I.layoutId), I.payload !== void 0 && a.DeleteLayoutPayload.encode(I.payload, F.uint32(18).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = Ie();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.layoutId = z.string();\n            break;\n          case 2:\n            fe.payload = a.DeleteLayoutPayload.decode(z, z.uint32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        layoutId: Ce(I.layoutId) ? String(I.layoutId) : \"\",\n        payload: Ce(I.payload) ? a.DeleteLayoutPayload.fromJSON(I.payload) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.payload !== void 0 && (F.payload = I.payload ? a.DeleteLayoutPayload.toJSON(I.payload) : void 0), F;\n    },\n    fromPartial(I) {\n      var F;\n      const z = Ie();\n      return z.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : \"\", z.payload = I.payload !== void 0 && I.payload !== null ? a.DeleteLayoutPayload.fromPartial(I.payload) : void 0, z;\n    }\n  };\n  function at() {\n    return { id: \"\", requestMetadata: void 0 };\n  }\n  a.DeleteLayoutResponse = {\n    encode(I, F = g.Writer.create()) {\n      return I.id !== \"\" && F.uint32(18).string(I.id), I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = at();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 2:\n            fe.id = z.string();\n            break;\n          case 100:\n            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        id: Ce(I.id) ? String(I.id) : \"\",\n        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.id !== void 0 && (F.id = I.id), I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), F;\n    },\n    fromPartial(I) {\n      var F, z;\n      const Te = at();\n      return Te.id = (F = I.id) !== null && F !== void 0 ? F : \"\", Te.requestMetadata = (z = I.requestMetadata) !== null && z !== void 0 ? z : void 0, Te;\n    }\n  };\n  function Ye() {\n    return {\n      properties: [],\n      durationMs: 0,\n      delayMs: void 0,\n      easingMode: void 0\n    };\n  }\n  a.LayerAnimation = {\n    encode(I, F = g.Writer.create()) {\n      for (const z of I.properties)\n        F.uint32(10).string(z);\n      return I.durationMs !== 0 && F.uint32(16).int32(I.durationMs), I.delayMs !== void 0 && F.uint32(32).int32(I.delayMs), I.easingMode !== void 0 && F.uint32(42).string(I.easingMode), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = Ye();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.properties.push(z.string());\n            break;\n          case 2:\n            fe.durationMs = z.int32();\n            break;\n          case 4:\n            fe.delayMs = z.int32();\n            break;\n          case 5:\n            fe.easingMode = z.string();\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        properties: Array.isArray(I == null ? void 0 : I.properties) ? I.properties.map((F) => String(F)) : [],\n        durationMs: Ce(I.durationMs) ? Number(I.durationMs) : 0,\n        delayMs: Ce(I.delayMs) ? Number(I.delayMs) : void 0,\n        easingMode: Ce(I.easingMode) ? String(I.easingMode) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.properties ? F.properties = I.properties.map((z) => z) : F.properties = [], I.durationMs !== void 0 && (F.durationMs = Math.round(I.durationMs)), I.delayMs !== void 0 && (F.delayMs = Math.round(I.delayMs)), I.easingMode !== void 0 && (F.easingMode = I.easingMode), F;\n    },\n    fromPartial(I) {\n      var F, z, Te, fe;\n      const ke = Ye();\n      return ke.properties = ((F = I.properties) === null || F === void 0 ? void 0 : F.map((it) => it)) || [], ke.durationMs = (z = I.durationMs) !== null && z !== void 0 ? z : 0, ke.delayMs = (Te = I.delayMs) !== null && Te !== void 0 ? Te : void 0, ke.easingMode = (fe = I.easingMode) !== null && fe !== void 0 ? fe : void 0, ke;\n    }\n  };\n  function je() {\n    return {\n      type: void 0,\n      data: void 0,\n      x: void 0,\n      y: void 0,\n      width: void 0,\n      height: void 0,\n      rotation: void 0,\n      opacity: void 0,\n      scale: void 0,\n      hidden: void 0,\n      children: void 0,\n      parentId: void 0,\n      metadata: void 0,\n      requestMetadata: void 0,\n      requestAnimation: []\n    };\n  }\n  a.PartialLayer = {\n    encode(I, F = g.Writer.create()) {\n      I.type !== void 0 && F.uint32(10).string(I.type), I.data !== void 0 && E.Struct.encode(E.Struct.wrap(I.data), F.uint32(18).fork()).ldelim(), I.x !== void 0 && E.Value.encode(E.Value.wrap(I.x), F.uint32(26).fork()).ldelim(), I.y !== void 0 && E.Value.encode(E.Value.wrap(I.y), F.uint32(34).fork()).ldelim(), I.width !== void 0 && E.Value.encode(E.Value.wrap(I.width), F.uint32(42).fork()).ldelim(), I.height !== void 0 && E.Value.encode(E.Value.wrap(I.height), F.uint32(50).fork()).ldelim(), I.rotation !== void 0 && F.uint32(57).double(I.rotation), I.opacity !== void 0 && F.uint32(65).double(I.opacity), I.scale !== void 0 && F.uint32(73).double(I.scale), I.hidden !== void 0 && F.uint32(80).bool(I.hidden), I.children !== void 0 && E.ListValue.encode(E.ListValue.wrap(I.children), F.uint32(98).fork()).ldelim(), I.parentId !== void 0 && F.uint32(106).string(I.parentId), I.metadata !== void 0 && E.Value.encode(E.Value.wrap(I.metadata), F.uint32(114).fork()).ldelim(), I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim();\n      for (const z of I.requestAnimation)\n        a.LayerAnimation.encode(z, F.uint32(826).fork()).ldelim();\n      return F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = je();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.type = z.string();\n            break;\n          case 2:\n            fe.data = E.Struct.unwrap(E.Struct.decode(z, z.uint32()));\n            break;\n          case 3:\n            fe.x = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 4:\n            fe.y = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 5:\n            fe.width = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 6:\n            fe.height = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 7:\n            fe.rotation = z.double();\n            break;\n          case 8:\n            fe.opacity = z.double();\n            break;\n          case 9:\n            fe.scale = z.double();\n            break;\n          case 10:\n            fe.hidden = z.bool();\n            break;\n          case 12:\n            fe.children = E.ListValue.unwrap(E.ListValue.decode(z, z.uint32()));\n            break;\n          case 13:\n            fe.parentId = z.string();\n            break;\n          case 14:\n            fe.metadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 100:\n            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 103:\n            fe.requestAnimation.push(a.LayerAnimation.decode(z, z.uint32()));\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        type: Ce(I.type) ? String(I.type) : void 0,\n        data: ft(I.data) ? I.data : void 0,\n        x: Ce(I == null ? void 0 : I.x) ? I.x : void 0,\n        y: Ce(I == null ? void 0 : I.y) ? I.y : void 0,\n        width: Ce(I == null ? void 0 : I.width) ? I.width : void 0,\n        height: Ce(I == null ? void 0 : I.height) ? I.height : void 0,\n        rotation: Ce(I.rotation) ? Number(I.rotation) : void 0,\n        opacity: Ce(I.opacity) ? Number(I.opacity) : void 0,\n        scale: Ce(I.scale) ? Number(I.scale) : void 0,\n        hidden: Ce(I.hidden) ? !!I.hidden : void 0,\n        children: Array.isArray(I.children) ? [...I.children] : void 0,\n        parentId: Ce(I.parentId) ? String(I.parentId) : void 0,\n        metadata: Ce(I == null ? void 0 : I.metadata) ? I.metadata : void 0,\n        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0,\n        requestAnimation: Array.isArray(I == null ? void 0 : I.requestAnimation) ? I.requestAnimation.map((F) => a.LayerAnimation.fromJSON(F)) : []\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.type !== void 0 && (F.type = I.type), I.data !== void 0 && (F.data = I.data), I.x !== void 0 && (F.x = I.x), I.y !== void 0 && (F.y = I.y), I.width !== void 0 && (F.width = I.width), I.height !== void 0 && (F.height = I.height), I.rotation !== void 0 && (F.rotation = I.rotation), I.opacity !== void 0 && (F.opacity = I.opacity), I.scale !== void 0 && (F.scale = I.scale), I.hidden !== void 0 && (F.hidden = I.hidden), I.children !== void 0 && (F.children = I.children), I.parentId !== void 0 && (F.parentId = I.parentId), I.metadata !== void 0 && (F.metadata = I.metadata), I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), I.requestAnimation ? F.requestAnimation = I.requestAnimation.map((z) => z ? a.LayerAnimation.toJSON(z) : void 0) : F.requestAnimation = [], F;\n    },\n    fromPartial(I) {\n      var F, z, Te, fe, ke, it, mt, vt, st, ut, yt, gt, bt, St, Et;\n      const ct = je();\n      return ct.type = (F = I.type) !== null && F !== void 0 ? F : void 0, ct.data = (z = I.data) !== null && z !== void 0 ? z : void 0, ct.x = (Te = I.x) !== null && Te !== void 0 ? Te : void 0, ct.y = (fe = I.y) !== null && fe !== void 0 ? fe : void 0, ct.width = (ke = I.width) !== null && ke !== void 0 ? ke : void 0, ct.height = (it = I.height) !== null && it !== void 0 ? it : void 0, ct.rotation = (mt = I.rotation) !== null && mt !== void 0 ? mt : void 0, ct.opacity = (vt = I.opacity) !== null && vt !== void 0 ? vt : void 0, ct.scale = (st = I.scale) !== null && st !== void 0 ? st : void 0, ct.hidden = (ut = I.hidden) !== null && ut !== void 0 ? ut : void 0, ct.children = (yt = I.children) !== null && yt !== void 0 ? yt : void 0, ct.parentId = (gt = I.parentId) !== null && gt !== void 0 ? gt : void 0, ct.metadata = (bt = I.metadata) !== null && bt !== void 0 ? bt : void 0, ct.requestMetadata = (St = I.requestMetadata) !== null && St !== void 0 ? St : void 0, ct.requestAnimation = ((Et = I.requestAnimation) === null || Et === void 0 ? void 0 : Et.map((Xe) => a.LayerAnimation.fromPartial(Xe))) || [], ct;\n    }\n  };\n  function tt() {\n    return {\n      id: \"\",\n      type: void 0,\n      data: void 0,\n      x: void 0,\n      y: void 0,\n      width: void 0,\n      height: void 0,\n      rotation: void 0,\n      opacity: void 0,\n      scale: void 0,\n      hidden: void 0,\n      children: void 0,\n      parentId: void 0,\n      metadata: void 0,\n      requestMetadata: void 0,\n      requestAnimation: []\n    };\n  }\n  a.PartialLayerWithID = {\n    encode(I, F = g.Writer.create()) {\n      I.id !== \"\" && F.uint32(8002).string(I.id), I.type !== void 0 && F.uint32(10).string(I.type), I.data !== void 0 && E.Struct.encode(E.Struct.wrap(I.data), F.uint32(18).fork()).ldelim(), I.x !== void 0 && E.Value.encode(E.Value.wrap(I.x), F.uint32(26).fork()).ldelim(), I.y !== void 0 && E.Value.encode(E.Value.wrap(I.y), F.uint32(34).fork()).ldelim(), I.width !== void 0 && E.Value.encode(E.Value.wrap(I.width), F.uint32(42).fork()).ldelim(), I.height !== void 0 && E.Value.encode(E.Value.wrap(I.height), F.uint32(50).fork()).ldelim(), I.rotation !== void 0 && F.uint32(57).double(I.rotation), I.opacity !== void 0 && F.uint32(65).double(I.opacity), I.scale !== void 0 && F.uint32(73).double(I.scale), I.hidden !== void 0 && F.uint32(80).bool(I.hidden), I.children !== void 0 && E.ListValue.encode(E.ListValue.wrap(I.children), F.uint32(98).fork()).ldelim(), I.parentId !== void 0 && F.uint32(106).string(I.parentId), I.metadata !== void 0 && E.Value.encode(E.Value.wrap(I.metadata), F.uint32(114).fork()).ldelim(), I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim();\n      for (const z of I.requestAnimation)\n        a.LayerAnimation.encode(z, F.uint32(826).fork()).ldelim();\n      return F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = tt();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1e3:\n            fe.id = z.string();\n            break;\n          case 1:\n            fe.type = z.string();\n            break;\n          case 2:\n            fe.data = E.Struct.unwrap(E.Struct.decode(z, z.uint32()));\n            break;\n          case 3:\n            fe.x = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 4:\n            fe.y = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 5:\n            fe.width = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 6:\n            fe.height = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 7:\n            fe.rotation = z.double();\n            break;\n          case 8:\n            fe.opacity = z.double();\n            break;\n          case 9:\n            fe.scale = z.double();\n            break;\n          case 10:\n            fe.hidden = z.bool();\n            break;\n          case 12:\n            fe.children = E.ListValue.unwrap(E.ListValue.decode(z, z.uint32()));\n            break;\n          case 13:\n            fe.parentId = z.string();\n            break;\n          case 14:\n            fe.metadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 100:\n            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 103:\n            fe.requestAnimation.push(a.LayerAnimation.decode(z, z.uint32()));\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        id: Ce(I.id) ? String(I.id) : \"\",\n        type: Ce(I.type) ? String(I.type) : void 0,\n        data: ft(I.data) ? I.data : void 0,\n        x: Ce(I == null ? void 0 : I.x) ? I.x : void 0,\n        y: Ce(I == null ? void 0 : I.y) ? I.y : void 0,\n        width: Ce(I == null ? void 0 : I.width) ? I.width : void 0,\n        height: Ce(I == null ? void 0 : I.height) ? I.height : void 0,\n        rotation: Ce(I.rotation) ? Number(I.rotation) : void 0,\n        opacity: Ce(I.opacity) ? Number(I.opacity) : void 0,\n        scale: Ce(I.scale) ? Number(I.scale) : void 0,\n        hidden: Ce(I.hidden) ? !!I.hidden : void 0,\n        children: Array.isArray(I.children) ? [...I.children] : void 0,\n        parentId: Ce(I.parentId) ? String(I.parentId) : void 0,\n        metadata: Ce(I == null ? void 0 : I.metadata) ? I.metadata : void 0,\n        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0,\n        requestAnimation: Array.isArray(I == null ? void 0 : I.requestAnimation) ? I.requestAnimation.map((F) => a.LayerAnimation.fromJSON(F)) : []\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.id !== void 0 && (F.id = I.id), I.type !== void 0 && (F.type = I.type), I.data !== void 0 && (F.data = I.data), I.x !== void 0 && (F.x = I.x), I.y !== void 0 && (F.y = I.y), I.width !== void 0 && (F.width = I.width), I.height !== void 0 && (F.height = I.height), I.rotation !== void 0 && (F.rotation = I.rotation), I.opacity !== void 0 && (F.opacity = I.opacity), I.scale !== void 0 && (F.scale = I.scale), I.hidden !== void 0 && (F.hidden = I.hidden), I.children !== void 0 && (F.children = I.children), I.parentId !== void 0 && (F.parentId = I.parentId), I.metadata !== void 0 && (F.metadata = I.metadata), I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), I.requestAnimation ? F.requestAnimation = I.requestAnimation.map((z) => z ? a.LayerAnimation.toJSON(z) : void 0) : F.requestAnimation = [], F;\n    },\n    fromPartial(I) {\n      var F, z, Te, fe, ke, it, mt, vt, st, ut, yt, gt, bt, St, Et, ct;\n      const Xe = tt();\n      return Xe.id = (F = I.id) !== null && F !== void 0 ? F : \"\", Xe.type = (z = I.type) !== null && z !== void 0 ? z : void 0, Xe.data = (Te = I.data) !== null && Te !== void 0 ? Te : void 0, Xe.x = (fe = I.x) !== null && fe !== void 0 ? fe : void 0, Xe.y = (ke = I.y) !== null && ke !== void 0 ? ke : void 0, Xe.width = (it = I.width) !== null && it !== void 0 ? it : void 0, Xe.height = (mt = I.height) !== null && mt !== void 0 ? mt : void 0, Xe.rotation = (vt = I.rotation) !== null && vt !== void 0 ? vt : void 0, Xe.opacity = (st = I.opacity) !== null && st !== void 0 ? st : void 0, Xe.scale = (ut = I.scale) !== null && ut !== void 0 ? ut : void 0, Xe.hidden = (yt = I.hidden) !== null && yt !== void 0 ? yt : void 0, Xe.children = (gt = I.children) !== null && gt !== void 0 ? gt : void 0, Xe.parentId = (bt = I.parentId) !== null && bt !== void 0 ? bt : void 0, Xe.metadata = (St = I.metadata) !== null && St !== void 0 ? St : void 0, Xe.requestMetadata = (Et = I.requestMetadata) !== null && Et !== void 0 ? Et : void 0, Xe.requestAnimation = ((ct = I.requestAnimation) === null || ct === void 0 ? void 0 : ct.map((Ct) => a.LayerAnimation.fromPartial(Ct))) || [], Xe;\n    }\n  };\n  function Oe() {\n    return { layoutId: \"\" };\n  }\n  a.ListLayersRequest = {\n    encode(I, F = g.Writer.create()) {\n      return I.layoutId !== \"\" && F.uint32(10).string(I.layoutId), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = Oe();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.layoutId = z.string();\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        layoutId: Ce(I.layoutId) ? String(I.layoutId) : \"\"\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), F;\n    },\n    fromPartial(I) {\n      var F;\n      const z = Oe();\n      return z.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : \"\", z;\n    }\n  };\n  function P() {\n    return { layers: [] };\n  }\n  a.ListLayersResponse = {\n    encode(I, F = g.Writer.create()) {\n      for (const z of I.layers)\n        a.Layer.encode(z, F.uint32(10).fork()).ldelim();\n      return F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = P();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.layers.push(a.Layer.decode(z, z.uint32()));\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        layers: Array.isArray(I == null ? void 0 : I.layers) ? I.layers.map((F) => a.Layer.fromJSON(F)) : []\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.layers ? F.layers = I.layers.map((z) => z ? a.Layer.toJSON(z) : void 0) : F.layers = [], F;\n    },\n    fromPartial(I) {\n      var F;\n      const z = P();\n      return z.layers = ((F = I.layers) === null || F === void 0 ? void 0 : F.map((Te) => a.Layer.fromPartial(Te))) || [], z;\n    }\n  };\n  function X() {\n    return { layoutId: \"\", layer: void 0 };\n  }\n  a.CreateLayerRequest = {\n    encode(I, F = g.Writer.create()) {\n      return I.layoutId !== \"\" && F.uint32(10).string(I.layoutId), I.layer !== void 0 && a.PartialLayer.encode(I.layer, F.uint32(18).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = X();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.layoutId = z.string();\n            break;\n          case 2:\n            fe.layer = a.PartialLayer.decode(z, z.uint32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        layoutId: Ce(I.layoutId) ? String(I.layoutId) : \"\",\n        layer: Ce(I.layer) ? a.PartialLayer.fromJSON(I.layer) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.layer !== void 0 && (F.layer = I.layer ? a.PartialLayer.toJSON(I.layer) : void 0), F;\n    },\n    fromPartial(I) {\n      var F;\n      const z = X();\n      return z.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : \"\", z.layer = I.layer !== void 0 && I.layer !== null ? a.PartialLayer.fromPartial(I.layer) : void 0, z;\n    }\n  };\n  function ie() {\n    return { layoutId: \"\", layerId: \"\" };\n  }\n  a.GetLayerRequest = {\n    encode(I, F = g.Writer.create()) {\n      return I.layoutId !== \"\" && F.uint32(10).string(I.layoutId), I.layerId !== \"\" && F.uint32(18).string(I.layerId), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = ie();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.layoutId = z.string();\n            break;\n          case 2:\n            fe.layerId = z.string();\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        layoutId: Ce(I.layoutId) ? String(I.layoutId) : \"\",\n        layerId: Ce(I.layerId) ? String(I.layerId) : \"\"\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.layerId !== void 0 && (F.layerId = I.layerId), F;\n    },\n    fromPartial(I) {\n      var F, z;\n      const Te = ie();\n      return Te.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : \"\", Te.layerId = (z = I.layerId) !== null && z !== void 0 ? z : \"\", Te;\n    }\n  };\n  function Ee() {\n    return { layoutId: \"\", layerId: \"\", layer: void 0 };\n  }\n  a.UpdateLayerRequest = {\n    encode(I, F = g.Writer.create()) {\n      return I.layoutId !== \"\" && F.uint32(10).string(I.layoutId), I.layerId !== \"\" && F.uint32(18).string(I.layerId), I.layer !== void 0 && a.PartialLayer.encode(I.layer, F.uint32(26).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = Ee();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.layoutId = z.string();\n            break;\n          case 2:\n            fe.layerId = z.string();\n            break;\n          case 3:\n            fe.layer = a.PartialLayer.decode(z, z.uint32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        layoutId: Ce(I.layoutId) ? String(I.layoutId) : \"\",\n        layerId: Ce(I.layerId) ? String(I.layerId) : \"\",\n        layer: Ce(I.layer) ? a.PartialLayer.fromJSON(I.layer) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.layerId !== void 0 && (F.layerId = I.layerId), I.layer !== void 0 && (F.layer = I.layer ? a.PartialLayer.toJSON(I.layer) : void 0), F;\n    },\n    fromPartial(I) {\n      var F, z;\n      const Te = Ee();\n      return Te.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : \"\", Te.layerId = (z = I.layerId) !== null && z !== void 0 ? z : \"\", Te.layer = I.layer !== void 0 && I.layer !== null ? a.PartialLayer.fromPartial(I.layer) : void 0, Te;\n    }\n  };\n  function ue() {\n    return { requestMetadata: void 0 };\n  }\n  a.DeleteLayerPayload = {\n    encode(I, F = g.Writer.create()) {\n      return I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = ue();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 100:\n            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), F;\n    },\n    fromPartial(I) {\n      var F;\n      const z = ue();\n      return z.requestMetadata = (F = I.requestMetadata) !== null && F !== void 0 ? F : void 0, z;\n    }\n  };\n  function O() {\n    return { id: \"\", requestMetadata: void 0 };\n  }\n  a.BatchDeleteLayerRequest = {\n    encode(I, F = g.Writer.create()) {\n      return I.id !== \"\" && F.uint32(10).string(I.id), I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = O();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.id = z.string();\n            break;\n          case 100:\n            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        id: Ce(I.id) ? String(I.id) : \"\",\n        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.id !== void 0 && (F.id = I.id), I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), F;\n    },\n    fromPartial(I) {\n      var F, z;\n      const Te = O();\n      return Te.id = (F = I.id) !== null && F !== void 0 ? F : \"\", Te.requestMetadata = (z = I.requestMetadata) !== null && z !== void 0 ? z : void 0, Te;\n    }\n  };\n  function j() {\n    return {\n      layoutId: \"\",\n      layers: [],\n      requestMetadata: void 0,\n      requestAnimationMode: void 0\n    };\n  }\n  a.BatchLayerRequest = {\n    encode(I, F = g.Writer.create()) {\n      I.layoutId !== \"\" && F.uint32(10).string(I.layoutId);\n      for (const z of I.layers)\n        a.BatchLayerRequest_BatchItem.encode(z, F.uint32(18).fork()).ldelim();\n      return I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim(), I.requestAnimationMode !== void 0 && F.uint32(808).int32(q(I.requestAnimationMode)), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = j();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.layoutId = z.string();\n            break;\n          case 2:\n            fe.layers.push(a.BatchLayerRequest_BatchItem.decode(z, z.uint32()));\n            break;\n          case 100:\n            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));\n            break;\n          case 101:\n            fe.requestAnimationMode = J(z.int32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        layoutId: Ce(I.layoutId) ? String(I.layoutId) : \"\",\n        layers: Array.isArray(I == null ? void 0 : I.layers) ? I.layers.map((F) => a.BatchLayerRequest_BatchItem.fromJSON(F)) : [],\n        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0,\n        requestAnimationMode: Ce(I.requestAnimationMode) ? J(I.requestAnimationMode) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.layers ? F.layers = I.layers.map((z) => z ? a.BatchLayerRequest_BatchItem.toJSON(z) : void 0) : F.layers = [], I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), I.requestAnimationMode !== void 0 && (F.requestAnimationMode = I.requestAnimationMode !== void 0 ? V(I.requestAnimationMode) : void 0), F;\n    },\n    fromPartial(I) {\n      var F, z, Te, fe;\n      const ke = j();\n      return ke.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : \"\", ke.layers = ((z = I.layers) === null || z === void 0 ? void 0 : z.map((it) => a.BatchLayerRequest_BatchItem.fromPartial(it))) || [], ke.requestMetadata = (Te = I.requestMetadata) !== null && Te !== void 0 ? Te : void 0, ke.requestAnimationMode = (fe = I.requestAnimationMode) !== null && fe !== void 0 ? fe : void 0, ke;\n    }\n  };\n  function se() {\n    return { create: void 0, update: void 0, delete: void 0 };\n  }\n  a.BatchLayerRequest_BatchItem = {\n    encode(I, F = g.Writer.create()) {\n      return I.create !== void 0 && a.PartialLayer.encode(I.create, F.uint32(10).fork()).ldelim(), I.update !== void 0 && a.PartialLayerWithID.encode(I.update, F.uint32(18).fork()).ldelim(), I.delete !== void 0 && a.BatchDeleteLayerRequest.encode(I.delete, F.uint32(26).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = se();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.create = a.PartialLayer.decode(z, z.uint32());\n            break;\n          case 2:\n            fe.update = a.PartialLayerWithID.decode(z, z.uint32());\n            break;\n          case 3:\n            fe.delete = a.BatchDeleteLayerRequest.decode(z, z.uint32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        create: Ce(I.create) ? a.PartialLayer.fromJSON(I.create) : void 0,\n        update: Ce(I.update) ? a.PartialLayerWithID.fromJSON(I.update) : void 0,\n        delete: Ce(I.delete) ? a.BatchDeleteLayerRequest.fromJSON(I.delete) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.create !== void 0 && (F.create = I.create ? a.PartialLayer.toJSON(I.create) : void 0), I.update !== void 0 && (F.update = I.update ? a.PartialLayerWithID.toJSON(I.update) : void 0), I.delete !== void 0 && (F.delete = I.delete ? a.BatchDeleteLayerRequest.toJSON(I.delete) : void 0), F;\n    },\n    fromPartial(I) {\n      const F = se();\n      return F.create = I.create !== void 0 && I.create !== null ? a.PartialLayer.fromPartial(I.create) : void 0, F.update = I.update !== void 0 && I.update !== null ? a.PartialLayerWithID.fromPartial(I.update) : void 0, F.delete = I.delete !== void 0 && I.delete !== null ? a.BatchDeleteLayerRequest.fromPartial(I.delete) : void 0, F;\n    }\n  };\n  function _e() {\n    return { create: void 0, update: void 0, delete: void 0 };\n  }\n  a.LayoutEvent = {\n    encode(I, F = g.Writer.create()) {\n      return I.create !== void 0 && a.Layout.encode(I.create, F.uint32(10).fork()).ldelim(), I.update !== void 0 && a.Layout.encode(I.update, F.uint32(18).fork()).ldelim(), I.delete !== void 0 && a.DeleteLayoutResponse.encode(I.delete, F.uint32(26).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = _e();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.create = a.Layout.decode(z, z.uint32());\n            break;\n          case 2:\n            fe.update = a.Layout.decode(z, z.uint32());\n            break;\n          case 3:\n            fe.delete = a.DeleteLayoutResponse.decode(z, z.uint32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        create: Ce(I.create) ? a.Layout.fromJSON(I.create) : void 0,\n        update: Ce(I.update) ? a.Layout.fromJSON(I.update) : void 0,\n        delete: Ce(I.delete) ? a.DeleteLayoutResponse.fromJSON(I.delete) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.create !== void 0 && (F.create = I.create ? a.Layout.toJSON(I.create) : void 0), I.update !== void 0 && (F.update = I.update ? a.Layout.toJSON(I.update) : void 0), I.delete !== void 0 && (F.delete = I.delete ? a.DeleteLayoutResponse.toJSON(I.delete) : void 0), F;\n    },\n    fromPartial(I) {\n      const F = _e();\n      return F.create = I.create !== void 0 && I.create !== null ? a.Layout.fromPartial(I.create) : void 0, F.update = I.update !== void 0 && I.update !== null ? a.Layout.fromPartial(I.update) : void 0, F.delete = I.delete !== void 0 && I.delete !== null ? a.DeleteLayoutResponse.fromPartial(I.delete) : void 0, F;\n    }\n  };\n  function ve() {\n    return {\n      create: void 0,\n      update: void 0,\n      delete: void 0,\n      batch: void 0\n    };\n  }\n  a.LayerEvent = {\n    encode(I, F = g.Writer.create()) {\n      return I.create !== void 0 && a.Layer.encode(I.create, F.uint32(10).fork()).ldelim(), I.update !== void 0 && a.Layer.encode(I.update, F.uint32(18).fork()).ldelim(), I.delete !== void 0 && a.DeleteLayerResponse.encode(I.delete, F.uint32(26).fork()).ldelim(), I.batch !== void 0 && a.BatchLayerResponse.encode(I.batch, F.uint32(34).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = ve();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.create = a.Layer.decode(z, z.uint32());\n            break;\n          case 2:\n            fe.update = a.Layer.decode(z, z.uint32());\n            break;\n          case 3:\n            fe.delete = a.DeleteLayerResponse.decode(z, z.uint32());\n            break;\n          case 4:\n            fe.batch = a.BatchLayerResponse.decode(z, z.uint32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        create: Ce(I.create) ? a.Layer.fromJSON(I.create) : void 0,\n        update: Ce(I.update) ? a.Layer.fromJSON(I.update) : void 0,\n        delete: Ce(I.delete) ? a.DeleteLayerResponse.fromJSON(I.delete) : void 0,\n        batch: Ce(I.batch) ? a.BatchLayerResponse.fromJSON(I.batch) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.create !== void 0 && (F.create = I.create ? a.Layer.toJSON(I.create) : void 0), I.update !== void 0 && (F.update = I.update ? a.Layer.toJSON(I.update) : void 0), I.delete !== void 0 && (F.delete = I.delete ? a.DeleteLayerResponse.toJSON(I.delete) : void 0), I.batch !== void 0 && (F.batch = I.batch ? a.BatchLayerResponse.toJSON(I.batch) : void 0), F;\n    },\n    fromPartial(I) {\n      const F = ve();\n      return F.create = I.create !== void 0 && I.create !== null ? a.Layer.fromPartial(I.create) : void 0, F.update = I.update !== void 0 && I.update !== null ? a.Layer.fromPartial(I.update) : void 0, F.delete = I.delete !== void 0 && I.delete !== null ? a.DeleteLayerResponse.fromPartial(I.delete) : void 0, F.batch = I.batch !== void 0 && I.batch !== null ? a.BatchLayerResponse.fromPartial(I.batch) : void 0, F;\n    }\n  };\n  function De() {\n    return { layout: void 0, layer: void 0 };\n  }\n  a.Event = {\n    encode(I, F = g.Writer.create()) {\n      return I.layout !== void 0 && a.LayoutEvent.encode(I.layout, F.uint32(10).fork()).ldelim(), I.layer !== void 0 && a.LayerEvent.encode(I.layer, F.uint32(18).fork()).ldelim(), F;\n    },\n    decode(I, F) {\n      const z = I instanceof g.Reader ? I : new g.Reader(I);\n      let Te = F === void 0 ? z.len : z.pos + F;\n      const fe = De();\n      for (; z.pos < Te; ) {\n        const ke = z.uint32();\n        switch (ke >>> 3) {\n          case 1:\n            fe.layout = a.LayoutEvent.decode(z, z.uint32());\n            break;\n          case 2:\n            fe.layer = a.LayerEvent.decode(z, z.uint32());\n            break;\n          default:\n            z.skipType(ke & 7);\n            break;\n        }\n      }\n      return fe;\n    },\n    fromJSON(I) {\n      return {\n        layout: Ce(I.layout) ? a.LayoutEvent.fromJSON(I.layout) : void 0,\n        layer: Ce(I.layer) ? a.LayerEvent.fromJSON(I.layer) : void 0\n      };\n    },\n    toJSON(I) {\n      const F = {};\n      return I.layout !== void 0 && (F.layout = I.layout ? a.LayoutEvent.toJSON(I.layout) : void 0), I.layer !== void 0 && (F.layer = I.layer ? a.LayerEvent.toJSON(I.layer) : void 0), F;\n    },\n    fromPartial(I) {\n      const F = De();\n      return F.layout = I.layout !== void 0 && I.layout !== null ? a.LayoutEvent.fromPartial(I.layout) : void 0, F.layer = I.layer !== void 0 && I.layer !== null ? a.LayerEvent.fromPartial(I.layer) : void 0, F;\n    }\n  };\n  class Ze {\n    constructor(F) {\n      this.rpc = F, this.ListLayers = this.ListLayers.bind(this), this.CreateLayer = this.CreateLayer.bind(this), this.GetLayer = this.GetLayer.bind(this), this.UpdateLayer = this.UpdateLayer.bind(this), this.DeleteLayer = this.DeleteLayer.bind(this), this.Batch = this.Batch.bind(this);\n    }\n    ListLayers(F) {\n      const z = a.ListLayersRequest.encode(F).finish();\n      return this.rpc.request(\"apis.layout.v2.LayerService\", \"ListLayers\", z).then((fe) => a.ListLayersResponse.decode(new g.Reader(fe)));\n    }\n    CreateLayer(F) {\n      const z = a.CreateLayerRequest.encode(F).finish();\n      return this.rpc.request(\"apis.layout.v2.LayerService\", \"CreateLayer\", z).then((fe) => a.Layer.decode(new g.Reader(fe)));\n    }\n    GetLayer(F) {\n      const z = a.GetLayerRequest.encode(F).finish();\n      return this.rpc.request(\"apis.layout.v2.LayerService\", \"GetLayer\", z).then((fe) => a.Layer.decode(new g.Reader(fe)));\n    }\n    UpdateLayer(F) {\n      const z = a.UpdateLayerRequest.encode(F).finish();\n      return this.rpc.request(\"apis.layout.v2.LayerService\", \"UpdateLayer\", z).then((fe) => a.Layer.decode(new g.Reader(fe)));\n    }\n    DeleteLayer(F) {\n      const z = a.DeleteLayerRequest.encode(F).finish();\n      return this.rpc.request(\"apis.layout.v2.LayerService\", \"DeleteLayer\", z).then((fe) => a.DeleteLayerResponse.decode(new g.Reader(fe)));\n    }\n    Batch(F) {\n      const z = a.BatchLayerRequest.encode(F).finish();\n      return this.rpc.request(\"apis.layout.v2.LayerService\", \"Batch\", z).then((fe) => a.BatchLayerResponse.decode(new g.Reader(fe)));\n    }\n  }\n  a.LayerServiceClientImpl = Ze, a.LayerServiceDefinition = {\n    name: \"LayerService\",\n    fullName: \"apis.layout.v2.LayerService\",\n    methods: {\n      /** List all layers */\n      listLayers: {\n        name: \"ListLayers\",\n        requestType: a.ListLayersRequest,\n        requestStream: !1,\n        responseType: a.ListLayersResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Create a layer\n       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME\n       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE\n       */\n      createLayer: {\n        name: \"CreateLayer\",\n        requestType: a.CreateLayerRequest,\n        requestStream: !1,\n        responseType: a.Layer,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Get a single layer\n       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME\n       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE\n       */\n      getLayer: {\n        name: \"GetLayer\",\n        requestType: a.GetLayerRequest,\n        requestStream: !1,\n        responseType: a.Layer,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Update a layer\n       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME\n       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE\n       */\n      updateLayer: {\n        name: \"UpdateLayer\",\n        requestType: a.UpdateLayerRequest,\n        requestStream: !1,\n        responseType: a.Layer,\n        responseStream: !1,\n        options: {}\n      },\n      /** Delete a layer */\n      deleteLayer: {\n        name: \"DeleteLayer\",\n        requestType: a.DeleteLayerRequest,\n        requestStream: !1,\n        responseType: a.DeleteLayerResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Batch update\n       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME\n       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME\n       */\n      batch: {\n        name: \"Batch\",\n        requestType: a.BatchLayerRequest,\n        requestStream: !1,\n        responseType: a.BatchLayerResponse,\n        responseStream: !1,\n        options: {}\n      }\n    }\n  };\n  class Qe {\n    constructor(F) {\n      this.rpc = F, this.ListLayouts = this.ListLayouts.bind(this), this.CreateLayout = this.CreateLayout.bind(this), this.GetLayout = this.GetLayout.bind(this), this.UpdateLayout = this.UpdateLayout.bind(this), this.DeleteLayout = this.DeleteLayout.bind(this);\n    }\n    ListLayouts(F) {\n      const z = a.ListLayoutsRequest.encode(F).finish();\n      return this.rpc.request(\"apis.layout.v2.LayoutService\", \"ListLayouts\", z).then((fe) => a.ListLayoutsResponse.decode(new g.Reader(fe)));\n    }\n    CreateLayout(F) {\n      const z = a.CreateLayoutRequest.encode(F).finish();\n      return this.rpc.request(\"apis.layout.v2.LayoutService\", \"CreateLayout\", z).then((fe) => a.Layout.decode(new g.Reader(fe)));\n    }\n    GetLayout(F) {\n      const z = a.GetLayoutRequest.encode(F).finish();\n      return this.rpc.request(\"apis.layout.v2.LayoutService\", \"GetLayout\", z).then((fe) => a.Layout.decode(new g.Reader(fe)));\n    }\n    UpdateLayout(F) {\n      const z = a.UpdateLayoutRequest.encode(F).finish();\n      return this.rpc.request(\"apis.layout.v2.LayoutService\", \"UpdateLayout\", z).then((fe) => a.Layout.decode(new g.Reader(fe)));\n    }\n    DeleteLayout(F) {\n      const z = a.DeleteLayoutRequest.encode(F).finish();\n      return this.rpc.request(\"apis.layout.v2.LayoutService\", \"DeleteLayout\", z).then((fe) => a.DeleteLayoutResponse.decode(new g.Reader(fe)));\n    }\n  }\n  a.LayoutServiceClientImpl = Qe, a.LayoutServiceDefinition = {\n    name: \"LayoutService\",\n    fullName: \"apis.layout.v2.LayoutService\",\n    methods: {\n      /** Get all layouts owned by the user. */\n      listLayouts: {\n        name: \"ListLayouts\",\n        requestType: a.ListLayoutsRequest,\n        requestStream: !1,\n        responseType: a.ListLayoutsResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Create a new layout\n       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME\n       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE\n       */\n      createLayout: {\n        name: \"CreateLayout\",\n        requestType: a.CreateLayoutRequest,\n        requestStream: !1,\n        responseType: a.Layout,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Get a layout\n       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME\n       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE\n       */\n      getLayout: {\n        name: \"GetLayout\",\n        requestType: a.GetLayoutRequest,\n        requestStream: !1,\n        responseType: a.Layout,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Update a layout\n       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME\n       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE\n       */\n      updateLayout: {\n        name: \"UpdateLayout\",\n        requestType: a.UpdateLayoutRequest,\n        requestStream: !1,\n        responseType: a.Layout,\n        responseStream: !1,\n        options: {}\n      },\n      /** Delete a layout */\n      deleteLayout: {\n        name: \"DeleteLayout\",\n        requestType: a.DeleteLayoutRequest,\n        requestStream: !1,\n        responseType: a.DeleteLayoutResponse,\n        responseStream: !1,\n        options: {}\n      }\n    }\n  };\n  var ot = (() => {\n    if (typeof ot < \"u\")\n      return ot;\n    if (typeof self < \"u\")\n      return self;\n    if (typeof window < \"u\")\n      return window;\n    if (typeof commonjsGlobal$1 < \"u\")\n      return commonjsGlobal$1;\n    throw \"Unable to locate global object\";\n  })();\n  g.util.Long !== S.default && (g.util.Long = S.default, g.configure());\n  function ft(I) {\n    return typeof I == \"object\" && I !== null;\n  }\n  function Ce(I) {\n    return I != null;\n  }\n})(api$3);\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(v, S, g, E) {\n    E === void 0 && (E = g), Object.defineProperty(v, E, { enumerable: !0, get: function() {\n      return S[g];\n    } });\n  } : function(v, S, g, E) {\n    E === void 0 && (E = g), v[E] = S[g];\n  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(v, S) {\n    for (var g in v)\n      g !== \"default\" && !S.hasOwnProperty(g) && u(S, v, g);\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.layoutApiEventMap = void 0;\n  const l = api$3;\n  c(api$3, a), a.layoutApiEventMap = {\n    [l.EventType.EVENT_TYPE_LAYOUT]: \"layout\",\n    [l.EventType.EVENT_TYPE_LAYER]: \"layer\",\n    [l.EventType.EVENT_TYPE_UNSPECIFIED]: \"unspecified\"\n  };\n})(dist$2);\nvar api$2 = {}, browser$2 = !1;\nconst __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: __viteBrowserExternal\n}, Symbol.toStringTag, { value: \"Module\" })), require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);\nvar logger = {};\nclass EnhancedMap extends Map {\n  /**\n   * If key has a mapping already returns the currently associated value. If\n   * there is no mapping, calls the computer which must return a value V.\n   * The value is then stored for given key and returned.\n   * @param key Key\n   * @param computer Computer which is called only if key has no mapping yet.\n   * @return Existing value if the key already existed, or the newly computed value.\n   */\n  computeIfAbsent(u, c) {\n    if (this.has(u))\n      return this.get(u);\n    const l = c(u);\n    return this.set(u, l), l;\n  }\n  /**\n   * If the key exists already calls given computer, if the key does not exist\n   * this method does nothing.\n   *\n   * The computer is called with current key and current value associated. The\n   * computer can return a (new) value V or undefined. When undefined is returned\n   * the key is removed from this map, when a V is returned the key is updated\n   * with the new value V.\n   * @param key Key\n   * @param computer Computer which is called only if the key has a mapping already\n   * @return Undefined if the key has no mapping, otherwise the value returned from computer\n   */\n  computeIfPresent(u, c) {\n    const l = this.get(u);\n    if (l === void 0)\n      return;\n    const v = c(u, l);\n    return v !== void 0 ? this.set(u, v) : this.delete(u), v;\n  }\n  /**\n   * Computes a value for given key, the computer can return a value V (in which case the map\n   * will set the value for given key), if it returns undefined the mapping for key K will be\n   * removed.\n   * @param key Key to compute\n   * @param computer Computer which is called, note that the currentValue argument contains the existing\n   *                 value or is undefined when no mapping exists for the key.\n   * @return The newly computed value\n   */\n  compute(u, c) {\n    const l = this.get(u), v = c(u, l);\n    return v ? this.set(u, v) : this.delete(u), v;\n  }\n}\nvar InternalLogLevel;\n(function(a) {\n  a[a.Trace = 0] = \"Trace\", a[a.Debug = 1] = \"Debug\", a[a.Info = 2] = \"Info\", a[a.Warn = 3] = \"Warn\", a[a.Error = 4] = \"Error\";\n})(InternalLogLevel || (InternalLogLevel = {}));\nfunction getInternalLogger(a) {\n  return provider.getLogger(a);\n}\nconst INTERNAL_LOGGING_SETTINGS = {\n  /**\n   * Changes the log level for the internal logging (for all new and existing loggers)\n   * @param level New log level\n   */\n  setInternalLogLevel: (a) => provider.changeLogLevel(a),\n  /**\n   * Changes where messages are written to for all new and existing loggers),\n   * by default they are written to the console.\n   * @param fnOutput Function to write messages to\n   */\n  setOutput: (a) => provider.changeOutput(a),\n  /**\n   * Resets the log level and output back to defaults (level to error and writing to console)\n   * for all new and existing loggers.\n   */\n  reset: () => provider.reset()\n};\nclass InternalLoggerImpl {\n  constructor(u, c, l) {\n    this._name = u, this._level = c, this._fnOutput = l;\n  }\n  trace(u) {\n    this.log(InternalLogLevel.Trace, u);\n  }\n  debug(u) {\n    this.log(InternalLogLevel.Debug, u);\n  }\n  error(u, c) {\n    this.log(InternalLogLevel.Error, u, c);\n  }\n  info(u) {\n    this.log(InternalLogLevel.Info, u);\n  }\n  warn(u, c) {\n    this.log(InternalLogLevel.Warn, u, c);\n  }\n  setLevel(u) {\n    this._level = u;\n  }\n  setOutput(u) {\n    this._fnOutput = u;\n  }\n  log(u, c, l) {\n    this._level > u || this._fnOutput(`${InternalLogLevel[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${c()}${l ? `\n` + l.stack : \"\"}`);\n  }\n}\nclass InternalProviderImpl {\n  constructor() {\n    this._loggers = new EnhancedMap(), this._logLevel = InternalLogLevel.Error, this._fnOutput = InternalProviderImpl.logConsole;\n  }\n  getLogger(u) {\n    return this._loggers.computeIfAbsent(u, (c) => new InternalLoggerImpl(c, this._logLevel, this._fnOutput));\n  }\n  changeLogLevel(u) {\n    this._logLevel = u, this._loggers.forEach((c) => c.setLevel(u));\n  }\n  changeOutput(u) {\n    this._fnOutput = u, this._loggers.forEach((c) => c.setOutput(this._fnOutput));\n  }\n  reset() {\n    this.changeLogLevel(InternalLogLevel.Error), this._fnOutput = InternalProviderImpl.logConsole, this._loggers.forEach((u) => u.setOutput(this._fnOutput));\n  }\n  static logConsole(u) {\n    console && console.log && console.log(u);\n  }\n}\nconst provider = new InternalProviderImpl();\nvar InternalLogger = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  get InternalLogLevel() {\n    return InternalLogLevel;\n  },\n  getInternalLogger,\n  INTERNAL_LOGGING_SETTINGS\n}), LogLevel$1;\n(function(a) {\n  a[a.Trace = 0] = \"Trace\", a[a.Debug = 1] = \"Debug\", a[a.Info = 2] = \"Info\", a[a.Warn = 3] = \"Warn\", a[a.Error = 4] = \"Error\", a[a.Fatal = 5] = \"Fatal\";\n})(LogLevel$1 || (LogLevel$1 = {}));\n(function(a) {\n  function u(c) {\n    switch (c.toLowerCase()) {\n      case \"trace\":\n        return a.Trace;\n      case \"debug\":\n        return a.Debug;\n      case \"info\":\n        return a.Info;\n      case \"warn\":\n        return a.Warn;\n      case \"error\":\n        return a.Error;\n      case \"fatal\":\n        return a.Fatal;\n      default:\n        return;\n    }\n  }\n  a.toLogLevel = u;\n})(LogLevel$1 || (LogLevel$1 = {}));\nclass CoreLoggerImpl {\n  constructor(u) {\n    this._runtime = u;\n  }\n  get id() {\n    return this._runtime.id;\n  }\n  get logLevel() {\n    return this._runtime.level;\n  }\n  get runtimeSettings() {\n    return Object.assign({}, this._runtime);\n  }\n  set runtimeSettings(u) {\n    this._runtime = u;\n  }\n  trace(u, ...c) {\n    this.logMessage(LogLevel$1.Trace, u, c);\n  }\n  debug(u, ...c) {\n    this.logMessage(LogLevel$1.Debug, u, c);\n  }\n  info(u, ...c) {\n    this.logMessage(LogLevel$1.Info, u, c);\n  }\n  warn(u, ...c) {\n    this.logMessage(LogLevel$1.Warn, u, c);\n  }\n  error(u, ...c) {\n    this.logMessage(LogLevel$1.Error, u, c);\n  }\n  fatal(u, ...c) {\n    this.logMessage(LogLevel$1.Fatal, u, c);\n  }\n  logMessage(u, c, l) {\n    if (this._runtime.level > u)\n      return;\n    const v = Date.now(), S = typeof c == \"string\" ? c : c(), g = CoreLoggerImpl.getErrorAndArgs(l);\n    switch (this._runtime.channel.type) {\n      case \"RawLogChannel\":\n        this._runtime.channel.write({\n          message: S,\n          exception: g.error,\n          args: g.args,\n          timeInMillis: v,\n          level: u,\n          logNames: this._runtime.name\n        }, this._runtime.argumentFormatter);\n        return;\n      case \"LogChannel\":\n        this._runtime.channel.write(this.createLogMessage(S, u, g, v));\n        break;\n    }\n  }\n  formatArgValue(u) {\n    try {\n      return this._runtime.argumentFormatter(u);\n    } catch {\n      return `>>ARG CONVERT FAILED: '${u !== void 0 ? u.toString() : \"undefined\"}'<<`;\n    }\n  }\n  createLogMessage(u, c, l, v) {\n    let S;\n    const g = l.error, E = l.args;\n    g && (S = `${g.name}: ${g.message}`, g.stack && (S += `@\n${g.stack}`));\n    const _ = this._runtime.dateFormatter(v);\n    let k = LogLevel$1[c].toUpperCase();\n    k.length < 5 && (k += \" \");\n    const L = typeof this._runtime.name == \"string\" ? this._runtime.name : this._runtime.name.join(\", \"), M = typeof E < \"u\" && E.length > 0 ? \" [\" + E.map((J) => this.formatArgValue(J)).join(\", \") + \"]\" : \"\";\n    return {\n      message: _ + \" \" + k + \" [\" + L + \"] \" + u + M,\n      error: S\n    };\n  }\n  static getErrorAndArgs(u) {\n    if (u.length === 0)\n      return {};\n    let c, l;\n    const v = u[0];\n    if (v instanceof Error)\n      return c = v, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l };\n    if (typeof v == \"function\") {\n      const S = v();\n      return S instanceof Error ? (c = S, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l }) : u.length === 1 ? Array.isArray(S) ? { args: S.length > 0 ? S : void 0 } : { args: S } : Array.isArray(S) ? { args: [...S, ...u.slice(1)] } : { args: [S, ...u.slice(1)] };\n    }\n    return { args: u };\n  }\n}\nfunction padStart(a, u, c = \" \") {\n  return padInternal(a, u, \"start\", c);\n}\nfunction padEnd(a, u, c = \" \") {\n  return padInternal(a, u, \"end\", c);\n}\nfunction maxLengthStringValueInArray(a) {\n  return a.map((u) => u.length).reduce((u, c) => c > u ? c : u, 0);\n}\nfunction padInternal(a, u, c, l = \" \") {\n  if (u <= a.length)\n    return a;\n  if (l.length > 1)\n    throw new Error(`Fill char must be one char exactly, it is: ${l.length}`);\n  const v = u - a.length;\n  let S = \"\";\n  for (let g = 0; g < v; g++)\n    S += l;\n  return c === \"start\" ? S + a : a + S;\n}\nfunction formatArgument(a) {\n  return a === void 0 ? \"undefined\" : JSON.stringify(a);\n}\nfunction formatDate(a) {\n  const u = new Date(a), c = u.getFullYear(), l = padStart((u.getMonth() + 1).toString(), 2, \"0\"), v = padStart(u.getDate().toString(), 2, \"0\"), S = padStart(u.getHours().toString(), 2, \"0\"), g = padStart(u.getMinutes().toString(), 2, \"0\"), E = padStart(u.getSeconds().toString(), 2, \"0\"), _ = padStart(u.getMilliseconds().toString(), 2, \"0\");\n  return `${c}-${l}-${v} ${S}:${g}:${E},${_}`;\n}\nclass ConsoleLogChannel {\n  constructor() {\n    this.type = \"LogChannel\";\n  }\n  write(u) {\n    console && console.log && console.log(u.message + (u.error ? `\n${u.error}` : \"\"));\n  }\n}\nvar DefaultChannels;\n(function(a) {\n  function u() {\n    return new ConsoleLogChannel();\n  }\n  a.createConsoleChannel = u;\n})(DefaultChannels || (DefaultChannels = {}));\nclass LogProviderImpl {\n  constructor(u, c) {\n    this._log = getInternalLogger(\"core.impl.LogProviderImpl\"), this._name = u, this._settings = c, this._loggers = new EnhancedMap(), this._idToKeyMap = new EnhancedMap(), this._globalRuntimeSettings = { level: c.level, channel: c.channel }, this._nextLoggerId = 1, this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);\n  }\n  get runtimeSettings() {\n    return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });\n  }\n  getLogger(u) {\n    return this.getOrCreateLogger(u);\n  }\n  updateLoggerRuntime(u, c) {\n    this._log.debug(() => `Updating logger ${u.id} runtime settings using: '${JSON.stringify(c)}'`);\n    const l = this._idToKeyMap.get(u.id);\n    return l === void 0 ? (this._log.warn(() => `Cannot update logger with id: ${u.id}, it was not found.`), !1) : (this._loggers.computeIfPresent(l, (v, S) => (S.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(S.runtimeSettings, c), S)), !0);\n  }\n  updateRuntimeSettings(u) {\n    this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(u)}'`), this._globalRuntimeSettings = {\n      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */\n      level: u.level !== void 0 ? u.level : this._globalRuntimeSettings.level,\n      channel: u.channel !== void 0 ? u.channel : this._globalRuntimeSettings.channel\n    }, this._loggers.forEach((c) => c.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(c.runtimeSettings, u));\n  }\n  /**\n   * Removes all state and loggers, it reverts back to as it was after initial construction.\n   */\n  clear() {\n    this._loggers.clear(), this._idToKeyMap.clear(), this._globalRuntimeSettings = Object.assign({}, this._settings), this._nextLoggerId = 1;\n  }\n  getOrCreateLogger(u) {\n    const c = LogProviderImpl.createKey(u), l = this._loggers.computeIfAbsent(c, () => {\n      const v = {\n        level: this._globalRuntimeSettings.level,\n        channel: this._globalRuntimeSettings.channel,\n        id: this.nextLoggerId(),\n        name: u,\n        argumentFormatter: this._settings.argumentFormatter,\n        dateFormatter: this._settings.dateFormatter\n      };\n      return new CoreLoggerImpl(v);\n    });\n    return this._idToKeyMap.computeIfAbsent(l.id, () => c), l;\n  }\n  nextLoggerId() {\n    const u = this._name + \"_\" + this._nextLoggerId;\n    return this._nextLoggerId++, u;\n  }\n  static mergeRuntimeSettingsIntoLogRuntime(u, c) {\n    return Object.assign(Object.assign({}, u), {\n      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */\n      level: c.level !== void 0 ? c.level : u.level,\n      channel: c.channel !== void 0 ? c.channel : u.channel\n    });\n  }\n  static createKey(u) {\n    return typeof u == \"string\" ? u : u.join(\",\");\n  }\n}\nfunction createLogProvider(a, u) {\n  return new LogProviderImpl(a, u);\n}\nvar index$3 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  EnhancedMap,\n  padStart,\n  padEnd,\n  maxLengthStringValueInArray\n});\nclass CategoryImpl {\n  constructor(u, c, l, v) {\n    this._children = [], this._logger = u, this._name = c, this._parent = l, this._fnGetOrCreateChildCategory = v;\n  }\n  get name() {\n    return this._name;\n  }\n  get parent() {\n    return this._parent;\n  }\n  get path() {\n    const u = [];\n    let c = this;\n    for (; c !== void 0; )\n      u.push(c.name), c = c.parent;\n    return u.reverse();\n  }\n  get children() {\n    return [...this._children];\n  }\n  addChild(u) {\n    if (u.parent !== this)\n      throw new Error(`Cannot add child '${u.name}', expected parent '${this._name} but got ${u.parent ? u.parent.name : \"undefined\"}'`);\n    this._children.push(u);\n  }\n  getChildCategory(u) {\n    const c = this._children.find((l) => l.name === u);\n    return c !== void 0 ? c : this._fnGetOrCreateChildCategory(u, this);\n  }\n  get id() {\n    return this._logger.id;\n  }\n  get logLevel() {\n    return this._logger.logLevel;\n  }\n  get runtimeSettings() {\n    return this._logger.runtimeSettings;\n  }\n  get logger() {\n    return this._logger;\n  }\n  trace(u, ...c) {\n    this._logger.trace(u, ...c);\n  }\n  debug(u, ...c) {\n    this._logger.debug(u, ...c);\n  }\n  info(u, ...c) {\n    this._logger.info(u, ...c);\n  }\n  warn(u, ...c) {\n    this._logger.warn(u, ...c);\n  }\n  error(u, ...c) {\n    this._logger.error(u, ...c);\n  }\n  fatal(u, ...c) {\n    this._logger.fatal(u, ...c);\n  }\n}\nconst CATEGORY_PATH_SEPARATOR = \"#\";\nclass CategoryProviderImpl {\n  constructor(u, c) {\n    this._name = u, this._initialConfig = c, this._categoryStorage = new CategoryStorage(u, c);\n  }\n  get name() {\n    return this._name;\n  }\n  get config() {\n    return this._initialConfig;\n  }\n  get runtimeConfig() {\n    return this._categoryStorage.getCurrentRuntimeConfig();\n  }\n  getCategory(u, c) {\n    return this._categoryStorage.getOrCreateCategory(u, c);\n  }\n  updateRuntimeSettingsCategory(u, c) {\n    this._categoryStorage.updateRuntimeSettingsCategory(u, c);\n  }\n  updateRuntimeSettings(u) {\n    this._categoryStorage.updateRuntimeSettings(u);\n  }\n  /** Returns all currently registered categories */\n  getRegisteredCategories() {\n    return this._categoryStorage.getRegisteredCategories();\n  }\n  /** Get a category by path, note that paths must be separated by #, e.g. root#child1#child1_1 */\n  getCategoryByPath(u) {\n    return this._categoryStorage.getCategoryByPath(u);\n  }\n}\nclass CategoryStorage {\n  constructor(u, c) {\n    this._categoriesById = /* @__PURE__ */ new Map(), this._categoriesByPath = /* @__PURE__ */ new Map(), this._categoryProviderName = u, this._allowSameCategoryName = c.allowSameCategoryName, this._logProvider = createLogProvider(u, Object.assign({}, c)), this.getOrCreateCategory = this.getOrCreateCategory.bind(this);\n  }\n  getOrCreateCategory(u, c) {\n    if (u.indexOf(CATEGORY_PATH_SEPARATOR) !== -1)\n      throw new Error(`Cannot create category '${u}', name cannot contain a '${CATEGORY_PATH_SEPARATOR}'.`);\n    const l = c !== void 0 ? this.getParentCategory(c) : void 0;\n    return l === void 0 ? this.getOrCreateRootCategory(u) : this.getOrCreateChildCategory(u, l);\n  }\n  updateRuntimeSettingsCategory(u, c) {\n    if (!u.id.startsWith(this._categoryProviderName))\n      throw new Error(`Category '${u.name}' with LogId '${u.id}' is from a different CategoryProvider, cannot mix categories between providers.`);\n    const l = this._categoriesById.get(u.id);\n    l !== void 0 && (this._logProvider.updateLoggerRuntime(l.logger, { level: c.level }), !(c.disableRecursion !== void 0 && c.disableRecursion) && l.children.forEach((v) => this.updateRuntimeSettingsCategory(v, c)));\n  }\n  updateRuntimeSettings(u) {\n    this._logProvider.updateRuntimeSettings(u);\n  }\n  getCurrentRuntimeConfig() {\n    return Object.assign(Object.assign({}, this._logProvider.runtimeSettings), { allowSameCategoryName: this._allowSameCategoryName });\n  }\n  /** Returns all currently registered categories */\n  getRegisteredCategories() {\n    return [...this._categoriesById.values()];\n  }\n  /** Get a category by path, note that paths must be separated by #, e.g. root#child1#child1_1 */\n  getCategoryByPath(u) {\n    return this._categoriesByPath.get(u);\n  }\n  getParentCategory(u) {\n    let c;\n    if (CategoryStorage.isLogId(u)) {\n      if (c = this._categoriesById.get(u), c === void 0)\n        throw new Error(`Parent category was not found by LogId '${u}'. Are you sure you passed in the correct argument?`);\n    } else if (c = this._categoriesById.get(u.id), c === void 0)\n      throw new Error(`Parent category '${u.name}' was not found by it's LogId '${u.id}'. Are you sure you passed in the correct parent category?`);\n    return c;\n  }\n  getOrCreateRootCategory(u) {\n    const c = this._categoriesByPath.get(u);\n    if (c) {\n      if (!this._allowSameCategoryName)\n        throw new Error(`Category '${u} already exists, config flag allowSameCategoryName=false - therefore matching version 1 behavior (hence this Error)`);\n      return c;\n    }\n    const l = this._logProvider.getLogger(u), v = new CategoryImpl(l, u, void 0, this.getOrCreateCategory);\n    return this._categoriesById.set(v.id, v), this._categoriesByPath.set(u, v), v;\n  }\n  getOrCreateChildCategory(u, c) {\n    if (!c.id.startsWith(this._categoryProviderName))\n      throw new Error(`Parent category '${c.name}' with LogId '${c.id}' is from a different CategoryProvider, cannot mix categories between providers.`);\n    const l = [...c.path, u].join(CATEGORY_PATH_SEPARATOR), v = this._categoriesByPath.get(l);\n    if (v) {\n      if (!this._allowSameCategoryName)\n        throw new Error(`Child category '${u} already exists for parent category ${c.name}, config flag allowSameCategoryName=false - therefore matching version 1 behavior (hence this Error)`);\n      return v;\n    }\n    const S = this._logProvider.getLogger(l);\n    this._logProvider.updateLoggerRuntime(S, {\n      level: c.logger.runtimeSettings.level,\n      channel: c.logger.runtimeSettings.channel\n    });\n    const g = new CategoryImpl(S, u, c, this.getOrCreateCategory);\n    return this._categoriesById.set(g.id, g), this._categoriesByPath.set(g.path.join(CATEGORY_PATH_SEPARATOR), g), c.addChild(g), g;\n  }\n  static isLogId(u) {\n    return typeof u == \"string\";\n  }\n}\nclass CategoryControlProviderImpl {\n  constructor(u, c) {\n    this._provider = u, this._messageChannel = c, this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(u);\n  }\n  get name() {\n    return this._provider.name;\n  }\n  /**\n   * Shows current settings.\n   */\n  showSettings() {\n    let u = `Available categories (CategoryProvider '${this._provider.name}'):\n`;\n    const c = this.createCategoryInfoHierarchy(), l = c.size.toString().length, v = index$3.maxLengthStringValueInArray([...c.values()].map((g) => g.category.name + \" \".repeat(g.depth))), S = [...c.values()].map((g, E) => CategoryControlProviderImpl.createSettingLineCategory(g, E, l, v));\n    u += S.join(`\n`) + (S.length > 0 ? `\n` : \"\"), this._messageChannel(u);\n  }\n  help() {\n    const u = `You can use the following commands (CategoryProvider ${this._provider.name}):\n  showSettings()\n    Shows the current configuration settings.\n  update(level: CategoryControlProviderLogLevel, categoryId?: number | string, noRecurse?: boolean)\n    Change the log level for a category (by default recursively).\n      @param level      The log level to set - must be one of 'trace', 'debug', 'info', 'warn', 'error' or 'fatal'\n      @param categoryId The category id or path of a category (e.g. root#child1) to update. Use showSettings() for id and/or name.\n                        When omitted, it applies the level to all categories recursively.\n  reset()\n    Resets the log levels of the config groups back to when this control provider was created.\n  save()\n    Saves the current log levels for all categories of this provider. Use restore() to load last saved state.\n  restore()\n    Restore stored saved state, if any. Log levels will be set according to the saved state.\n  help()\n    Shows this help.\n`;\n    this._messageChannel(u);\n  }\n  reset() {\n    const u = new Map(this._provider.getRegisteredCategories().map((c) => [c.id, c]));\n    this._originalLogLevels.forEach((c, l) => {\n      const v = u.get(l);\n      v !== void 0 && this._provider.updateRuntimeSettingsCategory(v, { level: c, disableRecursion: !0 }), u.delete(l);\n    }), u.forEach((c) => {\n      c.parent !== void 0 && this._provider.updateRuntimeSettingsCategory(c, { level: c.parent.logLevel, disableRecursion: !0 });\n    }), this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(this._provider), this._messageChannel(\"Successfully reset log levels back to original state (from when this CategoryControlProvider was created).\");\n  }\n  save() {\n    if (!localStorage) {\n      this._messageChannel(\"Cannot save state, localStorage is not available.\");\n      return;\n    }\n    const u = this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).map((l) => CategoryControlProviderImpl.createCategorySaveData(l)), c = {\n      name: this._provider.name,\n      rootCategories: u\n    };\n    localStorage.setItem(this.createKey(), JSON.stringify(c)), this._messageChannel(`Successfully saved state for CategoryControlProvider '${this._provider.name}'.`);\n  }\n  restore(u) {\n    const c = u !== void 0 ? u : !0;\n    if (!localStorage) {\n      c && this._messageChannel(`Will not attempt to restore state for CategoryControlProvider '${this._provider.name}', localStorage is not available.`);\n      return;\n    }\n    const l = this.createKey(), v = localStorage.getItem(l);\n    if (v === null) {\n      c && this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', no data available.`);\n      return;\n    }\n    try {\n      const S = JSON.parse(v);\n      if (this._provider.name !== S.name) {\n        c && this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', data is not for provider - found name '${S.name}'.`);\n        return;\n      }\n      this.restoreBySaveData(S, c), this._messageChannel(`Successfully restored state for CategoryControlProvider '${this._provider.name}'`), this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(this._provider);\n    } catch {\n      localStorage.removeItem(l), this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', data is not valid. Invalid data removed from localStorage.`);\n    }\n  }\n  update(u, c, l) {\n    typeof c > \"u\" ? this.updateAll(u) : typeof c == \"number\" ? this.updateByIndex(u, c, l !== void 0 ? l : !1) : this.updateByPath(u, c, l !== void 0 ? l : !1);\n  }\n  updateAll(u) {\n    const c = LogLevel$1.toLogLevel(u);\n    this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).forEach((l) => this._provider.updateRuntimeSettingsCategory(l, { level: c })), this._messageChannel(`Updated all categories to use log level '${u.toLowerCase()}'`);\n  }\n  updateByPath(u, c, l) {\n    const v = this._provider.getCategoryByPath(c);\n    if (v === void 0) {\n      this._messageChannel(`Failed to find a provider by path '${c}', please make sure to separate the parts by a ${CATEGORY_PATH_SEPARATOR}.`);\n      return;\n    }\n    this._provider.updateRuntimeSettingsCategory(v, { level: LogLevel$1.toLogLevel(u), disableRecursion: l }), this._messageChannel(`Successfully updated category '${v.name}' with path '${c}' to log level '${u.toLowerCase()}'${l ? \"\" : \" and recursively applied to children (if any)\"}.`);\n  }\n  updateByIndex(u, c, l) {\n    if (c < 0) {\n      this._messageChannel(`Cannot update category by index '${c}', it is negative.`);\n      return;\n    }\n    const v = this.createCategoryInfoHierarchy();\n    if (c >= v.size) {\n      this._messageChannel(`Cannot update category by index '${c}', it is outside of the range of available categories, use showSettings() to see the indices.`);\n      return;\n    }\n    const S = [...v.values()][c].category;\n    this._provider.updateRuntimeSettingsCategory(S, { level: LogLevel$1.toLogLevel(u), disableRecursion: l }), this._messageChannel(`Successfully updated category '${S.name}' by index '${c}' to log level '${u.toLowerCase()}'${l ? \"\" : \" and recursively applied to children (if any)\"}.`);\n  }\n  restoreBySaveData(u, c) {\n    const l = (v, S) => {\n      const g = S.length > 0 ? S + CATEGORY_PATH_SEPARATOR + v.name : v.name, E = this._provider.getCategoryByPath(g);\n      if (E !== void 0) {\n        const _ = LogLevel$1.toLogLevel(v.level);\n        _ !== void 0 ? this._provider.updateRuntimeSettingsCategory(E, { level: _, disableRecursion: !0 }) : c && this._messageChannel(`CategoryControlProvider '${this._provider.name}' - cannot restore log level for category path '${g}', log level is invalid.`);\n        for (const k of v.children)\n          l(k, g);\n      } else\n        c && this._messageChannel(`CategoryControlProvider '${this._provider.name}' - failed to find a Category by path '${g}', will not restore category (and children)`);\n    };\n    for (const v of u.rootCategories)\n      l(v, \"\");\n  }\n  createKey() {\n    return `CategoryProvider-${this._provider.name}`;\n  }\n  createCategoryInfoHierarchy() {\n    const u = /* @__PURE__ */ new Map();\n    return this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).forEach((l) => CategoryControlProviderImpl.addCategoryInfoHierarchy(l, 0, u)), u;\n  }\n  static createCategorySaveData(u) {\n    return {\n      name: u.name,\n      level: LogLevel$1[u.logLevel],\n      children: u.children.map((c) => this.createCategorySaveData(c))\n    };\n  }\n  static loadCurrentGroupLogLevels(u) {\n    return new Map(u.getRegisteredCategories().map((c) => [c.id, c.logLevel]));\n  }\n  static createSettingLineCategory(u, c, l, v) {\n    const g = \" \".repeat(u.depth) + u.category.name;\n    return `  [${index$3.padStart(c.toString(), l)}, ${index$3.padEnd(g, v)} (level=${index$3.padEnd(u.logLevel, 5)})]`;\n  }\n  static addCategoryInfoHierarchy(u, c, l) {\n    l.set(u.id, {\n      category: u,\n      logLevel: LogLevel$1[u.logLevel],\n      depth: c\n    }), u.children.forEach((v) => this.addCategoryInfoHierarchy(v, c + 1, l));\n  }\n}\nfunction categoryConfigDebug(a) {\n  return `CategoryConfig=level: ${LogLevel$1[a.level].toString()}, allowSameCategoryName=${a.allowSameCategoryName}`;\n}\nclass CategoryProviderService {\n  constructor() {\n    this._log = InternalLogger.getInternalLogger(\"category.impl.CategoryProviderService\"), this._providers = new index$3.EnhancedMap();\n  }\n  createLogProvider(u, c) {\n    const l = this._providers.compute(u, (v, S) => {\n      if (S)\n        throw new Error(`CategoryProvider with name '${u}' already exists, cannot create another.`);\n      const g = mergeWithDefaults(c);\n      return this._log.debug(() => `Creating new CategoryProvider with name '${u}', using config settings '${categoryConfigDebug(g)}'.`), new CategoryProviderImpl(u, g);\n    });\n    if (l)\n      return l;\n    throw new Error(\"No CategoryProvider? This is a bug.\");\n  }\n  getCategoryControl(u) {\n    const c = u || ((l) => {\n      if (console && console.log)\n        console.log(l);\n      else\n        throw new Error(\"Cannot use console (it is not present), please specify a custom function to write to.\");\n    });\n    return {\n      help: () => c(CategoryProviderService.help()),\n      showSettings: () => c(this.showSettings()),\n      getProvider: (l) => this.getCategoryControlProviderByIdOrName(l, c)\n    };\n  }\n  clear() {\n    this._providers.clear();\n  }\n  /* Functions for CategoryControl follow */\n  showSettings() {\n    let u = `Available CategoryProviders:\n`;\n    const c = this._providers.size.toString().length, l = index$3.maxLengthStringValueInArray([...this._providers.keys()]), v = [...this._providers.entries()].map((S, g) => {\n      const E = S[0];\n      return `  [${index$3.padStart(g.toString(), c)}, ${index$3.padEnd(E, l)}]`;\n    });\n    return u += v.join(`\n`) + (v.length > 0 ? `\n` : \"\"), u;\n  }\n  getCategoryControlProviderByIdOrName(u, c) {\n    if (typeof u == \"string\") {\n      const v = this._providers.get(u);\n      if (v === void 0)\n        throw new Error(`Provider with name '${u}' does not exist.`);\n      return new CategoryControlProviderImpl(v, c);\n    }\n    const l = [...this._providers.values()];\n    if (u < 0 || u >= l.length)\n      throw new Error(`Provider with index '${u}' does not exist (outside of range).`);\n    return new CategoryControlProviderImpl(l[u], c);\n  }\n  static help() {\n    return `You can use the following commands:\n  showSettings()\n    Shows the current configuration settings.\n  getProvider: (id: number | string): CategoryControlProvider\n    Get access to a CategoryControlProvider to change log levels.\n      @param id The id (use showSettings to see) or name of the provider\n  help()\n    Shows this help.\n`;\n  }\n}\nconst CATEGORY_PROVIDER_SERVICE = new CategoryProviderService(), CATEGORY_LOG_CONTROL = (a) => CATEGORY_PROVIDER_SERVICE.getCategoryControl(a);\nfunction mergeWithDefaults(a) {\n  const u = {\n    channel: DefaultChannels.createConsoleChannel(),\n    allowSameCategoryName: !0,\n    level: LogLevel$1.Error,\n    dateFormatter: formatDate,\n    argumentFormatter: formatArgument\n  };\n  return a ? {\n    channel: a.channel ? a.channel : u.channel,\n    allowSameCategoryName: a.allowSameCategoryName !== void 0 ? a.allowSameCategoryName : u.allowSameCategoryName,\n    level: a.level ? a.level : u.level,\n    dateFormatter: a.dateFormatter ? a.dateFormatter : u.dateFormatter,\n    argumentFormatter: a.argumentFormatter ? a.argumentFormatter : u.argumentFormatter\n  } : u;\n}\nvar CategoryProvider;\n(function(a) {\n  function u(l, v) {\n    return CATEGORY_PROVIDER_SERVICE.createLogProvider(l, v);\n  }\n  a.createProvider = u;\n  function c() {\n    CATEGORY_PROVIDER_SERVICE.clear();\n  }\n  a.clear = c;\n})(CategoryProvider || (CategoryProvider = {}));\nconst typescriptLoggingCategory_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  CATEGORY_LOG_CONTROL,\n  get CategoryProvider() {\n    return CategoryProvider;\n  }\n}, Symbol.toStringTag, { value: \"Module\" })), require$$1 = /* @__PURE__ */ getAugmentedNamespace(typescriptLoggingCategory_esm);\nObject.defineProperty(logger, \"__esModule\", { value: !0 });\nlogger.logger = void 0;\nconst typescript_logging_1 = require$$2$1, typescript_logging_category_style_1 = require$$1;\nlogger.logger = typescript_logging_category_style_1.CategoryProvider.createProvider(\"ApiStream\", { allowSameCategoryName: !0, level: typescript_logging_1.LogLevel.Warn });\nvar version$3 = \"1.0.25\", __createBinding$3 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {\n  l === void 0 && (l = c);\n  var v = Object.getOwnPropertyDescriptor(u, c);\n  (!v || (\"get\" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {\n    return u[c];\n  } }), Object.defineProperty(a, l, v);\n} : function(a, u, c, l) {\n  l === void 0 && (l = c), a[l] = u[c];\n}), __setModuleDefault$3 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {\n  Object.defineProperty(a, \"default\", { enumerable: !0, value: u });\n} : function(a, u) {\n  a.default = u;\n}), __importStar$3 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {\n  if (a && a.__esModule)\n    return a;\n  var u = {};\n  if (a != null)\n    for (var c in a)\n      c !== \"default\" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$3(u, a, c);\n  return __setModuleDefault$3(u, a), u;\n}, __importDefault$d = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(api$2, \"__esModule\", { value: !0 });\napi$2.ApiClient = void 0;\nconst NiceGrpc$1 = __importStar$3(lib$1), abort_controller_x_1 = require$$1$1, detect_node_1 = __importDefault$d(browser$2), NodeTransport = __importStar$3(require$$0$1), logger_1 = logger, clientVersion$1 = version$3;\nclass ApiClient {\n  constructor(u, c, l, v, S, g) {\n    this.sessionId = u, this.sdkVersion = l, this.version = clientVersion$1, this.apiLogCallback = S, this.eventLogCallback = g, this.log = logger_1.logger.getCategory(v), this.channel = NiceGrpc$1.createChannel(c, detect_node_1.default ? NodeTransport.NodeHttpTransport() : void 0), this.clientFactory = NiceGrpc$1.createClientFactory().use(this.logMiddleware.bind(this));\n  }\n  async *logMiddleware(u, c) {\n    const { path: l } = u.method;\n    try {\n      const v = yield* u.next(u.request, c);\n      if (this.log.debug(`-> ${l}: ok`), this.log.trace(`${JSON.stringify(u.request)} -> ${l}: ${JSON.stringify(v)}`), this.apiLogCallback) {\n        let S = l.split(\"/\"), g = S[1].split(\".\"), E = g[g.length - 1], _ = g[g.length - 2], k = g[g.length - 3], L = S[2];\n        this.apiLogCallback(k, E, L, u.request, v);\n      }\n      return v;\n    } catch (v) {\n      throw this.log.trace(`${JSON.stringify(u.request)} -> ${l}`), v instanceof NiceGrpc$1.ClientError ? this.log.warn(`-> ${l}: error: ${NiceGrpc$1.Status[v.code]}: ${v.details}`) : (0, abort_controller_x_1.isAbortError)(v) ? this.log.warn(`-> ${l}: cancel`) : this.log.warn(`-> ${l}: error: ${v == null ? void 0 : v.stack}`), v;\n    }\n  }\n  setAccessToken(u) {\n    (this.accessToken == null || this.accessToken != u) && (this.log.debug(\"access token refreshed\"), this.accessToken = u, this.setup());\n  }\n  makeGrpcMetadata() {\n    let u = NiceGrpc$1.Metadata({\n      Authorization: `Bearer ${this.accessToken}`,\n      Version: this.version,\n      SessionId: this.sessionId\n    });\n    return this.sdkVersion != null && u.set(\"SdkVersion\", this.sdkVersion), u;\n  }\n  setup() {\n    let u = {\n      metadata: this.makeGrpcMetadata()\n    };\n    this._setup(u);\n  }\n  _setup(u) {\n  }\n}\napi$2.ApiClient = ApiClient;\nvar decorator = {};\nObject.defineProperty(decorator, \"__esModule\", { value: !0 });\ndecorator.RequiresSdkAuthentication = void 0;\nfunction RequiresSdkAuthentication() {\n  return function(a, u) {\n    const c = Symbol(u);\n    Object.defineProperty(a, u, {\n      get: function() {\n        if (!this[c])\n          throw new Error(\"Please authenticate ApiStream by calling apiStream.load( accessToken )\");\n        return this[c];\n      },\n      set: function(l) {\n        this[c] = l;\n      }\n    });\n  };\n}\ndecorator.RequiresSdkAuthentication = RequiresSdkAuthentication;\nvar __createBinding$2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {\n  l === void 0 && (l = c);\n  var v = Object.getOwnPropertyDescriptor(u, c);\n  (!v || (\"get\" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {\n    return u[c];\n  } }), Object.defineProperty(a, l, v);\n} : function(a, u, c, l) {\n  l === void 0 && (l = c), a[l] = u[c];\n}), __setModuleDefault$2 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {\n  Object.defineProperty(a, \"default\", { enumerable: !0, value: u });\n} : function(a, u) {\n  a.default = u;\n}), __decorate = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function(a, u, c, l) {\n  var v = arguments.length, S = v < 3 ? u : l === null ? l = Object.getOwnPropertyDescriptor(u, c) : l, g;\n  if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\")\n    S = Reflect.decorate(a, u, c, l);\n  else\n    for (var E = a.length - 1; E >= 0; E--)\n      (g = a[E]) && (S = (v < 3 ? g(S) : v > 3 ? g(u, c, S) : g(u, c)) || S);\n  return v > 3 && S && Object.defineProperty(u, c, S), S;\n}, __importStar$2 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {\n  if (a && a.__esModule)\n    return a;\n  var u = {};\n  if (a != null)\n    for (var c in a)\n      c !== \"default\" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$2(u, a, c);\n  return __setModuleDefault$2(u, a), u;\n}, __metadata = commonjsGlobal$1 && commonjsGlobal$1.__metadata || function(a, u) {\n  if (typeof Reflect == \"object\" && typeof Reflect.metadata == \"function\")\n    return Reflect.metadata(a, u);\n};\nObject.defineProperty(layoutapi, \"__esModule\", { value: !0 });\nlayoutapi.LayoutApi = void 0;\n__importStar$2(lib$1);\nconst LayoutApiModel = __importStar$2(dist$2), api_1$1 = api$2, decorator_1 = decorator, LOG_CATEGORY$1 = \"LayoutApi\";\nclass LayoutApi extends api_1$1.ApiClient {\n  constructor(u, c, l, v, S) {\n    super(u, l, v, LOG_CATEGORY$1, S), this.handlers = {}, this.eventApi = c, this.eventApi.on(\"event\", { name: `${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:*`, ignoreSessionEvents: !0 }, (g) => {\n      var E;\n      const [, _] = g.name.split(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:`), [k, L] = _.split(\":\"), M = g.payload;\n      for (const $ of (E = this.handlers[k]) !== null && E !== void 0 ? E : [])\n        $(Object.values(M).find((J) => !!J), L);\n    });\n  }\n  _setup(u) {\n    this.layer = this.clientFactory.create(LayoutApiModel.LayerServiceDefinition, this.channel, {\n      \"*\": u\n    }), this.layout = this.clientFactory.create(LayoutApiModel.LayoutServiceDefinition, this.channel, {\n      \"*\": u\n    });\n  }\n  /**\n   * Subscribe to all events for a given layout.\n   *\n   * @param layoutId - the id of the layout to which you want to subscribe to layout events\n   */\n  async subscribeToLayout(u) {\n    await Promise.all([\n      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { layoutId: u } }),\n      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { layoutId: u } })\n    ]);\n  }\n  /**\n   * Unsubscribe from all events for a given layout.\n   *\n   * @param layoutId - the id of the layout to which you want to unsubscribe to layout events\n   */\n  async unsubscribeFromLayout(u) {\n    await Promise.all([\n      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { layoutId: u } }),\n      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { layoutId: u } })\n    ]);\n  }\n  /**\n   * Subscribe to all events for layouts in a project.\n   *\n   * @param collectionId - the id of the collection the layouts are in.\n   * @param projectId - the id of the project the layouts are in.\n   */\n  async subscribeToLayoutsInProject(u, c) {\n    await Promise.all([\n      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { collectionId: u, projectId: c } }),\n      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { collectionId: u, projectId: c } })\n    ]);\n  }\n  /**\n   * Unsubscribe from all events for layouts in a project.\n   *\n   * @param collectionId - the id of the collection the layouts are in.\n   * @param projectId - the id of the project the layouts are in.\n   */\n  async unsubscribeFromLayoutsInProject(u, c) {\n    await Promise.all([\n      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { collectionId: u, projectId: c } }),\n      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { collectionId: u, projectId: c } })\n    ]);\n  }\n  /**\n   * Register an event handler\n   *\n   * @param type Type of event\n   * @param handler\n   */\n  on(u, c) {\n    var l;\n    this.handlers[u] = (l = this.handlers[u]) !== null && l !== void 0 ? l : [], this.handlers[u].push(c);\n  }\n  /**\n   * Unregister an event handler\n   *\n   * @param type Type of event\n   * @param handler\n   */\n  off(u, c) {\n    this.handlers[u] = this.handlers[u].filter((l) => l !== c);\n  }\n}\nLayoutApi.LAYOUTAPI_EVENT_PREFIX = \"apistream:layout\";\n__decorate([\n  (0, decorator_1.RequiresSdkAuthentication)(),\n  __metadata(\"design:type\", Object)\n], LayoutApi.prototype, \"layout\", void 0);\n__decorate([\n  (0, decorator_1.RequiresSdkAuthentication)(),\n  __metadata(\"design:type\", Object)\n], LayoutApi.prototype, \"layer\", void 0);\nlayoutapi.LayoutApi = LayoutApi;\nvar liveapi = {}, api$1 = {}, httpbody = {}, any = {}, __importDefault$c = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(any, \"__esModule\", { value: !0 });\nany.Any = any.protobufPackage = void 0;\nconst minimal_1$5 = __importDefault$c(minimal);\nany.protobufPackage = \"google.protobuf\";\nfunction createBaseAny() {\n  return { typeUrl: \"\", value: new Uint8Array() };\n}\nany.Any = {\n  encode(a, u = minimal_1$5.default.Writer.create()) {\n    return a.typeUrl !== \"\" && u.uint32(10).string(a.typeUrl), a.value.length !== 0 && u.uint32(18).bytes(a.value), u;\n  },\n  decode(a, u) {\n    const c = a instanceof minimal_1$5.default.Reader ? a : new minimal_1$5.default.Reader(a);\n    let l = u === void 0 ? c.len : c.pos + u;\n    const v = createBaseAny();\n    for (; c.pos < l; ) {\n      const S = c.uint32();\n      switch (S >>> 3) {\n        case 1:\n          v.typeUrl = c.string();\n          break;\n        case 2:\n          v.value = c.bytes();\n          break;\n        default:\n          c.skipType(S & 7);\n          break;\n      }\n    }\n    return v;\n  },\n  fromJSON(a) {\n    return {\n      typeUrl: isSet$4(a.typeUrl) ? String(a.typeUrl) : \"\",\n      value: isSet$4(a.value) ? bytesFromBase64$1(a.value) : new Uint8Array()\n    };\n  },\n  toJSON(a) {\n    const u = {};\n    return a.typeUrl !== void 0 && (u.typeUrl = a.typeUrl), a.value !== void 0 && (u.value = base64FromBytes$1(a.value !== void 0 ? a.value : new Uint8Array())), u;\n  },\n  fromPartial(a) {\n    var u, c;\n    const l = createBaseAny();\n    return l.typeUrl = (u = a.typeUrl) !== null && u !== void 0 ? u : \"\", l.value = (c = a.value) !== null && c !== void 0 ? c : new Uint8Array(), l;\n  }\n};\nvar globalThis$5 = (() => {\n  if (typeof globalThis$5 < \"u\")\n    return globalThis$5;\n  if (typeof self < \"u\")\n    return self;\n  if (typeof window < \"u\")\n    return window;\n  if (typeof commonjsGlobal$1 < \"u\")\n    return commonjsGlobal$1;\n  throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64$1(a) {\n  if (globalThis$5.Buffer)\n    return Uint8Array.from(globalThis$5.Buffer.from(a, \"base64\"));\n  {\n    const u = globalThis$5.atob(a), c = new Uint8Array(u.length);\n    for (let l = 0; l < u.length; ++l)\n      c[l] = u.charCodeAt(l);\n    return c;\n  }\n}\nfunction base64FromBytes$1(a) {\n  if (globalThis$5.Buffer)\n    return globalThis$5.Buffer.from(a).toString(\"base64\");\n  {\n    const u = [];\n    return a.forEach((c) => {\n      u.push(String.fromCharCode(c));\n    }), globalThis$5.btoa(u.join(\"\"));\n  }\n}\nfunction isSet$4(a) {\n  return a != null;\n}\nvar __importDefault$b = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(httpbody, \"__esModule\", { value: !0 });\nhttpbody.HttpBody = httpbody.protobufPackage = void 0;\nconst minimal_1$4 = __importDefault$b(minimal), any_1 = any;\nhttpbody.protobufPackage = \"google.api\";\nfunction createBaseHttpBody() {\n  return { contentType: \"\", data: new Uint8Array(), extensions: [] };\n}\nhttpbody.HttpBody = {\n  encode(a, u = minimal_1$4.default.Writer.create()) {\n    a.contentType !== \"\" && u.uint32(10).string(a.contentType), a.data.length !== 0 && u.uint32(18).bytes(a.data);\n    for (const c of a.extensions)\n      any_1.Any.encode(c, u.uint32(26).fork()).ldelim();\n    return u;\n  },\n  decode(a, u) {\n    const c = a instanceof minimal_1$4.default.Reader ? a : new minimal_1$4.default.Reader(a);\n    let l = u === void 0 ? c.len : c.pos + u;\n    const v = createBaseHttpBody();\n    for (; c.pos < l; ) {\n      const S = c.uint32();\n      switch (S >>> 3) {\n        case 1:\n          v.contentType = c.string();\n          break;\n        case 2:\n          v.data = c.bytes();\n          break;\n        case 3:\n          v.extensions.push(any_1.Any.decode(c, c.uint32()));\n          break;\n        default:\n          c.skipType(S & 7);\n          break;\n      }\n    }\n    return v;\n  },\n  fromJSON(a) {\n    return {\n      contentType: isSet$3(a.contentType) ? String(a.contentType) : \"\",\n      data: isSet$3(a.data) ? bytesFromBase64(a.data) : new Uint8Array(),\n      extensions: Array.isArray(a == null ? void 0 : a.extensions) ? a.extensions.map((u) => any_1.Any.fromJSON(u)) : []\n    };\n  },\n  toJSON(a) {\n    const u = {};\n    return a.contentType !== void 0 && (u.contentType = a.contentType), a.data !== void 0 && (u.data = base64FromBytes(a.data !== void 0 ? a.data : new Uint8Array())), a.extensions ? u.extensions = a.extensions.map((c) => c ? any_1.Any.toJSON(c) : void 0) : u.extensions = [], u;\n  },\n  fromPartial(a) {\n    var u, c, l;\n    const v = createBaseHttpBody();\n    return v.contentType = (u = a.contentType) !== null && u !== void 0 ? u : \"\", v.data = (c = a.data) !== null && c !== void 0 ? c : new Uint8Array(), v.extensions = ((l = a.extensions) === null || l === void 0 ? void 0 : l.map((S) => any_1.Any.fromPartial(S))) || [], v;\n  }\n};\nvar globalThis$4 = (() => {\n  if (typeof globalThis$4 < \"u\")\n    return globalThis$4;\n  if (typeof self < \"u\")\n    return self;\n  if (typeof window < \"u\")\n    return window;\n  if (typeof commonjsGlobal$1 < \"u\")\n    return commonjsGlobal$1;\n  throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(a) {\n  if (globalThis$4.Buffer)\n    return Uint8Array.from(globalThis$4.Buffer.from(a, \"base64\"));\n  {\n    const u = globalThis$4.atob(a), c = new Uint8Array(u.length);\n    for (let l = 0; l < u.length; ++l)\n      c[l] = u.charCodeAt(l);\n    return c;\n  }\n}\nfunction base64FromBytes(a) {\n  if (globalThis$4.Buffer)\n    return globalThis$4.Buffer.from(a).toString(\"base64\");\n  {\n    const u = [];\n    return a.forEach((c) => {\n      u.push(String.fromCharCode(c));\n    }), globalThis$4.btoa(u.join(\"\"));\n  }\n}\nfunction isSet$3(a) {\n  return a != null;\n}\nvar field_mask = {}, __importDefault$a = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(field_mask, \"__esModule\", { value: !0 });\nfield_mask.FieldMask = field_mask.protobufPackage = void 0;\nconst minimal_1$3 = __importDefault$a(minimal);\nfield_mask.protobufPackage = \"google.protobuf\";\nfunction createBaseFieldMask() {\n  return { paths: [] };\n}\nfield_mask.FieldMask = {\n  encode(a, u = minimal_1$3.default.Writer.create()) {\n    for (const c of a.paths)\n      u.uint32(10).string(c);\n    return u;\n  },\n  decode(a, u) {\n    const c = a instanceof minimal_1$3.default.Reader ? a : new minimal_1$3.default.Reader(a);\n    let l = u === void 0 ? c.len : c.pos + u;\n    const v = createBaseFieldMask();\n    for (; c.pos < l; ) {\n      const S = c.uint32();\n      switch (S >>> 3) {\n        case 1:\n          v.paths.push(c.string());\n          break;\n        default:\n          c.skipType(S & 7);\n          break;\n      }\n    }\n    return v;\n  },\n  fromJSON(a) {\n    return {\n      paths: typeof a == \"string\" ? a.split(\",\").filter(Boolean) : Array.isArray(a == null ? void 0 : a.paths) ? a.paths.map(String) : []\n    };\n  },\n  toJSON(a) {\n    return a.paths.join(\",\");\n  },\n  fromPartial(a) {\n    var u;\n    const c = createBaseFieldMask();\n    return c.paths = ((u = a.paths) === null || u === void 0 ? void 0 : u.map((l) => l)) || [], c;\n  },\n  wrap(a) {\n    const u = createBaseFieldMask();\n    return u.paths = a, u;\n  },\n  unwrap(a) {\n    return a.paths;\n  }\n};\nvar struct$1 = {};\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(V) {\n    return V && V.__esModule ? V : { default: V };\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;\n  const c = u(minimal);\n  a.protobufPackage = \"google.protobuf\";\n  var l;\n  (function(V) {\n    V.NULL_VALUE = \"NULL_VALUE\";\n  })(l = a.NullValue || (a.NullValue = {}));\n  function v(V) {\n    switch (V) {\n      case 0:\n      case \"NULL_VALUE\":\n        return l.NULL_VALUE;\n      default:\n        throw new M.Error(\"Unrecognized enum value \" + V + \" for enum NullValue\");\n    }\n  }\n  a.nullValueFromJSON = v;\n  function S(V) {\n    switch (V) {\n      case l.NULL_VALUE:\n        return \"NULL_VALUE\";\n      default:\n        throw new M.Error(\"Unrecognized enum value \" + V + \" for enum NullValue\");\n    }\n  }\n  a.nullValueToJSON = S;\n  function g(V) {\n    switch (V) {\n      case l.NULL_VALUE:\n        return 0;\n      default:\n        throw new M.Error(\"Unrecognized enum value \" + V + \" for enum NullValue\");\n    }\n  }\n  a.nullValueToNumber = g;\n  function E() {\n    return { fields: {} };\n  }\n  a.Struct = {\n    encode(V, q = c.default.Writer.create()) {\n      return Object.entries(V.fields).forEach(([G, H]) => {\n        H !== void 0 && a.Struct_FieldsEntry.encode({ key: G, value: H }, q.uint32(10).fork()).ldelim();\n      }), q;\n    },\n    decode(V, q) {\n      const G = V instanceof c.default.Reader ? V : new c.default.Reader(V);\n      let H = q === void 0 ? G.len : G.pos + q;\n      const B = E();\n      for (; G.pos < H; ) {\n        const Y = G.uint32();\n        switch (Y >>> 3) {\n          case 1:\n            const ne = a.Struct_FieldsEntry.decode(G, G.uint32());\n            ne.value !== void 0 && (B.fields[ne.key] = ne.value);\n            break;\n          default:\n            G.skipType(Y & 7);\n            break;\n        }\n      }\n      return B;\n    },\n    fromJSON(V) {\n      return {\n        fields: $(V.fields) ? Object.entries(V.fields).reduce((q, [G, H]) => (q[G] = H, q), {}) : {}\n      };\n    },\n    toJSON(V) {\n      const q = {};\n      return q.fields = {}, V.fields && Object.entries(V.fields).forEach(([G, H]) => {\n        q.fields[G] = H;\n      }), q;\n    },\n    fromPartial(V) {\n      var q;\n      const G = E();\n      return G.fields = Object.entries((q = V.fields) !== null && q !== void 0 ? q : {}).reduce((H, [B, Y]) => (Y !== void 0 && (H[B] = Y), H), {}), G;\n    },\n    wrap(V) {\n      const q = E();\n      return V !== void 0 && Object.keys(V).forEach((G) => {\n        q.fields[G] = V[G];\n      }), q;\n    },\n    unwrap(V) {\n      const q = {};\n      return Object.keys(V.fields).forEach((G) => {\n        q[G] = V.fields[G];\n      }), q;\n    }\n  };\n  function _() {\n    return { key: \"\", value: void 0 };\n  }\n  a.Struct_FieldsEntry = {\n    encode(V, q = c.default.Writer.create()) {\n      return V.key !== \"\" && q.uint32(10).string(V.key), V.value !== void 0 && a.Value.encode(a.Value.wrap(V.value), q.uint32(18).fork()).ldelim(), q;\n    },\n    decode(V, q) {\n      const G = V instanceof c.default.Reader ? V : new c.default.Reader(V);\n      let H = q === void 0 ? G.len : G.pos + q;\n      const B = _();\n      for (; G.pos < H; ) {\n        const Y = G.uint32();\n        switch (Y >>> 3) {\n          case 1:\n            B.key = G.string();\n            break;\n          case 2:\n            B.value = a.Value.unwrap(a.Value.decode(G, G.uint32()));\n            break;\n          default:\n            G.skipType(Y & 7);\n            break;\n        }\n      }\n      return B;\n    },\n    fromJSON(V) {\n      return { key: J(V.key) ? String(V.key) : \"\", value: J(V == null ? void 0 : V.value) ? V.value : void 0 };\n    },\n    toJSON(V) {\n      const q = {};\n      return V.key !== void 0 && (q.key = V.key), V.value !== void 0 && (q.value = V.value), q;\n    },\n    fromPartial(V) {\n      var q, G;\n      const H = _();\n      return H.key = (q = V.key) !== null && q !== void 0 ? q : \"\", H.value = (G = V.value) !== null && G !== void 0 ? G : void 0, H;\n    }\n  };\n  function k() {\n    return {\n      nullValue: void 0,\n      numberValue: void 0,\n      stringValue: void 0,\n      boolValue: void 0,\n      structValue: void 0,\n      listValue: void 0\n    };\n  }\n  a.Value = {\n    encode(V, q = c.default.Writer.create()) {\n      return V.nullValue !== void 0 && q.uint32(8).int32(g(V.nullValue)), V.numberValue !== void 0 && q.uint32(17).double(V.numberValue), V.stringValue !== void 0 && q.uint32(26).string(V.stringValue), V.boolValue !== void 0 && q.uint32(32).bool(V.boolValue), V.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(V.structValue), q.uint32(42).fork()).ldelim(), V.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(V.listValue), q.uint32(50).fork()).ldelim(), q;\n    },\n    decode(V, q) {\n      const G = V instanceof c.default.Reader ? V : new c.default.Reader(V);\n      let H = q === void 0 ? G.len : G.pos + q;\n      const B = k();\n      for (; G.pos < H; ) {\n        const Y = G.uint32();\n        switch (Y >>> 3) {\n          case 1:\n            B.nullValue = v(G.int32());\n            break;\n          case 2:\n            B.numberValue = G.double();\n            break;\n          case 3:\n            B.stringValue = G.string();\n            break;\n          case 4:\n            B.boolValue = G.bool();\n            break;\n          case 5:\n            B.structValue = a.Struct.unwrap(a.Struct.decode(G, G.uint32()));\n            break;\n          case 6:\n            B.listValue = a.ListValue.unwrap(a.ListValue.decode(G, G.uint32()));\n            break;\n          default:\n            G.skipType(Y & 7);\n            break;\n        }\n      }\n      return B;\n    },\n    fromJSON(V) {\n      return {\n        nullValue: J(V.nullValue) ? v(V.nullValue) : void 0,\n        numberValue: J(V.numberValue) ? Number(V.numberValue) : void 0,\n        stringValue: J(V.stringValue) ? String(V.stringValue) : void 0,\n        boolValue: J(V.boolValue) ? !!V.boolValue : void 0,\n        structValue: $(V.structValue) ? V.structValue : void 0,\n        listValue: Array.isArray(V.listValue) ? [...V.listValue] : void 0\n      };\n    },\n    toJSON(V) {\n      const q = {};\n      return V.nullValue !== void 0 && (q.nullValue = V.nullValue !== void 0 ? S(V.nullValue) : void 0), V.numberValue !== void 0 && (q.numberValue = V.numberValue), V.stringValue !== void 0 && (q.stringValue = V.stringValue), V.boolValue !== void 0 && (q.boolValue = V.boolValue), V.structValue !== void 0 && (q.structValue = V.structValue), V.listValue !== void 0 && (q.listValue = V.listValue), q;\n    },\n    fromPartial(V) {\n      var q, G, H, B, Y, ne;\n      const Z = k();\n      return Z.nullValue = (q = V.nullValue) !== null && q !== void 0 ? q : void 0, Z.numberValue = (G = V.numberValue) !== null && G !== void 0 ? G : void 0, Z.stringValue = (H = V.stringValue) !== null && H !== void 0 ? H : void 0, Z.boolValue = (B = V.boolValue) !== null && B !== void 0 ? B : void 0, Z.structValue = (Y = V.structValue) !== null && Y !== void 0 ? Y : void 0, Z.listValue = (ne = V.listValue) !== null && ne !== void 0 ? ne : void 0, Z;\n    },\n    wrap(V) {\n      const q = k();\n      if (V === null)\n        q.nullValue = l.NULL_VALUE;\n      else if (typeof V == \"boolean\")\n        q.boolValue = V;\n      else if (typeof V == \"number\")\n        q.numberValue = V;\n      else if (typeof V == \"string\")\n        q.stringValue = V;\n      else if (Array.isArray(V))\n        q.listValue = V;\n      else if (typeof V == \"object\")\n        q.structValue = V;\n      else if (typeof V < \"u\")\n        throw new Error(\"Unsupported any value type: \" + typeof V);\n      return q;\n    },\n    unwrap(V) {\n      if ((V == null ? void 0 : V.stringValue) !== void 0)\n        return V.stringValue;\n      if ((V == null ? void 0 : V.numberValue) !== void 0)\n        return V.numberValue;\n      if ((V == null ? void 0 : V.boolValue) !== void 0)\n        return V.boolValue;\n      if ((V == null ? void 0 : V.structValue) !== void 0)\n        return V.structValue;\n      if ((V == null ? void 0 : V.listValue) !== void 0)\n        return V.listValue;\n      if ((V == null ? void 0 : V.nullValue) !== void 0)\n        return null;\n    }\n  };\n  function L() {\n    return { values: [] };\n  }\n  a.ListValue = {\n    encode(V, q = c.default.Writer.create()) {\n      for (const G of V.values)\n        a.Value.encode(a.Value.wrap(G), q.uint32(10).fork()).ldelim();\n      return q;\n    },\n    decode(V, q) {\n      const G = V instanceof c.default.Reader ? V : new c.default.Reader(V);\n      let H = q === void 0 ? G.len : G.pos + q;\n      const B = L();\n      for (; G.pos < H; ) {\n        const Y = G.uint32();\n        switch (Y >>> 3) {\n          case 1:\n            B.values.push(a.Value.unwrap(a.Value.decode(G, G.uint32())));\n            break;\n          default:\n            G.skipType(Y & 7);\n            break;\n        }\n      }\n      return B;\n    },\n    fromJSON(V) {\n      return { values: Array.isArray(V == null ? void 0 : V.values) ? [...V.values] : [] };\n    },\n    toJSON(V) {\n      const q = {};\n      return V.values ? q.values = V.values.map((G) => G) : q.values = [], q;\n    },\n    fromPartial(V) {\n      var q;\n      const G = L();\n      return G.values = ((q = V.values) === null || q === void 0 ? void 0 : q.map((H) => H)) || [], G;\n    },\n    wrap(V) {\n      const q = L();\n      return q.values = V ?? [], q;\n    },\n    unwrap(V) {\n      return V.values;\n    }\n  };\n  var M = (() => {\n    if (typeof M < \"u\")\n      return M;\n    if (typeof self < \"u\")\n      return self;\n    if (typeof window < \"u\")\n      return window;\n    if (typeof commonjsGlobal$1 < \"u\")\n      return commonjsGlobal$1;\n    throw \"Unable to locate global object\";\n  })();\n  function $(V) {\n    return typeof V == \"object\" && V !== null;\n  }\n  function J(V) {\n    return V != null;\n  }\n})(struct$1);\nvar timestamp$2 = {}, __importDefault$9 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(timestamp$2, \"__esModule\", { value: !0 });\ntimestamp$2.Timestamp = timestamp$2.protobufPackage = void 0;\nconst long_1$2 = __importDefault$9(umdExports), minimal_1$2 = __importDefault$9(minimal);\ntimestamp$2.protobufPackage = \"google.protobuf\";\nfunction createBaseTimestamp$1() {\n  return { seconds: 0, nanos: 0 };\n}\ntimestamp$2.Timestamp = {\n  encode(a, u = minimal_1$2.default.Writer.create()) {\n    return a.seconds !== 0 && u.uint32(8).int64(a.seconds), a.nanos !== 0 && u.uint32(16).int32(a.nanos), u;\n  },\n  decode(a, u) {\n    const c = a instanceof minimal_1$2.default.Reader ? a : new minimal_1$2.default.Reader(a);\n    let l = u === void 0 ? c.len : c.pos + u;\n    const v = createBaseTimestamp$1();\n    for (; c.pos < l; ) {\n      const S = c.uint32();\n      switch (S >>> 3) {\n        case 1:\n          v.seconds = longToNumber$2(c.int64());\n          break;\n        case 2:\n          v.nanos = c.int32();\n          break;\n        default:\n          c.skipType(S & 7);\n          break;\n      }\n    }\n    return v;\n  },\n  fromJSON(a) {\n    return {\n      seconds: isSet$2(a.seconds) ? Number(a.seconds) : 0,\n      nanos: isSet$2(a.nanos) ? Number(a.nanos) : 0\n    };\n  },\n  toJSON(a) {\n    const u = {};\n    return a.seconds !== void 0 && (u.seconds = Math.round(a.seconds)), a.nanos !== void 0 && (u.nanos = Math.round(a.nanos)), u;\n  },\n  fromPartial(a) {\n    var u, c;\n    const l = createBaseTimestamp$1();\n    return l.seconds = (u = a.seconds) !== null && u !== void 0 ? u : 0, l.nanos = (c = a.nanos) !== null && c !== void 0 ? c : 0, l;\n  }\n};\nvar globalThis$3 = (() => {\n  if (typeof globalThis$3 < \"u\")\n    return globalThis$3;\n  if (typeof self < \"u\")\n    return self;\n  if (typeof window < \"u\")\n    return window;\n  if (typeof commonjsGlobal$1 < \"u\")\n    return commonjsGlobal$1;\n  throw \"Unable to locate global object\";\n})();\nfunction longToNumber$2(a) {\n  if (a.gt(Number.MAX_SAFE_INTEGER))\n    throw new globalThis$3.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  return a.toNumber();\n}\nminimal_1$2.default.util.Long !== long_1$2.default && (minimal_1$2.default.util.Long = long_1$2.default, minimal_1$2.default.configure());\nfunction isSet$2(a) {\n  return a != null;\n}\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(p) {\n    return p && p.__esModule ? p : { default: p };\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.Role = a.regionToNumber = a.regionToJSON = a.regionFromJSON = a.Region = a.sourceTriggerActionToNumber = a.sourceTriggerActionToJSON = a.sourceTriggerActionFromJSON = a.SourceTriggerAction = a.s3ACLToNumber = a.s3ACLToJSON = a.s3ACLFromJSON = a.S3ACL = a.projectBroadcastPhaseToNumber = a.projectBroadcastPhaseToJSON = a.projectBroadcastPhaseFromJSON = a.ProjectBroadcastPhase = a.videoCodecRateControlModeToNumber = a.videoCodecRateControlModeToJSON = a.videoCodecRateControlModeFromJSON = a.VideoCodecRateControlMode = a.audioCodecToNumber = a.audioCodecToJSON = a.audioCodecFromJSON = a.AudioCodec = a.videoCodecProfileToNumber = a.videoCodecProfileToJSON = a.videoCodecProfileFromJSON = a.VideoCodecProfile = a.videoCodecToNumber = a.videoCodecToJSON = a.videoCodecFromJSON = a.VideoCodec = a.renderingQualityToNumber = a.renderingQualityToJSON = a.renderingQualityFromJSON = a.RenderingQuality = a.audioChannelLayoutToNumber = a.audioChannelLayoutToJSON = a.audioChannelLayoutFromJSON = a.AudioChannelLayout = a.videoColorSpaceToNumber = a.videoColorSpaceToJSON = a.videoColorSpaceFromJSON = a.VideoColorSpace = a.imageFormatToNumber = a.imageFormatToJSON = a.imageFormatFromJSON = a.ImageFormat = a.protobufPackage = void 0, a.ExternalComposition = a.SceneComposition = a.StudioSdkComposition = a.PreviewAddress = a.PreviewWebRtcAddress = a.PreviewHlsPullAddress = a.ProjectTrigger = a.WebRtcTrigger = a.SourceTrigger = a.DestinationAddress = a.S3StorageAddress = a.ObjectStoragePackaging = a.HlsPackaging = a.HlsLifecycle = a.HlsLifecycleVod = a.HlsLifecycleLive = a.DestinationAgoraPushAddress = a.DestinationSrtPushAddress = a.DestinationRtmpPushAddress = a.SourceAddress = a.SrtPullAddress = a.RtmpPullAddress = a.SrtPushAddress = a.SourceRtmpPushAddress = a.Encoding = a.AudioEncoding = a.VideoEncoding = a.VideoCodecRateControl = a.Rendering = a.AudioRendering = a.VideoRendering = a.eventTypeToNumber = a.eventTypeToJSON = a.eventTypeFromJSON = a.EventType = a.eventSubTypeToNumber = a.eventSubTypeToJSON = a.eventSubTypeFromJSON = a.EventSubType = a.connectStateToNumber = a.connectStateToJSON = a.connectStateFromJSON = a.ConnectState = a.projectBroadcastErrorToNumber = a.projectBroadcastErrorToJSON = a.projectBroadcastErrorFromJSON = a.ProjectBroadcastError = a.roleToNumber = a.roleToJSON = a.roleFromJSON = void 0, a.CreateSourceResponse = a.CreateSourceRequest = a.UpdateDestinationResponse = a.UpdateDestinationRequest = a.DeleteDestinationResponse = a.DeleteDestinationRequest = a.GetDestinationResponse = a.GetDestinationRequest = a.CreateDestinationResponse = a.CreateDestinationRequest = a.StopProjectWebRtcResponse = a.StopProjectWebRtcRequest = a.StartProjectWebRtcResponse = a.StartProjectWebRtcRequest = a.GetProjectBroadcastStatusResponse = a.GetProjectBroadcastStatusRequest = a.GetProjectBroadcastSnapshotResponse = a.GetProjectBroadcastSnapshotRequest = a.GetProjectResponse = a.GetProjectRequest = a.StopProjectBroadcastResponse = a.StopProjectBroadcastRequest = a.StartProjectBroadcastResponse = a.StartProjectBroadcastRequest = a.DeleteProjectResponse = a.DeleteProjectRequest = a.UpdateProjectResponse = a.UpdateProjectRequest = a.CreateProjectResponse = a.CreateProjectRequest = a.GetCollectionsResponse = a.GetCollectionsRequest = a.DeleteCollectionResponse = a.DeleteCollectionRequest = a.UpdateCollectionResponse = a.UpdateCollectionRequest = a.GetCollectionResponse = a.GetCollectionRequest = a.CreateCollectionResponse = a.CreateCollectionRequest = a.Collection = a.Project = a.Destination = a.Source = a.ProjectBroadcastStatus = a.LatLong = a.WebRtcAccess = a.WebRtc = a.HostedWebRtc = a.Composition = void 0, a.SourceAddEvent = a.SourceUpdateEvent = a.SourceDeleteEvent = a.SourceCreateEvent = a.CollectionUpdateEvent = a.CollectionDeleteEvent = a.CollectionCreateEvent = a.ProjectBroadcastStateEvent = a.ProjectUpdateEvent = a.ProjectDeleteEvent = a.ProjectCreateEvent = a.DestinationStateEvent = a.DestinationUpdateEvent = a.DestinationDeleteEvent = a.DestinationCreateEvent = a.GetTestTokenResponse = a.GetTestTokenRequest = a.GetJsonWebKeySetResponse = a.GetJsonWebKeySetRequest = a.JsonWebKey = a.GuestCodeRedirectResponse = a.GuestCodeRedirectRequest = a.GuestCode = a.RefreshAccessTokenResponse = a.RefreshAccessTokenRequest = a.CreateWebRtcAccessTokenResponse = a.CreateWebRtcAccessTokenRequest = a.CreateGuestAccessTokenResponse = a.CreateGuestAccessTokenRequest = a.GuestAccessToken = a.GuestAccessTokenExchange = a.GuestAccessTokenDirect = a.CreateAccessTokenResponse = a.CreateAccessTokenRequest = a.GetSourcePlaylistResponse = a.GetSourcePlaylistRequest = a.RemoveSourceFromProjectResponse = a.RemoveSourceFromProjectRequest = a.UpdateSourceResponse = a.UpdateSourceRequest = a.GetSourcesResponse = a.GetSourcesRequest = a.GetSourceResponse = a.GetSourceRequest = a.UpdateSourceInProjectResponse = a.UpdateSourceInProjectRequest = a.AddSourceToProjectResponse = a.AddSourceToProjectRequest = a.DeleteSourceResponse = a.DeleteSourceRequest = void 0, a.PublicAuthenticationServiceDefinition = a.PublicAuthenticationServiceClientImpl = a.AuthenticationServiceDefinition = a.AuthenticationServiceClientImpl = a.BackendAuthenticationServiceDefinition = a.BackendAuthenticationServiceClientImpl = a.SourceServiceDefinition = a.SourceServiceClientImpl = a.DestinationServiceDefinition = a.DestinationServiceClientImpl = a.ProjectServiceDefinition = a.ProjectServiceClientImpl = a.CollectionServiceDefinition = a.CollectionServiceClientImpl = a.LiveEvent = a.SourceEvent = a.ProjectEvent = a.DestinationEvent = a.CollectionEvent = a.SourceStateEvent = a.SourceRemoveEvent = void 0;\n  const c = u(minimal), l = httpbody, v = field_mask, S = struct$1, g = timestamp$2;\n  a.protobufPackage = \"live.v21\";\n  var E;\n  (function(p) {\n    p.IMAGE_FORMAT_UNSPECIFIED = \"IMAGE_FORMAT_UNSPECIFIED\", p.IMAGE_FORMAT_JPEG = \"IMAGE_FORMAT_JPEG\";\n  })(E = a.ImageFormat || (a.ImageFormat = {}));\n  function _(p) {\n    switch (p) {\n      case 0:\n      case \"IMAGE_FORMAT_UNSPECIFIED\":\n        return E.IMAGE_FORMAT_UNSPECIFIED;\n      case 1:\n      case \"IMAGE_FORMAT_JPEG\":\n        return E.IMAGE_FORMAT_JPEG;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum ImageFormat\");\n    }\n  }\n  a.imageFormatFromJSON = _;\n  function k(p) {\n    switch (p) {\n      case E.IMAGE_FORMAT_UNSPECIFIED:\n        return \"IMAGE_FORMAT_UNSPECIFIED\";\n      case E.IMAGE_FORMAT_JPEG:\n        return \"IMAGE_FORMAT_JPEG\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum ImageFormat\");\n    }\n  }\n  a.imageFormatToJSON = k;\n  function L(p) {\n    switch (p) {\n      case E.IMAGE_FORMAT_UNSPECIFIED:\n        return 0;\n      case E.IMAGE_FORMAT_JPEG:\n        return 1;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum ImageFormat\");\n    }\n  }\n  a.imageFormatToNumber = L;\n  var M;\n  (function(p) {\n    p.VIDEO_COLOR_SPACE_UNSPECIFIED = \"VIDEO_COLOR_SPACE_UNSPECIFIED\", p.VIDEO_COLOR_SPACE_YUV420 = \"VIDEO_COLOR_SPACE_YUV420\";\n  })(M = a.VideoColorSpace || (a.VideoColorSpace = {}));\n  function $(p) {\n    switch (p) {\n      case 0:\n      case \"VIDEO_COLOR_SPACE_UNSPECIFIED\":\n        return M.VIDEO_COLOR_SPACE_UNSPECIFIED;\n      case 1:\n      case \"VIDEO_COLOR_SPACE_YUV420\":\n        return M.VIDEO_COLOR_SPACE_YUV420;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum VideoColorSpace\");\n    }\n  }\n  a.videoColorSpaceFromJSON = $;\n  function J(p) {\n    switch (p) {\n      case M.VIDEO_COLOR_SPACE_UNSPECIFIED:\n        return \"VIDEO_COLOR_SPACE_UNSPECIFIED\";\n      case M.VIDEO_COLOR_SPACE_YUV420:\n        return \"VIDEO_COLOR_SPACE_YUV420\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum VideoColorSpace\");\n    }\n  }\n  a.videoColorSpaceToJSON = J;\n  function V(p) {\n    switch (p) {\n      case M.VIDEO_COLOR_SPACE_UNSPECIFIED:\n        return 0;\n      case M.VIDEO_COLOR_SPACE_YUV420:\n        return 1;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum VideoColorSpace\");\n    }\n  }\n  a.videoColorSpaceToNumber = V;\n  var q;\n  (function(p) {\n    p.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED = \"AUDIO_CHANNEL_LAYOUT_UNSPECIFIED\", p.AUDIO_CHANNEL_LAYOUT_STEREO = \"AUDIO_CHANNEL_LAYOUT_STEREO\";\n  })(q = a.AudioChannelLayout || (a.AudioChannelLayout = {}));\n  function G(p) {\n    switch (p) {\n      case 0:\n      case \"AUDIO_CHANNEL_LAYOUT_UNSPECIFIED\":\n        return q.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED;\n      case 1:\n      case \"AUDIO_CHANNEL_LAYOUT_STEREO\":\n        return q.AUDIO_CHANNEL_LAYOUT_STEREO;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum AudioChannelLayout\");\n    }\n  }\n  a.audioChannelLayoutFromJSON = G;\n  function H(p) {\n    switch (p) {\n      case q.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED:\n        return \"AUDIO_CHANNEL_LAYOUT_UNSPECIFIED\";\n      case q.AUDIO_CHANNEL_LAYOUT_STEREO:\n        return \"AUDIO_CHANNEL_LAYOUT_STEREO\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum AudioChannelLayout\");\n    }\n  }\n  a.audioChannelLayoutToJSON = H;\n  function B(p) {\n    switch (p) {\n      case q.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED:\n        return 0;\n      case q.AUDIO_CHANNEL_LAYOUT_STEREO:\n        return 1;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum AudioChannelLayout\");\n    }\n  }\n  a.audioChannelLayoutToNumber = B;\n  var Y;\n  (function(p) {\n    p.RENDERING_QUALITY_UNSPECIFIED = \"RENDERING_QUALITY_UNSPECIFIED\", p.RENDERING_QUALITY_STANDARD = \"RENDERING_QUALITY_STANDARD\", p.RENDERING_QUALITY_HIGH = \"RENDERING_QUALITY_HIGH\";\n  })(Y = a.RenderingQuality || (a.RenderingQuality = {}));\n  function ne(p) {\n    switch (p) {\n      case 0:\n      case \"RENDERING_QUALITY_UNSPECIFIED\":\n        return Y.RENDERING_QUALITY_UNSPECIFIED;\n      case 1:\n      case \"RENDERING_QUALITY_STANDARD\":\n        return Y.RENDERING_QUALITY_STANDARD;\n      case 2:\n      case \"RENDERING_QUALITY_HIGH\":\n        return Y.RENDERING_QUALITY_HIGH;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum RenderingQuality\");\n    }\n  }\n  a.renderingQualityFromJSON = ne;\n  function Z(p) {\n    switch (p) {\n      case Y.RENDERING_QUALITY_UNSPECIFIED:\n        return \"RENDERING_QUALITY_UNSPECIFIED\";\n      case Y.RENDERING_QUALITY_STANDARD:\n        return \"RENDERING_QUALITY_STANDARD\";\n      case Y.RENDERING_QUALITY_HIGH:\n        return \"RENDERING_QUALITY_HIGH\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum RenderingQuality\");\n    }\n  }\n  a.renderingQualityToJSON = Z;\n  function re(p) {\n    switch (p) {\n      case Y.RENDERING_QUALITY_UNSPECIFIED:\n        return 0;\n      case Y.RENDERING_QUALITY_STANDARD:\n        return 1;\n      case Y.RENDERING_QUALITY_HIGH:\n        return 2;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum RenderingQuality\");\n    }\n  }\n  a.renderingQualityToNumber = re;\n  var oe;\n  (function(p) {\n    p.VIDEO_CODEC_UNSPECIFIED = \"VIDEO_CODEC_UNSPECIFIED\", p.VIDEO_CODEC_H264 = \"VIDEO_CODEC_H264\";\n  })(oe = a.VideoCodec || (a.VideoCodec = {}));\n  function de(p) {\n    switch (p) {\n      case 0:\n      case \"VIDEO_CODEC_UNSPECIFIED\":\n        return oe.VIDEO_CODEC_UNSPECIFIED;\n      case 1:\n      case \"VIDEO_CODEC_H264\":\n        return oe.VIDEO_CODEC_H264;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum VideoCodec\");\n    }\n  }\n  a.videoCodecFromJSON = de;\n  function A(p) {\n    switch (p) {\n      case oe.VIDEO_CODEC_UNSPECIFIED:\n        return \"VIDEO_CODEC_UNSPECIFIED\";\n      case oe.VIDEO_CODEC_H264:\n        return \"VIDEO_CODEC_H264\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum VideoCodec\");\n    }\n  }\n  a.videoCodecToJSON = A;\n  function N(p) {\n    switch (p) {\n      case oe.VIDEO_CODEC_UNSPECIFIED:\n        return 0;\n      case oe.VIDEO_CODEC_H264:\n        return 1;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum VideoCodec\");\n    }\n  }\n  a.videoCodecToNumber = N;\n  var D;\n  (function(p) {\n    p.VIDEO_CODEC_PROFILE_UNSPECIFIED = \"VIDEO_CODEC_PROFILE_UNSPECIFIED\", p.VIDEO_CODEC_PROFILE_BASELINE = \"VIDEO_CODEC_PROFILE_BASELINE\", p.VIDEO_CODEC_PROFILE_MAIN = \"VIDEO_CODEC_PROFILE_MAIN\", p.VIDEO_CODEC_PROFILE_HIGH = \"VIDEO_CODEC_PROFILE_HIGH\";\n  })(D = a.VideoCodecProfile || (a.VideoCodecProfile = {}));\n  function W(p) {\n    switch (p) {\n      case 0:\n      case \"VIDEO_CODEC_PROFILE_UNSPECIFIED\":\n        return D.VIDEO_CODEC_PROFILE_UNSPECIFIED;\n      case 2:\n      case \"VIDEO_CODEC_PROFILE_BASELINE\":\n        return D.VIDEO_CODEC_PROFILE_BASELINE;\n      case 3:\n      case \"VIDEO_CODEC_PROFILE_MAIN\":\n        return D.VIDEO_CODEC_PROFILE_MAIN;\n      case 4:\n      case \"VIDEO_CODEC_PROFILE_HIGH\":\n        return D.VIDEO_CODEC_PROFILE_HIGH;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum VideoCodecProfile\");\n    }\n  }\n  a.videoCodecProfileFromJSON = W;\n  function ee(p) {\n    switch (p) {\n      case D.VIDEO_CODEC_PROFILE_UNSPECIFIED:\n        return \"VIDEO_CODEC_PROFILE_UNSPECIFIED\";\n      case D.VIDEO_CODEC_PROFILE_BASELINE:\n        return \"VIDEO_CODEC_PROFILE_BASELINE\";\n      case D.VIDEO_CODEC_PROFILE_MAIN:\n        return \"VIDEO_CODEC_PROFILE_MAIN\";\n      case D.VIDEO_CODEC_PROFILE_HIGH:\n        return \"VIDEO_CODEC_PROFILE_HIGH\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum VideoCodecProfile\");\n    }\n  }\n  a.videoCodecProfileToJSON = ee;\n  function ae(p) {\n    switch (p) {\n      case D.VIDEO_CODEC_PROFILE_UNSPECIFIED:\n        return 0;\n      case D.VIDEO_CODEC_PROFILE_BASELINE:\n        return 2;\n      case D.VIDEO_CODEC_PROFILE_MAIN:\n        return 3;\n      case D.VIDEO_CODEC_PROFILE_HIGH:\n        return 4;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum VideoCodecProfile\");\n    }\n  }\n  a.videoCodecProfileToNumber = ae;\n  var ye;\n  (function(p) {\n    p.AUDIO_CODEC_UNSPECIFIED = \"AUDIO_CODEC_UNSPECIFIED\", p.AUDIO_CODEC_AAC = \"AUDIO_CODEC_AAC\";\n  })(ye = a.AudioCodec || (a.AudioCodec = {}));\n  function he(p) {\n    switch (p) {\n      case 0:\n      case \"AUDIO_CODEC_UNSPECIFIED\":\n        return ye.AUDIO_CODEC_UNSPECIFIED;\n      case 1:\n      case \"AUDIO_CODEC_AAC\":\n        return ye.AUDIO_CODEC_AAC;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum AudioCodec\");\n    }\n  }\n  a.audioCodecFromJSON = he;\n  function le(p) {\n    switch (p) {\n      case ye.AUDIO_CODEC_UNSPECIFIED:\n        return \"AUDIO_CODEC_UNSPECIFIED\";\n      case ye.AUDIO_CODEC_AAC:\n        return \"AUDIO_CODEC_AAC\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum AudioCodec\");\n    }\n  }\n  a.audioCodecToJSON = le;\n  function we(p) {\n    switch (p) {\n      case ye.AUDIO_CODEC_UNSPECIFIED:\n        return 0;\n      case ye.AUDIO_CODEC_AAC:\n        return 1;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum AudioCodec\");\n    }\n  }\n  a.audioCodecToNumber = we;\n  var Be;\n  (function(p) {\n    p.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED = \"VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED\", p.VIDEO_CODEC_RATE_CONTROL_MODE_CBR = \"VIDEO_CODEC_RATE_CONTROL_MODE_CBR\";\n  })(Be = a.VideoCodecRateControlMode || (a.VideoCodecRateControlMode = {}));\n  function Ne(p) {\n    switch (p) {\n      case 0:\n      case \"VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED\":\n        return Be.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED;\n      case 1:\n      case \"VIDEO_CODEC_RATE_CONTROL_MODE_CBR\":\n        return Be.VIDEO_CODEC_RATE_CONTROL_MODE_CBR;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum VideoCodecRateControlMode\");\n    }\n  }\n  a.videoCodecRateControlModeFromJSON = Ne;\n  function Le(p) {\n    switch (p) {\n      case Be.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED:\n        return \"VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED\";\n      case Be.VIDEO_CODEC_RATE_CONTROL_MODE_CBR:\n        return \"VIDEO_CODEC_RATE_CONTROL_MODE_CBR\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum VideoCodecRateControlMode\");\n    }\n  }\n  a.videoCodecRateControlModeToJSON = Le;\n  function $e(p) {\n    switch (p) {\n      case Be.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED:\n        return 0;\n      case Be.VIDEO_CODEC_RATE_CONTROL_MODE_CBR:\n        return 1;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum VideoCodecRateControlMode\");\n    }\n  }\n  a.videoCodecRateControlModeToNumber = $e;\n  var Ue;\n  (function(p) {\n    p.PROJECT_BROADCAST_PHASE_UNSPECIFIED = \"PROJECT_BROADCAST_PHASE_UNSPECIFIED\", p.PROJECT_BROADCAST_PHASE_NOT_RUNNING = \"PROJECT_BROADCAST_PHASE_NOT_RUNNING\", p.PROJECT_BROADCAST_PHASE_WAITING = \"PROJECT_BROADCAST_PHASE_WAITING\", p.PROJECT_BROADCAST_PHASE_STARTING = \"PROJECT_BROADCAST_PHASE_STARTING\", p.PROJECT_BROADCAST_PHASE_RUNNING = \"PROJECT_BROADCAST_PHASE_RUNNING\", p.PROJECT_BROADCAST_PHASE_STOPPING = \"PROJECT_BROADCAST_PHASE_STOPPING\", p.PROJECT_BROADCAST_PHASE_STOPPED = \"PROJECT_BROADCAST_PHASE_STOPPED\", p.PROJECT_BROADCAST_PHASE_ARCHIVED = \"PROJECT_BROADCAST_PHASE_ARCHIVED\";\n  })(Ue = a.ProjectBroadcastPhase || (a.ProjectBroadcastPhase = {}));\n  function Ge(p) {\n    switch (p) {\n      case 0:\n      case \"PROJECT_BROADCAST_PHASE_UNSPECIFIED\":\n        return Ue.PROJECT_BROADCAST_PHASE_UNSPECIFIED;\n      case 1:\n      case \"PROJECT_BROADCAST_PHASE_NOT_RUNNING\":\n        return Ue.PROJECT_BROADCAST_PHASE_NOT_RUNNING;\n      case 2:\n      case \"PROJECT_BROADCAST_PHASE_WAITING\":\n        return Ue.PROJECT_BROADCAST_PHASE_WAITING;\n      case 3:\n      case \"PROJECT_BROADCAST_PHASE_STARTING\":\n        return Ue.PROJECT_BROADCAST_PHASE_STARTING;\n      case 4:\n      case \"PROJECT_BROADCAST_PHASE_RUNNING\":\n        return Ue.PROJECT_BROADCAST_PHASE_RUNNING;\n      case 5:\n      case \"PROJECT_BROADCAST_PHASE_STOPPING\":\n        return Ue.PROJECT_BROADCAST_PHASE_STOPPING;\n      case 6:\n      case \"PROJECT_BROADCAST_PHASE_STOPPED\":\n        return Ue.PROJECT_BROADCAST_PHASE_STOPPED;\n      case 7:\n      case \"PROJECT_BROADCAST_PHASE_ARCHIVED\":\n        return Ue.PROJECT_BROADCAST_PHASE_ARCHIVED;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum ProjectBroadcastPhase\");\n    }\n  }\n  a.projectBroadcastPhaseFromJSON = Ge;\n  function He(p) {\n    switch (p) {\n      case Ue.PROJECT_BROADCAST_PHASE_UNSPECIFIED:\n        return \"PROJECT_BROADCAST_PHASE_UNSPECIFIED\";\n      case Ue.PROJECT_BROADCAST_PHASE_NOT_RUNNING:\n        return \"PROJECT_BROADCAST_PHASE_NOT_RUNNING\";\n      case Ue.PROJECT_BROADCAST_PHASE_WAITING:\n        return \"PROJECT_BROADCAST_PHASE_WAITING\";\n      case Ue.PROJECT_BROADCAST_PHASE_STARTING:\n        return \"PROJECT_BROADCAST_PHASE_STARTING\";\n      case Ue.PROJECT_BROADCAST_PHASE_RUNNING:\n        return \"PROJECT_BROADCAST_PHASE_RUNNING\";\n      case Ue.PROJECT_BROADCAST_PHASE_STOPPING:\n        return \"PROJECT_BROADCAST_PHASE_STOPPING\";\n      case Ue.PROJECT_BROADCAST_PHASE_STOPPED:\n        return \"PROJECT_BROADCAST_PHASE_STOPPED\";\n      case Ue.PROJECT_BROADCAST_PHASE_ARCHIVED:\n        return \"PROJECT_BROADCAST_PHASE_ARCHIVED\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum ProjectBroadcastPhase\");\n    }\n  }\n  a.projectBroadcastPhaseToJSON = He;\n  function Ve(p) {\n    switch (p) {\n      case Ue.PROJECT_BROADCAST_PHASE_UNSPECIFIED:\n        return 0;\n      case Ue.PROJECT_BROADCAST_PHASE_NOT_RUNNING:\n        return 1;\n      case Ue.PROJECT_BROADCAST_PHASE_WAITING:\n        return 2;\n      case Ue.PROJECT_BROADCAST_PHASE_STARTING:\n        return 3;\n      case Ue.PROJECT_BROADCAST_PHASE_RUNNING:\n        return 4;\n      case Ue.PROJECT_BROADCAST_PHASE_STOPPING:\n        return 5;\n      case Ue.PROJECT_BROADCAST_PHASE_STOPPED:\n        return 6;\n      case Ue.PROJECT_BROADCAST_PHASE_ARCHIVED:\n        return 7;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum ProjectBroadcastPhase\");\n    }\n  }\n  a.projectBroadcastPhaseToNumber = Ve;\n  var be;\n  (function(p) {\n    p.S3ACL_UNSPECIFIED = \"S3ACL_UNSPECIFIED\", p.S3ACL_PRIVATE = \"S3ACL_PRIVATE\", p.S3ACL_PUBLIC_READ = \"S3ACL_PUBLIC_READ\", p.S3ACL_PUBLIC_READ_WRITE = \"S3ACL_PUBLIC_READ_WRITE\", p.S3ACL_AUTHENTICATED_READ = \"S3ACL_AUTHENTICATED_READ\", p.S3ACL_BUCKET_OWNER_READ = \"S3ACL_BUCKET_OWNER_READ\", p.S3ACL_BUCKET_OWNER_FULL_CONTROL = \"S3ACL_BUCKET_OWNER_FULL_CONTROL\";\n  })(be = a.S3ACL || (a.S3ACL = {}));\n  function Ae(p) {\n    switch (p) {\n      case 0:\n      case \"S3ACL_UNSPECIFIED\":\n        return be.S3ACL_UNSPECIFIED;\n      case 1:\n      case \"S3ACL_PRIVATE\":\n        return be.S3ACL_PRIVATE;\n      case 2:\n      case \"S3ACL_PUBLIC_READ\":\n        return be.S3ACL_PUBLIC_READ;\n      case 3:\n      case \"S3ACL_PUBLIC_READ_WRITE\":\n        return be.S3ACL_PUBLIC_READ_WRITE;\n      case 4:\n      case \"S3ACL_AUTHENTICATED_READ\":\n        return be.S3ACL_AUTHENTICATED_READ;\n      case 5:\n      case \"S3ACL_BUCKET_OWNER_READ\":\n        return be.S3ACL_BUCKET_OWNER_READ;\n      case 6:\n      case \"S3ACL_BUCKET_OWNER_FULL_CONTROL\":\n        return be.S3ACL_BUCKET_OWNER_FULL_CONTROL;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum S3ACL\");\n    }\n  }\n  a.s3ACLFromJSON = Ae;\n  function qe(p) {\n    switch (p) {\n      case be.S3ACL_UNSPECIFIED:\n        return \"S3ACL_UNSPECIFIED\";\n      case be.S3ACL_PRIVATE:\n        return \"S3ACL_PRIVATE\";\n      case be.S3ACL_PUBLIC_READ:\n        return \"S3ACL_PUBLIC_READ\";\n      case be.S3ACL_PUBLIC_READ_WRITE:\n        return \"S3ACL_PUBLIC_READ_WRITE\";\n      case be.S3ACL_AUTHENTICATED_READ:\n        return \"S3ACL_AUTHENTICATED_READ\";\n      case be.S3ACL_BUCKET_OWNER_READ:\n        return \"S3ACL_BUCKET_OWNER_READ\";\n      case be.S3ACL_BUCKET_OWNER_FULL_CONTROL:\n        return \"S3ACL_BUCKET_OWNER_FULL_CONTROL\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum S3ACL\");\n    }\n  }\n  a.s3ACLToJSON = qe;\n  function xe(p) {\n    switch (p) {\n      case be.S3ACL_UNSPECIFIED:\n        return 0;\n      case be.S3ACL_PRIVATE:\n        return 1;\n      case be.S3ACL_PUBLIC_READ:\n        return 2;\n      case be.S3ACL_PUBLIC_READ_WRITE:\n        return 3;\n      case be.S3ACL_AUTHENTICATED_READ:\n        return 4;\n      case be.S3ACL_BUCKET_OWNER_READ:\n        return 5;\n      case be.S3ACL_BUCKET_OWNER_FULL_CONTROL:\n        return 6;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum S3ACL\");\n    }\n  }\n  a.s3ACLToNumber = xe;\n  var Pe;\n  (function(p) {\n    p.SOURCE_TRIGGER_ACTION_UNSPECIFIED = \"SOURCE_TRIGGER_ACTION_UNSPECIFIED\", p.SOURCE_TRIGGER_ACTION_IGNORE = \"SOURCE_TRIGGER_ACTION_IGNORE\", p.SOURCE_TRIGGER_ACTION_OR = \"SOURCE_TRIGGER_ACTION_OR\";\n  })(Pe = a.SourceTriggerAction || (a.SourceTriggerAction = {}));\n  function C(p) {\n    switch (p) {\n      case 0:\n      case \"SOURCE_TRIGGER_ACTION_UNSPECIFIED\":\n        return Pe.SOURCE_TRIGGER_ACTION_UNSPECIFIED;\n      case 1:\n      case \"SOURCE_TRIGGER_ACTION_IGNORE\":\n        return Pe.SOURCE_TRIGGER_ACTION_IGNORE;\n      case 3:\n      case \"SOURCE_TRIGGER_ACTION_OR\":\n        return Pe.SOURCE_TRIGGER_ACTION_OR;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum SourceTriggerAction\");\n    }\n  }\n  a.sourceTriggerActionFromJSON = C;\n  function x(p) {\n    switch (p) {\n      case Pe.SOURCE_TRIGGER_ACTION_UNSPECIFIED:\n        return \"SOURCE_TRIGGER_ACTION_UNSPECIFIED\";\n      case Pe.SOURCE_TRIGGER_ACTION_IGNORE:\n        return \"SOURCE_TRIGGER_ACTION_IGNORE\";\n      case Pe.SOURCE_TRIGGER_ACTION_OR:\n        return \"SOURCE_TRIGGER_ACTION_OR\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum SourceTriggerAction\");\n    }\n  }\n  a.sourceTriggerActionToJSON = x;\n  function Q(p) {\n    switch (p) {\n      case Pe.SOURCE_TRIGGER_ACTION_UNSPECIFIED:\n        return 0;\n      case Pe.SOURCE_TRIGGER_ACTION_IGNORE:\n        return 1;\n      case Pe.SOURCE_TRIGGER_ACTION_OR:\n        return 3;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum SourceTriggerAction\");\n    }\n  }\n  a.sourceTriggerActionToNumber = Q;\n  var Se;\n  (function(p) {\n    p.REGION_UNSPECIFIED = \"REGION_UNSPECIFIED\", p.REGION_US_EAST_1 = \"REGION_US_EAST_1\", p.REGION_US_EAST_2 = \"REGION_US_EAST_2\", p.REGION_US_WEST_1 = \"REGION_US_WEST_1\", p.REGION_US_WEST_2 = \"REGION_US_WEST_2\", p.REGION_US_CENTRAL_1 = \"REGION_US_CENTRAL_1\", p.REGION_AP_SOUTHEAST_1 = \"REGION_AP_SOUTHEAST_1\", p.REGION_AP_SOUTHEAST_2 = \"REGION_AP_SOUTHEAST_2\", p.REGION_AP_SOUTH_1 = \"REGION_AP_SOUTH_1\", p.REGION_CA_EAST_1 = \"REGION_CA_EAST_1\", p.REGION_EU_CENTRAL_1 = \"REGION_EU_CENTRAL_1\", p.REGION_EU_WEST_1 = \"REGION_EU_WEST_1\";\n  })(Se = a.Region || (a.Region = {}));\n  function me(p) {\n    switch (p) {\n      case 0:\n      case \"REGION_UNSPECIFIED\":\n        return Se.REGION_UNSPECIFIED;\n      case 1:\n      case \"REGION_US_EAST_1\":\n        return Se.REGION_US_EAST_1;\n      case 2:\n      case \"REGION_US_EAST_2\":\n        return Se.REGION_US_EAST_2;\n      case 3:\n      case \"REGION_US_WEST_1\":\n        return Se.REGION_US_WEST_1;\n      case 4:\n      case \"REGION_US_WEST_2\":\n        return Se.REGION_US_WEST_2;\n      case 5:\n      case \"REGION_US_CENTRAL_1\":\n        return Se.REGION_US_CENTRAL_1;\n      case 10:\n      case \"REGION_AP_SOUTHEAST_1\":\n        return Se.REGION_AP_SOUTHEAST_1;\n      case 11:\n      case \"REGION_AP_SOUTHEAST_2\":\n        return Se.REGION_AP_SOUTHEAST_2;\n      case 15:\n      case \"REGION_AP_SOUTH_1\":\n        return Se.REGION_AP_SOUTH_1;\n      case 20:\n      case \"REGION_CA_EAST_1\":\n        return Se.REGION_CA_EAST_1;\n      case 30:\n      case \"REGION_EU_CENTRAL_1\":\n        return Se.REGION_EU_CENTRAL_1;\n      case 31:\n      case \"REGION_EU_WEST_1\":\n        return Se.REGION_EU_WEST_1;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum Region\");\n    }\n  }\n  a.regionFromJSON = me;\n  function Ie(p) {\n    switch (p) {\n      case Se.REGION_UNSPECIFIED:\n        return \"REGION_UNSPECIFIED\";\n      case Se.REGION_US_EAST_1:\n        return \"REGION_US_EAST_1\";\n      case Se.REGION_US_EAST_2:\n        return \"REGION_US_EAST_2\";\n      case Se.REGION_US_WEST_1:\n        return \"REGION_US_WEST_1\";\n      case Se.REGION_US_WEST_2:\n        return \"REGION_US_WEST_2\";\n      case Se.REGION_US_CENTRAL_1:\n        return \"REGION_US_CENTRAL_1\";\n      case Se.REGION_AP_SOUTHEAST_1:\n        return \"REGION_AP_SOUTHEAST_1\";\n      case Se.REGION_AP_SOUTHEAST_2:\n        return \"REGION_AP_SOUTHEAST_2\";\n      case Se.REGION_AP_SOUTH_1:\n        return \"REGION_AP_SOUTH_1\";\n      case Se.REGION_CA_EAST_1:\n        return \"REGION_CA_EAST_1\";\n      case Se.REGION_EU_CENTRAL_1:\n        return \"REGION_EU_CENTRAL_1\";\n      case Se.REGION_EU_WEST_1:\n        return \"REGION_EU_WEST_1\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum Region\");\n    }\n  }\n  a.regionToJSON = Ie;\n  function at(p) {\n    switch (p) {\n      case Se.REGION_UNSPECIFIED:\n        return 0;\n      case Se.REGION_US_EAST_1:\n        return 1;\n      case Se.REGION_US_EAST_2:\n        return 2;\n      case Se.REGION_US_WEST_1:\n        return 3;\n      case Se.REGION_US_WEST_2:\n        return 4;\n      case Se.REGION_US_CENTRAL_1:\n        return 5;\n      case Se.REGION_AP_SOUTHEAST_1:\n        return 10;\n      case Se.REGION_AP_SOUTHEAST_2:\n        return 11;\n      case Se.REGION_AP_SOUTH_1:\n        return 15;\n      case Se.REGION_CA_EAST_1:\n        return 20;\n      case Se.REGION_EU_CENTRAL_1:\n        return 30;\n      case Se.REGION_EU_WEST_1:\n        return 31;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum Region\");\n    }\n  }\n  a.regionToNumber = at;\n  var Ye;\n  (function(p) {\n    p.ROLE_UNSPECIFIED = \"ROLE_UNSPECIFIED\", p.ROLE_HOST = \"ROLE_HOST\", p.ROLE_COHOST = \"ROLE_COHOST\", p.ROLE_CONTRIBUTOR = \"ROLE_CONTRIBUTOR\", p.ROLE_GUEST = \"ROLE_GUEST\", p.ROLE_VIEWER = \"ROLE_VIEWER\", p.ROLE_RENDERER = \"ROLE_RENDERER\", p.ROLE_PLATFORM = \"ROLE_PLATFORM\", p.ROLE_IMPERSONATE = \"ROLE_IMPERSONATE\";\n  })(Ye = a.Role || (a.Role = {}));\n  function je(p) {\n    switch (p) {\n      case 0:\n      case \"ROLE_UNSPECIFIED\":\n        return Ye.ROLE_UNSPECIFIED;\n      case 1:\n      case \"ROLE_HOST\":\n        return Ye.ROLE_HOST;\n      case 2:\n      case \"ROLE_COHOST\":\n        return Ye.ROLE_COHOST;\n      case 3:\n      case \"ROLE_CONTRIBUTOR\":\n        return Ye.ROLE_CONTRIBUTOR;\n      case 4:\n      case \"ROLE_GUEST\":\n        return Ye.ROLE_GUEST;\n      case 5:\n      case \"ROLE_VIEWER\":\n        return Ye.ROLE_VIEWER;\n      case 6:\n      case \"ROLE_RENDERER\":\n        return Ye.ROLE_RENDERER;\n      case 7:\n      case \"ROLE_PLATFORM\":\n        return Ye.ROLE_PLATFORM;\n      case 8:\n      case \"ROLE_IMPERSONATE\":\n        return Ye.ROLE_IMPERSONATE;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum Role\");\n    }\n  }\n  a.roleFromJSON = je;\n  function tt(p) {\n    switch (p) {\n      case Ye.ROLE_UNSPECIFIED:\n        return \"ROLE_UNSPECIFIED\";\n      case Ye.ROLE_HOST:\n        return \"ROLE_HOST\";\n      case Ye.ROLE_COHOST:\n        return \"ROLE_COHOST\";\n      case Ye.ROLE_CONTRIBUTOR:\n        return \"ROLE_CONTRIBUTOR\";\n      case Ye.ROLE_GUEST:\n        return \"ROLE_GUEST\";\n      case Ye.ROLE_VIEWER:\n        return \"ROLE_VIEWER\";\n      case Ye.ROLE_RENDERER:\n        return \"ROLE_RENDERER\";\n      case Ye.ROLE_PLATFORM:\n        return \"ROLE_PLATFORM\";\n      case Ye.ROLE_IMPERSONATE:\n        return \"ROLE_IMPERSONATE\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum Role\");\n    }\n  }\n  a.roleToJSON = tt;\n  function Oe(p) {\n    switch (p) {\n      case Ye.ROLE_UNSPECIFIED:\n        return 0;\n      case Ye.ROLE_HOST:\n        return 1;\n      case Ye.ROLE_COHOST:\n        return 2;\n      case Ye.ROLE_CONTRIBUTOR:\n        return 3;\n      case Ye.ROLE_GUEST:\n        return 4;\n      case Ye.ROLE_VIEWER:\n        return 5;\n      case Ye.ROLE_RENDERER:\n        return 6;\n      case Ye.ROLE_PLATFORM:\n        return 7;\n      case Ye.ROLE_IMPERSONATE:\n        return 8;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum Role\");\n    }\n  }\n  a.roleToNumber = Oe;\n  var P;\n  (function(p) {\n    p.PROJECT_BROADCAST_ERROR_UNSPECIFIED = \"PROJECT_BROADCAST_ERROR_UNSPECIFIED\", p.PROJECT_BROADCAST_ERROR_INTERNAL = \"PROJECT_BROADCAST_ERROR_INTERNAL\", p.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED = \"PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED\";\n  })(P = a.ProjectBroadcastError || (a.ProjectBroadcastError = {}));\n  function X(p) {\n    switch (p) {\n      case 0:\n      case \"PROJECT_BROADCAST_ERROR_UNSPECIFIED\":\n        return P.PROJECT_BROADCAST_ERROR_UNSPECIFIED;\n      case 1:\n      case \"PROJECT_BROADCAST_ERROR_INTERNAL\":\n        return P.PROJECT_BROADCAST_ERROR_INTERNAL;\n      case 2:\n      case \"PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED\":\n        return P.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum ProjectBroadcastError\");\n    }\n  }\n  a.projectBroadcastErrorFromJSON = X;\n  function ie(p) {\n    switch (p) {\n      case P.PROJECT_BROADCAST_ERROR_UNSPECIFIED:\n        return \"PROJECT_BROADCAST_ERROR_UNSPECIFIED\";\n      case P.PROJECT_BROADCAST_ERROR_INTERNAL:\n        return \"PROJECT_BROADCAST_ERROR_INTERNAL\";\n      case P.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED:\n        return \"PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum ProjectBroadcastError\");\n    }\n  }\n  a.projectBroadcastErrorToJSON = ie;\n  function Ee(p) {\n    switch (p) {\n      case P.PROJECT_BROADCAST_ERROR_UNSPECIFIED:\n        return 0;\n      case P.PROJECT_BROADCAST_ERROR_INTERNAL:\n        return 1;\n      case P.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED:\n        return 2;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum ProjectBroadcastError\");\n    }\n  }\n  a.projectBroadcastErrorToNumber = Ee;\n  var ue;\n  (function(p) {\n    p.CONNECT_STATE_UNSPECIFIED = \"CONNECT_STATE_UNSPECIFIED\", p.CONNECT_STATE_CONNECTED = \"CONNECT_STATE_CONNECTED\", p.CONNECT_STATE_DISCONNECTED = \"CONNECT_STATE_DISCONNECTED\";\n  })(ue = a.ConnectState || (a.ConnectState = {}));\n  function O(p) {\n    switch (p) {\n      case 0:\n      case \"CONNECT_STATE_UNSPECIFIED\":\n        return ue.CONNECT_STATE_UNSPECIFIED;\n      case 1:\n      case \"CONNECT_STATE_CONNECTED\":\n        return ue.CONNECT_STATE_CONNECTED;\n      case 2:\n      case \"CONNECT_STATE_DISCONNECTED\":\n        return ue.CONNECT_STATE_DISCONNECTED;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum ConnectState\");\n    }\n  }\n  a.connectStateFromJSON = O;\n  function j(p) {\n    switch (p) {\n      case ue.CONNECT_STATE_UNSPECIFIED:\n        return \"CONNECT_STATE_UNSPECIFIED\";\n      case ue.CONNECT_STATE_CONNECTED:\n        return \"CONNECT_STATE_CONNECTED\";\n      case ue.CONNECT_STATE_DISCONNECTED:\n        return \"CONNECT_STATE_DISCONNECTED\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum ConnectState\");\n    }\n  }\n  a.connectStateToJSON = j;\n  function se(p) {\n    switch (p) {\n      case ue.CONNECT_STATE_UNSPECIFIED:\n        return 0;\n      case ue.CONNECT_STATE_CONNECTED:\n        return 1;\n      case ue.CONNECT_STATE_DISCONNECTED:\n        return 2;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum ConnectState\");\n    }\n  }\n  a.connectStateToNumber = se;\n  var _e;\n  (function(p) {\n    p.EVENT_SUB_TYPE_UNSPECIFIED = \"EVENT_SUB_TYPE_UNSPECIFIED\", p.EVENT_SUB_TYPE_CREATE = \"EVENT_SUB_TYPE_CREATE\", p.EVENT_SUB_TYPE_UPDATE = \"EVENT_SUB_TYPE_UPDATE\", p.EVENT_SUB_TYPE_DELETE = \"EVENT_SUB_TYPE_DELETE\", p.EVENT_SUB_TYPE_ADD = \"EVENT_SUB_TYPE_ADD\", p.EVENT_SUB_TYPE_REMOVE = \"EVENT_SUB_TYPE_REMOVE\", p.EVENT_SUB_TYPE_STATE = \"EVENT_SUB_TYPE_STATE\";\n  })(_e = a.EventSubType || (a.EventSubType = {}));\n  function ve(p) {\n    switch (p) {\n      case 0:\n      case \"EVENT_SUB_TYPE_UNSPECIFIED\":\n        return _e.EVENT_SUB_TYPE_UNSPECIFIED;\n      case 1:\n      case \"EVENT_SUB_TYPE_CREATE\":\n        return _e.EVENT_SUB_TYPE_CREATE;\n      case 2:\n      case \"EVENT_SUB_TYPE_UPDATE\":\n        return _e.EVENT_SUB_TYPE_UPDATE;\n      case 3:\n      case \"EVENT_SUB_TYPE_DELETE\":\n        return _e.EVENT_SUB_TYPE_DELETE;\n      case 4:\n      case \"EVENT_SUB_TYPE_ADD\":\n        return _e.EVENT_SUB_TYPE_ADD;\n      case 5:\n      case \"EVENT_SUB_TYPE_REMOVE\":\n        return _e.EVENT_SUB_TYPE_REMOVE;\n      case 6:\n      case \"EVENT_SUB_TYPE_STATE\":\n        return _e.EVENT_SUB_TYPE_STATE;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum EventSubType\");\n    }\n  }\n  a.eventSubTypeFromJSON = ve;\n  function De(p) {\n    switch (p) {\n      case _e.EVENT_SUB_TYPE_UNSPECIFIED:\n        return \"EVENT_SUB_TYPE_UNSPECIFIED\";\n      case _e.EVENT_SUB_TYPE_CREATE:\n        return \"EVENT_SUB_TYPE_CREATE\";\n      case _e.EVENT_SUB_TYPE_UPDATE:\n        return \"EVENT_SUB_TYPE_UPDATE\";\n      case _e.EVENT_SUB_TYPE_DELETE:\n        return \"EVENT_SUB_TYPE_DELETE\";\n      case _e.EVENT_SUB_TYPE_ADD:\n        return \"EVENT_SUB_TYPE_ADD\";\n      case _e.EVENT_SUB_TYPE_REMOVE:\n        return \"EVENT_SUB_TYPE_REMOVE\";\n      case _e.EVENT_SUB_TYPE_STATE:\n        return \"EVENT_SUB_TYPE_STATE\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum EventSubType\");\n    }\n  }\n  a.eventSubTypeToJSON = De;\n  function Ze(p) {\n    switch (p) {\n      case _e.EVENT_SUB_TYPE_UNSPECIFIED:\n        return 0;\n      case _e.EVENT_SUB_TYPE_CREATE:\n        return 1;\n      case _e.EVENT_SUB_TYPE_UPDATE:\n        return 2;\n      case _e.EVENT_SUB_TYPE_DELETE:\n        return 3;\n      case _e.EVENT_SUB_TYPE_ADD:\n        return 4;\n      case _e.EVENT_SUB_TYPE_REMOVE:\n        return 5;\n      case _e.EVENT_SUB_TYPE_STATE:\n        return 6;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum EventSubType\");\n    }\n  }\n  a.eventSubTypeToNumber = Ze;\n  var Qe;\n  (function(p) {\n    p.EVENT_TYPE_UNSPECIFIED = \"EVENT_TYPE_UNSPECIFIED\", p.EVENT_TYPE_COLLECTION = \"EVENT_TYPE_COLLECTION\", p.EVENT_TYPE_PROJECT = \"EVENT_TYPE_PROJECT\", p.EVENT_TYPE_SOURCE = \"EVENT_TYPE_SOURCE\", p.EVENT_TYPE_DESTINATION = \"EVENT_TYPE_DESTINATION\";\n  })(Qe = a.EventType || (a.EventType = {}));\n  function ot(p) {\n    switch (p) {\n      case 0:\n      case \"EVENT_TYPE_UNSPECIFIED\":\n        return Qe.EVENT_TYPE_UNSPECIFIED;\n      case 1:\n      case \"EVENT_TYPE_COLLECTION\":\n        return Qe.EVENT_TYPE_COLLECTION;\n      case 2:\n      case \"EVENT_TYPE_PROJECT\":\n        return Qe.EVENT_TYPE_PROJECT;\n      case 4:\n      case \"EVENT_TYPE_SOURCE\":\n        return Qe.EVENT_TYPE_SOURCE;\n      case 5:\n      case \"EVENT_TYPE_DESTINATION\":\n        return Qe.EVENT_TYPE_DESTINATION;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum EventType\");\n    }\n  }\n  a.eventTypeFromJSON = ot;\n  function ft(p) {\n    switch (p) {\n      case Qe.EVENT_TYPE_UNSPECIFIED:\n        return \"EVENT_TYPE_UNSPECIFIED\";\n      case Qe.EVENT_TYPE_COLLECTION:\n        return \"EVENT_TYPE_COLLECTION\";\n      case Qe.EVENT_TYPE_PROJECT:\n        return \"EVENT_TYPE_PROJECT\";\n      case Qe.EVENT_TYPE_SOURCE:\n        return \"EVENT_TYPE_SOURCE\";\n      case Qe.EVENT_TYPE_DESTINATION:\n        return \"EVENT_TYPE_DESTINATION\";\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum EventType\");\n    }\n  }\n  a.eventTypeToJSON = ft;\n  function Ce(p) {\n    switch (p) {\n      case Qe.EVENT_TYPE_UNSPECIFIED:\n        return 0;\n      case Qe.EVENT_TYPE_COLLECTION:\n        return 1;\n      case Qe.EVENT_TYPE_PROJECT:\n        return 2;\n      case Qe.EVENT_TYPE_SOURCE:\n        return 4;\n      case Qe.EVENT_TYPE_DESTINATION:\n        return 5;\n      default:\n        throw new Ke.Error(\"Unrecognized enum value \" + p + \" for enum EventType\");\n    }\n  }\n  a.eventTypeToNumber = Ce;\n  function I() {\n    return { height: void 0, width: void 0, framerate: void 0, colorSpace: void 0 };\n  }\n  a.VideoRendering = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.height !== void 0 && b.uint32(8).uint32(p.height), p.width !== void 0 && b.uint32(16).uint32(p.width), p.framerate !== void 0 && b.uint32(29).float(p.framerate), p.colorSpace !== void 0 && b.uint32(32).int32(V(p.colorSpace)), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = I();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.height = T.uint32();\n            break;\n          case 2:\n            U.width = T.uint32();\n            break;\n          case 3:\n            U.framerate = T.float();\n            break;\n          case 4:\n            U.colorSpace = $(T.int32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        height: ce(p.height) ? Number(p.height) : void 0,\n        width: ce(p.width) ? Number(p.width) : void 0,\n        framerate: ce(p.framerate) ? Number(p.framerate) : void 0,\n        colorSpace: ce(p.colorSpace) ? $(p.colorSpace) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.height !== void 0 && (b.height = Math.round(p.height)), p.width !== void 0 && (b.width = Math.round(p.width)), p.framerate !== void 0 && (b.framerate = p.framerate), p.colorSpace !== void 0 && (b.colorSpace = p.colorSpace !== void 0 ? J(p.colorSpace) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U;\n      const te = I();\n      return te.height = (b = p.height) !== null && b !== void 0 ? b : void 0, te.width = (T = p.width) !== null && T !== void 0 ? T : void 0, te.framerate = (K = p.framerate) !== null && K !== void 0 ? K : void 0, te.colorSpace = (U = p.colorSpace) !== null && U !== void 0 ? U : void 0, te;\n    }\n  };\n  function F() {\n    return { channelLayout: void 0 };\n  }\n  a.AudioRendering = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.channelLayout !== void 0 && b.uint32(8).int32(B(p.channelLayout)), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = F();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.channelLayout = G(T.int32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        channelLayout: ce(p.channelLayout) ? G(p.channelLayout) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.channelLayout !== void 0 && (b.channelLayout = p.channelLayout !== void 0 ? H(p.channelLayout) : void 0), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = F();\n      return T.channelLayout = (b = p.channelLayout) !== null && b !== void 0 ? b : void 0, T;\n    }\n  };\n  function z() {\n    return { video: void 0, audio: void 0, quality: void 0, targetLatency: void 0, complexity: void 0 };\n  }\n  a.Rendering = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.video !== void 0 && a.VideoRendering.encode(p.video, b.uint32(10).fork()).ldelim(), p.audio !== void 0 && a.AudioRendering.encode(p.audio, b.uint32(18).fork()).ldelim(), p.quality !== void 0 && b.uint32(24).int32(re(p.quality)), p.targetLatency !== void 0 && b.uint32(32).uint32(p.targetLatency), p.complexity !== void 0 && b.uint32(40).int32(p.complexity), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = z();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.video = a.VideoRendering.decode(T, T.uint32());\n            break;\n          case 2:\n            U.audio = a.AudioRendering.decode(T, T.uint32());\n            break;\n          case 3:\n            U.quality = ne(T.int32());\n            break;\n          case 4:\n            U.targetLatency = T.uint32();\n            break;\n          case 5:\n            U.complexity = T.int32();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        video: ce(p.video) ? a.VideoRendering.fromJSON(p.video) : void 0,\n        audio: ce(p.audio) ? a.AudioRendering.fromJSON(p.audio) : void 0,\n        quality: ce(p.quality) ? ne(p.quality) : void 0,\n        targetLatency: ce(p.targetLatency) ? Number(p.targetLatency) : void 0,\n        complexity: ce(p.complexity) ? Number(p.complexity) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.video !== void 0 && (b.video = p.video ? a.VideoRendering.toJSON(p.video) : void 0), p.audio !== void 0 && (b.audio = p.audio ? a.AudioRendering.toJSON(p.audio) : void 0), p.quality !== void 0 && (b.quality = p.quality !== void 0 ? Z(p.quality) : void 0), p.targetLatency !== void 0 && (b.targetLatency = Math.round(p.targetLatency)), p.complexity !== void 0 && (b.complexity = Math.round(p.complexity)), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = z();\n      return U.video = p.video !== void 0 && p.video !== null ? a.VideoRendering.fromPartial(p.video) : void 0, U.audio = p.audio !== void 0 && p.audio !== null ? a.AudioRendering.fromPartial(p.audio) : void 0, U.quality = (b = p.quality) !== null && b !== void 0 ? b : void 0, U.targetLatency = (T = p.targetLatency) !== null && T !== void 0 ? T : void 0, U.complexity = (K = p.complexity) !== null && K !== void 0 ? K : void 0, U;\n    }\n  };\n  function Te() {\n    return { mode: void 0, targetBitrate: void 0, maxKeyFrameInterval: void 0 };\n  }\n  a.VideoCodecRateControl = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.mode !== void 0 && b.uint32(8).int32($e(p.mode)), p.targetBitrate !== void 0 && b.uint32(16).uint32(p.targetBitrate), p.maxKeyFrameInterval !== void 0 && b.uint32(24).uint32(p.maxKeyFrameInterval), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Te();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.mode = Ne(T.int32());\n            break;\n          case 2:\n            U.targetBitrate = T.uint32();\n            break;\n          case 3:\n            U.maxKeyFrameInterval = T.uint32();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        mode: ce(p.mode) ? Ne(p.mode) : void 0,\n        targetBitrate: ce(p.targetBitrate) ? Number(p.targetBitrate) : void 0,\n        maxKeyFrameInterval: ce(p.maxKeyFrameInterval) ? Number(p.maxKeyFrameInterval) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.mode !== void 0 && (b.mode = p.mode !== void 0 ? Le(p.mode) : void 0), p.targetBitrate !== void 0 && (b.targetBitrate = Math.round(p.targetBitrate)), p.maxKeyFrameInterval !== void 0 && (b.maxKeyFrameInterval = Math.round(p.maxKeyFrameInterval)), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = Te();\n      return U.mode = (b = p.mode) !== null && b !== void 0 ? b : void 0, U.targetBitrate = (T = p.targetBitrate) !== null && T !== void 0 ? T : void 0, U.maxKeyFrameInterval = (K = p.maxKeyFrameInterval) !== null && K !== void 0 ? K : void 0, U;\n    }\n  };\n  function fe() {\n    return { codec: void 0, rateControl: void 0, profile: void 0 };\n  }\n  a.VideoEncoding = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.codec !== void 0 && b.uint32(8).int32(N(p.codec)), p.rateControl !== void 0 && a.VideoCodecRateControl.encode(p.rateControl, b.uint32(18).fork()).ldelim(), p.profile !== void 0 && b.uint32(32).int32(ae(p.profile)), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = fe();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.codec = de(T.int32());\n            break;\n          case 2:\n            U.rateControl = a.VideoCodecRateControl.decode(T, T.uint32());\n            break;\n          case 4:\n            U.profile = W(T.int32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        codec: ce(p.codec) ? de(p.codec) : void 0,\n        rateControl: ce(p.rateControl) ? a.VideoCodecRateControl.fromJSON(p.rateControl) : void 0,\n        profile: ce(p.profile) ? W(p.profile) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.codec !== void 0 && (b.codec = p.codec !== void 0 ? A(p.codec) : void 0), p.rateControl !== void 0 && (b.rateControl = p.rateControl ? a.VideoCodecRateControl.toJSON(p.rateControl) : void 0), p.profile !== void 0 && (b.profile = p.profile !== void 0 ? ee(p.profile) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = fe();\n      return K.codec = (b = p.codec) !== null && b !== void 0 ? b : void 0, K.rateControl = p.rateControl !== void 0 && p.rateControl !== null ? a.VideoCodecRateControl.fromPartial(p.rateControl) : void 0, K.profile = (T = p.profile) !== null && T !== void 0 ? T : void 0, K;\n    }\n  };\n  function ke() {\n    return { codec: void 0 };\n  }\n  a.AudioEncoding = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.codec !== void 0 && b.uint32(8).int32(we(p.codec)), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = ke();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.codec = he(T.int32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { codec: ce(p.codec) ? he(p.codec) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.codec !== void 0 && (b.codec = p.codec !== void 0 ? le(p.codec) : void 0), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = ke();\n      return T.codec = (b = p.codec) !== null && b !== void 0 ? b : void 0, T;\n    }\n  };\n  function it() {\n    return { video: void 0, audio: void 0 };\n  }\n  a.Encoding = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.video !== void 0 && a.VideoEncoding.encode(p.video, b.uint32(10).fork()).ldelim(), p.audio !== void 0 && a.AudioEncoding.encode(p.audio, b.uint32(18).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = it();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.video = a.VideoEncoding.decode(T, T.uint32());\n            break;\n          case 2:\n            U.audio = a.AudioEncoding.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        video: ce(p.video) ? a.VideoEncoding.fromJSON(p.video) : void 0,\n        audio: ce(p.audio) ? a.AudioEncoding.fromJSON(p.audio) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.video !== void 0 && (b.video = p.video ? a.VideoEncoding.toJSON(p.video) : void 0), p.audio !== void 0 && (b.audio = p.audio ? a.AudioEncoding.toJSON(p.audio) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = it();\n      return b.video = p.video !== void 0 && p.video !== null ? a.VideoEncoding.fromPartial(p.video) : void 0, b.audio = p.audio !== void 0 && p.audio !== null ? a.AudioEncoding.fromPartial(p.audio) : void 0, b;\n    }\n  };\n  function mt() {\n    return {\n      enabled: void 0,\n      key: void 0,\n      url: void 0,\n      baseUrl: void 0,\n      previewUrl: void 0,\n      ingestId: void 0,\n      secure: void 0,\n      ingestType: void 0\n    };\n  }\n  a.SourceRtmpPushAddress = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.enabled !== void 0 && b.uint32(8).bool(p.enabled), p.key !== void 0 && b.uint32(18).string(p.key), p.url !== void 0 && b.uint32(26).string(p.url), p.baseUrl !== void 0 && b.uint32(34).string(p.baseUrl), p.previewUrl !== void 0 && b.uint32(42).string(p.previewUrl), p.ingestId !== void 0 && b.uint32(50).string(p.ingestId), p.secure !== void 0 && b.uint32(56).bool(p.secure), p.ingestType !== void 0 && b.uint32(66).string(p.ingestType), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = mt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.enabled = T.bool();\n            break;\n          case 2:\n            U.key = T.string();\n            break;\n          case 3:\n            U.url = T.string();\n            break;\n          case 4:\n            U.baseUrl = T.string();\n            break;\n          case 5:\n            U.previewUrl = T.string();\n            break;\n          case 6:\n            U.ingestId = T.string();\n            break;\n          case 7:\n            U.secure = T.bool();\n            break;\n          case 8:\n            U.ingestType = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        enabled: ce(p.enabled) ? !!p.enabled : void 0,\n        key: ce(p.key) ? String(p.key) : void 0,\n        url: ce(p.url) ? String(p.url) : void 0,\n        baseUrl: ce(p.baseUrl) ? String(p.baseUrl) : void 0,\n        previewUrl: ce(p.previewUrl) ? String(p.previewUrl) : void 0,\n        ingestId: ce(p.ingestId) ? String(p.ingestId) : void 0,\n        secure: ce(p.secure) ? !!p.secure : void 0,\n        ingestType: ce(p.ingestType) ? String(p.ingestType) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.enabled !== void 0 && (b.enabled = p.enabled), p.key !== void 0 && (b.key = p.key), p.url !== void 0 && (b.url = p.url), p.baseUrl !== void 0 && (b.baseUrl = p.baseUrl), p.previewUrl !== void 0 && (b.previewUrl = p.previewUrl), p.ingestId !== void 0 && (b.ingestId = p.ingestId), p.secure !== void 0 && (b.secure = p.secure), p.ingestType !== void 0 && (b.ingestType = p.ingestType), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U, te, We, et, dt;\n      const lt = mt();\n      return lt.enabled = (b = p.enabled) !== null && b !== void 0 ? b : void 0, lt.key = (T = p.key) !== null && T !== void 0 ? T : void 0, lt.url = (K = p.url) !== null && K !== void 0 ? K : void 0, lt.baseUrl = (U = p.baseUrl) !== null && U !== void 0 ? U : void 0, lt.previewUrl = (te = p.previewUrl) !== null && te !== void 0 ? te : void 0, lt.ingestId = (We = p.ingestId) !== null && We !== void 0 ? We : void 0, lt.secure = (et = p.secure) !== null && et !== void 0 ? et : void 0, lt.ingestType = (dt = p.ingestType) !== null && dt !== void 0 ? dt : void 0, lt;\n    }\n  };\n  function vt() {\n    return {\n      enabled: void 0,\n      streamId: void 0,\n      url: void 0,\n      baseUrl: void 0,\n      previewUrl: void 0,\n      ingestId: void 0,\n      ingestType: void 0\n    };\n  }\n  a.SrtPushAddress = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.enabled !== void 0 && b.uint32(8).bool(p.enabled), p.streamId !== void 0 && b.uint32(18).string(p.streamId), p.url !== void 0 && b.uint32(26).string(p.url), p.baseUrl !== void 0 && b.uint32(34).string(p.baseUrl), p.previewUrl !== void 0 && b.uint32(42).string(p.previewUrl), p.ingestId !== void 0 && b.uint32(50).string(p.ingestId), p.ingestType !== void 0 && b.uint32(58).string(p.ingestType), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = vt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.enabled = T.bool();\n            break;\n          case 2:\n            U.streamId = T.string();\n            break;\n          case 3:\n            U.url = T.string();\n            break;\n          case 4:\n            U.baseUrl = T.string();\n            break;\n          case 5:\n            U.previewUrl = T.string();\n            break;\n          case 6:\n            U.ingestId = T.string();\n            break;\n          case 7:\n            U.ingestType = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        enabled: ce(p.enabled) ? !!p.enabled : void 0,\n        streamId: ce(p.streamId) ? String(p.streamId) : void 0,\n        url: ce(p.url) ? String(p.url) : void 0,\n        baseUrl: ce(p.baseUrl) ? String(p.baseUrl) : void 0,\n        previewUrl: ce(p.previewUrl) ? String(p.previewUrl) : void 0,\n        ingestId: ce(p.ingestId) ? String(p.ingestId) : void 0,\n        ingestType: ce(p.ingestType) ? String(p.ingestType) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.enabled !== void 0 && (b.enabled = p.enabled), p.streamId !== void 0 && (b.streamId = p.streamId), p.url !== void 0 && (b.url = p.url), p.baseUrl !== void 0 && (b.baseUrl = p.baseUrl), p.previewUrl !== void 0 && (b.previewUrl = p.previewUrl), p.ingestId !== void 0 && (b.ingestId = p.ingestId), p.ingestType !== void 0 && (b.ingestType = p.ingestType), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U, te, We, et;\n      const dt = vt();\n      return dt.enabled = (b = p.enabled) !== null && b !== void 0 ? b : void 0, dt.streamId = (T = p.streamId) !== null && T !== void 0 ? T : void 0, dt.url = (K = p.url) !== null && K !== void 0 ? K : void 0, dt.baseUrl = (U = p.baseUrl) !== null && U !== void 0 ? U : void 0, dt.previewUrl = (te = p.previewUrl) !== null && te !== void 0 ? te : void 0, dt.ingestId = (We = p.ingestId) !== null && We !== void 0 ? We : void 0, dt.ingestType = (et = p.ingestType) !== null && et !== void 0 ? et : void 0, dt;\n    }\n  };\n  function st() {\n    return { url: \"\" };\n  }\n  a.RtmpPullAddress = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.url !== \"\" && b.uint32(10).string(p.url), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = st();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.url = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { url: ce(p.url) ? String(p.url) : \"\" };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.url !== void 0 && (b.url = p.url), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = st();\n      return T.url = (b = p.url) !== null && b !== void 0 ? b : \"\", T;\n    }\n  };\n  function ut() {\n    return { url: \"\" };\n  }\n  a.SrtPullAddress = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.url !== \"\" && b.uint32(10).string(p.url), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = ut();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.url = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { url: ce(p.url) ? String(p.url) : \"\" };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.url !== void 0 && (b.url = p.url), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = ut();\n      return T.url = (b = p.url) !== null && b !== void 0 ? b : \"\", T;\n    }\n  };\n  function yt() {\n    return { rtmpPush: void 0, srtPush: void 0, rtmpPull: void 0, srtPull: void 0 };\n  }\n  a.SourceAddress = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.rtmpPush !== void 0 && a.SourceRtmpPushAddress.encode(p.rtmpPush, b.uint32(10).fork()).ldelim(), p.srtPush !== void 0 && a.SrtPushAddress.encode(p.srtPush, b.uint32(18).fork()).ldelim(), p.rtmpPull !== void 0 && a.RtmpPullAddress.encode(p.rtmpPull, b.uint32(26).fork()).ldelim(), p.srtPull !== void 0 && a.SrtPullAddress.encode(p.srtPull, b.uint32(34).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = yt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.rtmpPush = a.SourceRtmpPushAddress.decode(T, T.uint32());\n            break;\n          case 2:\n            U.srtPush = a.SrtPushAddress.decode(T, T.uint32());\n            break;\n          case 3:\n            U.rtmpPull = a.RtmpPullAddress.decode(T, T.uint32());\n            break;\n          case 4:\n            U.srtPull = a.SrtPullAddress.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        rtmpPush: ce(p.rtmpPush) ? a.SourceRtmpPushAddress.fromJSON(p.rtmpPush) : void 0,\n        srtPush: ce(p.srtPush) ? a.SrtPushAddress.fromJSON(p.srtPush) : void 0,\n        rtmpPull: ce(p.rtmpPull) ? a.RtmpPullAddress.fromJSON(p.rtmpPull) : void 0,\n        srtPull: ce(p.srtPull) ? a.SrtPullAddress.fromJSON(p.srtPull) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.rtmpPush !== void 0 && (b.rtmpPush = p.rtmpPush ? a.SourceRtmpPushAddress.toJSON(p.rtmpPush) : void 0), p.srtPush !== void 0 && (b.srtPush = p.srtPush ? a.SrtPushAddress.toJSON(p.srtPush) : void 0), p.rtmpPull !== void 0 && (b.rtmpPull = p.rtmpPull ? a.RtmpPullAddress.toJSON(p.rtmpPull) : void 0), p.srtPull !== void 0 && (b.srtPull = p.srtPull ? a.SrtPullAddress.toJSON(p.srtPull) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = yt();\n      return b.rtmpPush = p.rtmpPush !== void 0 && p.rtmpPush !== null ? a.SourceRtmpPushAddress.fromPartial(p.rtmpPush) : void 0, b.srtPush = p.srtPush !== void 0 && p.srtPush !== null ? a.SrtPushAddress.fromPartial(p.srtPush) : void 0, b.rtmpPull = p.rtmpPull !== void 0 && p.rtmpPull !== null ? a.RtmpPullAddress.fromPartial(p.rtmpPull) : void 0, b.srtPull = p.srtPull !== void 0 && p.srtPull !== null ? a.SrtPullAddress.fromPartial(p.srtPull) : void 0, b;\n    }\n  };\n  function gt() {\n    return { key: void 0, url: \"\" };\n  }\n  a.DestinationRtmpPushAddress = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.key !== void 0 && b.uint32(10).string(p.key), p.url !== \"\" && b.uint32(18).string(p.url), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = gt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.key = T.string();\n            break;\n          case 2:\n            U.url = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        key: ce(p.key) ? String(p.key) : void 0,\n        url: ce(p.url) ? String(p.url) : \"\"\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.key !== void 0 && (b.key = p.key), p.url !== void 0 && (b.url = p.url), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = gt();\n      return K.key = (b = p.key) !== null && b !== void 0 ? b : void 0, K.url = (T = p.url) !== null && T !== void 0 ? T : \"\", K;\n    }\n  };\n  function bt() {\n    return { url: \"\" };\n  }\n  a.DestinationSrtPushAddress = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.url !== \"\" && b.uint32(18).string(p.url), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = bt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 2:\n            U.url = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { url: ce(p.url) ? String(p.url) : \"\" };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.url !== void 0 && (b.url = p.url), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = bt();\n      return T.url = (b = p.url) !== null && b !== void 0 ? b : \"\", T;\n    }\n  };\n  function St() {\n    return { appId: \"\", channelId: \"\", userId: \"\" };\n  }\n  a.DestinationAgoraPushAddress = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.appId !== \"\" && b.uint32(10).string(p.appId), p.channelId !== \"\" && b.uint32(18).string(p.channelId), p.userId !== \"\" && b.uint32(26).string(p.userId), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = St();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.appId = T.string();\n            break;\n          case 2:\n            U.channelId = T.string();\n            break;\n          case 3:\n            U.userId = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        appId: ce(p.appId) ? String(p.appId) : \"\",\n        channelId: ce(p.channelId) ? String(p.channelId) : \"\",\n        userId: ce(p.userId) ? String(p.userId) : \"\"\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.appId !== void 0 && (b.appId = p.appId), p.channelId !== void 0 && (b.channelId = p.channelId), p.userId !== void 0 && (b.userId = p.userId), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = St();\n      return U.appId = (b = p.appId) !== null && b !== void 0 ? b : \"\", U.channelId = (T = p.channelId) !== null && T !== void 0 ? T : \"\", U.userId = (K = p.userId) !== null && K !== void 0 ? K : \"\", U;\n    }\n  };\n  function Et() {\n    return { playlistCount: void 0, fileCount: void 0 };\n  }\n  a.HlsLifecycleLive = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.playlistCount !== void 0 && b.uint32(8).int32(p.playlistCount), p.fileCount !== void 0 && b.uint32(16).int32(p.fileCount), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Et();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.playlistCount = T.int32();\n            break;\n          case 2:\n            U.fileCount = T.int32();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        playlistCount: ce(p.playlistCount) ? Number(p.playlistCount) : void 0,\n        fileCount: ce(p.fileCount) ? Number(p.fileCount) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.playlistCount !== void 0 && (b.playlistCount = Math.round(p.playlistCount)), p.fileCount !== void 0 && (b.fileCount = Math.round(p.fileCount)), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = Et();\n      return K.playlistCount = (b = p.playlistCount) !== null && b !== void 0 ? b : void 0, K.fileCount = (T = p.fileCount) !== null && T !== void 0 ? T : void 0, K;\n    }\n  };\n  function ct() {\n    return { maxDuration: void 0 };\n  }\n  a.HlsLifecycleVod = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.maxDuration !== void 0 && b.uint32(8).int32(p.maxDuration), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = ct();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.maxDuration = T.int32();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { maxDuration: ce(p.maxDuration) ? Number(p.maxDuration) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.maxDuration !== void 0 && (b.maxDuration = Math.round(p.maxDuration)), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = ct();\n      return T.maxDuration = (b = p.maxDuration) !== null && b !== void 0 ? b : void 0, T;\n    }\n  };\n  function Xe() {\n    return { vod: void 0, live: void 0 };\n  }\n  a.HlsLifecycle = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.vod !== void 0 && a.HlsLifecycleVod.encode(p.vod, b.uint32(10).fork()).ldelim(), p.live !== void 0 && a.HlsLifecycleLive.encode(p.live, b.uint32(18).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Xe();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.vod = a.HlsLifecycleVod.decode(T, T.uint32());\n            break;\n          case 2:\n            U.live = a.HlsLifecycleLive.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        vod: ce(p.vod) ? a.HlsLifecycleVod.fromJSON(p.vod) : void 0,\n        live: ce(p.live) ? a.HlsLifecycleLive.fromJSON(p.live) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.vod !== void 0 && (b.vod = p.vod ? a.HlsLifecycleVod.toJSON(p.vod) : void 0), p.live !== void 0 && (b.live = p.live ? a.HlsLifecycleLive.toJSON(p.live) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Xe();\n      return b.vod = p.vod !== void 0 && p.vod !== null ? a.HlsLifecycleVod.fromPartial(p.vod) : void 0, b.live = p.live !== void 0 && p.live !== null ? a.HlsLifecycleLive.fromPartial(p.live) : void 0, b;\n    }\n  };\n  function Ct() {\n    return { lifecycle: void 0, segmentDuration: void 0 };\n  }\n  a.HlsPackaging = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.lifecycle !== void 0 && a.HlsLifecycle.encode(p.lifecycle, b.uint32(10).fork()).ldelim(), p.segmentDuration !== void 0 && b.uint32(16).int32(p.segmentDuration), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Ct();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.lifecycle = a.HlsLifecycle.decode(T, T.uint32());\n            break;\n          case 2:\n            U.segmentDuration = T.int32();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        lifecycle: ce(p.lifecycle) ? a.HlsLifecycle.fromJSON(p.lifecycle) : void 0,\n        segmentDuration: ce(p.segmentDuration) ? Number(p.segmentDuration) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.lifecycle !== void 0 && (b.lifecycle = p.lifecycle ? a.HlsLifecycle.toJSON(p.lifecycle) : void 0), p.segmentDuration !== void 0 && (b.segmentDuration = Math.round(p.segmentDuration)), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = Ct();\n      return T.lifecycle = p.lifecycle !== void 0 && p.lifecycle !== null ? a.HlsLifecycle.fromPartial(p.lifecycle) : void 0, T.segmentDuration = (b = p.segmentDuration) !== null && b !== void 0 ? b : void 0, T;\n    }\n  };\n  function Ot() {\n    return { hls: void 0 };\n  }\n  a.ObjectStoragePackaging = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.hls !== void 0 && a.HlsPackaging.encode(p.hls, b.uint32(10).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Ot();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.hls = a.HlsPackaging.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { hls: ce(p.hls) ? a.HlsPackaging.fromJSON(p.hls) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.hls !== void 0 && (b.hls = p.hls ? a.HlsPackaging.toJSON(p.hls) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Ot();\n      return b.hls = p.hls !== void 0 && p.hls !== null ? a.HlsPackaging.fromPartial(p.hls) : void 0, b;\n    }\n  };\n  function Nt() {\n    return {\n      region: \"\",\n      bucket: \"\",\n      prefix: void 0,\n      accessKey: \"\",\n      secretKey: \"\",\n      token: void 0,\n      tokenDuration: void 0,\n      acl: void 0,\n      endpoint: void 0,\n      packaging: void 0\n    };\n  }\n  a.S3StorageAddress = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.region !== \"\" && b.uint32(10).string(p.region), p.bucket !== \"\" && b.uint32(18).string(p.bucket), p.prefix !== void 0 && b.uint32(26).string(p.prefix), p.accessKey !== \"\" && b.uint32(34).string(p.accessKey), p.secretKey !== \"\" && b.uint32(42).string(p.secretKey), p.token !== void 0 && b.uint32(50).string(p.token), p.tokenDuration !== void 0 && b.uint32(56).int32(p.tokenDuration), p.acl !== void 0 && b.uint32(64).int32(xe(p.acl)), p.endpoint !== void 0 && b.uint32(74).string(p.endpoint), p.packaging !== void 0 && a.ObjectStoragePackaging.encode(p.packaging, b.uint32(82).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Nt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.region = T.string();\n            break;\n          case 2:\n            U.bucket = T.string();\n            break;\n          case 3:\n            U.prefix = T.string();\n            break;\n          case 4:\n            U.accessKey = T.string();\n            break;\n          case 5:\n            U.secretKey = T.string();\n            break;\n          case 6:\n            U.token = T.string();\n            break;\n          case 7:\n            U.tokenDuration = T.int32();\n            break;\n          case 8:\n            U.acl = Ae(T.int32());\n            break;\n          case 9:\n            U.endpoint = T.string();\n            break;\n          case 10:\n            U.packaging = a.ObjectStoragePackaging.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        region: ce(p.region) ? String(p.region) : \"\",\n        bucket: ce(p.bucket) ? String(p.bucket) : \"\",\n        prefix: ce(p.prefix) ? String(p.prefix) : void 0,\n        accessKey: ce(p.accessKey) ? String(p.accessKey) : \"\",\n        secretKey: ce(p.secretKey) ? String(p.secretKey) : \"\",\n        token: ce(p.token) ? String(p.token) : void 0,\n        tokenDuration: ce(p.tokenDuration) ? Number(p.tokenDuration) : void 0,\n        acl: ce(p.acl) ? Ae(p.acl) : void 0,\n        endpoint: ce(p.endpoint) ? String(p.endpoint) : void 0,\n        packaging: ce(p.packaging) ? a.ObjectStoragePackaging.fromJSON(p.packaging) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.region !== void 0 && (b.region = p.region), p.bucket !== void 0 && (b.bucket = p.bucket), p.prefix !== void 0 && (b.prefix = p.prefix), p.accessKey !== void 0 && (b.accessKey = p.accessKey), p.secretKey !== void 0 && (b.secretKey = p.secretKey), p.token !== void 0 && (b.token = p.token), p.tokenDuration !== void 0 && (b.tokenDuration = Math.round(p.tokenDuration)), p.acl !== void 0 && (b.acl = p.acl !== void 0 ? qe(p.acl) : void 0), p.endpoint !== void 0 && (b.endpoint = p.endpoint), p.packaging !== void 0 && (b.packaging = p.packaging ? a.ObjectStoragePackaging.toJSON(p.packaging) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U, te, We, et, dt, lt;\n      const pt = Nt();\n      return pt.region = (b = p.region) !== null && b !== void 0 ? b : \"\", pt.bucket = (T = p.bucket) !== null && T !== void 0 ? T : \"\", pt.prefix = (K = p.prefix) !== null && K !== void 0 ? K : void 0, pt.accessKey = (U = p.accessKey) !== null && U !== void 0 ? U : \"\", pt.secretKey = (te = p.secretKey) !== null && te !== void 0 ? te : \"\", pt.token = (We = p.token) !== null && We !== void 0 ? We : void 0, pt.tokenDuration = (et = p.tokenDuration) !== null && et !== void 0 ? et : void 0, pt.acl = (dt = p.acl) !== null && dt !== void 0 ? dt : void 0, pt.endpoint = (lt = p.endpoint) !== null && lt !== void 0 ? lt : void 0, pt.packaging = p.packaging !== void 0 && p.packaging !== null ? a.ObjectStoragePackaging.fromPartial(p.packaging) : void 0, pt;\n    }\n  };\n  function Pt() {\n    return { rtmpPush: void 0, agora: void 0, s3Storage: void 0, srtPush: void 0 };\n  }\n  a.DestinationAddress = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.rtmpPush !== void 0 && a.DestinationRtmpPushAddress.encode(p.rtmpPush, b.uint32(10).fork()).ldelim(), p.agora !== void 0 && a.DestinationAgoraPushAddress.encode(p.agora, b.uint32(18).fork()).ldelim(), p.s3Storage !== void 0 && a.S3StorageAddress.encode(p.s3Storage, b.uint32(26).fork()).ldelim(), p.srtPush !== void 0 && a.DestinationSrtPushAddress.encode(p.srtPush, b.uint32(34).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Pt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.rtmpPush = a.DestinationRtmpPushAddress.decode(T, T.uint32());\n            break;\n          case 2:\n            U.agora = a.DestinationAgoraPushAddress.decode(T, T.uint32());\n            break;\n          case 3:\n            U.s3Storage = a.S3StorageAddress.decode(T, T.uint32());\n            break;\n          case 4:\n            U.srtPush = a.DestinationSrtPushAddress.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        rtmpPush: ce(p.rtmpPush) ? a.DestinationRtmpPushAddress.fromJSON(p.rtmpPush) : void 0,\n        agora: ce(p.agora) ? a.DestinationAgoraPushAddress.fromJSON(p.agora) : void 0,\n        s3Storage: ce(p.s3Storage) ? a.S3StorageAddress.fromJSON(p.s3Storage) : void 0,\n        srtPush: ce(p.srtPush) ? a.DestinationSrtPushAddress.fromJSON(p.srtPush) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.rtmpPush !== void 0 && (b.rtmpPush = p.rtmpPush ? a.DestinationRtmpPushAddress.toJSON(p.rtmpPush) : void 0), p.agora !== void 0 && (b.agora = p.agora ? a.DestinationAgoraPushAddress.toJSON(p.agora) : void 0), p.s3Storage !== void 0 && (b.s3Storage = p.s3Storage ? a.S3StorageAddress.toJSON(p.s3Storage) : void 0), p.srtPush !== void 0 && (b.srtPush = p.srtPush ? a.DestinationSrtPushAddress.toJSON(p.srtPush) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Pt();\n      return b.rtmpPush = p.rtmpPush !== void 0 && p.rtmpPush !== null ? a.DestinationRtmpPushAddress.fromPartial(p.rtmpPush) : void 0, b.agora = p.agora !== void 0 && p.agora !== null ? a.DestinationAgoraPushAddress.fromPartial(p.agora) : void 0, b.s3Storage = p.s3Storage !== void 0 && p.s3Storage !== null ? a.S3StorageAddress.fromPartial(p.s3Storage) : void 0, b.srtPush = p.srtPush !== void 0 && p.srtPush !== null ? a.DestinationSrtPushAddress.fromPartial(p.srtPush) : void 0, b;\n    }\n  };\n  function wt() {\n    return { sourceId: \"\", start: void 0, stop: void 0 };\n  }\n  a.SourceTrigger = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.sourceId !== \"\" && b.uint32(10).string(p.sourceId), p.start !== void 0 && b.uint32(16).int32(Q(p.start)), p.stop !== void 0 && b.uint32(24).int32(Q(p.stop)), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = wt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.sourceId = T.string();\n            break;\n          case 2:\n            U.start = C(T.int32());\n            break;\n          case 3:\n            U.stop = C(T.int32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        sourceId: ce(p.sourceId) ? String(p.sourceId) : \"\",\n        start: ce(p.start) ? C(p.start) : void 0,\n        stop: ce(p.stop) ? C(p.stop) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.start !== void 0 && (b.start = p.start !== void 0 ? x(p.start) : void 0), p.stop !== void 0 && (b.stop = p.stop !== void 0 ? x(p.stop) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = wt();\n      return U.sourceId = (b = p.sourceId) !== null && b !== void 0 ? b : \"\", U.start = (T = p.start) !== null && T !== void 0 ? T : void 0, U.stop = (K = p.stop) !== null && K !== void 0 ? K : void 0, U;\n    }\n  };\n  function At() {\n    return { stop: void 0 };\n  }\n  a.WebRtcTrigger = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.stop !== void 0 && b.uint32(24).int32(Q(p.stop)), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = At();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 3:\n            U.stop = C(T.int32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { stop: ce(p.stop) ? C(p.stop) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.stop !== void 0 && (b.stop = p.stop !== void 0 ? x(p.stop) : void 0), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = At();\n      return T.stop = (b = p.stop) !== null && b !== void 0 ? b : void 0, T;\n    }\n  };\n  function Dt() {\n    return { source: void 0 };\n  }\n  a.ProjectTrigger = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.source !== void 0 && a.SourceTrigger.encode(p.source, b.uint32(10).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Dt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.source = a.SourceTrigger.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { source: ce(p.source) ? a.SourceTrigger.fromJSON(p.source) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.source !== void 0 && (b.source = p.source ? a.SourceTrigger.toJSON(p.source) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Dt();\n      return b.source = p.source !== void 0 && p.source !== null ? a.SourceTrigger.fromPartial(p.source) : void 0, b;\n    }\n  };\n  function pe() {\n    return { enabled: void 0, url: void 0 };\n  }\n  a.PreviewHlsPullAddress = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.enabled !== void 0 && b.uint32(8).bool(p.enabled), p.url !== void 0 && b.uint32(18).string(p.url), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = pe();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.enabled = T.bool();\n            break;\n          case 2:\n            U.url = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        enabled: ce(p.enabled) ? !!p.enabled : void 0,\n        url: ce(p.url) ? String(p.url) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.enabled !== void 0 && (b.enabled = p.enabled), p.url !== void 0 && (b.url = p.url), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = pe();\n      return K.enabled = (b = p.enabled) !== null && b !== void 0 ? b : void 0, K.url = (T = p.url) !== null && T !== void 0 ? T : void 0, K;\n    }\n  };\n  function ge() {\n    return { enabled: void 0, displayName: void 0, participantId: void 0 };\n  }\n  a.PreviewWebRtcAddress = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.enabled !== void 0 && b.uint32(8).bool(p.enabled), p.displayName !== void 0 && b.uint32(18).string(p.displayName), p.participantId !== void 0 && b.uint32(26).string(p.participantId), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = ge();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.enabled = T.bool();\n            break;\n          case 2:\n            U.displayName = T.string();\n            break;\n          case 3:\n            U.participantId = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        enabled: ce(p.enabled) ? !!p.enabled : void 0,\n        displayName: ce(p.displayName) ? String(p.displayName) : void 0,\n        participantId: ce(p.participantId) ? String(p.participantId) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.enabled !== void 0 && (b.enabled = p.enabled), p.displayName !== void 0 && (b.displayName = p.displayName), p.participantId !== void 0 && (b.participantId = p.participantId), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = ge();\n      return U.enabled = (b = p.enabled) !== null && b !== void 0 ? b : void 0, U.displayName = (T = p.displayName) !== null && T !== void 0 ? T : void 0, U.participantId = (K = p.participantId) !== null && K !== void 0 ? K : void 0, U;\n    }\n  };\n  function Re() {\n    return { webrtc: void 0 };\n  }\n  a.PreviewAddress = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.webrtc !== void 0 && a.PreviewWebRtcAddress.encode(p.webrtc, b.uint32(18).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Re();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 2:\n            U.webrtc = a.PreviewWebRtcAddress.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { webrtc: ce(p.webrtc) ? a.PreviewWebRtcAddress.fromJSON(p.webrtc) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.webrtc !== void 0 && (b.webrtc = p.webrtc ? a.PreviewWebRtcAddress.toJSON(p.webrtc) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Re();\n      return b.webrtc = p.webrtc !== void 0 && p.webrtc !== null ? a.PreviewWebRtcAddress.fromPartial(p.webrtc) : void 0, b;\n    }\n  };\n  function Je() {\n    return { rendererUrl: void 0, version: void 0 };\n  }\n  a.StudioSdkComposition = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.rendererUrl !== void 0 && b.uint32(10).string(p.rendererUrl), p.version !== void 0 && b.uint32(18).string(p.version), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Je();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.rendererUrl = T.string();\n            break;\n          case 2:\n            U.version = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        rendererUrl: ce(p.rendererUrl) ? String(p.rendererUrl) : void 0,\n        version: ce(p.version) ? String(p.version) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.rendererUrl !== void 0 && (b.rendererUrl = p.rendererUrl), p.version !== void 0 && (b.version = p.version), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = Je();\n      return K.rendererUrl = (b = p.rendererUrl) !== null && b !== void 0 ? b : void 0, K.version = (T = p.version) !== null && T !== void 0 ? T : void 0, K;\n    }\n  };\n  function Fe() {\n    return { rendererUrl: void 0, selectedLayoutId: void 0, debug: void 0 };\n  }\n  a.SceneComposition = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.rendererUrl !== void 0 && b.uint32(10).string(p.rendererUrl), p.selectedLayoutId !== void 0 && b.uint32(18).string(p.selectedLayoutId), p.debug !== void 0 && b.uint32(24).bool(p.debug), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Fe();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.rendererUrl = T.string();\n            break;\n          case 2:\n            U.selectedLayoutId = T.string();\n            break;\n          case 3:\n            U.debug = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        rendererUrl: ce(p.rendererUrl) ? String(p.rendererUrl) : void 0,\n        selectedLayoutId: ce(p.selectedLayoutId) ? String(p.selectedLayoutId) : void 0,\n        debug: ce(p.debug) ? !!p.debug : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.rendererUrl !== void 0 && (b.rendererUrl = p.rendererUrl), p.selectedLayoutId !== void 0 && (b.selectedLayoutId = p.selectedLayoutId), p.debug !== void 0 && (b.debug = p.debug), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = Fe();\n      return U.rendererUrl = (b = p.rendererUrl) !== null && b !== void 0 ? b : void 0, U.selectedLayoutId = (T = p.selectedLayoutId) !== null && T !== void 0 ? T : void 0, U.debug = (K = p.debug) !== null && K !== void 0 ? K : void 0, U;\n    }\n  };\n  function ze() {\n    return { url: \"\" };\n  }\n  a.ExternalComposition = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.url !== \"\" && b.uint32(10).string(p.url), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = ze();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.url = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { url: ce(p.url) ? String(p.url) : \"\" };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.url !== void 0 && (b.url = p.url), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = ze();\n      return T.url = (b = p.url) !== null && b !== void 0 ? b : \"\", T;\n    }\n  };\n  function Me() {\n    return { external: void 0, studioSdk: void 0, scene: void 0 };\n  }\n  a.Composition = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.external !== void 0 && a.ExternalComposition.encode(p.external, b.uint32(10).fork()).ldelim(), p.studioSdk !== void 0 && a.StudioSdkComposition.encode(p.studioSdk, b.uint32(18).fork()).ldelim(), p.scene !== void 0 && a.SceneComposition.encode(p.scene, b.uint32(34).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Me();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.external = a.ExternalComposition.decode(T, T.uint32());\n            break;\n          case 2:\n            U.studioSdk = a.StudioSdkComposition.decode(T, T.uint32());\n            break;\n          case 4:\n            U.scene = a.SceneComposition.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        external: ce(p.external) ? a.ExternalComposition.fromJSON(p.external) : void 0,\n        studioSdk: ce(p.studioSdk) ? a.StudioSdkComposition.fromJSON(p.studioSdk) : void 0,\n        scene: ce(p.scene) ? a.SceneComposition.fromJSON(p.scene) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.external !== void 0 && (b.external = p.external ? a.ExternalComposition.toJSON(p.external) : void 0), p.studioSdk !== void 0 && (b.studioSdk = p.studioSdk ? a.StudioSdkComposition.toJSON(p.studioSdk) : void 0), p.scene !== void 0 && (b.scene = p.scene ? a.SceneComposition.toJSON(p.scene) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Me();\n      return b.external = p.external !== void 0 && p.external !== null ? a.ExternalComposition.fromPartial(p.external) : void 0, b.studioSdk = p.studioSdk !== void 0 && p.studioSdk !== null ? a.StudioSdkComposition.fromPartial(p.studioSdk) : void 0, b.scene = p.scene !== void 0 && p.scene !== null ? a.SceneComposition.fromPartial(p.scene) : void 0, b;\n    }\n  };\n  function nt() {\n    return { enabled: void 0 };\n  }\n  a.HostedWebRtc = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.enabled !== void 0 && b.uint32(8).bool(p.enabled), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = nt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.enabled = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { enabled: ce(p.enabled) ? !!p.enabled : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.enabled !== void 0 && (b.enabled = p.enabled), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = nt();\n      return T.enabled = (b = p.enabled) !== null && b !== void 0 ? b : void 0, T;\n    }\n  };\n  function rt() {\n    return { hosted: void 0 };\n  }\n  a.WebRtc = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.hosted !== void 0 && a.HostedWebRtc.encode(p.hosted, b.uint32(10).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = rt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.hosted = a.HostedWebRtc.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { hosted: ce(p.hosted) ? a.HostedWebRtc.fromJSON(p.hosted) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.hosted !== void 0 && (b.hosted = p.hosted ? a.HostedWebRtc.toJSON(p.hosted) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = rt();\n      return b.hosted = p.hosted !== void 0 && p.hosted !== null ? a.HostedWebRtc.fromPartial(p.hosted) : void 0, b;\n    }\n  };\n  function Tt() {\n    return { accessToken: \"\", participantId: void 0 };\n  }\n  a.WebRtcAccess = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.accessToken !== \"\" && b.uint32(10).string(p.accessToken), p.participantId !== void 0 && b.uint32(26).string(p.participantId), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Tt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.accessToken = T.string();\n            break;\n          case 3:\n            U.participantId = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        accessToken: ce(p.accessToken) ? String(p.accessToken) : \"\",\n        participantId: ce(p.participantId) ? String(p.participantId) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.accessToken !== void 0 && (b.accessToken = p.accessToken), p.participantId !== void 0 && (b.participantId = p.participantId), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = Tt();\n      return K.accessToken = (b = p.accessToken) !== null && b !== void 0 ? b : \"\", K.participantId = (T = p.participantId) !== null && T !== void 0 ? T : void 0, K;\n    }\n  };\n  function kt() {\n    return { latitude: 0, longitude: 0 };\n  }\n  a.LatLong = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.latitude !== 0 && b.uint32(9).double(p.latitude), p.longitude !== 0 && b.uint32(17).double(p.longitude), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = kt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.latitude = T.double();\n            break;\n          case 2:\n            U.longitude = T.double();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        latitude: ce(p.latitude) ? Number(p.latitude) : 0,\n        longitude: ce(p.longitude) ? Number(p.longitude) : 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.latitude !== void 0 && (b.latitude = p.latitude), p.longitude !== void 0 && (b.longitude = p.longitude), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = kt();\n      return K.latitude = (b = p.latitude) !== null && b !== void 0 ? b : 0, K.longitude = (T = p.longitude) !== null && T !== void 0 ? T : 0, K;\n    }\n  };\n  function It() {\n    return {\n      collectionId: \"\",\n      projectId: \"\",\n      broadcastId: void 0,\n      duration: void 0,\n      start: void 0,\n      stop: void 0,\n      phase: Ue.PROJECT_BROADCAST_PHASE_UNSPECIFIED,\n      region: void 0,\n      datacenter: void 0\n    };\n  }\n  a.ProjectBroadcastStatus = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.broadcastId !== void 0 && b.uint32(26).string(p.broadcastId), p.duration !== void 0 && b.uint32(32).uint32(p.duration), p.start !== void 0 && g.Timestamp.encode(Ut(p.start), b.uint32(42).fork()).ldelim(), p.stop !== void 0 && g.Timestamp.encode(Ut(p.stop), b.uint32(50).fork()).ldelim(), p.phase !== Ue.PROJECT_BROADCAST_PHASE_UNSPECIFIED && b.uint32(56).int32(Ve(p.phase)), p.region !== void 0 && b.uint32(64).int32(at(p.region)), p.datacenter !== void 0 && b.uint32(74).string(p.datacenter), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = It();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.broadcastId = T.string();\n            break;\n          case 4:\n            U.duration = T.uint32();\n            break;\n          case 5:\n            U.start = $t(g.Timestamp.decode(T, T.uint32()));\n            break;\n          case 6:\n            U.stop = $t(g.Timestamp.decode(T, T.uint32()));\n            break;\n          case 7:\n            U.phase = Ge(T.int32());\n            break;\n          case 8:\n            U.region = me(T.int32());\n            break;\n          case 9:\n            U.datacenter = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        broadcastId: ce(p.broadcastId) ? String(p.broadcastId) : void 0,\n        duration: ce(p.duration) ? Number(p.duration) : void 0,\n        start: ce(p.start) ? String(p.start) : void 0,\n        stop: ce(p.stop) ? String(p.stop) : void 0,\n        phase: ce(p.phase) ? Ge(p.phase) : Ue.PROJECT_BROADCAST_PHASE_UNSPECIFIED,\n        region: ce(p.region) ? me(p.region) : void 0,\n        datacenter: ce(p.datacenter) ? String(p.datacenter) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.broadcastId !== void 0 && (b.broadcastId = p.broadcastId), p.duration !== void 0 && (b.duration = Math.round(p.duration)), p.start !== void 0 && (b.start = p.start), p.stop !== void 0 && (b.stop = p.stop), p.phase !== void 0 && (b.phase = He(p.phase)), p.region !== void 0 && (b.region = p.region !== void 0 ? Ie(p.region) : void 0), p.datacenter !== void 0 && (b.datacenter = p.datacenter), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U, te, We, et, dt, lt;\n      const pt = It();\n      return pt.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", pt.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", pt.broadcastId = (K = p.broadcastId) !== null && K !== void 0 ? K : void 0, pt.duration = (U = p.duration) !== null && U !== void 0 ? U : void 0, pt.start = (te = p.start) !== null && te !== void 0 ? te : void 0, pt.stop = (We = p.stop) !== null && We !== void 0 ? We : void 0, pt.phase = (et = p.phase) !== null && et !== void 0 ? et : Ue.PROJECT_BROADCAST_PHASE_UNSPECIFIED, pt.region = (dt = p.region) !== null && dt !== void 0 ? dt : void 0, pt.datacenter = (lt = p.datacenter) !== null && lt !== void 0 ? lt : void 0, pt;\n    }\n  };\n  function _t() {\n    return { collectionId: \"\", sourceId: \"\", metadata: void 0, preview: void 0, address: void 0 };\n  }\n  a.Source = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.sourceId !== \"\" && b.uint32(18).string(p.sourceId), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(26).fork()).ldelim(), p.preview !== void 0 && a.PreviewAddress.encode(p.preview, b.uint32(34).fork()).ldelim(), p.address !== void 0 && a.SourceAddress.encode(p.address, b.uint32(50).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = _t();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.sourceId = T.string();\n            break;\n          case 3:\n            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));\n            break;\n          case 4:\n            U.preview = a.PreviewAddress.decode(T, T.uint32());\n            break;\n          case 6:\n            U.address = a.SourceAddress.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        sourceId: ce(p.sourceId) ? String(p.sourceId) : \"\",\n        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,\n        preview: ce(p.preview) ? a.PreviewAddress.fromJSON(p.preview) : void 0,\n        address: ce(p.address) ? a.SourceAddress.fromJSON(p.address) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.metadata !== void 0 && (b.metadata = p.metadata), p.preview !== void 0 && (b.preview = p.preview ? a.PreviewAddress.toJSON(p.preview) : void 0), p.address !== void 0 && (b.address = p.address ? a.SourceAddress.toJSON(p.address) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = _t();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : \"\", U.metadata = (K = p.metadata) !== null && K !== void 0 ? K : void 0, U.preview = p.preview !== void 0 && p.preview !== null ? a.PreviewAddress.fromPartial(p.preview) : void 0, U.address = p.address !== void 0 && p.address !== null ? a.SourceAddress.fromPartial(p.address) : void 0, U;\n    }\n  };\n  function Rt() {\n    return {\n      collectionId: \"\",\n      projectId: \"\",\n      destinationId: \"\",\n      metadata: void 0,\n      enabled: void 0,\n      address: void 0,\n      timeout: void 0\n    };\n  }\n  a.Destination = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.destinationId !== \"\" && b.uint32(26).string(p.destinationId), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(34).fork()).ldelim(), p.enabled !== void 0 && b.uint32(40).bool(p.enabled), p.address !== void 0 && a.DestinationAddress.encode(p.address, b.uint32(50).fork()).ldelim(), p.timeout !== void 0 && b.uint32(56).uint32(p.timeout), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Rt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.destinationId = T.string();\n            break;\n          case 4:\n            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));\n            break;\n          case 5:\n            U.enabled = T.bool();\n            break;\n          case 6:\n            U.address = a.DestinationAddress.decode(T, T.uint32());\n            break;\n          case 7:\n            U.timeout = T.uint32();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        destinationId: ce(p.destinationId) ? String(p.destinationId) : \"\",\n        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,\n        enabled: ce(p.enabled) ? !!p.enabled : void 0,\n        address: ce(p.address) ? a.DestinationAddress.fromJSON(p.address) : void 0,\n        timeout: ce(p.timeout) ? Number(p.timeout) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.destinationId !== void 0 && (b.destinationId = p.destinationId), p.metadata !== void 0 && (b.metadata = p.metadata), p.enabled !== void 0 && (b.enabled = p.enabled), p.address !== void 0 && (b.address = p.address ? a.DestinationAddress.toJSON(p.address) : void 0), p.timeout !== void 0 && (b.timeout = Math.round(p.timeout)), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U, te, We;\n      const et = Rt();\n      return et.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", et.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", et.destinationId = (K = p.destinationId) !== null && K !== void 0 ? K : \"\", et.metadata = (U = p.metadata) !== null && U !== void 0 ? U : void 0, et.enabled = (te = p.enabled) !== null && te !== void 0 ? te : void 0, et.address = p.address !== void 0 && p.address !== null ? a.DestinationAddress.fromPartial(p.address) : void 0, et.timeout = (We = p.timeout) !== null && We !== void 0 ? We : void 0, et;\n    }\n  };\n  function Jt() {\n    return {\n      collectionId: \"\",\n      projectId: \"\",\n      metadata: void 0,\n      rendering: void 0,\n      encoding: void 0,\n      sources: [],\n      destinations: [],\n      composition: void 0,\n      maxDuration: void 0,\n      webrtc: void 0,\n      triggers: [],\n      location: void 0,\n      guestCodes: []\n    };\n  }\n  a.Project = {\n    encode(p, b = c.default.Writer.create()) {\n      p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(26).fork()).ldelim(), p.rendering !== void 0 && a.Rendering.encode(p.rendering, b.uint32(34).fork()).ldelim(), p.encoding !== void 0 && a.Encoding.encode(p.encoding, b.uint32(42).fork()).ldelim();\n      for (const T of p.sources)\n        a.Source.encode(T, b.uint32(50).fork()).ldelim();\n      for (const T of p.destinations)\n        a.Destination.encode(T, b.uint32(58).fork()).ldelim();\n      p.composition !== void 0 && a.Composition.encode(p.composition, b.uint32(66).fork()).ldelim(), p.maxDuration !== void 0 && b.uint32(72).uint32(p.maxDuration), p.webrtc !== void 0 && a.WebRtc.encode(p.webrtc, b.uint32(82).fork()).ldelim();\n      for (const T of p.triggers)\n        a.ProjectTrigger.encode(T, b.uint32(90).fork()).ldelim();\n      p.location !== void 0 && a.LatLong.encode(p.location, b.uint32(98).fork()).ldelim();\n      for (const T of p.guestCodes)\n        a.GuestCode.encode(T, b.uint32(106).fork()).ldelim();\n      return b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Jt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));\n            break;\n          case 4:\n            U.rendering = a.Rendering.decode(T, T.uint32());\n            break;\n          case 5:\n            U.encoding = a.Encoding.decode(T, T.uint32());\n            break;\n          case 6:\n            U.sources.push(a.Source.decode(T, T.uint32()));\n            break;\n          case 7:\n            U.destinations.push(a.Destination.decode(T, T.uint32()));\n            break;\n          case 8:\n            U.composition = a.Composition.decode(T, T.uint32());\n            break;\n          case 9:\n            U.maxDuration = T.uint32();\n            break;\n          case 10:\n            U.webrtc = a.WebRtc.decode(T, T.uint32());\n            break;\n          case 11:\n            U.triggers.push(a.ProjectTrigger.decode(T, T.uint32()));\n            break;\n          case 12:\n            U.location = a.LatLong.decode(T, T.uint32());\n            break;\n          case 13:\n            U.guestCodes.push(a.GuestCode.decode(T, T.uint32()));\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,\n        rendering: ce(p.rendering) ? a.Rendering.fromJSON(p.rendering) : void 0,\n        encoding: ce(p.encoding) ? a.Encoding.fromJSON(p.encoding) : void 0,\n        sources: Array.isArray(p == null ? void 0 : p.sources) ? p.sources.map((b) => a.Source.fromJSON(b)) : [],\n        destinations: Array.isArray(p == null ? void 0 : p.destinations) ? p.destinations.map((b) => a.Destination.fromJSON(b)) : [],\n        composition: ce(p.composition) ? a.Composition.fromJSON(p.composition) : void 0,\n        maxDuration: ce(p.maxDuration) ? Number(p.maxDuration) : void 0,\n        webrtc: ce(p.webrtc) ? a.WebRtc.fromJSON(p.webrtc) : void 0,\n        triggers: Array.isArray(p == null ? void 0 : p.triggers) ? p.triggers.map((b) => a.ProjectTrigger.fromJSON(b)) : [],\n        location: ce(p.location) ? a.LatLong.fromJSON(p.location) : void 0,\n        guestCodes: Array.isArray(p == null ? void 0 : p.guestCodes) ? p.guestCodes.map((b) => a.GuestCode.fromJSON(b)) : []\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.metadata !== void 0 && (b.metadata = p.metadata), p.rendering !== void 0 && (b.rendering = p.rendering ? a.Rendering.toJSON(p.rendering) : void 0), p.encoding !== void 0 && (b.encoding = p.encoding ? a.Encoding.toJSON(p.encoding) : void 0), p.sources ? b.sources = p.sources.map((T) => T ? a.Source.toJSON(T) : void 0) : b.sources = [], p.destinations ? b.destinations = p.destinations.map((T) => T ? a.Destination.toJSON(T) : void 0) : b.destinations = [], p.composition !== void 0 && (b.composition = p.composition ? a.Composition.toJSON(p.composition) : void 0), p.maxDuration !== void 0 && (b.maxDuration = Math.round(p.maxDuration)), p.webrtc !== void 0 && (b.webrtc = p.webrtc ? a.WebRtc.toJSON(p.webrtc) : void 0), p.triggers ? b.triggers = p.triggers.map((T) => T ? a.ProjectTrigger.toJSON(T) : void 0) : b.triggers = [], p.location !== void 0 && (b.location = p.location ? a.LatLong.toJSON(p.location) : void 0), p.guestCodes ? b.guestCodes = p.guestCodes.map((T) => T ? a.GuestCode.toJSON(T) : void 0) : b.guestCodes = [], b;\n    },\n    fromPartial(p) {\n      var b, T, K, U, te, We, et, dt;\n      const lt = Jt();\n      return lt.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", lt.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", lt.metadata = (K = p.metadata) !== null && K !== void 0 ? K : void 0, lt.rendering = p.rendering !== void 0 && p.rendering !== null ? a.Rendering.fromPartial(p.rendering) : void 0, lt.encoding = p.encoding !== void 0 && p.encoding !== null ? a.Encoding.fromPartial(p.encoding) : void 0, lt.sources = ((U = p.sources) === null || U === void 0 ? void 0 : U.map((pt) => a.Source.fromPartial(pt))) || [], lt.destinations = ((te = p.destinations) === null || te === void 0 ? void 0 : te.map((pt) => a.Destination.fromPartial(pt))) || [], lt.composition = p.composition !== void 0 && p.composition !== null ? a.Composition.fromPartial(p.composition) : void 0, lt.maxDuration = (We = p.maxDuration) !== null && We !== void 0 ? We : void 0, lt.webrtc = p.webrtc !== void 0 && p.webrtc !== null ? a.WebRtc.fromPartial(p.webrtc) : void 0, lt.triggers = ((et = p.triggers) === null || et === void 0 ? void 0 : et.map((pt) => a.ProjectTrigger.fromPartial(pt))) || [], lt.location = p.location !== void 0 && p.location !== null ? a.LatLong.fromPartial(p.location) : void 0, lt.guestCodes = ((dt = p.guestCodes) === null || dt === void 0 ? void 0 : dt.map((pt) => a.GuestCode.fromPartial(pt))) || [], lt;\n    }\n  };\n  function Ft() {\n    return { collectionId: \"\", metadata: void 0, projects: [], sources: [] };\n  }\n  a.Collection = {\n    encode(p, b = c.default.Writer.create()) {\n      p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(18).fork()).ldelim();\n      for (const T of p.projects)\n        a.Project.encode(T, b.uint32(26).fork()).ldelim();\n      for (const T of p.sources)\n        a.Source.encode(T, b.uint32(34).fork()).ldelim();\n      return b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Ft();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));\n            break;\n          case 3:\n            U.projects.push(a.Project.decode(T, T.uint32()));\n            break;\n          case 4:\n            U.sources.push(a.Source.decode(T, T.uint32()));\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,\n        projects: Array.isArray(p == null ? void 0 : p.projects) ? p.projects.map((b) => a.Project.fromJSON(b)) : [],\n        sources: Array.isArray(p == null ? void 0 : p.sources) ? p.sources.map((b) => a.Source.fromJSON(b)) : []\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.metadata !== void 0 && (b.metadata = p.metadata), p.projects ? b.projects = p.projects.map((T) => T ? a.Project.toJSON(T) : void 0) : b.projects = [], p.sources ? b.sources = p.sources.map((T) => T ? a.Source.toJSON(T) : void 0) : b.sources = [], b;\n    },\n    fromPartial(p) {\n      var b, T, K, U;\n      const te = Ft();\n      return te.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", te.metadata = (T = p.metadata) !== null && T !== void 0 ? T : void 0, te.projects = ((K = p.projects) === null || K === void 0 ? void 0 : K.map((We) => a.Project.fromPartial(We))) || [], te.sources = ((U = p.sources) === null || U === void 0 ? void 0 : U.map((We) => a.Source.fromPartial(We))) || [], te;\n    }\n  };\n  function Vt() {\n    return { metadata: void 0 };\n  }\n  a.CreateCollectionRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(10).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Vt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.metadata !== void 0 && (b.metadata = p.metadata), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = Vt();\n      return T.metadata = (b = p.metadata) !== null && b !== void 0 ? b : void 0, T;\n    }\n  };\n  function qt() {\n    return { collection: void 0 };\n  }\n  a.CreateCollectionResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collection !== void 0 && a.Collection.encode(p.collection, b.uint32(10).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = qt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collection = a.Collection.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { collection: ce(p.collection) ? a.Collection.fromJSON(p.collection) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collection !== void 0 && (b.collection = p.collection ? a.Collection.toJSON(p.collection) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = qt();\n      return b.collection = p.collection !== void 0 && p.collection !== null ? a.Collection.fromPartial(p.collection) : void 0, b;\n    }\n  };\n  function Gt() {\n    return { collectionId: \"\", populateProjects: void 0, populateSources: void 0 };\n  }\n  a.GetCollectionRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.populateProjects !== void 0 && b.uint32(16).bool(p.populateProjects), p.populateSources !== void 0 && b.uint32(24).bool(p.populateSources), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Gt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.populateProjects = T.bool();\n            break;\n          case 3:\n            U.populateSources = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        populateProjects: ce(p.populateProjects) ? !!p.populateProjects : void 0,\n        populateSources: ce(p.populateSources) ? !!p.populateSources : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.populateProjects !== void 0 && (b.populateProjects = p.populateProjects), p.populateSources !== void 0 && (b.populateSources = p.populateSources), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = Gt();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.populateProjects = (T = p.populateProjects) !== null && T !== void 0 ? T : void 0, U.populateSources = (K = p.populateSources) !== null && K !== void 0 ? K : void 0, U;\n    }\n  };\n  function Wt() {\n    return { collection: void 0 };\n  }\n  a.GetCollectionResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collection !== void 0 && a.Collection.encode(p.collection, b.uint32(10).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Wt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collection = a.Collection.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { collection: ce(p.collection) ? a.Collection.fromJSON(p.collection) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collection !== void 0 && (b.collection = p.collection ? a.Collection.toJSON(p.collection) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Wt();\n      return b.collection = p.collection !== void 0 && p.collection !== null ? a.Collection.fromPartial(p.collection) : void 0, b;\n    }\n  };\n  function Ht() {\n    return { collectionId: \"\", updateMask: void 0, metadata: void 0 };\n  }\n  a.UpdateCollectionRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(p.updateMask), b.uint32(18).fork()).ldelim(), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(26).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Ht();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(T, T.uint32()));\n            break;\n          case 3:\n            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        updateMask: ce(p.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(p.updateMask)) : void 0,\n        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.updateMask !== void 0 && (b.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(p.updateMask))), p.metadata !== void 0 && (b.metadata = p.metadata), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = Ht();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.updateMask = (T = p.updateMask) !== null && T !== void 0 ? T : void 0, U.metadata = (K = p.metadata) !== null && K !== void 0 ? K : void 0, U;\n    }\n  };\n  function xt() {\n    return { collection: void 0 };\n  }\n  a.UpdateCollectionResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collection !== void 0 && a.Collection.encode(p.collection, b.uint32(10).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = xt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collection = a.Collection.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { collection: ce(p.collection) ? a.Collection.fromJSON(p.collection) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collection !== void 0 && (b.collection = p.collection ? a.Collection.toJSON(p.collection) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = xt();\n      return b.collection = p.collection !== void 0 && p.collection !== null ? a.Collection.fromPartial(p.collection) : void 0, b;\n    }\n  };\n  function zt() {\n    return { collectionId: \"\", force: void 0 };\n  }\n  a.DeleteCollectionRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.force !== void 0 && b.uint32(16).bool(p.force), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = zt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.force = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        force: ce(p.force) ? !!p.force : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.force !== void 0 && (b.force = p.force), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = zt();\n      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", K.force = (T = p.force) !== null && T !== void 0 ? T : void 0, K;\n    }\n  };\n  function Yt() {\n    return { sourcesDeleted: 0, projectsDeleted: 0, projectIdsStopped: [] };\n  }\n  a.DeleteCollectionResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      p.sourcesDeleted !== 0 && b.uint32(8).uint32(p.sourcesDeleted), p.projectsDeleted !== 0 && b.uint32(16).uint32(p.projectsDeleted);\n      for (const T of p.projectIdsStopped)\n        b.uint32(26).string(T);\n      return b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Yt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.sourcesDeleted = T.uint32();\n            break;\n          case 2:\n            U.projectsDeleted = T.uint32();\n            break;\n          case 3:\n            U.projectIdsStopped.push(T.string());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        sourcesDeleted: ce(p.sourcesDeleted) ? Number(p.sourcesDeleted) : 0,\n        projectsDeleted: ce(p.projectsDeleted) ? Number(p.projectsDeleted) : 0,\n        projectIdsStopped: Array.isArray(p == null ? void 0 : p.projectIdsStopped) ? p.projectIdsStopped.map((b) => String(b)) : []\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.sourcesDeleted !== void 0 && (b.sourcesDeleted = Math.round(p.sourcesDeleted)), p.projectsDeleted !== void 0 && (b.projectsDeleted = Math.round(p.projectsDeleted)), p.projectIdsStopped ? b.projectIdsStopped = p.projectIdsStopped.map((T) => T) : b.projectIdsStopped = [], b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = Yt();\n      return U.sourcesDeleted = (b = p.sourcesDeleted) !== null && b !== void 0 ? b : 0, U.projectsDeleted = (T = p.projectsDeleted) !== null && T !== void 0 ? T : 0, U.projectIdsStopped = ((K = p.projectIdsStopped) === null || K === void 0 ? void 0 : K.map((te) => te)) || [], U;\n    }\n  };\n  function Kt() {\n    return {};\n  }\n  a.GetCollectionsRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Kt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {};\n    },\n    toJSON(p) {\n      return {};\n    },\n    fromPartial(p) {\n      return Kt();\n    }\n  };\n  function Qt() {\n    return { collections: [] };\n  }\n  a.GetCollectionsResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      for (const T of p.collections)\n        a.Collection.encode(T, b.uint32(10).fork()).ldelim();\n      return b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Qt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collections.push(a.Collection.decode(T, T.uint32()));\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collections: Array.isArray(p == null ? void 0 : p.collections) ? p.collections.map((b) => a.Collection.fromJSON(b)) : []\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collections ? b.collections = p.collections.map((T) => T ? a.Collection.toJSON(T) : void 0) : b.collections = [], b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = Qt();\n      return T.collections = ((b = p.collections) === null || b === void 0 ? void 0 : b.map((K) => a.Collection.fromPartial(K))) || [], T;\n    }\n  };\n  function Zt() {\n    return {\n      collectionId: \"\",\n      metadata: void 0,\n      rendering: void 0,\n      encoding: void 0,\n      composition: void 0,\n      maxDuration: void 0,\n      webrtc: void 0,\n      location: void 0\n    };\n  }\n  a.CreateProjectRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(18).fork()).ldelim(), p.rendering !== void 0 && a.Rendering.encode(p.rendering, b.uint32(26).fork()).ldelim(), p.encoding !== void 0 && a.Encoding.encode(p.encoding, b.uint32(34).fork()).ldelim(), p.composition !== void 0 && a.Composition.encode(p.composition, b.uint32(42).fork()).ldelim(), p.maxDuration !== void 0 && b.uint32(48).uint32(p.maxDuration), p.webrtc !== void 0 && a.WebRtc.encode(p.webrtc, b.uint32(58).fork()).ldelim(), p.location !== void 0 && a.LatLong.encode(p.location, b.uint32(74).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Zt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));\n            break;\n          case 3:\n            U.rendering = a.Rendering.decode(T, T.uint32());\n            break;\n          case 4:\n            U.encoding = a.Encoding.decode(T, T.uint32());\n            break;\n          case 5:\n            U.composition = a.Composition.decode(T, T.uint32());\n            break;\n          case 6:\n            U.maxDuration = T.uint32();\n            break;\n          case 7:\n            U.webrtc = a.WebRtc.decode(T, T.uint32());\n            break;\n          case 9:\n            U.location = a.LatLong.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,\n        rendering: ce(p.rendering) ? a.Rendering.fromJSON(p.rendering) : void 0,\n        encoding: ce(p.encoding) ? a.Encoding.fromJSON(p.encoding) : void 0,\n        composition: ce(p.composition) ? a.Composition.fromJSON(p.composition) : void 0,\n        maxDuration: ce(p.maxDuration) ? Number(p.maxDuration) : void 0,\n        webrtc: ce(p.webrtc) ? a.WebRtc.fromJSON(p.webrtc) : void 0,\n        location: ce(p.location) ? a.LatLong.fromJSON(p.location) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.metadata !== void 0 && (b.metadata = p.metadata), p.rendering !== void 0 && (b.rendering = p.rendering ? a.Rendering.toJSON(p.rendering) : void 0), p.encoding !== void 0 && (b.encoding = p.encoding ? a.Encoding.toJSON(p.encoding) : void 0), p.composition !== void 0 && (b.composition = p.composition ? a.Composition.toJSON(p.composition) : void 0), p.maxDuration !== void 0 && (b.maxDuration = Math.round(p.maxDuration)), p.webrtc !== void 0 && (b.webrtc = p.webrtc ? a.WebRtc.toJSON(p.webrtc) : void 0), p.location !== void 0 && (b.location = p.location ? a.LatLong.toJSON(p.location) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = Zt();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.metadata = (T = p.metadata) !== null && T !== void 0 ? T : void 0, U.rendering = p.rendering !== void 0 && p.rendering !== null ? a.Rendering.fromPartial(p.rendering) : void 0, U.encoding = p.encoding !== void 0 && p.encoding !== null ? a.Encoding.fromPartial(p.encoding) : void 0, U.composition = p.composition !== void 0 && p.composition !== null ? a.Composition.fromPartial(p.composition) : void 0, U.maxDuration = (K = p.maxDuration) !== null && K !== void 0 ? K : void 0, U.webrtc = p.webrtc !== void 0 && p.webrtc !== null ? a.WebRtc.fromPartial(p.webrtc) : void 0, U.location = p.location !== void 0 && p.location !== null ? a.LatLong.fromPartial(p.location) : void 0, U;\n    }\n  };\n  function Xt() {\n    return { project: void 0 };\n  }\n  a.CreateProjectResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.project !== void 0 && a.Project.encode(p.project, b.uint32(10).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Xt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.project = a.Project.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { project: ce(p.project) ? a.Project.fromJSON(p.project) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.project !== void 0 && (b.project = p.project ? a.Project.toJSON(p.project) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Xt();\n      return b.project = p.project !== void 0 && p.project !== null ? a.Project.fromPartial(p.project) : void 0, b;\n    }\n  };\n  function jt() {\n    return {\n      collectionId: \"\",\n      projectId: \"\",\n      updateMask: void 0,\n      metadata: void 0,\n      rendering: void 0,\n      encoding: void 0,\n      composition: void 0,\n      maxDuration: void 0,\n      webrtc: void 0,\n      location: void 0\n    };\n  }\n  a.UpdateProjectRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(p.updateMask), b.uint32(26).fork()).ldelim(), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(34).fork()).ldelim(), p.rendering !== void 0 && a.Rendering.encode(p.rendering, b.uint32(42).fork()).ldelim(), p.encoding !== void 0 && a.Encoding.encode(p.encoding, b.uint32(50).fork()).ldelim(), p.composition !== void 0 && a.Composition.encode(p.composition, b.uint32(58).fork()).ldelim(), p.maxDuration !== void 0 && b.uint32(64).uint32(p.maxDuration), p.webrtc !== void 0 && a.WebRtc.encode(p.webrtc, b.uint32(74).fork()).ldelim(), p.location !== void 0 && a.LatLong.encode(p.location, b.uint32(82).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = jt();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(T, T.uint32()));\n            break;\n          case 4:\n            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));\n            break;\n          case 5:\n            U.rendering = a.Rendering.decode(T, T.uint32());\n            break;\n          case 6:\n            U.encoding = a.Encoding.decode(T, T.uint32());\n            break;\n          case 7:\n            U.composition = a.Composition.decode(T, T.uint32());\n            break;\n          case 8:\n            U.maxDuration = T.uint32();\n            break;\n          case 9:\n            U.webrtc = a.WebRtc.decode(T, T.uint32());\n            break;\n          case 10:\n            U.location = a.LatLong.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        updateMask: ce(p.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(p.updateMask)) : void 0,\n        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,\n        rendering: ce(p.rendering) ? a.Rendering.fromJSON(p.rendering) : void 0,\n        encoding: ce(p.encoding) ? a.Encoding.fromJSON(p.encoding) : void 0,\n        composition: ce(p.composition) ? a.Composition.fromJSON(p.composition) : void 0,\n        maxDuration: ce(p.maxDuration) ? Number(p.maxDuration) : void 0,\n        webrtc: ce(p.webrtc) ? a.WebRtc.fromJSON(p.webrtc) : void 0,\n        location: ce(p.location) ? a.LatLong.fromJSON(p.location) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.updateMask !== void 0 && (b.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(p.updateMask))), p.metadata !== void 0 && (b.metadata = p.metadata), p.rendering !== void 0 && (b.rendering = p.rendering ? a.Rendering.toJSON(p.rendering) : void 0), p.encoding !== void 0 && (b.encoding = p.encoding ? a.Encoding.toJSON(p.encoding) : void 0), p.composition !== void 0 && (b.composition = p.composition ? a.Composition.toJSON(p.composition) : void 0), p.maxDuration !== void 0 && (b.maxDuration = Math.round(p.maxDuration)), p.webrtc !== void 0 && (b.webrtc = p.webrtc ? a.WebRtc.toJSON(p.webrtc) : void 0), p.location !== void 0 && (b.location = p.location ? a.LatLong.toJSON(p.location) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U, te;\n      const We = jt();\n      return We.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", We.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", We.updateMask = (K = p.updateMask) !== null && K !== void 0 ? K : void 0, We.metadata = (U = p.metadata) !== null && U !== void 0 ? U : void 0, We.rendering = p.rendering !== void 0 && p.rendering !== null ? a.Rendering.fromPartial(p.rendering) : void 0, We.encoding = p.encoding !== void 0 && p.encoding !== null ? a.Encoding.fromPartial(p.encoding) : void 0, We.composition = p.composition !== void 0 && p.composition !== null ? a.Composition.fromPartial(p.composition) : void 0, We.maxDuration = (te = p.maxDuration) !== null && te !== void 0 ? te : void 0, We.webrtc = p.webrtc !== void 0 && p.webrtc !== null ? a.WebRtc.fromPartial(p.webrtc) : void 0, We.location = p.location !== void 0 && p.location !== null ? a.LatLong.fromPartial(p.location) : void 0, We;\n    }\n  };\n  function en() {\n    return { project: void 0, broadcastUpdated: !1 };\n  }\n  a.UpdateProjectResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.project !== void 0 && a.Project.encode(p.project, b.uint32(10).fork()).ldelim(), p.broadcastUpdated === !0 && b.uint32(16).bool(p.broadcastUpdated), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = en();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.project = a.Project.decode(T, T.uint32());\n            break;\n          case 2:\n            U.broadcastUpdated = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        project: ce(p.project) ? a.Project.fromJSON(p.project) : void 0,\n        broadcastUpdated: ce(p.broadcastUpdated) ? !!p.broadcastUpdated : !1\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.project !== void 0 && (b.project = p.project ? a.Project.toJSON(p.project) : void 0), p.broadcastUpdated !== void 0 && (b.broadcastUpdated = p.broadcastUpdated), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = en();\n      return T.project = p.project !== void 0 && p.project !== null ? a.Project.fromPartial(p.project) : void 0, T.broadcastUpdated = (b = p.broadcastUpdated) !== null && b !== void 0 ? b : !1, T;\n    }\n  };\n  function tn() {\n    return { collectionId: \"\", projectId: \"\", force: void 0 };\n  }\n  a.DeleteProjectRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.force !== void 0 && b.uint32(24).bool(p.force), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = tn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.force = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        force: ce(p.force) ? !!p.force : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.force !== void 0 && (b.force = p.force), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = tn();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", U.force = (K = p.force) !== null && K !== void 0 ? K : void 0, U;\n    }\n  };\n  function nn() {\n    return { broadcastStopped: !1, layoutsDeleted: 0 };\n  }\n  a.DeleteProjectResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.broadcastStopped === !0 && b.uint32(8).bool(p.broadcastStopped), p.layoutsDeleted !== 0 && b.uint32(16).uint32(p.layoutsDeleted), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = nn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.broadcastStopped = T.bool();\n            break;\n          case 2:\n            U.layoutsDeleted = T.uint32();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        broadcastStopped: ce(p.broadcastStopped) ? !!p.broadcastStopped : !1,\n        layoutsDeleted: ce(p.layoutsDeleted) ? Number(p.layoutsDeleted) : 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.broadcastStopped !== void 0 && (b.broadcastStopped = p.broadcastStopped), p.layoutsDeleted !== void 0 && (b.layoutsDeleted = Math.round(p.layoutsDeleted)), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = nn();\n      return K.broadcastStopped = (b = p.broadcastStopped) !== null && b !== void 0 ? b : !1, K.layoutsDeleted = (T = p.layoutsDeleted) !== null && T !== void 0 ? T : 0, K;\n    }\n  };\n  function rn() {\n    return { collectionId: \"\", projectId: \"\", webrtcStart: void 0 };\n  }\n  a.StartProjectBroadcastRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.webrtcStart !== void 0 && b.uint32(24).bool(p.webrtcStart), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = rn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.webrtcStart = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        webrtcStart: ce(p.webrtcStart) ? !!p.webrtcStart : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.webrtcStart !== void 0 && (b.webrtcStart = p.webrtcStart), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = rn();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", U.webrtcStart = (K = p.webrtcStart) !== null && K !== void 0 ? K : void 0, U;\n    }\n  };\n  function an() {\n    return { broadcastId: \"\" };\n  }\n  a.StartProjectBroadcastResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.broadcastId !== \"\" && b.uint32(10).string(p.broadcastId), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = an();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.broadcastId = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { broadcastId: ce(p.broadcastId) ? String(p.broadcastId) : \"\" };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.broadcastId !== void 0 && (b.broadcastId = p.broadcastId), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = an();\n      return T.broadcastId = (b = p.broadcastId) !== null && b !== void 0 ? b : \"\", T;\n    }\n  };\n  function sn() {\n    return { collectionId: \"\", projectId: \"\", webrtcStop: void 0 };\n  }\n  a.StopProjectBroadcastRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.webrtcStop !== void 0 && b.uint32(24).bool(p.webrtcStop), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = sn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.webrtcStop = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        webrtcStop: ce(p.webrtcStop) ? !!p.webrtcStop : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.webrtcStop !== void 0 && (b.webrtcStop = p.webrtcStop), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = sn();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", U.webrtcStop = (K = p.webrtcStop) !== null && K !== void 0 ? K : void 0, U;\n    }\n  };\n  function dn() {\n    return {};\n  }\n  a.StopProjectBroadcastResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = dn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {};\n    },\n    toJSON(p) {\n      return {};\n    },\n    fromPartial(p) {\n      return dn();\n    }\n  };\n  function un() {\n    return { collectionId: \"\", projectId: \"\", status: void 0 };\n  }\n  a.GetProjectRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.status !== void 0 && b.uint32(24).bool(p.status), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = un();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.status = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        status: ce(p.status) ? !!p.status : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.status !== void 0 && (b.status = p.status), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = un();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", U.status = (K = p.status) !== null && K !== void 0 ? K : void 0, U;\n    }\n  };\n  function cn() {\n    return { project: void 0, status: void 0 };\n  }\n  a.GetProjectResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.project !== void 0 && a.Project.encode(p.project, b.uint32(10).fork()).ldelim(), p.status !== void 0 && a.ProjectBroadcastStatus.encode(p.status, b.uint32(18).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = cn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.project = a.Project.decode(T, T.uint32());\n            break;\n          case 2:\n            U.status = a.ProjectBroadcastStatus.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        project: ce(p.project) ? a.Project.fromJSON(p.project) : void 0,\n        status: ce(p.status) ? a.ProjectBroadcastStatus.fromJSON(p.status) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.project !== void 0 && (b.project = p.project ? a.Project.toJSON(p.project) : void 0), p.status !== void 0 && (b.status = p.status ? a.ProjectBroadcastStatus.toJSON(p.status) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = cn();\n      return b.project = p.project !== void 0 && p.project !== null ? a.Project.fromPartial(p.project) : void 0, b.status = p.status !== void 0 && p.status !== null ? a.ProjectBroadcastStatus.fromPartial(p.status) : void 0, b;\n    }\n  };\n  function ln() {\n    return { collectionId: \"\", projectId: \"\", format: void 0 };\n  }\n  a.GetProjectBroadcastSnapshotRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.format !== void 0 && b.uint32(24).int32(L(p.format)), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = ln();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.format = _(T.int32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        format: ce(p.format) ? _(p.format) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.format !== void 0 && (b.format = p.format !== void 0 ? k(p.format) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = ln();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", U.format = (K = p.format) !== null && K !== void 0 ? K : void 0, U;\n    }\n  };\n  function fn() {\n    return { format: E.IMAGE_FORMAT_UNSPECIFIED, image: new Uint8Array() };\n  }\n  a.GetProjectBroadcastSnapshotResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.format !== E.IMAGE_FORMAT_UNSPECIFIED && b.uint32(8).int32(L(p.format)), p.image.length !== 0 && b.uint32(18).bytes(p.image), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = fn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.format = _(T.int32());\n            break;\n          case 2:\n            U.image = T.bytes();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        format: ce(p.format) ? _(p.format) : E.IMAGE_FORMAT_UNSPECIFIED,\n        image: ce(p.image) ? Fr(p.image) : new Uint8Array()\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.format !== void 0 && (b.format = k(p.format)), p.image !== void 0 && (b.image = Vr(p.image !== void 0 ? p.image : new Uint8Array())), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = fn();\n      return K.format = (b = p.format) !== null && b !== void 0 ? b : E.IMAGE_FORMAT_UNSPECIFIED, K.image = (T = p.image) !== null && T !== void 0 ? T : new Uint8Array(), K;\n    }\n  };\n  function pn() {\n    return { collectionId: \"\", projectId: \"\" };\n  }\n  a.GetProjectBroadcastStatusRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = pn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\"\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = pn();\n      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", K.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", K;\n    }\n  };\n  function hn() {\n    return { status: void 0 };\n  }\n  a.GetProjectBroadcastStatusResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.status !== void 0 && a.ProjectBroadcastStatus.encode(p.status, b.uint32(10).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = hn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.status = a.ProjectBroadcastStatus.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { status: ce(p.status) ? a.ProjectBroadcastStatus.fromJSON(p.status) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.status !== void 0 && (b.status = p.status ? a.ProjectBroadcastStatus.toJSON(p.status) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = hn();\n      return b.status = p.status !== void 0 && p.status !== null ? a.ProjectBroadcastStatus.fromPartial(p.status) : void 0, b;\n    }\n  };\n  function mn() {\n    return { collectionId: \"\", projectId: \"\" };\n  }\n  a.StartProjectWebRtcRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = mn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\"\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = mn();\n      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", K.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", K;\n    }\n  };\n  function vn() {\n    return {};\n  }\n  a.StartProjectWebRtcResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = vn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {};\n    },\n    toJSON(p) {\n      return {};\n    },\n    fromPartial(p) {\n      return vn();\n    }\n  };\n  function Sn() {\n    return { collectionId: \"\", projectId: \"\" };\n  }\n  a.StopProjectWebRtcRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Sn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\"\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = Sn();\n      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", K.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", K;\n    }\n  };\n  function yn() {\n    return {};\n  }\n  a.StopProjectWebRtcResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = yn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {};\n    },\n    toJSON(p) {\n      return {};\n    },\n    fromPartial(p) {\n      return yn();\n    }\n  };\n  function gn() {\n    return {\n      collectionId: \"\",\n      projectId: \"\",\n      metadata: void 0,\n      address: void 0,\n      enabled: void 0,\n      timeout: void 0\n    };\n  }\n  a.CreateDestinationRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(26).fork()).ldelim(), p.address !== void 0 && a.DestinationAddress.encode(p.address, b.uint32(42).fork()).ldelim(), p.enabled !== void 0 && b.uint32(48).bool(p.enabled), p.timeout !== void 0 && b.uint32(56).uint32(p.timeout), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = gn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));\n            break;\n          case 5:\n            U.address = a.DestinationAddress.decode(T, T.uint32());\n            break;\n          case 6:\n            U.enabled = T.bool();\n            break;\n          case 7:\n            U.timeout = T.uint32();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,\n        address: ce(p.address) ? a.DestinationAddress.fromJSON(p.address) : void 0,\n        enabled: ce(p.enabled) ? !!p.enabled : void 0,\n        timeout: ce(p.timeout) ? Number(p.timeout) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.metadata !== void 0 && (b.metadata = p.metadata), p.address !== void 0 && (b.address = p.address ? a.DestinationAddress.toJSON(p.address) : void 0), p.enabled !== void 0 && (b.enabled = p.enabled), p.timeout !== void 0 && (b.timeout = Math.round(p.timeout)), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U, te;\n      const We = gn();\n      return We.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", We.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", We.metadata = (K = p.metadata) !== null && K !== void 0 ? K : void 0, We.address = p.address !== void 0 && p.address !== null ? a.DestinationAddress.fromPartial(p.address) : void 0, We.enabled = (U = p.enabled) !== null && U !== void 0 ? U : void 0, We.timeout = (te = p.timeout) !== null && te !== void 0 ? te : void 0, We;\n    }\n  };\n  function bn() {\n    return { destination: void 0 };\n  }\n  a.CreateDestinationResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.destination !== void 0 && a.Destination.encode(p.destination, b.uint32(10).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = bn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.destination = a.Destination.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { destination: ce(p.destination) ? a.Destination.fromJSON(p.destination) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.destination !== void 0 && (b.destination = p.destination ? a.Destination.toJSON(p.destination) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = bn();\n      return b.destination = p.destination !== void 0 && p.destination !== null ? a.Destination.fromPartial(p.destination) : void 0, b;\n    }\n  };\n  function En() {\n    return { collectionId: \"\", projectId: \"\", destinationId: \"\" };\n  }\n  a.GetDestinationRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.destinationId !== \"\" && b.uint32(26).string(p.destinationId), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = En();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.destinationId = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        destinationId: ce(p.destinationId) ? String(p.destinationId) : \"\"\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.destinationId !== void 0 && (b.destinationId = p.destinationId), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = En();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", U.destinationId = (K = p.destinationId) !== null && K !== void 0 ? K : \"\", U;\n    }\n  };\n  function Tn() {\n    return { destination: void 0 };\n  }\n  a.GetDestinationResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.destination !== void 0 && a.Destination.encode(p.destination, b.uint32(10).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Tn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.destination = a.Destination.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { destination: ce(p.destination) ? a.Destination.fromJSON(p.destination) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.destination !== void 0 && (b.destination = p.destination ? a.Destination.toJSON(p.destination) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Tn();\n      return b.destination = p.destination !== void 0 && p.destination !== null ? a.Destination.fromPartial(p.destination) : void 0, b;\n    }\n  };\n  function _n() {\n    return { collectionId: \"\", projectId: \"\", destinationId: \"\", force: void 0 };\n  }\n  a.DeleteDestinationRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.destinationId !== \"\" && b.uint32(26).string(p.destinationId), p.force !== void 0 && b.uint32(32).bool(p.force), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = _n();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.destinationId = T.string();\n            break;\n          case 4:\n            U.force = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        destinationId: ce(p.destinationId) ? String(p.destinationId) : \"\",\n        force: ce(p.force) ? !!p.force : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.destinationId !== void 0 && (b.destinationId = p.destinationId), p.force !== void 0 && (b.force = p.force), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U;\n      const te = _n();\n      return te.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", te.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", te.destinationId = (K = p.destinationId) !== null && K !== void 0 ? K : \"\", te.force = (U = p.force) !== null && U !== void 0 ? U : void 0, te;\n    }\n  };\n  function In() {\n    return { broadcastUpdated: !1 };\n  }\n  a.DeleteDestinationResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.broadcastUpdated === !0 && b.uint32(8).bool(p.broadcastUpdated), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = In();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.broadcastUpdated = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { broadcastUpdated: ce(p.broadcastUpdated) ? !!p.broadcastUpdated : !1 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.broadcastUpdated !== void 0 && (b.broadcastUpdated = p.broadcastUpdated), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = In();\n      return T.broadcastUpdated = (b = p.broadcastUpdated) !== null && b !== void 0 ? b : !1, T;\n    }\n  };\n  function kn() {\n    return {\n      collectionId: \"\",\n      projectId: \"\",\n      destinationId: \"\",\n      updateMask: void 0,\n      metadata: void 0,\n      address: void 0,\n      enabled: void 0,\n      timeout: void 0\n    };\n  }\n  a.UpdateDestinationRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.destinationId !== \"\" && b.uint32(26).string(p.destinationId), p.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(p.updateMask), b.uint32(34).fork()).ldelim(), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(42).fork()).ldelim(), p.address !== void 0 && a.DestinationAddress.encode(p.address, b.uint32(50).fork()).ldelim(), p.enabled !== void 0 && b.uint32(56).bool(p.enabled), p.timeout !== void 0 && b.uint32(64).uint32(p.timeout), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = kn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.destinationId = T.string();\n            break;\n          case 4:\n            U.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(T, T.uint32()));\n            break;\n          case 5:\n            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));\n            break;\n          case 6:\n            U.address = a.DestinationAddress.decode(T, T.uint32());\n            break;\n          case 7:\n            U.enabled = T.bool();\n            break;\n          case 8:\n            U.timeout = T.uint32();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        destinationId: ce(p.destinationId) ? String(p.destinationId) : \"\",\n        updateMask: ce(p.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(p.updateMask)) : void 0,\n        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,\n        address: ce(p.address) ? a.DestinationAddress.fromJSON(p.address) : void 0,\n        enabled: ce(p.enabled) ? !!p.enabled : void 0,\n        timeout: ce(p.timeout) ? Number(p.timeout) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.destinationId !== void 0 && (b.destinationId = p.destinationId), p.updateMask !== void 0 && (b.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(p.updateMask))), p.metadata !== void 0 && (b.metadata = p.metadata), p.address !== void 0 && (b.address = p.address ? a.DestinationAddress.toJSON(p.address) : void 0), p.enabled !== void 0 && (b.enabled = p.enabled), p.timeout !== void 0 && (b.timeout = Math.round(p.timeout)), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U, te, We, et;\n      const dt = kn();\n      return dt.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", dt.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", dt.destinationId = (K = p.destinationId) !== null && K !== void 0 ? K : \"\", dt.updateMask = (U = p.updateMask) !== null && U !== void 0 ? U : void 0, dt.metadata = (te = p.metadata) !== null && te !== void 0 ? te : void 0, dt.address = p.address !== void 0 && p.address !== null ? a.DestinationAddress.fromPartial(p.address) : void 0, dt.enabled = (We = p.enabled) !== null && We !== void 0 ? We : void 0, dt.timeout = (et = p.timeout) !== null && et !== void 0 ? et : void 0, dt;\n    }\n  };\n  function Cn() {\n    return { destination: void 0, broadcastUpdated: !1 };\n  }\n  a.UpdateDestinationResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.destination !== void 0 && a.Destination.encode(p.destination, b.uint32(10).fork()).ldelim(), p.broadcastUpdated === !0 && b.uint32(16).bool(p.broadcastUpdated), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Cn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.destination = a.Destination.decode(T, T.uint32());\n            break;\n          case 2:\n            U.broadcastUpdated = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        destination: ce(p.destination) ? a.Destination.fromJSON(p.destination) : void 0,\n        broadcastUpdated: ce(p.broadcastUpdated) ? !!p.broadcastUpdated : !1\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.destination !== void 0 && (b.destination = p.destination ? a.Destination.toJSON(p.destination) : void 0), p.broadcastUpdated !== void 0 && (b.broadcastUpdated = p.broadcastUpdated), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = Cn();\n      return T.destination = p.destination !== void 0 && p.destination !== null ? a.Destination.fromPartial(p.destination) : void 0, T.broadcastUpdated = (b = p.broadcastUpdated) !== null && b !== void 0 ? b : !1, T;\n    }\n  };\n  function Rn() {\n    return { collectionId: \"\", metadata: void 0, address: void 0, preview: void 0 };\n  }\n  a.CreateSourceRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(18).fork()).ldelim(), p.address !== void 0 && a.SourceAddress.encode(p.address, b.uint32(26).fork()).ldelim(), p.preview !== void 0 && a.PreviewAddress.encode(p.preview, b.uint32(34).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Rn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));\n            break;\n          case 3:\n            U.address = a.SourceAddress.decode(T, T.uint32());\n            break;\n          case 4:\n            U.preview = a.PreviewAddress.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,\n        address: ce(p.address) ? a.SourceAddress.fromJSON(p.address) : void 0,\n        preview: ce(p.preview) ? a.PreviewAddress.fromJSON(p.preview) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.metadata !== void 0 && (b.metadata = p.metadata), p.address !== void 0 && (b.address = p.address ? a.SourceAddress.toJSON(p.address) : void 0), p.preview !== void 0 && (b.preview = p.preview ? a.PreviewAddress.toJSON(p.preview) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = Rn();\n      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", K.metadata = (T = p.metadata) !== null && T !== void 0 ? T : void 0, K.address = p.address !== void 0 && p.address !== null ? a.SourceAddress.fromPartial(p.address) : void 0, K.preview = p.preview !== void 0 && p.preview !== null ? a.PreviewAddress.fromPartial(p.preview) : void 0, K;\n    }\n  };\n  function Pn() {\n    return { source: void 0 };\n  }\n  a.CreateSourceResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.source !== void 0 && a.Source.encode(p.source, b.uint32(10).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Pn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.source = a.Source.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { source: ce(p.source) ? a.Source.fromJSON(p.source) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.source !== void 0 && (b.source = p.source ? a.Source.toJSON(p.source) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Pn();\n      return b.source = p.source !== void 0 && p.source !== null ? a.Source.fromPartial(p.source) : void 0, b;\n    }\n  };\n  function On() {\n    return { collectionId: \"\", sourceId: \"\", force: void 0 };\n  }\n  a.DeleteSourceRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.sourceId !== \"\" && b.uint32(18).string(p.sourceId), p.force !== void 0 && b.uint32(24).bool(p.force), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = On();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.sourceId = T.string();\n            break;\n          case 3:\n            U.force = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        sourceId: ce(p.sourceId) ? String(p.sourceId) : \"\",\n        force: ce(p.force) ? !!p.force : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.force !== void 0 && (b.force = p.force), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = On();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : \"\", U.force = (K = p.force) !== null && K !== void 0 ? K : void 0, U;\n    }\n  };\n  function Nn() {\n    return { projectIdsUpdated: [] };\n  }\n  a.DeleteSourceResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      for (const T of p.projectIdsUpdated)\n        b.uint32(26).string(T);\n      return b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Nn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 3:\n            U.projectIdsUpdated.push(T.string());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        projectIdsUpdated: Array.isArray(p == null ? void 0 : p.projectIdsUpdated) ? p.projectIdsUpdated.map((b) => String(b)) : []\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.projectIdsUpdated ? b.projectIdsUpdated = p.projectIdsUpdated.map((T) => T) : b.projectIdsUpdated = [], b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = Nn();\n      return T.projectIdsUpdated = ((b = p.projectIdsUpdated) === null || b === void 0 ? void 0 : b.map((K) => K)) || [], T;\n    }\n  };\n  function wn() {\n    return { collectionId: \"\", projectId: \"\", sourceId: \"\", trigger: void 0 };\n  }\n  a.AddSourceToProjectRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.sourceId !== \"\" && b.uint32(26).string(p.sourceId), p.trigger !== void 0 && a.SourceTrigger.encode(p.trigger, b.uint32(34).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = wn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.sourceId = T.string();\n            break;\n          case 4:\n            U.trigger = a.SourceTrigger.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        sourceId: ce(p.sourceId) ? String(p.sourceId) : \"\",\n        trigger: ce(p.trigger) ? a.SourceTrigger.fromJSON(p.trigger) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.trigger !== void 0 && (b.trigger = p.trigger ? a.SourceTrigger.toJSON(p.trigger) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = wn();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", U.sourceId = (K = p.sourceId) !== null && K !== void 0 ? K : \"\", U.trigger = p.trigger !== void 0 && p.trigger !== null ? a.SourceTrigger.fromPartial(p.trigger) : void 0, U;\n    }\n  };\n  function An() {\n    return { project: void 0, broadcastUpdated: !1 };\n  }\n  a.AddSourceToProjectResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.project !== void 0 && a.Project.encode(p.project, b.uint32(10).fork()).ldelim(), p.broadcastUpdated === !0 && b.uint32(16).bool(p.broadcastUpdated), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = An();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.project = a.Project.decode(T, T.uint32());\n            break;\n          case 2:\n            U.broadcastUpdated = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        project: ce(p.project) ? a.Project.fromJSON(p.project) : void 0,\n        broadcastUpdated: ce(p.broadcastUpdated) ? !!p.broadcastUpdated : !1\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.project !== void 0 && (b.project = p.project ? a.Project.toJSON(p.project) : void 0), p.broadcastUpdated !== void 0 && (b.broadcastUpdated = p.broadcastUpdated), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = An();\n      return T.project = p.project !== void 0 && p.project !== null ? a.Project.fromPartial(p.project) : void 0, T.broadcastUpdated = (b = p.broadcastUpdated) !== null && b !== void 0 ? b : !1, T;\n    }\n  };\n  function Dn() {\n    return { collectionId: \"\", projectId: \"\", sourceId: \"\", updateMask: void 0, trigger: void 0 };\n  }\n  a.UpdateSourceInProjectRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.sourceId !== \"\" && b.uint32(26).string(p.sourceId), p.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(p.updateMask), b.uint32(34).fork()).ldelim(), p.trigger !== void 0 && a.SourceTrigger.encode(p.trigger, b.uint32(42).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Dn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.sourceId = T.string();\n            break;\n          case 4:\n            U.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(T, T.uint32()));\n            break;\n          case 5:\n            U.trigger = a.SourceTrigger.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        sourceId: ce(p.sourceId) ? String(p.sourceId) : \"\",\n        updateMask: ce(p.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(p.updateMask)) : void 0,\n        trigger: ce(p.trigger) ? a.SourceTrigger.fromJSON(p.trigger) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.updateMask !== void 0 && (b.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(p.updateMask))), p.trigger !== void 0 && (b.trigger = p.trigger ? a.SourceTrigger.toJSON(p.trigger) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U;\n      const te = Dn();\n      return te.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", te.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", te.sourceId = (K = p.sourceId) !== null && K !== void 0 ? K : \"\", te.updateMask = (U = p.updateMask) !== null && U !== void 0 ? U : void 0, te.trigger = p.trigger !== void 0 && p.trigger !== null ? a.SourceTrigger.fromPartial(p.trigger) : void 0, te;\n    }\n  };\n  function Ln() {\n    return { project: void 0 };\n  }\n  a.UpdateSourceInProjectResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.project !== void 0 && a.Project.encode(p.project, b.uint32(10).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Ln();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.project = a.Project.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { project: ce(p.project) ? a.Project.fromJSON(p.project) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.project !== void 0 && (b.project = p.project ? a.Project.toJSON(p.project) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Ln();\n      return b.project = p.project !== void 0 && p.project !== null ? a.Project.fromPartial(p.project) : void 0, b;\n    }\n  };\n  function Mn() {\n    return { collectionId: \"\", sourceId: \"\" };\n  }\n  a.GetSourceRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.sourceId !== \"\" && b.uint32(26).string(p.sourceId), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Mn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 3:\n            U.sourceId = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        sourceId: ce(p.sourceId) ? String(p.sourceId) : \"\"\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = Mn();\n      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", K.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : \"\", K;\n    }\n  };\n  function Un() {\n    return { source: void 0 };\n  }\n  a.GetSourceResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.source !== void 0 && a.Source.encode(p.source, b.uint32(10).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Un();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.source = a.Source.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { source: ce(p.source) ? a.Source.fromJSON(p.source) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.source !== void 0 && (b.source = p.source ? a.Source.toJSON(p.source) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Un();\n      return b.source = p.source !== void 0 && p.source !== null ? a.Source.fromPartial(p.source) : void 0, b;\n    }\n  };\n  function $n() {\n    return { collectionId: \"\" };\n  }\n  a.GetSourcesRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = $n();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\" };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = $n();\n      return T.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", T;\n    }\n  };\n  function Bn() {\n    return { sources: [] };\n  }\n  a.GetSourcesResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      for (const T of p.sources)\n        a.Source.encode(T, b.uint32(10).fork()).ldelim();\n      return b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Bn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.sources.push(a.Source.decode(T, T.uint32()));\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { sources: Array.isArray(p == null ? void 0 : p.sources) ? p.sources.map((b) => a.Source.fromJSON(b)) : [] };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.sources ? b.sources = p.sources.map((T) => T ? a.Source.toJSON(T) : void 0) : b.sources = [], b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = Bn();\n      return T.sources = ((b = p.sources) === null || b === void 0 ? void 0 : b.map((K) => a.Source.fromPartial(K))) || [], T;\n    }\n  };\n  function Jn() {\n    return {\n      collectionId: \"\",\n      sourceId: \"\",\n      updateMask: void 0,\n      metadata: void 0,\n      address: void 0,\n      preview: void 0\n    };\n  }\n  a.UpdateSourceRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.sourceId !== \"\" && b.uint32(26).string(p.sourceId), p.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(p.updateMask), b.uint32(34).fork()).ldelim(), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(42).fork()).ldelim(), p.address !== void 0 && a.SourceAddress.encode(p.address, b.uint32(50).fork()).ldelim(), p.preview !== void 0 && a.PreviewAddress.encode(p.preview, b.uint32(58).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Jn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 3:\n            U.sourceId = T.string();\n            break;\n          case 4:\n            U.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(T, T.uint32()));\n            break;\n          case 5:\n            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));\n            break;\n          case 6:\n            U.address = a.SourceAddress.decode(T, T.uint32());\n            break;\n          case 7:\n            U.preview = a.PreviewAddress.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        sourceId: ce(p.sourceId) ? String(p.sourceId) : \"\",\n        updateMask: ce(p.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(p.updateMask)) : void 0,\n        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,\n        address: ce(p.address) ? a.SourceAddress.fromJSON(p.address) : void 0,\n        preview: ce(p.preview) ? a.PreviewAddress.fromJSON(p.preview) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.updateMask !== void 0 && (b.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(p.updateMask))), p.metadata !== void 0 && (b.metadata = p.metadata), p.address !== void 0 && (b.address = p.address ? a.SourceAddress.toJSON(p.address) : void 0), p.preview !== void 0 && (b.preview = p.preview ? a.PreviewAddress.toJSON(p.preview) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U;\n      const te = Jn();\n      return te.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", te.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : \"\", te.updateMask = (K = p.updateMask) !== null && K !== void 0 ? K : void 0, te.metadata = (U = p.metadata) !== null && U !== void 0 ? U : void 0, te.address = p.address !== void 0 && p.address !== null ? a.SourceAddress.fromPartial(p.address) : void 0, te.preview = p.preview !== void 0 && p.preview !== null ? a.PreviewAddress.fromPartial(p.preview) : void 0, te;\n    }\n  };\n  function Fn() {\n    return { source: void 0, broadcastUpdated: !1 };\n  }\n  a.UpdateSourceResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.source !== void 0 && a.Source.encode(p.source, b.uint32(10).fork()).ldelim(), p.broadcastUpdated === !0 && b.uint32(16).bool(p.broadcastUpdated), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Fn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.source = a.Source.decode(T, T.uint32());\n            break;\n          case 2:\n            U.broadcastUpdated = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        source: ce(p.source) ? a.Source.fromJSON(p.source) : void 0,\n        broadcastUpdated: ce(p.broadcastUpdated) ? !!p.broadcastUpdated : !1\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.source !== void 0 && (b.source = p.source ? a.Source.toJSON(p.source) : void 0), p.broadcastUpdated !== void 0 && (b.broadcastUpdated = p.broadcastUpdated), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = Fn();\n      return T.source = p.source !== void 0 && p.source !== null ? a.Source.fromPartial(p.source) : void 0, T.broadcastUpdated = (b = p.broadcastUpdated) !== null && b !== void 0 ? b : !1, T;\n    }\n  };\n  function Vn() {\n    return { collectionId: \"\", projectId: \"\", sourceId: \"\", force: void 0 };\n  }\n  a.RemoveSourceFromProjectRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.sourceId !== \"\" && b.uint32(26).string(p.sourceId), p.force !== void 0 && b.uint32(32).bool(p.force), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Vn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.sourceId = T.string();\n            break;\n          case 4:\n            U.force = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        sourceId: ce(p.sourceId) ? String(p.sourceId) : \"\",\n        force: ce(p.force) ? !!p.force : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.force !== void 0 && (b.force = p.force), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U;\n      const te = Vn();\n      return te.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", te.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", te.sourceId = (K = p.sourceId) !== null && K !== void 0 ? K : \"\", te.force = (U = p.force) !== null && U !== void 0 ? U : void 0, te;\n    }\n  };\n  function qn() {\n    return { project: void 0, broadcastUpdated: !1 };\n  }\n  a.RemoveSourceFromProjectResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.project !== void 0 && a.Project.encode(p.project, b.uint32(10).fork()).ldelim(), p.broadcastUpdated === !0 && b.uint32(16).bool(p.broadcastUpdated), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = qn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.project = a.Project.decode(T, T.uint32());\n            break;\n          case 2:\n            U.broadcastUpdated = T.bool();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        project: ce(p.project) ? a.Project.fromJSON(p.project) : void 0,\n        broadcastUpdated: ce(p.broadcastUpdated) ? !!p.broadcastUpdated : !1\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.project !== void 0 && (b.project = p.project ? a.Project.toJSON(p.project) : void 0), p.broadcastUpdated !== void 0 && (b.broadcastUpdated = p.broadcastUpdated), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = qn();\n      return T.project = p.project !== void 0 && p.project !== null ? a.Project.fromPartial(p.project) : void 0, T.broadcastUpdated = (b = p.broadcastUpdated) !== null && b !== void 0 ? b : !1, T;\n    }\n  };\n  function Gn() {\n    return { collectionId: \"\", sourceId: \"\", accessToken: void 0 };\n  }\n  a.GetSourcePlaylistRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.sourceId !== \"\" && b.uint32(26).string(p.sourceId), p.accessToken !== void 0 && b.uint32(34).string(p.accessToken), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Gn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 3:\n            U.sourceId = T.string();\n            break;\n          case 4:\n            U.accessToken = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        sourceId: ce(p.sourceId) ? String(p.sourceId) : \"\",\n        accessToken: ce(p.accessToken) ? String(p.accessToken) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.accessToken !== void 0 && (b.accessToken = p.accessToken), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = Gn();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : \"\", U.accessToken = (K = p.accessToken) !== null && K !== void 0 ? K : void 0, U;\n    }\n  };\n  function Wn() {\n    return { manifest: \"\" };\n  }\n  a.GetSourcePlaylistResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.manifest !== \"\" && b.uint32(10).string(p.manifest), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Wn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.manifest = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { manifest: ce(p.manifest) ? String(p.manifest) : \"\" };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.manifest !== void 0 && (b.manifest = p.manifest), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = Wn();\n      return T.manifest = (b = p.manifest) !== null && b !== void 0 ? b : \"\", T;\n    }\n  };\n  function Hn() {\n    return { serviceUserId: \"\", displayName: void 0, role: void 0, maxDuration: void 0 };\n  }\n  a.CreateAccessTokenRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.serviceUserId !== \"\" && b.uint32(10).string(p.serviceUserId), p.displayName !== void 0 && b.uint32(34).string(p.displayName), p.role !== void 0 && b.uint32(16).int32(Oe(p.role)), p.maxDuration !== void 0 && b.uint32(24).uint32(p.maxDuration), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Hn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.serviceUserId = T.string();\n            break;\n          case 4:\n            U.displayName = T.string();\n            break;\n          case 2:\n            U.role = je(T.int32());\n            break;\n          case 3:\n            U.maxDuration = T.uint32();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        serviceUserId: ce(p.serviceUserId) ? String(p.serviceUserId) : \"\",\n        displayName: ce(p.displayName) ? String(p.displayName) : void 0,\n        role: ce(p.role) ? je(p.role) : void 0,\n        maxDuration: ce(p.maxDuration) ? Number(p.maxDuration) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.serviceUserId !== void 0 && (b.serviceUserId = p.serviceUserId), p.displayName !== void 0 && (b.displayName = p.displayName), p.role !== void 0 && (b.role = p.role !== void 0 ? tt(p.role) : void 0), p.maxDuration !== void 0 && (b.maxDuration = Math.round(p.maxDuration)), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U;\n      const te = Hn();\n      return te.serviceUserId = (b = p.serviceUserId) !== null && b !== void 0 ? b : \"\", te.displayName = (T = p.displayName) !== null && T !== void 0 ? T : void 0, te.role = (K = p.role) !== null && K !== void 0 ? K : void 0, te.maxDuration = (U = p.maxDuration) !== null && U !== void 0 ? U : void 0, te;\n    }\n  };\n  function xn() {\n    return { accessToken: \"\" };\n  }\n  a.CreateAccessTokenResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.accessToken !== \"\" && b.uint32(10).string(p.accessToken), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = xn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.accessToken = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { accessToken: ce(p.accessToken) ? String(p.accessToken) : \"\" };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.accessToken !== void 0 && (b.accessToken = p.accessToken), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = xn();\n      return T.accessToken = (b = p.accessToken) !== null && b !== void 0 ? b : \"\", T;\n    }\n  };\n  function zn() {\n    return { displayName: \"\", serviceUserId: void 0 };\n  }\n  a.GuestAccessTokenDirect = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.displayName !== \"\" && b.uint32(10).string(p.displayName), p.serviceUserId !== void 0 && b.uint32(18).string(p.serviceUserId), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = zn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.displayName = T.string();\n            break;\n          case 2:\n            U.serviceUserId = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        displayName: ce(p.displayName) ? String(p.displayName) : \"\",\n        serviceUserId: ce(p.serviceUserId) ? String(p.serviceUserId) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.displayName !== void 0 && (b.displayName = p.displayName), p.serviceUserId !== void 0 && (b.serviceUserId = p.serviceUserId), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = zn();\n      return K.displayName = (b = p.displayName) !== null && b !== void 0 ? b : \"\", K.serviceUserId = (T = p.serviceUserId) !== null && T !== void 0 ? T : void 0, K;\n    }\n  };\n  function Yn() {\n    return { maxDuration: void 0 };\n  }\n  a.GuestAccessTokenExchange = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.maxDuration !== void 0 && b.uint32(8).uint32(p.maxDuration), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Yn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.maxDuration = T.uint32();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { maxDuration: ce(p.maxDuration) ? Number(p.maxDuration) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.maxDuration !== void 0 && (b.maxDuration = Math.round(p.maxDuration)), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = Yn();\n      return T.maxDuration = (b = p.maxDuration) !== null && b !== void 0 ? b : void 0, T;\n    }\n  };\n  function Kn() {\n    return { direct: void 0, exchange: void 0 };\n  }\n  a.GuestAccessToken = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.direct !== void 0 && a.GuestAccessTokenDirect.encode(p.direct, b.uint32(10).fork()).ldelim(), p.exchange !== void 0 && a.GuestAccessTokenExchange.encode(p.exchange, b.uint32(18).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Kn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.direct = a.GuestAccessTokenDirect.decode(T, T.uint32());\n            break;\n          case 2:\n            U.exchange = a.GuestAccessTokenExchange.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        direct: ce(p.direct) ? a.GuestAccessTokenDirect.fromJSON(p.direct) : void 0,\n        exchange: ce(p.exchange) ? a.GuestAccessTokenExchange.fromJSON(p.exchange) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.direct !== void 0 && (b.direct = p.direct ? a.GuestAccessTokenDirect.toJSON(p.direct) : void 0), p.exchange !== void 0 && (b.exchange = p.exchange ? a.GuestAccessTokenExchange.toJSON(p.exchange) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Kn();\n      return b.direct = p.direct !== void 0 && p.direct !== null ? a.GuestAccessTokenDirect.fromPartial(p.direct) : void 0, b.exchange = p.exchange !== void 0 && p.exchange !== null ? a.GuestAccessTokenExchange.fromPartial(p.exchange) : void 0, b;\n    }\n  };\n  function Qn() {\n    return {\n      collectionId: \"\",\n      projectId: \"\",\n      maxDuration: void 0,\n      role: Ye.ROLE_UNSPECIFIED,\n      token: void 0,\n      url: void 0\n    };\n  }\n  a.CreateGuestAccessTokenRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.maxDuration !== void 0 && b.uint32(24).uint32(p.maxDuration), p.role !== Ye.ROLE_UNSPECIFIED && b.uint32(32).int32(Oe(p.role)), p.token !== void 0 && a.GuestAccessToken.encode(p.token, b.uint32(42).fork()).ldelim(), p.url !== void 0 && b.uint32(50).string(p.url), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Qn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.maxDuration = T.uint32();\n            break;\n          case 4:\n            U.role = je(T.int32());\n            break;\n          case 5:\n            U.token = a.GuestAccessToken.decode(T, T.uint32());\n            break;\n          case 6:\n            U.url = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        maxDuration: ce(p.maxDuration) ? Number(p.maxDuration) : void 0,\n        role: ce(p.role) ? je(p.role) : Ye.ROLE_UNSPECIFIED,\n        token: ce(p.token) ? a.GuestAccessToken.fromJSON(p.token) : void 0,\n        url: ce(p.url) ? String(p.url) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.maxDuration !== void 0 && (b.maxDuration = Math.round(p.maxDuration)), p.role !== void 0 && (b.role = tt(p.role)), p.token !== void 0 && (b.token = p.token ? a.GuestAccessToken.toJSON(p.token) : void 0), p.url !== void 0 && (b.url = p.url), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U, te;\n      const We = Qn();\n      return We.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", We.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", We.maxDuration = (K = p.maxDuration) !== null && K !== void 0 ? K : void 0, We.role = (U = p.role) !== null && U !== void 0 ? U : Ye.ROLE_UNSPECIFIED, We.token = p.token !== void 0 && p.token !== null ? a.GuestAccessToken.fromPartial(p.token) : void 0, We.url = (te = p.url) !== null && te !== void 0 ? te : void 0, We;\n    }\n  };\n  function Zn() {\n    return { accessToken: \"\", url: void 0 };\n  }\n  a.CreateGuestAccessTokenResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.accessToken !== \"\" && b.uint32(10).string(p.accessToken), p.url !== void 0 && b.uint32(18).string(p.url), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Zn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.accessToken = T.string();\n            break;\n          case 2:\n            U.url = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        accessToken: ce(p.accessToken) ? String(p.accessToken) : \"\",\n        url: ce(p.url) ? String(p.url) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.accessToken !== void 0 && (b.accessToken = p.accessToken), p.url !== void 0 && (b.url = p.url), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = Zn();\n      return K.accessToken = (b = p.accessToken) !== null && b !== void 0 ? b : \"\", K.url = (T = p.url) !== null && T !== void 0 ? T : void 0, K;\n    }\n  };\n  function Xn() {\n    return { collectionId: \"\", projectId: \"\", displayName: \"\" };\n  }\n  a.CreateWebRtcAccessTokenRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.displayName !== \"\" && b.uint32(26).string(p.displayName), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Xn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.displayName = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        displayName: ce(p.displayName) ? String(p.displayName) : \"\"\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.displayName !== void 0 && (b.displayName = p.displayName), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = Xn();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", U.displayName = (K = p.displayName) !== null && K !== void 0 ? K : \"\", U;\n    }\n  };\n  function jn() {\n    return { webrtcAccess: void 0 };\n  }\n  a.CreateWebRtcAccessTokenResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.webrtcAccess !== void 0 && a.WebRtcAccess.encode(p.webrtcAccess, b.uint32(18).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = jn();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 2:\n            U.webrtcAccess = a.WebRtcAccess.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { webrtcAccess: ce(p.webrtcAccess) ? a.WebRtcAccess.fromJSON(p.webrtcAccess) : void 0 };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.webrtcAccess !== void 0 && (b.webrtcAccess = p.webrtcAccess ? a.WebRtcAccess.toJSON(p.webrtcAccess) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = jn();\n      return b.webrtcAccess = p.webrtcAccess !== void 0 && p.webrtcAccess !== null ? a.WebRtcAccess.fromPartial(p.webrtcAccess) : void 0, b;\n    }\n  };\n  function er() {\n    return {};\n  }\n  a.RefreshAccessTokenRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = er();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {};\n    },\n    toJSON(p) {\n      return {};\n    },\n    fromPartial(p) {\n      return er();\n    }\n  };\n  function tr() {\n    return {};\n  }\n  a.RefreshAccessTokenResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = tr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {};\n    },\n    toJSON(p) {\n      return {};\n    },\n    fromPartial(p) {\n      return tr();\n    }\n  };\n  function nr() {\n    return { collectionId: \"\", projectId: \"\", code: \"\", url: \"\", autoDelete: void 0 };\n  }\n  a.GuestCode = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.code !== \"\" && b.uint32(26).string(p.code), p.url !== \"\" && b.uint32(34).string(p.url), p.autoDelete !== void 0 && g.Timestamp.encode(Ut(p.autoDelete), b.uint32(42).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = nr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.code = T.string();\n            break;\n          case 4:\n            U.url = T.string();\n            break;\n          case 5:\n            U.autoDelete = $t(g.Timestamp.decode(T, T.uint32()));\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        code: ce(p.code) ? String(p.code) : \"\",\n        url: ce(p.url) ? String(p.url) : \"\",\n        autoDelete: ce(p.autoDelete) ? String(p.autoDelete) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.code !== void 0 && (b.code = p.code), p.url !== void 0 && (b.url = p.url), p.autoDelete !== void 0 && (b.autoDelete = p.autoDelete), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U, te;\n      const We = nr();\n      return We.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", We.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", We.code = (K = p.code) !== null && K !== void 0 ? K : \"\", We.url = (U = p.url) !== null && U !== void 0 ? U : \"\", We.autoDelete = (te = p.autoDelete) !== null && te !== void 0 ? te : void 0, We;\n    }\n  };\n  function rr() {\n    return { serviceId: \"\", code: \"\" };\n  }\n  a.GuestCodeRedirectRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.serviceId !== \"\" && b.uint32(10).string(p.serviceId), p.code !== \"\" && b.uint32(18).string(p.code), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = rr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.serviceId = T.string();\n            break;\n          case 2:\n            U.code = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        serviceId: ce(p.serviceId) ? String(p.serviceId) : \"\",\n        code: ce(p.code) ? String(p.code) : \"\"\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.serviceId !== void 0 && (b.serviceId = p.serviceId), p.code !== void 0 && (b.code = p.code), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = rr();\n      return K.serviceId = (b = p.serviceId) !== null && b !== void 0 ? b : \"\", K.code = (T = p.code) !== null && T !== void 0 ? T : \"\", K;\n    }\n  };\n  function ir() {\n    return {};\n  }\n  a.GuestCodeRedirectResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = ir();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {};\n    },\n    toJSON(p) {\n      return {};\n    },\n    fromPartial(p) {\n      return ir();\n    }\n  };\n  function ar() {\n    return { alg: \"\", kty: \"\", use: \"\", kid: \"\", e: \"\", n: \"\" };\n  }\n  a.JsonWebKey = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.alg !== \"\" && b.uint32(10).string(p.alg), p.kty !== \"\" && b.uint32(18).string(p.kty), p.use !== \"\" && b.uint32(26).string(p.use), p.kid !== \"\" && b.uint32(34).string(p.kid), p.e !== \"\" && b.uint32(42).string(p.e), p.n !== \"\" && b.uint32(50).string(p.n), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = ar();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.alg = T.string();\n            break;\n          case 2:\n            U.kty = T.string();\n            break;\n          case 3:\n            U.use = T.string();\n            break;\n          case 4:\n            U.kid = T.string();\n            break;\n          case 5:\n            U.e = T.string();\n            break;\n          case 6:\n            U.n = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        alg: ce(p.alg) ? String(p.alg) : \"\",\n        kty: ce(p.kty) ? String(p.kty) : \"\",\n        use: ce(p.use) ? String(p.use) : \"\",\n        kid: ce(p.kid) ? String(p.kid) : \"\",\n        e: ce(p.e) ? String(p.e) : \"\",\n        n: ce(p.n) ? String(p.n) : \"\"\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.alg !== void 0 && (b.alg = p.alg), p.kty !== void 0 && (b.kty = p.kty), p.use !== void 0 && (b.use = p.use), p.kid !== void 0 && (b.kid = p.kid), p.e !== void 0 && (b.e = p.e), p.n !== void 0 && (b.n = p.n), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U, te, We;\n      const et = ar();\n      return et.alg = (b = p.alg) !== null && b !== void 0 ? b : \"\", et.kty = (T = p.kty) !== null && T !== void 0 ? T : \"\", et.use = (K = p.use) !== null && K !== void 0 ? K : \"\", et.kid = (U = p.kid) !== null && U !== void 0 ? U : \"\", et.e = (te = p.e) !== null && te !== void 0 ? te : \"\", et.n = (We = p.n) !== null && We !== void 0 ? We : \"\", et;\n    }\n  };\n  function or() {\n    return {};\n  }\n  a.GetJsonWebKeySetRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = or();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {};\n    },\n    toJSON(p) {\n      return {};\n    },\n    fromPartial(p) {\n      return or();\n    }\n  };\n  function sr() {\n    return { keys: [] };\n  }\n  a.GetJsonWebKeySetResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      for (const T of p.keys)\n        a.JsonWebKey.encode(T, b.uint32(10).fork()).ldelim();\n      return b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = sr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.keys.push(a.JsonWebKey.decode(T, T.uint32()));\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { keys: Array.isArray(p == null ? void 0 : p.keys) ? p.keys.map((b) => a.JsonWebKey.fromJSON(b)) : [] };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.keys ? b.keys = p.keys.map((T) => T ? a.JsonWebKey.toJSON(T) : void 0) : b.keys = [], b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = sr();\n      return T.keys = ((b = p.keys) === null || b === void 0 ? void 0 : b.map((K) => a.JsonWebKey.fromPartial(K))) || [], T;\n    }\n  };\n  function dr() {\n    return {};\n  }\n  a.GetTestTokenRequest = {\n    encode(p, b = c.default.Writer.create()) {\n      return b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = dr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {};\n    },\n    toJSON(p) {\n      return {};\n    },\n    fromPartial(p) {\n      return dr();\n    }\n  };\n  function ur() {\n    return { accessToken: \"\" };\n  }\n  a.GetTestTokenResponse = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.accessToken !== \"\" && b.uint32(10).string(p.accessToken), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = ur();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.accessToken = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { accessToken: ce(p.accessToken) ? String(p.accessToken) : \"\" };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.accessToken !== void 0 && (b.accessToken = p.accessToken), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = ur();\n      return T.accessToken = (b = p.accessToken) !== null && b !== void 0 ? b : \"\", T;\n    }\n  };\n  function cr() {\n    return { collectionId: \"\", projectId: \"\", destinationId: \"\", destination: void 0 };\n  }\n  a.DestinationCreateEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.destinationId !== \"\" && b.uint32(26).string(p.destinationId), p.destination !== void 0 && a.Destination.encode(p.destination, b.uint32(34).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = cr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.destinationId = T.string();\n            break;\n          case 4:\n            U.destination = a.Destination.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        destinationId: ce(p.destinationId) ? String(p.destinationId) : \"\",\n        destination: ce(p.destination) ? a.Destination.fromJSON(p.destination) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.destinationId !== void 0 && (b.destinationId = p.destinationId), p.destination !== void 0 && (b.destination = p.destination ? a.Destination.toJSON(p.destination) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = cr();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", U.destinationId = (K = p.destinationId) !== null && K !== void 0 ? K : \"\", U.destination = p.destination !== void 0 && p.destination !== null ? a.Destination.fromPartial(p.destination) : void 0, U;\n    }\n  };\n  function lr() {\n    return { collectionId: \"\", projectId: \"\", destinationId: \"\" };\n  }\n  a.DestinationDeleteEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.destinationId !== \"\" && b.uint32(26).string(p.destinationId), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = lr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.destinationId = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        destinationId: ce(p.destinationId) ? String(p.destinationId) : \"\"\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.destinationId !== void 0 && (b.destinationId = p.destinationId), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = lr();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", U.destinationId = (K = p.destinationId) !== null && K !== void 0 ? K : \"\", U;\n    }\n  };\n  function fr() {\n    return { collectionId: \"\", projectId: \"\", destinationId: \"\", updateMask: [], destination: void 0 };\n  }\n  a.DestinationUpdateEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.destinationId !== \"\" && b.uint32(26).string(p.destinationId);\n      for (const T of p.updateMask)\n        b.uint32(34).string(T);\n      return p.destination !== void 0 && a.Destination.encode(p.destination, b.uint32(42).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = fr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.destinationId = T.string();\n            break;\n          case 4:\n            U.updateMask.push(T.string());\n            break;\n          case 5:\n            U.destination = a.Destination.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        destinationId: ce(p.destinationId) ? String(p.destinationId) : \"\",\n        updateMask: Array.isArray(p == null ? void 0 : p.updateMask) ? p.updateMask.map((b) => String(b)) : [],\n        destination: ce(p.destination) ? a.Destination.fromJSON(p.destination) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.destinationId !== void 0 && (b.destinationId = p.destinationId), p.updateMask ? b.updateMask = p.updateMask.map((T) => T) : b.updateMask = [], p.destination !== void 0 && (b.destination = p.destination ? a.Destination.toJSON(p.destination) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U;\n      const te = fr();\n      return te.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", te.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", te.destinationId = (K = p.destinationId) !== null && K !== void 0 ? K : \"\", te.updateMask = ((U = p.updateMask) === null || U === void 0 ? void 0 : U.map((We) => We)) || [], te.destination = p.destination !== void 0 && p.destination !== null ? a.Destination.fromPartial(p.destination) : void 0, te;\n    }\n  };\n  function pr() {\n    return { collectionId: \"\", projectId: \"\", destinationId: \"\", connect: void 0 };\n  }\n  a.DestinationStateEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.destinationId !== \"\" && b.uint32(26).string(p.destinationId), p.connect !== void 0 && b.uint32(32).int32(se(p.connect)), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = pr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.destinationId = T.string();\n            break;\n          case 4:\n            U.connect = O(T.int32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        destinationId: ce(p.destinationId) ? String(p.destinationId) : \"\",\n        connect: ce(p.connect) ? O(p.connect) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.destinationId !== void 0 && (b.destinationId = p.destinationId), p.connect !== void 0 && (b.connect = p.connect !== void 0 ? j(p.connect) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U;\n      const te = pr();\n      return te.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", te.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", te.destinationId = (K = p.destinationId) !== null && K !== void 0 ? K : \"\", te.connect = (U = p.connect) !== null && U !== void 0 ? U : void 0, te;\n    }\n  };\n  function hr() {\n    return { collectionId: \"\", projectId: \"\", project: void 0 };\n  }\n  a.ProjectCreateEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.project !== void 0 && a.Project.encode(p.project, b.uint32(26).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = hr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.project = a.Project.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        project: ce(p.project) ? a.Project.fromJSON(p.project) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.project !== void 0 && (b.project = p.project ? a.Project.toJSON(p.project) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = hr();\n      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", K.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", K.project = p.project !== void 0 && p.project !== null ? a.Project.fromPartial(p.project) : void 0, K;\n    }\n  };\n  function mr() {\n    return { collectionId: \"\", projectId: \"\" };\n  }\n  a.ProjectDeleteEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = mr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\"\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = mr();\n      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", K.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", K;\n    }\n  };\n  function vr() {\n    return { collectionId: \"\", projectId: \"\", updateMask: [], project: void 0 };\n  }\n  a.ProjectUpdateEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId);\n      for (const T of p.updateMask)\n        b.uint32(26).string(T);\n      return p.project !== void 0 && a.Project.encode(p.project, b.uint32(34).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = vr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.updateMask.push(T.string());\n            break;\n          case 4:\n            U.project = a.Project.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        updateMask: Array.isArray(p == null ? void 0 : p.updateMask) ? p.updateMask.map((b) => String(b)) : [],\n        project: ce(p.project) ? a.Project.fromJSON(p.project) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.updateMask ? b.updateMask = p.updateMask.map((T) => T) : b.updateMask = [], p.project !== void 0 && (b.project = p.project ? a.Project.toJSON(p.project) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = vr();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", U.updateMask = ((K = p.updateMask) === null || K === void 0 ? void 0 : K.map((te) => te)) || [], U.project = p.project !== void 0 && p.project !== null ? a.Project.fromPartial(p.project) : void 0, U;\n    }\n  };\n  function Sr() {\n    return { collectionId: \"\", projectId: \"\", broadcastId: \"\", phase: void 0, error: void 0 };\n  }\n  a.ProjectBroadcastStateEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.broadcastId !== \"\" && b.uint32(26).string(p.broadcastId), p.phase !== void 0 && b.uint32(32).int32(Ve(p.phase)), p.error !== void 0 && b.uint32(40).int32(Ee(p.error)), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Sr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.broadcastId = T.string();\n            break;\n          case 4:\n            U.phase = Ge(T.int32());\n            break;\n          case 5:\n            U.error = X(T.int32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        broadcastId: ce(p.broadcastId) ? String(p.broadcastId) : \"\",\n        phase: ce(p.phase) ? Ge(p.phase) : void 0,\n        error: ce(p.error) ? X(p.error) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.broadcastId !== void 0 && (b.broadcastId = p.broadcastId), p.phase !== void 0 && (b.phase = p.phase !== void 0 ? He(p.phase) : void 0), p.error !== void 0 && (b.error = p.error !== void 0 ? ie(p.error) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U, te;\n      const We = Sr();\n      return We.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", We.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", We.broadcastId = (K = p.broadcastId) !== null && K !== void 0 ? K : \"\", We.phase = (U = p.phase) !== null && U !== void 0 ? U : void 0, We.error = (te = p.error) !== null && te !== void 0 ? te : void 0, We;\n    }\n  };\n  function yr() {\n    return { collectionId: \"\", collection: void 0 };\n  }\n  a.CollectionCreateEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.collection !== void 0 && a.Collection.encode(p.collection, b.uint32(18).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = yr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.collection = a.Collection.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        collection: ce(p.collection) ? a.Collection.fromJSON(p.collection) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.collection !== void 0 && (b.collection = p.collection ? a.Collection.toJSON(p.collection) : void 0), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = yr();\n      return T.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", T.collection = p.collection !== void 0 && p.collection !== null ? a.Collection.fromPartial(p.collection) : void 0, T;\n    }\n  };\n  function gr() {\n    return { collectionId: \"\" };\n  }\n  a.CollectionDeleteEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = gr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return { collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\" };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = gr();\n      return T.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", T;\n    }\n  };\n  function br() {\n    return { collectionId: \"\", updateMask: [], collection: void 0 };\n  }\n  a.CollectionUpdateEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      p.collectionId !== \"\" && b.uint32(10).string(p.collectionId);\n      for (const T of p.updateMask)\n        b.uint32(18).string(T);\n      return p.collection !== void 0 && a.Collection.encode(p.collection, b.uint32(26).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = br();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.updateMask.push(T.string());\n            break;\n          case 3:\n            U.collection = a.Collection.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        updateMask: Array.isArray(p == null ? void 0 : p.updateMask) ? p.updateMask.map((b) => String(b)) : [],\n        collection: ce(p.collection) ? a.Collection.fromJSON(p.collection) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.updateMask ? b.updateMask = p.updateMask.map((T) => T) : b.updateMask = [], p.collection !== void 0 && (b.collection = p.collection ? a.Collection.toJSON(p.collection) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = br();\n      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", K.updateMask = ((T = p.updateMask) === null || T === void 0 ? void 0 : T.map((U) => U)) || [], K.collection = p.collection !== void 0 && p.collection !== null ? a.Collection.fromPartial(p.collection) : void 0, K;\n    }\n  };\n  function Er() {\n    return { collectionId: \"\", sourceId: \"\", source: void 0 };\n  }\n  a.SourceCreateEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.sourceId !== \"\" && b.uint32(18).string(p.sourceId), p.source !== void 0 && a.Source.encode(p.source, b.uint32(26).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Er();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.sourceId = T.string();\n            break;\n          case 3:\n            U.source = a.Source.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        sourceId: ce(p.sourceId) ? String(p.sourceId) : \"\",\n        source: ce(p.source) ? a.Source.fromJSON(p.source) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.source !== void 0 && (b.source = p.source ? a.Source.toJSON(p.source) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = Er();\n      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", K.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : \"\", K.source = p.source !== void 0 && p.source !== null ? a.Source.fromPartial(p.source) : void 0, K;\n    }\n  };\n  function Tr() {\n    return { collectionId: \"\", sourceId: \"\" };\n  }\n  a.SourceDeleteEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.sourceId !== \"\" && b.uint32(18).string(p.sourceId), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Tr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.sourceId = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        sourceId: ce(p.sourceId) ? String(p.sourceId) : \"\"\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), b;\n    },\n    fromPartial(p) {\n      var b, T;\n      const K = Tr();\n      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", K.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : \"\", K;\n    }\n  };\n  function _r() {\n    return { collectionId: \"\", sourceId: \"\", updateMask: [], source: void 0 };\n  }\n  a.SourceUpdateEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.sourceId !== \"\" && b.uint32(18).string(p.sourceId);\n      for (const T of p.updateMask)\n        b.uint32(26).string(T);\n      return p.source !== void 0 && a.Source.encode(p.source, b.uint32(34).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = _r();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.sourceId = T.string();\n            break;\n          case 3:\n            U.updateMask.push(T.string());\n            break;\n          case 4:\n            U.source = a.Source.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        sourceId: ce(p.sourceId) ? String(p.sourceId) : \"\",\n        updateMask: Array.isArray(p == null ? void 0 : p.updateMask) ? p.updateMask.map((b) => String(b)) : [],\n        source: ce(p.source) ? a.Source.fromJSON(p.source) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.updateMask ? b.updateMask = p.updateMask.map((T) => T) : b.updateMask = [], p.source !== void 0 && (b.source = p.source ? a.Source.toJSON(p.source) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = _r();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : \"\", U.updateMask = ((K = p.updateMask) === null || K === void 0 ? void 0 : K.map((te) => te)) || [], U.source = p.source !== void 0 && p.source !== null ? a.Source.fromPartial(p.source) : void 0, U;\n    }\n  };\n  function Ir() {\n    return { collectionId: \"\", sourceId: \"\", projectId: \"\", source: void 0 };\n  }\n  a.SourceAddEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.sourceId !== \"\" && b.uint32(18).string(p.sourceId), p.projectId !== \"\" && b.uint32(26).string(p.projectId), p.source !== void 0 && a.Source.encode(p.source, b.uint32(34).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Ir();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.sourceId = T.string();\n            break;\n          case 3:\n            U.projectId = T.string();\n            break;\n          case 4:\n            U.source = a.Source.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        sourceId: ce(p.sourceId) ? String(p.sourceId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        source: ce(p.source) ? a.Source.fromJSON(p.source) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.projectId !== void 0 && (b.projectId = p.projectId), p.source !== void 0 && (b.source = p.source ? a.Source.toJSON(p.source) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = Ir();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : \"\", U.projectId = (K = p.projectId) !== null && K !== void 0 ? K : \"\", U.source = p.source !== void 0 && p.source !== null ? a.Source.fromPartial(p.source) : void 0, U;\n    }\n  };\n  function kr() {\n    return { collectionId: \"\", sourceId: \"\", projectId: \"\" };\n  }\n  a.SourceRemoveEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.sourceId !== \"\" && b.uint32(18).string(p.sourceId), p.projectId !== \"\" && b.uint32(26).string(p.projectId), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = kr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.sourceId = T.string();\n            break;\n          case 3:\n            U.projectId = T.string();\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        sourceId: ce(p.sourceId) ? String(p.sourceId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\"\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.projectId !== void 0 && (b.projectId = p.projectId), b;\n    },\n    fromPartial(p) {\n      var b, T, K;\n      const U = kr();\n      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", U.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : \"\", U.projectId = (K = p.projectId) !== null && K !== void 0 ? K : \"\", U;\n    }\n  };\n  function Cr() {\n    return { collectionId: \"\", projectId: \"\", sourceId: \"\", connect: void 0 };\n  }\n  a.SourceStateEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collectionId !== \"\" && b.uint32(10).string(p.collectionId), p.projectId !== \"\" && b.uint32(18).string(p.projectId), p.sourceId !== \"\" && b.uint32(26).string(p.sourceId), p.connect !== void 0 && b.uint32(32).int32(se(p.connect)), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Cr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collectionId = T.string();\n            break;\n          case 2:\n            U.projectId = T.string();\n            break;\n          case 3:\n            U.sourceId = T.string();\n            break;\n          case 4:\n            U.connect = O(T.int32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collectionId: ce(p.collectionId) ? String(p.collectionId) : \"\",\n        projectId: ce(p.projectId) ? String(p.projectId) : \"\",\n        sourceId: ce(p.sourceId) ? String(p.sourceId) : \"\",\n        connect: ce(p.connect) ? O(p.connect) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.connect !== void 0 && (b.connect = p.connect !== void 0 ? j(p.connect) : void 0), b;\n    },\n    fromPartial(p) {\n      var b, T, K, U;\n      const te = Cr();\n      return te.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : \"\", te.projectId = (T = p.projectId) !== null && T !== void 0 ? T : \"\", te.sourceId = (K = p.sourceId) !== null && K !== void 0 ? K : \"\", te.connect = (U = p.connect) !== null && U !== void 0 ? U : void 0, te;\n    }\n  };\n  function Rr() {\n    return { create: void 0, update: void 0, delete: void 0 };\n  }\n  a.CollectionEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.create !== void 0 && a.CollectionCreateEvent.encode(p.create, b.uint32(10).fork()).ldelim(), p.update !== void 0 && a.CollectionUpdateEvent.encode(p.update, b.uint32(18).fork()).ldelim(), p.delete !== void 0 && a.CollectionDeleteEvent.encode(p.delete, b.uint32(26).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Rr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.create = a.CollectionCreateEvent.decode(T, T.uint32());\n            break;\n          case 2:\n            U.update = a.CollectionUpdateEvent.decode(T, T.uint32());\n            break;\n          case 3:\n            U.delete = a.CollectionDeleteEvent.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        create: ce(p.create) ? a.CollectionCreateEvent.fromJSON(p.create) : void 0,\n        update: ce(p.update) ? a.CollectionUpdateEvent.fromJSON(p.update) : void 0,\n        delete: ce(p.delete) ? a.CollectionDeleteEvent.fromJSON(p.delete) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.create !== void 0 && (b.create = p.create ? a.CollectionCreateEvent.toJSON(p.create) : void 0), p.update !== void 0 && (b.update = p.update ? a.CollectionUpdateEvent.toJSON(p.update) : void 0), p.delete !== void 0 && (b.delete = p.delete ? a.CollectionDeleteEvent.toJSON(p.delete) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Rr();\n      return b.create = p.create !== void 0 && p.create !== null ? a.CollectionCreateEvent.fromPartial(p.create) : void 0, b.update = p.update !== void 0 && p.update !== null ? a.CollectionUpdateEvent.fromPartial(p.update) : void 0, b.delete = p.delete !== void 0 && p.delete !== null ? a.CollectionDeleteEvent.fromPartial(p.delete) : void 0, b;\n    }\n  };\n  function Pr() {\n    return { create: void 0, update: void 0, delete: void 0, state: void 0 };\n  }\n  a.DestinationEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.create !== void 0 && a.DestinationCreateEvent.encode(p.create, b.uint32(10).fork()).ldelim(), p.update !== void 0 && a.DestinationUpdateEvent.encode(p.update, b.uint32(18).fork()).ldelim(), p.delete !== void 0 && a.DestinationDeleteEvent.encode(p.delete, b.uint32(26).fork()).ldelim(), p.state !== void 0 && a.DestinationStateEvent.encode(p.state, b.uint32(34).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Pr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.create = a.DestinationCreateEvent.decode(T, T.uint32());\n            break;\n          case 2:\n            U.update = a.DestinationUpdateEvent.decode(T, T.uint32());\n            break;\n          case 3:\n            U.delete = a.DestinationDeleteEvent.decode(T, T.uint32());\n            break;\n          case 4:\n            U.state = a.DestinationStateEvent.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        create: ce(p.create) ? a.DestinationCreateEvent.fromJSON(p.create) : void 0,\n        update: ce(p.update) ? a.DestinationUpdateEvent.fromJSON(p.update) : void 0,\n        delete: ce(p.delete) ? a.DestinationDeleteEvent.fromJSON(p.delete) : void 0,\n        state: ce(p.state) ? a.DestinationStateEvent.fromJSON(p.state) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.create !== void 0 && (b.create = p.create ? a.DestinationCreateEvent.toJSON(p.create) : void 0), p.update !== void 0 && (b.update = p.update ? a.DestinationUpdateEvent.toJSON(p.update) : void 0), p.delete !== void 0 && (b.delete = p.delete ? a.DestinationDeleteEvent.toJSON(p.delete) : void 0), p.state !== void 0 && (b.state = p.state ? a.DestinationStateEvent.toJSON(p.state) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Pr();\n      return b.create = p.create !== void 0 && p.create !== null ? a.DestinationCreateEvent.fromPartial(p.create) : void 0, b.update = p.update !== void 0 && p.update !== null ? a.DestinationUpdateEvent.fromPartial(p.update) : void 0, b.delete = p.delete !== void 0 && p.delete !== null ? a.DestinationDeleteEvent.fromPartial(p.delete) : void 0, b.state = p.state !== void 0 && p.state !== null ? a.DestinationStateEvent.fromPartial(p.state) : void 0, b;\n    }\n  };\n  function Or() {\n    return { create: void 0, update: void 0, delete: void 0, state: void 0 };\n  }\n  a.ProjectEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.create !== void 0 && a.ProjectCreateEvent.encode(p.create, b.uint32(10).fork()).ldelim(), p.update !== void 0 && a.ProjectUpdateEvent.encode(p.update, b.uint32(18).fork()).ldelim(), p.delete !== void 0 && a.ProjectDeleteEvent.encode(p.delete, b.uint32(26).fork()).ldelim(), p.state !== void 0 && a.ProjectBroadcastStateEvent.encode(p.state, b.uint32(34).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Or();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.create = a.ProjectCreateEvent.decode(T, T.uint32());\n            break;\n          case 2:\n            U.update = a.ProjectUpdateEvent.decode(T, T.uint32());\n            break;\n          case 3:\n            U.delete = a.ProjectDeleteEvent.decode(T, T.uint32());\n            break;\n          case 4:\n            U.state = a.ProjectBroadcastStateEvent.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        create: ce(p.create) ? a.ProjectCreateEvent.fromJSON(p.create) : void 0,\n        update: ce(p.update) ? a.ProjectUpdateEvent.fromJSON(p.update) : void 0,\n        delete: ce(p.delete) ? a.ProjectDeleteEvent.fromJSON(p.delete) : void 0,\n        state: ce(p.state) ? a.ProjectBroadcastStateEvent.fromJSON(p.state) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.create !== void 0 && (b.create = p.create ? a.ProjectCreateEvent.toJSON(p.create) : void 0), p.update !== void 0 && (b.update = p.update ? a.ProjectUpdateEvent.toJSON(p.update) : void 0), p.delete !== void 0 && (b.delete = p.delete ? a.ProjectDeleteEvent.toJSON(p.delete) : void 0), p.state !== void 0 && (b.state = p.state ? a.ProjectBroadcastStateEvent.toJSON(p.state) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Or();\n      return b.create = p.create !== void 0 && p.create !== null ? a.ProjectCreateEvent.fromPartial(p.create) : void 0, b.update = p.update !== void 0 && p.update !== null ? a.ProjectUpdateEvent.fromPartial(p.update) : void 0, b.delete = p.delete !== void 0 && p.delete !== null ? a.ProjectDeleteEvent.fromPartial(p.delete) : void 0, b.state = p.state !== void 0 && p.state !== null ? a.ProjectBroadcastStateEvent.fromPartial(p.state) : void 0, b;\n    }\n  };\n  function Nr() {\n    return {\n      create: void 0,\n      update: void 0,\n      delete: void 0,\n      add: void 0,\n      remove: void 0,\n      state: void 0\n    };\n  }\n  a.SourceEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.create !== void 0 && a.SourceCreateEvent.encode(p.create, b.uint32(10).fork()).ldelim(), p.update !== void 0 && a.SourceUpdateEvent.encode(p.update, b.uint32(18).fork()).ldelim(), p.delete !== void 0 && a.SourceDeleteEvent.encode(p.delete, b.uint32(26).fork()).ldelim(), p.add !== void 0 && a.SourceAddEvent.encode(p.add, b.uint32(34).fork()).ldelim(), p.remove !== void 0 && a.SourceRemoveEvent.encode(p.remove, b.uint32(42).fork()).ldelim(), p.state !== void 0 && a.SourceStateEvent.encode(p.state, b.uint32(50).fork()).ldelim(), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = Nr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.create = a.SourceCreateEvent.decode(T, T.uint32());\n            break;\n          case 2:\n            U.update = a.SourceUpdateEvent.decode(T, T.uint32());\n            break;\n          case 3:\n            U.delete = a.SourceDeleteEvent.decode(T, T.uint32());\n            break;\n          case 4:\n            U.add = a.SourceAddEvent.decode(T, T.uint32());\n            break;\n          case 5:\n            U.remove = a.SourceRemoveEvent.decode(T, T.uint32());\n            break;\n          case 6:\n            U.state = a.SourceStateEvent.decode(T, T.uint32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        create: ce(p.create) ? a.SourceCreateEvent.fromJSON(p.create) : void 0,\n        update: ce(p.update) ? a.SourceUpdateEvent.fromJSON(p.update) : void 0,\n        delete: ce(p.delete) ? a.SourceDeleteEvent.fromJSON(p.delete) : void 0,\n        add: ce(p.add) ? a.SourceAddEvent.fromJSON(p.add) : void 0,\n        remove: ce(p.remove) ? a.SourceRemoveEvent.fromJSON(p.remove) : void 0,\n        state: ce(p.state) ? a.SourceStateEvent.fromJSON(p.state) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.create !== void 0 && (b.create = p.create ? a.SourceCreateEvent.toJSON(p.create) : void 0), p.update !== void 0 && (b.update = p.update ? a.SourceUpdateEvent.toJSON(p.update) : void 0), p.delete !== void 0 && (b.delete = p.delete ? a.SourceDeleteEvent.toJSON(p.delete) : void 0), p.add !== void 0 && (b.add = p.add ? a.SourceAddEvent.toJSON(p.add) : void 0), p.remove !== void 0 && (b.remove = p.remove ? a.SourceRemoveEvent.toJSON(p.remove) : void 0), p.state !== void 0 && (b.state = p.state ? a.SourceStateEvent.toJSON(p.state) : void 0), b;\n    },\n    fromPartial(p) {\n      const b = Nr();\n      return b.create = p.create !== void 0 && p.create !== null ? a.SourceCreateEvent.fromPartial(p.create) : void 0, b.update = p.update !== void 0 && p.update !== null ? a.SourceUpdateEvent.fromPartial(p.update) : void 0, b.delete = p.delete !== void 0 && p.delete !== null ? a.SourceDeleteEvent.fromPartial(p.delete) : void 0, b.add = p.add !== void 0 && p.add !== null ? a.SourceAddEvent.fromPartial(p.add) : void 0, b.remove = p.remove !== void 0 && p.remove !== null ? a.SourceRemoveEvent.fromPartial(p.remove) : void 0, b.state = p.state !== void 0 && p.state !== null ? a.SourceStateEvent.fromPartial(p.state) : void 0, b;\n    }\n  };\n  function wr() {\n    return {\n      collection: void 0,\n      destination: void 0,\n      project: void 0,\n      source: void 0,\n      unspecified: void 0\n    };\n  }\n  a.LiveEvent = {\n    encode(p, b = c.default.Writer.create()) {\n      return p.collection !== void 0 && a.CollectionEvent.encode(p.collection, b.uint32(10).fork()).ldelim(), p.destination !== void 0 && a.DestinationEvent.encode(p.destination, b.uint32(18).fork()).ldelim(), p.project !== void 0 && a.ProjectEvent.encode(p.project, b.uint32(26).fork()).ldelim(), p.source !== void 0 && a.SourceEvent.encode(p.source, b.uint32(34).fork()).ldelim(), p.unspecified !== void 0 && b.uint32(40).int32((0, S.nullValueToNumber)(p.unspecified)), b;\n    },\n    decode(p, b) {\n      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);\n      let K = b === void 0 ? T.len : T.pos + b;\n      const U = wr();\n      for (; T.pos < K; ) {\n        const te = T.uint32();\n        switch (te >>> 3) {\n          case 1:\n            U.collection = a.CollectionEvent.decode(T, T.uint32());\n            break;\n          case 2:\n            U.destination = a.DestinationEvent.decode(T, T.uint32());\n            break;\n          case 3:\n            U.project = a.ProjectEvent.decode(T, T.uint32());\n            break;\n          case 4:\n            U.source = a.SourceEvent.decode(T, T.uint32());\n            break;\n          case 5:\n            U.unspecified = (0, S.nullValueFromJSON)(T.int32());\n            break;\n          default:\n            T.skipType(te & 7);\n            break;\n        }\n      }\n      return U;\n    },\n    fromJSON(p) {\n      return {\n        collection: ce(p.collection) ? a.CollectionEvent.fromJSON(p.collection) : void 0,\n        destination: ce(p.destination) ? a.DestinationEvent.fromJSON(p.destination) : void 0,\n        project: ce(p.project) ? a.ProjectEvent.fromJSON(p.project) : void 0,\n        source: ce(p.source) ? a.SourceEvent.fromJSON(p.source) : void 0,\n        unspecified: ce(p.unspecified) ? (0, S.nullValueFromJSON)(p.unspecified) : void 0\n      };\n    },\n    toJSON(p) {\n      const b = {};\n      return p.collection !== void 0 && (b.collection = p.collection ? a.CollectionEvent.toJSON(p.collection) : void 0), p.destination !== void 0 && (b.destination = p.destination ? a.DestinationEvent.toJSON(p.destination) : void 0), p.project !== void 0 && (b.project = p.project ? a.ProjectEvent.toJSON(p.project) : void 0), p.source !== void 0 && (b.source = p.source ? a.SourceEvent.toJSON(p.source) : void 0), p.unspecified !== void 0 && (b.unspecified = p.unspecified !== void 0 ? (0, S.nullValueToJSON)(p.unspecified) : void 0), b;\n    },\n    fromPartial(p) {\n      var b;\n      const T = wr();\n      return T.collection = p.collection !== void 0 && p.collection !== null ? a.CollectionEvent.fromPartial(p.collection) : void 0, T.destination = p.destination !== void 0 && p.destination !== null ? a.DestinationEvent.fromPartial(p.destination) : void 0, T.project = p.project !== void 0 && p.project !== null ? a.ProjectEvent.fromPartial(p.project) : void 0, T.source = p.source !== void 0 && p.source !== null ? a.SourceEvent.fromPartial(p.source) : void 0, T.unspecified = (b = p.unspecified) !== null && b !== void 0 ? b : void 0, T;\n    }\n  };\n  class Dr {\n    constructor(b, T) {\n      this.service = (T == null ? void 0 : T.service) || \"live.v21.CollectionService\", this.rpc = b, this.CreateCollection = this.CreateCollection.bind(this), this.GetCollection = this.GetCollection.bind(this), this.GetCollections = this.GetCollections.bind(this), this.UpdateCollection = this.UpdateCollection.bind(this), this.DeleteCollection = this.DeleteCollection.bind(this);\n    }\n    CreateCollection(b) {\n      const T = a.CreateCollectionRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"CreateCollection\", T).then((U) => a.CreateCollectionResponse.decode(new c.default.Reader(U)));\n    }\n    GetCollection(b) {\n      const T = a.GetCollectionRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"GetCollection\", T).then((U) => a.GetCollectionResponse.decode(new c.default.Reader(U)));\n    }\n    GetCollections(b) {\n      const T = a.GetCollectionsRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"GetCollections\", T).then((U) => a.GetCollectionsResponse.decode(new c.default.Reader(U)));\n    }\n    UpdateCollection(b) {\n      const T = a.UpdateCollectionRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"UpdateCollection\", T).then((U) => a.UpdateCollectionResponse.decode(new c.default.Reader(U)));\n    }\n    DeleteCollection(b) {\n      const T = a.DeleteCollectionRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"DeleteCollection\", T).then((U) => a.DeleteCollectionResponse.decode(new c.default.Reader(U)));\n    }\n  }\n  a.CollectionServiceClientImpl = Dr, a.CollectionServiceDefinition = {\n    name: \"CollectionService\",\n    fullName: \"live.v21.CollectionService\",\n    methods: {\n      /**\n       * Create Collection\n       *\n       * Create a new collection of related projects and collection live sources\n       */\n      createCollection: {\n        name: \"CreateCollection\",\n        requestType: a.CreateCollectionRequest,\n        requestStream: !1,\n        responseType: a.CreateCollectionResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Get Collection\n       *\n       * Get an existing collection of related projects and collection live\n       * sources\n       */\n      getCollection: {\n        name: \"GetCollection\",\n        requestType: a.GetCollectionRequest,\n        requestStream: !1,\n        responseType: a.GetCollectionResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Get Collections\n       *\n       * Get all collections owned by the user\n       */\n      getCollections: {\n        name: \"GetCollections\",\n        requestType: a.GetCollectionsRequest,\n        requestStream: !1,\n        responseType: a.GetCollectionsResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Update Collection\n       *\n       * Update select collection document data\n       */\n      updateCollection: {\n        name: \"UpdateCollection\",\n        requestType: a.UpdateCollectionRequest,\n        requestStream: !1,\n        responseType: a.UpdateCollectionResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Delete Collection\n       *\n       * Delete a collection of related projects and collection live sources\n       */\n      deleteCollection: {\n        name: \"DeleteCollection\",\n        requestType: a.DeleteCollectionRequest,\n        requestStream: !1,\n        responseType: a.DeleteCollectionResponse,\n        responseStream: !1,\n        options: {}\n      }\n    }\n  };\n  class Lr {\n    constructor(b, T) {\n      this.service = (T == null ? void 0 : T.service) || \"live.v21.ProjectService\", this.rpc = b, this.CreateProject = this.CreateProject.bind(this), this.GetProject = this.GetProject.bind(this), this.DeleteProject = this.DeleteProject.bind(this), this.UpdateProject = this.UpdateProject.bind(this), this.StartProjectBroadcast = this.StartProjectBroadcast.bind(this), this.StopProjectBroadcast = this.StopProjectBroadcast.bind(this), this.StartProjectWebRtc = this.StartProjectWebRtc.bind(this), this.StopProjectWebRtc = this.StopProjectWebRtc.bind(this), this.GetProjectBroadcastSnapshot = this.GetProjectBroadcastSnapshot.bind(this), this.GetProjectBroadcastStatus = this.GetProjectBroadcastStatus.bind(this);\n    }\n    CreateProject(b) {\n      const T = a.CreateProjectRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"CreateProject\", T).then((U) => a.CreateProjectResponse.decode(new c.default.Reader(U)));\n    }\n    GetProject(b) {\n      const T = a.GetProjectRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"GetProject\", T).then((U) => a.GetProjectResponse.decode(new c.default.Reader(U)));\n    }\n    DeleteProject(b) {\n      const T = a.DeleteProjectRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"DeleteProject\", T).then((U) => a.DeleteProjectResponse.decode(new c.default.Reader(U)));\n    }\n    UpdateProject(b) {\n      const T = a.UpdateProjectRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"UpdateProject\", T).then((U) => a.UpdateProjectResponse.decode(new c.default.Reader(U)));\n    }\n    StartProjectBroadcast(b) {\n      const T = a.StartProjectBroadcastRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"StartProjectBroadcast\", T).then((U) => a.StartProjectBroadcastResponse.decode(new c.default.Reader(U)));\n    }\n    StopProjectBroadcast(b) {\n      const T = a.StopProjectBroadcastRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"StopProjectBroadcast\", T).then((U) => a.StopProjectBroadcastResponse.decode(new c.default.Reader(U)));\n    }\n    StartProjectWebRtc(b) {\n      const T = a.StartProjectWebRtcRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"StartProjectWebRtc\", T).then((U) => a.StartProjectWebRtcResponse.decode(new c.default.Reader(U)));\n    }\n    StopProjectWebRtc(b) {\n      const T = a.StopProjectWebRtcRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"StopProjectWebRtc\", T).then((U) => a.StopProjectWebRtcResponse.decode(new c.default.Reader(U)));\n    }\n    GetProjectBroadcastSnapshot(b) {\n      const T = a.GetProjectBroadcastSnapshotRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"GetProjectBroadcastSnapshot\", T).then((U) => a.GetProjectBroadcastSnapshotResponse.decode(new c.default.Reader(U)));\n    }\n    GetProjectBroadcastStatus(b) {\n      const T = a.GetProjectBroadcastStatusRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"GetProjectBroadcastStatus\", T).then((U) => a.GetProjectBroadcastStatusResponse.decode(new c.default.Reader(U)));\n    }\n  }\n  a.ProjectServiceClientImpl = Lr, a.ProjectServiceDefinition = {\n    name: \"ProjectService\",\n    fullName: \"live.v21.ProjectService\",\n    methods: {\n      /**\n       * Create Project\n       *\n       * Create a new project\n       */\n      createProject: {\n        name: \"CreateProject\",\n        requestType: a.CreateProjectRequest,\n        requestStream: !1,\n        responseType: a.CreateProjectResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Get Project\n       *\n       * Get an existing project\n       */\n      getProject: {\n        name: \"GetProject\",\n        requestType: a.GetProjectRequest,\n        requestStream: !1,\n        responseType: a.GetProjectResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Delete Project\n       *\n       * Delete a project\n       */\n      deleteProject: {\n        name: \"DeleteProject\",\n        requestType: a.DeleteProjectRequest,\n        requestStream: !1,\n        responseType: a.DeleteProjectResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Update Project\n       *\n       * Updates a project\n       */\n      updateProject: {\n        name: \"UpdateProject\",\n        requestType: a.UpdateProjectRequest,\n        requestStream: !1,\n        responseType: a.UpdateProjectResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Start Broadcast\n       *\n       * Start broadcasting a project\n       */\n      startProjectBroadcast: {\n        name: \"StartProjectBroadcast\",\n        requestType: a.StartProjectBroadcastRequest,\n        requestStream: !1,\n        responseType: a.StartProjectBroadcastResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Stop Broadcast\n       *\n       * Stop broadcasting a project\n       */\n      stopProjectBroadcast: {\n        name: \"StopProjectBroadcast\",\n        requestType: a.StopProjectBroadcastRequest,\n        requestStream: !1,\n        responseType: a.StopProjectBroadcastResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Start WebRTC\n       *\n       * Start WebRTC services\n       */\n      startProjectWebRtc: {\n        name: \"StartProjectWebRtc\",\n        requestType: a.StartProjectWebRtcRequest,\n        requestStream: !1,\n        responseType: a.StartProjectWebRtcResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Stop WebRTC\n       *\n       * Stop WebRTC services\n       */\n      stopProjectWebRtc: {\n        name: \"StopProjectWebRtc\",\n        requestType: a.StopProjectWebRtcRequest,\n        requestStream: !1,\n        responseType: a.StopProjectWebRtcResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Get Snapshot\n       *\n       * Get a snapshot of the current output frame of the broadcast\n       */\n      getProjectBroadcastSnapshot: {\n        name: \"GetProjectBroadcastSnapshot\",\n        requestType: a.GetProjectBroadcastSnapshotRequest,\n        requestStream: !1,\n        responseType: a.GetProjectBroadcastSnapshotResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Get Broadcast Status\n       *\n       * Get the broadcast status of the project\n       */\n      getProjectBroadcastStatus: {\n        name: \"GetProjectBroadcastStatus\",\n        requestType: a.GetProjectBroadcastStatusRequest,\n        requestStream: !1,\n        responseType: a.GetProjectBroadcastStatusResponse,\n        responseStream: !1,\n        options: {}\n      }\n    }\n  };\n  class Mr {\n    constructor(b, T) {\n      this.service = (T == null ? void 0 : T.service) || \"live.v21.DestinationService\", this.rpc = b, this.CreateDestination = this.CreateDestination.bind(this), this.GetDestination = this.GetDestination.bind(this), this.UpdateDestination = this.UpdateDestination.bind(this), this.DeleteDestination = this.DeleteDestination.bind(this);\n    }\n    CreateDestination(b) {\n      const T = a.CreateDestinationRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"CreateDestination\", T).then((U) => a.CreateDestinationResponse.decode(new c.default.Reader(U)));\n    }\n    GetDestination(b) {\n      const T = a.GetDestinationRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"GetDestination\", T).then((U) => a.GetDestinationResponse.decode(new c.default.Reader(U)));\n    }\n    UpdateDestination(b) {\n      const T = a.UpdateDestinationRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"UpdateDestination\", T).then((U) => a.UpdateDestinationResponse.decode(new c.default.Reader(U)));\n    }\n    DeleteDestination(b) {\n      const T = a.DeleteDestinationRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"DeleteDestination\", T).then((U) => a.DeleteDestinationResponse.decode(new c.default.Reader(U)));\n    }\n  }\n  a.DestinationServiceClientImpl = Mr, a.DestinationServiceDefinition = {\n    name: \"DestinationService\",\n    fullName: \"live.v21.DestinationService\",\n    methods: {\n      /**\n       * Create Destination\n       *\n       * Create a new Destination\n       */\n      createDestination: {\n        name: \"CreateDestination\",\n        requestType: a.CreateDestinationRequest,\n        requestStream: !1,\n        responseType: a.CreateDestinationResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Get Destination\n       *\n       * Get an existing Destination.\n       */\n      getDestination: {\n        name: \"GetDestination\",\n        requestType: a.GetDestinationRequest,\n        requestStream: !1,\n        responseType: a.GetDestinationResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Update Destination\n       *\n       * Update a destination\n       */\n      updateDestination: {\n        name: \"UpdateDestination\",\n        requestType: a.UpdateDestinationRequest,\n        requestStream: !1,\n        responseType: a.UpdateDestinationResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Delete Destination\n       *\n       * Delete a destination\n       */\n      deleteDestination: {\n        name: \"DeleteDestination\",\n        requestType: a.DeleteDestinationRequest,\n        requestStream: !1,\n        responseType: a.DeleteDestinationResponse,\n        responseStream: !1,\n        options: {}\n      }\n    }\n  };\n  class Ur {\n    constructor(b, T) {\n      this.service = (T == null ? void 0 : T.service) || \"live.v21.SourceService\", this.rpc = b, this.CreateSource = this.CreateSource.bind(this), this.DeleteSource = this.DeleteSource.bind(this), this.UpdateSource = this.UpdateSource.bind(this), this.UpdateSourceInProject = this.UpdateSourceInProject.bind(this), this.GetSource = this.GetSource.bind(this), this.GetSources = this.GetSources.bind(this), this.AddSourceToProject = this.AddSourceToProject.bind(this), this.RemoveSourceFromProject = this.RemoveSourceFromProject.bind(this), this.GetSourcePlaylist = this.GetSourcePlaylist.bind(this);\n    }\n    CreateSource(b) {\n      const T = a.CreateSourceRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"CreateSource\", T).then((U) => a.CreateSourceResponse.decode(new c.default.Reader(U)));\n    }\n    DeleteSource(b) {\n      const T = a.DeleteSourceRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"DeleteSource\", T).then((U) => a.DeleteSourceResponse.decode(new c.default.Reader(U)));\n    }\n    UpdateSource(b) {\n      const T = a.UpdateSourceRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"UpdateSource\", T).then((U) => a.UpdateSourceResponse.decode(new c.default.Reader(U)));\n    }\n    UpdateSourceInProject(b) {\n      const T = a.UpdateSourceInProjectRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"UpdateSourceInProject\", T).then((U) => a.UpdateSourceInProjectResponse.decode(new c.default.Reader(U)));\n    }\n    GetSource(b) {\n      const T = a.GetSourceRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"GetSource\", T).then((U) => a.GetSourceResponse.decode(new c.default.Reader(U)));\n    }\n    GetSources(b) {\n      const T = a.GetSourcesRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"GetSources\", T).then((U) => a.GetSourcesResponse.decode(new c.default.Reader(U)));\n    }\n    AddSourceToProject(b) {\n      const T = a.AddSourceToProjectRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"AddSourceToProject\", T).then((U) => a.AddSourceToProjectResponse.decode(new c.default.Reader(U)));\n    }\n    RemoveSourceFromProject(b) {\n      const T = a.RemoveSourceFromProjectRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"RemoveSourceFromProject\", T).then((U) => a.RemoveSourceFromProjectResponse.decode(new c.default.Reader(U)));\n    }\n    GetSourcePlaylist(b) {\n      const T = a.GetSourcePlaylistRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"GetSourcePlaylist\", T).then((U) => l.HttpBody.decode(new c.default.Reader(U)));\n    }\n  }\n  a.SourceServiceClientImpl = Ur, a.SourceServiceDefinition = {\n    name: \"SourceService\",\n    fullName: \"live.v21.SourceService\",\n    methods: {\n      /**\n       * Create Collection Live Source\n       *\n       * Create a new live source in a collection\n       * ### Permissions\n       * * scope: `SCOPE_VAPI_CREATE`\n       */\n      createSource: {\n        name: \"CreateSource\",\n        requestType: a.CreateSourceRequest,\n        requestStream: !1,\n        responseType: a.CreateSourceResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Delete Live Source\n       *\n       * Deletes a live source from a collection\n       */\n      deleteSource: {\n        name: \"DeleteSource\",\n        requestType: a.DeleteSourceRequest,\n        requestStream: !1,\n        responseType: a.DeleteSourceResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Update Source\n       *\n       * Update attributes of the Source.\n       */\n      updateSource: {\n        name: \"UpdateSource\",\n        requestType: a.UpdateSourceRequest,\n        requestStream: !1,\n        responseType: a.UpdateSourceResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Update Source\n       *\n       * Update attributes of the Source.\n       */\n      updateSourceInProject: {\n        name: \"UpdateSourceInProject\",\n        requestType: a.UpdateSourceInProjectRequest,\n        requestStream: !1,\n        responseType: a.UpdateSourceInProjectResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Get Source\n       *\n       * Get an existing source in a project\n       */\n      getSource: {\n        name: \"GetSource\",\n        requestType: a.GetSourceRequest,\n        requestStream: !1,\n        responseType: a.GetSourceResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Get Source\n       *\n       * Get existing sources in a collection\n       */\n      getSources: {\n        name: \"GetSources\",\n        requestType: a.GetSourcesRequest,\n        requestStream: !1,\n        responseType: a.GetSourcesResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Add Source to Project\n       *\n       * Add a source to a project\n       */\n      addSourceToProject: {\n        name: \"AddSourceToProject\",\n        requestType: a.AddSourceToProjectRequest,\n        requestStream: !1,\n        responseType: a.AddSourceToProjectResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Delete Source From Project\n       *\n       * Removes a source from a project.\n       */\n      removeSourceFromProject: {\n        name: \"RemoveSourceFromProject\",\n        requestType: a.RemoveSourceFromProjectRequest,\n        requestStream: !1,\n        responseType: a.RemoveSourceFromProjectResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Get the HLS playlist for a source.\n       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME\n       */\n      getSourcePlaylist: {\n        name: \"GetSourcePlaylist\",\n        requestType: a.GetSourcePlaylistRequest,\n        requestStream: !1,\n        responseType: l.HttpBody,\n        responseStream: !1,\n        options: {}\n      }\n    }\n  };\n  class $r {\n    constructor(b, T) {\n      this.service = (T == null ? void 0 : T.service) || \"live.v21.BackendAuthenticationService\", this.rpc = b, this.CreateAccessToken = this.CreateAccessToken.bind(this);\n    }\n    CreateAccessToken(b) {\n      const T = a.CreateAccessTokenRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"CreateAccessToken\", T).then((U) => a.CreateAccessTokenResponse.decode(new c.default.Reader(U)));\n    }\n  }\n  a.BackendAuthenticationServiceClientImpl = $r, a.BackendAuthenticationServiceDefinition = {\n    name: \"BackendAuthenticationService\",\n    fullName: \"live.v21.BackendAuthenticationService\",\n    methods: {\n      /**\n       * Create Access Token\n       *\n       * Create an access token for a session host\n       */\n      createAccessToken: {\n        name: \"CreateAccessToken\",\n        requestType: a.CreateAccessTokenRequest,\n        requestStream: !1,\n        responseType: a.CreateAccessTokenResponse,\n        responseStream: !1,\n        options: {}\n      }\n    }\n  };\n  class Br {\n    constructor(b, T) {\n      this.service = (T == null ? void 0 : T.service) || \"live.v21.AuthenticationService\", this.rpc = b, this.CreateGuestAccessToken = this.CreateGuestAccessToken.bind(this), this.RefreshAccessToken = this.RefreshAccessToken.bind(this), this.CreateWebRtcAccessToken = this.CreateWebRtcAccessToken.bind(this);\n    }\n    CreateGuestAccessToken(b) {\n      const T = a.CreateGuestAccessTokenRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"CreateGuestAccessToken\", T).then((U) => a.CreateGuestAccessTokenResponse.decode(new c.default.Reader(U)));\n    }\n    RefreshAccessToken(b) {\n      const T = a.RefreshAccessTokenRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"RefreshAccessToken\", T).then((U) => a.RefreshAccessTokenResponse.decode(new c.default.Reader(U)));\n    }\n    CreateWebRtcAccessToken(b) {\n      const T = a.CreateWebRtcAccessTokenRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"CreateWebRtcAccessToken\", T).then((U) => a.CreateWebRtcAccessTokenResponse.decode(new c.default.Reader(U)));\n    }\n  }\n  a.AuthenticationServiceClientImpl = Br, a.AuthenticationServiceDefinition = {\n    name: \"AuthenticationService\",\n    fullName: \"live.v21.AuthenticationService\",\n    methods: {\n      /**\n       * Create Guest Access Token\n       *\n       * Create an access token for a guest\n       */\n      createGuestAccessToken: {\n        name: \"CreateGuestAccessToken\",\n        requestType: a.CreateGuestAccessTokenRequest,\n        requestStream: !1,\n        responseType: a.CreateGuestAccessTokenResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Refresh Access Token\n       *\n       * Forcibly refresh an access token prior to expiration\n       */\n      refreshAccessToken: {\n        name: \"RefreshAccessToken\",\n        requestType: a.RefreshAccessTokenRequest,\n        requestStream: !1,\n        responseType: a.RefreshAccessTokenResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Create WebRTC Access Token\n       *\n       * Create a WebRTC Access Token\n       */\n      createWebRtcAccessToken: {\n        name: \"CreateWebRtcAccessToken\",\n        requestType: a.CreateWebRtcAccessTokenRequest,\n        requestStream: !1,\n        responseType: a.CreateWebRtcAccessTokenResponse,\n        responseStream: !1,\n        options: {}\n      }\n    }\n  };\n  class Jr {\n    constructor(b, T) {\n      this.service = (T == null ? void 0 : T.service) || \"live.v21.PublicAuthenticationService\", this.rpc = b, this.GetJsonWebKeySet = this.GetJsonWebKeySet.bind(this), this.GuestCodeRedirect = this.GuestCodeRedirect.bind(this);\n    }\n    GetJsonWebKeySet(b) {\n      const T = a.GetJsonWebKeySetRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"GetJsonWebKeySet\", T).then((U) => a.GetJsonWebKeySetResponse.decode(new c.default.Reader(U)));\n    }\n    GuestCodeRedirect(b) {\n      const T = a.GuestCodeRedirectRequest.encode(b).finish();\n      return this.rpc.request(this.service, \"GuestCodeRedirect\", T).then((U) => a.GuestCodeRedirectResponse.decode(new c.default.Reader(U)));\n    }\n  }\n  a.PublicAuthenticationServiceClientImpl = Jr, a.PublicAuthenticationServiceDefinition = {\n    name: \"PublicAuthenticationService\",\n    fullName: \"live.v21.PublicAuthenticationService\",\n    methods: {\n      /**\n       * Get Public Keys\n       *\n       * Get public keys used to sign access tokens\n       */\n      getJsonWebKeySet: {\n        name: \"GetJsonWebKeySet\",\n        requestType: a.GetJsonWebKeySetRequest,\n        requestStream: !1,\n        responseType: a.GetJsonWebKeySetResponse,\n        responseStream: !1,\n        options: {}\n      },\n      /**\n       * Exchange Guest Access Token\n       *\n       * Exchange a guest access token with updated user identifiers\n       */\n      guestCodeRedirect: {\n        name: \"GuestCodeRedirect\",\n        requestType: a.GuestCodeRedirectRequest,\n        requestStream: !1,\n        responseType: a.GuestCodeRedirectResponse,\n        responseStream: !1,\n        options: {}\n      }\n    }\n  };\n  var Ke = (() => {\n    if (typeof Ke < \"u\")\n      return Ke;\n    if (typeof self < \"u\")\n      return self;\n    if (typeof window < \"u\")\n      return window;\n    if (typeof commonjsGlobal$1 < \"u\")\n      return commonjsGlobal$1;\n    throw \"Unable to locate global object\";\n  })();\n  function Fr(p) {\n    if (Ke.Buffer)\n      return Uint8Array.from(Ke.Buffer.from(p, \"base64\"));\n    {\n      const b = Ke.atob(p), T = new Uint8Array(b.length);\n      for (let K = 0; K < b.length; ++K)\n        T[K] = b.charCodeAt(K);\n      return T;\n    }\n  }\n  function Vr(p) {\n    if (Ke.Buffer)\n      return Ke.Buffer.from(p).toString(\"base64\");\n    {\n      const b = [];\n      return p.forEach((T) => {\n        b.push(String.fromCharCode(T));\n      }), Ke.btoa(b.join(\"\"));\n    }\n  }\n  function Ut(p) {\n    const b = new Date(p), T = b.getTime() / 1e3, K = b.getTime() % 1e3 * 1e6;\n    return { seconds: T, nanos: K };\n  }\n  function $t(p) {\n    let b = p.seconds * 1e3;\n    return b += p.nanos / 1e6, new Date(b).toISOString();\n  }\n  function ce(p) {\n    return p != null;\n  }\n})(api$1);\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function($, J, V, q) {\n    q === void 0 && (q = V);\n    var G = Object.getOwnPropertyDescriptor(J, V);\n    (!G || (\"get\" in G ? !J.__esModule : G.writable || G.configurable)) && (G = { enumerable: !0, get: function() {\n      return J[V];\n    } }), Object.defineProperty($, q, G);\n  } : function($, J, V, q) {\n    q === void 0 && (q = V), $[q] = J[V];\n  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function($, J) {\n    Object.defineProperty($, \"default\", { enumerable: !0, value: J });\n  } : function($, J) {\n    $.default = J;\n  }), l = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function($, J, V, q) {\n    var G = arguments.length, H = G < 3 ? J : q === null ? q = Object.getOwnPropertyDescriptor(J, V) : q, B;\n    if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\")\n      H = Reflect.decorate($, J, V, q);\n    else\n      for (var Y = $.length - 1; Y >= 0; Y--)\n        (B = $[Y]) && (H = (G < 3 ? B(H) : G > 3 ? B(J, V, H) : B(J, V)) || H);\n    return G > 3 && H && Object.defineProperty(J, V, H), H;\n  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function($) {\n    if ($ && $.__esModule)\n      return $;\n    var J = {};\n    if ($ != null)\n      for (var V in $)\n        V !== \"default\" && Object.prototype.hasOwnProperty.call($, V) && u(J, $, V);\n    return c(J, $), J;\n  }, S = commonjsGlobal$1 && commonjsGlobal$1.__metadata || function($, J) {\n    if (typeof Reflect == \"object\" && typeof Reflect.metadata == \"function\")\n      return Reflect.metadata($, J);\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.LiveApi = void 0;\n  const g = v(lib$1), E = api$2, _ = v(api$1), k = decorator, L = \"LiveApi\";\n  class M extends E.ApiClient {\n    constructor(J, V, q, G, H, B, Y) {\n      super(J, q, B, L, Y), this.handlers = {}, this.eventApi = V, this.accessTokenRefreshCallback = G, this.publicAuthentication = this.clientFactory.create(_.PublicAuthenticationServiceDefinition, this.channel), H != null && (this.backendAuthentication = this.clientFactory.create(_.BackendAuthenticationServiceDefinition, this.channel, {\n        \"*\": { metadata: g.Metadata({ \"X-Api-Key\": H }) }\n      })), this.eventApi.on(\"event\", { name: `${M.LIVEAPI_EVENT_PREFIX}:*`, ignoreSessionEvents: !0, allowedSessionEvents: [`${M.LIVEAPI_EVENT_PREFIX}:EVENT_TYPE_PROJECT:EVENT_SUB_TYPE_STATE`] }, this.eventCallback.bind(this));\n    }\n    /**\n    * Register an event handler\n    *\n    * @param type Type of event\n    * @param handler\n    */\n    on(J, V) {\n      var q;\n      this.handlers[J] = (q = this.handlers[J]) !== null && q !== void 0 ? q : [], this.handlers[J].push(V);\n    }\n    /**\n     * Unregister an event handler\n     *\n     * @param type Type of event\n     * @param handler\n     */\n    off(J, V) {\n      this.handlers[J] = this.handlers[J].filter((q) => q !== V);\n    }\n    emitToHandlers(J, V, q) {\n      var G;\n      for (const H of (G = this.handlers[J]) !== null && G !== void 0 ? G : [])\n        H(Object.values(q).find((B) => !!B), V);\n    }\n    async subscribeToCollection(J) {\n      await this.eventApi.subscribe(`${M.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: J } });\n    }\n    async unsubscribeFromCollection(J) {\n      await this.eventApi.unsubscribe(`${M.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: J } });\n    }\n    async subscribeToProject(J, V) {\n      await this.eventApi.subscribe(`${M.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: J, projectId: V } });\n    }\n    async unsubscribeFromProject(J, V) {\n      await this.eventApi.unsubscribe(`${M.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: J, projectId: V } });\n    }\n    eventCallback(J) {\n      let q = J.name.split(`${M.LIVEAPI_EVENT_PREFIX}:`)[1].split(\":\"), G = _.eventTypeFromJSON(q[0]), H = _.eventSubTypeFromJSON(q[1]);\n      this.log.info(\"processing event: \" + G + \"/\" + H), M.liveApiEventMap[G] && this.emitToHandlers(G, H, J.payload);\n    }\n    _setup(J) {\n      let V = this;\n      J.onHeader = function(q) {\n        let G = q.get(\"Authorization\");\n        if (G != null) {\n          const H = G.split(\" \");\n          if (H.length == 2 && H[0] == \"Bearer\") {\n            let B = H[1];\n            V.log.info(\"received refresh token\"), V.accessTokenRefreshCallback(B);\n          }\n        }\n      }, this.collection = this.clientFactory.create(_.CollectionServiceDefinition, this.channel, {\n        \"*\": J\n      }), this.project = this.clientFactory.create(_.ProjectServiceDefinition, this.channel, {\n        \"*\": J\n      }), this.source = this.clientFactory.create(_.SourceServiceDefinition, this.channel, {\n        \"*\": J\n      }), this.destination = this.clientFactory.create(_.DestinationServiceDefinition, this.channel, {\n        \"*\": J\n      }), this.authentication = this.clientFactory.create(_.AuthenticationServiceDefinition, this.channel, {\n        \"*\": J\n      });\n    }\n  }\n  M.LIVEAPI_EVENT_PREFIX = \"apistream:live\", l([\n    (0, k.RequiresSdkAuthentication)(),\n    S(\"design:type\", Object)\n  ], M.prototype, \"collection\", void 0), l([\n    (0, k.RequiresSdkAuthentication)(),\n    S(\"design:type\", Object)\n  ], M.prototype, \"project\", void 0), l([\n    (0, k.RequiresSdkAuthentication)(),\n    S(\"design:type\", Object)\n  ], M.prototype, \"source\", void 0), l([\n    (0, k.RequiresSdkAuthentication)(),\n    S(\"design:type\", Object)\n  ], M.prototype, \"destination\", void 0), l([\n    (0, k.RequiresSdkAuthentication)(),\n    S(\"design:type\", Object)\n  ], M.prototype, \"authentication\", void 0), a.LiveApi = M, function($) {\n    $.liveApiEventMap = {\n      [_.EventType.EVENT_TYPE_COLLECTION]: \"collection\",\n      [_.EventType.EVENT_TYPE_PROJECT]: \"project\",\n      [_.EventType.EVENT_TYPE_SOURCE]: \"source\",\n      [_.EventType.EVENT_TYPE_DESTINATION]: \"destination\",\n      [_.EventType.EVENT_TYPE_UNSPECIFIED]: \"unspecified\"\n    };\n  }(M = a.LiveApi || (a.LiveApi = {}));\n})(liveapi);\nvar eventapi = {}, dist$1 = {}, api = {};\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics = function(a, u) {\n  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(c, l) {\n    c.__proto__ = l;\n  } || function(c, l) {\n    for (var v in l)\n      l.hasOwnProperty(v) && (c[v] = l[v]);\n  }, extendStatics(a, u);\n};\nfunction __extends(a, u) {\n  extendStatics(a, u);\n  function c() {\n    this.constructor = a;\n  }\n  a.prototype = u === null ? Object.create(u) : (c.prototype = u.prototype, new c());\n}\nfunction isFunction$2(a) {\n  return typeof a == \"function\";\n}\nvar _enable_super_gross_mode_that_will_cause_bad_things = !1, config$2 = {\n  Promise: void 0,\n  set useDeprecatedSynchronousErrorHandling(a) {\n    if (a) {\n      var u = /* @__PURE__ */ new Error();\n      \"\" + u.stack;\n    }\n    _enable_super_gross_mode_that_will_cause_bad_things = a;\n  },\n  get useDeprecatedSynchronousErrorHandling() {\n    return _enable_super_gross_mode_that_will_cause_bad_things;\n  }\n};\nfunction hostReportError(a) {\n  setTimeout(function() {\n    throw a;\n  }, 0);\n}\nvar empty$2 = {\n  closed: !0,\n  next: function(a) {\n  },\n  error: function(a) {\n    if (config$2.useDeprecatedSynchronousErrorHandling)\n      throw a;\n    hostReportError(a);\n  },\n  complete: function() {\n  }\n}, isArray$4 = /* @__PURE__ */ function() {\n  return Array.isArray || function(a) {\n    return a && typeof a.length == \"number\";\n  };\n}();\nfunction isObject$8(a) {\n  return a !== null && typeof a == \"object\";\n}\nvar UnsubscriptionErrorImpl = /* @__PURE__ */ function() {\n  function a(u) {\n    return Error.call(this), this.message = u ? u.length + ` errors occurred during unsubscription:\n` + u.map(function(c, l) {\n      return l + 1 + \") \" + c.toString();\n    }).join(`\n  `) : \"\", this.name = \"UnsubscriptionError\", this.errors = u, this;\n  }\n  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;\n}(), UnsubscriptionError = UnsubscriptionErrorImpl, Subscription = /* @__PURE__ */ function() {\n  function a(u) {\n    this.closed = !1, this._parentOrParents = null, this._subscriptions = null, u && (this._ctorUnsubscribe = !0, this._unsubscribe = u);\n  }\n  return a.prototype.unsubscribe = function() {\n    var u;\n    if (!this.closed) {\n      var c = this, l = c._parentOrParents, v = c._ctorUnsubscribe, S = c._unsubscribe, g = c._subscriptions;\n      if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, l instanceof a)\n        l.remove(this);\n      else if (l !== null)\n        for (var E = 0; E < l.length; ++E) {\n          var _ = l[E];\n          _.remove(this);\n        }\n      if (isFunction$2(S)) {\n        v && (this._unsubscribe = void 0);\n        try {\n          S.call(this);\n        } catch (M) {\n          u = M instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(M.errors) : [M];\n        }\n      }\n      if (isArray$4(g))\n        for (var E = -1, k = g.length; ++E < k; ) {\n          var L = g[E];\n          if (isObject$8(L))\n            try {\n              L.unsubscribe();\n            } catch ($) {\n              u = u || [], $ instanceof UnsubscriptionError ? u = u.concat(flattenUnsubscriptionErrors($.errors)) : u.push($);\n            }\n        }\n      if (u)\n        throw new UnsubscriptionError(u);\n    }\n  }, a.prototype.add = function(u) {\n    var c = u;\n    if (!u)\n      return a.EMPTY;\n    switch (typeof u) {\n      case \"function\":\n        c = new a(u);\n      case \"object\":\n        if (c === this || c.closed || typeof c.unsubscribe != \"function\")\n          return c;\n        if (this.closed)\n          return c.unsubscribe(), c;\n        if (!(c instanceof a)) {\n          var l = c;\n          c = new a(), c._subscriptions = [l];\n        }\n        break;\n      default:\n        throw new Error(\"unrecognized teardown \" + u + \" added to Subscription.\");\n    }\n    var v = c._parentOrParents;\n    if (v === null)\n      c._parentOrParents = this;\n    else if (v instanceof a) {\n      if (v === this)\n        return c;\n      c._parentOrParents = [v, this];\n    } else if (v.indexOf(this) === -1)\n      v.push(this);\n    else\n      return c;\n    var S = this._subscriptions;\n    return S === null ? this._subscriptions = [c] : S.push(c), c;\n  }, a.prototype.remove = function(u) {\n    var c = this._subscriptions;\n    if (c) {\n      var l = c.indexOf(u);\n      l !== -1 && c.splice(l, 1);\n    }\n  }, a.EMPTY = function(u) {\n    return u.closed = !0, u;\n  }(new a()), a;\n}();\nfunction flattenUnsubscriptionErrors(a) {\n  return a.reduce(function(u, c) {\n    return u.concat(c instanceof UnsubscriptionError ? c.errors : c);\n  }, []);\n}\nvar rxSubscriber = /* @__PURE__ */ function() {\n  return typeof Symbol == \"function\" ? /* @__PURE__ */ Symbol(\"rxSubscriber\") : \"@@rxSubscriber_\" + /* @__PURE__ */ Math.random();\n}(), Subscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this) || this;\n    switch (S.syncErrorValue = null, S.syncErrorThrown = !1, S.syncErrorThrowable = !1, S.isStopped = !1, arguments.length) {\n      case 0:\n        S.destination = empty$2;\n        break;\n      case 1:\n        if (!c) {\n          S.destination = empty$2;\n          break;\n        }\n        if (typeof c == \"object\") {\n          c instanceof u ? (S.syncErrorThrowable = c.syncErrorThrowable, S.destination = c, c.add(S)) : (S.syncErrorThrowable = !0, S.destination = new SafeSubscriber(S, c));\n          break;\n        }\n      default:\n        S.syncErrorThrowable = !0, S.destination = new SafeSubscriber(S, c, l, v);\n        break;\n    }\n    return S;\n  }\n  return u.prototype[rxSubscriber] = function() {\n    return this;\n  }, u.create = function(c, l, v) {\n    var S = new u(c, l, v);\n    return S.syncErrorThrowable = !1, S;\n  }, u.prototype.next = function(c) {\n    this.isStopped || this._next(c);\n  }, u.prototype.error = function(c) {\n    this.isStopped || (this.isStopped = !0, this._error(c));\n  }, u.prototype.complete = function() {\n    this.isStopped || (this.isStopped = !0, this._complete());\n  }, u.prototype.unsubscribe = function() {\n    this.closed || (this.isStopped = !0, a.prototype.unsubscribe.call(this));\n  }, u.prototype._next = function(c) {\n    this.destination.next(c);\n  }, u.prototype._error = function(c) {\n    this.destination.error(c), this.unsubscribe();\n  }, u.prototype._complete = function() {\n    this.destination.complete(), this.unsubscribe();\n  }, u.prototype._unsubscribeAndRecycle = function() {\n    var c = this._parentOrParents;\n    return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = c, this;\n  }, u;\n}(Subscription), SafeSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v, S) {\n    var g = a.call(this) || this;\n    g._parentSubscriber = c;\n    var E, _ = g;\n    return isFunction$2(l) ? E = l : l && (E = l.next, v = l.error, S = l.complete, l !== empty$2 && (_ = Object.create(l), isFunction$2(_.unsubscribe) && g.add(_.unsubscribe.bind(_)), _.unsubscribe = g.unsubscribe.bind(g))), g._context = _, g._next = E, g._error = v, g._complete = S, g;\n  }\n  return u.prototype.next = function(c) {\n    if (!this.isStopped && this._next) {\n      var l = this._parentSubscriber;\n      !config$2.useDeprecatedSynchronousErrorHandling || !l.syncErrorThrowable ? this.__tryOrUnsub(this._next, c) : this.__tryOrSetError(l, this._next, c) && this.unsubscribe();\n    }\n  }, u.prototype.error = function(c) {\n    if (!this.isStopped) {\n      var l = this._parentSubscriber, v = config$2.useDeprecatedSynchronousErrorHandling;\n      if (this._error)\n        !v || !l.syncErrorThrowable ? (this.__tryOrUnsub(this._error, c), this.unsubscribe()) : (this.__tryOrSetError(l, this._error, c), this.unsubscribe());\n      else if (l.syncErrorThrowable)\n        v ? (l.syncErrorValue = c, l.syncErrorThrown = !0) : hostReportError(c), this.unsubscribe();\n      else {\n        if (this.unsubscribe(), v)\n          throw c;\n        hostReportError(c);\n      }\n    }\n  }, u.prototype.complete = function() {\n    var c = this;\n    if (!this.isStopped) {\n      var l = this._parentSubscriber;\n      if (this._complete) {\n        var v = function() {\n          return c._complete.call(c._context);\n        };\n        !config$2.useDeprecatedSynchronousErrorHandling || !l.syncErrorThrowable ? (this.__tryOrUnsub(v), this.unsubscribe()) : (this.__tryOrSetError(l, v), this.unsubscribe());\n      } else\n        this.unsubscribe();\n    }\n  }, u.prototype.__tryOrUnsub = function(c, l) {\n    try {\n      c.call(this._context, l);\n    } catch (v) {\n      if (this.unsubscribe(), config$2.useDeprecatedSynchronousErrorHandling)\n        throw v;\n      hostReportError(v);\n    }\n  }, u.prototype.__tryOrSetError = function(c, l, v) {\n    if (!config$2.useDeprecatedSynchronousErrorHandling)\n      throw new Error(\"bad call\");\n    try {\n      l.call(this._context, v);\n    } catch (S) {\n      return config$2.useDeprecatedSynchronousErrorHandling ? (c.syncErrorValue = S, c.syncErrorThrown = !0, !0) : (hostReportError(S), !0);\n    }\n    return !1;\n  }, u.prototype._unsubscribe = function() {\n    var c = this._parentSubscriber;\n    this._context = null, this._parentSubscriber = null, c.unsubscribe();\n  }, u;\n}(Subscriber);\nfunction canReportError(a) {\n  for (; a; ) {\n    var u = a, c = u.closed, l = u.destination, v = u.isStopped;\n    if (c || v)\n      return !1;\n    l && l instanceof Subscriber ? a = l : a = null;\n  }\n  return !0;\n}\nfunction toSubscriber(a, u, c) {\n  if (a) {\n    if (a instanceof Subscriber)\n      return a;\n    if (a[rxSubscriber])\n      return a[rxSubscriber]();\n  }\n  return !a && !u && !c ? new Subscriber(empty$2) : new Subscriber(a, u, c);\n}\nvar observable = /* @__PURE__ */ function() {\n  return typeof Symbol == \"function\" && Symbol.observable || \"@@observable\";\n}();\nfunction identity(a) {\n  return a;\n}\nfunction pipe() {\n  for (var a = [], u = 0; u < arguments.length; u++)\n    a[u] = arguments[u];\n  return pipeFromArray(a);\n}\nfunction pipeFromArray(a) {\n  return a.length === 0 ? identity : a.length === 1 ? a[0] : function(c) {\n    return a.reduce(function(l, v) {\n      return v(l);\n    }, c);\n  };\n}\nvar Observable = /* @__PURE__ */ function() {\n  function a(u) {\n    this._isScalar = !1, u && (this._subscribe = u);\n  }\n  return a.prototype.lift = function(u) {\n    var c = new a();\n    return c.source = this, c.operator = u, c;\n  }, a.prototype.subscribe = function(u, c, l) {\n    var v = this.operator, S = toSubscriber(u, c, l);\n    if (v ? S.add(v.call(S, this.source)) : S.add(this.source || config$2.useDeprecatedSynchronousErrorHandling && !S.syncErrorThrowable ? this._subscribe(S) : this._trySubscribe(S)), config$2.useDeprecatedSynchronousErrorHandling && S.syncErrorThrowable && (S.syncErrorThrowable = !1, S.syncErrorThrown))\n      throw S.syncErrorValue;\n    return S;\n  }, a.prototype._trySubscribe = function(u) {\n    try {\n      return this._subscribe(u);\n    } catch (c) {\n      config$2.useDeprecatedSynchronousErrorHandling && (u.syncErrorThrown = !0, u.syncErrorValue = c), canReportError(u) ? u.error(c) : console.warn(c);\n    }\n  }, a.prototype.forEach = function(u, c) {\n    var l = this;\n    return c = getPromiseCtor(c), new c(function(v, S) {\n      var g;\n      g = l.subscribe(function(E) {\n        try {\n          u(E);\n        } catch (_) {\n          S(_), g && g.unsubscribe();\n        }\n      }, S, v);\n    });\n  }, a.prototype._subscribe = function(u) {\n    var c = this.source;\n    return c && c.subscribe(u);\n  }, a.prototype[observable] = function() {\n    return this;\n  }, a.prototype.pipe = function() {\n    for (var u = [], c = 0; c < arguments.length; c++)\n      u[c] = arguments[c];\n    return u.length === 0 ? this : pipeFromArray(u)(this);\n  }, a.prototype.toPromise = function(u) {\n    var c = this;\n    return u = getPromiseCtor(u), new u(function(l, v) {\n      var S;\n      c.subscribe(function(g) {\n        return S = g;\n      }, function(g) {\n        return v(g);\n      }, function() {\n        return l(S);\n      });\n    });\n  }, a.create = function(u) {\n    return new a(u);\n  }, a;\n}();\nfunction getPromiseCtor(a) {\n  if (a || (a = Promise), !a)\n    throw new Error(\"no Promise impl found\");\n  return a;\n}\nvar subscribeToArray = function(a) {\n  return function(u) {\n    for (var c = 0, l = a.length; c < l && !u.closed; c++)\n      u.next(a[c]);\n    u.complete();\n  };\n}, subscribeToPromise = function(a) {\n  return function(u) {\n    return a.then(function(c) {\n      u.closed || (u.next(c), u.complete());\n    }, function(c) {\n      return u.error(c);\n    }).then(null, hostReportError), u;\n  };\n};\nfunction getSymbolIterator() {\n  return typeof Symbol != \"function\" || !Symbol.iterator ? \"@@iterator\" : Symbol.iterator;\n}\nvar iterator = /* @__PURE__ */ getSymbolIterator(), subscribeToIterable = function(a) {\n  return function(u) {\n    var c = a[iterator]();\n    do {\n      var l = void 0;\n      try {\n        l = c.next();\n      } catch (v) {\n        return u.error(v), u;\n      }\n      if (l.done) {\n        u.complete();\n        break;\n      }\n      if (u.next(l.value), u.closed)\n        break;\n    } while (!0);\n    return typeof c.return == \"function\" && u.add(function() {\n      c.return && c.return();\n    }), u;\n  };\n}, subscribeToObservable = function(a) {\n  return function(u) {\n    var c = a[observable]();\n    if (typeof c.subscribe != \"function\")\n      throw new TypeError(\"Provided object does not correctly implement Symbol.observable\");\n    return c.subscribe(u);\n  };\n}, isArrayLike$1 = function(a) {\n  return a && typeof a.length == \"number\" && typeof a != \"function\";\n};\nfunction isPromise(a) {\n  return !!a && typeof a.subscribe != \"function\" && typeof a.then == \"function\";\n}\nvar subscribeTo = function(a) {\n  if (a && typeof a[observable] == \"function\")\n    return subscribeToObservable(a);\n  if (isArrayLike$1(a))\n    return subscribeToArray(a);\n  if (isPromise(a))\n    return subscribeToPromise(a);\n  if (a && typeof a[iterator] == \"function\")\n    return subscribeToIterable(a);\n  var u = isObject$8(a) ? \"an invalid object\" : \"'\" + a + \"'\", c = \"You provided \" + u + \" where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.\";\n  throw new TypeError(c);\n}, SimpleInnerSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c) {\n    var l = a.call(this) || this;\n    return l.parent = c, l;\n  }\n  return u.prototype._next = function(c) {\n    this.parent.notifyNext(c);\n  }, u.prototype._error = function(c) {\n    this.parent.notifyError(c), this.unsubscribe();\n  }, u.prototype._complete = function() {\n    this.parent.notifyComplete(), this.unsubscribe();\n  }, u;\n}(Subscriber), SimpleOuterSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u() {\n    return a !== null && a.apply(this, arguments) || this;\n  }\n  return u.prototype.notifyNext = function(c) {\n    this.destination.next(c);\n  }, u.prototype.notifyError = function(c) {\n    this.destination.error(c);\n  }, u.prototype.notifyComplete = function() {\n    this.destination.complete();\n  }, u;\n}(Subscriber);\nfunction innerSubscribe(a, u) {\n  if (!u.closed) {\n    if (a instanceof Observable)\n      return a.subscribe(u);\n    var c;\n    try {\n      c = subscribeTo(a)(u);\n    } catch (l) {\n      u.error(l);\n    }\n    return c;\n  }\n}\nfunction audit(a) {\n  return function(c) {\n    return c.lift(new AuditOperator(a));\n  };\n}\nvar AuditOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.durationSelector = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new AuditSubscriber(u, this.durationSelector));\n  }, a;\n}(), AuditSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.durationSelector = l, v.hasValue = !1, v;\n  }\n  return u.prototype._next = function(c) {\n    if (this.value = c, this.hasValue = !0, !this.throttled) {\n      var l = void 0;\n      try {\n        var v = this.durationSelector;\n        l = v(c);\n      } catch (g) {\n        return this.destination.error(g);\n      }\n      var S = innerSubscribe(l, new SimpleInnerSubscriber(this));\n      !S || S.closed ? this.clearThrottle() : this.add(this.throttled = S);\n    }\n  }, u.prototype.clearThrottle = function() {\n    var c = this, l = c.value, v = c.hasValue, S = c.throttled;\n    S && (this.remove(S), this.throttled = void 0, S.unsubscribe()), v && (this.value = void 0, this.hasValue = !1, this.destination.next(l));\n  }, u.prototype.notifyNext = function() {\n    this.clearThrottle();\n  }, u.prototype.notifyComplete = function() {\n    this.clearThrottle();\n  }, u;\n}(SimpleOuterSubscriber), Action = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    return a.call(this) || this;\n  }\n  return u.prototype.schedule = function(c, l) {\n    return this;\n  }, u;\n}(Subscription), AsyncAction = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c, l) || this;\n    return v.scheduler = c, v.work = l, v.pending = !1, v;\n  }\n  return u.prototype.schedule = function(c, l) {\n    if (l === void 0 && (l = 0), this.closed)\n      return this;\n    this.state = c;\n    var v = this.id, S = this.scheduler;\n    return v != null && (this.id = this.recycleAsyncId(S, v, l)), this.pending = !0, this.delay = l, this.id = this.id || this.requestAsyncId(S, this.id, l), this;\n  }, u.prototype.requestAsyncId = function(c, l, v) {\n    return v === void 0 && (v = 0), setInterval(c.flush.bind(c, this), v);\n  }, u.prototype.recycleAsyncId = function(c, l, v) {\n    if (v === void 0 && (v = 0), v !== null && this.delay === v && this.pending === !1)\n      return l;\n    clearInterval(l);\n  }, u.prototype.execute = function(c, l) {\n    if (this.closed)\n      return new Error(\"executing a cancelled action\");\n    this.pending = !1;\n    var v = this._execute(c, l);\n    if (v)\n      return v;\n    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));\n  }, u.prototype._execute = function(c, l) {\n    var v = !1, S = void 0;\n    try {\n      this.work(c);\n    } catch (g) {\n      v = !0, S = !!g && g || new Error(g);\n    }\n    if (v)\n      return this.unsubscribe(), S;\n  }, u.prototype._unsubscribe = function() {\n    var c = this.id, l = this.scheduler, v = l.actions, S = v.indexOf(this);\n    this.work = null, this.state = null, this.pending = !1, this.scheduler = null, S !== -1 && v.splice(S, 1), c != null && (this.id = this.recycleAsyncId(l, c, null)), this.delay = null;\n  }, u;\n}(Action), Scheduler = /* @__PURE__ */ function() {\n  function a(u, c) {\n    c === void 0 && (c = a.now), this.SchedulerAction = u, this.now = c;\n  }\n  return a.prototype.schedule = function(u, c, l) {\n    return c === void 0 && (c = 0), new this.SchedulerAction(this, u).schedule(l, c);\n  }, a.now = function() {\n    return Date.now();\n  }, a;\n}(), AsyncScheduler = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    l === void 0 && (l = Scheduler.now);\n    var v = a.call(this, c, function() {\n      return u.delegate && u.delegate !== v ? u.delegate.now() : l();\n    }) || this;\n    return v.actions = [], v.active = !1, v.scheduled = void 0, v;\n  }\n  return u.prototype.schedule = function(c, l, v) {\n    return l === void 0 && (l = 0), u.delegate && u.delegate !== this ? u.delegate.schedule(c, l, v) : a.prototype.schedule.call(this, c, l, v);\n  }, u.prototype.flush = function(c) {\n    var l = this.actions;\n    if (this.active) {\n      l.push(c);\n      return;\n    }\n    var v;\n    this.active = !0;\n    do\n      if (v = c.execute(c.state, c.delay))\n        break;\n    while (c = l.shift());\n    if (this.active = !1, v) {\n      for (; c = l.shift(); )\n        c.unsubscribe();\n      throw v;\n    }\n  }, u;\n}(Scheduler), asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction), async = asyncScheduler;\nfunction isNumeric(a) {\n  return !isArray$4(a) && a - parseFloat(a) + 1 >= 0;\n}\nfunction isScheduler(a) {\n  return a && typeof a.schedule == \"function\";\n}\nfunction timer(a, u, c) {\n  a === void 0 && (a = 0);\n  var l = -1;\n  return isNumeric(u) ? l = Number(u) < 1 && 1 || Number(u) : isScheduler(u) && (c = u), isScheduler(c) || (c = async), new Observable(function(v) {\n    var S = isNumeric(a) ? a : +a - c.now();\n    return c.schedule(dispatch$1, S, {\n      index: 0,\n      period: l,\n      subscriber: v\n    });\n  });\n}\nfunction dispatch$1(a) {\n  var u = a.index, c = a.period, l = a.subscriber;\n  if (l.next(u), !l.closed) {\n    if (c === -1)\n      return l.complete();\n    a.index = u + 1, this.schedule(a, c);\n  }\n}\nfunction auditTime(a, u) {\n  return u === void 0 && (u = async), audit(function() {\n    return timer(a, u);\n  });\n}\nfunction buffer(a) {\n  return function(c) {\n    return c.lift(new BufferOperator(a));\n  };\n}\nvar BufferOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.closingNotifier = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new BufferSubscriber(u, this.closingNotifier));\n  }, a;\n}(), BufferSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.buffer = [], v.add(innerSubscribe(l, new SimpleInnerSubscriber(v))), v;\n  }\n  return u.prototype._next = function(c) {\n    this.buffer.push(c);\n  }, u.prototype.notifyNext = function() {\n    var c = this.buffer;\n    this.buffer = [], this.destination.next(c);\n  }, u;\n}(SimpleOuterSubscriber);\nfunction bufferCount(a, u) {\n  return u === void 0 && (u = null), function(l) {\n    return l.lift(new BufferCountOperator(a, u));\n  };\n}\nvar BufferCountOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.bufferSize = u, this.startBufferEvery = c, !c || u === c ? this.subscriberClass = BufferCountSubscriber : this.subscriberClass = BufferSkipCountSubscriber;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new this.subscriberClass(u, this.bufferSize, this.startBufferEvery));\n  }, a;\n}(), BufferCountSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.bufferSize = l, v.buffer = [], v;\n  }\n  return u.prototype._next = function(c) {\n    var l = this.buffer;\n    l.push(c), l.length == this.bufferSize && (this.destination.next(l), this.buffer = []);\n  }, u.prototype._complete = function() {\n    var c = this.buffer;\n    c.length > 0 && this.destination.next(c), a.prototype._complete.call(this);\n  }, u;\n}(Subscriber), BufferSkipCountSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.bufferSize = l, S.startBufferEvery = v, S.buffers = [], S.count = 0, S;\n  }\n  return u.prototype._next = function(c) {\n    var l = this, v = l.bufferSize, S = l.startBufferEvery, g = l.buffers, E = l.count;\n    this.count++, E % S === 0 && g.push([]);\n    for (var _ = g.length; _--; ) {\n      var k = g[_];\n      k.push(c), k.length === v && (g.splice(_, 1), this.destination.next(k));\n    }\n  }, u.prototype._complete = function() {\n    for (var c = this, l = c.buffers, v = c.destination; l.length > 0; ) {\n      var S = l.shift();\n      S.length > 0 && v.next(S);\n    }\n    a.prototype._complete.call(this);\n  }, u;\n}(Subscriber);\nfunction bufferTime(a) {\n  var u = arguments.length, c = async;\n  isScheduler(arguments[arguments.length - 1]) && (c = arguments[arguments.length - 1], u--);\n  var l = null;\n  u >= 2 && (l = arguments[1]);\n  var v = Number.POSITIVE_INFINITY;\n  return u >= 3 && (v = arguments[2]), function(g) {\n    return g.lift(new BufferTimeOperator(a, l, v, c));\n  };\n}\nvar BufferTimeOperator = /* @__PURE__ */ function() {\n  function a(u, c, l, v) {\n    this.bufferTimeSpan = u, this.bufferCreationInterval = c, this.maxBufferSize = l, this.scheduler = v;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new BufferTimeSubscriber(u, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n  }, a;\n}(), Context = /* @__PURE__ */ function() {\n  function a() {\n    this.buffer = [];\n  }\n  return a;\n}(), BufferTimeSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v, S, g) {\n    var E = a.call(this, c) || this;\n    E.bufferTimeSpan = l, E.bufferCreationInterval = v, E.maxBufferSize = S, E.scheduler = g, E.contexts = [];\n    var _ = E.openContext();\n    if (E.timespanOnly = v == null || v < 0, E.timespanOnly) {\n      var k = { subscriber: E, context: _, bufferTimeSpan: l };\n      E.add(_.closeAction = g.schedule(dispatchBufferTimeSpanOnly, l, k));\n    } else {\n      var L = { subscriber: E, context: _ }, M = { bufferTimeSpan: l, bufferCreationInterval: v, subscriber: E, scheduler: g };\n      E.add(_.closeAction = g.schedule(dispatchBufferClose, l, L)), E.add(g.schedule(dispatchBufferCreation, v, M));\n    }\n    return E;\n  }\n  return u.prototype._next = function(c) {\n    for (var l = this.contexts, v = l.length, S, g = 0; g < v; g++) {\n      var E = l[g], _ = E.buffer;\n      _.push(c), _.length == this.maxBufferSize && (S = E);\n    }\n    S && this.onBufferFull(S);\n  }, u.prototype._error = function(c) {\n    this.contexts.length = 0, a.prototype._error.call(this, c);\n  }, u.prototype._complete = function() {\n    for (var c = this, l = c.contexts, v = c.destination; l.length > 0; ) {\n      var S = l.shift();\n      v.next(S.buffer);\n    }\n    a.prototype._complete.call(this);\n  }, u.prototype._unsubscribe = function() {\n    this.contexts = null;\n  }, u.prototype.onBufferFull = function(c) {\n    this.closeContext(c);\n    var l = c.closeAction;\n    if (l.unsubscribe(), this.remove(l), !this.closed && this.timespanOnly) {\n      c = this.openContext();\n      var v = this.bufferTimeSpan, S = { subscriber: this, context: c, bufferTimeSpan: v };\n      this.add(c.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, v, S));\n    }\n  }, u.prototype.openContext = function() {\n    var c = new Context();\n    return this.contexts.push(c), c;\n  }, u.prototype.closeContext = function(c) {\n    this.destination.next(c.buffer);\n    var l = this.contexts, v = l ? l.indexOf(c) : -1;\n    v >= 0 && l.splice(l.indexOf(c), 1);\n  }, u;\n}(Subscriber);\nfunction dispatchBufferTimeSpanOnly(a) {\n  var u = a.subscriber, c = a.context;\n  c && u.closeContext(c), u.closed || (a.context = u.openContext(), a.context.closeAction = this.schedule(a, a.bufferTimeSpan));\n}\nfunction dispatchBufferCreation(a) {\n  var u = a.bufferCreationInterval, c = a.bufferTimeSpan, l = a.subscriber, v = a.scheduler, S = l.openContext(), g = this;\n  l.closed || (l.add(S.closeAction = v.schedule(dispatchBufferClose, c, { subscriber: l, context: S })), g.schedule(a, u));\n}\nfunction dispatchBufferClose(a) {\n  var u = a.subscriber, c = a.context;\n  u.closeContext(c);\n}\nvar InnerSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this) || this;\n    return S.parent = c, S.outerValue = l, S.outerIndex = v, S.index = 0, S;\n  }\n  return u.prototype._next = function(c) {\n    this.parent.notifyNext(this.outerValue, c, this.outerIndex, this.index++, this);\n  }, u.prototype._error = function(c) {\n    this.parent.notifyError(c, this), this.unsubscribe();\n  }, u.prototype._complete = function() {\n    this.parent.notifyComplete(this), this.unsubscribe();\n  }, u;\n}(Subscriber);\nfunction subscribeToResult(a, u, c, l, v) {\n  if (v === void 0 && (v = new InnerSubscriber(a, c, l)), !v.closed)\n    return u instanceof Observable ? u.subscribe(v) : subscribeTo(u)(v);\n}\nvar OuterSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u() {\n    return a !== null && a.apply(this, arguments) || this;\n  }\n  return u.prototype.notifyNext = function(c, l, v, S, g) {\n    this.destination.next(l);\n  }, u.prototype.notifyError = function(c, l) {\n    this.destination.error(c);\n  }, u.prototype.notifyComplete = function(c) {\n    this.destination.complete();\n  }, u;\n}(Subscriber);\nfunction bufferToggle(a, u) {\n  return function(l) {\n    return l.lift(new BufferToggleOperator(a, u));\n  };\n}\nvar BufferToggleOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.openings = u, this.closingSelector = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new BufferToggleSubscriber(u, this.openings, this.closingSelector));\n  }, a;\n}(), BufferToggleSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.closingSelector = v, S.contexts = [], S.add(subscribeToResult(S, l)), S;\n  }\n  return u.prototype._next = function(c) {\n    for (var l = this.contexts, v = l.length, S = 0; S < v; S++)\n      l[S].buffer.push(c);\n  }, u.prototype._error = function(c) {\n    for (var l = this.contexts; l.length > 0; ) {\n      var v = l.shift();\n      v.subscription.unsubscribe(), v.buffer = null, v.subscription = null;\n    }\n    this.contexts = null, a.prototype._error.call(this, c);\n  }, u.prototype._complete = function() {\n    for (var c = this.contexts; c.length > 0; ) {\n      var l = c.shift();\n      this.destination.next(l.buffer), l.subscription.unsubscribe(), l.buffer = null, l.subscription = null;\n    }\n    this.contexts = null, a.prototype._complete.call(this);\n  }, u.prototype.notifyNext = function(c, l) {\n    c ? this.closeBuffer(c) : this.openBuffer(l);\n  }, u.prototype.notifyComplete = function(c) {\n    this.closeBuffer(c.context);\n  }, u.prototype.openBuffer = function(c) {\n    try {\n      var l = this.closingSelector, v = l.call(this, c);\n      v && this.trySubscribe(v);\n    } catch (S) {\n      this._error(S);\n    }\n  }, u.prototype.closeBuffer = function(c) {\n    var l = this.contexts;\n    if (l && c) {\n      var v = c.buffer, S = c.subscription;\n      this.destination.next(v), l.splice(l.indexOf(c), 1), this.remove(S), S.unsubscribe();\n    }\n  }, u.prototype.trySubscribe = function(c) {\n    var l = this.contexts, v = [], S = new Subscription(), g = { buffer: v, subscription: S };\n    l.push(g);\n    var E = subscribeToResult(this, c, g);\n    !E || E.closed ? this.closeBuffer(g) : (E.context = g, this.add(E), S.add(E));\n  }, u;\n}(OuterSubscriber);\nfunction bufferWhen(a) {\n  return function(u) {\n    return u.lift(new BufferWhenOperator(a));\n  };\n}\nvar BufferWhenOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.closingSelector = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new BufferWhenSubscriber(u, this.closingSelector));\n  }, a;\n}(), BufferWhenSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.closingSelector = l, v.subscribing = !1, v.openBuffer(), v;\n  }\n  return u.prototype._next = function(c) {\n    this.buffer.push(c);\n  }, u.prototype._complete = function() {\n    var c = this.buffer;\n    c && this.destination.next(c), a.prototype._complete.call(this);\n  }, u.prototype._unsubscribe = function() {\n    this.buffer = void 0, this.subscribing = !1;\n  }, u.prototype.notifyNext = function() {\n    this.openBuffer();\n  }, u.prototype.notifyComplete = function() {\n    this.subscribing ? this.complete() : this.openBuffer();\n  }, u.prototype.openBuffer = function() {\n    var c = this.closingSubscription;\n    c && (this.remove(c), c.unsubscribe());\n    var l = this.buffer;\n    this.buffer && this.destination.next(l), this.buffer = [];\n    var v;\n    try {\n      var S = this.closingSelector;\n      v = S();\n    } catch (g) {\n      return this.error(g);\n    }\n    c = new Subscription(), this.closingSubscription = c, this.add(c), this.subscribing = !0, c.add(innerSubscribe(v, new SimpleInnerSubscriber(this))), this.subscribing = !1;\n  }, u;\n}(SimpleOuterSubscriber);\nfunction catchError(a) {\n  return function(c) {\n    var l = new CatchOperator(a), v = c.lift(l);\n    return l.caught = v;\n  };\n}\nvar CatchOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.selector = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new CatchSubscriber(u, this.selector, this.caught));\n  }, a;\n}(), CatchSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.selector = l, S.caught = v, S;\n  }\n  return u.prototype.error = function(c) {\n    if (!this.isStopped) {\n      var l = void 0;\n      try {\n        l = this.selector(c, this.caught);\n      } catch (g) {\n        a.prototype.error.call(this, g);\n        return;\n      }\n      this._unsubscribeAndRecycle();\n      var v = new SimpleInnerSubscriber(this);\n      this.add(v);\n      var S = innerSubscribe(l, v);\n      S !== v && this.add(S);\n    }\n  }, u;\n}(SimpleOuterSubscriber);\nfunction scheduleArray(a, u) {\n  return new Observable(function(c) {\n    var l = new Subscription(), v = 0;\n    return l.add(u.schedule(function() {\n      if (v === a.length) {\n        c.complete();\n        return;\n      }\n      c.next(a[v++]), c.closed || l.add(this.schedule());\n    })), l;\n  });\n}\nfunction fromArray(a, u) {\n  return u ? scheduleArray(a, u) : new Observable(subscribeToArray(a));\n}\nvar NONE = {}, CombineLatestOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.resultSelector = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new CombineLatestSubscriber(u, this.resultSelector));\n  }, a;\n}(), CombineLatestSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.resultSelector = l, v.active = 0, v.values = [], v.observables = [], v;\n  }\n  return u.prototype._next = function(c) {\n    this.values.push(NONE), this.observables.push(c);\n  }, u.prototype._complete = function() {\n    var c = this.observables, l = c.length;\n    if (l === 0)\n      this.destination.complete();\n    else {\n      this.active = l, this.toRespond = l;\n      for (var v = 0; v < l; v++) {\n        var S = c[v];\n        this.add(subscribeToResult(this, S, void 0, v));\n      }\n    }\n  }, u.prototype.notifyComplete = function(c) {\n    (this.active -= 1) === 0 && this.destination.complete();\n  }, u.prototype.notifyNext = function(c, l, v) {\n    var S = this.values, g = S[v], E = this.toRespond ? g === NONE ? --this.toRespond : this.toRespond : 0;\n    S[v] = l, E === 0 && (this.resultSelector ? this._tryResultSelector(S) : this.destination.next(S.slice()));\n  }, u.prototype._tryResultSelector = function(c) {\n    var l;\n    try {\n      l = this.resultSelector.apply(this, c);\n    } catch (v) {\n      this.destination.error(v);\n      return;\n    }\n    this.destination.next(l);\n  }, u;\n}(OuterSubscriber);\nfunction combineAll(a) {\n  return function(u) {\n    return u.lift(new CombineLatestOperator(a));\n  };\n}\nfunction scheduleObservable(a, u) {\n  return new Observable(function(c) {\n    var l = new Subscription();\n    return l.add(u.schedule(function() {\n      var v = a[observable]();\n      l.add(v.subscribe({\n        next: function(S) {\n          l.add(u.schedule(function() {\n            return c.next(S);\n          }));\n        },\n        error: function(S) {\n          l.add(u.schedule(function() {\n            return c.error(S);\n          }));\n        },\n        complete: function() {\n          l.add(u.schedule(function() {\n            return c.complete();\n          }));\n        }\n      }));\n    })), l;\n  });\n}\nfunction schedulePromise(a, u) {\n  return new Observable(function(c) {\n    var l = new Subscription();\n    return l.add(u.schedule(function() {\n      return a.then(function(v) {\n        l.add(u.schedule(function() {\n          c.next(v), l.add(u.schedule(function() {\n            return c.complete();\n          }));\n        }));\n      }, function(v) {\n        l.add(u.schedule(function() {\n          return c.error(v);\n        }));\n      });\n    })), l;\n  });\n}\nfunction scheduleIterable(a, u) {\n  if (!a)\n    throw new Error(\"Iterable cannot be null\");\n  return new Observable(function(c) {\n    var l = new Subscription(), v;\n    return l.add(function() {\n      v && typeof v.return == \"function\" && v.return();\n    }), l.add(u.schedule(function() {\n      v = a[iterator](), l.add(u.schedule(function() {\n        if (!c.closed) {\n          var S, g;\n          try {\n            var E = v.next();\n            S = E.value, g = E.done;\n          } catch (_) {\n            c.error(_);\n            return;\n          }\n          g ? c.complete() : (c.next(S), this.schedule());\n        }\n      }));\n    })), l;\n  });\n}\nfunction isInteropObservable(a) {\n  return a && typeof a[observable] == \"function\";\n}\nfunction isIterable(a) {\n  return a && typeof a[iterator] == \"function\";\n}\nfunction scheduled(a, u) {\n  if (a != null) {\n    if (isInteropObservable(a))\n      return scheduleObservable(a, u);\n    if (isPromise(a))\n      return schedulePromise(a, u);\n    if (isArrayLike$1(a))\n      return scheduleArray(a, u);\n    if (isIterable(a) || typeof a == \"string\")\n      return scheduleIterable(a, u);\n  }\n  throw new TypeError((a !== null && typeof a || a) + \" is not observable\");\n}\nfunction from(a, u) {\n  return u ? scheduled(a, u) : a instanceof Observable ? a : new Observable(subscribeTo(a));\n}\nfunction combineLatest() {\n  for (var a = [], u = 0; u < arguments.length; u++)\n    a[u] = arguments[u];\n  var c = null;\n  return typeof a[a.length - 1] == \"function\" && (c = a.pop()), a.length === 1 && isArray$4(a[0]) && (a = a[0].slice()), function(l) {\n    return l.lift.call(from([l].concat(a)), new CombineLatestOperator(c));\n  };\n}\nfunction of$1() {\n  for (var a = [], u = 0; u < arguments.length; u++)\n    a[u] = arguments[u];\n  var c = a[a.length - 1];\n  return isScheduler(c) ? (a.pop(), scheduleArray(a, c)) : fromArray(a);\n}\nfunction map(a, u) {\n  return function(l) {\n    if (typeof a != \"function\")\n      throw new TypeError(\"argument is not a function. Are you looking for `mapTo()`?\");\n    return l.lift(new MapOperator(a, u));\n  };\n}\nvar MapOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.project = u, this.thisArg = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new MapSubscriber(u, this.project, this.thisArg));\n  }, a;\n}(), MapSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.project = l, S.count = 0, S.thisArg = v || S, S;\n  }\n  return u.prototype._next = function(c) {\n    var l;\n    try {\n      l = this.project.call(this.thisArg, c, this.count++);\n    } catch (v) {\n      this.destination.error(v);\n      return;\n    }\n    this.destination.next(l);\n  }, u;\n}(Subscriber);\nfunction mergeMap(a, u, c) {\n  return c === void 0 && (c = Number.POSITIVE_INFINITY), typeof u == \"function\" ? function(l) {\n    return l.pipe(mergeMap(function(v, S) {\n      return from(a(v, S)).pipe(map(function(g, E) {\n        return u(v, g, S, E);\n      }));\n    }, c));\n  } : (typeof u == \"number\" && (c = u), function(l) {\n    return l.lift(new MergeMapOperator(a, c));\n  });\n}\nvar MergeMapOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    c === void 0 && (c = Number.POSITIVE_INFINITY), this.project = u, this.concurrent = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new MergeMapSubscriber(u, this.project, this.concurrent));\n  }, a;\n}(), MergeMapSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    v === void 0 && (v = Number.POSITIVE_INFINITY);\n    var S = a.call(this, c) || this;\n    return S.project = l, S.concurrent = v, S.hasCompleted = !1, S.buffer = [], S.active = 0, S.index = 0, S;\n  }\n  return u.prototype._next = function(c) {\n    this.active < this.concurrent ? this._tryNext(c) : this.buffer.push(c);\n  }, u.prototype._tryNext = function(c) {\n    var l, v = this.index++;\n    try {\n      l = this.project(c, v);\n    } catch (S) {\n      this.destination.error(S);\n      return;\n    }\n    this.active++, this._innerSub(l);\n  }, u.prototype._innerSub = function(c) {\n    var l = new SimpleInnerSubscriber(this), v = this.destination;\n    v.add(l);\n    var S = innerSubscribe(c, l);\n    S !== l && v.add(S);\n  }, u.prototype._complete = function() {\n    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && this.destination.complete(), this.unsubscribe();\n  }, u.prototype.notifyNext = function(c) {\n    this.destination.next(c);\n  }, u.prototype.notifyComplete = function() {\n    var c = this.buffer;\n    this.active--, c.length > 0 ? this._next(c.shift()) : this.active === 0 && this.hasCompleted && this.destination.complete();\n  }, u;\n}(SimpleOuterSubscriber), flatMap = mergeMap;\nfunction mergeAll(a) {\n  return a === void 0 && (a = Number.POSITIVE_INFINITY), mergeMap(identity, a);\n}\nfunction concatAll() {\n  return mergeAll(1);\n}\nfunction concat$1() {\n  for (var a = [], u = 0; u < arguments.length; u++)\n    a[u] = arguments[u];\n  return concatAll()(of$1.apply(void 0, a));\n}\nfunction concat() {\n  for (var a = [], u = 0; u < arguments.length; u++)\n    a[u] = arguments[u];\n  return function(c) {\n    return c.lift.call(concat$1.apply(void 0, [c].concat(a)));\n  };\n}\nfunction concatMap(a, u) {\n  return mergeMap(a, u, 1);\n}\nfunction concatMapTo(a, u) {\n  return concatMap(function() {\n    return a;\n  }, u);\n}\nfunction count(a) {\n  return function(u) {\n    return u.lift(new CountOperator(a, u));\n  };\n}\nvar CountOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.predicate = u, this.source = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new CountSubscriber(u, this.predicate, this.source));\n  }, a;\n}(), CountSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.predicate = l, S.source = v, S.count = 0, S.index = 0, S;\n  }\n  return u.prototype._next = function(c) {\n    this.predicate ? this._tryPredicate(c) : this.count++;\n  }, u.prototype._tryPredicate = function(c) {\n    var l;\n    try {\n      l = this.predicate(c, this.index++, this.source);\n    } catch (v) {\n      this.destination.error(v);\n      return;\n    }\n    l && this.count++;\n  }, u.prototype._complete = function() {\n    this.destination.next(this.count), this.destination.complete();\n  }, u;\n}(Subscriber);\nfunction debounce(a) {\n  return function(u) {\n    return u.lift(new DebounceOperator(a));\n  };\n}\nvar DebounceOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.durationSelector = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new DebounceSubscriber(u, this.durationSelector));\n  }, a;\n}(), DebounceSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.durationSelector = l, v.hasValue = !1, v;\n  }\n  return u.prototype._next = function(c) {\n    try {\n      var l = this.durationSelector.call(this, c);\n      l && this._tryNext(c, l);\n    } catch (v) {\n      this.destination.error(v);\n    }\n  }, u.prototype._complete = function() {\n    this.emitValue(), this.destination.complete();\n  }, u.prototype._tryNext = function(c, l) {\n    var v = this.durationSubscription;\n    this.value = c, this.hasValue = !0, v && (v.unsubscribe(), this.remove(v)), v = innerSubscribe(l, new SimpleInnerSubscriber(this)), v && !v.closed && this.add(this.durationSubscription = v);\n  }, u.prototype.notifyNext = function() {\n    this.emitValue();\n  }, u.prototype.notifyComplete = function() {\n    this.emitValue();\n  }, u.prototype.emitValue = function() {\n    if (this.hasValue) {\n      var c = this.value, l = this.durationSubscription;\n      l && (this.durationSubscription = void 0, l.unsubscribe(), this.remove(l)), this.value = void 0, this.hasValue = !1, a.prototype._next.call(this, c);\n    }\n  }, u;\n}(SimpleOuterSubscriber);\nfunction debounceTime(a, u) {\n  return u === void 0 && (u = async), function(c) {\n    return c.lift(new DebounceTimeOperator(a, u));\n  };\n}\nvar DebounceTimeOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.dueTime = u, this.scheduler = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new DebounceTimeSubscriber(u, this.dueTime, this.scheduler));\n  }, a;\n}(), DebounceTimeSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.dueTime = l, S.scheduler = v, S.debouncedSubscription = null, S.lastValue = null, S.hasValue = !1, S;\n  }\n  return u.prototype._next = function(c) {\n    this.clearDebounce(), this.lastValue = c, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));\n  }, u.prototype._complete = function() {\n    this.debouncedNext(), this.destination.complete();\n  }, u.prototype.debouncedNext = function() {\n    if (this.clearDebounce(), this.hasValue) {\n      var c = this.lastValue;\n      this.lastValue = null, this.hasValue = !1, this.destination.next(c);\n    }\n  }, u.prototype.clearDebounce = function() {\n    var c = this.debouncedSubscription;\n    c !== null && (this.remove(c), c.unsubscribe(), this.debouncedSubscription = null);\n  }, u;\n}(Subscriber);\nfunction dispatchNext$1(a) {\n  a.debouncedNext();\n}\nfunction defaultIfEmpty(a) {\n  return a === void 0 && (a = null), function(u) {\n    return u.lift(new DefaultIfEmptyOperator(a));\n  };\n}\nvar DefaultIfEmptyOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.defaultValue = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new DefaultIfEmptySubscriber(u, this.defaultValue));\n  }, a;\n}(), DefaultIfEmptySubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.defaultValue = l, v.isEmpty = !0, v;\n  }\n  return u.prototype._next = function(c) {\n    this.isEmpty = !1, this.destination.next(c);\n  }, u.prototype._complete = function() {\n    this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete();\n  }, u;\n}(Subscriber);\nfunction isDate$1(a) {\n  return a instanceof Date && !isNaN(+a);\n}\nvar EMPTY = /* @__PURE__ */ new Observable(function(a) {\n  return a.complete();\n});\nfunction empty$1(a) {\n  return a ? emptyScheduled(a) : EMPTY;\n}\nfunction emptyScheduled(a) {\n  return new Observable(function(u) {\n    return a.schedule(function() {\n      return u.complete();\n    });\n  });\n}\nfunction throwError(a, u) {\n  return u ? new Observable(function(c) {\n    return u.schedule(dispatch, 0, { error: a, subscriber: c });\n  }) : new Observable(function(c) {\n    return c.error(a);\n  });\n}\nfunction dispatch(a) {\n  var u = a.error, c = a.subscriber;\n  c.error(u);\n}\nvar Notification = /* @__PURE__ */ function() {\n  function a(u, c, l) {\n    this.kind = u, this.value = c, this.error = l, this.hasValue = u === \"N\";\n  }\n  return a.prototype.observe = function(u) {\n    switch (this.kind) {\n      case \"N\":\n        return u.next && u.next(this.value);\n      case \"E\":\n        return u.error && u.error(this.error);\n      case \"C\":\n        return u.complete && u.complete();\n    }\n  }, a.prototype.do = function(u, c, l) {\n    var v = this.kind;\n    switch (v) {\n      case \"N\":\n        return u && u(this.value);\n      case \"E\":\n        return c && c(this.error);\n      case \"C\":\n        return l && l();\n    }\n  }, a.prototype.accept = function(u, c, l) {\n    return u && typeof u.next == \"function\" ? this.observe(u) : this.do(u, c, l);\n  }, a.prototype.toObservable = function() {\n    var u = this.kind;\n    switch (u) {\n      case \"N\":\n        return of$1(this.value);\n      case \"E\":\n        return throwError(this.error);\n      case \"C\":\n        return empty$1();\n    }\n    throw new Error(\"unexpected notification kind value\");\n  }, a.createNext = function(u) {\n    return typeof u < \"u\" ? new a(\"N\", u) : a.undefinedValueNotification;\n  }, a.createError = function(u) {\n    return new a(\"E\", void 0, u);\n  }, a.createComplete = function() {\n    return a.completeNotification;\n  }, a.completeNotification = new a(\"C\"), a.undefinedValueNotification = new a(\"N\", void 0), a;\n}();\nfunction delay(a, u) {\n  u === void 0 && (u = async);\n  var c = isDate$1(a), l = c ? +a - u.now() : Math.abs(a);\n  return function(v) {\n    return v.lift(new DelayOperator(l, u));\n  };\n}\nvar DelayOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.delay = u, this.scheduler = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new DelaySubscriber(u, this.delay, this.scheduler));\n  }, a;\n}(), DelaySubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.delay = l, S.scheduler = v, S.queue = [], S.active = !1, S.errored = !1, S;\n  }\n  return u.dispatch = function(c) {\n    for (var l = c.source, v = l.queue, S = c.scheduler, g = c.destination; v.length > 0 && v[0].time - S.now() <= 0; )\n      v.shift().notification.observe(g);\n    if (v.length > 0) {\n      var E = Math.max(0, v[0].time - S.now());\n      this.schedule(c, E);\n    } else\n      this.unsubscribe(), l.active = !1;\n  }, u.prototype._schedule = function(c) {\n    this.active = !0;\n    var l = this.destination;\n    l.add(c.schedule(u.dispatch, this.delay, {\n      source: this,\n      destination: this.destination,\n      scheduler: c\n    }));\n  }, u.prototype.scheduleNotification = function(c) {\n    if (this.errored !== !0) {\n      var l = this.scheduler, v = new DelayMessage(l.now() + this.delay, c);\n      this.queue.push(v), this.active === !1 && this._schedule(l);\n    }\n  }, u.prototype._next = function(c) {\n    this.scheduleNotification(Notification.createNext(c));\n  }, u.prototype._error = function(c) {\n    this.errored = !0, this.queue = [], this.destination.error(c), this.unsubscribe();\n  }, u.prototype._complete = function() {\n    this.scheduleNotification(Notification.createComplete()), this.unsubscribe();\n  }, u;\n}(Subscriber), DelayMessage = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.time = u, this.notification = c;\n  }\n  return a;\n}();\nfunction delayWhen(a, u) {\n  return u ? function(c) {\n    return new SubscriptionDelayObservable(c, u).lift(new DelayWhenOperator(a));\n  } : function(c) {\n    return c.lift(new DelayWhenOperator(a));\n  };\n}\nvar DelayWhenOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.delayDurationSelector = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new DelayWhenSubscriber(u, this.delayDurationSelector));\n  }, a;\n}(), DelayWhenSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.delayDurationSelector = l, v.completed = !1, v.delayNotifierSubscriptions = [], v.index = 0, v;\n  }\n  return u.prototype.notifyNext = function(c, l, v, S, g) {\n    this.destination.next(c), this.removeSubscription(g), this.tryComplete();\n  }, u.prototype.notifyError = function(c, l) {\n    this._error(c);\n  }, u.prototype.notifyComplete = function(c) {\n    var l = this.removeSubscription(c);\n    l && this.destination.next(l), this.tryComplete();\n  }, u.prototype._next = function(c) {\n    var l = this.index++;\n    try {\n      var v = this.delayDurationSelector(c, l);\n      v && this.tryDelay(v, c);\n    } catch (S) {\n      this.destination.error(S);\n    }\n  }, u.prototype._complete = function() {\n    this.completed = !0, this.tryComplete(), this.unsubscribe();\n  }, u.prototype.removeSubscription = function(c) {\n    c.unsubscribe();\n    var l = this.delayNotifierSubscriptions.indexOf(c);\n    return l !== -1 && this.delayNotifierSubscriptions.splice(l, 1), c.outerValue;\n  }, u.prototype.tryDelay = function(c, l) {\n    var v = subscribeToResult(this, c, l);\n    if (v && !v.closed) {\n      var S = this.destination;\n      S.add(v), this.delayNotifierSubscriptions.push(v);\n    }\n  }, u.prototype.tryComplete = function() {\n    this.completed && this.delayNotifierSubscriptions.length === 0 && this.destination.complete();\n  }, u;\n}(OuterSubscriber), SubscriptionDelayObservable = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this) || this;\n    return v.source = c, v.subscriptionDelay = l, v;\n  }\n  return u.prototype._subscribe = function(c) {\n    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(c, this.source));\n  }, u;\n}(Observable), SubscriptionDelaySubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this) || this;\n    return v.parent = c, v.source = l, v.sourceSubscribed = !1, v;\n  }\n  return u.prototype._next = function(c) {\n    this.subscribeToSource();\n  }, u.prototype._error = function(c) {\n    this.unsubscribe(), this.parent.error(c);\n  }, u.prototype._complete = function() {\n    this.unsubscribe(), this.subscribeToSource();\n  }, u.prototype.subscribeToSource = function() {\n    this.sourceSubscribed || (this.sourceSubscribed = !0, this.unsubscribe(), this.source.subscribe(this.parent));\n  }, u;\n}(Subscriber);\nfunction dematerialize() {\n  return function(u) {\n    return u.lift(new DeMaterializeOperator());\n  };\n}\nvar DeMaterializeOperator = /* @__PURE__ */ function() {\n  function a() {\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new DeMaterializeSubscriber(u));\n  }, a;\n}(), DeMaterializeSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c) {\n    return a.call(this, c) || this;\n  }\n  return u.prototype._next = function(c) {\n    c.observe(this.destination);\n  }, u;\n}(Subscriber);\nfunction distinct(a, u) {\n  return function(c) {\n    return c.lift(new DistinctOperator(a, u));\n  };\n}\nvar DistinctOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.keySelector = u, this.flushes = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new DistinctSubscriber(u, this.keySelector, this.flushes));\n  }, a;\n}(), DistinctSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.keySelector = l, S.values = /* @__PURE__ */ new Set(), v && S.add(innerSubscribe(v, new SimpleInnerSubscriber(S))), S;\n  }\n  return u.prototype.notifyNext = function() {\n    this.values.clear();\n  }, u.prototype.notifyError = function(c) {\n    this._error(c);\n  }, u.prototype._next = function(c) {\n    this.keySelector ? this._useKeySelector(c) : this._finalizeNext(c, c);\n  }, u.prototype._useKeySelector = function(c) {\n    var l, v = this.destination;\n    try {\n      l = this.keySelector(c);\n    } catch (S) {\n      v.error(S);\n      return;\n    }\n    this._finalizeNext(l, c);\n  }, u.prototype._finalizeNext = function(c, l) {\n    var v = this.values;\n    v.has(c) || (v.add(c), this.destination.next(l));\n  }, u;\n}(SimpleOuterSubscriber);\nfunction distinctUntilChanged(a, u) {\n  return function(c) {\n    return c.lift(new DistinctUntilChangedOperator(a, u));\n  };\n}\nvar DistinctUntilChangedOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.compare = u, this.keySelector = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new DistinctUntilChangedSubscriber(u, this.compare, this.keySelector));\n  }, a;\n}(), DistinctUntilChangedSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.keySelector = v, S.hasKey = !1, typeof l == \"function\" && (S.compare = l), S;\n  }\n  return u.prototype.compare = function(c, l) {\n    return c === l;\n  }, u.prototype._next = function(c) {\n    var l;\n    try {\n      var v = this.keySelector;\n      l = v ? v(c) : c;\n    } catch (E) {\n      return this.destination.error(E);\n    }\n    var S = !1;\n    if (this.hasKey)\n      try {\n        var g = this.compare;\n        S = g(this.key, l);\n      } catch (E) {\n        return this.destination.error(E);\n      }\n    else\n      this.hasKey = !0;\n    S || (this.key = l, this.destination.next(c));\n  }, u;\n}(Subscriber);\nfunction distinctUntilKeyChanged(a, u) {\n  return distinctUntilChanged(function(c, l) {\n    return u ? u(c[a], l[a]) : c[a] === l[a];\n  });\n}\nvar ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {\n  function a() {\n    return Error.call(this), this.message = \"argument out of range\", this.name = \"ArgumentOutOfRangeError\", this;\n  }\n  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;\n}(), ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;\nfunction filter(a, u) {\n  return function(l) {\n    return l.lift(new FilterOperator(a, u));\n  };\n}\nvar FilterOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.predicate = u, this.thisArg = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new FilterSubscriber(u, this.predicate, this.thisArg));\n  }, a;\n}(), FilterSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.predicate = l, S.thisArg = v, S.count = 0, S;\n  }\n  return u.prototype._next = function(c) {\n    var l;\n    try {\n      l = this.predicate.call(this.thisArg, c, this.count++);\n    } catch (v) {\n      this.destination.error(v);\n      return;\n    }\n    l && this.destination.next(c);\n  }, u;\n}(Subscriber), EmptyErrorImpl = /* @__PURE__ */ function() {\n  function a() {\n    return Error.call(this), this.message = \"no elements in sequence\", this.name = \"EmptyError\", this;\n  }\n  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;\n}(), EmptyError = EmptyErrorImpl;\nfunction throwIfEmpty(a) {\n  return a === void 0 && (a = defaultErrorFactory), function(u) {\n    return u.lift(new ThrowIfEmptyOperator(a));\n  };\n}\nvar ThrowIfEmptyOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.errorFactory = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new ThrowIfEmptySubscriber(u, this.errorFactory));\n  }, a;\n}(), ThrowIfEmptySubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.errorFactory = l, v.hasValue = !1, v;\n  }\n  return u.prototype._next = function(c) {\n    this.hasValue = !0, this.destination.next(c);\n  }, u.prototype._complete = function() {\n    if (this.hasValue)\n      return this.destination.complete();\n    var c = void 0;\n    try {\n      c = this.errorFactory();\n    } catch (l) {\n      c = l;\n    }\n    this.destination.error(c);\n  }, u;\n}(Subscriber);\nfunction defaultErrorFactory() {\n  return new EmptyError();\n}\nfunction take(a) {\n  return function(u) {\n    return a === 0 ? empty$1() : u.lift(new TakeOperator(a));\n  };\n}\nvar TakeOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    if (this.total = u, this.total < 0)\n      throw new ArgumentOutOfRangeError();\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new TakeSubscriber(u, this.total));\n  }, a;\n}(), TakeSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.total = l, v.count = 0, v;\n  }\n  return u.prototype._next = function(c) {\n    var l = this.total, v = ++this.count;\n    v <= l && (this.destination.next(c), v === l && (this.destination.complete(), this.unsubscribe()));\n  }, u;\n}(Subscriber);\nfunction elementAt(a, u) {\n  if (a < 0)\n    throw new ArgumentOutOfRangeError();\n  var c = arguments.length >= 2;\n  return function(l) {\n    return l.pipe(filter(function(v, S) {\n      return S === a;\n    }), take(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {\n      return new ArgumentOutOfRangeError();\n    }));\n  };\n}\nfunction endWith() {\n  for (var a = [], u = 0; u < arguments.length; u++)\n    a[u] = arguments[u];\n  return function(c) {\n    return concat$1(c, of$1.apply(void 0, a));\n  };\n}\nfunction every(a, u) {\n  return function(c) {\n    return c.lift(new EveryOperator(a, u, c));\n  };\n}\nvar EveryOperator = /* @__PURE__ */ function() {\n  function a(u, c, l) {\n    this.predicate = u, this.thisArg = c, this.source = l;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new EverySubscriber(u, this.predicate, this.thisArg, this.source));\n  }, a;\n}(), EverySubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v, S) {\n    var g = a.call(this, c) || this;\n    return g.predicate = l, g.thisArg = v, g.source = S, g.index = 0, g.thisArg = v || g, g;\n  }\n  return u.prototype.notifyComplete = function(c) {\n    this.destination.next(c), this.destination.complete();\n  }, u.prototype._next = function(c) {\n    var l = !1;\n    try {\n      l = this.predicate.call(this.thisArg, c, this.index++, this.source);\n    } catch (v) {\n      this.destination.error(v);\n      return;\n    }\n    l || this.notifyComplete(!1);\n  }, u.prototype._complete = function() {\n    this.notifyComplete(!0);\n  }, u;\n}(Subscriber);\nfunction exhaust() {\n  return function(a) {\n    return a.lift(new SwitchFirstOperator());\n  };\n}\nvar SwitchFirstOperator = /* @__PURE__ */ function() {\n  function a() {\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new SwitchFirstSubscriber(u));\n  }, a;\n}(), SwitchFirstSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c) {\n    var l = a.call(this, c) || this;\n    return l.hasCompleted = !1, l.hasSubscription = !1, l;\n  }\n  return u.prototype._next = function(c) {\n    this.hasSubscription || (this.hasSubscription = !0, this.add(innerSubscribe(c, new SimpleInnerSubscriber(this))));\n  }, u.prototype._complete = function() {\n    this.hasCompleted = !0, this.hasSubscription || this.destination.complete();\n  }, u.prototype.notifyComplete = function() {\n    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();\n  }, u;\n}(SimpleOuterSubscriber);\nfunction exhaustMap(a, u) {\n  return u ? function(c) {\n    return c.pipe(exhaustMap(function(l, v) {\n      return from(a(l, v)).pipe(map(function(S, g) {\n        return u(l, S, v, g);\n      }));\n    }));\n  } : function(c) {\n    return c.lift(new ExhaustMapOperator(a));\n  };\n}\nvar ExhaustMapOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.project = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new ExhaustMapSubscriber(u, this.project));\n  }, a;\n}(), ExhaustMapSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.project = l, v.hasSubscription = !1, v.hasCompleted = !1, v.index = 0, v;\n  }\n  return u.prototype._next = function(c) {\n    this.hasSubscription || this.tryNext(c);\n  }, u.prototype.tryNext = function(c) {\n    var l, v = this.index++;\n    try {\n      l = this.project(c, v);\n    } catch (S) {\n      this.destination.error(S);\n      return;\n    }\n    this.hasSubscription = !0, this._innerSub(l);\n  }, u.prototype._innerSub = function(c) {\n    var l = new SimpleInnerSubscriber(this), v = this.destination;\n    v.add(l);\n    var S = innerSubscribe(c, l);\n    S !== l && v.add(S);\n  }, u.prototype._complete = function() {\n    this.hasCompleted = !0, this.hasSubscription || this.destination.complete(), this.unsubscribe();\n  }, u.prototype.notifyNext = function(c) {\n    this.destination.next(c);\n  }, u.prototype.notifyError = function(c) {\n    this.destination.error(c);\n  }, u.prototype.notifyComplete = function() {\n    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();\n  }, u;\n}(SimpleOuterSubscriber);\nfunction expand(a, u, c) {\n  return u === void 0 && (u = Number.POSITIVE_INFINITY), u = (u || 0) < 1 ? Number.POSITIVE_INFINITY : u, function(l) {\n    return l.lift(new ExpandOperator(a, u, c));\n  };\n}\nvar ExpandOperator = /* @__PURE__ */ function() {\n  function a(u, c, l) {\n    this.project = u, this.concurrent = c, this.scheduler = l;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new ExpandSubscriber(u, this.project, this.concurrent, this.scheduler));\n  }, a;\n}(), ExpandSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v, S) {\n    var g = a.call(this, c) || this;\n    return g.project = l, g.concurrent = v, g.scheduler = S, g.index = 0, g.active = 0, g.hasCompleted = !1, v < Number.POSITIVE_INFINITY && (g.buffer = []), g;\n  }\n  return u.dispatch = function(c) {\n    var l = c.subscriber, v = c.result, S = c.value, g = c.index;\n    l.subscribeToProjection(v, S, g);\n  }, u.prototype._next = function(c) {\n    var l = this.destination;\n    if (l.closed) {\n      this._complete();\n      return;\n    }\n    var v = this.index++;\n    if (this.active < this.concurrent) {\n      l.next(c);\n      try {\n        var S = this.project, g = S(c, v);\n        if (!this.scheduler)\n          this.subscribeToProjection(g, c, v);\n        else {\n          var E = { subscriber: this, result: g, value: c, index: v }, _ = this.destination;\n          _.add(this.scheduler.schedule(u.dispatch, 0, E));\n        }\n      } catch (k) {\n        l.error(k);\n      }\n    } else\n      this.buffer.push(c);\n  }, u.prototype.subscribeToProjection = function(c, l, v) {\n    this.active++;\n    var S = this.destination;\n    S.add(innerSubscribe(c, new SimpleInnerSubscriber(this)));\n  }, u.prototype._complete = function() {\n    this.hasCompleted = !0, this.hasCompleted && this.active === 0 && this.destination.complete(), this.unsubscribe();\n  }, u.prototype.notifyNext = function(c) {\n    this._next(c);\n  }, u.prototype.notifyComplete = function() {\n    var c = this.buffer;\n    this.active--, c && c.length > 0 && this._next(c.shift()), this.hasCompleted && this.active === 0 && this.destination.complete();\n  }, u;\n}(SimpleOuterSubscriber);\nfunction finalize(a) {\n  return function(u) {\n    return u.lift(new FinallyOperator(a));\n  };\n}\nvar FinallyOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.callback = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new FinallySubscriber(u, this.callback));\n  }, a;\n}(), FinallySubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.add(new Subscription(l)), v;\n  }\n  return u;\n}(Subscriber);\nfunction find$1(a, u) {\n  if (typeof a != \"function\")\n    throw new TypeError(\"predicate is not a function\");\n  return function(c) {\n    return c.lift(new FindValueOperator(a, c, !1, u));\n  };\n}\nvar FindValueOperator = /* @__PURE__ */ function() {\n  function a(u, c, l, v) {\n    this.predicate = u, this.source = c, this.yieldIndex = l, this.thisArg = v;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new FindValueSubscriber(u, this.predicate, this.source, this.yieldIndex, this.thisArg));\n  }, a;\n}(), FindValueSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v, S, g) {\n    var E = a.call(this, c) || this;\n    return E.predicate = l, E.source = v, E.yieldIndex = S, E.thisArg = g, E.index = 0, E;\n  }\n  return u.prototype.notifyComplete = function(c) {\n    var l = this.destination;\n    l.next(c), l.complete(), this.unsubscribe();\n  }, u.prototype._next = function(c) {\n    var l = this, v = l.predicate, S = l.thisArg, g = this.index++;\n    try {\n      var E = v.call(S || this, c, g, this.source);\n      E && this.notifyComplete(this.yieldIndex ? g : c);\n    } catch (_) {\n      this.destination.error(_);\n    }\n  }, u.prototype._complete = function() {\n    this.notifyComplete(this.yieldIndex ? -1 : void 0);\n  }, u;\n}(Subscriber);\nfunction findIndex(a, u) {\n  return function(c) {\n    return c.lift(new FindValueOperator(a, c, !0, u));\n  };\n}\nfunction first(a, u) {\n  var c = arguments.length >= 2;\n  return function(l) {\n    return l.pipe(a ? filter(function(v, S) {\n      return a(v, S, l);\n    }) : identity, take(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {\n      return new EmptyError();\n    }));\n  };\n}\nvar ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {\n  function a() {\n    return Error.call(this), this.message = \"object unsubscribed\", this.name = \"ObjectUnsubscribedError\", this;\n  }\n  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;\n}(), ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl, SubjectSubscription = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this) || this;\n    return v.subject = c, v.subscriber = l, v.closed = !1, v;\n  }\n  return u.prototype.unsubscribe = function() {\n    if (!this.closed) {\n      this.closed = !0;\n      var c = this.subject, l = c.observers;\n      if (this.subject = null, !(!l || l.length === 0 || c.isStopped || c.closed)) {\n        var v = l.indexOf(this.subscriber);\n        v !== -1 && l.splice(v, 1);\n      }\n    }\n  }, u;\n}(Subscription), SubjectSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c) {\n    var l = a.call(this, c) || this;\n    return l.destination = c, l;\n  }\n  return u;\n}(Subscriber), Subject = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u() {\n    var c = a.call(this) || this;\n    return c.observers = [], c.closed = !1, c.isStopped = !1, c.hasError = !1, c.thrownError = null, c;\n  }\n  return u.prototype[rxSubscriber] = function() {\n    return new SubjectSubscriber(this);\n  }, u.prototype.lift = function(c) {\n    var l = new AnonymousSubject(this, this);\n    return l.operator = c, l;\n  }, u.prototype.next = function(c) {\n    if (this.closed)\n      throw new ObjectUnsubscribedError();\n    if (!this.isStopped)\n      for (var l = this.observers, v = l.length, S = l.slice(), g = 0; g < v; g++)\n        S[g].next(c);\n  }, u.prototype.error = function(c) {\n    if (this.closed)\n      throw new ObjectUnsubscribedError();\n    this.hasError = !0, this.thrownError = c, this.isStopped = !0;\n    for (var l = this.observers, v = l.length, S = l.slice(), g = 0; g < v; g++)\n      S[g].error(c);\n    this.observers.length = 0;\n  }, u.prototype.complete = function() {\n    if (this.closed)\n      throw new ObjectUnsubscribedError();\n    this.isStopped = !0;\n    for (var c = this.observers, l = c.length, v = c.slice(), S = 0; S < l; S++)\n      v[S].complete();\n    this.observers.length = 0;\n  }, u.prototype.unsubscribe = function() {\n    this.isStopped = !0, this.closed = !0, this.observers = null;\n  }, u.prototype._trySubscribe = function(c) {\n    if (this.closed)\n      throw new ObjectUnsubscribedError();\n    return a.prototype._trySubscribe.call(this, c);\n  }, u.prototype._subscribe = function(c) {\n    if (this.closed)\n      throw new ObjectUnsubscribedError();\n    return this.hasError ? (c.error(this.thrownError), Subscription.EMPTY) : this.isStopped ? (c.complete(), Subscription.EMPTY) : (this.observers.push(c), new SubjectSubscription(this, c));\n  }, u.prototype.asObservable = function() {\n    var c = new Observable();\n    return c.source = this, c;\n  }, u.create = function(c, l) {\n    return new AnonymousSubject(c, l);\n  }, u;\n}(Observable), AnonymousSubject = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this) || this;\n    return v.destination = c, v.source = l, v;\n  }\n  return u.prototype.next = function(c) {\n    var l = this.destination;\n    l && l.next && l.next(c);\n  }, u.prototype.error = function(c) {\n    var l = this.destination;\n    l && l.error && this.destination.error(c);\n  }, u.prototype.complete = function() {\n    var c = this.destination;\n    c && c.complete && this.destination.complete();\n  }, u.prototype._subscribe = function(c) {\n    var l = this.source;\n    return l ? this.source.subscribe(c) : Subscription.EMPTY;\n  }, u;\n}(Subject);\nfunction groupBy(a, u, c, l) {\n  return function(v) {\n    return v.lift(new GroupByOperator(a, u, c, l));\n  };\n}\nvar GroupByOperator = /* @__PURE__ */ function() {\n  function a(u, c, l, v) {\n    this.keySelector = u, this.elementSelector = c, this.durationSelector = l, this.subjectSelector = v;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new GroupBySubscriber(u, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n  }, a;\n}(), GroupBySubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v, S, g) {\n    var E = a.call(this, c) || this;\n    return E.keySelector = l, E.elementSelector = v, E.durationSelector = S, E.subjectSelector = g, E.groups = null, E.attemptedToUnsubscribe = !1, E.count = 0, E;\n  }\n  return u.prototype._next = function(c) {\n    var l;\n    try {\n      l = this.keySelector(c);\n    } catch (v) {\n      this.error(v);\n      return;\n    }\n    this._group(c, l);\n  }, u.prototype._group = function(c, l) {\n    var v = this.groups;\n    v || (v = this.groups = /* @__PURE__ */ new Map());\n    var S = v.get(l), g;\n    if (this.elementSelector)\n      try {\n        g = this.elementSelector(c);\n      } catch (k) {\n        this.error(k);\n      }\n    else\n      g = c;\n    if (!S) {\n      S = this.subjectSelector ? this.subjectSelector() : new Subject(), v.set(l, S);\n      var E = new GroupedObservable(l, S, this);\n      if (this.destination.next(E), this.durationSelector) {\n        var _ = void 0;\n        try {\n          _ = this.durationSelector(new GroupedObservable(l, S));\n        } catch (k) {\n          this.error(k);\n          return;\n        }\n        this.add(_.subscribe(new GroupDurationSubscriber(l, S, this)));\n      }\n    }\n    S.closed || S.next(g);\n  }, u.prototype._error = function(c) {\n    var l = this.groups;\n    l && (l.forEach(function(v, S) {\n      v.error(c);\n    }), l.clear()), this.destination.error(c);\n  }, u.prototype._complete = function() {\n    var c = this.groups;\n    c && (c.forEach(function(l, v) {\n      l.complete();\n    }), c.clear()), this.destination.complete();\n  }, u.prototype.removeGroup = function(c) {\n    this.groups.delete(c);\n  }, u.prototype.unsubscribe = function() {\n    this.closed || (this.attemptedToUnsubscribe = !0, this.count === 0 && a.prototype.unsubscribe.call(this));\n  }, u;\n}(Subscriber), GroupDurationSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, l) || this;\n    return S.key = c, S.group = l, S.parent = v, S;\n  }\n  return u.prototype._next = function(c) {\n    this.complete();\n  }, u.prototype._unsubscribe = function() {\n    var c = this, l = c.parent, v = c.key;\n    this.key = this.parent = null, l && l.removeGroup(v);\n  }, u;\n}(Subscriber), GroupedObservable = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this) || this;\n    return S.key = c, S.groupSubject = l, S.refCountSubscription = v, S;\n  }\n  return u.prototype._subscribe = function(c) {\n    var l = new Subscription(), v = this, S = v.refCountSubscription, g = v.groupSubject;\n    return S && !S.closed && l.add(new InnerRefCountSubscription(S)), l.add(g.subscribe(c)), l;\n  }, u;\n}(Observable), InnerRefCountSubscription = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c) {\n    var l = a.call(this) || this;\n    return l.parent = c, c.count++, l;\n  }\n  return u.prototype.unsubscribe = function() {\n    var c = this.parent;\n    !c.closed && !this.closed && (a.prototype.unsubscribe.call(this), c.count -= 1, c.count === 0 && c.attemptedToUnsubscribe && c.unsubscribe());\n  }, u;\n}(Subscription);\nfunction ignoreElements() {\n  return function(u) {\n    return u.lift(new IgnoreElementsOperator());\n  };\n}\nvar IgnoreElementsOperator = /* @__PURE__ */ function() {\n  function a() {\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new IgnoreElementsSubscriber(u));\n  }, a;\n}(), IgnoreElementsSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u() {\n    return a !== null && a.apply(this, arguments) || this;\n  }\n  return u.prototype._next = function(c) {\n  }, u;\n}(Subscriber);\nfunction isEmpty() {\n  return function(a) {\n    return a.lift(new IsEmptyOperator());\n  };\n}\nvar IsEmptyOperator = /* @__PURE__ */ function() {\n  function a() {\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new IsEmptySubscriber(u));\n  }, a;\n}(), IsEmptySubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c) {\n    return a.call(this, c) || this;\n  }\n  return u.prototype.notifyComplete = function(c) {\n    var l = this.destination;\n    l.next(c), l.complete();\n  }, u.prototype._next = function(c) {\n    this.notifyComplete(!1);\n  }, u.prototype._complete = function() {\n    this.notifyComplete(!0);\n  }, u;\n}(Subscriber);\nfunction takeLast(a) {\n  return function(c) {\n    return a === 0 ? empty$1() : c.lift(new TakeLastOperator(a));\n  };\n}\nvar TakeLastOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    if (this.total = u, this.total < 0)\n      throw new ArgumentOutOfRangeError();\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new TakeLastSubscriber(u, this.total));\n  }, a;\n}(), TakeLastSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.total = l, v.ring = new Array(), v.count = 0, v;\n  }\n  return u.prototype._next = function(c) {\n    var l = this.ring, v = this.total, S = this.count++;\n    if (l.length < v)\n      l.push(c);\n    else {\n      var g = S % v;\n      l[g] = c;\n    }\n  }, u.prototype._complete = function() {\n    var c = this.destination, l = this.count;\n    if (l > 0)\n      for (var v = this.count >= this.total ? this.total : this.count, S = this.ring, g = 0; g < v; g++) {\n        var E = l++ % v;\n        c.next(S[E]);\n      }\n    c.complete();\n  }, u;\n}(Subscriber);\nfunction last(a, u) {\n  var c = arguments.length >= 2;\n  return function(l) {\n    return l.pipe(a ? filter(function(v, S) {\n      return a(v, S, l);\n    }) : identity, takeLast(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {\n      return new EmptyError();\n    }));\n  };\n}\nfunction mapTo(a) {\n  return function(u) {\n    return u.lift(new MapToOperator(a));\n  };\n}\nvar MapToOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.value = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new MapToSubscriber(u, this.value));\n  }, a;\n}(), MapToSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.value = l, v;\n  }\n  return u.prototype._next = function(c) {\n    this.destination.next(this.value);\n  }, u;\n}(Subscriber);\nfunction materialize() {\n  return function(u) {\n    return u.lift(new MaterializeOperator());\n  };\n}\nvar MaterializeOperator = /* @__PURE__ */ function() {\n  function a() {\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new MaterializeSubscriber(u));\n  }, a;\n}(), MaterializeSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c) {\n    return a.call(this, c) || this;\n  }\n  return u.prototype._next = function(c) {\n    this.destination.next(Notification.createNext(c));\n  }, u.prototype._error = function(c) {\n    var l = this.destination;\n    l.next(Notification.createError(c)), l.complete();\n  }, u.prototype._complete = function() {\n    var c = this.destination;\n    c.next(Notification.createComplete()), c.complete();\n  }, u;\n}(Subscriber);\nfunction scan(a, u) {\n  var c = !1;\n  return arguments.length >= 2 && (c = !0), function(v) {\n    return v.lift(new ScanOperator(a, u, c));\n  };\n}\nvar ScanOperator = /* @__PURE__ */ function() {\n  function a(u, c, l) {\n    l === void 0 && (l = !1), this.accumulator = u, this.seed = c, this.hasSeed = l;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new ScanSubscriber(u, this.accumulator, this.seed, this.hasSeed));\n  }, a;\n}(), ScanSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v, S) {\n    var g = a.call(this, c) || this;\n    return g.accumulator = l, g._seed = v, g.hasSeed = S, g.index = 0, g;\n  }\n  return Object.defineProperty(u.prototype, \"seed\", {\n    get: function() {\n      return this._seed;\n    },\n    set: function(c) {\n      this.hasSeed = !0, this._seed = c;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), u.prototype._next = function(c) {\n    if (!this.hasSeed)\n      this.seed = c, this.destination.next(c);\n    else\n      return this._tryNext(c);\n  }, u.prototype._tryNext = function(c) {\n    var l = this.index++, v;\n    try {\n      v = this.accumulator(this.seed, c, l);\n    } catch (S) {\n      this.destination.error(S);\n    }\n    this.seed = v, this.destination.next(v);\n  }, u;\n}(Subscriber);\nfunction reduce(a, u) {\n  return arguments.length >= 2 ? function(l) {\n    return pipe(scan(a, u), takeLast(1), defaultIfEmpty(u))(l);\n  } : function(l) {\n    return pipe(scan(function(v, S, g) {\n      return a(v, S, g + 1);\n    }), takeLast(1))(l);\n  };\n}\nfunction max(a) {\n  var u = typeof a == \"function\" ? function(c, l) {\n    return a(c, l) > 0 ? c : l;\n  } : function(c, l) {\n    return c > l ? c : l;\n  };\n  return reduce(u);\n}\nfunction merge$2() {\n  for (var a = [], u = 0; u < arguments.length; u++)\n    a[u] = arguments[u];\n  var c = Number.POSITIVE_INFINITY, l = null, v = a[a.length - 1];\n  return isScheduler(v) ? (l = a.pop(), a.length > 1 && typeof a[a.length - 1] == \"number\" && (c = a.pop())) : typeof v == \"number\" && (c = a.pop()), l === null && a.length === 1 && a[0] instanceof Observable ? a[0] : mergeAll(c)(fromArray(a, l));\n}\nfunction merge$1() {\n  for (var a = [], u = 0; u < arguments.length; u++)\n    a[u] = arguments[u];\n  return function(c) {\n    return c.lift.call(merge$2.apply(void 0, [c].concat(a)));\n  };\n}\nfunction mergeMapTo(a, u, c) {\n  return c === void 0 && (c = Number.POSITIVE_INFINITY), typeof u == \"function\" ? mergeMap(function() {\n    return a;\n  }, u, c) : (typeof u == \"number\" && (c = u), mergeMap(function() {\n    return a;\n  }, c));\n}\nfunction mergeScan(a, u, c) {\n  return c === void 0 && (c = Number.POSITIVE_INFINITY), function(l) {\n    return l.lift(new MergeScanOperator(a, u, c));\n  };\n}\nvar MergeScanOperator = /* @__PURE__ */ function() {\n  function a(u, c, l) {\n    this.accumulator = u, this.seed = c, this.concurrent = l;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new MergeScanSubscriber(u, this.accumulator, this.seed, this.concurrent));\n  }, a;\n}(), MergeScanSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v, S) {\n    var g = a.call(this, c) || this;\n    return g.accumulator = l, g.acc = v, g.concurrent = S, g.hasValue = !1, g.hasCompleted = !1, g.buffer = [], g.active = 0, g.index = 0, g;\n  }\n  return u.prototype._next = function(c) {\n    if (this.active < this.concurrent) {\n      var l = this.index++, v = this.destination, S = void 0;\n      try {\n        var g = this.accumulator;\n        S = g(this.acc, c, l);\n      } catch (E) {\n        return v.error(E);\n      }\n      this.active++, this._innerSub(S);\n    } else\n      this.buffer.push(c);\n  }, u.prototype._innerSub = function(c) {\n    var l = new SimpleInnerSubscriber(this), v = this.destination;\n    v.add(l);\n    var S = innerSubscribe(c, l);\n    S !== l && v.add(S);\n  }, u.prototype._complete = function() {\n    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete()), this.unsubscribe();\n  }, u.prototype.notifyNext = function(c) {\n    var l = this.destination;\n    this.acc = c, this.hasValue = !0, l.next(c);\n  }, u.prototype.notifyComplete = function() {\n    var c = this.buffer;\n    this.active--, c.length > 0 ? this._next(c.shift()) : this.active === 0 && this.hasCompleted && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete());\n  }, u;\n}(SimpleOuterSubscriber);\nfunction min(a) {\n  var u = typeof a == \"function\" ? function(c, l) {\n    return a(c, l) < 0 ? c : l;\n  } : function(c, l) {\n    return c < l ? c : l;\n  };\n  return reduce(u);\n}\nfunction refCount() {\n  return function(u) {\n    return u.lift(new RefCountOperator(u));\n  };\n}\nvar RefCountOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.connectable = u;\n  }\n  return a.prototype.call = function(u, c) {\n    var l = this.connectable;\n    l._refCount++;\n    var v = new RefCountSubscriber(u, l), S = c.subscribe(v);\n    return v.closed || (v.connection = l.connect()), S;\n  }, a;\n}(), RefCountSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.connectable = l, v;\n  }\n  return u.prototype._unsubscribe = function() {\n    var c = this.connectable;\n    if (!c) {\n      this.connection = null;\n      return;\n    }\n    this.connectable = null;\n    var l = c._refCount;\n    if (l <= 0) {\n      this.connection = null;\n      return;\n    }\n    if (c._refCount = l - 1, l > 1) {\n      this.connection = null;\n      return;\n    }\n    var v = this.connection, S = c._connection;\n    this.connection = null, S && (!v || S === v) && S.unsubscribe();\n  }, u;\n}(Subscriber), ConnectableObservable = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this) || this;\n    return v.source = c, v.subjectFactory = l, v._refCount = 0, v._isComplete = !1, v;\n  }\n  return u.prototype._subscribe = function(c) {\n    return this.getSubject().subscribe(c);\n  }, u.prototype.getSubject = function() {\n    var c = this._subject;\n    return (!c || c.isStopped) && (this._subject = this.subjectFactory()), this._subject;\n  }, u.prototype.connect = function() {\n    var c = this._connection;\n    return c || (this._isComplete = !1, c = this._connection = new Subscription(), c.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this))), c.closed && (this._connection = null, c = Subscription.EMPTY)), c;\n  }, u.prototype.refCount = function() {\n    return refCount()(this);\n  }, u;\n}(Observable), connectableObservableDescriptor = /* @__PURE__ */ function() {\n  var a = ConnectableObservable.prototype;\n  return {\n    operator: { value: null },\n    _refCount: { value: 0, writable: !0 },\n    _subject: { value: null, writable: !0 },\n    _connection: { value: null, writable: !0 },\n    _subscribe: { value: a._subscribe },\n    _isComplete: { value: a._isComplete, writable: !0 },\n    getSubject: { value: a.getSubject },\n    connect: { value: a.connect },\n    refCount: { value: a.refCount }\n  };\n}(), ConnectableSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.connectable = l, v;\n  }\n  return u.prototype._error = function(c) {\n    this._unsubscribe(), a.prototype._error.call(this, c);\n  }, u.prototype._complete = function() {\n    this.connectable._isComplete = !0, this._unsubscribe(), a.prototype._complete.call(this);\n  }, u.prototype._unsubscribe = function() {\n    var c = this.connectable;\n    if (c) {\n      this.connectable = null;\n      var l = c._connection;\n      c._refCount = 0, c._subject = null, c._connection = null, l && l.unsubscribe();\n    }\n  }, u;\n}(SubjectSubscriber);\nfunction multicast(a, u) {\n  return function(l) {\n    var v;\n    if (typeof a == \"function\" ? v = a : v = function() {\n      return a;\n    }, typeof u == \"function\")\n      return l.lift(new MulticastOperator(v, u));\n    var S = Object.create(l, connectableObservableDescriptor);\n    return S.source = l, S.subjectFactory = v, S;\n  };\n}\nvar MulticastOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.subjectFactory = u, this.selector = c;\n  }\n  return a.prototype.call = function(u, c) {\n    var l = this.selector, v = this.subjectFactory(), S = l(v).subscribe(u);\n    return S.add(c.subscribe(v)), S;\n  }, a;\n}();\nfunction observeOn(a, u) {\n  return u === void 0 && (u = 0), function(l) {\n    return l.lift(new ObserveOnOperator(a, u));\n  };\n}\nvar ObserveOnOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    c === void 0 && (c = 0), this.scheduler = u, this.delay = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new ObserveOnSubscriber(u, this.scheduler, this.delay));\n  }, a;\n}(), ObserveOnSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    v === void 0 && (v = 0);\n    var S = a.call(this, c) || this;\n    return S.scheduler = l, S.delay = v, S;\n  }\n  return u.dispatch = function(c) {\n    var l = c.notification, v = c.destination;\n    l.observe(v), this.unsubscribe();\n  }, u.prototype.scheduleMessage = function(c) {\n    var l = this.destination;\n    l.add(this.scheduler.schedule(u.dispatch, this.delay, new ObserveOnMessage(c, this.destination)));\n  }, u.prototype._next = function(c) {\n    this.scheduleMessage(Notification.createNext(c));\n  }, u.prototype._error = function(c) {\n    this.scheduleMessage(Notification.createError(c)), this.unsubscribe();\n  }, u.prototype._complete = function() {\n    this.scheduleMessage(Notification.createComplete()), this.unsubscribe();\n  }, u;\n}(Subscriber), ObserveOnMessage = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.notification = u, this.destination = c;\n  }\n  return a;\n}();\nfunction onErrorResumeNext() {\n  for (var a = [], u = 0; u < arguments.length; u++)\n    a[u] = arguments[u];\n  return a.length === 1 && isArray$4(a[0]) && (a = a[0]), function(c) {\n    return c.lift(new OnErrorResumeNextOperator(a));\n  };\n}\nvar OnErrorResumeNextOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.nextSources = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new OnErrorResumeNextSubscriber(u, this.nextSources));\n  }, a;\n}(), OnErrorResumeNextSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.destination = c, v.nextSources = l, v;\n  }\n  return u.prototype.notifyError = function() {\n    this.subscribeToNextSource();\n  }, u.prototype.notifyComplete = function() {\n    this.subscribeToNextSource();\n  }, u.prototype._error = function(c) {\n    this.subscribeToNextSource(), this.unsubscribe();\n  }, u.prototype._complete = function() {\n    this.subscribeToNextSource(), this.unsubscribe();\n  }, u.prototype.subscribeToNextSource = function() {\n    var c = this.nextSources.shift();\n    if (c) {\n      var l = new SimpleInnerSubscriber(this), v = this.destination;\n      v.add(l);\n      var S = innerSubscribe(c, l);\n      S !== l && v.add(S);\n    } else\n      this.destination.complete();\n  }, u;\n}(SimpleOuterSubscriber);\nfunction pairwise() {\n  return function(a) {\n    return a.lift(new PairwiseOperator());\n  };\n}\nvar PairwiseOperator = /* @__PURE__ */ function() {\n  function a() {\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new PairwiseSubscriber(u));\n  }, a;\n}(), PairwiseSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c) {\n    var l = a.call(this, c) || this;\n    return l.hasPrev = !1, l;\n  }\n  return u.prototype._next = function(c) {\n    var l;\n    this.hasPrev ? l = [this.prev, c] : this.hasPrev = !0, this.prev = c, l && this.destination.next(l);\n  }, u;\n}(Subscriber);\nfunction not(a, u) {\n  function c() {\n    return !c.pred.apply(c.thisArg, arguments);\n  }\n  return c.pred = a, c.thisArg = u, c;\n}\nfunction partition(a, u) {\n  return function(c) {\n    return [\n      filter(a, u)(c),\n      filter(not(a, u))(c)\n    ];\n  };\n}\nfunction pluck() {\n  for (var a = [], u = 0; u < arguments.length; u++)\n    a[u] = arguments[u];\n  var c = a.length;\n  if (c === 0)\n    throw new Error(\"list of properties cannot be empty.\");\n  return function(l) {\n    return map(plucker(a, c))(l);\n  };\n}\nfunction plucker(a, u) {\n  var c = function(l) {\n    for (var v = l, S = 0; S < u; S++) {\n      var g = v != null ? v[a[S]] : void 0;\n      if (g !== void 0)\n        v = g;\n      else\n        return;\n    }\n    return v;\n  };\n  return c;\n}\nfunction publish(a) {\n  return a ? multicast(function() {\n    return new Subject();\n  }, a) : multicast(new Subject());\n}\nvar BehaviorSubject = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c) {\n    var l = a.call(this) || this;\n    return l._value = c, l;\n  }\n  return Object.defineProperty(u.prototype, \"value\", {\n    get: function() {\n      return this.getValue();\n    },\n    enumerable: !0,\n    configurable: !0\n  }), u.prototype._subscribe = function(c) {\n    var l = a.prototype._subscribe.call(this, c);\n    return l && !l.closed && c.next(this._value), l;\n  }, u.prototype.getValue = function() {\n    if (this.hasError)\n      throw this.thrownError;\n    if (this.closed)\n      throw new ObjectUnsubscribedError();\n    return this._value;\n  }, u.prototype.next = function(c) {\n    a.prototype.next.call(this, this._value = c);\n  }, u;\n}(Subject);\nfunction publishBehavior(a) {\n  return function(u) {\n    return multicast(new BehaviorSubject(a))(u);\n  };\n}\nvar AsyncSubject = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u() {\n    var c = a !== null && a.apply(this, arguments) || this;\n    return c.value = null, c.hasNext = !1, c.hasCompleted = !1, c;\n  }\n  return u.prototype._subscribe = function(c) {\n    return this.hasError ? (c.error(this.thrownError), Subscription.EMPTY) : this.hasCompleted && this.hasNext ? (c.next(this.value), c.complete(), Subscription.EMPTY) : a.prototype._subscribe.call(this, c);\n  }, u.prototype.next = function(c) {\n    this.hasCompleted || (this.value = c, this.hasNext = !0);\n  }, u.prototype.error = function(c) {\n    this.hasCompleted || a.prototype.error.call(this, c);\n  }, u.prototype.complete = function() {\n    this.hasCompleted = !0, this.hasNext && a.prototype.next.call(this, this.value), a.prototype.complete.call(this);\n  }, u;\n}(Subject);\nfunction publishLast() {\n  return function(a) {\n    return multicast(new AsyncSubject())(a);\n  };\n}\nvar QueueAction = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c, l) || this;\n    return v.scheduler = c, v.work = l, v;\n  }\n  return u.prototype.schedule = function(c, l) {\n    return l === void 0 && (l = 0), l > 0 ? a.prototype.schedule.call(this, c, l) : (this.delay = l, this.state = c, this.scheduler.flush(this), this);\n  }, u.prototype.execute = function(c, l) {\n    return l > 0 || this.closed ? a.prototype.execute.call(this, c, l) : this._execute(c, l);\n  }, u.prototype.requestAsyncId = function(c, l, v) {\n    return v === void 0 && (v = 0), v !== null && v > 0 || v === null && this.delay > 0 ? a.prototype.requestAsyncId.call(this, c, l, v) : c.flush(this);\n  }, u;\n}(AsyncAction), QueueScheduler = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u() {\n    return a !== null && a.apply(this, arguments) || this;\n  }\n  return u;\n}(AsyncScheduler), queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction), queue = queueScheduler, ReplaySubject = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    c === void 0 && (c = Number.POSITIVE_INFINITY), l === void 0 && (l = Number.POSITIVE_INFINITY);\n    var S = a.call(this) || this;\n    return S.scheduler = v, S._events = [], S._infiniteTimeWindow = !1, S._bufferSize = c < 1 ? 1 : c, S._windowTime = l < 1 ? 1 : l, l === Number.POSITIVE_INFINITY ? (S._infiniteTimeWindow = !0, S.next = S.nextInfiniteTimeWindow) : S.next = S.nextTimeWindow, S;\n  }\n  return u.prototype.nextInfiniteTimeWindow = function(c) {\n    if (!this.isStopped) {\n      var l = this._events;\n      l.push(c), l.length > this._bufferSize && l.shift();\n    }\n    a.prototype.next.call(this, c);\n  }, u.prototype.nextTimeWindow = function(c) {\n    this.isStopped || (this._events.push(new ReplayEvent(this._getNow(), c)), this._trimBufferThenGetEvents()), a.prototype.next.call(this, c);\n  }, u.prototype._subscribe = function(c) {\n    var l = this._infiniteTimeWindow, v = l ? this._events : this._trimBufferThenGetEvents(), S = this.scheduler, g = v.length, E;\n    if (this.closed)\n      throw new ObjectUnsubscribedError();\n    if (this.isStopped || this.hasError ? E = Subscription.EMPTY : (this.observers.push(c), E = new SubjectSubscription(this, c)), S && c.add(c = new ObserveOnSubscriber(c, S)), l)\n      for (var _ = 0; _ < g && !c.closed; _++)\n        c.next(v[_]);\n    else\n      for (var _ = 0; _ < g && !c.closed; _++)\n        c.next(v[_].value);\n    return this.hasError ? c.error(this.thrownError) : this.isStopped && c.complete(), E;\n  }, u.prototype._getNow = function() {\n    return (this.scheduler || queue).now();\n  }, u.prototype._trimBufferThenGetEvents = function() {\n    for (var c = this._getNow(), l = this._bufferSize, v = this._windowTime, S = this._events, g = S.length, E = 0; E < g && !(c - S[E].time < v); )\n      E++;\n    return g > l && (E = Math.max(E, g - l)), E > 0 && S.splice(0, E), S;\n  }, u;\n}(Subject), ReplayEvent = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.time = u, this.value = c;\n  }\n  return a;\n}();\nfunction publishReplay(a, u, c, l) {\n  c && typeof c != \"function\" && (l = c);\n  var v = typeof c == \"function\" ? c : void 0, S = new ReplaySubject(a, u, l);\n  return function(g) {\n    return multicast(function() {\n      return S;\n    }, v)(g);\n  };\n}\nfunction race$1() {\n  for (var a = [], u = 0; u < arguments.length; u++)\n    a[u] = arguments[u];\n  if (a.length === 1)\n    if (isArray$4(a[0]))\n      a = a[0];\n    else\n      return a[0];\n  return fromArray(a, void 0).lift(new RaceOperator());\n}\nvar RaceOperator = /* @__PURE__ */ function() {\n  function a() {\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new RaceSubscriber(u));\n  }, a;\n}(), RaceSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c) {\n    var l = a.call(this, c) || this;\n    return l.hasFirst = !1, l.observables = [], l.subscriptions = [], l;\n  }\n  return u.prototype._next = function(c) {\n    this.observables.push(c);\n  }, u.prototype._complete = function() {\n    var c = this.observables, l = c.length;\n    if (l === 0)\n      this.destination.complete();\n    else {\n      for (var v = 0; v < l && !this.hasFirst; v++) {\n        var S = c[v], g = subscribeToResult(this, S, void 0, v);\n        this.subscriptions && this.subscriptions.push(g), this.add(g);\n      }\n      this.observables = null;\n    }\n  }, u.prototype.notifyNext = function(c, l, v) {\n    if (!this.hasFirst) {\n      this.hasFirst = !0;\n      for (var S = 0; S < this.subscriptions.length; S++)\n        if (S !== v) {\n          var g = this.subscriptions[S];\n          g.unsubscribe(), this.remove(g);\n        }\n      this.subscriptions = null;\n    }\n    this.destination.next(l);\n  }, u;\n}(OuterSubscriber);\nfunction race() {\n  for (var a = [], u = 0; u < arguments.length; u++)\n    a[u] = arguments[u];\n  return function(l) {\n    return a.length === 1 && isArray$4(a[0]) && (a = a[0]), l.lift.call(race$1.apply(void 0, [l].concat(a)));\n  };\n}\nfunction repeat(a) {\n  return a === void 0 && (a = -1), function(u) {\n    return a === 0 ? empty$1() : a < 0 ? u.lift(new RepeatOperator(-1, u)) : u.lift(new RepeatOperator(a - 1, u));\n  };\n}\nvar RepeatOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.count = u, this.source = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new RepeatSubscriber(u, this.count, this.source));\n  }, a;\n}(), RepeatSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.count = l, S.source = v, S;\n  }\n  return u.prototype.complete = function() {\n    if (!this.isStopped) {\n      var c = this, l = c.source, v = c.count;\n      if (v === 0)\n        return a.prototype.complete.call(this);\n      v > -1 && (this.count = v - 1), l.subscribe(this._unsubscribeAndRecycle());\n    }\n  }, u;\n}(Subscriber);\nfunction repeatWhen(a) {\n  return function(u) {\n    return u.lift(new RepeatWhenOperator(a));\n  };\n}\nvar RepeatWhenOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.notifier = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new RepeatWhenSubscriber(u, this.notifier, c));\n  }, a;\n}(), RepeatWhenSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.notifier = l, S.source = v, S.sourceIsBeingSubscribedTo = !0, S;\n  }\n  return u.prototype.notifyNext = function() {\n    this.sourceIsBeingSubscribedTo = !0, this.source.subscribe(this);\n  }, u.prototype.notifyComplete = function() {\n    if (this.sourceIsBeingSubscribedTo === !1)\n      return a.prototype.complete.call(this);\n  }, u.prototype.complete = function() {\n    if (this.sourceIsBeingSubscribedTo = !1, !this.isStopped) {\n      if (this.retries || this.subscribeToRetries(), !this.retriesSubscription || this.retriesSubscription.closed)\n        return a.prototype.complete.call(this);\n      this._unsubscribeAndRecycle(), this.notifications.next(void 0);\n    }\n  }, u.prototype._unsubscribe = function() {\n    var c = this, l = c.notifications, v = c.retriesSubscription;\n    l && (l.unsubscribe(), this.notifications = void 0), v && (v.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;\n  }, u.prototype._unsubscribeAndRecycle = function() {\n    var c = this._unsubscribe;\n    return this._unsubscribe = null, a.prototype._unsubscribeAndRecycle.call(this), this._unsubscribe = c, this;\n  }, u.prototype.subscribeToRetries = function() {\n    this.notifications = new Subject();\n    var c;\n    try {\n      var l = this.notifier;\n      c = l(this.notifications);\n    } catch {\n      return a.prototype.complete.call(this);\n    }\n    this.retries = c, this.retriesSubscription = innerSubscribe(c, new SimpleInnerSubscriber(this));\n  }, u;\n}(SimpleOuterSubscriber);\nfunction retry(a) {\n  return a === void 0 && (a = -1), function(u) {\n    return u.lift(new RetryOperator(a, u));\n  };\n}\nvar RetryOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.count = u, this.source = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new RetrySubscriber(u, this.count, this.source));\n  }, a;\n}(), RetrySubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.count = l, S.source = v, S;\n  }\n  return u.prototype.error = function(c) {\n    if (!this.isStopped) {\n      var l = this, v = l.source, S = l.count;\n      if (S === 0)\n        return a.prototype.error.call(this, c);\n      S > -1 && (this.count = S - 1), v.subscribe(this._unsubscribeAndRecycle());\n    }\n  }, u;\n}(Subscriber);\nfunction retryWhen(a) {\n  return function(u) {\n    return u.lift(new RetryWhenOperator(a, u));\n  };\n}\nvar RetryWhenOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.notifier = u, this.source = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new RetryWhenSubscriber(u, this.notifier, this.source));\n  }, a;\n}(), RetryWhenSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.notifier = l, S.source = v, S;\n  }\n  return u.prototype.error = function(c) {\n    if (!this.isStopped) {\n      var l = this.errors, v = this.retries, S = this.retriesSubscription;\n      if (v)\n        this.errors = void 0, this.retriesSubscription = void 0;\n      else {\n        l = new Subject();\n        try {\n          var g = this.notifier;\n          v = g(l);\n        } catch (E) {\n          return a.prototype.error.call(this, E);\n        }\n        S = innerSubscribe(v, new SimpleInnerSubscriber(this));\n      }\n      this._unsubscribeAndRecycle(), this.errors = l, this.retries = v, this.retriesSubscription = S, l.next(c);\n    }\n  }, u.prototype._unsubscribe = function() {\n    var c = this, l = c.errors, v = c.retriesSubscription;\n    l && (l.unsubscribe(), this.errors = void 0), v && (v.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;\n  }, u.prototype.notifyNext = function() {\n    var c = this._unsubscribe;\n    this._unsubscribe = null, this._unsubscribeAndRecycle(), this._unsubscribe = c, this.source.subscribe(this);\n  }, u;\n}(SimpleOuterSubscriber);\nfunction sample(a) {\n  return function(u) {\n    return u.lift(new SampleOperator(a));\n  };\n}\nvar SampleOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.notifier = u;\n  }\n  return a.prototype.call = function(u, c) {\n    var l = new SampleSubscriber(u), v = c.subscribe(l);\n    return v.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(l))), v;\n  }, a;\n}(), SampleSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u() {\n    var c = a !== null && a.apply(this, arguments) || this;\n    return c.hasValue = !1, c;\n  }\n  return u.prototype._next = function(c) {\n    this.value = c, this.hasValue = !0;\n  }, u.prototype.notifyNext = function() {\n    this.emitValue();\n  }, u.prototype.notifyComplete = function() {\n    this.emitValue();\n  }, u.prototype.emitValue = function() {\n    this.hasValue && (this.hasValue = !1, this.destination.next(this.value));\n  }, u;\n}(SimpleOuterSubscriber);\nfunction sampleTime(a, u) {\n  return u === void 0 && (u = async), function(c) {\n    return c.lift(new SampleTimeOperator(a, u));\n  };\n}\nvar SampleTimeOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.period = u, this.scheduler = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new SampleTimeSubscriber(u, this.period, this.scheduler));\n  }, a;\n}(), SampleTimeSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.period = l, S.scheduler = v, S.hasValue = !1, S.add(v.schedule(dispatchNotification, l, { subscriber: S, period: l })), S;\n  }\n  return u.prototype._next = function(c) {\n    this.lastValue = c, this.hasValue = !0;\n  }, u.prototype.notifyNext = function() {\n    this.hasValue && (this.hasValue = !1, this.destination.next(this.lastValue));\n  }, u;\n}(Subscriber);\nfunction dispatchNotification(a) {\n  var u = a.subscriber, c = a.period;\n  u.notifyNext(), this.schedule(a, c);\n}\nfunction sequenceEqual(a, u) {\n  return function(c) {\n    return c.lift(new SequenceEqualOperator(a, u));\n  };\n}\nvar SequenceEqualOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.compareTo = u, this.comparator = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new SequenceEqualSubscriber(u, this.compareTo, this.comparator));\n  }, a;\n}(), SequenceEqualSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.compareTo = l, S.comparator = v, S._a = [], S._b = [], S._oneComplete = !1, S.destination.add(l.subscribe(new SequenceEqualCompareToSubscriber(c, S))), S;\n  }\n  return u.prototype._next = function(c) {\n    this._oneComplete && this._b.length === 0 ? this.emit(!1) : (this._a.push(c), this.checkValues());\n  }, u.prototype._complete = function() {\n    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0, this.unsubscribe();\n  }, u.prototype.checkValues = function() {\n    for (var c = this, l = c._a, v = c._b, S = c.comparator; l.length > 0 && v.length > 0; ) {\n      var g = l.shift(), E = v.shift(), _ = !1;\n      try {\n        _ = S ? S(g, E) : g === E;\n      } catch (k) {\n        this.destination.error(k);\n      }\n      _ || this.emit(!1);\n    }\n  }, u.prototype.emit = function(c) {\n    var l = this.destination;\n    l.next(c), l.complete();\n  }, u.prototype.nextB = function(c) {\n    this._oneComplete && this._a.length === 0 ? this.emit(!1) : (this._b.push(c), this.checkValues());\n  }, u.prototype.completeB = function() {\n    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0;\n  }, u;\n}(Subscriber), SequenceEqualCompareToSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.parent = l, v;\n  }\n  return u.prototype._next = function(c) {\n    this.parent.nextB(c);\n  }, u.prototype._error = function(c) {\n    this.parent.error(c), this.unsubscribe();\n  }, u.prototype._complete = function() {\n    this.parent.completeB(), this.unsubscribe();\n  }, u;\n}(Subscriber);\nfunction shareSubjectFactory() {\n  return new Subject();\n}\nfunction share() {\n  return function(a) {\n    return refCount()(multicast(shareSubjectFactory)(a));\n  };\n}\nfunction shareReplay(a, u, c) {\n  var l;\n  return a && typeof a == \"object\" ? l = a : l = {\n    bufferSize: a,\n    windowTime: u,\n    refCount: !1,\n    scheduler: c\n  }, function(v) {\n    return v.lift(shareReplayOperator(l));\n  };\n}\nfunction shareReplayOperator(a) {\n  var u = a.bufferSize, c = u === void 0 ? Number.POSITIVE_INFINITY : u, l = a.windowTime, v = l === void 0 ? Number.POSITIVE_INFINITY : l, S = a.refCount, g = a.scheduler, E, _ = 0, k, L = !1, M = !1;\n  return function(J) {\n    _++;\n    var V;\n    !E || L ? (L = !1, E = new ReplaySubject(c, v, g), V = E.subscribe(this), k = J.subscribe({\n      next: function(q) {\n        E.next(q);\n      },\n      error: function(q) {\n        L = !0, E.error(q);\n      },\n      complete: function() {\n        M = !0, k = void 0, E.complete();\n      }\n    }), M && (k = void 0)) : V = E.subscribe(this), this.add(function() {\n      _--, V.unsubscribe(), V = void 0, k && !M && S && _ === 0 && (k.unsubscribe(), k = void 0, E = void 0);\n    });\n  };\n}\nfunction single(a) {\n  return function(u) {\n    return u.lift(new SingleOperator(a, u));\n  };\n}\nvar SingleOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.predicate = u, this.source = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new SingleSubscriber(u, this.predicate, this.source));\n  }, a;\n}(), SingleSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.predicate = l, S.source = v, S.seenValue = !1, S.index = 0, S;\n  }\n  return u.prototype.applySingleValue = function(c) {\n    this.seenValue ? this.destination.error(\"Sequence contains more than one element\") : (this.seenValue = !0, this.singleValue = c);\n  }, u.prototype._next = function(c) {\n    var l = this.index++;\n    this.predicate ? this.tryNext(c, l) : this.applySingleValue(c);\n  }, u.prototype.tryNext = function(c, l) {\n    try {\n      this.predicate(c, l, this.source) && this.applySingleValue(c);\n    } catch (v) {\n      this.destination.error(v);\n    }\n  }, u.prototype._complete = function() {\n    var c = this.destination;\n    this.index > 0 ? (c.next(this.seenValue ? this.singleValue : void 0), c.complete()) : c.error(new EmptyError());\n  }, u;\n}(Subscriber);\nfunction skip(a) {\n  return function(u) {\n    return u.lift(new SkipOperator(a));\n  };\n}\nvar SkipOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.total = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new SkipSubscriber(u, this.total));\n  }, a;\n}(), SkipSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.total = l, v.count = 0, v;\n  }\n  return u.prototype._next = function(c) {\n    ++this.count > this.total && this.destination.next(c);\n  }, u;\n}(Subscriber);\nfunction skipLast(a) {\n  return function(u) {\n    return u.lift(new SkipLastOperator(a));\n  };\n}\nvar SkipLastOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    if (this._skipCount = u, this._skipCount < 0)\n      throw new ArgumentOutOfRangeError();\n  }\n  return a.prototype.call = function(u, c) {\n    return this._skipCount === 0 ? c.subscribe(new Subscriber(u)) : c.subscribe(new SkipLastSubscriber(u, this._skipCount));\n  }, a;\n}(), SkipLastSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v._skipCount = l, v._count = 0, v._ring = new Array(l), v;\n  }\n  return u.prototype._next = function(c) {\n    var l = this._skipCount, v = this._count++;\n    if (v < l)\n      this._ring[v] = c;\n    else {\n      var S = v % l, g = this._ring, E = g[S];\n      g[S] = c, this.destination.next(E);\n    }\n  }, u;\n}(Subscriber);\nfunction skipUntil(a) {\n  return function(u) {\n    return u.lift(new SkipUntilOperator(a));\n  };\n}\nvar SkipUntilOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.notifier = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new SkipUntilSubscriber(u, this.notifier));\n  }, a;\n}(), SkipUntilSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    v.hasValue = !1;\n    var S = new SimpleInnerSubscriber(v);\n    v.add(S), v.innerSubscription = S;\n    var g = innerSubscribe(l, S);\n    return g !== S && (v.add(g), v.innerSubscription = g), v;\n  }\n  return u.prototype._next = function(c) {\n    this.hasValue && a.prototype._next.call(this, c);\n  }, u.prototype.notifyNext = function() {\n    this.hasValue = !0, this.innerSubscription && this.innerSubscription.unsubscribe();\n  }, u.prototype.notifyComplete = function() {\n  }, u;\n}(SimpleOuterSubscriber);\nfunction skipWhile(a) {\n  return function(u) {\n    return u.lift(new SkipWhileOperator(a));\n  };\n}\nvar SkipWhileOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.predicate = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new SkipWhileSubscriber(u, this.predicate));\n  }, a;\n}(), SkipWhileSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.predicate = l, v.skipping = !0, v.index = 0, v;\n  }\n  return u.prototype._next = function(c) {\n    var l = this.destination;\n    this.skipping && this.tryCallPredicate(c), this.skipping || l.next(c);\n  }, u.prototype.tryCallPredicate = function(c) {\n    try {\n      var l = this.predicate(c, this.index++);\n      this.skipping = !!l;\n    } catch (v) {\n      this.destination.error(v);\n    }\n  }, u;\n}(Subscriber);\nfunction startWith() {\n  for (var a = [], u = 0; u < arguments.length; u++)\n    a[u] = arguments[u];\n  var c = a[a.length - 1];\n  return isScheduler(c) ? (a.pop(), function(l) {\n    return concat$1(a, l, c);\n  }) : function(l) {\n    return concat$1(a, l);\n  };\n}\nvar nextHandle = 1, RESOLVED = /* @__PURE__ */ function() {\n  return /* @__PURE__ */ Promise.resolve();\n}(), activeHandles = {};\nfunction findAndClearHandle(a) {\n  return a in activeHandles ? (delete activeHandles[a], !0) : !1;\n}\nvar Immediate = {\n  setImmediate: function(a) {\n    var u = nextHandle++;\n    return activeHandles[u] = !0, RESOLVED.then(function() {\n      return findAndClearHandle(u) && a();\n    }), u;\n  },\n  clearImmediate: function(a) {\n    findAndClearHandle(a);\n  }\n}, AsapAction = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c, l) || this;\n    return v.scheduler = c, v.work = l, v;\n  }\n  return u.prototype.requestAsyncId = function(c, l, v) {\n    return v === void 0 && (v = 0), v !== null && v > 0 ? a.prototype.requestAsyncId.call(this, c, l, v) : (c.actions.push(this), c.scheduled || (c.scheduled = Immediate.setImmediate(c.flush.bind(c, null))));\n  }, u.prototype.recycleAsyncId = function(c, l, v) {\n    if (v === void 0 && (v = 0), v !== null && v > 0 || v === null && this.delay > 0)\n      return a.prototype.recycleAsyncId.call(this, c, l, v);\n    c.actions.length === 0 && (Immediate.clearImmediate(l), c.scheduled = void 0);\n  }, u;\n}(AsyncAction), AsapScheduler = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u() {\n    return a !== null && a.apply(this, arguments) || this;\n  }\n  return u.prototype.flush = function(c) {\n    this.active = !0, this.scheduled = void 0;\n    var l = this.actions, v, S = -1, g = l.length;\n    c = c || l.shift();\n    do\n      if (v = c.execute(c.state, c.delay))\n        break;\n    while (++S < g && (c = l.shift()));\n    if (this.active = !1, v) {\n      for (; ++S < g && (c = l.shift()); )\n        c.unsubscribe();\n      throw v;\n    }\n  }, u;\n}(AsyncScheduler), asapScheduler = /* @__PURE__ */ new AsapScheduler(AsapAction), asap = asapScheduler, SubscribeOnObservable = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    l === void 0 && (l = 0), v === void 0 && (v = asap);\n    var S = a.call(this) || this;\n    return S.source = c, S.delayTime = l, S.scheduler = v, (!isNumeric(l) || l < 0) && (S.delayTime = 0), (!v || typeof v.schedule != \"function\") && (S.scheduler = asap), S;\n  }\n  return u.create = function(c, l, v) {\n    return l === void 0 && (l = 0), v === void 0 && (v = asap), new u(c, l, v);\n  }, u.dispatch = function(c) {\n    var l = c.source, v = c.subscriber;\n    return this.add(l.subscribe(v));\n  }, u.prototype._subscribe = function(c) {\n    var l = this.delayTime, v = this.source, S = this.scheduler;\n    return S.schedule(u.dispatch, l, {\n      source: v,\n      subscriber: c\n    });\n  }, u;\n}(Observable);\nfunction subscribeOn(a, u) {\n  return u === void 0 && (u = 0), function(l) {\n    return l.lift(new SubscribeOnOperator(a, u));\n  };\n}\nvar SubscribeOnOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.scheduler = u, this.delay = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return new SubscribeOnObservable(c, this.delay, this.scheduler).subscribe(u);\n  }, a;\n}();\nfunction switchMap(a, u) {\n  return typeof u == \"function\" ? function(c) {\n    return c.pipe(switchMap(function(l, v) {\n      return from(a(l, v)).pipe(map(function(S, g) {\n        return u(l, S, v, g);\n      }));\n    }));\n  } : function(c) {\n    return c.lift(new SwitchMapOperator(a));\n  };\n}\nvar SwitchMapOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.project = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new SwitchMapSubscriber(u, this.project));\n  }, a;\n}(), SwitchMapSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.project = l, v.index = 0, v;\n  }\n  return u.prototype._next = function(c) {\n    var l, v = this.index++;\n    try {\n      l = this.project(c, v);\n    } catch (S) {\n      this.destination.error(S);\n      return;\n    }\n    this._innerSub(l);\n  }, u.prototype._innerSub = function(c) {\n    var l = this.innerSubscription;\n    l && l.unsubscribe();\n    var v = new SimpleInnerSubscriber(this), S = this.destination;\n    S.add(v), this.innerSubscription = innerSubscribe(c, v), this.innerSubscription !== v && S.add(this.innerSubscription);\n  }, u.prototype._complete = function() {\n    var c = this.innerSubscription;\n    (!c || c.closed) && a.prototype._complete.call(this), this.unsubscribe();\n  }, u.prototype._unsubscribe = function() {\n    this.innerSubscription = void 0;\n  }, u.prototype.notifyComplete = function() {\n    this.innerSubscription = void 0, this.isStopped && a.prototype._complete.call(this);\n  }, u.prototype.notifyNext = function(c) {\n    this.destination.next(c);\n  }, u;\n}(SimpleOuterSubscriber);\nfunction switchAll() {\n  return switchMap(identity);\n}\nfunction switchMapTo(a, u) {\n  return u ? switchMap(function() {\n    return a;\n  }, u) : switchMap(function() {\n    return a;\n  });\n}\nfunction takeUntil(a) {\n  return function(u) {\n    return u.lift(new TakeUntilOperator(a));\n  };\n}\nvar TakeUntilOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.notifier = u;\n  }\n  return a.prototype.call = function(u, c) {\n    var l = new TakeUntilSubscriber(u), v = innerSubscribe(this.notifier, new SimpleInnerSubscriber(l));\n    return v && !l.seenValue ? (l.add(v), c.subscribe(l)) : l;\n  }, a;\n}(), TakeUntilSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c) {\n    var l = a.call(this, c) || this;\n    return l.seenValue = !1, l;\n  }\n  return u.prototype.notifyNext = function() {\n    this.seenValue = !0, this.complete();\n  }, u.prototype.notifyComplete = function() {\n  }, u;\n}(SimpleOuterSubscriber);\nfunction takeWhile(a, u) {\n  return u === void 0 && (u = !1), function(c) {\n    return c.lift(new TakeWhileOperator(a, u));\n  };\n}\nvar TakeWhileOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.predicate = u, this.inclusive = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new TakeWhileSubscriber(u, this.predicate, this.inclusive));\n  }, a;\n}(), TakeWhileSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.predicate = l, S.inclusive = v, S.index = 0, S;\n  }\n  return u.prototype._next = function(c) {\n    var l = this.destination, v;\n    try {\n      v = this.predicate(c, this.index++);\n    } catch (S) {\n      l.error(S);\n      return;\n    }\n    this.nextOrComplete(c, v);\n  }, u.prototype.nextOrComplete = function(c, l) {\n    var v = this.destination;\n    l ? v.next(c) : (this.inclusive && v.next(c), v.complete());\n  }, u;\n}(Subscriber);\nfunction noop$1() {\n}\nfunction tap(a, u, c) {\n  return function(v) {\n    return v.lift(new DoOperator(a, u, c));\n  };\n}\nvar DoOperator = /* @__PURE__ */ function() {\n  function a(u, c, l) {\n    this.nextOrObserver = u, this.error = c, this.complete = l;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new TapSubscriber(u, this.nextOrObserver, this.error, this.complete));\n  }, a;\n}(), TapSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v, S) {\n    var g = a.call(this, c) || this;\n    return g._tapNext = noop$1, g._tapError = noop$1, g._tapComplete = noop$1, g._tapError = v || noop$1, g._tapComplete = S || noop$1, isFunction$2(l) ? (g._context = g, g._tapNext = l) : l && (g._context = l, g._tapNext = l.next || noop$1, g._tapError = l.error || noop$1, g._tapComplete = l.complete || noop$1), g;\n  }\n  return u.prototype._next = function(c) {\n    try {\n      this._tapNext.call(this._context, c);\n    } catch (l) {\n      this.destination.error(l);\n      return;\n    }\n    this.destination.next(c);\n  }, u.prototype._error = function(c) {\n    try {\n      this._tapError.call(this._context, c);\n    } catch (l) {\n      this.destination.error(l);\n      return;\n    }\n    this.destination.error(c);\n  }, u.prototype._complete = function() {\n    try {\n      this._tapComplete.call(this._context);\n    } catch (c) {\n      this.destination.error(c);\n      return;\n    }\n    return this.destination.complete();\n  }, u;\n}(Subscriber), defaultThrottleConfig = {\n  leading: !0,\n  trailing: !1\n};\nfunction throttle(a, u) {\n  return u === void 0 && (u = defaultThrottleConfig), function(c) {\n    return c.lift(new ThrottleOperator(a, !!u.leading, !!u.trailing));\n  };\n}\nvar ThrottleOperator = /* @__PURE__ */ function() {\n  function a(u, c, l) {\n    this.durationSelector = u, this.leading = c, this.trailing = l;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new ThrottleSubscriber(u, this.durationSelector, this.leading, this.trailing));\n  }, a;\n}(), ThrottleSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v, S) {\n    var g = a.call(this, c) || this;\n    return g.destination = c, g.durationSelector = l, g._leading = v, g._trailing = S, g._hasValue = !1, g;\n  }\n  return u.prototype._next = function(c) {\n    this._hasValue = !0, this._sendValue = c, this._throttled || (this._leading ? this.send() : this.throttle(c));\n  }, u.prototype.send = function() {\n    var c = this, l = c._hasValue, v = c._sendValue;\n    l && (this.destination.next(v), this.throttle(v)), this._hasValue = !1, this._sendValue = void 0;\n  }, u.prototype.throttle = function(c) {\n    var l = this.tryDurationSelector(c);\n    l && this.add(this._throttled = innerSubscribe(l, new SimpleInnerSubscriber(this)));\n  }, u.prototype.tryDurationSelector = function(c) {\n    try {\n      return this.durationSelector(c);\n    } catch (l) {\n      return this.destination.error(l), null;\n    }\n  }, u.prototype.throttlingDone = function() {\n    var c = this, l = c._throttled, v = c._trailing;\n    l && l.unsubscribe(), this._throttled = void 0, v && this.send();\n  }, u.prototype.notifyNext = function() {\n    this.throttlingDone();\n  }, u.prototype.notifyComplete = function() {\n    this.throttlingDone();\n  }, u;\n}(SimpleOuterSubscriber);\nfunction throttleTime(a, u, c) {\n  return u === void 0 && (u = async), c === void 0 && (c = defaultThrottleConfig), function(l) {\n    return l.lift(new ThrottleTimeOperator(a, u, c.leading, c.trailing));\n  };\n}\nvar ThrottleTimeOperator = /* @__PURE__ */ function() {\n  function a(u, c, l, v) {\n    this.duration = u, this.scheduler = c, this.leading = l, this.trailing = v;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new ThrottleTimeSubscriber(u, this.duration, this.scheduler, this.leading, this.trailing));\n  }, a;\n}(), ThrottleTimeSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v, S, g) {\n    var E = a.call(this, c) || this;\n    return E.duration = l, E.scheduler = v, E.leading = S, E.trailing = g, E._hasTrailingValue = !1, E._trailingValue = null, E;\n  }\n  return u.prototype._next = function(c) {\n    this.throttled ? this.trailing && (this._trailingValue = c, this._hasTrailingValue = !0) : (this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this })), this.leading ? this.destination.next(c) : this.trailing && (this._trailingValue = c, this._hasTrailingValue = !0));\n  }, u.prototype._complete = function() {\n    this._hasTrailingValue ? (this.destination.next(this._trailingValue), this.destination.complete()) : this.destination.complete();\n  }, u.prototype.clearThrottle = function() {\n    var c = this.throttled;\n    c && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue), this._trailingValue = null, this._hasTrailingValue = !1), c.unsubscribe(), this.remove(c), this.throttled = null);\n  }, u;\n}(Subscriber);\nfunction dispatchNext(a) {\n  var u = a.subscriber;\n  u.clearThrottle();\n}\nfunction defer(a) {\n  return new Observable(function(u) {\n    var c;\n    try {\n      c = a();\n    } catch (v) {\n      u.error(v);\n      return;\n    }\n    var l = c ? from(c) : empty$1();\n    return l.subscribe(u);\n  });\n}\nfunction timeInterval(a) {\n  return a === void 0 && (a = async), function(u) {\n    return defer(function() {\n      return u.pipe(scan(function(c, l) {\n        var v = c.current;\n        return { value: l, current: a.now(), last: v };\n      }, { current: a.now(), value: void 0, last: void 0 }), map(function(c) {\n        var l = c.current, v = c.last, S = c.value;\n        return new TimeInterval(S, l - v);\n      }));\n    });\n  };\n}\nvar TimeInterval = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.value = u, this.interval = c;\n  }\n  return a;\n}(), TimeoutErrorImpl = /* @__PURE__ */ function() {\n  function a() {\n    return Error.call(this), this.message = \"Timeout has occurred\", this.name = \"TimeoutError\", this;\n  }\n  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;\n}(), TimeoutError = TimeoutErrorImpl;\nfunction timeoutWith(a, u, c) {\n  return c === void 0 && (c = async), function(l) {\n    var v = isDate$1(a), S = v ? +a - c.now() : Math.abs(a);\n    return l.lift(new TimeoutWithOperator(S, v, u, c));\n  };\n}\nvar TimeoutWithOperator = /* @__PURE__ */ function() {\n  function a(u, c, l, v) {\n    this.waitFor = u, this.absoluteTimeout = c, this.withObservable = l, this.scheduler = v;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new TimeoutWithSubscriber(u, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n  }, a;\n}(), TimeoutWithSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v, S, g) {\n    var E = a.call(this, c) || this;\n    return E.absoluteTimeout = l, E.waitFor = v, E.withObservable = S, E.scheduler = g, E.scheduleTimeout(), E;\n  }\n  return u.dispatchTimeout = function(c) {\n    var l = c.withObservable;\n    c._unsubscribeAndRecycle(), c.add(innerSubscribe(l, new SimpleInnerSubscriber(c)));\n  }, u.prototype.scheduleTimeout = function() {\n    var c = this.action;\n    c ? this.action = c.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(u.dispatchTimeout, this.waitFor, this));\n  }, u.prototype._next = function(c) {\n    this.absoluteTimeout || this.scheduleTimeout(), a.prototype._next.call(this, c);\n  }, u.prototype._unsubscribe = function() {\n    this.action = void 0, this.scheduler = null, this.withObservable = null;\n  }, u;\n}(SimpleOuterSubscriber);\nfunction timeout(a, u) {\n  return u === void 0 && (u = async), timeoutWith(a, throwError(new TimeoutError()), u);\n}\nfunction timestamp$1(a) {\n  return a === void 0 && (a = async), map(function(u) {\n    return new Timestamp$1(u, a.now());\n  });\n}\nvar Timestamp$1 = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.value = u, this.timestamp = c;\n  }\n  return a;\n}();\nfunction toArrayReducer(a, u, c) {\n  return c === 0 ? [u] : (a.push(u), a);\n}\nfunction toArray() {\n  return reduce(toArrayReducer, []);\n}\nfunction window$1(a) {\n  return function(c) {\n    return c.lift(new WindowOperator$1(a));\n  };\n}\nvar WindowOperator$1 = /* @__PURE__ */ function() {\n  function a(u) {\n    this.windowBoundaries = u;\n  }\n  return a.prototype.call = function(u, c) {\n    var l = new WindowSubscriber$1(u), v = c.subscribe(l);\n    return v.closed || l.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(l))), v;\n  }, a;\n}(), WindowSubscriber$1 = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c) {\n    var l = a.call(this, c) || this;\n    return l.window = new Subject(), c.next(l.window), l;\n  }\n  return u.prototype.notifyNext = function() {\n    this.openWindow();\n  }, u.prototype.notifyError = function(c) {\n    this._error(c);\n  }, u.prototype.notifyComplete = function() {\n    this._complete();\n  }, u.prototype._next = function(c) {\n    this.window.next(c);\n  }, u.prototype._error = function(c) {\n    this.window.error(c), this.destination.error(c);\n  }, u.prototype._complete = function() {\n    this.window.complete(), this.destination.complete();\n  }, u.prototype._unsubscribe = function() {\n    this.window = null;\n  }, u.prototype.openWindow = function() {\n    var c = this.window;\n    c && c.complete();\n    var l = this.destination, v = this.window = new Subject();\n    l.next(v);\n  }, u;\n}(SimpleOuterSubscriber);\nfunction windowCount(a, u) {\n  return u === void 0 && (u = 0), function(l) {\n    return l.lift(new WindowCountOperator(a, u));\n  };\n}\nvar WindowCountOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.windowSize = u, this.startWindowEvery = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new WindowCountSubscriber(u, this.windowSize, this.startWindowEvery));\n  }, a;\n}(), WindowCountSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.destination = c, S.windowSize = l, S.startWindowEvery = v, S.windows = [new Subject()], S.count = 0, c.next(S.windows[0]), S;\n  }\n  return u.prototype._next = function(c) {\n    for (var l = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize, v = this.destination, S = this.windowSize, g = this.windows, E = g.length, _ = 0; _ < E && !this.closed; _++)\n      g[_].next(c);\n    var k = this.count - S + 1;\n    if (k >= 0 && k % l === 0 && !this.closed && g.shift().complete(), ++this.count % l === 0 && !this.closed) {\n      var L = new Subject();\n      g.push(L), v.next(L);\n    }\n  }, u.prototype._error = function(c) {\n    var l = this.windows;\n    if (l)\n      for (; l.length > 0 && !this.closed; )\n        l.shift().error(c);\n    this.destination.error(c);\n  }, u.prototype._complete = function() {\n    var c = this.windows;\n    if (c)\n      for (; c.length > 0 && !this.closed; )\n        c.shift().complete();\n    this.destination.complete();\n  }, u.prototype._unsubscribe = function() {\n    this.count = 0, this.windows = null;\n  }, u;\n}(Subscriber);\nfunction windowTime(a) {\n  var u = async, c = null, l = Number.POSITIVE_INFINITY;\n  return isScheduler(arguments[3]) && (u = arguments[3]), isScheduler(arguments[2]) ? u = arguments[2] : isNumeric(arguments[2]) && (l = Number(arguments[2])), isScheduler(arguments[1]) ? u = arguments[1] : isNumeric(arguments[1]) && (c = Number(arguments[1])), function(S) {\n    return S.lift(new WindowTimeOperator(a, c, l, u));\n  };\n}\nvar WindowTimeOperator = /* @__PURE__ */ function() {\n  function a(u, c, l, v) {\n    this.windowTimeSpan = u, this.windowCreationInterval = c, this.maxWindowSize = l, this.scheduler = v;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new WindowTimeSubscriber(u, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n  }, a;\n}(), CountedSubject = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u() {\n    var c = a !== null && a.apply(this, arguments) || this;\n    return c._numberOfNextedValues = 0, c;\n  }\n  return u.prototype.next = function(c) {\n    this._numberOfNextedValues++, a.prototype.next.call(this, c);\n  }, Object.defineProperty(u.prototype, \"numberOfNextedValues\", {\n    get: function() {\n      return this._numberOfNextedValues;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), u;\n}(Subject), WindowTimeSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v, S, g) {\n    var E = a.call(this, c) || this;\n    E.destination = c, E.windowTimeSpan = l, E.windowCreationInterval = v, E.maxWindowSize = S, E.scheduler = g, E.windows = [];\n    var _ = E.openWindow();\n    if (v !== null && v >= 0) {\n      var k = { subscriber: E, window: _, context: null }, L = { windowTimeSpan: l, windowCreationInterval: v, subscriber: E, scheduler: g };\n      E.add(g.schedule(dispatchWindowClose, l, k)), E.add(g.schedule(dispatchWindowCreation, v, L));\n    } else {\n      var M = { subscriber: E, window: _, windowTimeSpan: l };\n      E.add(g.schedule(dispatchWindowTimeSpanOnly, l, M));\n    }\n    return E;\n  }\n  return u.prototype._next = function(c) {\n    for (var l = this.windows, v = l.length, S = 0; S < v; S++) {\n      var g = l[S];\n      g.closed || (g.next(c), g.numberOfNextedValues >= this.maxWindowSize && this.closeWindow(g));\n    }\n  }, u.prototype._error = function(c) {\n    for (var l = this.windows; l.length > 0; )\n      l.shift().error(c);\n    this.destination.error(c);\n  }, u.prototype._complete = function() {\n    for (var c = this.windows; c.length > 0; ) {\n      var l = c.shift();\n      l.closed || l.complete();\n    }\n    this.destination.complete();\n  }, u.prototype.openWindow = function() {\n    var c = new CountedSubject();\n    this.windows.push(c);\n    var l = this.destination;\n    return l.next(c), c;\n  }, u.prototype.closeWindow = function(c) {\n    c.complete();\n    var l = this.windows;\n    l.splice(l.indexOf(c), 1);\n  }, u;\n}(Subscriber);\nfunction dispatchWindowTimeSpanOnly(a) {\n  var u = a.subscriber, c = a.windowTimeSpan, l = a.window;\n  l && u.closeWindow(l), a.window = u.openWindow(), this.schedule(a, c);\n}\nfunction dispatchWindowCreation(a) {\n  var u = a.windowTimeSpan, c = a.subscriber, l = a.scheduler, v = a.windowCreationInterval, S = c.openWindow(), g = this, E = { action: g, subscription: null }, _ = { subscriber: c, window: S, context: E };\n  E.subscription = l.schedule(dispatchWindowClose, u, _), g.add(E.subscription), g.schedule(a, v);\n}\nfunction dispatchWindowClose(a) {\n  var u = a.subscriber, c = a.window, l = a.context;\n  l && l.action && l.subscription && l.action.remove(l.subscription), u.closeWindow(c);\n}\nfunction windowToggle(a, u) {\n  return function(c) {\n    return c.lift(new WindowToggleOperator(a, u));\n  };\n}\nvar WindowToggleOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.openings = u, this.closingSelector = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new WindowToggleSubscriber(u, this.openings, this.closingSelector));\n  }, a;\n}(), WindowToggleSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.openings = l, S.closingSelector = v, S.contexts = [], S.add(S.openSubscription = subscribeToResult(S, l, l)), S;\n  }\n  return u.prototype._next = function(c) {\n    var l = this.contexts;\n    if (l)\n      for (var v = l.length, S = 0; S < v; S++)\n        l[S].window.next(c);\n  }, u.prototype._error = function(c) {\n    var l = this.contexts;\n    if (this.contexts = null, l)\n      for (var v = l.length, S = -1; ++S < v; ) {\n        var g = l[S];\n        g.window.error(c), g.subscription.unsubscribe();\n      }\n    a.prototype._error.call(this, c);\n  }, u.prototype._complete = function() {\n    var c = this.contexts;\n    if (this.contexts = null, c)\n      for (var l = c.length, v = -1; ++v < l; ) {\n        var S = c[v];\n        S.window.complete(), S.subscription.unsubscribe();\n      }\n    a.prototype._complete.call(this);\n  }, u.prototype._unsubscribe = function() {\n    var c = this.contexts;\n    if (this.contexts = null, c)\n      for (var l = c.length, v = -1; ++v < l; ) {\n        var S = c[v];\n        S.window.unsubscribe(), S.subscription.unsubscribe();\n      }\n  }, u.prototype.notifyNext = function(c, l, v, S, g) {\n    if (c === this.openings) {\n      var E = void 0;\n      try {\n        var _ = this.closingSelector;\n        E = _(l);\n      } catch (J) {\n        return this.error(J);\n      }\n      var k = new Subject(), L = new Subscription(), M = { window: k, subscription: L };\n      this.contexts.push(M);\n      var $ = subscribeToResult(this, E, M);\n      $.closed ? this.closeWindow(this.contexts.length - 1) : ($.context = M, L.add($)), this.destination.next(k);\n    } else\n      this.closeWindow(this.contexts.indexOf(c));\n  }, u.prototype.notifyError = function(c) {\n    this.error(c);\n  }, u.prototype.notifyComplete = function(c) {\n    c !== this.openSubscription && this.closeWindow(this.contexts.indexOf(c.context));\n  }, u.prototype.closeWindow = function(c) {\n    if (c !== -1) {\n      var l = this.contexts, v = l[c], S = v.window, g = v.subscription;\n      l.splice(c, 1), S.complete(), g.unsubscribe();\n    }\n  }, u;\n}(OuterSubscriber);\nfunction windowWhen(a) {\n  return function(c) {\n    return c.lift(new WindowOperator(a));\n  };\n}\nvar WindowOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.closingSelector = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new WindowSubscriber(u, this.closingSelector));\n  }, a;\n}(), WindowSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l) {\n    var v = a.call(this, c) || this;\n    return v.destination = c, v.closingSelector = l, v.openWindow(), v;\n  }\n  return u.prototype.notifyNext = function(c, l, v, S, g) {\n    this.openWindow(g);\n  }, u.prototype.notifyError = function(c) {\n    this._error(c);\n  }, u.prototype.notifyComplete = function(c) {\n    this.openWindow(c);\n  }, u.prototype._next = function(c) {\n    this.window.next(c);\n  }, u.prototype._error = function(c) {\n    this.window.error(c), this.destination.error(c), this.unsubscribeClosingNotification();\n  }, u.prototype._complete = function() {\n    this.window.complete(), this.destination.complete(), this.unsubscribeClosingNotification();\n  }, u.prototype.unsubscribeClosingNotification = function() {\n    this.closingNotification && this.closingNotification.unsubscribe();\n  }, u.prototype.openWindow = function(c) {\n    c === void 0 && (c = null), c && (this.remove(c), c.unsubscribe());\n    var l = this.window;\n    l && l.complete();\n    var v = this.window = new Subject();\n    this.destination.next(v);\n    var S;\n    try {\n      var g = this.closingSelector;\n      S = g();\n    } catch (E) {\n      this.destination.error(E), this.window.error(E);\n      return;\n    }\n    this.add(this.closingNotification = subscribeToResult(this, S));\n  }, u;\n}(OuterSubscriber);\nfunction withLatestFrom() {\n  for (var a = [], u = 0; u < arguments.length; u++)\n    a[u] = arguments[u];\n  return function(c) {\n    var l;\n    typeof a[a.length - 1] == \"function\" && (l = a.pop());\n    var v = a;\n    return c.lift(new WithLatestFromOperator(v, l));\n  };\n}\nvar WithLatestFromOperator = /* @__PURE__ */ function() {\n  function a(u, c) {\n    this.observables = u, this.project = c;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new WithLatestFromSubscriber(u, this.observables, this.project));\n  }, a;\n}(), WithLatestFromSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    S.observables = l, S.project = v, S.toRespond = [];\n    var g = l.length;\n    S.values = new Array(g);\n    for (var E = 0; E < g; E++)\n      S.toRespond.push(E);\n    for (var E = 0; E < g; E++) {\n      var _ = l[E];\n      S.add(subscribeToResult(S, _, void 0, E));\n    }\n    return S;\n  }\n  return u.prototype.notifyNext = function(c, l, v) {\n    this.values[v] = l;\n    var S = this.toRespond;\n    if (S.length > 0) {\n      var g = S.indexOf(v);\n      g !== -1 && S.splice(g, 1);\n    }\n  }, u.prototype.notifyComplete = function() {\n  }, u.prototype._next = function(c) {\n    if (this.toRespond.length === 0) {\n      var l = [c].concat(this.values);\n      this.project ? this._tryProject(l) : this.destination.next(l);\n    }\n  }, u.prototype._tryProject = function(c) {\n    var l;\n    try {\n      l = this.project.apply(this, c);\n    } catch (v) {\n      this.destination.error(v);\n      return;\n    }\n    this.destination.next(l);\n  }, u;\n}(OuterSubscriber);\nfunction zip$1() {\n  for (var a = [], u = 0; u < arguments.length; u++)\n    a[u] = arguments[u];\n  var c = a[a.length - 1];\n  return typeof c == \"function\" && a.pop(), fromArray(a, void 0).lift(new ZipOperator(c));\n}\nvar ZipOperator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.resultSelector = u;\n  }\n  return a.prototype.call = function(u, c) {\n    return c.subscribe(new ZipSubscriber(u, this.resultSelector));\n  }, a;\n}(), ZipSubscriber = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.resultSelector = l, S.iterators = [], S.active = 0, S.resultSelector = typeof l == \"function\" ? l : void 0, S;\n  }\n  return u.prototype._next = function(c) {\n    var l = this.iterators;\n    isArray$4(c) ? l.push(new StaticArrayIterator(c)) : typeof c[iterator] == \"function\" ? l.push(new StaticIterator(c[iterator]())) : l.push(new ZipBufferIterator(this.destination, this, c));\n  }, u.prototype._complete = function() {\n    var c = this.iterators, l = c.length;\n    if (this.unsubscribe(), l === 0) {\n      this.destination.complete();\n      return;\n    }\n    this.active = l;\n    for (var v = 0; v < l; v++) {\n      var S = c[v];\n      if (S.stillUnsubscribed) {\n        var g = this.destination;\n        g.add(S.subscribe());\n      } else\n        this.active--;\n    }\n  }, u.prototype.notifyInactive = function() {\n    this.active--, this.active === 0 && this.destination.complete();\n  }, u.prototype.checkIterators = function() {\n    for (var c = this.iterators, l = c.length, v = this.destination, S = 0; S < l; S++) {\n      var g = c[S];\n      if (typeof g.hasValue == \"function\" && !g.hasValue())\n        return;\n    }\n    for (var E = !1, _ = [], S = 0; S < l; S++) {\n      var g = c[S], k = g.next();\n      if (g.hasCompleted() && (E = !0), k.done) {\n        v.complete();\n        return;\n      }\n      _.push(k.value);\n    }\n    this.resultSelector ? this._tryresultSelector(_) : v.next(_), E && v.complete();\n  }, u.prototype._tryresultSelector = function(c) {\n    var l;\n    try {\n      l = this.resultSelector.apply(this, c);\n    } catch (v) {\n      this.destination.error(v);\n      return;\n    }\n    this.destination.next(l);\n  }, u;\n}(Subscriber), StaticIterator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.iterator = u, this.nextResult = u.next();\n  }\n  return a.prototype.hasValue = function() {\n    return !0;\n  }, a.prototype.next = function() {\n    var u = this.nextResult;\n    return this.nextResult = this.iterator.next(), u;\n  }, a.prototype.hasCompleted = function() {\n    var u = this.nextResult;\n    return !!(u && u.done);\n  }, a;\n}(), StaticArrayIterator = /* @__PURE__ */ function() {\n  function a(u) {\n    this.array = u, this.index = 0, this.length = 0, this.length = u.length;\n  }\n  return a.prototype[iterator] = function() {\n    return this;\n  }, a.prototype.next = function(u) {\n    var c = this.index++, l = this.array;\n    return c < this.length ? { value: l[c], done: !1 } : { value: null, done: !0 };\n  }, a.prototype.hasValue = function() {\n    return this.array.length > this.index;\n  }, a.prototype.hasCompleted = function() {\n    return this.array.length === this.index;\n  }, a;\n}(), ZipBufferIterator = /* @__PURE__ */ function(a) {\n  __extends(u, a);\n  function u(c, l, v) {\n    var S = a.call(this, c) || this;\n    return S.parent = l, S.observable = v, S.stillUnsubscribed = !0, S.buffer = [], S.isComplete = !1, S;\n  }\n  return u.prototype[iterator] = function() {\n    return this;\n  }, u.prototype.next = function() {\n    var c = this.buffer;\n    return c.length === 0 && this.isComplete ? { value: null, done: !0 } : { value: c.shift(), done: !1 };\n  }, u.prototype.hasValue = function() {\n    return this.buffer.length > 0;\n  }, u.prototype.hasCompleted = function() {\n    return this.buffer.length === 0 && this.isComplete;\n  }, u.prototype.notifyComplete = function() {\n    this.buffer.length > 0 ? (this.isComplete = !0, this.parent.notifyInactive()) : this.destination.complete();\n  }, u.prototype.notifyNext = function(c) {\n    this.buffer.push(c), this.parent.checkIterators();\n  }, u.prototype.subscribe = function() {\n    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));\n  }, u;\n}(SimpleOuterSubscriber);\nfunction zip() {\n  for (var a = [], u = 0; u < arguments.length; u++)\n    a[u] = arguments[u];\n  return function(l) {\n    return l.lift.call(zip$1.apply(void 0, [l].concat(a)));\n  };\n}\nfunction zipAll(a) {\n  return function(u) {\n    return u.lift(new ZipOperator(a));\n  };\n}\nconst operators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  audit,\n  auditTime,\n  buffer,\n  bufferCount,\n  bufferTime,\n  bufferToggle,\n  bufferWhen,\n  catchError,\n  combineAll,\n  combineLatest,\n  concat,\n  concatAll,\n  concatMap,\n  concatMapTo,\n  count,\n  debounce,\n  debounceTime,\n  defaultIfEmpty,\n  delay,\n  delayWhen,\n  dematerialize,\n  distinct,\n  distinctUntilChanged,\n  distinctUntilKeyChanged,\n  elementAt,\n  endWith,\n  every,\n  exhaust,\n  exhaustMap,\n  expand,\n  filter,\n  finalize,\n  find: find$1,\n  findIndex,\n  first,\n  flatMap,\n  groupBy,\n  ignoreElements,\n  isEmpty,\n  last,\n  map,\n  mapTo,\n  materialize,\n  max,\n  merge: merge$1,\n  mergeAll,\n  mergeMap,\n  mergeMapTo,\n  mergeScan,\n  min,\n  multicast,\n  observeOn,\n  onErrorResumeNext,\n  pairwise,\n  partition,\n  pluck,\n  publish,\n  publishBehavior,\n  publishLast,\n  publishReplay,\n  race,\n  reduce,\n  refCount,\n  repeat,\n  repeatWhen,\n  retry,\n  retryWhen,\n  sample,\n  sampleTime,\n  scan,\n  sequenceEqual,\n  share,\n  shareReplay,\n  single,\n  skip,\n  skipLast,\n  skipUntil,\n  skipWhile,\n  startWith,\n  subscribeOn,\n  switchAll,\n  switchMap,\n  switchMapTo,\n  take,\n  takeLast,\n  takeUntil,\n  takeWhile,\n  tap,\n  throttle,\n  throttleTime,\n  throwIfEmpty,\n  timeInterval,\n  timeout,\n  timeoutWith,\n  timestamp: timestamp$1,\n  toArray,\n  window: window$1,\n  windowCount,\n  windowTime,\n  windowToggle,\n  windowWhen,\n  withLatestFrom,\n  zip,\n  zipAll\n}, Symbol.toStringTag, { value: \"Module\" })), require$$2 = /* @__PURE__ */ getAugmentedNamespace(operators);\nvar struct = {};\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(B, Y, ne, Z) {\n    Z === void 0 && (Z = ne), Object.defineProperty(B, Z, { enumerable: !0, get: function() {\n      return Y[ne];\n    } });\n  } : function(B, Y, ne, Z) {\n    Z === void 0 && (Z = ne), B[Z] = Y[ne];\n  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(B, Y) {\n    Object.defineProperty(B, \"default\", { enumerable: !0, value: Y });\n  } : function(B, Y) {\n    B.default = Y;\n  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(B) {\n    if (B && B.__esModule)\n      return B;\n    var Y = {};\n    if (B != null)\n      for (var ne in B)\n        ne !== \"default\" && Object.hasOwnProperty.call(B, ne) && u(Y, B, ne);\n    return c(Y, B), Y;\n  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(B) {\n    return B && B.__esModule ? B : { default: B };\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;\n  const S = v(umdExports), g = l(minimal);\n  a.protobufPackage = \"google.protobuf\";\n  var E;\n  (function(B) {\n    B.NULL_VALUE = \"NULL_VALUE\";\n  })(E = a.NullValue || (a.NullValue = {}));\n  function _(B) {\n    switch (B) {\n      case 0:\n      case \"NULL_VALUE\":\n        return E.NULL_VALUE;\n      default:\n        throw new q.Error(\"Unrecognized enum value \" + B + \" for enum NullValue\");\n    }\n  }\n  a.nullValueFromJSON = _;\n  function k(B) {\n    switch (B) {\n      case E.NULL_VALUE:\n        return \"NULL_VALUE\";\n      default:\n        return \"UNKNOWN\";\n    }\n  }\n  a.nullValueToJSON = k;\n  function L(B) {\n    switch (B) {\n      case E.NULL_VALUE:\n        return 0;\n      default:\n        return 0;\n    }\n  }\n  a.nullValueToNumber = L;\n  function M() {\n    return { fields: {} };\n  }\n  a.Struct = {\n    encode(B, Y = g.Writer.create()) {\n      return Object.entries(B.fields).forEach(([ne, Z]) => {\n        Z !== void 0 && a.Struct_FieldsEntry.encode({ key: ne, value: Z }, Y.uint32(10).fork()).ldelim();\n      }), Y;\n    },\n    decode(B, Y) {\n      const ne = B instanceof g.Reader ? B : new g.Reader(B);\n      let Z = Y === void 0 ? ne.len : ne.pos + Y;\n      const re = M();\n      for (; ne.pos < Z; ) {\n        const oe = ne.uint32();\n        switch (oe >>> 3) {\n          case 1:\n            const de = a.Struct_FieldsEntry.decode(ne, ne.uint32());\n            de.value !== void 0 && (re.fields[de.key] = de.value);\n            break;\n          default:\n            ne.skipType(oe & 7);\n            break;\n        }\n      }\n      return re;\n    },\n    fromJSON(B) {\n      return {\n        fields: G(B.fields) ? Object.entries(B.fields).reduce((Y, [ne, Z]) => (Y[ne] = Z, Y), {}) : {}\n      };\n    },\n    toJSON(B) {\n      const Y = {};\n      return Y.fields = {}, B.fields && Object.entries(B.fields).forEach(([ne, Z]) => {\n        Y.fields[ne] = Z;\n      }), Y;\n    },\n    fromPartial(B) {\n      var Y;\n      const ne = M();\n      return ne.fields = Object.entries((Y = B.fields) !== null && Y !== void 0 ? Y : {}).reduce((Z, [re, oe]) => (oe !== void 0 && (Z[re] = oe), Z), {}), ne;\n    },\n    wrap(B) {\n      const Y = M();\n      return B !== void 0 && Object.keys(B).forEach((ne) => {\n        Y.fields[ne] = B[ne];\n      }), Y;\n    },\n    unwrap(B) {\n      const Y = {};\n      return Object.keys(B.fields).forEach((ne) => {\n        Y[ne] = B.fields[ne];\n      }), Y;\n    }\n  };\n  function $() {\n    return { key: \"\", value: void 0 };\n  }\n  a.Struct_FieldsEntry = {\n    encode(B, Y = g.Writer.create()) {\n      return B.key !== \"\" && Y.uint32(10).string(B.key), B.value !== void 0 && a.Value.encode(a.Value.wrap(B.value), Y.uint32(18).fork()).ldelim(), Y;\n    },\n    decode(B, Y) {\n      const ne = B instanceof g.Reader ? B : new g.Reader(B);\n      let Z = Y === void 0 ? ne.len : ne.pos + Y;\n      const re = $();\n      for (; ne.pos < Z; ) {\n        const oe = ne.uint32();\n        switch (oe >>> 3) {\n          case 1:\n            re.key = ne.string();\n            break;\n          case 2:\n            re.value = a.Value.unwrap(a.Value.decode(ne, ne.uint32()));\n            break;\n          default:\n            ne.skipType(oe & 7);\n            break;\n        }\n      }\n      return re;\n    },\n    fromJSON(B) {\n      return {\n        key: H(B.key) ? String(B.key) : \"\",\n        value: H(B == null ? void 0 : B.value) ? B.value : void 0\n      };\n    },\n    toJSON(B) {\n      const Y = {};\n      return B.key !== void 0 && (Y.key = B.key), B.value !== void 0 && (Y.value = B.value), Y;\n    },\n    fromPartial(B) {\n      var Y, ne;\n      const Z = $();\n      return Z.key = (Y = B.key) !== null && Y !== void 0 ? Y : \"\", Z.value = (ne = B.value) !== null && ne !== void 0 ? ne : void 0, Z;\n    }\n  };\n  function J() {\n    return {\n      nullValue: void 0,\n      numberValue: void 0,\n      stringValue: void 0,\n      boolValue: void 0,\n      structValue: void 0,\n      listValue: void 0\n    };\n  }\n  a.Value = {\n    encode(B, Y = g.Writer.create()) {\n      return B.nullValue !== void 0 && Y.uint32(8).int32(L(B.nullValue)), B.numberValue !== void 0 && Y.uint32(17).double(B.numberValue), B.stringValue !== void 0 && Y.uint32(26).string(B.stringValue), B.boolValue !== void 0 && Y.uint32(32).bool(B.boolValue), B.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(B.structValue), Y.uint32(42).fork()).ldelim(), B.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(B.listValue), Y.uint32(50).fork()).ldelim(), Y;\n    },\n    decode(B, Y) {\n      const ne = B instanceof g.Reader ? B : new g.Reader(B);\n      let Z = Y === void 0 ? ne.len : ne.pos + Y;\n      const re = J();\n      for (; ne.pos < Z; ) {\n        const oe = ne.uint32();\n        switch (oe >>> 3) {\n          case 1:\n            re.nullValue = _(ne.int32());\n            break;\n          case 2:\n            re.numberValue = ne.double();\n            break;\n          case 3:\n            re.stringValue = ne.string();\n            break;\n          case 4:\n            re.boolValue = ne.bool();\n            break;\n          case 5:\n            re.structValue = a.Struct.unwrap(a.Struct.decode(ne, ne.uint32()));\n            break;\n          case 6:\n            re.listValue = a.ListValue.unwrap(a.ListValue.decode(ne, ne.uint32()));\n            break;\n          default:\n            ne.skipType(oe & 7);\n            break;\n        }\n      }\n      return re;\n    },\n    fromJSON(B) {\n      return {\n        nullValue: H(B.nullValue) ? _(B.nullValue) : void 0,\n        numberValue: H(B.numberValue) ? Number(B.numberValue) : void 0,\n        stringValue: H(B.stringValue) ? String(B.stringValue) : void 0,\n        boolValue: H(B.boolValue) ? !!B.boolValue : void 0,\n        structValue: G(B.structValue) ? B.structValue : void 0,\n        listValue: Array.isArray(B.listValue) ? [...B.listValue] : void 0\n      };\n    },\n    toJSON(B) {\n      const Y = {};\n      return B.nullValue !== void 0 && (Y.nullValue = B.nullValue !== void 0 ? k(B.nullValue) : void 0), B.numberValue !== void 0 && (Y.numberValue = B.numberValue), B.stringValue !== void 0 && (Y.stringValue = B.stringValue), B.boolValue !== void 0 && (Y.boolValue = B.boolValue), B.structValue !== void 0 && (Y.structValue = B.structValue), B.listValue !== void 0 && (Y.listValue = B.listValue), Y;\n    },\n    fromPartial(B) {\n      var Y, ne, Z, re, oe, de;\n      const A = J();\n      return A.nullValue = (Y = B.nullValue) !== null && Y !== void 0 ? Y : void 0, A.numberValue = (ne = B.numberValue) !== null && ne !== void 0 ? ne : void 0, A.stringValue = (Z = B.stringValue) !== null && Z !== void 0 ? Z : void 0, A.boolValue = (re = B.boolValue) !== null && re !== void 0 ? re : void 0, A.structValue = (oe = B.structValue) !== null && oe !== void 0 ? oe : void 0, A.listValue = (de = B.listValue) !== null && de !== void 0 ? de : void 0, A;\n    },\n    wrap(B) {\n      const Y = J();\n      if (B === null)\n        Y.nullValue = E.NULL_VALUE;\n      else if (typeof B == \"boolean\")\n        Y.boolValue = B;\n      else if (typeof B == \"number\")\n        Y.numberValue = B;\n      else if (typeof B == \"string\")\n        Y.stringValue = B;\n      else if (Array.isArray(B))\n        Y.listValue = B;\n      else if (typeof B == \"object\")\n        Y.structValue = B;\n      else if (typeof B < \"u\")\n        throw new Error(\"Unsupported any value type: \" + typeof B);\n      return Y;\n    },\n    unwrap(B) {\n      if ((B == null ? void 0 : B.stringValue) !== void 0)\n        return B.stringValue;\n      if ((B == null ? void 0 : B.numberValue) !== void 0)\n        return B.numberValue;\n      if ((B == null ? void 0 : B.boolValue) !== void 0)\n        return B.boolValue;\n      if ((B == null ? void 0 : B.structValue) !== void 0)\n        return B.structValue;\n      if ((B == null ? void 0 : B.listValue) !== void 0)\n        return B.listValue;\n      if ((B == null ? void 0 : B.nullValue) !== void 0)\n        return null;\n    }\n  };\n  function V() {\n    return { values: [] };\n  }\n  a.ListValue = {\n    encode(B, Y = g.Writer.create()) {\n      for (const ne of B.values)\n        a.Value.encode(a.Value.wrap(ne), Y.uint32(10).fork()).ldelim();\n      return Y;\n    },\n    decode(B, Y) {\n      const ne = B instanceof g.Reader ? B : new g.Reader(B);\n      let Z = Y === void 0 ? ne.len : ne.pos + Y;\n      const re = V();\n      for (; ne.pos < Z; ) {\n        const oe = ne.uint32();\n        switch (oe >>> 3) {\n          case 1:\n            re.values.push(a.Value.unwrap(a.Value.decode(ne, ne.uint32())));\n            break;\n          default:\n            ne.skipType(oe & 7);\n            break;\n        }\n      }\n      return re;\n    },\n    fromJSON(B) {\n      return {\n        values: Array.isArray(B == null ? void 0 : B.values) ? [...B.values] : []\n      };\n    },\n    toJSON(B) {\n      const Y = {};\n      return B.values ? Y.values = B.values.map((ne) => ne) : Y.values = [], Y;\n    },\n    fromPartial(B) {\n      var Y;\n      const ne = V();\n      return ne.values = ((Y = B.values) === null || Y === void 0 ? void 0 : Y.map((Z) => Z)) || [], ne;\n    },\n    wrap(B) {\n      const Y = V();\n      return Y.values = B ?? [], Y;\n    },\n    unwrap(B) {\n      return B.values;\n    }\n  };\n  var q = (() => {\n    if (typeof q < \"u\")\n      return q;\n    if (typeof self < \"u\")\n      return self;\n    if (typeof window < \"u\")\n      return window;\n    if (typeof commonjsGlobal$1 < \"u\")\n      return commonjsGlobal$1;\n    throw \"Unable to locate global object\";\n  })();\n  g.util.Long !== S.default && (g.util.Long = S.default, g.configure());\n  function G(B) {\n    return typeof B == \"object\" && B !== null;\n  }\n  function H(B) {\n    return B != null;\n  }\n})(struct);\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(A, N, D, W) {\n    W === void 0 && (W = D), Object.defineProperty(A, W, { enumerable: !0, get: function() {\n      return N[D];\n    } });\n  } : function(A, N, D, W) {\n    W === void 0 && (W = D), A[W] = N[D];\n  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(A, N) {\n    Object.defineProperty(A, \"default\", { enumerable: !0, value: N });\n  } : function(A, N) {\n    A.default = N;\n  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(A) {\n    if (A && A.__esModule)\n      return A;\n    var N = {};\n    if (A != null)\n      for (var D in A)\n        D !== \"default\" && Object.hasOwnProperty.call(A, D) && u(N, A, D);\n    return c(N, A), N;\n  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(A) {\n    return A && A.__esModule ? A : { default: A };\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.EventServiceDefinition = a.EventServiceClientImpl = a.EventsStreamResponse = a.EventsStreamRequest = a.EventsStreamReconnectRequest = a.EventsStreamError = a.SubscribePayload = a.PublishEventResponse = a.PublishEventRequest = a.EventTarget = a.eventsStreamMessageTypeToNumber = a.eventsStreamMessageTypeToJSON = a.eventsStreamMessageTypeFromJSON = a.EventsStreamMessageType = a.protobufPackage = void 0;\n  const S = v(umdExports), g = l(minimal), E = require$$2, _ = struct;\n  a.protobufPackage = \"apis.event.v2\";\n  var k;\n  (function(A) {\n    A.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED = \"EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED\", A.EVENTS_STREAM_MESSAGE_TYPE_PING = \"EVENTS_STREAM_MESSAGE_TYPE_PING\", A.EVENTS_STREAM_MESSAGE_TYPE_ERROR = \"EVENTS_STREAM_MESSAGE_TYPE_ERROR\", A.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED = \"EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED\", A.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED = \"EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED\", A.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED = \"EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED\";\n  })(k = a.EventsStreamMessageType || (a.EventsStreamMessageType = {}));\n  function L(A) {\n    switch (A) {\n      case 0:\n      case \"EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED\":\n        return k.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED;\n      case 1:\n      case \"EVENTS_STREAM_MESSAGE_TYPE_PING\":\n        return k.EVENTS_STREAM_MESSAGE_TYPE_PING;\n      case 2:\n      case \"EVENTS_STREAM_MESSAGE_TYPE_ERROR\":\n        return k.EVENTS_STREAM_MESSAGE_TYPE_ERROR;\n      case 3:\n      case \"EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED\":\n        return k.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED;\n      case 4:\n      case \"EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED\":\n        return k.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED;\n      case 5:\n      case \"EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED\":\n        return k.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED;\n      default:\n        throw new re.Error(\"Unrecognized enum value \" + A + \" for enum EventsStreamMessageType\");\n    }\n  }\n  a.eventsStreamMessageTypeFromJSON = L;\n  function M(A) {\n    switch (A) {\n      case k.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED:\n        return \"EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED\";\n      case k.EVENTS_STREAM_MESSAGE_TYPE_PING:\n        return \"EVENTS_STREAM_MESSAGE_TYPE_PING\";\n      case k.EVENTS_STREAM_MESSAGE_TYPE_ERROR:\n        return \"EVENTS_STREAM_MESSAGE_TYPE_ERROR\";\n      case k.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED:\n        return \"EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED\";\n      case k.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED:\n        return \"EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED\";\n      case k.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED:\n        return \"EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED\";\n      default:\n        return \"UNKNOWN\";\n    }\n  }\n  a.eventsStreamMessageTypeToJSON = M;\n  function $(A) {\n    switch (A) {\n      case k.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED:\n        return 0;\n      case k.EVENTS_STREAM_MESSAGE_TYPE_PING:\n        return 1;\n      case k.EVENTS_STREAM_MESSAGE_TYPE_ERROR:\n        return 2;\n      case k.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED:\n        return 3;\n      case k.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED:\n        return 4;\n      case k.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED:\n        return 5;\n      default:\n        return 0;\n    }\n  }\n  a.eventsStreamMessageTypeToNumber = $;\n  function J() {\n    return { collectionId: void 0, projectId: void 0, layoutId: void 0 };\n  }\n  a.EventTarget = {\n    encode(A, N = g.Writer.create()) {\n      return A.collectionId !== void 0 && N.uint32(42).string(A.collectionId), A.projectId !== void 0 && N.uint32(34).string(A.projectId), A.layoutId !== void 0 && N.uint32(10).string(A.layoutId), N;\n    },\n    decode(A, N) {\n      const D = A instanceof g.Reader ? A : new g.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = J();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 5:\n            ee.collectionId = D.string();\n            break;\n          case 4:\n            ee.projectId = D.string();\n            break;\n          case 1:\n            ee.layoutId = D.string();\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return {\n        collectionId: de(A.collectionId) ? String(A.collectionId) : void 0,\n        projectId: de(A.projectId) ? String(A.projectId) : void 0,\n        layoutId: de(A.layoutId) ? String(A.layoutId) : void 0\n      };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.collectionId !== void 0 && (N.collectionId = A.collectionId), A.projectId !== void 0 && (N.projectId = A.projectId), A.layoutId !== void 0 && (N.layoutId = A.layoutId), N;\n    },\n    fromPartial(A) {\n      var N, D, W;\n      const ee = J();\n      return ee.collectionId = (N = A.collectionId) !== null && N !== void 0 ? N : void 0, ee.projectId = (D = A.projectId) !== null && D !== void 0 ? D : void 0, ee.layoutId = (W = A.layoutId) !== null && W !== void 0 ? W : void 0, ee;\n    }\n  };\n  function V() {\n    return {\n      name: \"\",\n      payload: void 0,\n      requestMetadata: void 0,\n      target: void 0\n    };\n  }\n  a.PublishEventRequest = {\n    encode(A, N = g.Writer.create()) {\n      return A.name !== \"\" && N.uint32(10).string(A.name), A.payload !== void 0 && _.Struct.encode(_.Struct.wrap(A.payload), N.uint32(18).fork()).ldelim(), A.requestMetadata !== void 0 && _.Value.encode(_.Value.wrap(A.requestMetadata), N.uint32(34).fork()).ldelim(), A.target !== void 0 && a.EventTarget.encode(A.target, N.uint32(26).fork()).ldelim(), N;\n    },\n    decode(A, N) {\n      const D = A instanceof g.Reader ? A : new g.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = V();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.name = D.string();\n            break;\n          case 2:\n            ee.payload = _.Struct.unwrap(_.Struct.decode(D, D.uint32()));\n            break;\n          case 4:\n            ee.requestMetadata = _.Value.unwrap(_.Value.decode(D, D.uint32()));\n            break;\n          case 3:\n            ee.target = a.EventTarget.decode(D, D.uint32());\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return {\n        name: de(A.name) ? String(A.name) : \"\",\n        payload: oe(A.payload) ? A.payload : void 0,\n        requestMetadata: de(A == null ? void 0 : A.requestMetadata) ? A.requestMetadata : void 0,\n        target: de(A.target) ? a.EventTarget.fromJSON(A.target) : void 0\n      };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.name !== void 0 && (N.name = A.name), A.payload !== void 0 && (N.payload = A.payload), A.requestMetadata !== void 0 && (N.requestMetadata = A.requestMetadata), A.target !== void 0 && (N.target = A.target ? a.EventTarget.toJSON(A.target) : void 0), N;\n    },\n    fromPartial(A) {\n      var N, D, W;\n      const ee = V();\n      return ee.name = (N = A.name) !== null && N !== void 0 ? N : \"\", ee.payload = (D = A.payload) !== null && D !== void 0 ? D : void 0, ee.requestMetadata = (W = A.requestMetadata) !== null && W !== void 0 ? W : void 0, ee.target = A.target !== void 0 && A.target !== null ? a.EventTarget.fromPartial(A.target) : void 0, ee;\n    }\n  };\n  function q() {\n    return {\n      name: \"\",\n      payload: void 0,\n      target: void 0,\n      requestMetadata: void 0,\n      id: \"\"\n    };\n  }\n  a.PublishEventResponse = {\n    encode(A, N = g.Writer.create()) {\n      return A.name !== \"\" && N.uint32(10).string(A.name), A.payload !== void 0 && _.Struct.encode(_.Struct.wrap(A.payload), N.uint32(18).fork()).ldelim(), A.target !== void 0 && a.EventTarget.encode(A.target, N.uint32(26).fork()).ldelim(), A.requestMetadata !== void 0 && _.Value.encode(_.Value.wrap(A.requestMetadata), N.uint32(34).fork()).ldelim(), A.id !== \"\" && N.uint32(42).string(A.id), N;\n    },\n    decode(A, N) {\n      const D = A instanceof g.Reader ? A : new g.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = q();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.name = D.string();\n            break;\n          case 2:\n            ee.payload = _.Struct.unwrap(_.Struct.decode(D, D.uint32()));\n            break;\n          case 3:\n            ee.target = a.EventTarget.decode(D, D.uint32());\n            break;\n          case 4:\n            ee.requestMetadata = _.Value.unwrap(_.Value.decode(D, D.uint32()));\n            break;\n          case 5:\n            ee.id = D.string();\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return {\n        name: de(A.name) ? String(A.name) : \"\",\n        payload: oe(A.payload) ? A.payload : void 0,\n        target: de(A.target) ? a.EventTarget.fromJSON(A.target) : void 0,\n        requestMetadata: de(A == null ? void 0 : A.requestMetadata) ? A.requestMetadata : void 0,\n        id: de(A.id) ? String(A.id) : \"\"\n      };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.name !== void 0 && (N.name = A.name), A.payload !== void 0 && (N.payload = A.payload), A.target !== void 0 && (N.target = A.target ? a.EventTarget.toJSON(A.target) : void 0), A.requestMetadata !== void 0 && (N.requestMetadata = A.requestMetadata), A.id !== void 0 && (N.id = A.id), N;\n    },\n    fromPartial(A) {\n      var N, D, W, ee;\n      const ae = q();\n      return ae.name = (N = A.name) !== null && N !== void 0 ? N : \"\", ae.payload = (D = A.payload) !== null && D !== void 0 ? D : void 0, ae.target = A.target !== void 0 && A.target !== null ? a.EventTarget.fromPartial(A.target) : void 0, ae.requestMetadata = (W = A.requestMetadata) !== null && W !== void 0 ? W : void 0, ae.id = (ee = A.id) !== null && ee !== void 0 ? ee : \"\", ae;\n    }\n  };\n  function G() {\n    return { name: \"\", target: void 0 };\n  }\n  a.SubscribePayload = {\n    encode(A, N = g.Writer.create()) {\n      return A.name !== \"\" && N.uint32(10).string(A.name), A.target !== void 0 && a.EventTarget.encode(A.target, N.uint32(18).fork()).ldelim(), N;\n    },\n    decode(A, N) {\n      const D = A instanceof g.Reader ? A : new g.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = G();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.name = D.string();\n            break;\n          case 2:\n            ee.target = a.EventTarget.decode(D, D.uint32());\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return {\n        name: de(A.name) ? String(A.name) : \"\",\n        target: de(A.target) ? a.EventTarget.fromJSON(A.target) : void 0\n      };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.name !== void 0 && (N.name = A.name), A.target !== void 0 && (N.target = A.target ? a.EventTarget.toJSON(A.target) : void 0), N;\n    },\n    fromPartial(A) {\n      var N;\n      const D = G();\n      return D.name = (N = A.name) !== null && N !== void 0 ? N : \"\", D.target = A.target !== void 0 && A.target !== null ? a.EventTarget.fromPartial(A.target) : void 0, D;\n    }\n  };\n  function H() {\n    return { code: 0, message: \"\" };\n  }\n  a.EventsStreamError = {\n    encode(A, N = g.Writer.create()) {\n      return A.code !== 0 && N.uint32(8).int32(A.code), A.message !== \"\" && N.uint32(18).string(A.message), N;\n    },\n    decode(A, N) {\n      const D = A instanceof g.Reader ? A : new g.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = H();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.code = D.int32();\n            break;\n          case 2:\n            ee.message = D.string();\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return {\n        code: de(A.code) ? Number(A.code) : 0,\n        message: de(A.message) ? String(A.message) : \"\"\n      };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.code !== void 0 && (N.code = Math.round(A.code)), A.message !== void 0 && (N.message = A.message), N;\n    },\n    fromPartial(A) {\n      var N, D;\n      const W = H();\n      return W.code = (N = A.code) !== null && N !== void 0 ? N : 0, W.message = (D = A.message) !== null && D !== void 0 ? D : \"\", W;\n    }\n  };\n  function B() {\n    return { reauthenticate: !1, beforeTimestamp: \"\" };\n  }\n  a.EventsStreamReconnectRequest = {\n    encode(A, N = g.Writer.create()) {\n      return A.reauthenticate === !0 && N.uint32(8).bool(A.reauthenticate), A.beforeTimestamp !== \"\" && N.uint32(18).string(A.beforeTimestamp), N;\n    },\n    decode(A, N) {\n      const D = A instanceof g.Reader ? A : new g.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = B();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.reauthenticate = D.bool();\n            break;\n          case 2:\n            ee.beforeTimestamp = D.string();\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return {\n        reauthenticate: de(A.reauthenticate) ? !!A.reauthenticate : !1,\n        beforeTimestamp: de(A.beforeTimestamp) ? String(A.beforeTimestamp) : \"\"\n      };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.reauthenticate !== void 0 && (N.reauthenticate = A.reauthenticate), A.beforeTimestamp !== void 0 && (N.beforeTimestamp = A.beforeTimestamp), N;\n    },\n    fromPartial(A) {\n      var N, D;\n      const W = B();\n      return W.reauthenticate = (N = A.reauthenticate) !== null && N !== void 0 ? N : !1, W.beforeTimestamp = (D = A.beforeTimestamp) !== null && D !== void 0 ? D : \"\", W;\n    }\n  };\n  function Y() {\n    return {\n      correlationId: void 0,\n      subscribe: void 0,\n      unsubscribe: void 0,\n      publish: void 0,\n      ping: void 0\n    };\n  }\n  a.EventsStreamRequest = {\n    encode(A, N = g.Writer.create()) {\n      return A.correlationId !== void 0 && N.uint32(10).string(A.correlationId), A.subscribe !== void 0 && a.SubscribePayload.encode(A.subscribe, N.uint32(802).fork()).ldelim(), A.unsubscribe !== void 0 && a.SubscribePayload.encode(A.unsubscribe, N.uint32(810).fork()).ldelim(), A.publish !== void 0 && a.PublishEventRequest.encode(A.publish, N.uint32(818).fork()).ldelim(), A.ping !== void 0 && N.uint32(826).string(A.ping), N;\n    },\n    decode(A, N) {\n      const D = A instanceof g.Reader ? A : new g.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = Y();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.correlationId = D.string();\n            break;\n          case 100:\n            ee.subscribe = a.SubscribePayload.decode(D, D.uint32());\n            break;\n          case 101:\n            ee.unsubscribe = a.SubscribePayload.decode(D, D.uint32());\n            break;\n          case 102:\n            ee.publish = a.PublishEventRequest.decode(D, D.uint32());\n            break;\n          case 103:\n            ee.ping = D.string();\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return {\n        correlationId: de(A.correlationId) ? String(A.correlationId) : void 0,\n        subscribe: de(A.subscribe) ? a.SubscribePayload.fromJSON(A.subscribe) : void 0,\n        unsubscribe: de(A.unsubscribe) ? a.SubscribePayload.fromJSON(A.unsubscribe) : void 0,\n        publish: de(A.publish) ? a.PublishEventRequest.fromJSON(A.publish) : void 0,\n        ping: de(A.ping) ? String(A.ping) : void 0\n      };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.correlationId !== void 0 && (N.correlationId = A.correlationId), A.subscribe !== void 0 && (N.subscribe = A.subscribe ? a.SubscribePayload.toJSON(A.subscribe) : void 0), A.unsubscribe !== void 0 && (N.unsubscribe = A.unsubscribe ? a.SubscribePayload.toJSON(A.unsubscribe) : void 0), A.publish !== void 0 && (N.publish = A.publish ? a.PublishEventRequest.toJSON(A.publish) : void 0), A.ping !== void 0 && (N.ping = A.ping), N;\n    },\n    fromPartial(A) {\n      var N, D;\n      const W = Y();\n      return W.correlationId = (N = A.correlationId) !== null && N !== void 0 ? N : void 0, W.subscribe = A.subscribe !== void 0 && A.subscribe !== null ? a.SubscribePayload.fromPartial(A.subscribe) : void 0, W.unsubscribe = A.unsubscribe !== void 0 && A.unsubscribe !== null ? a.SubscribePayload.fromPartial(A.unsubscribe) : void 0, W.publish = A.publish !== void 0 && A.publish !== null ? a.PublishEventRequest.fromPartial(A.publish) : void 0, W.ping = (D = A.ping) !== null && D !== void 0 ? D : void 0, W;\n    }\n  };\n  function ne() {\n    return {\n      correlationId: void 0,\n      sessionId: void 0,\n      event: void 0,\n      pong: void 0,\n      error: void 0,\n      subscribed: void 0,\n      unsubscribed: void 0,\n      published: void 0,\n      reconnectBefore: void 0\n    };\n  }\n  a.EventsStreamResponse = {\n    encode(A, N = g.Writer.create()) {\n      return A.correlationId !== void 0 && N.uint32(18).string(A.correlationId), A.sessionId !== void 0 && N.uint32(26).string(A.sessionId), A.event !== void 0 && a.PublishEventResponse.encode(A.event, N.uint32(802).fork()).ldelim(), A.pong !== void 0 && N.uint32(1602).string(A.pong), A.error !== void 0 && a.EventsStreamError.encode(A.error, N.uint32(1610).fork()).ldelim(), A.subscribed !== void 0 && a.SubscribePayload.encode(A.subscribed, N.uint32(1618).fork()).ldelim(), A.unsubscribed !== void 0 && a.SubscribePayload.encode(A.unsubscribed, N.uint32(1626).fork()).ldelim(), A.published !== void 0 && a.PublishEventResponse.encode(A.published, N.uint32(1634).fork()).ldelim(), A.reconnectBefore !== void 0 && a.EventsStreamReconnectRequest.encode(A.reconnectBefore, N.uint32(1642).fork()).ldelim(), N;\n    },\n    decode(A, N) {\n      const D = A instanceof g.Reader ? A : new g.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = ne();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 2:\n            ee.correlationId = D.string();\n            break;\n          case 3:\n            ee.sessionId = D.string();\n            break;\n          case 100:\n            ee.event = a.PublishEventResponse.decode(D, D.uint32());\n            break;\n          case 200:\n            ee.pong = D.string();\n            break;\n          case 201:\n            ee.error = a.EventsStreamError.decode(D, D.uint32());\n            break;\n          case 202:\n            ee.subscribed = a.SubscribePayload.decode(D, D.uint32());\n            break;\n          case 203:\n            ee.unsubscribed = a.SubscribePayload.decode(D, D.uint32());\n            break;\n          case 204:\n            ee.published = a.PublishEventResponse.decode(D, D.uint32());\n            break;\n          case 205:\n            ee.reconnectBefore = a.EventsStreamReconnectRequest.decode(D, D.uint32());\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return {\n        correlationId: de(A.correlationId) ? String(A.correlationId) : void 0,\n        sessionId: de(A.sessionId) ? String(A.sessionId) : void 0,\n        event: de(A.event) ? a.PublishEventResponse.fromJSON(A.event) : void 0,\n        pong: de(A.pong) ? String(A.pong) : void 0,\n        error: de(A.error) ? a.EventsStreamError.fromJSON(A.error) : void 0,\n        subscribed: de(A.subscribed) ? a.SubscribePayload.fromJSON(A.subscribed) : void 0,\n        unsubscribed: de(A.unsubscribed) ? a.SubscribePayload.fromJSON(A.unsubscribed) : void 0,\n        published: de(A.published) ? a.PublishEventResponse.fromJSON(A.published) : void 0,\n        reconnectBefore: de(A.reconnectBefore) ? a.EventsStreamReconnectRequest.fromJSON(A.reconnectBefore) : void 0\n      };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.correlationId !== void 0 && (N.correlationId = A.correlationId), A.sessionId !== void 0 && (N.sessionId = A.sessionId), A.event !== void 0 && (N.event = A.event ? a.PublishEventResponse.toJSON(A.event) : void 0), A.pong !== void 0 && (N.pong = A.pong), A.error !== void 0 && (N.error = A.error ? a.EventsStreamError.toJSON(A.error) : void 0), A.subscribed !== void 0 && (N.subscribed = A.subscribed ? a.SubscribePayload.toJSON(A.subscribed) : void 0), A.unsubscribed !== void 0 && (N.unsubscribed = A.unsubscribed ? a.SubscribePayload.toJSON(A.unsubscribed) : void 0), A.published !== void 0 && (N.published = A.published ? a.PublishEventResponse.toJSON(A.published) : void 0), A.reconnectBefore !== void 0 && (N.reconnectBefore = A.reconnectBefore ? a.EventsStreamReconnectRequest.toJSON(A.reconnectBefore) : void 0), N;\n    },\n    fromPartial(A) {\n      var N, D, W;\n      const ee = ne();\n      return ee.correlationId = (N = A.correlationId) !== null && N !== void 0 ? N : void 0, ee.sessionId = (D = A.sessionId) !== null && D !== void 0 ? D : void 0, ee.event = A.event !== void 0 && A.event !== null ? a.PublishEventResponse.fromPartial(A.event) : void 0, ee.pong = (W = A.pong) !== null && W !== void 0 ? W : void 0, ee.error = A.error !== void 0 && A.error !== null ? a.EventsStreamError.fromPartial(A.error) : void 0, ee.subscribed = A.subscribed !== void 0 && A.subscribed !== null ? a.SubscribePayload.fromPartial(A.subscribed) : void 0, ee.unsubscribed = A.unsubscribed !== void 0 && A.unsubscribed !== null ? a.SubscribePayload.fromPartial(A.unsubscribed) : void 0, ee.published = A.published !== void 0 && A.published !== null ? a.PublishEventResponse.fromPartial(A.published) : void 0, ee.reconnectBefore = A.reconnectBefore !== void 0 && A.reconnectBefore !== null ? a.EventsStreamReconnectRequest.fromPartial(A.reconnectBefore) : void 0, ee;\n    }\n  };\n  class Z {\n    constructor(N) {\n      this.rpc = N, this.Stream = this.Stream.bind(this), this.Publish = this.Publish.bind(this);\n    }\n    Stream(N) {\n      const D = N.pipe(E.map((ee) => a.EventsStreamRequest.encode(ee).finish()));\n      return this.rpc.bidirectionalStreamingRequest(\"apis.event.v2.EventService\", \"Stream\", D).pipe(E.map((ee) => a.EventsStreamResponse.decode(new g.Reader(ee))));\n    }\n    Publish(N) {\n      const D = a.PublishEventRequest.encode(N).finish();\n      return this.rpc.request(\"apis.event.v2.EventService\", \"Publish\", D).then((ee) => a.PublishEventResponse.decode(new g.Reader(ee)));\n    }\n  }\n  a.EventServiceClientImpl = Z, a.EventServiceDefinition = {\n    name: \"EventService\",\n    fullName: \"apis.event.v2.EventService\",\n    methods: {\n      /**\n       * Stream Events\n       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME\n       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME\n       */\n      stream: {\n        name: \"Stream\",\n        requestType: a.EventsStreamRequest,\n        requestStream: !0,\n        responseType: a.EventsStreamResponse,\n        responseStream: !0,\n        options: {}\n      },\n      /**\n       * Publish Event\n       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME\n       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME\n       */\n      publish: {\n        name: \"Publish\",\n        requestType: a.PublishEventRequest,\n        requestStream: !1,\n        responseType: a.PublishEventResponse,\n        responseStream: !1,\n        options: {}\n      }\n    }\n  };\n  var re = (() => {\n    if (typeof re < \"u\")\n      return re;\n    if (typeof self < \"u\")\n      return self;\n    if (typeof window < \"u\")\n      return window;\n    if (typeof commonjsGlobal$1 < \"u\")\n      return commonjsGlobal$1;\n    throw \"Unable to locate global object\";\n  })();\n  g.util.Long !== S.default && (g.util.Long = S.default, g.configure());\n  function oe(A) {\n    return typeof A == \"object\" && A !== null;\n  }\n  function de(A) {\n    return A != null;\n  }\n})(api);\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(l, v, S, g) {\n    g === void 0 && (g = S), Object.defineProperty(l, g, { enumerable: !0, get: function() {\n      return v[S];\n    } });\n  } : function(l, v, S, g) {\n    g === void 0 && (g = S), l[g] = v[S];\n  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(l, v) {\n    for (var S in l)\n      S !== \"default\" && !v.hasOwnProperty(S) && u(v, l, S);\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.eventsApiSupportedEvents = a.eventsApiEventRpcCalls = void 0, c(api, a), a.eventsApiEventRpcCalls = {\n    ping: \"pong\",\n    publish: \"published\",\n    subscribe: \"subscribed\",\n    unsubscribe: \"unsubscribed\"\n  }, a.eventsApiSupportedEvents = [...Object.values(a.eventsApiEventRpcCalls), \"error\", \"event\", \"reconnectBefore\"];\n})(dist$1);\nvar ws = null;\ntypeof WebSocket < \"u\" ? ws = WebSocket : typeof MozWebSocket < \"u\" ? ws = MozWebSocket : typeof commonjsGlobal$1 < \"u\" ? ws = commonjsGlobal$1.WebSocket || commonjsGlobal$1.MozWebSocket : typeof window < \"u\" ? ws = window.WebSocket || window.MozWebSocket : typeof self < \"u\" && (ws = self.WebSocket || self.MozWebSocket);\nvar browser$1 = ws, matcher = { exports: {} }, escapeStringRegexp$1 = (a) => {\n  if (typeof a != \"string\")\n    throw new TypeError(\"Expected a string\");\n  return a.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\").replace(/-/g, \"\\\\x2d\");\n};\nconst escapeStringRegexp = escapeStringRegexp$1, regexpCache = /* @__PURE__ */ new Map();\nfunction sanitizeArray(a, u) {\n  if (!Array.isArray(a))\n    switch (typeof a) {\n      case \"string\":\n        a = [a];\n        break;\n      case \"undefined\":\n        a = [];\n        break;\n      default:\n        throw new TypeError(`Expected '${u}' to be a string or an array, but got a type of '${typeof a}'`);\n    }\n  return a.filter((c) => {\n    if (typeof c != \"string\") {\n      if (typeof c > \"u\")\n        return !1;\n      throw new TypeError(`Expected '${u}' to be an array of strings, but found a type of '${typeof c}' in the array`);\n    }\n    return !0;\n  });\n}\nfunction makeRegexp(a, u) {\n  u = {\n    caseSensitive: !1,\n    ...u\n  };\n  const c = a + JSON.stringify(u);\n  if (regexpCache.has(c))\n    return regexpCache.get(c);\n  const l = a[0] === \"!\";\n  l && (a = a.slice(1)), a = escapeStringRegexp(a).replace(/\\\\\\*/g, \"[\\\\s\\\\S]*\");\n  const v = new RegExp(`^${a}$`, u.caseSensitive ? \"\" : \"i\");\n  return v.negated = l, regexpCache.set(c, v), v;\n}\nmatcher.exports = (a, u, c) => {\n  if (a = sanitizeArray(a, \"inputs\"), u = sanitizeArray(u, \"patterns\"), u.length === 0)\n    return [];\n  const l = u[0][0] === \"!\";\n  u = u.map((S) => makeRegexp(S, c));\n  const v = [];\n  for (const S of a) {\n    let g = l;\n    for (const E of u)\n      E.test(S) && (g = !E.negated);\n    g && v.push(S);\n  }\n  return v;\n};\nmatcher.exports.isMatch = (a, u, c) => (a = sanitizeArray(a, \"inputs\"), u = sanitizeArray(u, \"patterns\"), u.length === 0 ? !1 : a.some((l) => u.every((v) => {\n  const S = makeRegexp(v, c), g = S.test(l);\n  return S.negated ? !g : g;\n})));\nvar matcherExports = matcher.exports, __createBinding$1 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {\n  l === void 0 && (l = c);\n  var v = Object.getOwnPropertyDescriptor(u, c);\n  (!v || (\"get\" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {\n    return u[c];\n  } }), Object.defineProperty(a, l, v);\n} : function(a, u, c, l) {\n  l === void 0 && (l = c), a[l] = u[c];\n}), __setModuleDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {\n  Object.defineProperty(a, \"default\", { enumerable: !0, value: u });\n} : function(a, u) {\n  a.default = u;\n}), __importStar$1 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {\n  if (a && a.__esModule)\n    return a;\n  var u = {};\n  if (a != null)\n    for (var c in a)\n      c !== \"default\" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$1(u, a, c);\n  return __setModuleDefault$1(u, a), u;\n}, __importDefault$8 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(eventapi, \"__esModule\", { value: !0 });\neventapi.EventApi = void 0;\nconst EventApiModel = __importStar$1(dist$1), isomorphic_ws_1 = __importDefault$8(browser$1), uuid_1 = require$$1$2, NiceGrpc = __importStar$1(lib$1), matcher_1 = matcherExports, api_1 = api$2, clientVersion = version$3, WS_PING_INTERVAL = 2e4, WS_PING_TIMEOUT = 1e4, WS_RECONNECT_DELAY = 2e3, WS_MAX_BADAUTH_ATTEMPTS = 3, LOG_CATEGORY = \"EventApi\";\nclass EventApi extends api_1.ApiClient {\n  constructor(u, c, l, v, S, g) {\n    super(u, c, v, LOG_CATEGORY, S, g), this.websocketServer = l, this.subscriptions = /* @__PURE__ */ new Set(), this.eventHandlers = {}, this.calls = {}, this.messageQueue = [], this.websocketReady = !1, this.reconnectionAttempts = 0, this.badAuthentication = !1, this.eventsClient = null;\n  }\n  /**\n   * Publish a custom event\n   *\n   * note: if this session has an established stream, all custom\n   * events will use that transport.\n   *\n   * @param request\n   * @returns\n   */\n  publish(...u) {\n    return this.websocketReady ? this.call(\"publish\", u[0]) : this.eventsClient.publish(...u);\n  }\n  /**\n   * Open the connection\n   */\n  connect() {\n    if (!this.ws) {\n      this.cleanup();\n      const u = this.accessToken, c = [`version=${clientVersion}`, `sessionid=${this.sessionId}`];\n      this.sdkVersion && c.push(`sdkversion=${this.sdkVersion}`), this.ws = new isomorphic_ws_1.default(`${this.websocketServer}/stream?${c.join(\"&\")}`, [\n        \"Bearer\",\n        this.accessToken\n      ]);\n      let l;\n      this.ws.addEventListener(\"message\", (v) => {\n        const S = JSON.parse(v.data.toString()), g = S.result;\n        if (S.error && (l = S.error, this.handleEvent(\"error\", {\n          error: {\n            code: S.code,\n            message: S.message\n          }\n        }), [\"You do not have permission to this resource\", \"You do not have permission to this resource\"].includes(S.message) && (this.badAuthentication = !0)), !g)\n          return;\n        g.reconnectBefore && g.reconnectBefore.reauthenticate && this.accessToken === u && (this.badAuthentication = !0);\n        const E = EventApiModel.eventsApiSupportedEvents.find((_) => !!g[_]);\n        E && this.handleEvent(E, g);\n      }), this.ws.addEventListener(\"open\", () => {\n        this.log.info(\"websocket connected\"), this.call(\"ping\", \"hello\", { timeout: WS_PING_TIMEOUT, skipQueue: !0 }).then(() => {\n          this.ready();\n        }).catch((v) => {\n          !l && v.message !== \"Stream connection closed\" && this.disconnect(\"hello timeout\");\n        });\n      }), this.ws.addEventListener(\"close\", (v) => {\n        var S;\n        l ? this.reconnect(`${(S = l == null ? void 0 : l.message) !== null && S !== void 0 ? S : \"unknown\"}`) : this.reconnect(`closed - ${v.reason || v.code}`);\n      }), this.ws.addEventListener(\"error\", (v) => {\n        l = v;\n      });\n    }\n  }\n  /**\n   * Subscribe to an event\n   *\n   * note: if a connection does not exist, one will be established.\n   *\n   * @param type\n   * @param payload\n   */\n  async subscribe(u, c = {}) {\n    return this.call(\"subscribe\", { name: u, ...c }).then(() => {\n      this.subscriptions.add(JSON.stringify({ name: u, ...c }));\n    });\n  }\n  /**\n   * Unsubscribe from an event\n   * @param type\n   * @param payload\n   */\n  async unsubscribe(u, c = {}) {\n    this.subscriptions.delete(JSON.stringify({ name: u, payload: c })), await this.call(\"unsubscribe\", { name: u, ...c });\n  }\n  on(u, c, l) {\n    const v = l || c, S = {\n      ignoreSessionEvents: !1,\n      allowedSessionEvents: [],\n      ...l ? c : {}\n    };\n    this.eventHandlers[u] || (this.eventHandlers[u] = []), this.eventHandlers[u].push({\n      ...S,\n      handler: v\n    });\n  }\n  off(u, c, l) {\n    var v;\n    const S = l || c, g = {\n      ignoreSessionEvents: !1,\n      allowedSessionEvents: [],\n      ...l ? c : {}\n    };\n    this.eventHandlers[u] = ((v = this.eventHandlers[u]) !== null && v !== void 0 ? v : []).filter((E) => !(E.ignoreSessionEvents === g.ignoreSessionEvents && E.allowedSessionEvents === g.allowedSessionEvents && E.handler === S && E.name === g.name));\n  }\n  /**\n   * Disconnect the websocket connection\n   */\n  disconnect(u) {\n    this.log.warn(`disconnected from events reason=${u}`), Object.values(this.calls).forEach((c) => {\n      clearTimeout(c.timeout), c.reject(new Error(\"Stream connection closed\"));\n    }), this.calls = {}, this.cleanup();\n  }\n  _setup(u) {\n    this.eventsClient = this.clientFactory.create(EventApiModel.EventServiceDefinition, this.channel, {\n      \"*\": u\n    }), this.badAuthentication && (this.badAuthentication = !1, this.reconnectionAttempts = 0, this.reconnect(\"updated token\"));\n  }\n  /**\n   * Called when the websocket is ready.\n   */\n  ready() {\n    this.reconnectionAttempts = 0, this.badAuthentication = !1, this.websocketReady = !0, this.handleEvent(\"connected\", { connected: void 0 });\n    for (const u of this.subscriptions.values())\n      this.send({ subscribe: JSON.parse(u), correlationId: (0, uuid_1.v4)() });\n    for (const u of this.messageQueue)\n      this.send(u);\n    this.messageQueue = [], this.pingLoop = setInterval(() => {\n      this.ping();\n    }, WS_PING_INTERVAL);\n  }\n  ping() {\n    this.call(\"ping\", `${+/* @__PURE__ */ new Date()}`, { timeout: WS_PING_TIMEOUT }).catch(() => {\n      this.reconnect(\"connection stalled\");\n    });\n  }\n  /**\n   * Reconnect event stream\n   *\n   * @param reason Rec\n   */\n  reconnect(u) {\n    this.disconnect(u), this.reconnectTimeout = setTimeout(() => {\n      if (this.reconnectionAttempts++, this.badAuthentication && this.reconnectionAttempts >= WS_MAX_BADAUTH_ATTEMPTS) {\n        this.log.warn(\"Maximum number of reconnection attempts reached with bad authentication, please re-authenticate the SDK\");\n        return;\n      }\n      this.connect();\n    }, WS_RECONNECT_DELAY);\n  }\n  /**\n   * Send a raw message to the websocket.\n   *\n   * @param data\n   */\n  send(u) {\n    this.ws && this.ws.readyState === this.ws.OPEN ? this.ws.send(JSON.stringify(u)) : this.log.warn(\"Message sent to a disconnected stream\");\n  }\n  /**\n   * Process a stream event\n   *\n   * @param name the name of the event\n   * @param payload the full event stream payload\n   *\n   * @returns void\n   */\n  handleEvent(u, c) {\n    var l;\n    if (this.calls[c.correlationId]) {\n      const v = EventApiModel.eventsApiEventRpcCalls[this.calls[c.correlationId].method] === u, S = !!c.error;\n      if (v || S) {\n        this.resolveCall(u, c);\n        return;\n      }\n    }\n    for (const v of (l = this.eventHandlers[u]) !== null && l !== void 0 ? l : []) {\n      if (u === \"event\" && c.event) {\n        if (c.sessionId === this.sessionId && v.ignoreSessionEvents && !v.allowedSessionEvents.includes(c.event.name)) {\n          this.log.trace(\"ignoring user event from self: \" + c.event.name + \", payload.sessionId=\" + c.sessionId + \", this.sessionId\");\n          continue;\n        }\n        if (v.name && !(0, matcher_1.isMatch)(c.event.name, v.name))\n          continue;\n        if (this.eventLogCallback) {\n          let S, g = c.event.name, E;\n          if (c.event.name.startsWith(EventApi.APISTREAM_EVENT_PREFIX)) {\n            let _ = c.event.name.split(\":\");\n            _.length == 4 && (S = _[1], g = _[2], E = _[3]), this.eventLogCallback(S, g, E, c);\n          }\n        }\n      } else if (c.sessionId === this.sessionId && v.ignoreSessionEvents) {\n        this.log.trace(\"ignoring event from self: \" + c.event.name + \", payload.sessionId=\" + c.sessionId + \", this.sessionId\");\n        continue;\n      }\n      this.log.trace(\"processing event: payload.sessionId=\" + c.sessionId + \", this.sessionId\"), v.handler(c ? c[u] : void 0, { isFromCurrentSession: c.sessionId === this.sessionId });\n    }\n  }\n  /**\n   * Make an RPC call\n   *\n   * Initiates an async request via the stream. A correlationId is generated and used to track\n   * responses and errors. A handler is registered\n   *\n   * @param method request method to call\n   * @param payload payload to send\n   * @param opts timeout\n   * @returns\n   */\n  async call(u, c, l = { timeout: 2e4, skipQueue: !1 }) {\n    this.ws || this.connect();\n    const v = (0, uuid_1.v4)();\n    return new Promise((S, g) => {\n      const E = setTimeout(() => {\n        delete this.calls[v], g(new Error(\"Request timed out\"));\n      }, l.timeout);\n      this.calls[v] = { resolve: S, reject: g, timeout: E, method: u }, this.websocketReady || l.skipQueue ? this.send({ [u]: c, correlationId: v }) : this.messageQueue.push({ [u]: c, correlationId: v });\n    });\n  }\n  /**\n   * Handler for `.call()`\n   *\n   * Handle response events for a socket call.\n   *\n   * @param name name of responding event\n   * @param payload payload of the event\n   * @returns void\n   */\n  resolveCall(u, c) {\n    const l = this.calls[c.correlationId];\n    if (l) {\n      if (clearTimeout(l.timeout), delete this.calls[c.correlationId], u === \"error\" && c.error) {\n        l.reject(new NiceGrpc.ClientError(\"error\", c.error.code, c.error.message));\n        return;\n      }\n      l.resolve(c[u]);\n    }\n  }\n  /**\n   * Cleanup connection\n   *\n   * This cleans up the local state for a given websocket connection.\n   */\n  cleanup() {\n    clearTimeout(this.pingLoop), clearTimeout(this.reconnectTimeout), this.websocketReady = !1, this.ws && (this.ws.onclose = function() {\n    }, this.ws.close(), this.ws = null);\n  }\n}\neventapi.EventApi = EventApi;\nEventApi.APISTREAM_EVENT_PREFIX = \"apistream\";\nvar livekit = {}, __importDefault$7 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(livekit, \"__esModule\", { value: !0 });\nlivekit.LiveKitUtils = void 0;\nconst jwt_decode_1 = __importDefault$7(require$$0$2);\nclass LiveKitUtils {\n  static decodeJwt(u) {\n    return (0, jwt_decode_1.default)(u, { header: !1 });\n  }\n  static isRoomAdmin(u) {\n    return LiveKitUtils.decodeJwt(u).video.roomAdmin;\n  }\n  static getRoomName(u) {\n    return LiveKitUtils.decodeJwt(u).video.room;\n  }\n}\nlivekit.LiveKitUtils = LiveKitUtils;\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(de, A, N, D) {\n    D === void 0 && (D = N);\n    var W = Object.getOwnPropertyDescriptor(A, N);\n    (!W || (\"get\" in W ? !A.__esModule : W.writable || W.configurable)) && (W = { enumerable: !0, get: function() {\n      return A[N];\n    } }), Object.defineProperty(de, D, W);\n  } : function(de, A, N, D) {\n    D === void 0 && (D = N), de[D] = A[N];\n  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(de, A) {\n    Object.defineProperty(de, \"default\", { enumerable: !0, value: A });\n  } : function(de, A) {\n    de.default = A;\n  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(de) {\n    if (de && de.__esModule)\n      return de;\n    var A = {};\n    if (de != null)\n      for (var N in de)\n        N !== \"default\" && Object.prototype.hasOwnProperty.call(de, N) && u(A, de, N);\n    return c(A, de), A;\n  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(de) {\n    return de && de.__esModule ? de : { default: de };\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.ApiStream = a.LiveKitUtils = a.EventApiModel = a.LayoutApiModel = a.LiveApiModel = void 0;\n  const S = v(require$$0$2), g = require$$1$2, E = require$$2$1, _ = layoutapi, k = liveapi, L = eventapi, M = l(api$1);\n  a.LiveApiModel = M;\n  const $ = l(dist$2);\n  a.LayoutApiModel = $;\n  const J = l(dist$1);\n  a.EventApiModel = J;\n  const V = livekit;\n  Object.defineProperty(a, \"LiveKitUtils\", { enumerable: !0, get: function() {\n    return V.LiveKitUtils;\n  } });\n  const q = logger, G = version$3, H = {\n    dev: \"http://127.0.0.1:8081\",\n    stage: \"https://live.silly.horse/grpcweb/live/v2\",\n    prod: \"https://live.api.stream/grpcweb/live/v2\"\n  }, B = {\n    dev: \"https://live.silly.horse/grpcweb/layout/v2\",\n    stage: \"https://live.silly.horse/grpcweb/layout/v2\",\n    prod: \"https://live.api.stream/grpcweb/layout/v2\"\n  }, Y = {\n    dev: \"wss://live.silly.horse/event/v2\",\n    stage: \"wss://live.silly.horse/event/v2\",\n    prod: \"wss://live.api.stream/event/v2\"\n  }, ne = {\n    dev: \"https://live.silly.horse/grpcweb/event/v2\",\n    stage: \"https://live.silly.horse/grpcweb/event/v2\",\n    prod: \"https://live.api.stream/grpcweb/event/v2\"\n  }, Z = {\n    dev: \"wss://live.silly.horse/webrtc/v2\",\n    stage: \"wss://live.silly.horse/webrtc/v2\",\n    prod: \"wss://live.api.stream/webrtc/v2\"\n  }, re = {\n    dev: \"https://live.silly.horse/webrtc/v2\",\n    stage: \"https://live.silly.horse/webrtc/v2\",\n    prod: \"https://live.api.stream/webrtc/v2\"\n  };\n  class oe {\n    /**\n     * Create an ApiStream API Client\n     */\n    constructor(A = {}) {\n      var N;\n      const D = {\n        env: \"prod\",\n        logLevel: \"Warn\",\n        ...A\n      };\n      this.env = D.env;\n      let W = (0, g.v4)();\n      D.sessionId != null && (W = D.sessionId), this.log = q.logger.getCategory(\"ApiStream\"), this.setLogLevel(D.env == \"dev\" ? \"Trace\" : D.logLevel);\n      const ee = (N = D.overrideEndpoints) !== null && N !== void 0 ? N : {};\n      ee.liveApiServer == null && (ee.liveApiServer = H[this.env]), ee.layoutApiServer == null && (ee.layoutApiServer = B[this.env]), ee.eventApiServer == null && (ee.eventApiServer = ne[this.env]), ee.eventApiWebSocketServer == null && (ee.eventApiWebSocketServer = Y[this.env]), this.eventApi = new L.EventApi(W, ee.eventApiServer, ee.eventApiWebSocketServer, D.sdkVersion, D.apiLogCallback, D.eventLogCallback), this.layoutApi = new _.LayoutApi(W, this.eventApi, ee.layoutApiServer, D.sdkVersion, D.apiLogCallback), this.liveApi = new k.LiveApi(W, this.eventApi, ee.liveApiServer, this.setAccessToken.bind(this), D.apiKey, D.sdkVersion, D.apiLogCallback), this.eventApi.on(\"reconnectBefore\", (ae) => {\n        ae.reauthenticate && this.liveApi.authentication.refreshAccessToken({}).catch(() => {\n        });\n      }), this.log.info(\"api.stream: sessionid=\" + W + \", version=\" + G + \", sdkVersion=\" + D.sdkVersion);\n    }\n    /**\n     * Returns the live api client\n     *\n     * @returns the live api client\n     */\n    LiveApi() {\n      return this.liveApi;\n    }\n    /**\n     * Returns the layout api client\n     *\n     * @returns the layout api client\n     */\n    LayoutApi() {\n      return this.layoutApi;\n    }\n    /**\n     * Returns the layout api client\n     *\n     * @returns the layout api client\n     */\n    EventApi() {\n      return this.eventApi;\n    }\n    setLogLevel(A) {\n      try {\n        let N = E.LogLevel.toLogLevel(A);\n        q.logger.updateRuntimeSettings({\n          level: N\n        });\n      } catch {\n        this.log.warn(`unknown logging level ${A}`);\n      }\n    }\n    setAccessToken(A) {\n      this.decodedAccessToken = oe.decodeAccessToken(A), this.log.debug(\"setting accessToken\", A, this.decodedAccessToken), this.layoutApi.setAccessToken(A), this.liveApi.setAccessToken(A), this.eventApi.setAccessToken(A);\n    }\n    getAccessToken() {\n      return this.decodedAccessToken;\n    }\n    /**\n     * Are we running as a guest role?\n     *\n     * @returns {(ApiStream.GuestProject | null)} return the active project if running as a guest role\n     */\n    getGuestProject() {\n      return this.decodedAccessToken.guestControl;\n    }\n    /**\n     * Initialize the api library and check if we are running inside of the rendering engine\n     * @async\n     * @param {string} accessToken - a valid ApiStream access token\n     * @returns {(ApiStream.GuestProject | null)} if we are operating inside of the rendering engine, this is the active project\n     */\n    async load(A) {\n      if (A == null && typeof window < \"u\") {\n        let N = this.parseQuery();\n        N.get(oe.ACCESS_TOKEN_QUERY_PARAM) != null && (A = N.get(oe.ACCESS_TOKEN_QUERY_PARAM));\n      }\n      return A != null && (this.setAccessToken(A), this.decodedAccessToken.guestControl != null) ? (this.log.info(\"loading guest token and exchanging\"), await this.LiveApi().authentication.refreshAccessToken({}), this.log.info(\"auto-loading project = \" + JSON.stringify(this.decodedAccessToken.guestControl)), this.decodedAccessToken.guestControl) : null;\n    }\n    /**\n     * get the signaling address of the appropriate livekit webrtc server\n     *\n     * @param {boolean} admin - if true, return the admin (vs. client) address\n     * @returns {string} the address of the appropriate livekit webrtc server\n     */\n    getLiveKitServer(A = !1) {\n      return A ? re[this.env] : Z[this.env];\n    }\n    parseQuery() {\n      let A = window.location.search, N = /* @__PURE__ */ new Map(), D = (A[0] === \"?\" ? A.substr(1) : A).split(\"&\");\n      for (let W = 0; W < D.length; W++) {\n        let ee = D[W].split(\"=\");\n        ee.length == 2 && (N.set(decodeURIComponent(ee[0]), decodeURIComponent(ee[1] || \"\")), this.log.debug(`found query param: ${decodeURIComponent(ee[0])}=${decodeURIComponent(ee[1] || \"\")}`));\n      }\n      return N;\n    }\n    static decodeAccessToken(A) {\n      let N = (0, S.default)(A, { header: !1 }), D = {\n        serviceUserId: N.user.serviceUserId,\n        userId: N.user.userId,\n        displayName: N.user.displayName,\n        trial: N.user.trial,\n        demo: N.user.demo\n      };\n      return N.guestControl != null && (D.guestControl = {\n        collectionId: N.guestControl.collectionId,\n        projectId: N.guestControl.projectId,\n        role: M.roleFromJSON(N.guestControl.role)\n      }), D;\n    }\n  }\n  a.ApiStream = oe, oe.ACCESS_TOKEN_QUERY_PARAM = \"at\";\n})(lib$2);\nvar dist = {}, AccessToken$1 = {}, jws$3 = {}, safeBuffer = { exports: {} };\n(function(a, u) {\n  var c = require$$0$1, l = c.Buffer;\n  function v(g, E) {\n    for (var _ in g)\n      E[_] = g[_];\n  }\n  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = S);\n  function S(g, E, _) {\n    return l(g, E, _);\n  }\n  v(l, S), S.from = function(g, E, _) {\n    if (typeof g == \"number\")\n      throw new TypeError(\"Argument must not be a number\");\n    return l(g, E, _);\n  }, S.alloc = function(g, E, _) {\n    if (typeof g != \"number\")\n      throw new TypeError(\"Argument must be a number\");\n    var k = l(g);\n    return E !== void 0 ? typeof _ == \"string\" ? k.fill(E, _) : k.fill(E) : k.fill(0), k;\n  }, S.allocUnsafe = function(g) {\n    if (typeof g != \"number\")\n      throw new TypeError(\"Argument must be a number\");\n    return l(g);\n  }, S.allocUnsafeSlow = function(g) {\n    if (typeof g != \"number\")\n      throw new TypeError(\"Argument must be a number\");\n    return c.SlowBuffer(g);\n  };\n})(safeBuffer, safeBuffer.exports);\nvar safeBufferExports = safeBuffer.exports, Buffer$7 = safeBufferExports.Buffer, Stream$2 = require$$0$1, util$3 = require$$0$1;\nfunction DataStream$2(a) {\n  if (this.buffer = null, this.writable = !0, this.readable = !0, !a)\n    return this.buffer = Buffer$7.alloc(0), this;\n  if (typeof a.pipe == \"function\")\n    return this.buffer = Buffer$7.alloc(0), a.pipe(this), this;\n  if (a.length || typeof a == \"object\")\n    return this.buffer = a, this.writable = !1, process.nextTick((function() {\n      this.emit(\"end\", a), this.readable = !1, this.emit(\"close\");\n    }).bind(this)), this;\n  throw new TypeError(\"Unexpected data type (\" + typeof a + \")\");\n}\nutil$3.inherits(DataStream$2, Stream$2);\nDataStream$2.prototype.write = function a(u) {\n  this.buffer = Buffer$7.concat([this.buffer, Buffer$7.from(u)]), this.emit(\"data\", u);\n};\nDataStream$2.prototype.end = function a(u) {\n  u && this.write(u), this.emit(\"end\", u), this.emit(\"close\"), this.writable = !1, this.readable = !1;\n};\nvar dataStream = DataStream$2, Buffer$6 = require$$0$1.Buffer, SlowBuffer = require$$0$1.SlowBuffer, bufferEqualConstantTime = bufferEq;\nfunction bufferEq(a, u) {\n  if (!Buffer$6.isBuffer(a) || !Buffer$6.isBuffer(u) || a.length !== u.length)\n    return !1;\n  for (var c = 0, l = 0; l < a.length; l++)\n    c |= a[l] ^ u[l];\n  return c === 0;\n}\nbufferEq.install = function() {\n  Buffer$6.prototype.equal = SlowBuffer.prototype.equal = function(u) {\n    return bufferEq(this, u);\n  };\n};\nvar origBufEqual = Buffer$6.prototype.equal, origSlowBufEqual = SlowBuffer.prototype.equal;\nbufferEq.restore = function() {\n  Buffer$6.prototype.equal = origBufEqual, SlowBuffer.prototype.equal = origSlowBufEqual;\n};\nfunction getParamSize(a) {\n  var u = (a / 8 | 0) + (a % 8 === 0 ? 0 : 1);\n  return u;\n}\nvar paramBytesForAlg = {\n  ES256: getParamSize(256),\n  ES384: getParamSize(384),\n  ES512: getParamSize(521)\n};\nfunction getParamBytesForAlg$1(a) {\n  var u = paramBytesForAlg[a];\n  if (u)\n    return u;\n  throw new Error('Unknown algorithm \"' + a + '\"');\n}\nvar paramBytesForAlg_1 = getParamBytesForAlg$1, Buffer$5 = safeBufferExports.Buffer, getParamBytesForAlg = paramBytesForAlg_1, MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;\nfunction base64Url(a) {\n  return a.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction signatureAsBuffer(a) {\n  if (Buffer$5.isBuffer(a))\n    return a;\n  if (typeof a == \"string\")\n    return Buffer$5.from(a, \"base64\");\n  throw new TypeError(\"ECDSA signature must be a Base64 string or a Buffer\");\n}\nfunction derToJose(a, u) {\n  a = signatureAsBuffer(a);\n  var c = getParamBytesForAlg(u), l = c + 1, v = a.length, S = 0;\n  if (a[S++] !== ENCODED_TAG_SEQ)\n    throw new Error('Could not find expected \"seq\"');\n  var g = a[S++];\n  if (g === (MAX_OCTET | 1) && (g = a[S++]), v - S < g)\n    throw new Error('\"seq\" specified length of \"' + g + '\", only \"' + (v - S) + '\" remaining');\n  if (a[S++] !== ENCODED_TAG_INT)\n    throw new Error('Could not find expected \"int\" for \"r\"');\n  var E = a[S++];\n  if (v - S - 2 < E)\n    throw new Error('\"r\" specified length of \"' + E + '\", only \"' + (v - S - 2) + '\" available');\n  if (l < E)\n    throw new Error('\"r\" specified length of \"' + E + '\", max of \"' + l + '\" is acceptable');\n  var _ = S;\n  if (S += E, a[S++] !== ENCODED_TAG_INT)\n    throw new Error('Could not find expected \"int\" for \"s\"');\n  var k = a[S++];\n  if (v - S !== k)\n    throw new Error('\"s\" specified length of \"' + k + '\", expected \"' + (v - S) + '\"');\n  if (l < k)\n    throw new Error('\"s\" specified length of \"' + k + '\", max of \"' + l + '\" is acceptable');\n  var L = S;\n  if (S += k, S !== v)\n    throw new Error('Expected to consume entire buffer, but \"' + (v - S) + '\" bytes remain');\n  var M = c - E, $ = c - k, J = Buffer$5.allocUnsafe(M + E + $ + k);\n  for (S = 0; S < M; ++S)\n    J[S] = 0;\n  a.copy(J, S, _ + Math.max(-M, 0), _ + E), S = c;\n  for (var V = S; S < V + $; ++S)\n    J[S] = 0;\n  return a.copy(J, S, L + Math.max(-$, 0), L + k), J = J.toString(\"base64\"), J = base64Url(J), J;\n}\nfunction countPadding(a, u, c) {\n  for (var l = 0; u + l < c && a[u + l] === 0; )\n    ++l;\n  var v = a[u + l] >= MAX_OCTET;\n  return v && --l, l;\n}\nfunction joseToDer(a, u) {\n  a = signatureAsBuffer(a);\n  var c = getParamBytesForAlg(u), l = a.length;\n  if (l !== c * 2)\n    throw new TypeError('\"' + u + '\" signatures must be \"' + c * 2 + '\" bytes, saw \"' + l + '\"');\n  var v = countPadding(a, 0, c), S = countPadding(a, c, a.length), g = c - v, E = c - S, _ = 2 + g + 1 + 1 + E, k = _ < MAX_OCTET, L = Buffer$5.allocUnsafe((k ? 2 : 3) + _), M = 0;\n  return L[M++] = ENCODED_TAG_SEQ, k ? L[M++] = _ : (L[M++] = MAX_OCTET | 1, L[M++] = _ & 255), L[M++] = ENCODED_TAG_INT, L[M++] = g, v < 0 ? (L[M++] = 0, M += a.copy(L, M, 0, c)) : M += a.copy(L, M, v, c), L[M++] = ENCODED_TAG_INT, L[M++] = E, S < 0 ? (L[M++] = 0, a.copy(L, M, c)) : a.copy(L, M, c + S), L;\n}\nvar ecdsaSigFormatter = {\n  derToJose,\n  joseToDer\n}, bufferEqual = bufferEqualConstantTime, Buffer$4 = safeBufferExports.Buffer, crypto$1 = require$$0$1, formatEcdsa = ecdsaSigFormatter, util$2 = require$$0$1, MSG_INVALID_ALGORITHM = `\"%s\" is not a valid algorithm.\n  Supported algorithms are:\n  \"HS256\", \"HS384\", \"HS512\", \"RS256\", \"RS384\", \"RS512\", \"PS256\", \"PS384\", \"PS512\", \"ES256\", \"ES384\", \"ES512\" and \"none\".`, MSG_INVALID_SECRET = \"secret must be a string or buffer\", MSG_INVALID_VERIFIER_KEY = \"key must be a string or a buffer\", MSG_INVALID_SIGNER_KEY = \"key must be a string, a buffer or an object\", supportsKeyObjects = typeof crypto$1.createPublicKey == \"function\";\nsupportsKeyObjects && (MSG_INVALID_VERIFIER_KEY += \" or a KeyObject\", MSG_INVALID_SECRET += \"or a KeyObject\");\nfunction checkIsPublicKey(a) {\n  if (!Buffer$4.isBuffer(a) && typeof a != \"string\" && (!supportsKeyObjects || typeof a != \"object\" || typeof a.type != \"string\" || typeof a.asymmetricKeyType != \"string\" || typeof a.export != \"function\"))\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n}\nfunction checkIsPrivateKey(a) {\n  if (!Buffer$4.isBuffer(a) && typeof a != \"string\" && typeof a != \"object\")\n    throw typeError(MSG_INVALID_SIGNER_KEY);\n}\nfunction checkIsSecretKey(a) {\n  if (!Buffer$4.isBuffer(a)) {\n    if (typeof a == \"string\")\n      return a;\n    if (!supportsKeyObjects || typeof a != \"object\" || a.type !== \"secret\" || typeof a.export != \"function\")\n      throw typeError(MSG_INVALID_SECRET);\n  }\n}\nfunction fromBase64(a) {\n  return a.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction toBase64(a) {\n  a = a.toString();\n  var u = 4 - a.length % 4;\n  if (u !== 4)\n    for (var c = 0; c < u; ++c)\n      a += \"=\";\n  return a.replace(/\\-/g, \"+\").replace(/_/g, \"/\");\n}\nfunction typeError(a) {\n  var u = [].slice.call(arguments, 1), c = util$2.format.bind(util$2, a).apply(null, u);\n  return new TypeError(c);\n}\nfunction bufferOrString(a) {\n  return Buffer$4.isBuffer(a) || typeof a == \"string\";\n}\nfunction normalizeInput(a) {\n  return bufferOrString(a) || (a = JSON.stringify(a)), a;\n}\nfunction createHmacSigner(a) {\n  return function(c, l) {\n    checkIsSecretKey(l), c = normalizeInput(c);\n    var v = crypto$1.createHmac(\"sha\" + a, l), S = (v.update(c), v.digest(\"base64\"));\n    return fromBase64(S);\n  };\n}\nfunction createHmacVerifier(a) {\n  return function(c, l, v) {\n    var S = createHmacSigner(a)(c, v);\n    return bufferEqual(Buffer$4.from(l), Buffer$4.from(S));\n  };\n}\nfunction createKeySigner(a) {\n  return function(c, l) {\n    checkIsPrivateKey(l), c = normalizeInput(c);\n    var v = crypto$1.createSign(\"RSA-SHA\" + a), S = (v.update(c), v.sign(l, \"base64\"));\n    return fromBase64(S);\n  };\n}\nfunction createKeyVerifier(a) {\n  return function(c, l, v) {\n    checkIsPublicKey(v), c = normalizeInput(c), l = toBase64(l);\n    var S = crypto$1.createVerify(\"RSA-SHA\" + a);\n    return S.update(c), S.verify(v, l, \"base64\");\n  };\n}\nfunction createPSSKeySigner(a) {\n  return function(c, l) {\n    checkIsPrivateKey(l), c = normalizeInput(c);\n    var v = crypto$1.createSign(\"RSA-SHA\" + a), S = (v.update(c), v.sign({\n      key: l,\n      padding: crypto$1.constants.RSA_PKCS1_PSS_PADDING,\n      saltLength: crypto$1.constants.RSA_PSS_SALTLEN_DIGEST\n    }, \"base64\"));\n    return fromBase64(S);\n  };\n}\nfunction createPSSKeyVerifier(a) {\n  return function(c, l, v) {\n    checkIsPublicKey(v), c = normalizeInput(c), l = toBase64(l);\n    var S = crypto$1.createVerify(\"RSA-SHA\" + a);\n    return S.update(c), S.verify({\n      key: v,\n      padding: crypto$1.constants.RSA_PKCS1_PSS_PADDING,\n      saltLength: crypto$1.constants.RSA_PSS_SALTLEN_DIGEST\n    }, l, \"base64\");\n  };\n}\nfunction createECDSASigner(a) {\n  var u = createKeySigner(a);\n  return function() {\n    var l = u.apply(null, arguments);\n    return l = formatEcdsa.derToJose(l, \"ES\" + a), l;\n  };\n}\nfunction createECDSAVerifer(a) {\n  var u = createKeyVerifier(a);\n  return function(l, v, S) {\n    v = formatEcdsa.joseToDer(v, \"ES\" + a).toString(\"base64\");\n    var g = u(l, v, S);\n    return g;\n  };\n}\nfunction createNoneSigner() {\n  return function() {\n    return \"\";\n  };\n}\nfunction createNoneVerifier() {\n  return function(u, c) {\n    return c === \"\";\n  };\n}\nvar jwa$2 = function a(u) {\n  var c = {\n    hs: createHmacSigner,\n    rs: createKeySigner,\n    ps: createPSSKeySigner,\n    es: createECDSASigner,\n    none: createNoneSigner\n  }, l = {\n    hs: createHmacVerifier,\n    rs: createKeyVerifier,\n    ps: createPSSKeyVerifier,\n    es: createECDSAVerifer,\n    none: createNoneVerifier\n  }, v = u.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);\n  if (!v)\n    throw typeError(MSG_INVALID_ALGORITHM, u);\n  var S = (v[1] || v[3]).toLowerCase(), g = v[2];\n  return {\n    sign: c[S](g),\n    verify: l[S](g)\n  };\n}, Buffer$3 = require$$0$1.Buffer, tostring = function a(u) {\n  return typeof u == \"string\" ? u : typeof u == \"number\" || Buffer$3.isBuffer(u) ? u.toString() : JSON.stringify(u);\n}, Buffer$2 = safeBufferExports.Buffer, DataStream$1 = dataStream, jwa$1 = jwa$2, Stream$1 = require$$0$1, toString$2 = tostring, util$1 = require$$0$1;\nfunction base64url(a, u) {\n  return Buffer$2.from(a, u).toString(\"base64\").replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction jwsSecuredInput(a, u, c) {\n  c = c || \"utf8\";\n  var l = base64url(toString$2(a), \"binary\"), v = base64url(toString$2(u), c);\n  return util$1.format(\"%s.%s\", l, v);\n}\nfunction jwsSign(a) {\n  var u = a.header, c = a.payload, l = a.secret || a.privateKey, v = a.encoding, S = jwa$1(u.alg), g = jwsSecuredInput(u, c, v), E = S.sign(g, l);\n  return util$1.format(\"%s.%s\", g, E);\n}\nfunction SignStream$1(a) {\n  var u = a.secret || a.privateKey || a.key, c = new DataStream$1(u);\n  this.readable = !0, this.header = a.header, this.encoding = a.encoding, this.secret = this.privateKey = this.key = c, this.payload = new DataStream$1(a.payload), this.secret.once(\"close\", (function() {\n    !this.payload.writable && this.readable && this.sign();\n  }).bind(this)), this.payload.once(\"close\", (function() {\n    !this.secret.writable && this.readable && this.sign();\n  }).bind(this));\n}\nutil$1.inherits(SignStream$1, Stream$1);\nSignStream$1.prototype.sign = function a() {\n  try {\n    var u = jwsSign({\n      header: this.header,\n      payload: this.payload.buffer,\n      secret: this.secret.buffer,\n      encoding: this.encoding\n    });\n    return this.emit(\"done\", u), this.emit(\"data\", u), this.emit(\"end\"), this.readable = !1, u;\n  } catch (c) {\n    this.readable = !1, this.emit(\"error\", c), this.emit(\"close\");\n  }\n};\nSignStream$1.sign = jwsSign;\nvar signStream = SignStream$1, Buffer$1 = safeBufferExports.Buffer, DataStream = dataStream, jwa = jwa$2, Stream = require$$0$1, toString$1 = tostring, util = require$$0$1, JWS_REGEX = /^[a-zA-Z0-9\\-_]+?\\.[a-zA-Z0-9\\-_]+?\\.([a-zA-Z0-9\\-_]+)?$/;\nfunction isObject$7(a) {\n  return Object.prototype.toString.call(a) === \"[object Object]\";\n}\nfunction safeJsonParse(a) {\n  if (isObject$7(a))\n    return a;\n  try {\n    return JSON.parse(a);\n  } catch {\n    return;\n  }\n}\nfunction headerFromJWS(a) {\n  var u = a.split(\".\", 1)[0];\n  return safeJsonParse(Buffer$1.from(u, \"base64\").toString(\"binary\"));\n}\nfunction securedInputFromJWS(a) {\n  return a.split(\".\", 2).join(\".\");\n}\nfunction signatureFromJWS(a) {\n  return a.split(\".\")[2];\n}\nfunction payloadFromJWS(a, u) {\n  u = u || \"utf8\";\n  var c = a.split(\".\")[1];\n  return Buffer$1.from(c, \"base64\").toString(u);\n}\nfunction isValidJws(a) {\n  return JWS_REGEX.test(a) && !!headerFromJWS(a);\n}\nfunction jwsVerify(a, u, c) {\n  if (!u) {\n    var l = new Error(\"Missing algorithm parameter for jws.verify\");\n    throw l.code = \"MISSING_ALGORITHM\", l;\n  }\n  a = toString$1(a);\n  var v = signatureFromJWS(a), S = securedInputFromJWS(a), g = jwa(u);\n  return g.verify(S, v, c);\n}\nfunction jwsDecode(a, u) {\n  if (u = u || {}, a = toString$1(a), !isValidJws(a))\n    return null;\n  var c = headerFromJWS(a);\n  if (!c)\n    return null;\n  var l = payloadFromJWS(a);\n  return (c.typ === \"JWT\" || u.json) && (l = JSON.parse(l, u.encoding)), {\n    header: c,\n    payload: l,\n    signature: signatureFromJWS(a)\n  };\n}\nfunction VerifyStream$1(a) {\n  a = a || {};\n  var u = a.secret || a.publicKey || a.key, c = new DataStream(u);\n  this.readable = !0, this.algorithm = a.algorithm, this.encoding = a.encoding, this.secret = this.publicKey = this.key = c, this.signature = new DataStream(a.signature), this.secret.once(\"close\", (function() {\n    !this.signature.writable && this.readable && this.verify();\n  }).bind(this)), this.signature.once(\"close\", (function() {\n    !this.secret.writable && this.readable && this.verify();\n  }).bind(this));\n}\nutil.inherits(VerifyStream$1, Stream);\nVerifyStream$1.prototype.verify = function a() {\n  try {\n    var u = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer), c = jwsDecode(this.signature.buffer, this.encoding);\n    return this.emit(\"done\", u, c), this.emit(\"data\", u), this.emit(\"end\"), this.readable = !1, u;\n  } catch (l) {\n    this.readable = !1, this.emit(\"error\", l), this.emit(\"close\");\n  }\n};\nVerifyStream$1.decode = jwsDecode;\nVerifyStream$1.isValid = isValidJws;\nVerifyStream$1.verify = jwsVerify;\nvar verifyStream = VerifyStream$1, SignStream = signStream, VerifyStream = verifyStream, ALGORITHMS = [\n  \"HS256\",\n  \"HS384\",\n  \"HS512\",\n  \"RS256\",\n  \"RS384\",\n  \"RS512\",\n  \"PS256\",\n  \"PS384\",\n  \"PS512\",\n  \"ES256\",\n  \"ES384\",\n  \"ES512\"\n];\njws$3.ALGORITHMS = ALGORITHMS;\njws$3.sign = SignStream.sign;\njws$3.verify = VerifyStream.verify;\njws$3.decode = VerifyStream.decode;\njws$3.isValid = VerifyStream.isValid;\njws$3.createSign = function a(u) {\n  return new SignStream(u);\n};\njws$3.createVerify = function a(u) {\n  return new VerifyStream(u);\n};\nvar jws$2 = jws$3, decode$1 = function(a, u) {\n  u = u || {};\n  var c = jws$2.decode(a, u);\n  if (!c)\n    return null;\n  var l = c.payload;\n  if (typeof l == \"string\")\n    try {\n      var v = JSON.parse(l);\n      v !== null && typeof v == \"object\" && (l = v);\n    } catch {\n    }\n  return u.complete === !0 ? {\n    header: c.header,\n    payload: l,\n    signature: c.signature\n  } : l;\n}, JsonWebTokenError$3 = function(a, u) {\n  Error.call(this, a), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.name = \"JsonWebTokenError\", this.message = a, u && (this.inner = u);\n};\nJsonWebTokenError$3.prototype = Object.create(Error.prototype);\nJsonWebTokenError$3.prototype.constructor = JsonWebTokenError$3;\nvar JsonWebTokenError_1 = JsonWebTokenError$3, JsonWebTokenError$2 = JsonWebTokenError_1, NotBeforeError$1 = function(a, u) {\n  JsonWebTokenError$2.call(this, a), this.name = \"NotBeforeError\", this.date = u;\n};\nNotBeforeError$1.prototype = Object.create(JsonWebTokenError$2.prototype);\nNotBeforeError$1.prototype.constructor = NotBeforeError$1;\nvar NotBeforeError_1 = NotBeforeError$1, JsonWebTokenError$1 = JsonWebTokenError_1, TokenExpiredError$1 = function(a, u) {\n  JsonWebTokenError$1.call(this, a), this.name = \"TokenExpiredError\", this.expiredAt = u;\n};\nTokenExpiredError$1.prototype = Object.create(JsonWebTokenError$1.prototype);\nTokenExpiredError$1.prototype.constructor = TokenExpiredError$1;\nvar TokenExpiredError_1 = TokenExpiredError$1, s = 1e3, m = s * 60, h = m * 60, d = h * 24, w = d * 7, y = d * 365.25, ms$1 = function(a, u) {\n  u = u || {};\n  var c = typeof a;\n  if (c === \"string\" && a.length > 0)\n    return parse$2(a);\n  if (c === \"number\" && isFinite(a))\n    return u.long ? fmtLong(a) : fmtShort(a);\n  throw new Error(\n    \"val is not a non-empty string or a valid number. val=\" + JSON.stringify(a)\n  );\n};\nfunction parse$2(a) {\n  if (a = String(a), !(a.length > 100)) {\n    var u = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n      a\n    );\n    if (u) {\n      var c = parseFloat(u[1]), l = (u[2] || \"ms\").toLowerCase();\n      switch (l) {\n        case \"years\":\n        case \"year\":\n        case \"yrs\":\n        case \"yr\":\n        case \"y\":\n          return c * y;\n        case \"weeks\":\n        case \"week\":\n        case \"w\":\n          return c * w;\n        case \"days\":\n        case \"day\":\n        case \"d\":\n          return c * d;\n        case \"hours\":\n        case \"hour\":\n        case \"hrs\":\n        case \"hr\":\n        case \"h\":\n          return c * h;\n        case \"minutes\":\n        case \"minute\":\n        case \"mins\":\n        case \"min\":\n        case \"m\":\n          return c * m;\n        case \"seconds\":\n        case \"second\":\n        case \"secs\":\n        case \"sec\":\n        case \"s\":\n          return c * s;\n        case \"milliseconds\":\n        case \"millisecond\":\n        case \"msecs\":\n        case \"msec\":\n        case \"ms\":\n          return c;\n        default:\n          return;\n      }\n    }\n  }\n}\nfunction fmtShort(a) {\n  var u = Math.abs(a);\n  return u >= d ? Math.round(a / d) + \"d\" : u >= h ? Math.round(a / h) + \"h\" : u >= m ? Math.round(a / m) + \"m\" : u >= s ? Math.round(a / s) + \"s\" : a + \"ms\";\n}\nfunction fmtLong(a) {\n  var u = Math.abs(a);\n  return u >= d ? plural(a, u, d, \"day\") : u >= h ? plural(a, u, h, \"hour\") : u >= m ? plural(a, u, m, \"minute\") : u >= s ? plural(a, u, s, \"second\") : a + \" ms\";\n}\nfunction plural(a, u, c, l) {\n  var v = u >= c * 1.5;\n  return Math.round(a / c) + \" \" + l + (v ? \"s\" : \"\");\n}\nvar ms = ms$1, timespan$2 = function(a, u) {\n  var c = u || Math.floor(Date.now() / 1e3);\n  if (typeof a == \"string\") {\n    var l = ms(a);\n    return typeof l > \"u\" ? void 0 : Math.floor(c + l / 1e3);\n  } else\n    return typeof a == \"number\" ? c + a : void 0;\n}, semver$1 = { exports: {} };\n(function(a, u) {\n  u = a.exports = Ie;\n  var c;\n  typeof process == \"object\" && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG) ? c = function() {\n    var pe = Array.prototype.slice.call(arguments, 0);\n    pe.unshift(\"SEMVER\"), console.log.apply(console, pe);\n  } : c = function() {\n  }, u.SEMVER_SPEC_VERSION = \"2.0.0\";\n  var l = 256, v = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */\n  9007199254740991, S = 16, g = u.re = [], E = u.src = [], _ = 0, k = _++;\n  E[k] = \"0|[1-9]\\\\d*\";\n  var L = _++;\n  E[L] = \"[0-9]+\";\n  var M = _++;\n  E[M] = \"\\\\d*[a-zA-Z-][a-zA-Z0-9-]*\";\n  var $ = _++;\n  E[$] = \"(\" + E[k] + \")\\\\.(\" + E[k] + \")\\\\.(\" + E[k] + \")\";\n  var J = _++;\n  E[J] = \"(\" + E[L] + \")\\\\.(\" + E[L] + \")\\\\.(\" + E[L] + \")\";\n  var V = _++;\n  E[V] = \"(?:\" + E[k] + \"|\" + E[M] + \")\";\n  var q = _++;\n  E[q] = \"(?:\" + E[L] + \"|\" + E[M] + \")\";\n  var G = _++;\n  E[G] = \"(?:-(\" + E[V] + \"(?:\\\\.\" + E[V] + \")*))\";\n  var H = _++;\n  E[H] = \"(?:-?(\" + E[q] + \"(?:\\\\.\" + E[q] + \")*))\";\n  var B = _++;\n  E[B] = \"[0-9A-Za-z-]+\";\n  var Y = _++;\n  E[Y] = \"(?:\\\\+(\" + E[B] + \"(?:\\\\.\" + E[B] + \")*))\";\n  var ne = _++, Z = \"v?\" + E[$] + E[G] + \"?\" + E[Y] + \"?\";\n  E[ne] = \"^\" + Z + \"$\";\n  var re = \"[v=\\\\s]*\" + E[J] + E[H] + \"?\" + E[Y] + \"?\", oe = _++;\n  E[oe] = \"^\" + re + \"$\";\n  var de = _++;\n  E[de] = \"((?:<|>)?=?)\";\n  var A = _++;\n  E[A] = E[L] + \"|x|X|\\\\*\";\n  var N = _++;\n  E[N] = E[k] + \"|x|X|\\\\*\";\n  var D = _++;\n  E[D] = \"[v=\\\\s]*(\" + E[N] + \")(?:\\\\.(\" + E[N] + \")(?:\\\\.(\" + E[N] + \")(?:\" + E[G] + \")?\" + E[Y] + \"?)?)?\";\n  var W = _++;\n  E[W] = \"[v=\\\\s]*(\" + E[A] + \")(?:\\\\.(\" + E[A] + \")(?:\\\\.(\" + E[A] + \")(?:\" + E[H] + \")?\" + E[Y] + \"?)?)?\";\n  var ee = _++;\n  E[ee] = \"^\" + E[de] + \"\\\\s*\" + E[D] + \"$\";\n  var ae = _++;\n  E[ae] = \"^\" + E[de] + \"\\\\s*\" + E[W] + \"$\";\n  var ye = _++;\n  E[ye] = \"(?:^|[^\\\\d])(\\\\d{1,\" + S + \"})(?:\\\\.(\\\\d{1,\" + S + \"}))?(?:\\\\.(\\\\d{1,\" + S + \"}))?(?:$|[^\\\\d])\";\n  var he = _++;\n  E[he] = \"(?:~>?)\";\n  var le = _++;\n  E[le] = \"(\\\\s*)\" + E[he] + \"\\\\s+\", g[le] = new RegExp(E[le], \"g\");\n  var we = \"$1~\", Be = _++;\n  E[Be] = \"^\" + E[he] + E[D] + \"$\";\n  var Ne = _++;\n  E[Ne] = \"^\" + E[he] + E[W] + \"$\";\n  var Le = _++;\n  E[Le] = \"(?:\\\\^)\";\n  var $e = _++;\n  E[$e] = \"(\\\\s*)\" + E[Le] + \"\\\\s+\", g[$e] = new RegExp(E[$e], \"g\");\n  var Ue = \"$1^\", Ge = _++;\n  E[Ge] = \"^\" + E[Le] + E[D] + \"$\";\n  var He = _++;\n  E[He] = \"^\" + E[Le] + E[W] + \"$\";\n  var Ve = _++;\n  E[Ve] = \"^\" + E[de] + \"\\\\s*(\" + re + \")$|^$\";\n  var be = _++;\n  E[be] = \"^\" + E[de] + \"\\\\s*(\" + Z + \")$|^$\";\n  var Ae = _++;\n  E[Ae] = \"(\\\\s*)\" + E[de] + \"\\\\s*(\" + re + \"|\" + E[D] + \")\", g[Ae] = new RegExp(E[Ae], \"g\");\n  var qe = \"$1$2$3\", xe = _++;\n  E[xe] = \"^\\\\s*(\" + E[D] + \")\\\\s+-\\\\s+(\" + E[D] + \")\\\\s*$\";\n  var Pe = _++;\n  E[Pe] = \"^\\\\s*(\" + E[W] + \")\\\\s+-\\\\s+(\" + E[W] + \")\\\\s*$\";\n  var C = _++;\n  E[C] = \"(<|>)?=?\\\\s*\\\\*\";\n  for (var x = 0; x < _; x++)\n    c(x, E[x]), g[x] || (g[x] = new RegExp(E[x]));\n  u.parse = Q;\n  function Q(pe, ge) {\n    if ((!ge || typeof ge != \"object\") && (ge = {\n      loose: !!ge,\n      includePrerelease: !1\n    }), pe instanceof Ie)\n      return pe;\n    if (typeof pe != \"string\" || pe.length > l)\n      return null;\n    var Re = ge.loose ? g[oe] : g[ne];\n    if (!Re.test(pe))\n      return null;\n    try {\n      return new Ie(pe, ge);\n    } catch {\n      return null;\n    }\n  }\n  u.valid = Se;\n  function Se(pe, ge) {\n    var Re = Q(pe, ge);\n    return Re ? Re.version : null;\n  }\n  u.clean = me;\n  function me(pe, ge) {\n    var Re = Q(pe.trim().replace(/^[=v]+/, \"\"), ge);\n    return Re ? Re.version : null;\n  }\n  u.SemVer = Ie;\n  function Ie(pe, ge) {\n    if ((!ge || typeof ge != \"object\") && (ge = {\n      loose: !!ge,\n      includePrerelease: !1\n    }), pe instanceof Ie) {\n      if (pe.loose === ge.loose)\n        return pe;\n      pe = pe.version;\n    } else if (typeof pe != \"string\")\n      throw new TypeError(\"Invalid Version: \" + pe);\n    if (pe.length > l)\n      throw new TypeError(\"version is longer than \" + l + \" characters\");\n    if (!(this instanceof Ie))\n      return new Ie(pe, ge);\n    c(\"SemVer\", pe, ge), this.options = ge, this.loose = !!ge.loose;\n    var Re = pe.trim().match(ge.loose ? g[oe] : g[ne]);\n    if (!Re)\n      throw new TypeError(\"Invalid Version: \" + pe);\n    if (this.raw = pe, this.major = +Re[1], this.minor = +Re[2], this.patch = +Re[3], this.major > v || this.major < 0)\n      throw new TypeError(\"Invalid major version\");\n    if (this.minor > v || this.minor < 0)\n      throw new TypeError(\"Invalid minor version\");\n    if (this.patch > v || this.patch < 0)\n      throw new TypeError(\"Invalid patch version\");\n    Re[4] ? this.prerelease = Re[4].split(\".\").map(function(Je) {\n      if (/^[0-9]+$/.test(Je)) {\n        var Fe = +Je;\n        if (Fe >= 0 && Fe < v)\n          return Fe;\n      }\n      return Je;\n    }) : this.prerelease = [], this.build = Re[5] ? Re[5].split(\".\") : [], this.format();\n  }\n  Ie.prototype.format = function() {\n    return this.version = this.major + \".\" + this.minor + \".\" + this.patch, this.prerelease.length && (this.version += \"-\" + this.prerelease.join(\".\")), this.version;\n  }, Ie.prototype.toString = function() {\n    return this.version;\n  }, Ie.prototype.compare = function(pe) {\n    return c(\"SemVer.compare\", this.version, this.options, pe), pe instanceof Ie || (pe = new Ie(pe, this.options)), this.compareMain(pe) || this.comparePre(pe);\n  }, Ie.prototype.compareMain = function(pe) {\n    return pe instanceof Ie || (pe = new Ie(pe, this.options)), tt(this.major, pe.major) || tt(this.minor, pe.minor) || tt(this.patch, pe.patch);\n  }, Ie.prototype.comparePre = function(pe) {\n    if (pe instanceof Ie || (pe = new Ie(pe, this.options)), this.prerelease.length && !pe.prerelease.length)\n      return -1;\n    if (!this.prerelease.length && pe.prerelease.length)\n      return 1;\n    if (!this.prerelease.length && !pe.prerelease.length)\n      return 0;\n    var ge = 0;\n    do {\n      var Re = this.prerelease[ge], Je = pe.prerelease[ge];\n      if (c(\"prerelease compare\", ge, Re, Je), Re === void 0 && Je === void 0)\n        return 0;\n      if (Je === void 0)\n        return 1;\n      if (Re === void 0)\n        return -1;\n      if (Re === Je)\n        continue;\n      return tt(Re, Je);\n    } while (++ge);\n  }, Ie.prototype.inc = function(pe, ge) {\n    switch (pe) {\n      case \"premajor\":\n        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc(\"pre\", ge);\n        break;\n      case \"preminor\":\n        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc(\"pre\", ge);\n        break;\n      case \"prepatch\":\n        this.prerelease.length = 0, this.inc(\"patch\", ge), this.inc(\"pre\", ge);\n        break;\n      case \"prerelease\":\n        this.prerelease.length === 0 && this.inc(\"patch\", ge), this.inc(\"pre\", ge);\n        break;\n      case \"major\":\n        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];\n        break;\n      case \"minor\":\n        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];\n        break;\n      case \"patch\":\n        this.prerelease.length === 0 && this.patch++, this.prerelease = [];\n        break;\n      case \"pre\":\n        if (this.prerelease.length === 0)\n          this.prerelease = [0];\n        else {\n          for (var Re = this.prerelease.length; --Re >= 0; )\n            typeof this.prerelease[Re] == \"number\" && (this.prerelease[Re]++, Re = -2);\n          Re === -1 && this.prerelease.push(0);\n        }\n        ge && (this.prerelease[0] === ge ? isNaN(this.prerelease[1]) && (this.prerelease = [ge, 0]) : this.prerelease = [ge, 0]);\n        break;\n      default:\n        throw new Error(\"invalid increment argument: \" + pe);\n    }\n    return this.format(), this.raw = this.version, this;\n  }, u.inc = at;\n  function at(pe, ge, Re, Je) {\n    typeof Re == \"string\" && (Je = Re, Re = void 0);\n    try {\n      return new Ie(pe, Re).inc(ge, Je).version;\n    } catch {\n      return null;\n    }\n  }\n  u.diff = Ye;\n  function Ye(pe, ge) {\n    if (De(pe, ge))\n      return null;\n    var Re = Q(pe), Je = Q(ge), Fe = \"\";\n    if (Re.prerelease.length || Je.prerelease.length) {\n      Fe = \"pre\";\n      var ze = \"prerelease\";\n    }\n    for (var Me in Re)\n      if ((Me === \"major\" || Me === \"minor\" || Me === \"patch\") && Re[Me] !== Je[Me])\n        return Fe + Me;\n    return ze;\n  }\n  u.compareIdentifiers = tt;\n  var je = /^[0-9]+$/;\n  function tt(pe, ge) {\n    var Re = je.test(pe), Je = je.test(ge);\n    return Re && Je && (pe = +pe, ge = +ge), pe === ge ? 0 : Re && !Je ? -1 : Je && !Re ? 1 : pe < ge ? -1 : 1;\n  }\n  u.rcompareIdentifiers = Oe;\n  function Oe(pe, ge) {\n    return tt(ge, pe);\n  }\n  u.major = P;\n  function P(pe, ge) {\n    return new Ie(pe, ge).major;\n  }\n  u.minor = X;\n  function X(pe, ge) {\n    return new Ie(pe, ge).minor;\n  }\n  u.patch = ie;\n  function ie(pe, ge) {\n    return new Ie(pe, ge).patch;\n  }\n  u.compare = Ee;\n  function Ee(pe, ge, Re) {\n    return new Ie(pe, Re).compare(new Ie(ge, Re));\n  }\n  u.compareLoose = ue;\n  function ue(pe, ge) {\n    return Ee(pe, ge, !0);\n  }\n  u.rcompare = O;\n  function O(pe, ge, Re) {\n    return Ee(ge, pe, Re);\n  }\n  u.sort = j;\n  function j(pe, ge) {\n    return pe.sort(function(Re, Je) {\n      return u.compare(Re, Je, ge);\n    });\n  }\n  u.rsort = se;\n  function se(pe, ge) {\n    return pe.sort(function(Re, Je) {\n      return u.rcompare(Re, Je, ge);\n    });\n  }\n  u.gt = _e;\n  function _e(pe, ge, Re) {\n    return Ee(pe, ge, Re) > 0;\n  }\n  u.lt = ve;\n  function ve(pe, ge, Re) {\n    return Ee(pe, ge, Re) < 0;\n  }\n  u.eq = De;\n  function De(pe, ge, Re) {\n    return Ee(pe, ge, Re) === 0;\n  }\n  u.neq = Ze;\n  function Ze(pe, ge, Re) {\n    return Ee(pe, ge, Re) !== 0;\n  }\n  u.gte = Qe;\n  function Qe(pe, ge, Re) {\n    return Ee(pe, ge, Re) >= 0;\n  }\n  u.lte = ot;\n  function ot(pe, ge, Re) {\n    return Ee(pe, ge, Re) <= 0;\n  }\n  u.cmp = ft;\n  function ft(pe, ge, Re, Je) {\n    switch (ge) {\n      case \"===\":\n        return typeof pe == \"object\" && (pe = pe.version), typeof Re == \"object\" && (Re = Re.version), pe === Re;\n      case \"!==\":\n        return typeof pe == \"object\" && (pe = pe.version), typeof Re == \"object\" && (Re = Re.version), pe !== Re;\n      case \"\":\n      case \"=\":\n      case \"==\":\n        return De(pe, Re, Je);\n      case \"!=\":\n        return Ze(pe, Re, Je);\n      case \">\":\n        return _e(pe, Re, Je);\n      case \">=\":\n        return Qe(pe, Re, Je);\n      case \"<\":\n        return ve(pe, Re, Je);\n      case \"<=\":\n        return ot(pe, Re, Je);\n      default:\n        throw new TypeError(\"Invalid operator: \" + ge);\n    }\n  }\n  u.Comparator = Ce;\n  function Ce(pe, ge) {\n    if ((!ge || typeof ge != \"object\") && (ge = {\n      loose: !!ge,\n      includePrerelease: !1\n    }), pe instanceof Ce) {\n      if (pe.loose === !!ge.loose)\n        return pe;\n      pe = pe.value;\n    }\n    if (!(this instanceof Ce))\n      return new Ce(pe, ge);\n    c(\"comparator\", pe, ge), this.options = ge, this.loose = !!ge.loose, this.parse(pe), this.semver === I ? this.value = \"\" : this.value = this.operator + this.semver.version, c(\"comp\", this);\n  }\n  var I = {};\n  Ce.prototype.parse = function(pe) {\n    var ge = this.options.loose ? g[Ve] : g[be], Re = pe.match(ge);\n    if (!Re)\n      throw new TypeError(\"Invalid comparator: \" + pe);\n    this.operator = Re[1], this.operator === \"=\" && (this.operator = \"\"), Re[2] ? this.semver = new Ie(Re[2], this.options.loose) : this.semver = I;\n  }, Ce.prototype.toString = function() {\n    return this.value;\n  }, Ce.prototype.test = function(pe) {\n    return c(\"Comparator.test\", pe, this.options.loose), this.semver === I ? !0 : (typeof pe == \"string\" && (pe = new Ie(pe, this.options)), ft(pe, this.operator, this.semver, this.options));\n  }, Ce.prototype.intersects = function(pe, ge) {\n    if (!(pe instanceof Ce))\n      throw new TypeError(\"a Comparator is required\");\n    (!ge || typeof ge != \"object\") && (ge = {\n      loose: !!ge,\n      includePrerelease: !1\n    });\n    var Re;\n    if (this.operator === \"\")\n      return Re = new F(pe.value, ge), St(this.value, Re, ge);\n    if (pe.operator === \"\")\n      return Re = new F(this.value, ge), St(pe.semver, Re, ge);\n    var Je = (this.operator === \">=\" || this.operator === \">\") && (pe.operator === \">=\" || pe.operator === \">\"), Fe = (this.operator === \"<=\" || this.operator === \"<\") && (pe.operator === \"<=\" || pe.operator === \"<\"), ze = this.semver.version === pe.semver.version, Me = (this.operator === \">=\" || this.operator === \"<=\") && (pe.operator === \">=\" || pe.operator === \"<=\"), nt = ft(this.semver, \"<\", pe.semver, ge) && (this.operator === \">=\" || this.operator === \">\") && (pe.operator === \"<=\" || pe.operator === \"<\"), rt = ft(this.semver, \">\", pe.semver, ge) && (this.operator === \"<=\" || this.operator === \"<\") && (pe.operator === \">=\" || pe.operator === \">\");\n    return Je || Fe || ze && Me || nt || rt;\n  }, u.Range = F;\n  function F(pe, ge) {\n    if ((!ge || typeof ge != \"object\") && (ge = {\n      loose: !!ge,\n      includePrerelease: !1\n    }), pe instanceof F)\n      return pe.loose === !!ge.loose && pe.includePrerelease === !!ge.includePrerelease ? pe : new F(pe.raw, ge);\n    if (pe instanceof Ce)\n      return new F(pe.value, ge);\n    if (!(this instanceof F))\n      return new F(pe, ge);\n    if (this.options = ge, this.loose = !!ge.loose, this.includePrerelease = !!ge.includePrerelease, this.raw = pe, this.set = pe.split(/\\s*\\|\\|\\s*/).map(function(Re) {\n      return this.parseRange(Re.trim());\n    }, this).filter(function(Re) {\n      return Re.length;\n    }), !this.set.length)\n      throw new TypeError(\"Invalid SemVer Range: \" + pe);\n    this.format();\n  }\n  F.prototype.format = function() {\n    return this.range = this.set.map(function(pe) {\n      return pe.join(\" \").trim();\n    }).join(\"||\").trim(), this.range;\n  }, F.prototype.toString = function() {\n    return this.range;\n  }, F.prototype.parseRange = function(pe) {\n    var ge = this.options.loose;\n    pe = pe.trim();\n    var Re = ge ? g[Pe] : g[xe];\n    pe = pe.replace(Re, gt), c(\"hyphen replace\", pe), pe = pe.replace(g[Ae], qe), c(\"comparator trim\", pe, g[Ae]), pe = pe.replace(g[le], we), pe = pe.replace(g[$e], Ue), pe = pe.split(/\\s+/).join(\" \");\n    var Je = ge ? g[Ve] : g[be], Fe = pe.split(\" \").map(function(ze) {\n      return Te(ze, this.options);\n    }, this).join(\" \").split(/\\s+/);\n    return this.options.loose && (Fe = Fe.filter(function(ze) {\n      return !!ze.match(Je);\n    })), Fe = Fe.map(function(ze) {\n      return new Ce(ze, this.options);\n    }, this), Fe;\n  }, F.prototype.intersects = function(pe, ge) {\n    if (!(pe instanceof F))\n      throw new TypeError(\"a Range is required\");\n    return this.set.some(function(Re) {\n      return Re.every(function(Je) {\n        return pe.set.some(function(Fe) {\n          return Fe.every(function(ze) {\n            return Je.intersects(ze, ge);\n          });\n        });\n      });\n    });\n  }, u.toComparators = z;\n  function z(pe, ge) {\n    return new F(pe, ge).set.map(function(Re) {\n      return Re.map(function(Je) {\n        return Je.value;\n      }).join(\" \").trim().split(\" \");\n    });\n  }\n  function Te(pe, ge) {\n    return c(\"comp\", pe, ge), pe = mt(pe, ge), c(\"caret\", pe), pe = ke(pe, ge), c(\"tildes\", pe), pe = st(pe, ge), c(\"xrange\", pe), pe = yt(pe, ge), c(\"stars\", pe), pe;\n  }\n  function fe(pe) {\n    return !pe || pe.toLowerCase() === \"x\" || pe === \"*\";\n  }\n  function ke(pe, ge) {\n    return pe.trim().split(/\\s+/).map(function(Re) {\n      return it(Re, ge);\n    }).join(\" \");\n  }\n  function it(pe, ge) {\n    var Re = ge.loose ? g[Ne] : g[Be];\n    return pe.replace(Re, function(Je, Fe, ze, Me, nt) {\n      c(\"tilde\", pe, Je, Fe, ze, Me, nt);\n      var rt;\n      return fe(Fe) ? rt = \"\" : fe(ze) ? rt = \">=\" + Fe + \".0.0 <\" + (+Fe + 1) + \".0.0\" : fe(Me) ? rt = \">=\" + Fe + \".\" + ze + \".0 <\" + Fe + \".\" + (+ze + 1) + \".0\" : nt ? (c(\"replaceTilde pr\", nt), rt = \">=\" + Fe + \".\" + ze + \".\" + Me + \"-\" + nt + \" <\" + Fe + \".\" + (+ze + 1) + \".0\") : rt = \">=\" + Fe + \".\" + ze + \".\" + Me + \" <\" + Fe + \".\" + (+ze + 1) + \".0\", c(\"tilde return\", rt), rt;\n    });\n  }\n  function mt(pe, ge) {\n    return pe.trim().split(/\\s+/).map(function(Re) {\n      return vt(Re, ge);\n    }).join(\" \");\n  }\n  function vt(pe, ge) {\n    c(\"caret\", pe, ge);\n    var Re = ge.loose ? g[He] : g[Ge];\n    return pe.replace(Re, function(Je, Fe, ze, Me, nt) {\n      c(\"caret\", pe, Je, Fe, ze, Me, nt);\n      var rt;\n      return fe(Fe) ? rt = \"\" : fe(ze) ? rt = \">=\" + Fe + \".0.0 <\" + (+Fe + 1) + \".0.0\" : fe(Me) ? Fe === \"0\" ? rt = \">=\" + Fe + \".\" + ze + \".0 <\" + Fe + \".\" + (+ze + 1) + \".0\" : rt = \">=\" + Fe + \".\" + ze + \".0 <\" + (+Fe + 1) + \".0.0\" : nt ? (c(\"replaceCaret pr\", nt), Fe === \"0\" ? ze === \"0\" ? rt = \">=\" + Fe + \".\" + ze + \".\" + Me + \"-\" + nt + \" <\" + Fe + \".\" + ze + \".\" + (+Me + 1) : rt = \">=\" + Fe + \".\" + ze + \".\" + Me + \"-\" + nt + \" <\" + Fe + \".\" + (+ze + 1) + \".0\" : rt = \">=\" + Fe + \".\" + ze + \".\" + Me + \"-\" + nt + \" <\" + (+Fe + 1) + \".0.0\") : (c(\"no pr\"), Fe === \"0\" ? ze === \"0\" ? rt = \">=\" + Fe + \".\" + ze + \".\" + Me + \" <\" + Fe + \".\" + ze + \".\" + (+Me + 1) : rt = \">=\" + Fe + \".\" + ze + \".\" + Me + \" <\" + Fe + \".\" + (+ze + 1) + \".0\" : rt = \">=\" + Fe + \".\" + ze + \".\" + Me + \" <\" + (+Fe + 1) + \".0.0\"), c(\"caret return\", rt), rt;\n    });\n  }\n  function st(pe, ge) {\n    return c(\"replaceXRanges\", pe, ge), pe.split(/\\s+/).map(function(Re) {\n      return ut(Re, ge);\n    }).join(\" \");\n  }\n  function ut(pe, ge) {\n    pe = pe.trim();\n    var Re = ge.loose ? g[ae] : g[ee];\n    return pe.replace(Re, function(Je, Fe, ze, Me, nt, rt) {\n      c(\"xRange\", pe, Je, Fe, ze, Me, nt, rt);\n      var Tt = fe(ze), kt = Tt || fe(Me), It = kt || fe(nt), _t = It;\n      return Fe === \"=\" && _t && (Fe = \"\"), Tt ? Fe === \">\" || Fe === \"<\" ? Je = \"<0.0.0\" : Je = \"*\" : Fe && _t ? (kt && (Me = 0), nt = 0, Fe === \">\" ? (Fe = \">=\", kt ? (ze = +ze + 1, Me = 0, nt = 0) : (Me = +Me + 1, nt = 0)) : Fe === \"<=\" && (Fe = \"<\", kt ? ze = +ze + 1 : Me = +Me + 1), Je = Fe + ze + \".\" + Me + \".\" + nt) : kt ? Je = \">=\" + ze + \".0.0 <\" + (+ze + 1) + \".0.0\" : It && (Je = \">=\" + ze + \".\" + Me + \".0 <\" + ze + \".\" + (+Me + 1) + \".0\"), c(\"xRange return\", Je), Je;\n    });\n  }\n  function yt(pe, ge) {\n    return c(\"replaceStars\", pe, ge), pe.trim().replace(g[C], \"\");\n  }\n  function gt(pe, ge, Re, Je, Fe, ze, Me, nt, rt, Tt, kt, It, _t) {\n    return fe(Re) ? ge = \"\" : fe(Je) ? ge = \">=\" + Re + \".0.0\" : fe(Fe) ? ge = \">=\" + Re + \".\" + Je + \".0\" : ge = \">=\" + ge, fe(rt) ? nt = \"\" : fe(Tt) ? nt = \"<\" + (+rt + 1) + \".0.0\" : fe(kt) ? nt = \"<\" + rt + \".\" + (+Tt + 1) + \".0\" : It ? nt = \"<=\" + rt + \".\" + Tt + \".\" + kt + \"-\" + It : nt = \"<=\" + nt, (ge + \" \" + nt).trim();\n  }\n  F.prototype.test = function(pe) {\n    if (!pe)\n      return !1;\n    typeof pe == \"string\" && (pe = new Ie(pe, this.options));\n    for (var ge = 0; ge < this.set.length; ge++)\n      if (bt(this.set[ge], pe, this.options))\n        return !0;\n    return !1;\n  };\n  function bt(pe, ge, Re) {\n    for (var Je = 0; Je < pe.length; Je++)\n      if (!pe[Je].test(ge))\n        return !1;\n    if (ge.prerelease.length && !Re.includePrerelease) {\n      for (Je = 0; Je < pe.length; Je++)\n        if (c(pe[Je].semver), pe[Je].semver !== I && pe[Je].semver.prerelease.length > 0) {\n          var Fe = pe[Je].semver;\n          if (Fe.major === ge.major && Fe.minor === ge.minor && Fe.patch === ge.patch)\n            return !0;\n        }\n      return !1;\n    }\n    return !0;\n  }\n  u.satisfies = St;\n  function St(pe, ge, Re) {\n    try {\n      ge = new F(ge, Re);\n    } catch {\n      return !1;\n    }\n    return ge.test(pe);\n  }\n  u.maxSatisfying = Et;\n  function Et(pe, ge, Re) {\n    var Je = null, Fe = null;\n    try {\n      var ze = new F(ge, Re);\n    } catch {\n      return null;\n    }\n    return pe.forEach(function(Me) {\n      ze.test(Me) && (!Je || Fe.compare(Me) === -1) && (Je = Me, Fe = new Ie(Je, Re));\n    }), Je;\n  }\n  u.minSatisfying = ct;\n  function ct(pe, ge, Re) {\n    var Je = null, Fe = null;\n    try {\n      var ze = new F(ge, Re);\n    } catch {\n      return null;\n    }\n    return pe.forEach(function(Me) {\n      ze.test(Me) && (!Je || Fe.compare(Me) === 1) && (Je = Me, Fe = new Ie(Je, Re));\n    }), Je;\n  }\n  u.minVersion = Xe;\n  function Xe(pe, ge) {\n    pe = new F(pe, ge);\n    var Re = new Ie(\"0.0.0\");\n    if (pe.test(Re) || (Re = new Ie(\"0.0.0-0\"), pe.test(Re)))\n      return Re;\n    Re = null;\n    for (var Je = 0; Je < pe.set.length; ++Je) {\n      var Fe = pe.set[Je];\n      Fe.forEach(function(ze) {\n        var Me = new Ie(ze.semver.version);\n        switch (ze.operator) {\n          case \">\":\n            Me.prerelease.length === 0 ? Me.patch++ : Me.prerelease.push(0), Me.raw = Me.format();\n          case \"\":\n          case \">=\":\n            (!Re || _e(Re, Me)) && (Re = Me);\n            break;\n          case \"<\":\n          case \"<=\":\n            break;\n          default:\n            throw new Error(\"Unexpected operation: \" + ze.operator);\n        }\n      });\n    }\n    return Re && pe.test(Re) ? Re : null;\n  }\n  u.validRange = Ct;\n  function Ct(pe, ge) {\n    try {\n      return new F(pe, ge).range || \"*\";\n    } catch {\n      return null;\n    }\n  }\n  u.ltr = Ot;\n  function Ot(pe, ge, Re) {\n    return Pt(pe, ge, \"<\", Re);\n  }\n  u.gtr = Nt;\n  function Nt(pe, ge, Re) {\n    return Pt(pe, ge, \">\", Re);\n  }\n  u.outside = Pt;\n  function Pt(pe, ge, Re, Je) {\n    pe = new Ie(pe, Je), ge = new F(ge, Je);\n    var Fe, ze, Me, nt, rt;\n    switch (Re) {\n      case \">\":\n        Fe = _e, ze = ot, Me = ve, nt = \">\", rt = \">=\";\n        break;\n      case \"<\":\n        Fe = ve, ze = Qe, Me = _e, nt = \"<\", rt = \"<=\";\n        break;\n      default:\n        throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n    }\n    if (St(pe, ge, Je))\n      return !1;\n    for (var Tt = 0; Tt < ge.set.length; ++Tt) {\n      var kt = ge.set[Tt], It = null, _t = null;\n      if (kt.forEach(function(Rt) {\n        Rt.semver === I && (Rt = new Ce(\">=0.0.0\")), It = It || Rt, _t = _t || Rt, Fe(Rt.semver, It.semver, Je) ? It = Rt : Me(Rt.semver, _t.semver, Je) && (_t = Rt);\n      }), It.operator === nt || It.operator === rt || (!_t.operator || _t.operator === nt) && ze(pe, _t.semver))\n        return !1;\n      if (_t.operator === rt && Me(pe, _t.semver))\n        return !1;\n    }\n    return !0;\n  }\n  u.prerelease = wt;\n  function wt(pe, ge) {\n    var Re = Q(pe, ge);\n    return Re && Re.prerelease.length ? Re.prerelease : null;\n  }\n  u.intersects = At;\n  function At(pe, ge, Re) {\n    return pe = new F(pe, Re), ge = new F(ge, Re), pe.intersects(ge);\n  }\n  u.coerce = Dt;\n  function Dt(pe) {\n    if (pe instanceof Ie)\n      return pe;\n    if (typeof pe != \"string\")\n      return null;\n    var ge = pe.match(g[ye]);\n    return ge == null ? null : Q(ge[1] + \".\" + (ge[2] || \"0\") + \".\" + (ge[3] || \"0\"));\n  }\n})(semver$1, semver$1.exports);\nvar semverExports = semver$1.exports, semver = semverExports, psSupported = semver.satisfies(process.version, \"^6.12.0 || >=8.0.0\"), JsonWebTokenError = JsonWebTokenError_1, NotBeforeError = NotBeforeError_1, TokenExpiredError = TokenExpiredError_1, decode = decode$1, timespan$1 = timespan$2, PS_SUPPORTED$1 = psSupported, jws$1 = jws$3, PUB_KEY_ALGS = [\"RS256\", \"RS384\", \"RS512\", \"ES256\", \"ES384\", \"ES512\"], RSA_KEY_ALGS = [\"RS256\", \"RS384\", \"RS512\"], HS_ALGS = [\"HS256\", \"HS384\", \"HS512\"];\nPS_SUPPORTED$1 && (PUB_KEY_ALGS.splice(3, 0, \"PS256\", \"PS384\", \"PS512\"), RSA_KEY_ALGS.splice(3, 0, \"PS256\", \"PS384\", \"PS512\"));\nvar verify = function(a, u, c, l) {\n  typeof c == \"function\" && !l && (l = c, c = {}), c || (c = {}), c = Object.assign({}, c);\n  var v;\n  if (l ? v = l : v = function(L, M) {\n    if (L)\n      throw L;\n    return M;\n  }, c.clockTimestamp && typeof c.clockTimestamp != \"number\")\n    return v(new JsonWebTokenError(\"clockTimestamp must be a number\"));\n  if (c.nonce !== void 0 && (typeof c.nonce != \"string\" || c.nonce.trim() === \"\"))\n    return v(new JsonWebTokenError(\"nonce must be a non-empty string\"));\n  var S = c.clockTimestamp || Math.floor(Date.now() / 1e3);\n  if (!a)\n    return v(new JsonWebTokenError(\"jwt must be provided\"));\n  if (typeof a != \"string\")\n    return v(new JsonWebTokenError(\"jwt must be a string\"));\n  var g = a.split(\".\");\n  if (g.length !== 3)\n    return v(new JsonWebTokenError(\"jwt malformed\"));\n  var E;\n  try {\n    E = decode(a, { complete: !0 });\n  } catch (L) {\n    return v(L);\n  }\n  if (!E)\n    return v(new JsonWebTokenError(\"invalid token\"));\n  var _ = E.header, k;\n  if (typeof u == \"function\") {\n    if (!l)\n      return v(new JsonWebTokenError(\"verify must be called asynchronous if secret or public key is provided as a callback\"));\n    k = u;\n  } else\n    k = function(L, M) {\n      return M(null, u);\n    };\n  return k(_, function(L, M) {\n    if (L)\n      return v(new JsonWebTokenError(\"error in secret or public key callback: \" + L.message));\n    var $ = g[2].trim() !== \"\";\n    if (!$ && M)\n      return v(new JsonWebTokenError(\"jwt signature is required\"));\n    if ($ && !M)\n      return v(new JsonWebTokenError(\"secret or public key must be provided\"));\n    if (!$ && !c.algorithms && (c.algorithms = [\"none\"]), c.algorithms || (c.algorithms = ~M.toString().indexOf(\"BEGIN CERTIFICATE\") || ~M.toString().indexOf(\"BEGIN PUBLIC KEY\") ? PUB_KEY_ALGS : ~M.toString().indexOf(\"BEGIN RSA PUBLIC KEY\") ? RSA_KEY_ALGS : HS_ALGS), !~c.algorithms.indexOf(E.header.alg))\n      return v(new JsonWebTokenError(\"invalid algorithm\"));\n    var J;\n    try {\n      J = jws$1.verify(a, E.header.alg, M);\n    } catch (Z) {\n      return v(Z);\n    }\n    if (!J)\n      return v(new JsonWebTokenError(\"invalid signature\"));\n    var V = E.payload;\n    if (typeof V.nbf < \"u\" && !c.ignoreNotBefore) {\n      if (typeof V.nbf != \"number\")\n        return v(new JsonWebTokenError(\"invalid nbf value\"));\n      if (V.nbf > S + (c.clockTolerance || 0))\n        return v(new NotBeforeError(\"jwt not active\", new Date(V.nbf * 1e3)));\n    }\n    if (typeof V.exp < \"u\" && !c.ignoreExpiration) {\n      if (typeof V.exp != \"number\")\n        return v(new JsonWebTokenError(\"invalid exp value\"));\n      if (S >= V.exp + (c.clockTolerance || 0))\n        return v(new TokenExpiredError(\"jwt expired\", new Date(V.exp * 1e3)));\n    }\n    if (c.audience) {\n      var q = Array.isArray(c.audience) ? c.audience : [c.audience], G = Array.isArray(V.aud) ? V.aud : [V.aud], H = G.some(function(Z) {\n        return q.some(function(re) {\n          return re instanceof RegExp ? re.test(Z) : re === Z;\n        });\n      });\n      if (!H)\n        return v(new JsonWebTokenError(\"jwt audience invalid. expected: \" + q.join(\" or \")));\n    }\n    if (c.issuer) {\n      var B = typeof c.issuer == \"string\" && V.iss !== c.issuer || Array.isArray(c.issuer) && c.issuer.indexOf(V.iss) === -1;\n      if (B)\n        return v(new JsonWebTokenError(\"jwt issuer invalid. expected: \" + c.issuer));\n    }\n    if (c.subject && V.sub !== c.subject)\n      return v(new JsonWebTokenError(\"jwt subject invalid. expected: \" + c.subject));\n    if (c.jwtid && V.jti !== c.jwtid)\n      return v(new JsonWebTokenError(\"jwt jwtid invalid. expected: \" + c.jwtid));\n    if (c.nonce && V.nonce !== c.nonce)\n      return v(new JsonWebTokenError(\"jwt nonce invalid. expected: \" + c.nonce));\n    if (c.maxAge) {\n      if (typeof V.iat != \"number\")\n        return v(new JsonWebTokenError(\"iat required when maxAge is specified\"));\n      var Y = timespan$1(c.maxAge, V.iat);\n      if (typeof Y > \"u\")\n        return v(new JsonWebTokenError('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n      if (S >= Y + (c.clockTolerance || 0))\n        return v(new TokenExpiredError(\"maxAge exceeded\", new Date(Y * 1e3)));\n    }\n    if (c.complete === !0) {\n      var ne = E.signature;\n      return v(null, {\n        header: _,\n        payload: V,\n        signature: ne\n      });\n    }\n    return v(null, V);\n  });\n}, INFINITY$2 = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER$2 = 17976931348623157e292, NAN$2 = NaN, argsTag = \"[object Arguments]\", funcTag = \"[object Function]\", genTag = \"[object GeneratorFunction]\", stringTag$1 = \"[object String]\", symbolTag$2 = \"[object Symbol]\", reTrim$2 = /^\\s+|\\s+$/g, reIsBadHex$2 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$2 = /^0b[01]+$/i, reIsOctal$2 = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\\d*)$/, freeParseInt$2 = parseInt;\nfunction arrayMap(a, u) {\n  for (var c = -1, l = a ? a.length : 0, v = Array(l); ++c < l; )\n    v[c] = u(a[c], c, a);\n  return v;\n}\nfunction baseFindIndex(a, u, c, l) {\n  for (var v = a.length, S = c + (l ? 1 : -1); l ? S-- : ++S < v; )\n    if (u(a[S], S, a))\n      return S;\n  return -1;\n}\nfunction baseIndexOf(a, u, c) {\n  if (u !== u)\n    return baseFindIndex(a, baseIsNaN, c);\n  for (var l = c - 1, v = a.length; ++l < v; )\n    if (a[l] === u)\n      return l;\n  return -1;\n}\nfunction baseIsNaN(a) {\n  return a !== a;\n}\nfunction baseTimes(a, u) {\n  for (var c = -1, l = Array(a); ++c < a; )\n    l[c] = u(c);\n  return l;\n}\nfunction baseValues(a, u) {\n  return arrayMap(u, function(c) {\n    return a[c];\n  });\n}\nfunction overArg$1(a, u) {\n  return function(c) {\n    return a(u(c));\n  };\n}\nvar objectProto$6 = Object.prototype, hasOwnProperty$1 = objectProto$6.hasOwnProperty, objectToString$6 = objectProto$6.toString, propertyIsEnumerable = objectProto$6.propertyIsEnumerable, nativeKeys = overArg$1(Object.keys, Object), nativeMax = Math.max;\nfunction arrayLikeKeys(a, u) {\n  var c = isArray$3(a) || isArguments(a) ? baseTimes(a.length, String) : [], l = c.length, v = !!l;\n  for (var S in a)\n    (u || hasOwnProperty$1.call(a, S)) && !(v && (S == \"length\" || isIndex(S, l))) && c.push(S);\n  return c;\n}\nfunction baseKeys(a) {\n  if (!isPrototype(a))\n    return nativeKeys(a);\n  var u = [];\n  for (var c in Object(a))\n    hasOwnProperty$1.call(a, c) && c != \"constructor\" && u.push(c);\n  return u;\n}\nfunction isIndex(a, u) {\n  return u = u ?? MAX_SAFE_INTEGER, !!u && (typeof a == \"number\" || reIsUint.test(a)) && a > -1 && a % 1 == 0 && a < u;\n}\nfunction isPrototype(a) {\n  var u = a && a.constructor, c = typeof u == \"function\" && u.prototype || objectProto$6;\n  return a === c;\n}\nfunction includes$1(a, u, c, l) {\n  a = isArrayLike(a) ? a : values(a), c = c && !l ? toInteger$2(c) : 0;\n  var v = a.length;\n  return c < 0 && (c = nativeMax(v + c, 0)), isString$3(a) ? c <= v && a.indexOf(u, c) > -1 : !!v && baseIndexOf(a, u, c) > -1;\n}\nfunction isArguments(a) {\n  return isArrayLikeObject(a) && hasOwnProperty$1.call(a, \"callee\") && (!propertyIsEnumerable.call(a, \"callee\") || objectToString$6.call(a) == argsTag);\n}\nvar isArray$3 = Array.isArray;\nfunction isArrayLike(a) {\n  return a != null && isLength(a.length) && !isFunction$1(a);\n}\nfunction isArrayLikeObject(a) {\n  return isObjectLike$6(a) && isArrayLike(a);\n}\nfunction isFunction$1(a) {\n  var u = isObject$6(a) ? objectToString$6.call(a) : \"\";\n  return u == funcTag || u == genTag;\n}\nfunction isLength(a) {\n  return typeof a == \"number\" && a > -1 && a % 1 == 0 && a <= MAX_SAFE_INTEGER;\n}\nfunction isObject$6(a) {\n  var u = typeof a;\n  return !!a && (u == \"object\" || u == \"function\");\n}\nfunction isObjectLike$6(a) {\n  return !!a && typeof a == \"object\";\n}\nfunction isString$3(a) {\n  return typeof a == \"string\" || !isArray$3(a) && isObjectLike$6(a) && objectToString$6.call(a) == stringTag$1;\n}\nfunction isSymbol$2(a) {\n  return typeof a == \"symbol\" || isObjectLike$6(a) && objectToString$6.call(a) == symbolTag$2;\n}\nfunction toFinite$2(a) {\n  if (!a)\n    return a === 0 ? a : 0;\n  if (a = toNumber$2(a), a === INFINITY$2 || a === -INFINITY$2) {\n    var u = a < 0 ? -1 : 1;\n    return u * MAX_INTEGER$2;\n  }\n  return a === a ? a : 0;\n}\nfunction toInteger$2(a) {\n  var u = toFinite$2(a), c = u % 1;\n  return u === u ? c ? u - c : u : 0;\n}\nfunction toNumber$2(a) {\n  if (typeof a == \"number\")\n    return a;\n  if (isSymbol$2(a))\n    return NAN$2;\n  if (isObject$6(a)) {\n    var u = typeof a.valueOf == \"function\" ? a.valueOf() : a;\n    a = isObject$6(u) ? u + \"\" : u;\n  }\n  if (typeof a != \"string\")\n    return a === 0 ? a : +a;\n  a = a.replace(reTrim$2, \"\");\n  var c = reIsBinary$2.test(a);\n  return c || reIsOctal$2.test(a) ? freeParseInt$2(a.slice(2), c ? 2 : 8) : reIsBadHex$2.test(a) ? NAN$2 : +a;\n}\nfunction keys$1(a) {\n  return isArrayLike(a) ? arrayLikeKeys(a) : baseKeys(a);\n}\nfunction values(a) {\n  return a ? baseValues(a, keys$1(a)) : [];\n}\nvar lodash_includes = includes$1, boolTag = \"[object Boolean]\", objectProto$5 = Object.prototype, objectToString$5 = objectProto$5.toString;\nfunction isBoolean$1(a) {\n  return a === !0 || a === !1 || isObjectLike$5(a) && objectToString$5.call(a) == boolTag;\n}\nfunction isObjectLike$5(a) {\n  return !!a && typeof a == \"object\";\n}\nvar lodash_isboolean = isBoolean$1, INFINITY$1 = 1 / 0, MAX_INTEGER$1 = 17976931348623157e292, NAN$1 = NaN, symbolTag$1 = \"[object Symbol]\", reTrim$1 = /^\\s+|\\s+$/g, reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$1 = /^0b[01]+$/i, reIsOctal$1 = /^0o[0-7]+$/i, freeParseInt$1 = parseInt, objectProto$4 = Object.prototype, objectToString$4 = objectProto$4.toString;\nfunction isInteger$1(a) {\n  return typeof a == \"number\" && a == toInteger$1(a);\n}\nfunction isObject$5(a) {\n  var u = typeof a;\n  return !!a && (u == \"object\" || u == \"function\");\n}\nfunction isObjectLike$4(a) {\n  return !!a && typeof a == \"object\";\n}\nfunction isSymbol$1(a) {\n  return typeof a == \"symbol\" || isObjectLike$4(a) && objectToString$4.call(a) == symbolTag$1;\n}\nfunction toFinite$1(a) {\n  if (!a)\n    return a === 0 ? a : 0;\n  if (a = toNumber$1(a), a === INFINITY$1 || a === -INFINITY$1) {\n    var u = a < 0 ? -1 : 1;\n    return u * MAX_INTEGER$1;\n  }\n  return a === a ? a : 0;\n}\nfunction toInteger$1(a) {\n  var u = toFinite$1(a), c = u % 1;\n  return u === u ? c ? u - c : u : 0;\n}\nfunction toNumber$1(a) {\n  if (typeof a == \"number\")\n    return a;\n  if (isSymbol$1(a))\n    return NAN$1;\n  if (isObject$5(a)) {\n    var u = typeof a.valueOf == \"function\" ? a.valueOf() : a;\n    a = isObject$5(u) ? u + \"\" : u;\n  }\n  if (typeof a != \"string\")\n    return a === 0 ? a : +a;\n  a = a.replace(reTrim$1, \"\");\n  var c = reIsBinary$1.test(a);\n  return c || reIsOctal$1.test(a) ? freeParseInt$1(a.slice(2), c ? 2 : 8) : reIsBadHex$1.test(a) ? NAN$1 : +a;\n}\nvar lodash_isinteger = isInteger$1, numberTag = \"[object Number]\", objectProto$3 = Object.prototype, objectToString$3 = objectProto$3.toString;\nfunction isObjectLike$3(a) {\n  return !!a && typeof a == \"object\";\n}\nfunction isNumber$2(a) {\n  return typeof a == \"number\" || isObjectLike$3(a) && objectToString$3.call(a) == numberTag;\n}\nvar lodash_isnumber = isNumber$2, objectTag = \"[object Object]\";\nfunction isHostObject(a) {\n  var u = !1;\n  if (a != null && typeof a.toString != \"function\")\n    try {\n      u = !!(a + \"\");\n    } catch {\n    }\n  return u;\n}\nfunction overArg(a, u) {\n  return function(c) {\n    return a(u(c));\n  };\n}\nvar funcProto = Function.prototype, objectProto$2 = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto$2.hasOwnProperty, objectCtorString = funcToString.call(Object), objectToString$2 = objectProto$2.toString, getPrototype = overArg(Object.getPrototypeOf, Object);\nfunction isObjectLike$2(a) {\n  return !!a && typeof a == \"object\";\n}\nfunction isPlainObject$2(a) {\n  if (!isObjectLike$2(a) || objectToString$2.call(a) != objectTag || isHostObject(a))\n    return !1;\n  var u = getPrototype(a);\n  if (u === null)\n    return !0;\n  var c = hasOwnProperty.call(u, \"constructor\") && u.constructor;\n  return typeof c == \"function\" && c instanceof c && funcToString.call(c) == objectCtorString;\n}\nvar lodash_isplainobject = isPlainObject$2, stringTag = \"[object String]\", objectProto$1 = Object.prototype, objectToString$1 = objectProto$1.toString, isArray$2 = Array.isArray;\nfunction isObjectLike$1(a) {\n  return !!a && typeof a == \"object\";\n}\nfunction isString$2(a) {\n  return typeof a == \"string\" || !isArray$2(a) && isObjectLike$1(a) && objectToString$1.call(a) == stringTag;\n}\nvar lodash_isstring = isString$2, FUNC_ERROR_TEXT = \"Expected a function\", INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292, NAN = NaN, symbolTag = \"[object Symbol]\", reTrim = /^\\s+|\\s+$/g, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt, objectProto = Object.prototype, objectToString = objectProto.toString;\nfunction before(a, u) {\n  var c;\n  if (typeof u != \"function\")\n    throw new TypeError(FUNC_ERROR_TEXT);\n  return a = toInteger(a), function() {\n    return --a > 0 && (c = u.apply(this, arguments)), a <= 1 && (u = void 0), c;\n  };\n}\nfunction once$2(a) {\n  return before(2, a);\n}\nfunction isObject$4(a) {\n  var u = typeof a;\n  return !!a && (u == \"object\" || u == \"function\");\n}\nfunction isObjectLike(a) {\n  return !!a && typeof a == \"object\";\n}\nfunction isSymbol(a) {\n  return typeof a == \"symbol\" || isObjectLike(a) && objectToString.call(a) == symbolTag;\n}\nfunction toFinite(a) {\n  if (!a)\n    return a === 0 ? a : 0;\n  if (a = toNumber(a), a === INFINITY || a === -INFINITY) {\n    var u = a < 0 ? -1 : 1;\n    return u * MAX_INTEGER;\n  }\n  return a === a ? a : 0;\n}\nfunction toInteger(a) {\n  var u = toFinite(a), c = u % 1;\n  return u === u ? c ? u - c : u : 0;\n}\nfunction toNumber(a) {\n  if (typeof a == \"number\")\n    return a;\n  if (isSymbol(a))\n    return NAN;\n  if (isObject$4(a)) {\n    var u = typeof a.valueOf == \"function\" ? a.valueOf() : a;\n    a = isObject$4(u) ? u + \"\" : u;\n  }\n  if (typeof a != \"string\")\n    return a === 0 ? a : +a;\n  a = a.replace(reTrim, \"\");\n  var c = reIsBinary.test(a);\n  return c || reIsOctal.test(a) ? freeParseInt(a.slice(2), c ? 2 : 8) : reIsBadHex.test(a) ? NAN : +a;\n}\nvar lodash_once = once$2, timespan = timespan$2, PS_SUPPORTED = psSupported, jws = jws$3, includes = lodash_includes, isBoolean = lodash_isboolean, isInteger = lodash_isinteger, isNumber$1 = lodash_isnumber, isPlainObject$1 = lodash_isplainobject, isString$1 = lodash_isstring, once$1 = lodash_once, SUPPORTED_ALGS = [\"RS256\", \"RS384\", \"RS512\", \"ES256\", \"ES384\", \"ES512\", \"HS256\", \"HS384\", \"HS512\", \"none\"];\nPS_SUPPORTED && SUPPORTED_ALGS.splice(3, 0, \"PS256\", \"PS384\", \"PS512\");\nvar sign_options_schema = {\n  expiresIn: { isValid: function(a) {\n    return isInteger(a) || isString$1(a) && a;\n  }, message: '\"expiresIn\" should be a number of seconds or string representing a timespan' },\n  notBefore: { isValid: function(a) {\n    return isInteger(a) || isString$1(a) && a;\n  }, message: '\"notBefore\" should be a number of seconds or string representing a timespan' },\n  audience: { isValid: function(a) {\n    return isString$1(a) || Array.isArray(a);\n  }, message: '\"audience\" must be a string or array' },\n  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '\"algorithm\" must be a valid string enum value' },\n  header: { isValid: isPlainObject$1, message: '\"header\" must be an object' },\n  encoding: { isValid: isString$1, message: '\"encoding\" must be a string' },\n  issuer: { isValid: isString$1, message: '\"issuer\" must be a string' },\n  subject: { isValid: isString$1, message: '\"subject\" must be a string' },\n  jwtid: { isValid: isString$1, message: '\"jwtid\" must be a string' },\n  noTimestamp: { isValid: isBoolean, message: '\"noTimestamp\" must be a boolean' },\n  keyid: { isValid: isString$1, message: '\"keyid\" must be a string' },\n  mutatePayload: { isValid: isBoolean, message: '\"mutatePayload\" must be a boolean' }\n}, registered_claims_schema = {\n  iat: { isValid: isNumber$1, message: '\"iat\" should be a number of seconds' },\n  exp: { isValid: isNumber$1, message: '\"exp\" should be a number of seconds' },\n  nbf: { isValid: isNumber$1, message: '\"nbf\" should be a number of seconds' }\n};\nfunction validate(a, u, c, l) {\n  if (!isPlainObject$1(c))\n    throw new Error('Expected \"' + l + '\" to be a plain object.');\n  Object.keys(c).forEach(function(v) {\n    var S = a[v];\n    if (!S) {\n      if (!u)\n        throw new Error('\"' + v + '\" is not allowed in \"' + l + '\"');\n      return;\n    }\n    if (!S.isValid(c[v]))\n      throw new Error(S.message);\n  });\n}\nfunction validateOptions(a) {\n  return validate(sign_options_schema, !1, a, \"options\");\n}\nfunction validatePayload(a) {\n  return validate(registered_claims_schema, !0, a, \"payload\");\n}\nvar options_to_payload = {\n  audience: \"aud\",\n  issuer: \"iss\",\n  subject: \"sub\",\n  jwtid: \"jti\"\n}, options_for_objects = [\n  \"expiresIn\",\n  \"notBefore\",\n  \"noTimestamp\",\n  \"audience\",\n  \"issuer\",\n  \"subject\",\n  \"jwtid\"\n], sign = function(a, u, c, l) {\n  typeof c == \"function\" ? (l = c, c = {}) : c = c || {};\n  var v = typeof a == \"object\" && !Buffer.isBuffer(a), S = Object.assign({\n    alg: c.algorithm || \"HS256\",\n    typ: v ? \"JWT\" : void 0,\n    kid: c.keyid\n  }, c.header);\n  function g(L) {\n    if (l)\n      return l(L);\n    throw L;\n  }\n  if (!u && c.algorithm !== \"none\")\n    return g(new Error(\"secretOrPrivateKey must have a value\"));\n  if (typeof a > \"u\")\n    return g(new Error(\"payload is required\"));\n  if (v) {\n    try {\n      validatePayload(a);\n    } catch (L) {\n      return g(L);\n    }\n    c.mutatePayload || (a = Object.assign({}, a));\n  } else {\n    var E = options_for_objects.filter(function(L) {\n      return typeof c[L] < \"u\";\n    });\n    if (E.length > 0)\n      return g(new Error(\"invalid \" + E.join(\",\") + \" option for \" + typeof a + \" payload\"));\n  }\n  if (typeof a.exp < \"u\" && typeof c.expiresIn < \"u\")\n    return g(new Error('Bad \"options.expiresIn\" option the payload already has an \"exp\" property.'));\n  if (typeof a.nbf < \"u\" && typeof c.notBefore < \"u\")\n    return g(new Error('Bad \"options.notBefore\" option the payload already has an \"nbf\" property.'));\n  try {\n    validateOptions(c);\n  } catch (L) {\n    return g(L);\n  }\n  var _ = a.iat || Math.floor(Date.now() / 1e3);\n  if (c.noTimestamp ? delete a.iat : v && (a.iat = _), typeof c.notBefore < \"u\") {\n    try {\n      a.nbf = timespan(c.notBefore, _);\n    } catch (L) {\n      return g(L);\n    }\n    if (typeof a.nbf > \"u\")\n      return g(new Error('\"notBefore\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n  }\n  if (typeof c.expiresIn < \"u\" && typeof a == \"object\") {\n    try {\n      a.exp = timespan(c.expiresIn, _);\n    } catch (L) {\n      return g(L);\n    }\n    if (typeof a.exp > \"u\")\n      return g(new Error('\"expiresIn\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n  }\n  Object.keys(options_to_payload).forEach(function(L) {\n    var M = options_to_payload[L];\n    if (typeof c[L] < \"u\") {\n      if (typeof a[M] < \"u\")\n        return g(new Error('Bad \"options.' + L + '\" option. The payload already has an \"' + M + '\" property.'));\n      a[M] = c[L];\n    }\n  });\n  var k = c.encoding || \"utf8\";\n  if (typeof l == \"function\")\n    l = l && once$1(l), jws.createSign({\n      header: S,\n      privateKey: u,\n      payload: a,\n      encoding: k\n    }).once(\"error\", l).once(\"done\", function(L) {\n      l(null, L);\n    });\n  else\n    return jws.sign({ header: S, payload: a, secret: u, encoding: k });\n}, jsonwebtoken = {\n  decode: decode$1,\n  verify,\n  sign,\n  JsonWebTokenError: JsonWebTokenError_1,\n  NotBeforeError: NotBeforeError_1,\n  TokenExpiredError: TokenExpiredError_1\n}, __createBinding = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {\n  l === void 0 && (l = c), Object.defineProperty(a, l, { enumerable: !0, get: function() {\n    return u[c];\n  } });\n} : function(a, u, c, l) {\n  l === void 0 && (l = c), a[l] = u[c];\n}), __setModuleDefault = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {\n  Object.defineProperty(a, \"default\", { enumerable: !0, value: u });\n} : function(a, u) {\n  a.default = u;\n}), __importStar = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {\n  if (a && a.__esModule)\n    return a;\n  var u = {};\n  if (a != null)\n    for (var c in a)\n      c !== \"default\" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding(u, a, c);\n  return __setModuleDefault(u, a), u;\n};\nObject.defineProperty(AccessToken$1, \"__esModule\", { value: !0 });\nAccessToken$1.TokenVerifier = AccessToken$1.AccessToken = void 0;\nconst jwt = __importStar(jsonwebtoken), defaultTTL = 6 * 60 * 60;\nclass AccessToken {\n  /**\n   * Creates a new AccessToken\n   * @param apiKey API Key, can be set in env LIVEKIT_API_KEY\n   * @param apiSecret Secret, can be set in env LIVEKIT_API_SECRET\n   */\n  constructor(u, c, l) {\n    if (u || (u = process.env.LIVEKIT_API_KEY), c || (c = process.env.LIVEKIT_API_SECRET), !u || !c)\n      throw Error(\"api-key and api-secret must be set\");\n    this.apiKey = u, this.apiSecret = c, this.grants = {}, this.identity = l == null ? void 0 : l.identity, this.ttl = (l == null ? void 0 : l.ttl) || defaultTTL, l != null && l.metadata && (this.metadata = l.metadata), l != null && l.name && (this.name = l.name);\n  }\n  /**\n   * Adds a video grant to this token.\n   * @param grant\n   */\n  addGrant(u) {\n    this.grants.video = u;\n  }\n  /**\n   * Set metadata to be passed to the Participant, used only when joining the room\n   */\n  set metadata(u) {\n    this.grants.metadata = u;\n  }\n  set name(u) {\n    this.grants.name = u;\n  }\n  get sha256() {\n    return this.grants.sha256;\n  }\n  set sha256(u) {\n    this.grants.sha256 = u;\n  }\n  /**\n   * @returns JWT encoded token\n   */\n  toJwt() {\n    var u;\n    const c = {\n      issuer: this.apiKey,\n      expiresIn: this.ttl,\n      notBefore: 0\n    };\n    if (this.identity)\n      c.subject = this.identity, c.jwtid = this.identity;\n    else if (!((u = this.grants.video) === null || u === void 0) && u.roomJoin)\n      throw Error(\"identity is required for join but not set\");\n    return jwt.sign(this.grants, this.apiSecret, c);\n  }\n}\nAccessToken$1.AccessToken = AccessToken;\nclass TokenVerifier {\n  constructor(u, c) {\n    this.apiKey = u, this.apiSecret = c;\n  }\n  verify(u) {\n    const c = jwt.verify(u, this.apiSecret, { issuer: this.apiKey });\n    if (!c)\n      throw Error(\"invalid token\");\n    return c;\n  }\n}\nAccessToken$1.TokenVerifier = TokenVerifier;\nvar EgressClient$1 = {}, livekit_egress = {};\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(P) {\n    return P && P.__esModule ? P : { default: P };\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.AutoTrackEgress = a.SegmentsInfo = a.FileInfo = a.StreamInfo = a.StreamInfoList = a.EgressInfo = a.StopEgressRequest = a.ListEgressResponse = a.ListEgressRequest = a.UpdateStreamRequest = a.UpdateLayoutRequest = a.EncodingOptions = a.StreamOutput = a.AliOSSUpload = a.AzureBlobUpload = a.GCPUpload = a.S3Upload_MetadataEntry = a.S3Upload = a.DirectFileOutput = a.SegmentedFileOutput = a.EncodedFileOutput = a.WebEgressRequest = a.TrackEgressRequest = a.TrackCompositeEgressRequest = a.RoomCompositeEgressRequest = a.streamInfo_StatusToJSON = a.streamInfo_StatusFromJSON = a.StreamInfo_Status = a.egressStatusToJSON = a.egressStatusFromJSON = a.EgressStatus = a.encodingOptionsPresetToJSON = a.encodingOptionsPresetFromJSON = a.EncodingOptionsPreset = a.videoCodecToJSON = a.videoCodecFromJSON = a.VideoCodec = a.audioCodecToJSON = a.audioCodecFromJSON = a.AudioCodec = a.segmentedFileProtocolToJSON = a.segmentedFileProtocolFromJSON = a.SegmentedFileProtocol = a.streamProtocolToJSON = a.streamProtocolFromJSON = a.StreamProtocol = a.encodedFileTypeToJSON = a.encodedFileTypeFromJSON = a.EncodedFileType = a.protobufPackage = void 0;\n  const c = u(umdExports), l = u(minimal);\n  a.protobufPackage = \"livekit\";\n  var v;\n  (function(P) {\n    P[P.DEFAULT_FILETYPE = 0] = \"DEFAULT_FILETYPE\", P[P.MP4 = 1] = \"MP4\", P[P.OGG = 2] = \"OGG\", P[P.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(v = a.EncodedFileType || (a.EncodedFileType = {}));\n  function S(P) {\n    switch (P) {\n      case 0:\n      case \"DEFAULT_FILETYPE\":\n        return v.DEFAULT_FILETYPE;\n      case 1:\n      case \"MP4\":\n        return v.MP4;\n      case 2:\n      case \"OGG\":\n        return v.OGG;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return v.UNRECOGNIZED;\n    }\n  }\n  a.encodedFileTypeFromJSON = S;\n  function g(P) {\n    switch (P) {\n      case v.DEFAULT_FILETYPE:\n        return \"DEFAULT_FILETYPE\";\n      case v.MP4:\n        return \"MP4\";\n      case v.OGG:\n        return \"OGG\";\n      case v.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.encodedFileTypeToJSON = g;\n  var E;\n  (function(P) {\n    P[P.DEFAULT_PROTOCOL = 0] = \"DEFAULT_PROTOCOL\", P[P.RTMP = 1] = \"RTMP\", P[P.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(E = a.StreamProtocol || (a.StreamProtocol = {}));\n  function _(P) {\n    switch (P) {\n      case 0:\n      case \"DEFAULT_PROTOCOL\":\n        return E.DEFAULT_PROTOCOL;\n      case 1:\n      case \"RTMP\":\n        return E.RTMP;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return E.UNRECOGNIZED;\n    }\n  }\n  a.streamProtocolFromJSON = _;\n  function k(P) {\n    switch (P) {\n      case E.DEFAULT_PROTOCOL:\n        return \"DEFAULT_PROTOCOL\";\n      case E.RTMP:\n        return \"RTMP\";\n      case E.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.streamProtocolToJSON = k;\n  var L;\n  (function(P) {\n    P[P.DEFAULT_SEGMENTED_FILE_PROTOCOL = 0] = \"DEFAULT_SEGMENTED_FILE_PROTOCOL\", P[P.HLS_PROTOCOL = 1] = \"HLS_PROTOCOL\", P[P.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(L = a.SegmentedFileProtocol || (a.SegmentedFileProtocol = {}));\n  function M(P) {\n    switch (P) {\n      case 0:\n      case \"DEFAULT_SEGMENTED_FILE_PROTOCOL\":\n        return L.DEFAULT_SEGMENTED_FILE_PROTOCOL;\n      case 1:\n      case \"HLS_PROTOCOL\":\n        return L.HLS_PROTOCOL;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return L.UNRECOGNIZED;\n    }\n  }\n  a.segmentedFileProtocolFromJSON = M;\n  function $(P) {\n    switch (P) {\n      case L.DEFAULT_SEGMENTED_FILE_PROTOCOL:\n        return \"DEFAULT_SEGMENTED_FILE_PROTOCOL\";\n      case L.HLS_PROTOCOL:\n        return \"HLS_PROTOCOL\";\n      case L.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.segmentedFileProtocolToJSON = $;\n  var J;\n  (function(P) {\n    P[P.DEFAULT_AC = 0] = \"DEFAULT_AC\", P[P.OPUS = 1] = \"OPUS\", P[P.AAC = 2] = \"AAC\", P[P.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(J = a.AudioCodec || (a.AudioCodec = {}));\n  function V(P) {\n    switch (P) {\n      case 0:\n      case \"DEFAULT_AC\":\n        return J.DEFAULT_AC;\n      case 1:\n      case \"OPUS\":\n        return J.OPUS;\n      case 2:\n      case \"AAC\":\n        return J.AAC;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return J.UNRECOGNIZED;\n    }\n  }\n  a.audioCodecFromJSON = V;\n  function q(P) {\n    switch (P) {\n      case J.DEFAULT_AC:\n        return \"DEFAULT_AC\";\n      case J.OPUS:\n        return \"OPUS\";\n      case J.AAC:\n        return \"AAC\";\n      case J.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.audioCodecToJSON = q;\n  var G;\n  (function(P) {\n    P[P.DEFAULT_VC = 0] = \"DEFAULT_VC\", P[P.H264_BASELINE = 1] = \"H264_BASELINE\", P[P.H264_MAIN = 2] = \"H264_MAIN\", P[P.H264_HIGH = 3] = \"H264_HIGH\", P[P.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(G = a.VideoCodec || (a.VideoCodec = {}));\n  function H(P) {\n    switch (P) {\n      case 0:\n      case \"DEFAULT_VC\":\n        return G.DEFAULT_VC;\n      case 1:\n      case \"H264_BASELINE\":\n        return G.H264_BASELINE;\n      case 2:\n      case \"H264_MAIN\":\n        return G.H264_MAIN;\n      case 3:\n      case \"H264_HIGH\":\n        return G.H264_HIGH;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return G.UNRECOGNIZED;\n    }\n  }\n  a.videoCodecFromJSON = H;\n  function B(P) {\n    switch (P) {\n      case G.DEFAULT_VC:\n        return \"DEFAULT_VC\";\n      case G.H264_BASELINE:\n        return \"H264_BASELINE\";\n      case G.H264_MAIN:\n        return \"H264_MAIN\";\n      case G.H264_HIGH:\n        return \"H264_HIGH\";\n      case G.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.videoCodecToJSON = B;\n  var Y;\n  (function(P) {\n    P[P.H264_720P_30 = 0] = \"H264_720P_30\", P[P.H264_720P_60 = 1] = \"H264_720P_60\", P[P.H264_1080P_30 = 2] = \"H264_1080P_30\", P[P.H264_1080P_60 = 3] = \"H264_1080P_60\", P[P.PORTRAIT_H264_720P_30 = 4] = \"PORTRAIT_H264_720P_30\", P[P.PORTRAIT_H264_720P_60 = 5] = \"PORTRAIT_H264_720P_60\", P[P.PORTRAIT_H264_1080P_30 = 6] = \"PORTRAIT_H264_1080P_30\", P[P.PORTRAIT_H264_1080P_60 = 7] = \"PORTRAIT_H264_1080P_60\", P[P.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(Y = a.EncodingOptionsPreset || (a.EncodingOptionsPreset = {}));\n  function ne(P) {\n    switch (P) {\n      case 0:\n      case \"H264_720P_30\":\n        return Y.H264_720P_30;\n      case 1:\n      case \"H264_720P_60\":\n        return Y.H264_720P_60;\n      case 2:\n      case \"H264_1080P_30\":\n        return Y.H264_1080P_30;\n      case 3:\n      case \"H264_1080P_60\":\n        return Y.H264_1080P_60;\n      case 4:\n      case \"PORTRAIT_H264_720P_30\":\n        return Y.PORTRAIT_H264_720P_30;\n      case 5:\n      case \"PORTRAIT_H264_720P_60\":\n        return Y.PORTRAIT_H264_720P_60;\n      case 6:\n      case \"PORTRAIT_H264_1080P_30\":\n        return Y.PORTRAIT_H264_1080P_30;\n      case 7:\n      case \"PORTRAIT_H264_1080P_60\":\n        return Y.PORTRAIT_H264_1080P_60;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return Y.UNRECOGNIZED;\n    }\n  }\n  a.encodingOptionsPresetFromJSON = ne;\n  function Z(P) {\n    switch (P) {\n      case Y.H264_720P_30:\n        return \"H264_720P_30\";\n      case Y.H264_720P_60:\n        return \"H264_720P_60\";\n      case Y.H264_1080P_30:\n        return \"H264_1080P_30\";\n      case Y.H264_1080P_60:\n        return \"H264_1080P_60\";\n      case Y.PORTRAIT_H264_720P_30:\n        return \"PORTRAIT_H264_720P_30\";\n      case Y.PORTRAIT_H264_720P_60:\n        return \"PORTRAIT_H264_720P_60\";\n      case Y.PORTRAIT_H264_1080P_30:\n        return \"PORTRAIT_H264_1080P_30\";\n      case Y.PORTRAIT_H264_1080P_60:\n        return \"PORTRAIT_H264_1080P_60\";\n      case Y.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.encodingOptionsPresetToJSON = Z;\n  var re;\n  (function(P) {\n    P[P.EGRESS_STARTING = 0] = \"EGRESS_STARTING\", P[P.EGRESS_ACTIVE = 1] = \"EGRESS_ACTIVE\", P[P.EGRESS_ENDING = 2] = \"EGRESS_ENDING\", P[P.EGRESS_COMPLETE = 3] = \"EGRESS_COMPLETE\", P[P.EGRESS_FAILED = 4] = \"EGRESS_FAILED\", P[P.EGRESS_ABORTED = 5] = \"EGRESS_ABORTED\", P[P.EGRESS_LIMIT_REACHED = 6] = \"EGRESS_LIMIT_REACHED\", P[P.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(re = a.EgressStatus || (a.EgressStatus = {}));\n  function oe(P) {\n    switch (P) {\n      case 0:\n      case \"EGRESS_STARTING\":\n        return re.EGRESS_STARTING;\n      case 1:\n      case \"EGRESS_ACTIVE\":\n        return re.EGRESS_ACTIVE;\n      case 2:\n      case \"EGRESS_ENDING\":\n        return re.EGRESS_ENDING;\n      case 3:\n      case \"EGRESS_COMPLETE\":\n        return re.EGRESS_COMPLETE;\n      case 4:\n      case \"EGRESS_FAILED\":\n        return re.EGRESS_FAILED;\n      case 5:\n      case \"EGRESS_ABORTED\":\n        return re.EGRESS_ABORTED;\n      case 6:\n      case \"EGRESS_LIMIT_REACHED\":\n        return re.EGRESS_LIMIT_REACHED;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return re.UNRECOGNIZED;\n    }\n  }\n  a.egressStatusFromJSON = oe;\n  function de(P) {\n    switch (P) {\n      case re.EGRESS_STARTING:\n        return \"EGRESS_STARTING\";\n      case re.EGRESS_ACTIVE:\n        return \"EGRESS_ACTIVE\";\n      case re.EGRESS_ENDING:\n        return \"EGRESS_ENDING\";\n      case re.EGRESS_COMPLETE:\n        return \"EGRESS_COMPLETE\";\n      case re.EGRESS_FAILED:\n        return \"EGRESS_FAILED\";\n      case re.EGRESS_ABORTED:\n        return \"EGRESS_ABORTED\";\n      case re.EGRESS_LIMIT_REACHED:\n        return \"EGRESS_LIMIT_REACHED\";\n      case re.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.egressStatusToJSON = de;\n  var A;\n  (function(P) {\n    P[P.ACTIVE = 0] = \"ACTIVE\", P[P.FINISHED = 1] = \"FINISHED\", P[P.FAILED = 2] = \"FAILED\", P[P.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(A = a.StreamInfo_Status || (a.StreamInfo_Status = {}));\n  function N(P) {\n    switch (P) {\n      case 0:\n      case \"ACTIVE\":\n        return A.ACTIVE;\n      case 1:\n      case \"FINISHED\":\n        return A.FINISHED;\n      case 2:\n      case \"FAILED\":\n        return A.FAILED;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return A.UNRECOGNIZED;\n    }\n  }\n  a.streamInfo_StatusFromJSON = N;\n  function D(P) {\n    switch (P) {\n      case A.ACTIVE:\n        return \"ACTIVE\";\n      case A.FINISHED:\n        return \"FINISHED\";\n      case A.FAILED:\n        return \"FAILED\";\n      case A.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.streamInfo_StatusToJSON = D;\n  function W() {\n    return {\n      roomName: \"\",\n      layout: \"\",\n      audioOnly: !1,\n      videoOnly: !1,\n      customBaseUrl: \"\",\n      file: void 0,\n      stream: void 0,\n      segments: void 0,\n      preset: void 0,\n      advanced: void 0\n    };\n  }\n  a.RoomCompositeEgressRequest = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.roomName !== void 0 && P.roomName !== \"\" && X.uint32(10).string(P.roomName), P.layout !== void 0 && P.layout !== \"\" && X.uint32(18).string(P.layout), P.audioOnly === !0 && X.uint32(24).bool(P.audioOnly), P.videoOnly === !0 && X.uint32(32).bool(P.videoOnly), P.customBaseUrl !== void 0 && P.customBaseUrl !== \"\" && X.uint32(42).string(P.customBaseUrl), P.file !== void 0 && a.EncodedFileOutput.encode(P.file, X.uint32(50).fork()).ldelim(), P.stream !== void 0 && a.StreamOutput.encode(P.stream, X.uint32(58).fork()).ldelim(), P.segments !== void 0 && a.SegmentedFileOutput.encode(P.segments, X.uint32(82).fork()).ldelim(), P.preset !== void 0 && X.uint32(64).int32(P.preset), P.advanced !== void 0 && a.EncodingOptions.encode(P.advanced, X.uint32(74).fork()).ldelim(), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = W();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.roomName = ie.string();\n            break;\n          case 2:\n            ue.layout = ie.string();\n            break;\n          case 3:\n            ue.audioOnly = ie.bool();\n            break;\n          case 4:\n            ue.videoOnly = ie.bool();\n            break;\n          case 5:\n            ue.customBaseUrl = ie.string();\n            break;\n          case 6:\n            ue.file = a.EncodedFileOutput.decode(ie, ie.uint32());\n            break;\n          case 7:\n            ue.stream = a.StreamOutput.decode(ie, ie.uint32());\n            break;\n          case 10:\n            ue.segments = a.SegmentedFileOutput.decode(ie, ie.uint32());\n            break;\n          case 8:\n            ue.preset = ie.int32();\n            break;\n          case 9:\n            ue.advanced = a.EncodingOptions.decode(ie, ie.uint32());\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        roomName: Oe(P.roomName) ? String(P.roomName) : \"\",\n        layout: Oe(P.layout) ? String(P.layout) : \"\",\n        audioOnly: Oe(P.audioOnly) ? !!P.audioOnly : !1,\n        videoOnly: Oe(P.videoOnly) ? !!P.videoOnly : !1,\n        customBaseUrl: Oe(P.customBaseUrl) ? String(P.customBaseUrl) : \"\",\n        file: Oe(P.file) ? a.EncodedFileOutput.fromJSON(P.file) : void 0,\n        stream: Oe(P.stream) ? a.StreamOutput.fromJSON(P.stream) : void 0,\n        segments: Oe(P.segments) ? a.SegmentedFileOutput.fromJSON(P.segments) : void 0,\n        preset: Oe(P.preset) ? ne(P.preset) : void 0,\n        advanced: Oe(P.advanced) ? a.EncodingOptions.fromJSON(P.advanced) : void 0\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.roomName !== void 0 && (X.roomName = P.roomName), P.layout !== void 0 && (X.layout = P.layout), P.audioOnly !== void 0 && (X.audioOnly = P.audioOnly), P.videoOnly !== void 0 && (X.videoOnly = P.videoOnly), P.customBaseUrl !== void 0 && (X.customBaseUrl = P.customBaseUrl), P.file !== void 0 && (X.file = P.file ? a.EncodedFileOutput.toJSON(P.file) : void 0), P.stream !== void 0 && (X.stream = P.stream ? a.StreamOutput.toJSON(P.stream) : void 0), P.segments !== void 0 && (X.segments = P.segments ? a.SegmentedFileOutput.toJSON(P.segments) : void 0), P.preset !== void 0 && (X.preset = P.preset !== void 0 ? Z(P.preset) : void 0), P.advanced !== void 0 && (X.advanced = P.advanced ? a.EncodingOptions.toJSON(P.advanced) : void 0), X;\n    },\n    fromPartial(P) {\n      var X, ie, Ee, ue, O, j;\n      const se = W();\n      return se.roomName = (X = P.roomName) !== null && X !== void 0 ? X : \"\", se.layout = (ie = P.layout) !== null && ie !== void 0 ? ie : \"\", se.audioOnly = (Ee = P.audioOnly) !== null && Ee !== void 0 ? Ee : !1, se.videoOnly = (ue = P.videoOnly) !== null && ue !== void 0 ? ue : !1, se.customBaseUrl = (O = P.customBaseUrl) !== null && O !== void 0 ? O : \"\", se.file = P.file !== void 0 && P.file !== null ? a.EncodedFileOutput.fromPartial(P.file) : void 0, se.stream = P.stream !== void 0 && P.stream !== null ? a.StreamOutput.fromPartial(P.stream) : void 0, se.segments = P.segments !== void 0 && P.segments !== null ? a.SegmentedFileOutput.fromPartial(P.segments) : void 0, se.preset = (j = P.preset) !== null && j !== void 0 ? j : void 0, se.advanced = P.advanced !== void 0 && P.advanced !== null ? a.EncodingOptions.fromPartial(P.advanced) : void 0, se;\n    }\n  };\n  function ee() {\n    return {\n      roomName: \"\",\n      audioTrackId: \"\",\n      videoTrackId: \"\",\n      file: void 0,\n      stream: void 0,\n      segments: void 0,\n      preset: void 0,\n      advanced: void 0\n    };\n  }\n  a.TrackCompositeEgressRequest = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.roomName !== void 0 && P.roomName !== \"\" && X.uint32(10).string(P.roomName), P.audioTrackId !== void 0 && P.audioTrackId !== \"\" && X.uint32(18).string(P.audioTrackId), P.videoTrackId !== void 0 && P.videoTrackId !== \"\" && X.uint32(26).string(P.videoTrackId), P.file !== void 0 && a.EncodedFileOutput.encode(P.file, X.uint32(34).fork()).ldelim(), P.stream !== void 0 && a.StreamOutput.encode(P.stream, X.uint32(42).fork()).ldelim(), P.segments !== void 0 && a.SegmentedFileOutput.encode(P.segments, X.uint32(66).fork()).ldelim(), P.preset !== void 0 && X.uint32(48).int32(P.preset), P.advanced !== void 0 && a.EncodingOptions.encode(P.advanced, X.uint32(58).fork()).ldelim(), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = ee();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.roomName = ie.string();\n            break;\n          case 2:\n            ue.audioTrackId = ie.string();\n            break;\n          case 3:\n            ue.videoTrackId = ie.string();\n            break;\n          case 4:\n            ue.file = a.EncodedFileOutput.decode(ie, ie.uint32());\n            break;\n          case 5:\n            ue.stream = a.StreamOutput.decode(ie, ie.uint32());\n            break;\n          case 8:\n            ue.segments = a.SegmentedFileOutput.decode(ie, ie.uint32());\n            break;\n          case 6:\n            ue.preset = ie.int32();\n            break;\n          case 7:\n            ue.advanced = a.EncodingOptions.decode(ie, ie.uint32());\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        roomName: Oe(P.roomName) ? String(P.roomName) : \"\",\n        audioTrackId: Oe(P.audioTrackId) ? String(P.audioTrackId) : \"\",\n        videoTrackId: Oe(P.videoTrackId) ? String(P.videoTrackId) : \"\",\n        file: Oe(P.file) ? a.EncodedFileOutput.fromJSON(P.file) : void 0,\n        stream: Oe(P.stream) ? a.StreamOutput.fromJSON(P.stream) : void 0,\n        segments: Oe(P.segments) ? a.SegmentedFileOutput.fromJSON(P.segments) : void 0,\n        preset: Oe(P.preset) ? ne(P.preset) : void 0,\n        advanced: Oe(P.advanced) ? a.EncodingOptions.fromJSON(P.advanced) : void 0\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.roomName !== void 0 && (X.roomName = P.roomName), P.audioTrackId !== void 0 && (X.audioTrackId = P.audioTrackId), P.videoTrackId !== void 0 && (X.videoTrackId = P.videoTrackId), P.file !== void 0 && (X.file = P.file ? a.EncodedFileOutput.toJSON(P.file) : void 0), P.stream !== void 0 && (X.stream = P.stream ? a.StreamOutput.toJSON(P.stream) : void 0), P.segments !== void 0 && (X.segments = P.segments ? a.SegmentedFileOutput.toJSON(P.segments) : void 0), P.preset !== void 0 && (X.preset = P.preset !== void 0 ? Z(P.preset) : void 0), P.advanced !== void 0 && (X.advanced = P.advanced ? a.EncodingOptions.toJSON(P.advanced) : void 0), X;\n    },\n    fromPartial(P) {\n      var X, ie, Ee, ue;\n      const O = ee();\n      return O.roomName = (X = P.roomName) !== null && X !== void 0 ? X : \"\", O.audioTrackId = (ie = P.audioTrackId) !== null && ie !== void 0 ? ie : \"\", O.videoTrackId = (Ee = P.videoTrackId) !== null && Ee !== void 0 ? Ee : \"\", O.file = P.file !== void 0 && P.file !== null ? a.EncodedFileOutput.fromPartial(P.file) : void 0, O.stream = P.stream !== void 0 && P.stream !== null ? a.StreamOutput.fromPartial(P.stream) : void 0, O.segments = P.segments !== void 0 && P.segments !== null ? a.SegmentedFileOutput.fromPartial(P.segments) : void 0, O.preset = (ue = P.preset) !== null && ue !== void 0 ? ue : void 0, O.advanced = P.advanced !== void 0 && P.advanced !== null ? a.EncodingOptions.fromPartial(P.advanced) : void 0, O;\n    }\n  };\n  function ae() {\n    return { roomName: \"\", trackId: \"\", file: void 0, websocketUrl: void 0 };\n  }\n  a.TrackEgressRequest = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.roomName !== void 0 && P.roomName !== \"\" && X.uint32(10).string(P.roomName), P.trackId !== void 0 && P.trackId !== \"\" && X.uint32(18).string(P.trackId), P.file !== void 0 && a.DirectFileOutput.encode(P.file, X.uint32(26).fork()).ldelim(), P.websocketUrl !== void 0 && X.uint32(34).string(P.websocketUrl), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = ae();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.roomName = ie.string();\n            break;\n          case 2:\n            ue.trackId = ie.string();\n            break;\n          case 3:\n            ue.file = a.DirectFileOutput.decode(ie, ie.uint32());\n            break;\n          case 4:\n            ue.websocketUrl = ie.string();\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        roomName: Oe(P.roomName) ? String(P.roomName) : \"\",\n        trackId: Oe(P.trackId) ? String(P.trackId) : \"\",\n        file: Oe(P.file) ? a.DirectFileOutput.fromJSON(P.file) : void 0,\n        websocketUrl: Oe(P.websocketUrl) ? String(P.websocketUrl) : void 0\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.roomName !== void 0 && (X.roomName = P.roomName), P.trackId !== void 0 && (X.trackId = P.trackId), P.file !== void 0 && (X.file = P.file ? a.DirectFileOutput.toJSON(P.file) : void 0), P.websocketUrl !== void 0 && (X.websocketUrl = P.websocketUrl), X;\n    },\n    fromPartial(P) {\n      var X, ie, Ee;\n      const ue = ae();\n      return ue.roomName = (X = P.roomName) !== null && X !== void 0 ? X : \"\", ue.trackId = (ie = P.trackId) !== null && ie !== void 0 ? ie : \"\", ue.file = P.file !== void 0 && P.file !== null ? a.DirectFileOutput.fromPartial(P.file) : void 0, ue.websocketUrl = (Ee = P.websocketUrl) !== null && Ee !== void 0 ? Ee : void 0, ue;\n    }\n  };\n  function ye() {\n    return {\n      url: \"\",\n      audioOnly: !1,\n      videoOnly: !1,\n      file: void 0,\n      stream: void 0,\n      segments: void 0,\n      preset: void 0,\n      advanced: void 0\n    };\n  }\n  a.WebEgressRequest = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.url !== void 0 && P.url !== \"\" && X.uint32(10).string(P.url), P.audioOnly === !0 && X.uint32(16).bool(P.audioOnly), P.videoOnly === !0 && X.uint32(24).bool(P.videoOnly), P.file !== void 0 && a.EncodedFileOutput.encode(P.file, X.uint32(34).fork()).ldelim(), P.stream !== void 0 && a.StreamOutput.encode(P.stream, X.uint32(42).fork()).ldelim(), P.segments !== void 0 && a.SegmentedFileOutput.encode(P.segments, X.uint32(50).fork()).ldelim(), P.preset !== void 0 && X.uint32(56).int32(P.preset), P.advanced !== void 0 && a.EncodingOptions.encode(P.advanced, X.uint32(66).fork()).ldelim(), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = ye();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.url = ie.string();\n            break;\n          case 2:\n            ue.audioOnly = ie.bool();\n            break;\n          case 3:\n            ue.videoOnly = ie.bool();\n            break;\n          case 4:\n            ue.file = a.EncodedFileOutput.decode(ie, ie.uint32());\n            break;\n          case 5:\n            ue.stream = a.StreamOutput.decode(ie, ie.uint32());\n            break;\n          case 6:\n            ue.segments = a.SegmentedFileOutput.decode(ie, ie.uint32());\n            break;\n          case 7:\n            ue.preset = ie.int32();\n            break;\n          case 8:\n            ue.advanced = a.EncodingOptions.decode(ie, ie.uint32());\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        url: Oe(P.url) ? String(P.url) : \"\",\n        audioOnly: Oe(P.audioOnly) ? !!P.audioOnly : !1,\n        videoOnly: Oe(P.videoOnly) ? !!P.videoOnly : !1,\n        file: Oe(P.file) ? a.EncodedFileOutput.fromJSON(P.file) : void 0,\n        stream: Oe(P.stream) ? a.StreamOutput.fromJSON(P.stream) : void 0,\n        segments: Oe(P.segments) ? a.SegmentedFileOutput.fromJSON(P.segments) : void 0,\n        preset: Oe(P.preset) ? ne(P.preset) : void 0,\n        advanced: Oe(P.advanced) ? a.EncodingOptions.fromJSON(P.advanced) : void 0\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.url !== void 0 && (X.url = P.url), P.audioOnly !== void 0 && (X.audioOnly = P.audioOnly), P.videoOnly !== void 0 && (X.videoOnly = P.videoOnly), P.file !== void 0 && (X.file = P.file ? a.EncodedFileOutput.toJSON(P.file) : void 0), P.stream !== void 0 && (X.stream = P.stream ? a.StreamOutput.toJSON(P.stream) : void 0), P.segments !== void 0 && (X.segments = P.segments ? a.SegmentedFileOutput.toJSON(P.segments) : void 0), P.preset !== void 0 && (X.preset = P.preset !== void 0 ? Z(P.preset) : void 0), P.advanced !== void 0 && (X.advanced = P.advanced ? a.EncodingOptions.toJSON(P.advanced) : void 0), X;\n    },\n    fromPartial(P) {\n      var X, ie, Ee, ue;\n      const O = ye();\n      return O.url = (X = P.url) !== null && X !== void 0 ? X : \"\", O.audioOnly = (ie = P.audioOnly) !== null && ie !== void 0 ? ie : !1, O.videoOnly = (Ee = P.videoOnly) !== null && Ee !== void 0 ? Ee : !1, O.file = P.file !== void 0 && P.file !== null ? a.EncodedFileOutput.fromPartial(P.file) : void 0, O.stream = P.stream !== void 0 && P.stream !== null ? a.StreamOutput.fromPartial(P.stream) : void 0, O.segments = P.segments !== void 0 && P.segments !== null ? a.SegmentedFileOutput.fromPartial(P.segments) : void 0, O.preset = (ue = P.preset) !== null && ue !== void 0 ? ue : void 0, O.advanced = P.advanced !== void 0 && P.advanced !== null ? a.EncodingOptions.fromPartial(P.advanced) : void 0, O;\n    }\n  };\n  function he() {\n    return {\n      fileType: 0,\n      filepath: \"\",\n      disableManifest: !1,\n      s3: void 0,\n      gcp: void 0,\n      azure: void 0,\n      aliOSS: void 0\n    };\n  }\n  a.EncodedFileOutput = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.fileType !== void 0 && P.fileType !== 0 && X.uint32(8).int32(P.fileType), P.filepath !== void 0 && P.filepath !== \"\" && X.uint32(18).string(P.filepath), P.disableManifest === !0 && X.uint32(48).bool(P.disableManifest), P.s3 !== void 0 && a.S3Upload.encode(P.s3, X.uint32(26).fork()).ldelim(), P.gcp !== void 0 && a.GCPUpload.encode(P.gcp, X.uint32(34).fork()).ldelim(), P.azure !== void 0 && a.AzureBlobUpload.encode(P.azure, X.uint32(42).fork()).ldelim(), P.aliOSS !== void 0 && a.AliOSSUpload.encode(P.aliOSS, X.uint32(58).fork()).ldelim(), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = he();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.fileType = ie.int32();\n            break;\n          case 2:\n            ue.filepath = ie.string();\n            break;\n          case 6:\n            ue.disableManifest = ie.bool();\n            break;\n          case 3:\n            ue.s3 = a.S3Upload.decode(ie, ie.uint32());\n            break;\n          case 4:\n            ue.gcp = a.GCPUpload.decode(ie, ie.uint32());\n            break;\n          case 5:\n            ue.azure = a.AzureBlobUpload.decode(ie, ie.uint32());\n            break;\n          case 7:\n            ue.aliOSS = a.AliOSSUpload.decode(ie, ie.uint32());\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        fileType: Oe(P.fileType) ? S(P.fileType) : 0,\n        filepath: Oe(P.filepath) ? String(P.filepath) : \"\",\n        disableManifest: Oe(P.disableManifest) ? !!P.disableManifest : !1,\n        s3: Oe(P.s3) ? a.S3Upload.fromJSON(P.s3) : void 0,\n        gcp: Oe(P.gcp) ? a.GCPUpload.fromJSON(P.gcp) : void 0,\n        azure: Oe(P.azure) ? a.AzureBlobUpload.fromJSON(P.azure) : void 0,\n        aliOSS: Oe(P.aliOSS) ? a.AliOSSUpload.fromJSON(P.aliOSS) : void 0\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.fileType !== void 0 && (X.fileType = g(P.fileType)), P.filepath !== void 0 && (X.filepath = P.filepath), P.disableManifest !== void 0 && (X.disableManifest = P.disableManifest), P.s3 !== void 0 && (X.s3 = P.s3 ? a.S3Upload.toJSON(P.s3) : void 0), P.gcp !== void 0 && (X.gcp = P.gcp ? a.GCPUpload.toJSON(P.gcp) : void 0), P.azure !== void 0 && (X.azure = P.azure ? a.AzureBlobUpload.toJSON(P.azure) : void 0), P.aliOSS !== void 0 && (X.aliOSS = P.aliOSS ? a.AliOSSUpload.toJSON(P.aliOSS) : void 0), X;\n    },\n    fromPartial(P) {\n      var X, ie, Ee;\n      const ue = he();\n      return ue.fileType = (X = P.fileType) !== null && X !== void 0 ? X : 0, ue.filepath = (ie = P.filepath) !== null && ie !== void 0 ? ie : \"\", ue.disableManifest = (Ee = P.disableManifest) !== null && Ee !== void 0 ? Ee : !1, ue.s3 = P.s3 !== void 0 && P.s3 !== null ? a.S3Upload.fromPartial(P.s3) : void 0, ue.gcp = P.gcp !== void 0 && P.gcp !== null ? a.GCPUpload.fromPartial(P.gcp) : void 0, ue.azure = P.azure !== void 0 && P.azure !== null ? a.AzureBlobUpload.fromPartial(P.azure) : void 0, ue.aliOSS = P.aliOSS !== void 0 && P.aliOSS !== null ? a.AliOSSUpload.fromPartial(P.aliOSS) : void 0, ue;\n    }\n  };\n  function le() {\n    return {\n      protocol: 0,\n      filenamePrefix: \"\",\n      playlistName: \"\",\n      segmentDuration: 0,\n      disableManifest: !1,\n      s3: void 0,\n      gcp: void 0,\n      azure: void 0,\n      aliOSS: void 0\n    };\n  }\n  a.SegmentedFileOutput = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.protocol !== void 0 && P.protocol !== 0 && X.uint32(8).int32(P.protocol), P.filenamePrefix !== void 0 && P.filenamePrefix !== \"\" && X.uint32(18).string(P.filenamePrefix), P.playlistName !== void 0 && P.playlistName !== \"\" && X.uint32(26).string(P.playlistName), P.segmentDuration !== void 0 && P.segmentDuration !== 0 && X.uint32(32).uint32(P.segmentDuration), P.disableManifest === !0 && X.uint32(64).bool(P.disableManifest), P.s3 !== void 0 && a.S3Upload.encode(P.s3, X.uint32(42).fork()).ldelim(), P.gcp !== void 0 && a.GCPUpload.encode(P.gcp, X.uint32(50).fork()).ldelim(), P.azure !== void 0 && a.AzureBlobUpload.encode(P.azure, X.uint32(58).fork()).ldelim(), P.aliOSS !== void 0 && a.AliOSSUpload.encode(P.aliOSS, X.uint32(74).fork()).ldelim(), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = le();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.protocol = ie.int32();\n            break;\n          case 2:\n            ue.filenamePrefix = ie.string();\n            break;\n          case 3:\n            ue.playlistName = ie.string();\n            break;\n          case 4:\n            ue.segmentDuration = ie.uint32();\n            break;\n          case 8:\n            ue.disableManifest = ie.bool();\n            break;\n          case 5:\n            ue.s3 = a.S3Upload.decode(ie, ie.uint32());\n            break;\n          case 6:\n            ue.gcp = a.GCPUpload.decode(ie, ie.uint32());\n            break;\n          case 7:\n            ue.azure = a.AzureBlobUpload.decode(ie, ie.uint32());\n            break;\n          case 9:\n            ue.aliOSS = a.AliOSSUpload.decode(ie, ie.uint32());\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        protocol: Oe(P.protocol) ? M(P.protocol) : 0,\n        filenamePrefix: Oe(P.filenamePrefix) ? String(P.filenamePrefix) : \"\",\n        playlistName: Oe(P.playlistName) ? String(P.playlistName) : \"\",\n        segmentDuration: Oe(P.segmentDuration) ? Number(P.segmentDuration) : 0,\n        disableManifest: Oe(P.disableManifest) ? !!P.disableManifest : !1,\n        s3: Oe(P.s3) ? a.S3Upload.fromJSON(P.s3) : void 0,\n        gcp: Oe(P.gcp) ? a.GCPUpload.fromJSON(P.gcp) : void 0,\n        azure: Oe(P.azure) ? a.AzureBlobUpload.fromJSON(P.azure) : void 0,\n        aliOSS: Oe(P.aliOSS) ? a.AliOSSUpload.fromJSON(P.aliOSS) : void 0\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.protocol !== void 0 && (X.protocol = $(P.protocol)), P.filenamePrefix !== void 0 && (X.filenamePrefix = P.filenamePrefix), P.playlistName !== void 0 && (X.playlistName = P.playlistName), P.segmentDuration !== void 0 && (X.segmentDuration = Math.round(P.segmentDuration)), P.disableManifest !== void 0 && (X.disableManifest = P.disableManifest), P.s3 !== void 0 && (X.s3 = P.s3 ? a.S3Upload.toJSON(P.s3) : void 0), P.gcp !== void 0 && (X.gcp = P.gcp ? a.GCPUpload.toJSON(P.gcp) : void 0), P.azure !== void 0 && (X.azure = P.azure ? a.AzureBlobUpload.toJSON(P.azure) : void 0), P.aliOSS !== void 0 && (X.aliOSS = P.aliOSS ? a.AliOSSUpload.toJSON(P.aliOSS) : void 0), X;\n    },\n    fromPartial(P) {\n      var X, ie, Ee, ue, O;\n      const j = le();\n      return j.protocol = (X = P.protocol) !== null && X !== void 0 ? X : 0, j.filenamePrefix = (ie = P.filenamePrefix) !== null && ie !== void 0 ? ie : \"\", j.playlistName = (Ee = P.playlistName) !== null && Ee !== void 0 ? Ee : \"\", j.segmentDuration = (ue = P.segmentDuration) !== null && ue !== void 0 ? ue : 0, j.disableManifest = (O = P.disableManifest) !== null && O !== void 0 ? O : !1, j.s3 = P.s3 !== void 0 && P.s3 !== null ? a.S3Upload.fromPartial(P.s3) : void 0, j.gcp = P.gcp !== void 0 && P.gcp !== null ? a.GCPUpload.fromPartial(P.gcp) : void 0, j.azure = P.azure !== void 0 && P.azure !== null ? a.AzureBlobUpload.fromPartial(P.azure) : void 0, j.aliOSS = P.aliOSS !== void 0 && P.aliOSS !== null ? a.AliOSSUpload.fromPartial(P.aliOSS) : void 0, j;\n    }\n  };\n  function we() {\n    return { filepath: \"\", disableManifest: !1, s3: void 0, gcp: void 0, azure: void 0, aliOSS: void 0 };\n  }\n  a.DirectFileOutput = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.filepath !== void 0 && P.filepath !== \"\" && X.uint32(10).string(P.filepath), P.disableManifest === !0 && X.uint32(40).bool(P.disableManifest), P.s3 !== void 0 && a.S3Upload.encode(P.s3, X.uint32(18).fork()).ldelim(), P.gcp !== void 0 && a.GCPUpload.encode(P.gcp, X.uint32(26).fork()).ldelim(), P.azure !== void 0 && a.AzureBlobUpload.encode(P.azure, X.uint32(34).fork()).ldelim(), P.aliOSS !== void 0 && a.AliOSSUpload.encode(P.aliOSS, X.uint32(50).fork()).ldelim(), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = we();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.filepath = ie.string();\n            break;\n          case 5:\n            ue.disableManifest = ie.bool();\n            break;\n          case 2:\n            ue.s3 = a.S3Upload.decode(ie, ie.uint32());\n            break;\n          case 3:\n            ue.gcp = a.GCPUpload.decode(ie, ie.uint32());\n            break;\n          case 4:\n            ue.azure = a.AzureBlobUpload.decode(ie, ie.uint32());\n            break;\n          case 6:\n            ue.aliOSS = a.AliOSSUpload.decode(ie, ie.uint32());\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        filepath: Oe(P.filepath) ? String(P.filepath) : \"\",\n        disableManifest: Oe(P.disableManifest) ? !!P.disableManifest : !1,\n        s3: Oe(P.s3) ? a.S3Upload.fromJSON(P.s3) : void 0,\n        gcp: Oe(P.gcp) ? a.GCPUpload.fromJSON(P.gcp) : void 0,\n        azure: Oe(P.azure) ? a.AzureBlobUpload.fromJSON(P.azure) : void 0,\n        aliOSS: Oe(P.aliOSS) ? a.AliOSSUpload.fromJSON(P.aliOSS) : void 0\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.filepath !== void 0 && (X.filepath = P.filepath), P.disableManifest !== void 0 && (X.disableManifest = P.disableManifest), P.s3 !== void 0 && (X.s3 = P.s3 ? a.S3Upload.toJSON(P.s3) : void 0), P.gcp !== void 0 && (X.gcp = P.gcp ? a.GCPUpload.toJSON(P.gcp) : void 0), P.azure !== void 0 && (X.azure = P.azure ? a.AzureBlobUpload.toJSON(P.azure) : void 0), P.aliOSS !== void 0 && (X.aliOSS = P.aliOSS ? a.AliOSSUpload.toJSON(P.aliOSS) : void 0), X;\n    },\n    fromPartial(P) {\n      var X, ie;\n      const Ee = we();\n      return Ee.filepath = (X = P.filepath) !== null && X !== void 0 ? X : \"\", Ee.disableManifest = (ie = P.disableManifest) !== null && ie !== void 0 ? ie : !1, Ee.s3 = P.s3 !== void 0 && P.s3 !== null ? a.S3Upload.fromPartial(P.s3) : void 0, Ee.gcp = P.gcp !== void 0 && P.gcp !== null ? a.GCPUpload.fromPartial(P.gcp) : void 0, Ee.azure = P.azure !== void 0 && P.azure !== null ? a.AzureBlobUpload.fromPartial(P.azure) : void 0, Ee.aliOSS = P.aliOSS !== void 0 && P.aliOSS !== null ? a.AliOSSUpload.fromPartial(P.aliOSS) : void 0, Ee;\n    }\n  };\n  function Be() {\n    return {\n      accessKey: \"\",\n      secret: \"\",\n      region: \"\",\n      endpoint: \"\",\n      bucket: \"\",\n      forcePathStyle: !1,\n      metadata: {},\n      tagging: \"\"\n    };\n  }\n  a.S3Upload = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.accessKey !== void 0 && P.accessKey !== \"\" && X.uint32(10).string(P.accessKey), P.secret !== void 0 && P.secret !== \"\" && X.uint32(18).string(P.secret), P.region !== void 0 && P.region !== \"\" && X.uint32(26).string(P.region), P.endpoint !== void 0 && P.endpoint !== \"\" && X.uint32(34).string(P.endpoint), P.bucket !== void 0 && P.bucket !== \"\" && X.uint32(42).string(P.bucket), P.forcePathStyle === !0 && X.uint32(48).bool(P.forcePathStyle), Object.entries(P.metadata || {}).forEach(([ie, Ee]) => {\n        a.S3Upload_MetadataEntry.encode({ key: ie, value: Ee }, X.uint32(58).fork()).ldelim();\n      }), P.tagging !== void 0 && P.tagging !== \"\" && X.uint32(66).string(P.tagging), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = Be();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.accessKey = ie.string();\n            break;\n          case 2:\n            ue.secret = ie.string();\n            break;\n          case 3:\n            ue.region = ie.string();\n            break;\n          case 4:\n            ue.endpoint = ie.string();\n            break;\n          case 5:\n            ue.bucket = ie.string();\n            break;\n          case 6:\n            ue.forcePathStyle = ie.bool();\n            break;\n          case 7:\n            const j = a.S3Upload_MetadataEntry.decode(ie, ie.uint32());\n            j.value !== void 0 && (ue.metadata[j.key] = j.value);\n            break;\n          case 8:\n            ue.tagging = ie.string();\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        accessKey: Oe(P.accessKey) ? String(P.accessKey) : \"\",\n        secret: Oe(P.secret) ? String(P.secret) : \"\",\n        region: Oe(P.region) ? String(P.region) : \"\",\n        endpoint: Oe(P.endpoint) ? String(P.endpoint) : \"\",\n        bucket: Oe(P.bucket) ? String(P.bucket) : \"\",\n        forcePathStyle: Oe(P.forcePathStyle) ? !!P.forcePathStyle : !1,\n        metadata: tt(P.metadata) ? Object.entries(P.metadata).reduce((X, [ie, Ee]) => (X[ie] = String(Ee), X), {}) : {},\n        tagging: Oe(P.tagging) ? String(P.tagging) : \"\"\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.accessKey !== void 0 && (X.accessKey = P.accessKey), P.secret !== void 0 && (X.secret = P.secret), P.region !== void 0 && (X.region = P.region), P.endpoint !== void 0 && (X.endpoint = P.endpoint), P.bucket !== void 0 && (X.bucket = P.bucket), P.forcePathStyle !== void 0 && (X.forcePathStyle = P.forcePathStyle), X.metadata = {}, P.metadata && Object.entries(P.metadata).forEach(([ie, Ee]) => {\n        X.metadata[ie] = Ee;\n      }), P.tagging !== void 0 && (X.tagging = P.tagging), X;\n    },\n    fromPartial(P) {\n      var X, ie, Ee, ue, O, j, se, _e;\n      const ve = Be();\n      return ve.accessKey = (X = P.accessKey) !== null && X !== void 0 ? X : \"\", ve.secret = (ie = P.secret) !== null && ie !== void 0 ? ie : \"\", ve.region = (Ee = P.region) !== null && Ee !== void 0 ? Ee : \"\", ve.endpoint = (ue = P.endpoint) !== null && ue !== void 0 ? ue : \"\", ve.bucket = (O = P.bucket) !== null && O !== void 0 ? O : \"\", ve.forcePathStyle = (j = P.forcePathStyle) !== null && j !== void 0 ? j : !1, ve.metadata = Object.entries((se = P.metadata) !== null && se !== void 0 ? se : {}).reduce((De, [Ze, Qe]) => (Qe !== void 0 && (De[Ze] = String(Qe)), De), {}), ve.tagging = (_e = P.tagging) !== null && _e !== void 0 ? _e : \"\", ve;\n    }\n  };\n  function Ne() {\n    return { key: \"\", value: \"\" };\n  }\n  a.S3Upload_MetadataEntry = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.key !== \"\" && X.uint32(10).string(P.key), P.value !== \"\" && X.uint32(18).string(P.value), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = Ne();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.key = ie.string();\n            break;\n          case 2:\n            ue.value = ie.string();\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return { key: Oe(P.key) ? String(P.key) : \"\", value: Oe(P.value) ? String(P.value) : \"\" };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.key !== void 0 && (X.key = P.key), P.value !== void 0 && (X.value = P.value), X;\n    },\n    fromPartial(P) {\n      var X, ie;\n      const Ee = Ne();\n      return Ee.key = (X = P.key) !== null && X !== void 0 ? X : \"\", Ee.value = (ie = P.value) !== null && ie !== void 0 ? ie : \"\", Ee;\n    }\n  };\n  function Le() {\n    return { credentials: new Uint8Array(), bucket: \"\" };\n  }\n  a.GCPUpload = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.credentials !== void 0 && P.credentials.length !== 0 && X.uint32(10).bytes(P.credentials), P.bucket !== void 0 && P.bucket !== \"\" && X.uint32(18).string(P.bucket), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = Le();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.credentials = ie.bytes();\n            break;\n          case 2:\n            ue.bucket = ie.string();\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        credentials: Oe(P.credentials) ? at(P.credentials) : new Uint8Array(),\n        bucket: Oe(P.bucket) ? String(P.bucket) : \"\"\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.credentials !== void 0 && (X.credentials = Ye(P.credentials !== void 0 ? P.credentials : new Uint8Array())), P.bucket !== void 0 && (X.bucket = P.bucket), X;\n    },\n    fromPartial(P) {\n      var X, ie;\n      const Ee = Le();\n      return Ee.credentials = (X = P.credentials) !== null && X !== void 0 ? X : new Uint8Array(), Ee.bucket = (ie = P.bucket) !== null && ie !== void 0 ? ie : \"\", Ee;\n    }\n  };\n  function $e() {\n    return { accountName: \"\", accountKey: \"\", containerName: \"\" };\n  }\n  a.AzureBlobUpload = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.accountName !== void 0 && P.accountName !== \"\" && X.uint32(10).string(P.accountName), P.accountKey !== void 0 && P.accountKey !== \"\" && X.uint32(18).string(P.accountKey), P.containerName !== void 0 && P.containerName !== \"\" && X.uint32(26).string(P.containerName), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = $e();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.accountName = ie.string();\n            break;\n          case 2:\n            ue.accountKey = ie.string();\n            break;\n          case 3:\n            ue.containerName = ie.string();\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        accountName: Oe(P.accountName) ? String(P.accountName) : \"\",\n        accountKey: Oe(P.accountKey) ? String(P.accountKey) : \"\",\n        containerName: Oe(P.containerName) ? String(P.containerName) : \"\"\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.accountName !== void 0 && (X.accountName = P.accountName), P.accountKey !== void 0 && (X.accountKey = P.accountKey), P.containerName !== void 0 && (X.containerName = P.containerName), X;\n    },\n    fromPartial(P) {\n      var X, ie, Ee;\n      const ue = $e();\n      return ue.accountName = (X = P.accountName) !== null && X !== void 0 ? X : \"\", ue.accountKey = (ie = P.accountKey) !== null && ie !== void 0 ? ie : \"\", ue.containerName = (Ee = P.containerName) !== null && Ee !== void 0 ? Ee : \"\", ue;\n    }\n  };\n  function Ue() {\n    return { accessKey: \"\", secret: \"\", region: \"\", endpoint: \"\", bucket: \"\" };\n  }\n  a.AliOSSUpload = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.accessKey !== void 0 && P.accessKey !== \"\" && X.uint32(10).string(P.accessKey), P.secret !== void 0 && P.secret !== \"\" && X.uint32(18).string(P.secret), P.region !== void 0 && P.region !== \"\" && X.uint32(26).string(P.region), P.endpoint !== void 0 && P.endpoint !== \"\" && X.uint32(34).string(P.endpoint), P.bucket !== void 0 && P.bucket !== \"\" && X.uint32(42).string(P.bucket), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = Ue();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.accessKey = ie.string();\n            break;\n          case 2:\n            ue.secret = ie.string();\n            break;\n          case 3:\n            ue.region = ie.string();\n            break;\n          case 4:\n            ue.endpoint = ie.string();\n            break;\n          case 5:\n            ue.bucket = ie.string();\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        accessKey: Oe(P.accessKey) ? String(P.accessKey) : \"\",\n        secret: Oe(P.secret) ? String(P.secret) : \"\",\n        region: Oe(P.region) ? String(P.region) : \"\",\n        endpoint: Oe(P.endpoint) ? String(P.endpoint) : \"\",\n        bucket: Oe(P.bucket) ? String(P.bucket) : \"\"\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.accessKey !== void 0 && (X.accessKey = P.accessKey), P.secret !== void 0 && (X.secret = P.secret), P.region !== void 0 && (X.region = P.region), P.endpoint !== void 0 && (X.endpoint = P.endpoint), P.bucket !== void 0 && (X.bucket = P.bucket), X;\n    },\n    fromPartial(P) {\n      var X, ie, Ee, ue, O;\n      const j = Ue();\n      return j.accessKey = (X = P.accessKey) !== null && X !== void 0 ? X : \"\", j.secret = (ie = P.secret) !== null && ie !== void 0 ? ie : \"\", j.region = (Ee = P.region) !== null && Ee !== void 0 ? Ee : \"\", j.endpoint = (ue = P.endpoint) !== null && ue !== void 0 ? ue : \"\", j.bucket = (O = P.bucket) !== null && O !== void 0 ? O : \"\", j;\n    }\n  };\n  function Ge() {\n    return { protocol: 0, urls: [] };\n  }\n  a.StreamOutput = {\n    encode(P, X = l.default.Writer.create()) {\n      if (P.protocol !== void 0 && P.protocol !== 0 && X.uint32(8).int32(P.protocol), P.urls !== void 0 && P.urls.length !== 0)\n        for (const ie of P.urls)\n          X.uint32(18).string(ie);\n      return X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = Ge();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.protocol = ie.int32();\n            break;\n          case 2:\n            ue.urls.push(ie.string());\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        protocol: Oe(P.protocol) ? _(P.protocol) : 0,\n        urls: Array.isArray(P == null ? void 0 : P.urls) ? P.urls.map((X) => String(X)) : []\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.protocol !== void 0 && (X.protocol = k(P.protocol)), P.urls ? X.urls = P.urls.map((ie) => ie) : X.urls = [], X;\n    },\n    fromPartial(P) {\n      var X, ie;\n      const Ee = Ge();\n      return Ee.protocol = (X = P.protocol) !== null && X !== void 0 ? X : 0, Ee.urls = ((ie = P.urls) === null || ie === void 0 ? void 0 : ie.map((ue) => ue)) || [], Ee;\n    }\n  };\n  function He() {\n    return {\n      width: 0,\n      height: 0,\n      depth: 0,\n      framerate: 0,\n      audioCodec: 0,\n      audioBitrate: 0,\n      audioFrequency: 0,\n      videoCodec: 0,\n      videoBitrate: 0\n    };\n  }\n  a.EncodingOptions = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.width !== void 0 && P.width !== 0 && X.uint32(8).int32(P.width), P.height !== void 0 && P.height !== 0 && X.uint32(16).int32(P.height), P.depth !== void 0 && P.depth !== 0 && X.uint32(24).int32(P.depth), P.framerate !== void 0 && P.framerate !== 0 && X.uint32(32).int32(P.framerate), P.audioCodec !== void 0 && P.audioCodec !== 0 && X.uint32(40).int32(P.audioCodec), P.audioBitrate !== void 0 && P.audioBitrate !== 0 && X.uint32(48).int32(P.audioBitrate), P.audioFrequency !== void 0 && P.audioFrequency !== 0 && X.uint32(56).int32(P.audioFrequency), P.videoCodec !== void 0 && P.videoCodec !== 0 && X.uint32(64).int32(P.videoCodec), P.videoBitrate !== void 0 && P.videoBitrate !== 0 && X.uint32(72).int32(P.videoBitrate), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = He();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.width = ie.int32();\n            break;\n          case 2:\n            ue.height = ie.int32();\n            break;\n          case 3:\n            ue.depth = ie.int32();\n            break;\n          case 4:\n            ue.framerate = ie.int32();\n            break;\n          case 5:\n            ue.audioCodec = ie.int32();\n            break;\n          case 6:\n            ue.audioBitrate = ie.int32();\n            break;\n          case 7:\n            ue.audioFrequency = ie.int32();\n            break;\n          case 8:\n            ue.videoCodec = ie.int32();\n            break;\n          case 9:\n            ue.videoBitrate = ie.int32();\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        width: Oe(P.width) ? Number(P.width) : 0,\n        height: Oe(P.height) ? Number(P.height) : 0,\n        depth: Oe(P.depth) ? Number(P.depth) : 0,\n        framerate: Oe(P.framerate) ? Number(P.framerate) : 0,\n        audioCodec: Oe(P.audioCodec) ? V(P.audioCodec) : 0,\n        audioBitrate: Oe(P.audioBitrate) ? Number(P.audioBitrate) : 0,\n        audioFrequency: Oe(P.audioFrequency) ? Number(P.audioFrequency) : 0,\n        videoCodec: Oe(P.videoCodec) ? H(P.videoCodec) : 0,\n        videoBitrate: Oe(P.videoBitrate) ? Number(P.videoBitrate) : 0\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.width !== void 0 && (X.width = Math.round(P.width)), P.height !== void 0 && (X.height = Math.round(P.height)), P.depth !== void 0 && (X.depth = Math.round(P.depth)), P.framerate !== void 0 && (X.framerate = Math.round(P.framerate)), P.audioCodec !== void 0 && (X.audioCodec = q(P.audioCodec)), P.audioBitrate !== void 0 && (X.audioBitrate = Math.round(P.audioBitrate)), P.audioFrequency !== void 0 && (X.audioFrequency = Math.round(P.audioFrequency)), P.videoCodec !== void 0 && (X.videoCodec = B(P.videoCodec)), P.videoBitrate !== void 0 && (X.videoBitrate = Math.round(P.videoBitrate)), X;\n    },\n    fromPartial(P) {\n      var X, ie, Ee, ue, O, j, se, _e, ve;\n      const De = He();\n      return De.width = (X = P.width) !== null && X !== void 0 ? X : 0, De.height = (ie = P.height) !== null && ie !== void 0 ? ie : 0, De.depth = (Ee = P.depth) !== null && Ee !== void 0 ? Ee : 0, De.framerate = (ue = P.framerate) !== null && ue !== void 0 ? ue : 0, De.audioCodec = (O = P.audioCodec) !== null && O !== void 0 ? O : 0, De.audioBitrate = (j = P.audioBitrate) !== null && j !== void 0 ? j : 0, De.audioFrequency = (se = P.audioFrequency) !== null && se !== void 0 ? se : 0, De.videoCodec = (_e = P.videoCodec) !== null && _e !== void 0 ? _e : 0, De.videoBitrate = (ve = P.videoBitrate) !== null && ve !== void 0 ? ve : 0, De;\n    }\n  };\n  function Ve() {\n    return { egressId: \"\", layout: \"\" };\n  }\n  a.UpdateLayoutRequest = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.egressId !== void 0 && P.egressId !== \"\" && X.uint32(10).string(P.egressId), P.layout !== void 0 && P.layout !== \"\" && X.uint32(18).string(P.layout), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = Ve();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.egressId = ie.string();\n            break;\n          case 2:\n            ue.layout = ie.string();\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        egressId: Oe(P.egressId) ? String(P.egressId) : \"\",\n        layout: Oe(P.layout) ? String(P.layout) : \"\"\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.egressId !== void 0 && (X.egressId = P.egressId), P.layout !== void 0 && (X.layout = P.layout), X;\n    },\n    fromPartial(P) {\n      var X, ie;\n      const Ee = Ve();\n      return Ee.egressId = (X = P.egressId) !== null && X !== void 0 ? X : \"\", Ee.layout = (ie = P.layout) !== null && ie !== void 0 ? ie : \"\", Ee;\n    }\n  };\n  function be() {\n    return { egressId: \"\", addOutputUrls: [], removeOutputUrls: [] };\n  }\n  a.UpdateStreamRequest = {\n    encode(P, X = l.default.Writer.create()) {\n      if (P.egressId !== void 0 && P.egressId !== \"\" && X.uint32(10).string(P.egressId), P.addOutputUrls !== void 0 && P.addOutputUrls.length !== 0)\n        for (const ie of P.addOutputUrls)\n          X.uint32(18).string(ie);\n      if (P.removeOutputUrls !== void 0 && P.removeOutputUrls.length !== 0)\n        for (const ie of P.removeOutputUrls)\n          X.uint32(26).string(ie);\n      return X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = be();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.egressId = ie.string();\n            break;\n          case 2:\n            ue.addOutputUrls.push(ie.string());\n            break;\n          case 3:\n            ue.removeOutputUrls.push(ie.string());\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        egressId: Oe(P.egressId) ? String(P.egressId) : \"\",\n        addOutputUrls: Array.isArray(P == null ? void 0 : P.addOutputUrls) ? P.addOutputUrls.map((X) => String(X)) : [],\n        removeOutputUrls: Array.isArray(P == null ? void 0 : P.removeOutputUrls) ? P.removeOutputUrls.map((X) => String(X)) : []\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.egressId !== void 0 && (X.egressId = P.egressId), P.addOutputUrls ? X.addOutputUrls = P.addOutputUrls.map((ie) => ie) : X.addOutputUrls = [], P.removeOutputUrls ? X.removeOutputUrls = P.removeOutputUrls.map((ie) => ie) : X.removeOutputUrls = [], X;\n    },\n    fromPartial(P) {\n      var X, ie, Ee;\n      const ue = be();\n      return ue.egressId = (X = P.egressId) !== null && X !== void 0 ? X : \"\", ue.addOutputUrls = ((ie = P.addOutputUrls) === null || ie === void 0 ? void 0 : ie.map((O) => O)) || [], ue.removeOutputUrls = ((Ee = P.removeOutputUrls) === null || Ee === void 0 ? void 0 : Ee.map((O) => O)) || [], ue;\n    }\n  };\n  function Ae() {\n    return { roomName: \"\" };\n  }\n  a.ListEgressRequest = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.roomName !== void 0 && P.roomName !== \"\" && X.uint32(10).string(P.roomName), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = Ae();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.roomName = ie.string();\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return { roomName: Oe(P.roomName) ? String(P.roomName) : \"\" };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.roomName !== void 0 && (X.roomName = P.roomName), X;\n    },\n    fromPartial(P) {\n      var X;\n      const ie = Ae();\n      return ie.roomName = (X = P.roomName) !== null && X !== void 0 ? X : \"\", ie;\n    }\n  };\n  function qe() {\n    return { items: [] };\n  }\n  a.ListEgressResponse = {\n    encode(P, X = l.default.Writer.create()) {\n      if (P.items !== void 0 && P.items.length !== 0)\n        for (const ie of P.items)\n          a.EgressInfo.encode(ie, X.uint32(10).fork()).ldelim();\n      return X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = qe();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.items.push(a.EgressInfo.decode(ie, ie.uint32()));\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return { items: Array.isArray(P == null ? void 0 : P.items) ? P.items.map((X) => a.EgressInfo.fromJSON(X)) : [] };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.items ? X.items = P.items.map((ie) => ie ? a.EgressInfo.toJSON(ie) : void 0) : X.items = [], X;\n    },\n    fromPartial(P) {\n      var X;\n      const ie = qe();\n      return ie.items = ((X = P.items) === null || X === void 0 ? void 0 : X.map((Ee) => a.EgressInfo.fromPartial(Ee))) || [], ie;\n    }\n  };\n  function xe() {\n    return { egressId: \"\" };\n  }\n  a.StopEgressRequest = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.egressId !== void 0 && P.egressId !== \"\" && X.uint32(10).string(P.egressId), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = xe();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.egressId = ie.string();\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return { egressId: Oe(P.egressId) ? String(P.egressId) : \"\" };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.egressId !== void 0 && (X.egressId = P.egressId), X;\n    },\n    fromPartial(P) {\n      var X;\n      const ie = xe();\n      return ie.egressId = (X = P.egressId) !== null && X !== void 0 ? X : \"\", ie;\n    }\n  };\n  function Pe() {\n    return {\n      egressId: \"\",\n      roomId: \"\",\n      roomName: \"\",\n      status: 0,\n      startedAt: 0,\n      endedAt: 0,\n      error: \"\",\n      roomComposite: void 0,\n      trackComposite: void 0,\n      track: void 0,\n      web: void 0,\n      stream: void 0,\n      file: void 0,\n      segments: void 0\n    };\n  }\n  a.EgressInfo = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.egressId !== void 0 && P.egressId !== \"\" && X.uint32(10).string(P.egressId), P.roomId !== void 0 && P.roomId !== \"\" && X.uint32(18).string(P.roomId), P.roomName !== void 0 && P.roomName !== \"\" && X.uint32(106).string(P.roomName), P.status !== void 0 && P.status !== 0 && X.uint32(24).int32(P.status), P.startedAt !== void 0 && P.startedAt !== 0 && X.uint32(80).int64(P.startedAt), P.endedAt !== void 0 && P.endedAt !== 0 && X.uint32(88).int64(P.endedAt), P.error !== void 0 && P.error !== \"\" && X.uint32(74).string(P.error), P.roomComposite !== void 0 && a.RoomCompositeEgressRequest.encode(P.roomComposite, X.uint32(34).fork()).ldelim(), P.trackComposite !== void 0 && a.TrackCompositeEgressRequest.encode(P.trackComposite, X.uint32(42).fork()).ldelim(), P.track !== void 0 && a.TrackEgressRequest.encode(P.track, X.uint32(50).fork()).ldelim(), P.web !== void 0 && a.WebEgressRequest.encode(P.web, X.uint32(114).fork()).ldelim(), P.stream !== void 0 && a.StreamInfoList.encode(P.stream, X.uint32(58).fork()).ldelim(), P.file !== void 0 && a.FileInfo.encode(P.file, X.uint32(66).fork()).ldelim(), P.segments !== void 0 && a.SegmentsInfo.encode(P.segments, X.uint32(98).fork()).ldelim(), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = Pe();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.egressId = ie.string();\n            break;\n          case 2:\n            ue.roomId = ie.string();\n            break;\n          case 13:\n            ue.roomName = ie.string();\n            break;\n          case 3:\n            ue.status = ie.int32();\n            break;\n          case 10:\n            ue.startedAt = je(ie.int64());\n            break;\n          case 11:\n            ue.endedAt = je(ie.int64());\n            break;\n          case 9:\n            ue.error = ie.string();\n            break;\n          case 4:\n            ue.roomComposite = a.RoomCompositeEgressRequest.decode(ie, ie.uint32());\n            break;\n          case 5:\n            ue.trackComposite = a.TrackCompositeEgressRequest.decode(ie, ie.uint32());\n            break;\n          case 6:\n            ue.track = a.TrackEgressRequest.decode(ie, ie.uint32());\n            break;\n          case 14:\n            ue.web = a.WebEgressRequest.decode(ie, ie.uint32());\n            break;\n          case 7:\n            ue.stream = a.StreamInfoList.decode(ie, ie.uint32());\n            break;\n          case 8:\n            ue.file = a.FileInfo.decode(ie, ie.uint32());\n            break;\n          case 12:\n            ue.segments = a.SegmentsInfo.decode(ie, ie.uint32());\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        egressId: Oe(P.egressId) ? String(P.egressId) : \"\",\n        roomId: Oe(P.roomId) ? String(P.roomId) : \"\",\n        roomName: Oe(P.roomName) ? String(P.roomName) : \"\",\n        status: Oe(P.status) ? oe(P.status) : 0,\n        startedAt: Oe(P.startedAt) ? Number(P.startedAt) : 0,\n        endedAt: Oe(P.endedAt) ? Number(P.endedAt) : 0,\n        error: Oe(P.error) ? String(P.error) : \"\",\n        roomComposite: Oe(P.roomComposite) ? a.RoomCompositeEgressRequest.fromJSON(P.roomComposite) : void 0,\n        trackComposite: Oe(P.trackComposite) ? a.TrackCompositeEgressRequest.fromJSON(P.trackComposite) : void 0,\n        track: Oe(P.track) ? a.TrackEgressRequest.fromJSON(P.track) : void 0,\n        web: Oe(P.web) ? a.WebEgressRequest.fromJSON(P.web) : void 0,\n        stream: Oe(P.stream) ? a.StreamInfoList.fromJSON(P.stream) : void 0,\n        file: Oe(P.file) ? a.FileInfo.fromJSON(P.file) : void 0,\n        segments: Oe(P.segments) ? a.SegmentsInfo.fromJSON(P.segments) : void 0\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.egressId !== void 0 && (X.egressId = P.egressId), P.roomId !== void 0 && (X.roomId = P.roomId), P.roomName !== void 0 && (X.roomName = P.roomName), P.status !== void 0 && (X.status = de(P.status)), P.startedAt !== void 0 && (X.startedAt = Math.round(P.startedAt)), P.endedAt !== void 0 && (X.endedAt = Math.round(P.endedAt)), P.error !== void 0 && (X.error = P.error), P.roomComposite !== void 0 && (X.roomComposite = P.roomComposite ? a.RoomCompositeEgressRequest.toJSON(P.roomComposite) : void 0), P.trackComposite !== void 0 && (X.trackComposite = P.trackComposite ? a.TrackCompositeEgressRequest.toJSON(P.trackComposite) : void 0), P.track !== void 0 && (X.track = P.track ? a.TrackEgressRequest.toJSON(P.track) : void 0), P.web !== void 0 && (X.web = P.web ? a.WebEgressRequest.toJSON(P.web) : void 0), P.stream !== void 0 && (X.stream = P.stream ? a.StreamInfoList.toJSON(P.stream) : void 0), P.file !== void 0 && (X.file = P.file ? a.FileInfo.toJSON(P.file) : void 0), P.segments !== void 0 && (X.segments = P.segments ? a.SegmentsInfo.toJSON(P.segments) : void 0), X;\n    },\n    fromPartial(P) {\n      var X, ie, Ee, ue, O, j, se;\n      const _e = Pe();\n      return _e.egressId = (X = P.egressId) !== null && X !== void 0 ? X : \"\", _e.roomId = (ie = P.roomId) !== null && ie !== void 0 ? ie : \"\", _e.roomName = (Ee = P.roomName) !== null && Ee !== void 0 ? Ee : \"\", _e.status = (ue = P.status) !== null && ue !== void 0 ? ue : 0, _e.startedAt = (O = P.startedAt) !== null && O !== void 0 ? O : 0, _e.endedAt = (j = P.endedAt) !== null && j !== void 0 ? j : 0, _e.error = (se = P.error) !== null && se !== void 0 ? se : \"\", _e.roomComposite = P.roomComposite !== void 0 && P.roomComposite !== null ? a.RoomCompositeEgressRequest.fromPartial(P.roomComposite) : void 0, _e.trackComposite = P.trackComposite !== void 0 && P.trackComposite !== null ? a.TrackCompositeEgressRequest.fromPartial(P.trackComposite) : void 0, _e.track = P.track !== void 0 && P.track !== null ? a.TrackEgressRequest.fromPartial(P.track) : void 0, _e.web = P.web !== void 0 && P.web !== null ? a.WebEgressRequest.fromPartial(P.web) : void 0, _e.stream = P.stream !== void 0 && P.stream !== null ? a.StreamInfoList.fromPartial(P.stream) : void 0, _e.file = P.file !== void 0 && P.file !== null ? a.FileInfo.fromPartial(P.file) : void 0, _e.segments = P.segments !== void 0 && P.segments !== null ? a.SegmentsInfo.fromPartial(P.segments) : void 0, _e;\n    }\n  };\n  function C() {\n    return { info: [] };\n  }\n  a.StreamInfoList = {\n    encode(P, X = l.default.Writer.create()) {\n      if (P.info !== void 0 && P.info.length !== 0)\n        for (const ie of P.info)\n          a.StreamInfo.encode(ie, X.uint32(10).fork()).ldelim();\n      return X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = C();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.info.push(a.StreamInfo.decode(ie, ie.uint32()));\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return { info: Array.isArray(P == null ? void 0 : P.info) ? P.info.map((X) => a.StreamInfo.fromJSON(X)) : [] };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.info ? X.info = P.info.map((ie) => ie ? a.StreamInfo.toJSON(ie) : void 0) : X.info = [], X;\n    },\n    fromPartial(P) {\n      var X;\n      const ie = C();\n      return ie.info = ((X = P.info) === null || X === void 0 ? void 0 : X.map((Ee) => a.StreamInfo.fromPartial(Ee))) || [], ie;\n    }\n  };\n  function x() {\n    return { url: \"\", startedAt: 0, endedAt: 0, duration: 0, status: 0 };\n  }\n  a.StreamInfo = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.url !== void 0 && P.url !== \"\" && X.uint32(10).string(P.url), P.startedAt !== void 0 && P.startedAt !== 0 && X.uint32(16).int64(P.startedAt), P.endedAt !== void 0 && P.endedAt !== 0 && X.uint32(24).int64(P.endedAt), P.duration !== void 0 && P.duration !== 0 && X.uint32(32).int64(P.duration), P.status !== void 0 && P.status !== 0 && X.uint32(40).int32(P.status), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = x();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.url = ie.string();\n            break;\n          case 2:\n            ue.startedAt = je(ie.int64());\n            break;\n          case 3:\n            ue.endedAt = je(ie.int64());\n            break;\n          case 4:\n            ue.duration = je(ie.int64());\n            break;\n          case 5:\n            ue.status = ie.int32();\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        url: Oe(P.url) ? String(P.url) : \"\",\n        startedAt: Oe(P.startedAt) ? Number(P.startedAt) : 0,\n        endedAt: Oe(P.endedAt) ? Number(P.endedAt) : 0,\n        duration: Oe(P.duration) ? Number(P.duration) : 0,\n        status: Oe(P.status) ? N(P.status) : 0\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.url !== void 0 && (X.url = P.url), P.startedAt !== void 0 && (X.startedAt = Math.round(P.startedAt)), P.endedAt !== void 0 && (X.endedAt = Math.round(P.endedAt)), P.duration !== void 0 && (X.duration = Math.round(P.duration)), P.status !== void 0 && (X.status = D(P.status)), X;\n    },\n    fromPartial(P) {\n      var X, ie, Ee, ue, O;\n      const j = x();\n      return j.url = (X = P.url) !== null && X !== void 0 ? X : \"\", j.startedAt = (ie = P.startedAt) !== null && ie !== void 0 ? ie : 0, j.endedAt = (Ee = P.endedAt) !== null && Ee !== void 0 ? Ee : 0, j.duration = (ue = P.duration) !== null && ue !== void 0 ? ue : 0, j.status = (O = P.status) !== null && O !== void 0 ? O : 0, j;\n    }\n  };\n  function Q() {\n    return { filename: \"\", startedAt: 0, endedAt: 0, duration: 0, size: 0, location: \"\" };\n  }\n  a.FileInfo = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.filename !== void 0 && P.filename !== \"\" && X.uint32(10).string(P.filename), P.startedAt !== void 0 && P.startedAt !== 0 && X.uint32(16).int64(P.startedAt), P.endedAt !== void 0 && P.endedAt !== 0 && X.uint32(24).int64(P.endedAt), P.duration !== void 0 && P.duration !== 0 && X.uint32(48).int64(P.duration), P.size !== void 0 && P.size !== 0 && X.uint32(32).int64(P.size), P.location !== void 0 && P.location !== \"\" && X.uint32(42).string(P.location), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = Q();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.filename = ie.string();\n            break;\n          case 2:\n            ue.startedAt = je(ie.int64());\n            break;\n          case 3:\n            ue.endedAt = je(ie.int64());\n            break;\n          case 6:\n            ue.duration = je(ie.int64());\n            break;\n          case 4:\n            ue.size = je(ie.int64());\n            break;\n          case 5:\n            ue.location = ie.string();\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        filename: Oe(P.filename) ? String(P.filename) : \"\",\n        startedAt: Oe(P.startedAt) ? Number(P.startedAt) : 0,\n        endedAt: Oe(P.endedAt) ? Number(P.endedAt) : 0,\n        duration: Oe(P.duration) ? Number(P.duration) : 0,\n        size: Oe(P.size) ? Number(P.size) : 0,\n        location: Oe(P.location) ? String(P.location) : \"\"\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.filename !== void 0 && (X.filename = P.filename), P.startedAt !== void 0 && (X.startedAt = Math.round(P.startedAt)), P.endedAt !== void 0 && (X.endedAt = Math.round(P.endedAt)), P.duration !== void 0 && (X.duration = Math.round(P.duration)), P.size !== void 0 && (X.size = Math.round(P.size)), P.location !== void 0 && (X.location = P.location), X;\n    },\n    fromPartial(P) {\n      var X, ie, Ee, ue, O, j;\n      const se = Q();\n      return se.filename = (X = P.filename) !== null && X !== void 0 ? X : \"\", se.startedAt = (ie = P.startedAt) !== null && ie !== void 0 ? ie : 0, se.endedAt = (Ee = P.endedAt) !== null && Ee !== void 0 ? Ee : 0, se.duration = (ue = P.duration) !== null && ue !== void 0 ? ue : 0, se.size = (O = P.size) !== null && O !== void 0 ? O : 0, se.location = (j = P.location) !== null && j !== void 0 ? j : \"\", se;\n    }\n  };\n  function Se() {\n    return { playlistName: \"\", duration: 0, size: 0, playlistLocation: \"\", segmentCount: 0, startedAt: 0, endedAt: 0 };\n  }\n  a.SegmentsInfo = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.playlistName !== void 0 && P.playlistName !== \"\" && X.uint32(10).string(P.playlistName), P.duration !== void 0 && P.duration !== 0 && X.uint32(16).int64(P.duration), P.size !== void 0 && P.size !== 0 && X.uint32(24).int64(P.size), P.playlistLocation !== void 0 && P.playlistLocation !== \"\" && X.uint32(34).string(P.playlistLocation), P.segmentCount !== void 0 && P.segmentCount !== 0 && X.uint32(40).int64(P.segmentCount), P.startedAt !== void 0 && P.startedAt !== 0 && X.uint32(48).int64(P.startedAt), P.endedAt !== void 0 && P.endedAt !== 0 && X.uint32(56).int64(P.endedAt), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = Se();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.playlistName = ie.string();\n            break;\n          case 2:\n            ue.duration = je(ie.int64());\n            break;\n          case 3:\n            ue.size = je(ie.int64());\n            break;\n          case 4:\n            ue.playlistLocation = ie.string();\n            break;\n          case 5:\n            ue.segmentCount = je(ie.int64());\n            break;\n          case 6:\n            ue.startedAt = je(ie.int64());\n            break;\n          case 7:\n            ue.endedAt = je(ie.int64());\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        playlistName: Oe(P.playlistName) ? String(P.playlistName) : \"\",\n        duration: Oe(P.duration) ? Number(P.duration) : 0,\n        size: Oe(P.size) ? Number(P.size) : 0,\n        playlistLocation: Oe(P.playlistLocation) ? String(P.playlistLocation) : \"\",\n        segmentCount: Oe(P.segmentCount) ? Number(P.segmentCount) : 0,\n        startedAt: Oe(P.startedAt) ? Number(P.startedAt) : 0,\n        endedAt: Oe(P.endedAt) ? Number(P.endedAt) : 0\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.playlistName !== void 0 && (X.playlistName = P.playlistName), P.duration !== void 0 && (X.duration = Math.round(P.duration)), P.size !== void 0 && (X.size = Math.round(P.size)), P.playlistLocation !== void 0 && (X.playlistLocation = P.playlistLocation), P.segmentCount !== void 0 && (X.segmentCount = Math.round(P.segmentCount)), P.startedAt !== void 0 && (X.startedAt = Math.round(P.startedAt)), P.endedAt !== void 0 && (X.endedAt = Math.round(P.endedAt)), X;\n    },\n    fromPartial(P) {\n      var X, ie, Ee, ue, O, j, se;\n      const _e = Se();\n      return _e.playlistName = (X = P.playlistName) !== null && X !== void 0 ? X : \"\", _e.duration = (ie = P.duration) !== null && ie !== void 0 ? ie : 0, _e.size = (Ee = P.size) !== null && Ee !== void 0 ? Ee : 0, _e.playlistLocation = (ue = P.playlistLocation) !== null && ue !== void 0 ? ue : \"\", _e.segmentCount = (O = P.segmentCount) !== null && O !== void 0 ? O : 0, _e.startedAt = (j = P.startedAt) !== null && j !== void 0 ? j : 0, _e.endedAt = (se = P.endedAt) !== null && se !== void 0 ? se : 0, _e;\n    }\n  };\n  function me() {\n    return { filepath: \"\", disableManifest: !1, s3: void 0, gcp: void 0, azure: void 0 };\n  }\n  a.AutoTrackEgress = {\n    encode(P, X = l.default.Writer.create()) {\n      return P.filepath !== void 0 && P.filepath !== \"\" && X.uint32(10).string(P.filepath), P.disableManifest === !0 && X.uint32(40).bool(P.disableManifest), P.s3 !== void 0 && a.S3Upload.encode(P.s3, X.uint32(18).fork()).ldelim(), P.gcp !== void 0 && a.GCPUpload.encode(P.gcp, X.uint32(26).fork()).ldelim(), P.azure !== void 0 && a.AzureBlobUpload.encode(P.azure, X.uint32(34).fork()).ldelim(), X;\n    },\n    decode(P, X) {\n      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);\n      let Ee = X === void 0 ? ie.len : ie.pos + X;\n      const ue = me();\n      for (; ie.pos < Ee; ) {\n        const O = ie.uint32();\n        switch (O >>> 3) {\n          case 1:\n            ue.filepath = ie.string();\n            break;\n          case 5:\n            ue.disableManifest = ie.bool();\n            break;\n          case 2:\n            ue.s3 = a.S3Upload.decode(ie, ie.uint32());\n            break;\n          case 3:\n            ue.gcp = a.GCPUpload.decode(ie, ie.uint32());\n            break;\n          case 4:\n            ue.azure = a.AzureBlobUpload.decode(ie, ie.uint32());\n            break;\n          default:\n            ie.skipType(O & 7);\n            break;\n        }\n      }\n      return ue;\n    },\n    fromJSON(P) {\n      return {\n        filepath: Oe(P.filepath) ? String(P.filepath) : \"\",\n        disableManifest: Oe(P.disableManifest) ? !!P.disableManifest : !1,\n        s3: Oe(P.s3) ? a.S3Upload.fromJSON(P.s3) : void 0,\n        gcp: Oe(P.gcp) ? a.GCPUpload.fromJSON(P.gcp) : void 0,\n        azure: Oe(P.azure) ? a.AzureBlobUpload.fromJSON(P.azure) : void 0\n      };\n    },\n    toJSON(P) {\n      const X = {};\n      return P.filepath !== void 0 && (X.filepath = P.filepath), P.disableManifest !== void 0 && (X.disableManifest = P.disableManifest), P.s3 !== void 0 && (X.s3 = P.s3 ? a.S3Upload.toJSON(P.s3) : void 0), P.gcp !== void 0 && (X.gcp = P.gcp ? a.GCPUpload.toJSON(P.gcp) : void 0), P.azure !== void 0 && (X.azure = P.azure ? a.AzureBlobUpload.toJSON(P.azure) : void 0), X;\n    },\n    fromPartial(P) {\n      var X, ie;\n      const Ee = me();\n      return Ee.filepath = (X = P.filepath) !== null && X !== void 0 ? X : \"\", Ee.disableManifest = (ie = P.disableManifest) !== null && ie !== void 0 ? ie : !1, Ee.s3 = P.s3 !== void 0 && P.s3 !== null ? a.S3Upload.fromPartial(P.s3) : void 0, Ee.gcp = P.gcp !== void 0 && P.gcp !== null ? a.GCPUpload.fromPartial(P.gcp) : void 0, Ee.azure = P.azure !== void 0 && P.azure !== null ? a.AzureBlobUpload.fromPartial(P.azure) : void 0, Ee;\n    }\n  };\n  var Ie = (() => {\n    if (typeof Ie < \"u\")\n      return Ie;\n    if (typeof self < \"u\")\n      return self;\n    if (typeof window < \"u\")\n      return window;\n    if (typeof commonjsGlobal$1 < \"u\")\n      return commonjsGlobal$1;\n    throw \"Unable to locate global object\";\n  })();\n  function at(P) {\n    if (Ie.Buffer)\n      return Uint8Array.from(Ie.Buffer.from(P, \"base64\"));\n    {\n      const X = Ie.atob(P), ie = new Uint8Array(X.length);\n      for (let Ee = 0; Ee < X.length; ++Ee)\n        ie[Ee] = X.charCodeAt(Ee);\n      return ie;\n    }\n  }\n  function Ye(P) {\n    if (Ie.Buffer)\n      return Ie.Buffer.from(P).toString(\"base64\");\n    {\n      const X = [];\n      return P.forEach((ie) => {\n        X.push(String.fromCharCode(ie));\n      }), Ie.btoa(X.join(\"\"));\n    }\n  }\n  function je(P) {\n    if (P.gt(Number.MAX_SAFE_INTEGER))\n      throw new Ie.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n    return P.toNumber();\n  }\n  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());\n  function tt(P) {\n    return typeof P == \"object\" && P !== null;\n  }\n  function Oe(P) {\n    return P != null;\n  }\n})(livekit_egress);\nvar ServiceBase$1 = {};\nObject.defineProperty(ServiceBase$1, \"__esModule\", { value: !0 });\nconst AccessToken_1$1 = AccessToken$1;\nclass ServiceBase {\n  /**\n   * @param apiKey API Key.\n   * @param secret API Secret.\n   * @param ttl token TTL\n   */\n  constructor(u, c, l) {\n    this.apiKey = u, this.secret = c, this.ttl = l || \"10m\";\n  }\n  authHeader(u) {\n    const c = new AccessToken_1$1.AccessToken(this.apiKey, this.secret, { ttl: this.ttl });\n    return c.addGrant(u), {\n      Authorization: `Bearer ${c.toJwt()}`\n    };\n  }\n}\nServiceBase$1.default = ServiceBase;\nvar TwirpRPC = {}, axios$2 = { exports: {} }, bind$2 = function a(u, c) {\n  return function() {\n    for (var v = new Array(arguments.length), S = 0; S < v.length; S++)\n      v[S] = arguments[S];\n    return u.apply(c, v);\n  };\n}, bind$1 = bind$2, toString = Object.prototype.toString;\nfunction isArray$1(a) {\n  return toString.call(a) === \"[object Array]\";\n}\nfunction isUndefined(a) {\n  return typeof a > \"u\";\n}\nfunction isBuffer(a) {\n  return a !== null && !isUndefined(a) && a.constructor !== null && !isUndefined(a.constructor) && typeof a.constructor.isBuffer == \"function\" && a.constructor.isBuffer(a);\n}\nfunction isArrayBuffer(a) {\n  return toString.call(a) === \"[object ArrayBuffer]\";\n}\nfunction isFormData(a) {\n  return typeof FormData < \"u\" && a instanceof FormData;\n}\nfunction isArrayBufferView(a) {\n  var u;\n  return typeof ArrayBuffer < \"u\" && ArrayBuffer.isView ? u = ArrayBuffer.isView(a) : u = a && a.buffer && a.buffer instanceof ArrayBuffer, u;\n}\nfunction isString(a) {\n  return typeof a == \"string\";\n}\nfunction isNumber(a) {\n  return typeof a == \"number\";\n}\nfunction isObject$3(a) {\n  return a !== null && typeof a == \"object\";\n}\nfunction isPlainObject(a) {\n  if (toString.call(a) !== \"[object Object]\")\n    return !1;\n  var u = Object.getPrototypeOf(a);\n  return u === null || u === Object.prototype;\n}\nfunction isDate(a) {\n  return toString.call(a) === \"[object Date]\";\n}\nfunction isFile(a) {\n  return toString.call(a) === \"[object File]\";\n}\nfunction isBlob(a) {\n  return toString.call(a) === \"[object Blob]\";\n}\nfunction isFunction(a) {\n  return toString.call(a) === \"[object Function]\";\n}\nfunction isStream(a) {\n  return isObject$3(a) && isFunction(a.pipe);\n}\nfunction isURLSearchParams(a) {\n  return typeof URLSearchParams < \"u\" && a instanceof URLSearchParams;\n}\nfunction trim$1(a) {\n  return a.trim ? a.trim() : a.replace(/^\\s+|\\s+$/g, \"\");\n}\nfunction isStandardBrowserEnv() {\n  return typeof navigator < \"u\" && (navigator.product === \"ReactNative\" || navigator.product === \"NativeScript\" || navigator.product === \"NS\") ? !1 : typeof window < \"u\" && typeof document < \"u\";\n}\nfunction forEach(a, u) {\n  if (!(a === null || typeof a > \"u\"))\n    if (typeof a != \"object\" && (a = [a]), isArray$1(a))\n      for (var c = 0, l = a.length; c < l; c++)\n        u.call(null, a[c], c, a);\n    else\n      for (var v in a)\n        Object.prototype.hasOwnProperty.call(a, v) && u.call(null, a[v], v, a);\n}\nfunction merge() {\n  var a = {};\n  function u(v, S) {\n    isPlainObject(a[S]) && isPlainObject(v) ? a[S] = merge(a[S], v) : isPlainObject(v) ? a[S] = merge({}, v) : isArray$1(v) ? a[S] = v.slice() : a[S] = v;\n  }\n  for (var c = 0, l = arguments.length; c < l; c++)\n    forEach(arguments[c], u);\n  return a;\n}\nfunction extend(a, u, c) {\n  return forEach(u, function(v, S) {\n    c && typeof v == \"function\" ? a[S] = bind$1(v, c) : a[S] = v;\n  }), a;\n}\nfunction stripBOM(a) {\n  return a.charCodeAt(0) === 65279 && (a = a.slice(1)), a;\n}\nvar utils$9 = {\n  isArray: isArray$1,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isObject: isObject$3,\n  isPlainObject,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isFunction,\n  isStream,\n  isURLSearchParams,\n  isStandardBrowserEnv,\n  forEach,\n  merge,\n  extend,\n  trim: trim$1,\n  stripBOM\n}, utils$8 = utils$9;\nfunction encode(a) {\n  return encodeURIComponent(a).replace(/%3A/gi, \":\").replace(/%24/g, \"$\").replace(/%2C/gi, \",\").replace(/%20/g, \"+\").replace(/%5B/gi, \"[\").replace(/%5D/gi, \"]\");\n}\nvar buildURL$1 = function a(u, c, l) {\n  if (!c)\n    return u;\n  var v;\n  if (l)\n    v = l(c);\n  else if (utils$8.isURLSearchParams(c))\n    v = c.toString();\n  else {\n    var S = [];\n    utils$8.forEach(c, function(_, k) {\n      _ === null || typeof _ > \"u\" || (utils$8.isArray(_) ? k = k + \"[]\" : _ = [_], utils$8.forEach(_, function(M) {\n        utils$8.isDate(M) ? M = M.toISOString() : utils$8.isObject(M) && (M = JSON.stringify(M)), S.push(encode(k) + \"=\" + encode(M));\n      }));\n    }), v = S.join(\"&\");\n  }\n  if (v) {\n    var g = u.indexOf(\"#\");\n    g !== -1 && (u = u.slice(0, g)), u += (u.indexOf(\"?\") === -1 ? \"?\" : \"&\") + v;\n  }\n  return u;\n}, utils$7 = utils$9;\nfunction InterceptorManager$1() {\n  this.handlers = [];\n}\nInterceptorManager$1.prototype.use = function a(u, c, l) {\n  return this.handlers.push({\n    fulfilled: u,\n    rejected: c,\n    synchronous: l ? l.synchronous : !1,\n    runWhen: l ? l.runWhen : null\n  }), this.handlers.length - 1;\n};\nInterceptorManager$1.prototype.eject = function a(u) {\n  this.handlers[u] && (this.handlers[u] = null);\n};\nInterceptorManager$1.prototype.forEach = function a(u) {\n  utils$7.forEach(this.handlers, function(l) {\n    l !== null && u(l);\n  });\n};\nvar InterceptorManager_1 = InterceptorManager$1, utils$6 = utils$9, normalizeHeaderName$1 = function a(u, c) {\n  utils$6.forEach(u, function(v, S) {\n    S !== c && S.toUpperCase() === c.toUpperCase() && (u[c] = v, delete u[S]);\n  });\n}, enhanceError$1 = function a(u, c, l, v, S) {\n  return u.config = c, l && (u.code = l), u.request = v, u.response = S, u.isAxiosError = !0, u.toJSON = function() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  }, u;\n}, createError, hasRequiredCreateError;\nfunction requireCreateError() {\n  if (hasRequiredCreateError)\n    return createError;\n  hasRequiredCreateError = 1;\n  var a = enhanceError$1;\n  return createError = function(c, l, v, S, g) {\n    var E = new Error(c);\n    return a(E, l, v, S, g);\n  }, createError;\n}\nvar settle, hasRequiredSettle;\nfunction requireSettle() {\n  if (hasRequiredSettle)\n    return settle;\n  hasRequiredSettle = 1;\n  var a = requireCreateError();\n  return settle = function(c, l, v) {\n    var S = v.config.validateStatus;\n    !v.status || !S || S(v.status) ? c(v) : l(a(\n      \"Request failed with status code \" + v.status,\n      v.config,\n      null,\n      v.request,\n      v\n    ));\n  }, settle;\n}\nvar cookies, hasRequiredCookies;\nfunction requireCookies() {\n  if (hasRequiredCookies)\n    return cookies;\n  hasRequiredCookies = 1;\n  var a = utils$9;\n  return cookies = a.isStandardBrowserEnv() ? (\n    // Standard browser envs support document.cookie\n    /* @__PURE__ */ function() {\n      return {\n        write: function(l, v, S, g, E, _) {\n          var k = [];\n          k.push(l + \"=\" + encodeURIComponent(v)), a.isNumber(S) && k.push(\"expires=\" + new Date(S).toGMTString()), a.isString(g) && k.push(\"path=\" + g), a.isString(E) && k.push(\"domain=\" + E), _ === !0 && k.push(\"secure\"), document.cookie = k.join(\"; \");\n        },\n        read: function(l) {\n          var v = document.cookie.match(new RegExp(\"(^|;\\\\s*)(\" + l + \")=([^;]*)\"));\n          return v ? decodeURIComponent(v[3]) : null;\n        },\n        remove: function(l) {\n          this.write(l, \"\", Date.now() - 864e5);\n        }\n      };\n    }()\n  ) : (\n    // Non standard browser env (web workers, react-native) lack needed support.\n    /* @__PURE__ */ function() {\n      return {\n        write: function() {\n        },\n        read: function() {\n          return null;\n        },\n        remove: function() {\n        }\n      };\n    }()\n  ), cookies;\n}\nvar isAbsoluteURL, hasRequiredIsAbsoluteURL;\nfunction requireIsAbsoluteURL() {\n  return hasRequiredIsAbsoluteURL || (hasRequiredIsAbsoluteURL = 1, isAbsoluteURL = function(u) {\n    return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(u);\n  }), isAbsoluteURL;\n}\nvar combineURLs, hasRequiredCombineURLs;\nfunction requireCombineURLs() {\n  return hasRequiredCombineURLs || (hasRequiredCombineURLs = 1, combineURLs = function(u, c) {\n    return c ? u.replace(/\\/+$/, \"\") + \"/\" + c.replace(/^\\/+/, \"\") : u;\n  }), combineURLs;\n}\nvar buildFullPath, hasRequiredBuildFullPath;\nfunction requireBuildFullPath() {\n  if (hasRequiredBuildFullPath)\n    return buildFullPath;\n  hasRequiredBuildFullPath = 1;\n  var a = requireIsAbsoluteURL(), u = requireCombineURLs();\n  return buildFullPath = function(l, v) {\n    return l && !a(v) ? u(l, v) : v;\n  }, buildFullPath;\n}\nvar parseHeaders, hasRequiredParseHeaders;\nfunction requireParseHeaders() {\n  if (hasRequiredParseHeaders)\n    return parseHeaders;\n  hasRequiredParseHeaders = 1;\n  var a = utils$9, u = [\n    \"age\",\n    \"authorization\",\n    \"content-length\",\n    \"content-type\",\n    \"etag\",\n    \"expires\",\n    \"from\",\n    \"host\",\n    \"if-modified-since\",\n    \"if-unmodified-since\",\n    \"last-modified\",\n    \"location\",\n    \"max-forwards\",\n    \"proxy-authorization\",\n    \"referer\",\n    \"retry-after\",\n    \"user-agent\"\n  ];\n  return parseHeaders = function(l) {\n    var v = {}, S, g, E;\n    return l && a.forEach(l.split(`\n`), function(k) {\n      if (E = k.indexOf(\":\"), S = a.trim(k.substr(0, E)).toLowerCase(), g = a.trim(k.substr(E + 1)), S) {\n        if (v[S] && u.indexOf(S) >= 0)\n          return;\n        S === \"set-cookie\" ? v[S] = (v[S] ? v[S] : []).concat([g]) : v[S] = v[S] ? v[S] + \", \" + g : g;\n      }\n    }), v;\n  }, parseHeaders;\n}\nvar isURLSameOrigin, hasRequiredIsURLSameOrigin;\nfunction requireIsURLSameOrigin() {\n  if (hasRequiredIsURLSameOrigin)\n    return isURLSameOrigin;\n  hasRequiredIsURLSameOrigin = 1;\n  var a = utils$9;\n  return isURLSameOrigin = a.isStandardBrowserEnv() ? (\n    // Standard browser envs have full support of the APIs needed to test\n    // whether the request URL is of the same origin as current location.\n    function() {\n      var c = /(msie|trident)/i.test(navigator.userAgent), l = document.createElement(\"a\"), v;\n      function S(g) {\n        var E = g;\n        return c && (l.setAttribute(\"href\", E), E = l.href), l.setAttribute(\"href\", E), {\n          href: l.href,\n          protocol: l.protocol ? l.protocol.replace(/:$/, \"\") : \"\",\n          host: l.host,\n          search: l.search ? l.search.replace(/^\\?/, \"\") : \"\",\n          hash: l.hash ? l.hash.replace(/^#/, \"\") : \"\",\n          hostname: l.hostname,\n          port: l.port,\n          pathname: l.pathname.charAt(0) === \"/\" ? l.pathname : \"/\" + l.pathname\n        };\n      }\n      return v = S(window.location.href), function(E) {\n        var _ = a.isString(E) ? S(E) : E;\n        return _.protocol === v.protocol && _.host === v.host;\n      };\n    }()\n  ) : (\n    // Non standard browser envs (web workers, react-native) lack needed support.\n    /* @__PURE__ */ function() {\n      return function() {\n        return !0;\n      };\n    }()\n  ), isURLSameOrigin;\n}\nvar xhr, hasRequiredXhr;\nfunction requireXhr() {\n  if (hasRequiredXhr)\n    return xhr;\n  hasRequiredXhr = 1;\n  var a = utils$9, u = requireSettle(), c = requireCookies(), l = buildURL$1, v = requireBuildFullPath(), S = requireParseHeaders(), g = requireIsURLSameOrigin(), E = requireCreateError();\n  return xhr = function(k) {\n    return new Promise(function(M, $) {\n      var J = k.data, V = k.headers, q = k.responseType;\n      a.isFormData(J) && delete V[\"Content-Type\"];\n      var G = new XMLHttpRequest();\n      if (k.auth) {\n        var H = k.auth.username || \"\", B = k.auth.password ? unescape(encodeURIComponent(k.auth.password)) : \"\";\n        V.Authorization = \"Basic \" + btoa(H + \":\" + B);\n      }\n      var Y = v(k.baseURL, k.url);\n      G.open(k.method.toUpperCase(), l(Y, k.params, k.paramsSerializer), !0), G.timeout = k.timeout;\n      function ne() {\n        if (G) {\n          var re = \"getAllResponseHeaders\" in G ? S(G.getAllResponseHeaders()) : null, oe = !q || q === \"text\" || q === \"json\" ? G.responseText : G.response, de = {\n            data: oe,\n            status: G.status,\n            statusText: G.statusText,\n            headers: re,\n            config: k,\n            request: G\n          };\n          u(M, $, de), G = null;\n        }\n      }\n      if (\"onloadend\" in G ? G.onloadend = ne : G.onreadystatechange = function() {\n        !G || G.readyState !== 4 || G.status === 0 && !(G.responseURL && G.responseURL.indexOf(\"file:\") === 0) || setTimeout(ne);\n      }, G.onabort = function() {\n        G && ($(E(\"Request aborted\", k, \"ECONNABORTED\", G)), G = null);\n      }, G.onerror = function() {\n        $(E(\"Network Error\", k, null, G)), G = null;\n      }, G.ontimeout = function() {\n        var oe = \"timeout of \" + k.timeout + \"ms exceeded\";\n        k.timeoutErrorMessage && (oe = k.timeoutErrorMessage), $(E(\n          oe,\n          k,\n          k.transitional && k.transitional.clarifyTimeoutError ? \"ETIMEDOUT\" : \"ECONNABORTED\",\n          G\n        )), G = null;\n      }, a.isStandardBrowserEnv()) {\n        var Z = (k.withCredentials || g(Y)) && k.xsrfCookieName ? c.read(k.xsrfCookieName) : void 0;\n        Z && (V[k.xsrfHeaderName] = Z);\n      }\n      \"setRequestHeader\" in G && a.forEach(V, function(oe, de) {\n        typeof J > \"u\" && de.toLowerCase() === \"content-type\" ? delete V[de] : G.setRequestHeader(de, oe);\n      }), a.isUndefined(k.withCredentials) || (G.withCredentials = !!k.withCredentials), q && q !== \"json\" && (G.responseType = k.responseType), typeof k.onDownloadProgress == \"function\" && G.addEventListener(\"progress\", k.onDownloadProgress), typeof k.onUploadProgress == \"function\" && G.upload && G.upload.addEventListener(\"progress\", k.onUploadProgress), k.cancelToken && k.cancelToken.promise.then(function(oe) {\n        G && (G.abort(), $(oe), G = null);\n      }), J || (J = null), G.send(J);\n    });\n  }, xhr;\n}\nvar utils$5 = utils$9, normalizeHeaderName = normalizeHeaderName$1, enhanceError = enhanceError$1, DEFAULT_CONTENT_TYPE = {\n  \"Content-Type\": \"application/x-www-form-urlencoded\"\n};\nfunction setContentTypeIfUnset(a, u) {\n  !utils$5.isUndefined(a) && utils$5.isUndefined(a[\"Content-Type\"]) && (a[\"Content-Type\"] = u);\n}\nfunction getDefaultAdapter() {\n  var a;\n  return (typeof XMLHttpRequest < \"u\" || typeof process < \"u\" && Object.prototype.toString.call(process) === \"[object process]\") && (a = requireXhr()), a;\n}\nfunction stringifySafely(a, u, c) {\n  if (utils$5.isString(a))\n    try {\n      return (u || JSON.parse)(a), utils$5.trim(a);\n    } catch (l) {\n      if (l.name !== \"SyntaxError\")\n        throw l;\n    }\n  return (c || JSON.stringify)(a);\n}\nvar defaults$3 = {\n  transitional: {\n    silentJSONParsing: !0,\n    forcedJSONParsing: !0,\n    clarifyTimeoutError: !1\n  },\n  adapter: getDefaultAdapter(),\n  transformRequest: [function a(u, c) {\n    return normalizeHeaderName(c, \"Accept\"), normalizeHeaderName(c, \"Content-Type\"), utils$5.isFormData(u) || utils$5.isArrayBuffer(u) || utils$5.isBuffer(u) || utils$5.isStream(u) || utils$5.isFile(u) || utils$5.isBlob(u) ? u : utils$5.isArrayBufferView(u) ? u.buffer : utils$5.isURLSearchParams(u) ? (setContentTypeIfUnset(c, \"application/x-www-form-urlencoded;charset=utf-8\"), u.toString()) : utils$5.isObject(u) || c && c[\"Content-Type\"] === \"application/json\" ? (setContentTypeIfUnset(c, \"application/json\"), stringifySafely(u)) : u;\n  }],\n  transformResponse: [function a(u) {\n    var c = this.transitional, l = c && c.silentJSONParsing, v = c && c.forcedJSONParsing, S = !l && this.responseType === \"json\";\n    if (S || v && utils$5.isString(u) && u.length)\n      try {\n        return JSON.parse(u);\n      } catch (g) {\n        if (S)\n          throw g.name === \"SyntaxError\" ? enhanceError(g, this, \"E_JSON_PARSE\") : g;\n      }\n    return u;\n  }],\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n  xsrfCookieName: \"XSRF-TOKEN\",\n  xsrfHeaderName: \"X-XSRF-TOKEN\",\n  maxContentLength: -1,\n  maxBodyLength: -1,\n  validateStatus: function a(u) {\n    return u >= 200 && u < 300;\n  }\n};\ndefaults$3.headers = {\n  common: {\n    Accept: \"application/json, text/plain, */*\"\n  }\n};\nutils$5.forEach([\"delete\", \"get\", \"head\"], function a(u) {\n  defaults$3.headers[u] = {};\n});\nutils$5.forEach([\"post\", \"put\", \"patch\"], function a(u) {\n  defaults$3.headers[u] = utils$5.merge(DEFAULT_CONTENT_TYPE);\n});\nvar defaults_1 = defaults$3, utils$4 = utils$9, defaults$2 = defaults_1, transformData$1 = function a(u, c, l) {\n  var v = this || defaults$2;\n  return utils$4.forEach(l, function(g) {\n    u = g.call(v, u, c);\n  }), u;\n}, isCancel$1, hasRequiredIsCancel;\nfunction requireIsCancel() {\n  return hasRequiredIsCancel || (hasRequiredIsCancel = 1, isCancel$1 = function(u) {\n    return !!(u && u.__CANCEL__);\n  }), isCancel$1;\n}\nvar utils$3 = utils$9, transformData = transformData$1, isCancel = requireIsCancel(), defaults$1 = defaults_1;\nfunction throwIfCancellationRequested(a) {\n  a.cancelToken && a.cancelToken.throwIfRequested();\n}\nvar dispatchRequest$1 = function a(u) {\n  throwIfCancellationRequested(u), u.headers = u.headers || {}, u.data = transformData.call(\n    u,\n    u.data,\n    u.headers,\n    u.transformRequest\n  ), u.headers = utils$3.merge(\n    u.headers.common || {},\n    u.headers[u.method] || {},\n    u.headers\n  ), utils$3.forEach(\n    [\"delete\", \"get\", \"head\", \"post\", \"put\", \"patch\", \"common\"],\n    function(v) {\n      delete u.headers[v];\n    }\n  );\n  var c = u.adapter || defaults$1.adapter;\n  return c(u).then(function(v) {\n    return throwIfCancellationRequested(u), v.data = transformData.call(\n      u,\n      v.data,\n      v.headers,\n      u.transformResponse\n    ), v;\n  }, function(v) {\n    return isCancel(v) || (throwIfCancellationRequested(u), v && v.response && (v.response.data = transformData.call(\n      u,\n      v.response.data,\n      v.response.headers,\n      u.transformResponse\n    ))), Promise.reject(v);\n  });\n}, utils$2 = utils$9, mergeConfig$2 = function a(u, c) {\n  c = c || {};\n  var l = {}, v = [\"url\", \"method\", \"data\"], S = [\"headers\", \"auth\", \"proxy\", \"params\"], g = [\n    \"baseURL\",\n    \"transformRequest\",\n    \"transformResponse\",\n    \"paramsSerializer\",\n    \"timeout\",\n    \"timeoutMessage\",\n    \"withCredentials\",\n    \"adapter\",\n    \"responseType\",\n    \"xsrfCookieName\",\n    \"xsrfHeaderName\",\n    \"onUploadProgress\",\n    \"onDownloadProgress\",\n    \"decompress\",\n    \"maxContentLength\",\n    \"maxBodyLength\",\n    \"maxRedirects\",\n    \"transport\",\n    \"httpAgent\",\n    \"httpsAgent\",\n    \"cancelToken\",\n    \"socketPath\",\n    \"responseEncoding\"\n  ], E = [\"validateStatus\"];\n  function _($, J) {\n    return utils$2.isPlainObject($) && utils$2.isPlainObject(J) ? utils$2.merge($, J) : utils$2.isPlainObject(J) ? utils$2.merge({}, J) : utils$2.isArray(J) ? J.slice() : J;\n  }\n  function k($) {\n    utils$2.isUndefined(c[$]) ? utils$2.isUndefined(u[$]) || (l[$] = _(void 0, u[$])) : l[$] = _(u[$], c[$]);\n  }\n  utils$2.forEach(v, function(J) {\n    utils$2.isUndefined(c[J]) || (l[J] = _(void 0, c[J]));\n  }), utils$2.forEach(S, k), utils$2.forEach(g, function(J) {\n    utils$2.isUndefined(c[J]) ? utils$2.isUndefined(u[J]) || (l[J] = _(void 0, u[J])) : l[J] = _(void 0, c[J]);\n  }), utils$2.forEach(E, function(J) {\n    J in c ? l[J] = _(u[J], c[J]) : J in u && (l[J] = _(void 0, u[J]));\n  });\n  var L = v.concat(S).concat(g).concat(E), M = Object.keys(u).concat(Object.keys(c)).filter(function(J) {\n    return L.indexOf(J) === -1;\n  });\n  return utils$2.forEach(M, k), l;\n};\nconst name = \"axios\", version$2 = \"0.21.4\", description = \"Promise based HTTP client for the browser and node.js\", main = \"index.js\", scripts = {\n  test: \"grunt test\",\n  start: \"node ./sandbox/server.js\",\n  build: \"NODE_ENV=production grunt build\",\n  preversion: \"npm test\",\n  version: \"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json\",\n  postversion: \"git push && git push --tags\",\n  examples: \"node ./examples/server.js\",\n  coveralls: \"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js\",\n  fix: \"eslint --fix lib/**/*.js\"\n}, repository = {\n  type: \"git\",\n  url: \"https://github.com/axios/axios.git\"\n}, keywords = [\n  \"xhr\",\n  \"http\",\n  \"ajax\",\n  \"promise\",\n  \"node\"\n], author = \"Matt Zabriskie\", license = \"MIT\", bugs = {\n  url: \"https://github.com/axios/axios/issues\"\n}, homepage = \"https://axios-http.com\", devDependencies = {\n  coveralls: \"^3.0.0\",\n  \"es6-promise\": \"^4.2.4\",\n  grunt: \"^1.3.0\",\n  \"grunt-banner\": \"^0.6.0\",\n  \"grunt-cli\": \"^1.2.0\",\n  \"grunt-contrib-clean\": \"^1.1.0\",\n  \"grunt-contrib-watch\": \"^1.0.0\",\n  \"grunt-eslint\": \"^23.0.0\",\n  \"grunt-karma\": \"^4.0.0\",\n  \"grunt-mocha-test\": \"^0.13.3\",\n  \"grunt-ts\": \"^6.0.0-beta.19\",\n  \"grunt-webpack\": \"^4.0.2\",\n  \"istanbul-instrumenter-loader\": \"^1.0.0\",\n  \"jasmine-core\": \"^2.4.1\",\n  karma: \"^6.3.2\",\n  \"karma-chrome-launcher\": \"^3.1.0\",\n  \"karma-firefox-launcher\": \"^2.1.0\",\n  \"karma-jasmine\": \"^1.1.1\",\n  \"karma-jasmine-ajax\": \"^0.1.13\",\n  \"karma-safari-launcher\": \"^1.0.0\",\n  \"karma-sauce-launcher\": \"^4.3.6\",\n  \"karma-sinon\": \"^1.0.5\",\n  \"karma-sourcemap-loader\": \"^0.3.8\",\n  \"karma-webpack\": \"^4.0.2\",\n  \"load-grunt-tasks\": \"^3.5.2\",\n  minimist: \"^1.2.0\",\n  mocha: \"^8.2.1\",\n  sinon: \"^4.5.0\",\n  \"terser-webpack-plugin\": \"^4.2.3\",\n  typescript: \"^4.0.5\",\n  \"url-search-params\": \"^0.10.0\",\n  webpack: \"^4.44.2\",\n  \"webpack-dev-server\": \"^3.11.0\"\n}, browser = {\n  \"./lib/adapters/http.js\": \"./lib/adapters/xhr.js\"\n}, jsdelivr = \"dist/axios.min.js\", unpkg = \"dist/axios.min.js\", typings = \"./index.d.ts\", dependencies = {\n  \"follow-redirects\": \"^1.14.0\"\n}, bundlesize = [\n  {\n    path: \"./dist/axios.min.js\",\n    threshold: \"5kB\"\n  }\n], require$$0 = {\n  name,\n  version: version$2,\n  description,\n  main,\n  scripts,\n  repository,\n  keywords,\n  author,\n  license,\n  bugs,\n  homepage,\n  devDependencies,\n  browser,\n  jsdelivr,\n  unpkg,\n  typings,\n  dependencies,\n  bundlesize\n};\nvar pkg = require$$0, validators$1 = {};\n[\"object\", \"boolean\", \"number\", \"function\", \"string\", \"symbol\"].forEach(function(a, u) {\n  validators$1[a] = function(l) {\n    return typeof l === a || \"a\" + (u < 1 ? \"n \" : \" \") + a;\n  };\n});\nvar deprecatedWarnings = {}, currentVerArr = pkg.version.split(\".\");\nfunction isOlderVersion(a, u) {\n  for (var c = u ? u.split(\".\") : currentVerArr, l = a.split(\".\"), v = 0; v < 3; v++) {\n    if (c[v] > l[v])\n      return !0;\n    if (c[v] < l[v])\n      return !1;\n  }\n  return !1;\n}\nvalidators$1.transitional = function a(u, c, l) {\n  var v = c && isOlderVersion(c);\n  function S(g, E) {\n    return \"[Axios v\" + pkg.version + \"] Transitional option '\" + g + \"'\" + E + (l ? \". \" + l : \"\");\n  }\n  return function(g, E, _) {\n    if (u === !1)\n      throw new Error(S(E, \" has been removed in \" + c));\n    return v && !deprecatedWarnings[E] && (deprecatedWarnings[E] = !0, console.warn(\n      S(\n        E,\n        \" has been deprecated since v\" + c + \" and will be removed in the near future\"\n      )\n    )), u ? u(g, E, _) : !0;\n  };\n};\nfunction assertOptions(a, u, c) {\n  if (typeof a != \"object\")\n    throw new TypeError(\"options must be an object\");\n  for (var l = Object.keys(a), v = l.length; v-- > 0; ) {\n    var S = l[v], g = u[S];\n    if (g) {\n      var E = a[S], _ = E === void 0 || g(E, S, a);\n      if (_ !== !0)\n        throw new TypeError(\"option \" + S + \" must be \" + _);\n      continue;\n    }\n    if (c !== !0)\n      throw Error(\"Unknown option \" + S);\n  }\n}\nvar validator$1 = {\n  isOlderVersion,\n  assertOptions,\n  validators: validators$1\n}, utils$1 = utils$9, buildURL = buildURL$1, InterceptorManager = InterceptorManager_1, dispatchRequest = dispatchRequest$1, mergeConfig$1 = mergeConfig$2, validator = validator$1, validators = validator.validators;\nfunction Axios$1(a) {\n  this.defaults = a, this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\nAxios$1.prototype.request = function a(u) {\n  typeof u == \"string\" ? (u = arguments[1] || {}, u.url = arguments[0]) : u = u || {}, u = mergeConfig$1(this.defaults, u), u.method ? u.method = u.method.toLowerCase() : this.defaults.method ? u.method = this.defaults.method.toLowerCase() : u.method = \"get\";\n  var c = u.transitional;\n  c !== void 0 && validator.assertOptions(c, {\n    silentJSONParsing: validators.transitional(validators.boolean, \"1.0.0\"),\n    forcedJSONParsing: validators.transitional(validators.boolean, \"1.0.0\"),\n    clarifyTimeoutError: validators.transitional(validators.boolean, \"1.0.0\")\n  }, !1);\n  var l = [], v = !0;\n  this.interceptors.request.forEach(function($) {\n    typeof $.runWhen == \"function\" && $.runWhen(u) === !1 || (v = v && $.synchronous, l.unshift($.fulfilled, $.rejected));\n  });\n  var S = [];\n  this.interceptors.response.forEach(function($) {\n    S.push($.fulfilled, $.rejected);\n  });\n  var g;\n  if (!v) {\n    var E = [dispatchRequest, void 0];\n    for (Array.prototype.unshift.apply(E, l), E = E.concat(S), g = Promise.resolve(u); E.length; )\n      g = g.then(E.shift(), E.shift());\n    return g;\n  }\n  for (var _ = u; l.length; ) {\n    var k = l.shift(), L = l.shift();\n    try {\n      _ = k(_);\n    } catch (M) {\n      L(M);\n      break;\n    }\n  }\n  try {\n    g = dispatchRequest(_);\n  } catch (M) {\n    return Promise.reject(M);\n  }\n  for (; S.length; )\n    g = g.then(S.shift(), S.shift());\n  return g;\n};\nAxios$1.prototype.getUri = function a(u) {\n  return u = mergeConfig$1(this.defaults, u), buildURL(u.url, u.params, u.paramsSerializer).replace(/^\\?/, \"\");\n};\nutils$1.forEach([\"delete\", \"get\", \"head\", \"options\"], function a(u) {\n  Axios$1.prototype[u] = function(c, l) {\n    return this.request(mergeConfig$1(l || {}, {\n      method: u,\n      url: c,\n      data: (l || {}).data\n    }));\n  };\n});\nutils$1.forEach([\"post\", \"put\", \"patch\"], function a(u) {\n  Axios$1.prototype[u] = function(c, l, v) {\n    return this.request(mergeConfig$1(v || {}, {\n      method: u,\n      url: c,\n      data: l\n    }));\n  };\n});\nvar Axios_1 = Axios$1, Cancel_1, hasRequiredCancel;\nfunction requireCancel() {\n  if (hasRequiredCancel)\n    return Cancel_1;\n  hasRequiredCancel = 1;\n  function a(u) {\n    this.message = u;\n  }\n  return a.prototype.toString = function() {\n    return \"Cancel\" + (this.message ? \": \" + this.message : \"\");\n  }, a.prototype.__CANCEL__ = !0, Cancel_1 = a, Cancel_1;\n}\nvar CancelToken_1, hasRequiredCancelToken;\nfunction requireCancelToken() {\n  if (hasRequiredCancelToken)\n    return CancelToken_1;\n  hasRequiredCancelToken = 1;\n  var a = requireCancel();\n  function u(c) {\n    if (typeof c != \"function\")\n      throw new TypeError(\"executor must be a function.\");\n    var l;\n    this.promise = new Promise(function(g) {\n      l = g;\n    });\n    var v = this;\n    c(function(g) {\n      v.reason || (v.reason = new a(g), l(v.reason));\n    });\n  }\n  return u.prototype.throwIfRequested = function() {\n    if (this.reason)\n      throw this.reason;\n  }, u.source = function() {\n    var l, v = new u(function(g) {\n      l = g;\n    });\n    return {\n      token: v,\n      cancel: l\n    };\n  }, CancelToken_1 = u, CancelToken_1;\n}\nvar spread, hasRequiredSpread;\nfunction requireSpread() {\n  return hasRequiredSpread || (hasRequiredSpread = 1, spread = function(u) {\n    return function(l) {\n      return u.apply(null, l);\n    };\n  }), spread;\n}\nvar isAxiosError, hasRequiredIsAxiosError;\nfunction requireIsAxiosError() {\n  return hasRequiredIsAxiosError || (hasRequiredIsAxiosError = 1, isAxiosError = function(u) {\n    return typeof u == \"object\" && u.isAxiosError === !0;\n  }), isAxiosError;\n}\nvar utils = utils$9, bind = bind$2, Axios = Axios_1, mergeConfig = mergeConfig$2, defaults = defaults_1;\nfunction createInstance(a) {\n  var u = new Axios(a), c = bind(Axios.prototype.request, u);\n  return utils.extend(c, Axios.prototype, u), utils.extend(c, u), c;\n}\nvar axios$1 = createInstance(defaults);\naxios$1.Axios = Axios;\naxios$1.create = function a(u) {\n  return createInstance(mergeConfig(axios$1.defaults, u));\n};\naxios$1.Cancel = requireCancel();\naxios$1.CancelToken = requireCancelToken();\naxios$1.isCancel = requireIsCancel();\naxios$1.all = function a(u) {\n  return Promise.all(u);\n};\naxios$1.spread = requireSpread();\naxios$1.isAxiosError = requireIsAxiosError();\naxios$2.exports = axios$1;\naxios$2.exports.default = axios$1;\nvar axiosExports = axios$2.exports, axios = axiosExports, mapObj$1 = { exports: {} };\nconst isObject$2 = (a) => typeof a == \"object\" && a !== null, mapObjectSkip = Symbol(\"skip\"), isObjectCustom = (a) => isObject$2(a) && !(a instanceof RegExp) && !(a instanceof Error) && !(a instanceof Date), mapObject = (a, u, c, l = /* @__PURE__ */ new WeakMap()) => {\n  if (c = {\n    deep: !1,\n    target: {},\n    ...c\n  }, l.has(a))\n    return l.get(a);\n  l.set(a, c.target);\n  const { target: v } = c;\n  delete c.target;\n  const S = (g) => g.map((E) => isObjectCustom(E) ? mapObject(E, u, c, l) : E);\n  if (Array.isArray(a))\n    return S(a);\n  for (const [g, E] of Object.entries(a)) {\n    const _ = u(g, E, a);\n    if (_ === mapObjectSkip)\n      continue;\n    let [k, L, { shouldRecurse: M = !0 } = {}] = _;\n    k !== \"__proto__\" && (c.deep && M && isObjectCustom(L) && (L = Array.isArray(L) ? S(L) : mapObject(L, u, c, l)), v[k] = L);\n  }\n  return v;\n};\nmapObj$1.exports = (a, u, c) => {\n  if (!isObject$2(a))\n    throw new TypeError(`Expected an object, got \\`${a}\\` (${typeof a})`);\n  return mapObject(a, u, c);\n};\nmapObj$1.exports.mapObjectSkip = mapObjectSkip;\nvar mapObjExports = mapObj$1.exports, camelcase = { exports: {} };\nconst UPPERCASE = /[\\p{Lu}]/u, LOWERCASE = /[\\p{Ll}]/u, LEADING_CAPITAL = /^[\\p{Lu}](?![\\p{Lu}])/gu, IDENTIFIER = /([\\p{Alpha}\\p{N}_]|$)/u, SEPARATORS = /[_.\\- ]+/, LEADING_SEPARATORS = new RegExp(\"^\" + SEPARATORS.source), SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, \"gu\"), NUMBERS_AND_IDENTIFIER = new RegExp(\"\\\\d+\" + IDENTIFIER.source, \"gu\"), preserveCamelCase = (a, u, c) => {\n  let l = !1, v = !1, S = !1;\n  for (let g = 0; g < a.length; g++) {\n    const E = a[g];\n    l && UPPERCASE.test(E) ? (a = a.slice(0, g) + \"-\" + a.slice(g), l = !1, S = v, v = !0, g++) : v && S && LOWERCASE.test(E) ? (a = a.slice(0, g - 1) + \"-\" + a.slice(g - 1), S = v, v = !1, l = !0) : (l = u(E) === E && c(E) !== E, S = v, v = c(E) === E && u(E) !== E);\n  }\n  return a;\n}, preserveConsecutiveUppercase = (a, u) => (LEADING_CAPITAL.lastIndex = 0, a.replace(LEADING_CAPITAL, (c) => u(c))), postProcess = (a, u) => (SEPARATORS_AND_IDENTIFIER.lastIndex = 0, NUMBERS_AND_IDENTIFIER.lastIndex = 0, a.replace(SEPARATORS_AND_IDENTIFIER, (c, l) => u(l)).replace(NUMBERS_AND_IDENTIFIER, (c) => u(c))), camelCase$1 = (a, u) => {\n  if (!(typeof a == \"string\" || Array.isArray(a)))\n    throw new TypeError(\"Expected the input to be `string | string[]`\");\n  if (u = {\n    pascalCase: !1,\n    preserveConsecutiveUppercase: !1,\n    ...u\n  }, Array.isArray(a) ? a = a.map((S) => S.trim()).filter((S) => S.length).join(\"-\") : a = a.trim(), a.length === 0)\n    return \"\";\n  const c = u.locale === !1 ? (S) => S.toLowerCase() : (S) => S.toLocaleLowerCase(u.locale), l = u.locale === !1 ? (S) => S.toUpperCase() : (S) => S.toLocaleUpperCase(u.locale);\n  return a.length === 1 ? u.pascalCase ? l(a) : c(a) : (a !== c(a) && (a = preserveCamelCase(a, c, l)), a = a.replace(LEADING_SEPARATORS, \"\"), u.preserveConsecutiveUppercase ? a = preserveConsecutiveUppercase(a, c) : a = c(a), u.pascalCase && (a = l(a.charAt(0)) + a.slice(1)), postProcess(a, l));\n};\ncamelcase.exports = camelCase$1;\ncamelcase.exports.default = camelCase$1;\nvar camelcaseExports = camelcase.exports;\nclass QuickLRU {\n  constructor(u = {}) {\n    if (!(u.maxSize && u.maxSize > 0))\n      throw new TypeError(\"`maxSize` must be a number greater than 0\");\n    this.maxSize = u.maxSize, this.onEviction = u.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;\n  }\n  _set(u, c) {\n    if (this.cache.set(u, c), this._size++, this._size >= this.maxSize) {\n      if (this._size = 0, typeof this.onEviction == \"function\")\n        for (const [l, v] of this.oldCache.entries())\n          this.onEviction(l, v);\n      this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map();\n    }\n  }\n  get(u) {\n    if (this.cache.has(u))\n      return this.cache.get(u);\n    if (this.oldCache.has(u)) {\n      const c = this.oldCache.get(u);\n      return this.oldCache.delete(u), this._set(u, c), c;\n    }\n  }\n  set(u, c) {\n    return this.cache.has(u) ? this.cache.set(u, c) : this._set(u, c), this;\n  }\n  has(u) {\n    return this.cache.has(u) || this.oldCache.has(u);\n  }\n  peek(u) {\n    if (this.cache.has(u))\n      return this.cache.get(u);\n    if (this.oldCache.has(u))\n      return this.oldCache.get(u);\n  }\n  delete(u) {\n    const c = this.cache.delete(u);\n    return c && this._size--, this.oldCache.delete(u) || c;\n  }\n  clear() {\n    this.cache.clear(), this.oldCache.clear(), this._size = 0;\n  }\n  *keys() {\n    for (const [u] of this)\n      yield u;\n  }\n  *values() {\n    for (const [, u] of this)\n      yield u;\n  }\n  *[Symbol.iterator]() {\n    for (const u of this.cache)\n      yield u;\n    for (const u of this.oldCache) {\n      const [c] = u;\n      this.cache.has(c) || (yield u);\n    }\n  }\n  get size() {\n    let u = 0;\n    for (const c of this.oldCache.keys())\n      this.cache.has(c) || u++;\n    return Math.min(this._size + u, this.maxSize);\n  }\n}\nvar quickLru = QuickLRU;\nconst mapObj = mapObjExports, camelCase = camelcaseExports, QuickLru = quickLru, has$1 = (a, u) => a.some((c) => typeof c == \"string\" ? c === u : (c.lastIndex = 0, c.test(u))), cache$1 = new QuickLru({ maxSize: 1e5 }), isObject$1 = (a) => typeof a == \"object\" && a !== null && !(a instanceof RegExp) && !(a instanceof Error) && !(a instanceof Date), camelCaseConvert = (a, u) => {\n  if (!isObject$1(a))\n    return a;\n  u = {\n    deep: !1,\n    pascalCase: !1,\n    ...u\n  };\n  const { exclude: c, pascalCase: l, stopPaths: v, deep: S } = u, g = new Set(v), E = (_) => (k, L) => {\n    if (S && isObject$1(L)) {\n      const M = _ === void 0 ? k : `${_}.${k}`;\n      g.has(M) || (L = mapObj(L, E(M)));\n    }\n    if (!(c && has$1(c, k))) {\n      const M = l ? `${k}_` : k;\n      if (cache$1.has(M))\n        k = cache$1.get(M);\n      else {\n        const $ = camelCase(k, { pascalCase: l, locale: !1 });\n        k.length < 100 && cache$1.set(M, $), k = $;\n      }\n    }\n    return [k, L];\n  };\n  return mapObj(a, E(void 0));\n};\nvar camelcaseKeys = (a, u) => Array.isArray(a) ? Object.keys(a).map((c) => camelCaseConvert(a[c], u)) : camelCaseConvert(a, u), __importDefault$6 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(TwirpRPC, \"__esModule\", { value: !0 });\nTwirpRPC.TwirpRpc = TwirpRPC.livekitPackage = void 0;\nconst axios_1 = __importDefault$6(axios), camelcase_keys_1 = __importDefault$6(camelcaseKeys), defaultPrefix = \"/twirp\";\nTwirpRPC.livekitPackage = \"livekit\";\nclass TwirpRpc {\n  constructor(u, c, l, v) {\n    this.host = u, this.pkg = c, this.prefix = l || defaultPrefix, this.instance = axios_1.default.create({\n      baseURL: u,\n      headers: Object.assign({}, v ? { Host: v } : {})\n    });\n  }\n  request(u, c, l, v) {\n    return new Promise((S, g) => {\n      const E = `${this.prefix}/${this.pkg}.${u}/${c}`;\n      this.instance.post(E, l, { headers: v }).then((_) => {\n        S(camelcase_keys_1.default(_.data, { deep: !0 }));\n      }).catch(g);\n    });\n  }\n}\nTwirpRPC.TwirpRpc = TwirpRpc;\nvar __awaiter$3 = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {\n  function v(S) {\n    return S instanceof c ? S : new c(function(g) {\n      g(S);\n    });\n  }\n  return new (c || (c = Promise))(function(S, g) {\n    function E(L) {\n      try {\n        k(l.next(L));\n      } catch (M) {\n        g(M);\n      }\n    }\n    function _(L) {\n      try {\n        k(l.throw(L));\n      } catch (M) {\n        g(M);\n      }\n    }\n    function k(L) {\n      L.done ? S(L.value) : v(L.value).then(E, _);\n    }\n    k((l = l.apply(a, u || [])).next());\n  });\n}, __importDefault$5 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(EgressClient$1, \"__esModule\", { value: !0 });\nEgressClient$1.EgressClient = void 0;\nconst livekit_egress_1$1 = livekit_egress, ServiceBase_1$2 = __importDefault$5(ServiceBase$1), TwirpRPC_1$2 = TwirpRPC, svc$2 = \"Egress\";\nclass EgressClient extends ServiceBase_1$2.default {\n  /**\n   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'\n   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY\n   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET\n   */\n  constructor(u, c, l) {\n    super(c, l), this.rpc = new TwirpRPC_1$2.TwirpRpc(u, TwirpRPC_1$2.livekitPackage);\n  }\n  startRoomCompositeEgress(u, c, l, v, S, g, E) {\n    return __awaiter$3(this, void 0, void 0, function* () {\n      let _;\n      if (l !== void 0)\n        if (typeof l == \"string\")\n          _ = l;\n        else {\n          const G = l;\n          _ = G.layout, v = G.encodingOptions, S = G.audioOnly, g = G.videoOnly, E = G.customBaseUrl;\n        }\n      _ ?? (_ = \"\"), S ?? (S = !1), g ?? (g = !1), E ?? (E = \"\");\n      const { file: k, segments: L, stream: M, preset: $, advanced: J } = this.getOutputParams(c, v), V = livekit_egress_1$1.RoomCompositeEgressRequest.toJSON({\n        roomName: u,\n        layout: _,\n        audioOnly: S,\n        videoOnly: g,\n        customBaseUrl: E,\n        file: k,\n        stream: M,\n        segments: L,\n        preset: $,\n        advanced: J\n      }), q = yield this.rpc.request(svc$2, \"StartRoomCompositeEgress\", V, this.authHeader({ roomRecord: !0 }));\n      return livekit_egress_1$1.EgressInfo.fromJSON(q);\n    });\n  }\n  /**\n   * @param url url\n   * @param output file or stream output\n   * @param opts WebOptions\n   */\n  startWebEgress(u, c, l) {\n    return __awaiter$3(this, void 0, void 0, function* () {\n      const v = (l == null ? void 0 : l.audioOnly) || !1, S = (l == null ? void 0 : l.videoOnly) || !1, { file: g, segments: E, stream: _, preset: k, advanced: L } = this.getOutputParams(c, l == null ? void 0 : l.encodingOptions), M = livekit_egress_1$1.WebEgressRequest.toJSON({\n        url: u,\n        audioOnly: v,\n        videoOnly: S,\n        file: g,\n        stream: _,\n        segments: E,\n        preset: k,\n        advanced: L\n      }), $ = yield this.rpc.request(svc$2, \"StartWebEgress\", M, this.authHeader({ roomRecord: !0 }));\n      return livekit_egress_1$1.EgressInfo.fromJSON($);\n    });\n  }\n  startTrackCompositeEgress(u, c, l, v, S) {\n    return __awaiter$3(this, void 0, void 0, function* () {\n      let g;\n      if (l !== void 0)\n        if (typeof l == \"string\")\n          g = l;\n        else {\n          const V = l;\n          g = V.audioTrackId, v = V.videoTrackId, S = V.encodingOptions;\n        }\n      g ?? (g = \"\"), v ?? (v = \"\");\n      const { file: E, segments: _, stream: k, preset: L, advanced: M } = this.getOutputParams(c, S), $ = livekit_egress_1$1.TrackCompositeEgressRequest.toJSON({\n        roomName: u,\n        audioTrackId: g,\n        videoTrackId: v,\n        file: E,\n        stream: k,\n        segments: _,\n        preset: L,\n        advanced: M\n      }), J = yield this.rpc.request(svc$2, \"StartTrackCompositeEgress\", $, this.authHeader({ roomRecord: !0 }));\n      return livekit_egress_1$1.EgressInfo.fromJSON(J);\n    });\n  }\n  getOutputParams(u, c) {\n    let l, v, S, g, E;\n    return u.filepath !== void 0 ? l = u : u.filenamePrefix !== void 0 ? S = u : v = u, c && (typeof c == \"number\" ? g = c : E = c), { file: l, segments: S, stream: v, preset: g, advanced: E };\n  }\n  /**\n   * @param roomName room name\n   * @param output file or websocket output\n   * @param trackId track Id\n   */\n  startTrackEgress(u, c, l) {\n    return __awaiter$3(this, void 0, void 0, function* () {\n      let v, S;\n      c.filepath !== void 0 ? v = c : S = c;\n      const g = livekit_egress_1$1.TrackEgressRequest.toJSON({\n        roomName: u,\n        trackId: l,\n        file: v,\n        websocketUrl: S\n      }), E = yield this.rpc.request(svc$2, \"StartTrackEgress\", g, this.authHeader({ roomRecord: !0 }));\n      return livekit_egress_1$1.EgressInfo.fromJSON(E);\n    });\n  }\n  /**\n   * @param egressId\n   * @param layout\n   */\n  updateLayout(u, c) {\n    return __awaiter$3(this, void 0, void 0, function* () {\n      const l = yield this.rpc.request(svc$2, \"UpdateLayout\", livekit_egress_1$1.UpdateLayoutRequest.toJSON({ egressId: u, layout: c }), this.authHeader({ roomRecord: !0 }));\n      return livekit_egress_1$1.EgressInfo.fromJSON(l);\n    });\n  }\n  /**\n   * @param egressId\n   * @param addOutputUrls\n   * @param removeOutputUrls\n   */\n  updateStream(u, c, l) {\n    return __awaiter$3(this, void 0, void 0, function* () {\n      c ?? (c = []), l ?? (l = []);\n      const v = yield this.rpc.request(svc$2, \"UpdateStream\", livekit_egress_1$1.UpdateStreamRequest.toJSON({ egressId: u, addOutputUrls: c, removeOutputUrls: l }), this.authHeader({ roomRecord: !0 }));\n      return livekit_egress_1$1.EgressInfo.fromJSON(v);\n    });\n  }\n  /**\n   * @param roomName list egress for one room only\n   */\n  listEgress(u) {\n    var c;\n    return __awaiter$3(this, void 0, void 0, function* () {\n      u ?? (u = \"\");\n      const l = yield this.rpc.request(svc$2, \"ListEgress\", livekit_egress_1$1.ListEgressRequest.toJSON({ roomName: u }), this.authHeader({ roomRecord: !0 }));\n      return (c = livekit_egress_1$1.ListEgressResponse.fromJSON(l).items) !== null && c !== void 0 ? c : [];\n    });\n  }\n  /**\n   * @param egressId\n   */\n  stopEgress(u) {\n    return __awaiter$3(this, void 0, void 0, function* () {\n      const c = yield this.rpc.request(svc$2, \"StopEgress\", livekit_egress_1$1.StopEgressRequest.toJSON({ egressId: u }), this.authHeader({ roomRecord: !0 }));\n      return livekit_egress_1$1.EgressInfo.fromJSON(c);\n    });\n  }\n}\nEgressClient$1.EgressClient = EgressClient;\nvar grants = {};\nObject.defineProperty(grants, \"__esModule\", { value: !0 });\nvar IngressClient$1 = {}, livekit_ingress = {}, livekit_models = {}, timestamp = {}, __importDefault$4 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(timestamp, \"__esModule\", { value: !0 });\ntimestamp.Timestamp = timestamp.protobufPackage = void 0;\nconst long_1$1 = __importDefault$4(umdExports), minimal_1$1 = __importDefault$4(minimal);\ntimestamp.protobufPackage = \"google.protobuf\";\nfunction createBaseTimestamp() {\n  return { seconds: 0, nanos: 0 };\n}\ntimestamp.Timestamp = {\n  encode(a, u = minimal_1$1.default.Writer.create()) {\n    return a.seconds !== 0 && u.uint32(8).int64(a.seconds), a.nanos !== 0 && u.uint32(16).int32(a.nanos), u;\n  },\n  decode(a, u) {\n    const c = a instanceof minimal_1$1.default.Reader ? a : new minimal_1$1.default.Reader(a);\n    let l = u === void 0 ? c.len : c.pos + u;\n    const v = createBaseTimestamp();\n    for (; c.pos < l; ) {\n      const S = c.uint32();\n      switch (S >>> 3) {\n        case 1:\n          v.seconds = longToNumber$1(c.int64());\n          break;\n        case 2:\n          v.nanos = c.int32();\n          break;\n        default:\n          c.skipType(S & 7);\n          break;\n      }\n    }\n    return v;\n  },\n  fromJSON(a) {\n    return {\n      seconds: isSet$1(a.seconds) ? Number(a.seconds) : 0,\n      nanos: isSet$1(a.nanos) ? Number(a.nanos) : 0\n    };\n  },\n  toJSON(a) {\n    const u = {};\n    return a.seconds !== void 0 && (u.seconds = Math.round(a.seconds)), a.nanos !== void 0 && (u.nanos = Math.round(a.nanos)), u;\n  },\n  fromPartial(a) {\n    var u, c;\n    const l = createBaseTimestamp();\n    return l.seconds = (u = a.seconds) !== null && u !== void 0 ? u : 0, l.nanos = (c = a.nanos) !== null && c !== void 0 ? c : 0, l;\n  }\n};\nvar globalThis$2 = (() => {\n  if (typeof globalThis$2 < \"u\")\n    return globalThis$2;\n  if (typeof self < \"u\")\n    return self;\n  if (typeof window < \"u\")\n    return window;\n  if (typeof commonjsGlobal$1 < \"u\")\n    return commonjsGlobal$1;\n  throw \"Unable to locate global object\";\n})();\nfunction longToNumber$1(a) {\n  if (a.gt(Number.MAX_SAFE_INTEGER))\n    throw new globalThis$2.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  return a.toNumber();\n}\nminimal_1$1.default.util.Long !== long_1$1.default && (minimal_1$1.default.util.Long = long_1$1.default, minimal_1$1.default.configure());\nfunction isSet$1(a) {\n  return a != null;\n}\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(O) {\n    return O && O.__esModule ? O : { default: O };\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.RTPStats_GapHistogramEntry = a.RTPStats = a.DisabledCodecs = a.VideoConfiguration = a.ClientConfiguration = a.ClientInfo = a.ServerInfo = a.ParticipantTracks = a.UserPacket = a.SpeakerInfo = a.ActiveSpeakerUpdate = a.DataPacket = a.VideoLayer = a.TrackInfo = a.SimulcastCodecInfo = a.ParticipantInfo = a.ParticipantPermission = a.Codec = a.Room = a.clientInfo_SDKToJSON = a.clientInfo_SDKFromJSON = a.ClientInfo_SDK = a.serverInfo_EditionToJSON = a.serverInfo_EditionFromJSON = a.ServerInfo_Edition = a.dataPacket_KindToJSON = a.dataPacket_KindFromJSON = a.DataPacket_Kind = a.participantInfo_StateToJSON = a.participantInfo_StateFromJSON = a.ParticipantInfo_State = a.disconnectReasonToJSON = a.disconnectReasonFromJSON = a.DisconnectReason = a.clientConfigSettingToJSON = a.clientConfigSettingFromJSON = a.ClientConfigSetting = a.connectionQualityToJSON = a.connectionQualityFromJSON = a.ConnectionQuality = a.videoQualityToJSON = a.videoQualityFromJSON = a.VideoQuality = a.trackSourceToJSON = a.trackSourceFromJSON = a.TrackSource = a.trackTypeToJSON = a.trackTypeFromJSON = a.TrackType = a.protobufPackage = void 0, a.TimedVersion = void 0;\n  const c = u(umdExports), l = u(minimal), v = timestamp;\n  a.protobufPackage = \"livekit\";\n  var S;\n  (function(O) {\n    O[O.AUDIO = 0] = \"AUDIO\", O[O.VIDEO = 1] = \"VIDEO\", O[O.DATA = 2] = \"DATA\", O[O.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(S = a.TrackType || (a.TrackType = {}));\n  function g(O) {\n    switch (O) {\n      case 0:\n      case \"AUDIO\":\n        return S.AUDIO;\n      case 1:\n      case \"VIDEO\":\n        return S.VIDEO;\n      case 2:\n      case \"DATA\":\n        return S.DATA;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return S.UNRECOGNIZED;\n    }\n  }\n  a.trackTypeFromJSON = g;\n  function E(O) {\n    switch (O) {\n      case S.AUDIO:\n        return \"AUDIO\";\n      case S.VIDEO:\n        return \"VIDEO\";\n      case S.DATA:\n        return \"DATA\";\n      case S.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.trackTypeToJSON = E;\n  var _;\n  (function(O) {\n    O[O.UNKNOWN = 0] = \"UNKNOWN\", O[O.CAMERA = 1] = \"CAMERA\", O[O.MICROPHONE = 2] = \"MICROPHONE\", O[O.SCREEN_SHARE = 3] = \"SCREEN_SHARE\", O[O.SCREEN_SHARE_AUDIO = 4] = \"SCREEN_SHARE_AUDIO\", O[O.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(_ = a.TrackSource || (a.TrackSource = {}));\n  function k(O) {\n    switch (O) {\n      case 0:\n      case \"UNKNOWN\":\n        return _.UNKNOWN;\n      case 1:\n      case \"CAMERA\":\n        return _.CAMERA;\n      case 2:\n      case \"MICROPHONE\":\n        return _.MICROPHONE;\n      case 3:\n      case \"SCREEN_SHARE\":\n        return _.SCREEN_SHARE;\n      case 4:\n      case \"SCREEN_SHARE_AUDIO\":\n        return _.SCREEN_SHARE_AUDIO;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return _.UNRECOGNIZED;\n    }\n  }\n  a.trackSourceFromJSON = k;\n  function L(O) {\n    switch (O) {\n      case _.UNKNOWN:\n        return \"UNKNOWN\";\n      case _.CAMERA:\n        return \"CAMERA\";\n      case _.MICROPHONE:\n        return \"MICROPHONE\";\n      case _.SCREEN_SHARE:\n        return \"SCREEN_SHARE\";\n      case _.SCREEN_SHARE_AUDIO:\n        return \"SCREEN_SHARE_AUDIO\";\n      case _.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.trackSourceToJSON = L;\n  var M;\n  (function(O) {\n    O[O.LOW = 0] = \"LOW\", O[O.MEDIUM = 1] = \"MEDIUM\", O[O.HIGH = 2] = \"HIGH\", O[O.OFF = 3] = \"OFF\", O[O.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(M = a.VideoQuality || (a.VideoQuality = {}));\n  function $(O) {\n    switch (O) {\n      case 0:\n      case \"LOW\":\n        return M.LOW;\n      case 1:\n      case \"MEDIUM\":\n        return M.MEDIUM;\n      case 2:\n      case \"HIGH\":\n        return M.HIGH;\n      case 3:\n      case \"OFF\":\n        return M.OFF;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return M.UNRECOGNIZED;\n    }\n  }\n  a.videoQualityFromJSON = $;\n  function J(O) {\n    switch (O) {\n      case M.LOW:\n        return \"LOW\";\n      case M.MEDIUM:\n        return \"MEDIUM\";\n      case M.HIGH:\n        return \"HIGH\";\n      case M.OFF:\n        return \"OFF\";\n      case M.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.videoQualityToJSON = J;\n  var V;\n  (function(O) {\n    O[O.POOR = 0] = \"POOR\", O[O.GOOD = 1] = \"GOOD\", O[O.EXCELLENT = 2] = \"EXCELLENT\", O[O.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(V = a.ConnectionQuality || (a.ConnectionQuality = {}));\n  function q(O) {\n    switch (O) {\n      case 0:\n      case \"POOR\":\n        return V.POOR;\n      case 1:\n      case \"GOOD\":\n        return V.GOOD;\n      case 2:\n      case \"EXCELLENT\":\n        return V.EXCELLENT;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return V.UNRECOGNIZED;\n    }\n  }\n  a.connectionQualityFromJSON = q;\n  function G(O) {\n    switch (O) {\n      case V.POOR:\n        return \"POOR\";\n      case V.GOOD:\n        return \"GOOD\";\n      case V.EXCELLENT:\n        return \"EXCELLENT\";\n      case V.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.connectionQualityToJSON = G;\n  var H;\n  (function(O) {\n    O[O.UNSET = 0] = \"UNSET\", O[O.DISABLED = 1] = \"DISABLED\", O[O.ENABLED = 2] = \"ENABLED\", O[O.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(H = a.ClientConfigSetting || (a.ClientConfigSetting = {}));\n  function B(O) {\n    switch (O) {\n      case 0:\n      case \"UNSET\":\n        return H.UNSET;\n      case 1:\n      case \"DISABLED\":\n        return H.DISABLED;\n      case 2:\n      case \"ENABLED\":\n        return H.ENABLED;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return H.UNRECOGNIZED;\n    }\n  }\n  a.clientConfigSettingFromJSON = B;\n  function Y(O) {\n    switch (O) {\n      case H.UNSET:\n        return \"UNSET\";\n      case H.DISABLED:\n        return \"DISABLED\";\n      case H.ENABLED:\n        return \"ENABLED\";\n      case H.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.clientConfigSettingToJSON = Y;\n  var ne;\n  (function(O) {\n    O[O.UNKNOWN_REASON = 0] = \"UNKNOWN_REASON\", O[O.CLIENT_INITIATED = 1] = \"CLIENT_INITIATED\", O[O.DUPLICATE_IDENTITY = 2] = \"DUPLICATE_IDENTITY\", O[O.SERVER_SHUTDOWN = 3] = \"SERVER_SHUTDOWN\", O[O.PARTICIPANT_REMOVED = 4] = \"PARTICIPANT_REMOVED\", O[O.ROOM_DELETED = 5] = \"ROOM_DELETED\", O[O.STATE_MISMATCH = 6] = \"STATE_MISMATCH\", O[O.JOIN_FAILURE = 7] = \"JOIN_FAILURE\", O[O.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(ne = a.DisconnectReason || (a.DisconnectReason = {}));\n  function Z(O) {\n    switch (O) {\n      case 0:\n      case \"UNKNOWN_REASON\":\n        return ne.UNKNOWN_REASON;\n      case 1:\n      case \"CLIENT_INITIATED\":\n        return ne.CLIENT_INITIATED;\n      case 2:\n      case \"DUPLICATE_IDENTITY\":\n        return ne.DUPLICATE_IDENTITY;\n      case 3:\n      case \"SERVER_SHUTDOWN\":\n        return ne.SERVER_SHUTDOWN;\n      case 4:\n      case \"PARTICIPANT_REMOVED\":\n        return ne.PARTICIPANT_REMOVED;\n      case 5:\n      case \"ROOM_DELETED\":\n        return ne.ROOM_DELETED;\n      case 6:\n      case \"STATE_MISMATCH\":\n        return ne.STATE_MISMATCH;\n      case 7:\n      case \"JOIN_FAILURE\":\n        return ne.JOIN_FAILURE;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return ne.UNRECOGNIZED;\n    }\n  }\n  a.disconnectReasonFromJSON = Z;\n  function re(O) {\n    switch (O) {\n      case ne.UNKNOWN_REASON:\n        return \"UNKNOWN_REASON\";\n      case ne.CLIENT_INITIATED:\n        return \"CLIENT_INITIATED\";\n      case ne.DUPLICATE_IDENTITY:\n        return \"DUPLICATE_IDENTITY\";\n      case ne.SERVER_SHUTDOWN:\n        return \"SERVER_SHUTDOWN\";\n      case ne.PARTICIPANT_REMOVED:\n        return \"PARTICIPANT_REMOVED\";\n      case ne.ROOM_DELETED:\n        return \"ROOM_DELETED\";\n      case ne.STATE_MISMATCH:\n        return \"STATE_MISMATCH\";\n      case ne.JOIN_FAILURE:\n        return \"JOIN_FAILURE\";\n      case ne.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.disconnectReasonToJSON = re;\n  var oe;\n  (function(O) {\n    O[O.JOINING = 0] = \"JOINING\", O[O.JOINED = 1] = \"JOINED\", O[O.ACTIVE = 2] = \"ACTIVE\", O[O.DISCONNECTED = 3] = \"DISCONNECTED\", O[O.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(oe = a.ParticipantInfo_State || (a.ParticipantInfo_State = {}));\n  function de(O) {\n    switch (O) {\n      case 0:\n      case \"JOINING\":\n        return oe.JOINING;\n      case 1:\n      case \"JOINED\":\n        return oe.JOINED;\n      case 2:\n      case \"ACTIVE\":\n        return oe.ACTIVE;\n      case 3:\n      case \"DISCONNECTED\":\n        return oe.DISCONNECTED;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return oe.UNRECOGNIZED;\n    }\n  }\n  a.participantInfo_StateFromJSON = de;\n  function A(O) {\n    switch (O) {\n      case oe.JOINING:\n        return \"JOINING\";\n      case oe.JOINED:\n        return \"JOINED\";\n      case oe.ACTIVE:\n        return \"ACTIVE\";\n      case oe.DISCONNECTED:\n        return \"DISCONNECTED\";\n      case oe.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.participantInfo_StateToJSON = A;\n  var N;\n  (function(O) {\n    O[O.RELIABLE = 0] = \"RELIABLE\", O[O.LOSSY = 1] = \"LOSSY\", O[O.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(N = a.DataPacket_Kind || (a.DataPacket_Kind = {}));\n  function D(O) {\n    switch (O) {\n      case 0:\n      case \"RELIABLE\":\n        return N.RELIABLE;\n      case 1:\n      case \"LOSSY\":\n        return N.LOSSY;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return N.UNRECOGNIZED;\n    }\n  }\n  a.dataPacket_KindFromJSON = D;\n  function W(O) {\n    switch (O) {\n      case N.RELIABLE:\n        return \"RELIABLE\";\n      case N.LOSSY:\n        return \"LOSSY\";\n      case N.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.dataPacket_KindToJSON = W;\n  var ee;\n  (function(O) {\n    O[O.Standard = 0] = \"Standard\", O[O.Cloud = 1] = \"Cloud\", O[O.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(ee = a.ServerInfo_Edition || (a.ServerInfo_Edition = {}));\n  function ae(O) {\n    switch (O) {\n      case 0:\n      case \"Standard\":\n        return ee.Standard;\n      case 1:\n      case \"Cloud\":\n        return ee.Cloud;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return ee.UNRECOGNIZED;\n    }\n  }\n  a.serverInfo_EditionFromJSON = ae;\n  function ye(O) {\n    switch (O) {\n      case ee.Standard:\n        return \"Standard\";\n      case ee.Cloud:\n        return \"Cloud\";\n      case ee.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.serverInfo_EditionToJSON = ye;\n  var he;\n  (function(O) {\n    O[O.UNKNOWN = 0] = \"UNKNOWN\", O[O.JS = 1] = \"JS\", O[O.SWIFT = 2] = \"SWIFT\", O[O.ANDROID = 3] = \"ANDROID\", O[O.FLUTTER = 4] = \"FLUTTER\", O[O.GO = 5] = \"GO\", O[O.UNITY = 6] = \"UNITY\", O[O.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(he = a.ClientInfo_SDK || (a.ClientInfo_SDK = {}));\n  function le(O) {\n    switch (O) {\n      case 0:\n      case \"UNKNOWN\":\n        return he.UNKNOWN;\n      case 1:\n      case \"JS\":\n        return he.JS;\n      case 2:\n      case \"SWIFT\":\n        return he.SWIFT;\n      case 3:\n      case \"ANDROID\":\n        return he.ANDROID;\n      case 4:\n      case \"FLUTTER\":\n        return he.FLUTTER;\n      case 5:\n      case \"GO\":\n        return he.GO;\n      case 6:\n      case \"UNITY\":\n        return he.UNITY;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return he.UNRECOGNIZED;\n    }\n  }\n  a.clientInfo_SDKFromJSON = le;\n  function we(O) {\n    switch (O) {\n      case he.UNKNOWN:\n        return \"UNKNOWN\";\n      case he.JS:\n        return \"JS\";\n      case he.SWIFT:\n        return \"SWIFT\";\n      case he.ANDROID:\n        return \"ANDROID\";\n      case he.FLUTTER:\n        return \"FLUTTER\";\n      case he.GO:\n        return \"GO\";\n      case he.UNITY:\n        return \"UNITY\";\n      case he.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.clientInfo_SDKToJSON = we;\n  function Be() {\n    return {\n      sid: \"\",\n      name: \"\",\n      emptyTimeout: 0,\n      maxParticipants: 0,\n      creationTime: 0,\n      turnPassword: \"\",\n      enabledCodecs: [],\n      metadata: \"\",\n      numParticipants: 0,\n      activeRecording: !1\n    };\n  }\n  a.Room = {\n    encode(O, j = l.default.Writer.create()) {\n      O.sid !== \"\" && j.uint32(10).string(O.sid), O.name !== \"\" && j.uint32(18).string(O.name), O.emptyTimeout !== 0 && j.uint32(24).uint32(O.emptyTimeout), O.maxParticipants !== 0 && j.uint32(32).uint32(O.maxParticipants), O.creationTime !== 0 && j.uint32(40).int64(O.creationTime), O.turnPassword !== \"\" && j.uint32(50).string(O.turnPassword);\n      for (const se of O.enabledCodecs)\n        a.Codec.encode(se, j.uint32(58).fork()).ldelim();\n      return O.metadata !== \"\" && j.uint32(66).string(O.metadata), O.numParticipants !== 0 && j.uint32(72).uint32(O.numParticipants), O.activeRecording === !0 && j.uint32(80).bool(O.activeRecording), j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = Be();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.sid = se.string();\n            break;\n          case 2:\n            ve.name = se.string();\n            break;\n          case 3:\n            ve.emptyTimeout = se.uint32();\n            break;\n          case 4:\n            ve.maxParticipants = se.uint32();\n            break;\n          case 5:\n            ve.creationTime = ie(se.int64());\n            break;\n          case 6:\n            ve.turnPassword = se.string();\n            break;\n          case 7:\n            ve.enabledCodecs.push(a.Codec.decode(se, se.uint32()));\n            break;\n          case 8:\n            ve.metadata = se.string();\n            break;\n          case 9:\n            ve.numParticipants = se.uint32();\n            break;\n          case 10:\n            ve.activeRecording = se.bool();\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        sid: ue(O.sid) ? String(O.sid) : \"\",\n        name: ue(O.name) ? String(O.name) : \"\",\n        emptyTimeout: ue(O.emptyTimeout) ? Number(O.emptyTimeout) : 0,\n        maxParticipants: ue(O.maxParticipants) ? Number(O.maxParticipants) : 0,\n        creationTime: ue(O.creationTime) ? Number(O.creationTime) : 0,\n        turnPassword: ue(O.turnPassword) ? String(O.turnPassword) : \"\",\n        enabledCodecs: Array.isArray(O == null ? void 0 : O.enabledCodecs) ? O.enabledCodecs.map((j) => a.Codec.fromJSON(j)) : [],\n        metadata: ue(O.metadata) ? String(O.metadata) : \"\",\n        numParticipants: ue(O.numParticipants) ? Number(O.numParticipants) : 0,\n        activeRecording: ue(O.activeRecording) ? !!O.activeRecording : !1\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.sid !== void 0 && (j.sid = O.sid), O.name !== void 0 && (j.name = O.name), O.emptyTimeout !== void 0 && (j.emptyTimeout = Math.round(O.emptyTimeout)), O.maxParticipants !== void 0 && (j.maxParticipants = Math.round(O.maxParticipants)), O.creationTime !== void 0 && (j.creationTime = Math.round(O.creationTime)), O.turnPassword !== void 0 && (j.turnPassword = O.turnPassword), O.enabledCodecs ? j.enabledCodecs = O.enabledCodecs.map((se) => se ? a.Codec.toJSON(se) : void 0) : j.enabledCodecs = [], O.metadata !== void 0 && (j.metadata = O.metadata), O.numParticipants !== void 0 && (j.numParticipants = Math.round(O.numParticipants)), O.activeRecording !== void 0 && (j.activeRecording = O.activeRecording), j;\n    },\n    fromPartial(O) {\n      var j, se, _e, ve, De, Ze, Qe, ot, ft, Ce;\n      const I = Be();\n      return I.sid = (j = O.sid) !== null && j !== void 0 ? j : \"\", I.name = (se = O.name) !== null && se !== void 0 ? se : \"\", I.emptyTimeout = (_e = O.emptyTimeout) !== null && _e !== void 0 ? _e : 0, I.maxParticipants = (ve = O.maxParticipants) !== null && ve !== void 0 ? ve : 0, I.creationTime = (De = O.creationTime) !== null && De !== void 0 ? De : 0, I.turnPassword = (Ze = O.turnPassword) !== null && Ze !== void 0 ? Ze : \"\", I.enabledCodecs = ((Qe = O.enabledCodecs) === null || Qe === void 0 ? void 0 : Qe.map((F) => a.Codec.fromPartial(F))) || [], I.metadata = (ot = O.metadata) !== null && ot !== void 0 ? ot : \"\", I.numParticipants = (ft = O.numParticipants) !== null && ft !== void 0 ? ft : 0, I.activeRecording = (Ce = O.activeRecording) !== null && Ce !== void 0 ? Ce : !1, I;\n    }\n  };\n  function Ne() {\n    return { mime: \"\", fmtpLine: \"\" };\n  }\n  a.Codec = {\n    encode(O, j = l.default.Writer.create()) {\n      return O.mime !== \"\" && j.uint32(10).string(O.mime), O.fmtpLine !== \"\" && j.uint32(18).string(O.fmtpLine), j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = Ne();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.mime = se.string();\n            break;\n          case 2:\n            ve.fmtpLine = se.string();\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        mime: ue(O.mime) ? String(O.mime) : \"\",\n        fmtpLine: ue(O.fmtpLine) ? String(O.fmtpLine) : \"\"\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.mime !== void 0 && (j.mime = O.mime), O.fmtpLine !== void 0 && (j.fmtpLine = O.fmtpLine), j;\n    },\n    fromPartial(O) {\n      var j, se;\n      const _e = Ne();\n      return _e.mime = (j = O.mime) !== null && j !== void 0 ? j : \"\", _e.fmtpLine = (se = O.fmtpLine) !== null && se !== void 0 ? se : \"\", _e;\n    }\n  };\n  function Le() {\n    return { canSubscribe: !1, canPublish: !1, canPublishData: !1, hidden: !1, recorder: !1 };\n  }\n  a.ParticipantPermission = {\n    encode(O, j = l.default.Writer.create()) {\n      return O.canSubscribe === !0 && j.uint32(8).bool(O.canSubscribe), O.canPublish === !0 && j.uint32(16).bool(O.canPublish), O.canPublishData === !0 && j.uint32(24).bool(O.canPublishData), O.hidden === !0 && j.uint32(56).bool(O.hidden), O.recorder === !0 && j.uint32(64).bool(O.recorder), j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = Le();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.canSubscribe = se.bool();\n            break;\n          case 2:\n            ve.canPublish = se.bool();\n            break;\n          case 3:\n            ve.canPublishData = se.bool();\n            break;\n          case 7:\n            ve.hidden = se.bool();\n            break;\n          case 8:\n            ve.recorder = se.bool();\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        canSubscribe: ue(O.canSubscribe) ? !!O.canSubscribe : !1,\n        canPublish: ue(O.canPublish) ? !!O.canPublish : !1,\n        canPublishData: ue(O.canPublishData) ? !!O.canPublishData : !1,\n        hidden: ue(O.hidden) ? !!O.hidden : !1,\n        recorder: ue(O.recorder) ? !!O.recorder : !1\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.canSubscribe !== void 0 && (j.canSubscribe = O.canSubscribe), O.canPublish !== void 0 && (j.canPublish = O.canPublish), O.canPublishData !== void 0 && (j.canPublishData = O.canPublishData), O.hidden !== void 0 && (j.hidden = O.hidden), O.recorder !== void 0 && (j.recorder = O.recorder), j;\n    },\n    fromPartial(O) {\n      var j, se, _e, ve, De;\n      const Ze = Le();\n      return Ze.canSubscribe = (j = O.canSubscribe) !== null && j !== void 0 ? j : !1, Ze.canPublish = (se = O.canPublish) !== null && se !== void 0 ? se : !1, Ze.canPublishData = (_e = O.canPublishData) !== null && _e !== void 0 ? _e : !1, Ze.hidden = (ve = O.hidden) !== null && ve !== void 0 ? ve : !1, Ze.recorder = (De = O.recorder) !== null && De !== void 0 ? De : !1, Ze;\n    }\n  };\n  function $e() {\n    return {\n      sid: \"\",\n      identity: \"\",\n      state: 0,\n      tracks: [],\n      metadata: \"\",\n      joinedAt: 0,\n      name: \"\",\n      version: 0,\n      permission: void 0,\n      region: \"\",\n      isPublisher: !1\n    };\n  }\n  a.ParticipantInfo = {\n    encode(O, j = l.default.Writer.create()) {\n      O.sid !== \"\" && j.uint32(10).string(O.sid), O.identity !== \"\" && j.uint32(18).string(O.identity), O.state !== 0 && j.uint32(24).int32(O.state);\n      for (const se of O.tracks)\n        a.TrackInfo.encode(se, j.uint32(34).fork()).ldelim();\n      return O.metadata !== \"\" && j.uint32(42).string(O.metadata), O.joinedAt !== 0 && j.uint32(48).int64(O.joinedAt), O.name !== \"\" && j.uint32(74).string(O.name), O.version !== 0 && j.uint32(80).uint32(O.version), O.permission !== void 0 && a.ParticipantPermission.encode(O.permission, j.uint32(90).fork()).ldelim(), O.region !== \"\" && j.uint32(98).string(O.region), O.isPublisher === !0 && j.uint32(104).bool(O.isPublisher), j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = $e();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.sid = se.string();\n            break;\n          case 2:\n            ve.identity = se.string();\n            break;\n          case 3:\n            ve.state = se.int32();\n            break;\n          case 4:\n            ve.tracks.push(a.TrackInfo.decode(se, se.uint32()));\n            break;\n          case 5:\n            ve.metadata = se.string();\n            break;\n          case 6:\n            ve.joinedAt = ie(se.int64());\n            break;\n          case 9:\n            ve.name = se.string();\n            break;\n          case 10:\n            ve.version = se.uint32();\n            break;\n          case 11:\n            ve.permission = a.ParticipantPermission.decode(se, se.uint32());\n            break;\n          case 12:\n            ve.region = se.string();\n            break;\n          case 13:\n            ve.isPublisher = se.bool();\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        sid: ue(O.sid) ? String(O.sid) : \"\",\n        identity: ue(O.identity) ? String(O.identity) : \"\",\n        state: ue(O.state) ? de(O.state) : 0,\n        tracks: Array.isArray(O == null ? void 0 : O.tracks) ? O.tracks.map((j) => a.TrackInfo.fromJSON(j)) : [],\n        metadata: ue(O.metadata) ? String(O.metadata) : \"\",\n        joinedAt: ue(O.joinedAt) ? Number(O.joinedAt) : 0,\n        name: ue(O.name) ? String(O.name) : \"\",\n        version: ue(O.version) ? Number(O.version) : 0,\n        permission: ue(O.permission) ? a.ParticipantPermission.fromJSON(O.permission) : void 0,\n        region: ue(O.region) ? String(O.region) : \"\",\n        isPublisher: ue(O.isPublisher) ? !!O.isPublisher : !1\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.sid !== void 0 && (j.sid = O.sid), O.identity !== void 0 && (j.identity = O.identity), O.state !== void 0 && (j.state = A(O.state)), O.tracks ? j.tracks = O.tracks.map((se) => se ? a.TrackInfo.toJSON(se) : void 0) : j.tracks = [], O.metadata !== void 0 && (j.metadata = O.metadata), O.joinedAt !== void 0 && (j.joinedAt = Math.round(O.joinedAt)), O.name !== void 0 && (j.name = O.name), O.version !== void 0 && (j.version = Math.round(O.version)), O.permission !== void 0 && (j.permission = O.permission ? a.ParticipantPermission.toJSON(O.permission) : void 0), O.region !== void 0 && (j.region = O.region), O.isPublisher !== void 0 && (j.isPublisher = O.isPublisher), j;\n    },\n    fromPartial(O) {\n      var j, se, _e, ve, De, Ze, Qe, ot, ft, Ce;\n      const I = $e();\n      return I.sid = (j = O.sid) !== null && j !== void 0 ? j : \"\", I.identity = (se = O.identity) !== null && se !== void 0 ? se : \"\", I.state = (_e = O.state) !== null && _e !== void 0 ? _e : 0, I.tracks = ((ve = O.tracks) === null || ve === void 0 ? void 0 : ve.map((F) => a.TrackInfo.fromPartial(F))) || [], I.metadata = (De = O.metadata) !== null && De !== void 0 ? De : \"\", I.joinedAt = (Ze = O.joinedAt) !== null && Ze !== void 0 ? Ze : 0, I.name = (Qe = O.name) !== null && Qe !== void 0 ? Qe : \"\", I.version = (ot = O.version) !== null && ot !== void 0 ? ot : 0, I.permission = O.permission !== void 0 && O.permission !== null ? a.ParticipantPermission.fromPartial(O.permission) : void 0, I.region = (ft = O.region) !== null && ft !== void 0 ? ft : \"\", I.isPublisher = (Ce = O.isPublisher) !== null && Ce !== void 0 ? Ce : !1, I;\n    }\n  };\n  function Ue() {\n    return { mimeType: \"\", mid: \"\", cid: \"\", layers: [] };\n  }\n  a.SimulcastCodecInfo = {\n    encode(O, j = l.default.Writer.create()) {\n      O.mimeType !== \"\" && j.uint32(10).string(O.mimeType), O.mid !== \"\" && j.uint32(18).string(O.mid), O.cid !== \"\" && j.uint32(26).string(O.cid);\n      for (const se of O.layers)\n        a.VideoLayer.encode(se, j.uint32(34).fork()).ldelim();\n      return j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = Ue();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.mimeType = se.string();\n            break;\n          case 2:\n            ve.mid = se.string();\n            break;\n          case 3:\n            ve.cid = se.string();\n            break;\n          case 4:\n            ve.layers.push(a.VideoLayer.decode(se, se.uint32()));\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        mimeType: ue(O.mimeType) ? String(O.mimeType) : \"\",\n        mid: ue(O.mid) ? String(O.mid) : \"\",\n        cid: ue(O.cid) ? String(O.cid) : \"\",\n        layers: Array.isArray(O == null ? void 0 : O.layers) ? O.layers.map((j) => a.VideoLayer.fromJSON(j)) : []\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.mimeType !== void 0 && (j.mimeType = O.mimeType), O.mid !== void 0 && (j.mid = O.mid), O.cid !== void 0 && (j.cid = O.cid), O.layers ? j.layers = O.layers.map((se) => se ? a.VideoLayer.toJSON(se) : void 0) : j.layers = [], j;\n    },\n    fromPartial(O) {\n      var j, se, _e, ve;\n      const De = Ue();\n      return De.mimeType = (j = O.mimeType) !== null && j !== void 0 ? j : \"\", De.mid = (se = O.mid) !== null && se !== void 0 ? se : \"\", De.cid = (_e = O.cid) !== null && _e !== void 0 ? _e : \"\", De.layers = ((ve = O.layers) === null || ve === void 0 ? void 0 : ve.map((Ze) => a.VideoLayer.fromPartial(Ze))) || [], De;\n    }\n  };\n  function Ge() {\n    return {\n      sid: \"\",\n      type: 0,\n      name: \"\",\n      muted: !1,\n      width: 0,\n      height: 0,\n      simulcast: !1,\n      disableDtx: !1,\n      source: 0,\n      layers: [],\n      mimeType: \"\",\n      mid: \"\",\n      codecs: [],\n      stereo: !1,\n      disableRed: !1\n    };\n  }\n  a.TrackInfo = {\n    encode(O, j = l.default.Writer.create()) {\n      O.sid !== \"\" && j.uint32(10).string(O.sid), O.type !== 0 && j.uint32(16).int32(O.type), O.name !== \"\" && j.uint32(26).string(O.name), O.muted === !0 && j.uint32(32).bool(O.muted), O.width !== 0 && j.uint32(40).uint32(O.width), O.height !== 0 && j.uint32(48).uint32(O.height), O.simulcast === !0 && j.uint32(56).bool(O.simulcast), O.disableDtx === !0 && j.uint32(64).bool(O.disableDtx), O.source !== 0 && j.uint32(72).int32(O.source);\n      for (const se of O.layers)\n        a.VideoLayer.encode(se, j.uint32(82).fork()).ldelim();\n      O.mimeType !== \"\" && j.uint32(90).string(O.mimeType), O.mid !== \"\" && j.uint32(98).string(O.mid);\n      for (const se of O.codecs)\n        a.SimulcastCodecInfo.encode(se, j.uint32(106).fork()).ldelim();\n      return O.stereo === !0 && j.uint32(112).bool(O.stereo), O.disableRed === !0 && j.uint32(120).bool(O.disableRed), j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = Ge();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.sid = se.string();\n            break;\n          case 2:\n            ve.type = se.int32();\n            break;\n          case 3:\n            ve.name = se.string();\n            break;\n          case 4:\n            ve.muted = se.bool();\n            break;\n          case 5:\n            ve.width = se.uint32();\n            break;\n          case 6:\n            ve.height = se.uint32();\n            break;\n          case 7:\n            ve.simulcast = se.bool();\n            break;\n          case 8:\n            ve.disableDtx = se.bool();\n            break;\n          case 9:\n            ve.source = se.int32();\n            break;\n          case 10:\n            ve.layers.push(a.VideoLayer.decode(se, se.uint32()));\n            break;\n          case 11:\n            ve.mimeType = se.string();\n            break;\n          case 12:\n            ve.mid = se.string();\n            break;\n          case 13:\n            ve.codecs.push(a.SimulcastCodecInfo.decode(se, se.uint32()));\n            break;\n          case 14:\n            ve.stereo = se.bool();\n            break;\n          case 15:\n            ve.disableRed = se.bool();\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        sid: ue(O.sid) ? String(O.sid) : \"\",\n        type: ue(O.type) ? g(O.type) : 0,\n        name: ue(O.name) ? String(O.name) : \"\",\n        muted: ue(O.muted) ? !!O.muted : !1,\n        width: ue(O.width) ? Number(O.width) : 0,\n        height: ue(O.height) ? Number(O.height) : 0,\n        simulcast: ue(O.simulcast) ? !!O.simulcast : !1,\n        disableDtx: ue(O.disableDtx) ? !!O.disableDtx : !1,\n        source: ue(O.source) ? k(O.source) : 0,\n        layers: Array.isArray(O == null ? void 0 : O.layers) ? O.layers.map((j) => a.VideoLayer.fromJSON(j)) : [],\n        mimeType: ue(O.mimeType) ? String(O.mimeType) : \"\",\n        mid: ue(O.mid) ? String(O.mid) : \"\",\n        codecs: Array.isArray(O == null ? void 0 : O.codecs) ? O.codecs.map((j) => a.SimulcastCodecInfo.fromJSON(j)) : [],\n        stereo: ue(O.stereo) ? !!O.stereo : !1,\n        disableRed: ue(O.disableRed) ? !!O.disableRed : !1\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.sid !== void 0 && (j.sid = O.sid), O.type !== void 0 && (j.type = E(O.type)), O.name !== void 0 && (j.name = O.name), O.muted !== void 0 && (j.muted = O.muted), O.width !== void 0 && (j.width = Math.round(O.width)), O.height !== void 0 && (j.height = Math.round(O.height)), O.simulcast !== void 0 && (j.simulcast = O.simulcast), O.disableDtx !== void 0 && (j.disableDtx = O.disableDtx), O.source !== void 0 && (j.source = L(O.source)), O.layers ? j.layers = O.layers.map((se) => se ? a.VideoLayer.toJSON(se) : void 0) : j.layers = [], O.mimeType !== void 0 && (j.mimeType = O.mimeType), O.mid !== void 0 && (j.mid = O.mid), O.codecs ? j.codecs = O.codecs.map((se) => se ? a.SimulcastCodecInfo.toJSON(se) : void 0) : j.codecs = [], O.stereo !== void 0 && (j.stereo = O.stereo), O.disableRed !== void 0 && (j.disableRed = O.disableRed), j;\n    },\n    fromPartial(O) {\n      var j, se, _e, ve, De, Ze, Qe, ot, ft, Ce, I, F, z, Te, fe;\n      const ke = Ge();\n      return ke.sid = (j = O.sid) !== null && j !== void 0 ? j : \"\", ke.type = (se = O.type) !== null && se !== void 0 ? se : 0, ke.name = (_e = O.name) !== null && _e !== void 0 ? _e : \"\", ke.muted = (ve = O.muted) !== null && ve !== void 0 ? ve : !1, ke.width = (De = O.width) !== null && De !== void 0 ? De : 0, ke.height = (Ze = O.height) !== null && Ze !== void 0 ? Ze : 0, ke.simulcast = (Qe = O.simulcast) !== null && Qe !== void 0 ? Qe : !1, ke.disableDtx = (ot = O.disableDtx) !== null && ot !== void 0 ? ot : !1, ke.source = (ft = O.source) !== null && ft !== void 0 ? ft : 0, ke.layers = ((Ce = O.layers) === null || Ce === void 0 ? void 0 : Ce.map((it) => a.VideoLayer.fromPartial(it))) || [], ke.mimeType = (I = O.mimeType) !== null && I !== void 0 ? I : \"\", ke.mid = (F = O.mid) !== null && F !== void 0 ? F : \"\", ke.codecs = ((z = O.codecs) === null || z === void 0 ? void 0 : z.map((it) => a.SimulcastCodecInfo.fromPartial(it))) || [], ke.stereo = (Te = O.stereo) !== null && Te !== void 0 ? Te : !1, ke.disableRed = (fe = O.disableRed) !== null && fe !== void 0 ? fe : !1, ke;\n    }\n  };\n  function He() {\n    return { quality: 0, width: 0, height: 0, bitrate: 0, ssrc: 0 };\n  }\n  a.VideoLayer = {\n    encode(O, j = l.default.Writer.create()) {\n      return O.quality !== 0 && j.uint32(8).int32(O.quality), O.width !== 0 && j.uint32(16).uint32(O.width), O.height !== 0 && j.uint32(24).uint32(O.height), O.bitrate !== 0 && j.uint32(32).uint32(O.bitrate), O.ssrc !== 0 && j.uint32(40).uint32(O.ssrc), j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = He();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.quality = se.int32();\n            break;\n          case 2:\n            ve.width = se.uint32();\n            break;\n          case 3:\n            ve.height = se.uint32();\n            break;\n          case 4:\n            ve.bitrate = se.uint32();\n            break;\n          case 5:\n            ve.ssrc = se.uint32();\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        quality: ue(O.quality) ? $(O.quality) : 0,\n        width: ue(O.width) ? Number(O.width) : 0,\n        height: ue(O.height) ? Number(O.height) : 0,\n        bitrate: ue(O.bitrate) ? Number(O.bitrate) : 0,\n        ssrc: ue(O.ssrc) ? Number(O.ssrc) : 0\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.quality !== void 0 && (j.quality = J(O.quality)), O.width !== void 0 && (j.width = Math.round(O.width)), O.height !== void 0 && (j.height = Math.round(O.height)), O.bitrate !== void 0 && (j.bitrate = Math.round(O.bitrate)), O.ssrc !== void 0 && (j.ssrc = Math.round(O.ssrc)), j;\n    },\n    fromPartial(O) {\n      var j, se, _e, ve, De;\n      const Ze = He();\n      return Ze.quality = (j = O.quality) !== null && j !== void 0 ? j : 0, Ze.width = (se = O.width) !== null && se !== void 0 ? se : 0, Ze.height = (_e = O.height) !== null && _e !== void 0 ? _e : 0, Ze.bitrate = (ve = O.bitrate) !== null && ve !== void 0 ? ve : 0, Ze.ssrc = (De = O.ssrc) !== null && De !== void 0 ? De : 0, Ze;\n    }\n  };\n  function Ve() {\n    return { kind: 0, user: void 0, speaker: void 0 };\n  }\n  a.DataPacket = {\n    encode(O, j = l.default.Writer.create()) {\n      return O.kind !== 0 && j.uint32(8).int32(O.kind), O.user !== void 0 && a.UserPacket.encode(O.user, j.uint32(18).fork()).ldelim(), O.speaker !== void 0 && a.ActiveSpeakerUpdate.encode(O.speaker, j.uint32(26).fork()).ldelim(), j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = Ve();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.kind = se.int32();\n            break;\n          case 2:\n            ve.user = a.UserPacket.decode(se, se.uint32());\n            break;\n          case 3:\n            ve.speaker = a.ActiveSpeakerUpdate.decode(se, se.uint32());\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        kind: ue(O.kind) ? D(O.kind) : 0,\n        user: ue(O.user) ? a.UserPacket.fromJSON(O.user) : void 0,\n        speaker: ue(O.speaker) ? a.ActiveSpeakerUpdate.fromJSON(O.speaker) : void 0\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.kind !== void 0 && (j.kind = W(O.kind)), O.user !== void 0 && (j.user = O.user ? a.UserPacket.toJSON(O.user) : void 0), O.speaker !== void 0 && (j.speaker = O.speaker ? a.ActiveSpeakerUpdate.toJSON(O.speaker) : void 0), j;\n    },\n    fromPartial(O) {\n      var j;\n      const se = Ve();\n      return se.kind = (j = O.kind) !== null && j !== void 0 ? j : 0, se.user = O.user !== void 0 && O.user !== null ? a.UserPacket.fromPartial(O.user) : void 0, se.speaker = O.speaker !== void 0 && O.speaker !== null ? a.ActiveSpeakerUpdate.fromPartial(O.speaker) : void 0, se;\n    }\n  };\n  function be() {\n    return { speakers: [] };\n  }\n  a.ActiveSpeakerUpdate = {\n    encode(O, j = l.default.Writer.create()) {\n      for (const se of O.speakers)\n        a.SpeakerInfo.encode(se, j.uint32(10).fork()).ldelim();\n      return j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = be();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.speakers.push(a.SpeakerInfo.decode(se, se.uint32()));\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        speakers: Array.isArray(O == null ? void 0 : O.speakers) ? O.speakers.map((j) => a.SpeakerInfo.fromJSON(j)) : []\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.speakers ? j.speakers = O.speakers.map((se) => se ? a.SpeakerInfo.toJSON(se) : void 0) : j.speakers = [], j;\n    },\n    fromPartial(O) {\n      var j;\n      const se = be();\n      return se.speakers = ((j = O.speakers) === null || j === void 0 ? void 0 : j.map((_e) => a.SpeakerInfo.fromPartial(_e))) || [], se;\n    }\n  };\n  function Ae() {\n    return { sid: \"\", level: 0, active: !1 };\n  }\n  a.SpeakerInfo = {\n    encode(O, j = l.default.Writer.create()) {\n      return O.sid !== \"\" && j.uint32(10).string(O.sid), O.level !== 0 && j.uint32(21).float(O.level), O.active === !0 && j.uint32(24).bool(O.active), j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = Ae();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.sid = se.string();\n            break;\n          case 2:\n            ve.level = se.float();\n            break;\n          case 3:\n            ve.active = se.bool();\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        sid: ue(O.sid) ? String(O.sid) : \"\",\n        level: ue(O.level) ? Number(O.level) : 0,\n        active: ue(O.active) ? !!O.active : !1\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.sid !== void 0 && (j.sid = O.sid), O.level !== void 0 && (j.level = O.level), O.active !== void 0 && (j.active = O.active), j;\n    },\n    fromPartial(O) {\n      var j, se, _e;\n      const ve = Ae();\n      return ve.sid = (j = O.sid) !== null && j !== void 0 ? j : \"\", ve.level = (se = O.level) !== null && se !== void 0 ? se : 0, ve.active = (_e = O.active) !== null && _e !== void 0 ? _e : !1, ve;\n    }\n  };\n  function qe() {\n    return { participantSid: \"\", payload: new Uint8Array(), destinationSids: [] };\n  }\n  a.UserPacket = {\n    encode(O, j = l.default.Writer.create()) {\n      O.participantSid !== \"\" && j.uint32(10).string(O.participantSid), O.payload.length !== 0 && j.uint32(18).bytes(O.payload);\n      for (const se of O.destinationSids)\n        j.uint32(26).string(se);\n      return j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = qe();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.participantSid = se.string();\n            break;\n          case 2:\n            ve.payload = se.bytes();\n            break;\n          case 3:\n            ve.destinationSids.push(se.string());\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        participantSid: ue(O.participantSid) ? String(O.participantSid) : \"\",\n        payload: ue(O.payload) ? je(O.payload) : new Uint8Array(),\n        destinationSids: Array.isArray(O == null ? void 0 : O.destinationSids) ? O.destinationSids.map((j) => String(j)) : []\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.participantSid !== void 0 && (j.participantSid = O.participantSid), O.payload !== void 0 && (j.payload = tt(O.payload !== void 0 ? O.payload : new Uint8Array())), O.destinationSids ? j.destinationSids = O.destinationSids.map((se) => se) : j.destinationSids = [], j;\n    },\n    fromPartial(O) {\n      var j, se, _e;\n      const ve = qe();\n      return ve.participantSid = (j = O.participantSid) !== null && j !== void 0 ? j : \"\", ve.payload = (se = O.payload) !== null && se !== void 0 ? se : new Uint8Array(), ve.destinationSids = ((_e = O.destinationSids) === null || _e === void 0 ? void 0 : _e.map((De) => De)) || [], ve;\n    }\n  };\n  function xe() {\n    return { participantSid: \"\", trackSids: [] };\n  }\n  a.ParticipantTracks = {\n    encode(O, j = l.default.Writer.create()) {\n      O.participantSid !== \"\" && j.uint32(10).string(O.participantSid);\n      for (const se of O.trackSids)\n        j.uint32(18).string(se);\n      return j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = xe();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.participantSid = se.string();\n            break;\n          case 2:\n            ve.trackSids.push(se.string());\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        participantSid: ue(O.participantSid) ? String(O.participantSid) : \"\",\n        trackSids: Array.isArray(O == null ? void 0 : O.trackSids) ? O.trackSids.map((j) => String(j)) : []\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.participantSid !== void 0 && (j.participantSid = O.participantSid), O.trackSids ? j.trackSids = O.trackSids.map((se) => se) : j.trackSids = [], j;\n    },\n    fromPartial(O) {\n      var j, se;\n      const _e = xe();\n      return _e.participantSid = (j = O.participantSid) !== null && j !== void 0 ? j : \"\", _e.trackSids = ((se = O.trackSids) === null || se === void 0 ? void 0 : se.map((ve) => ve)) || [], _e;\n    }\n  };\n  function Pe() {\n    return { edition: 0, version: \"\", protocol: 0, region: \"\", nodeId: \"\", debugInfo: \"\" };\n  }\n  a.ServerInfo = {\n    encode(O, j = l.default.Writer.create()) {\n      return O.edition !== 0 && j.uint32(8).int32(O.edition), O.version !== \"\" && j.uint32(18).string(O.version), O.protocol !== 0 && j.uint32(24).int32(O.protocol), O.region !== \"\" && j.uint32(34).string(O.region), O.nodeId !== \"\" && j.uint32(42).string(O.nodeId), O.debugInfo !== \"\" && j.uint32(50).string(O.debugInfo), j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = Pe();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.edition = se.int32();\n            break;\n          case 2:\n            ve.version = se.string();\n            break;\n          case 3:\n            ve.protocol = se.int32();\n            break;\n          case 4:\n            ve.region = se.string();\n            break;\n          case 5:\n            ve.nodeId = se.string();\n            break;\n          case 6:\n            ve.debugInfo = se.string();\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        edition: ue(O.edition) ? ae(O.edition) : 0,\n        version: ue(O.version) ? String(O.version) : \"\",\n        protocol: ue(O.protocol) ? Number(O.protocol) : 0,\n        region: ue(O.region) ? String(O.region) : \"\",\n        nodeId: ue(O.nodeId) ? String(O.nodeId) : \"\",\n        debugInfo: ue(O.debugInfo) ? String(O.debugInfo) : \"\"\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.edition !== void 0 && (j.edition = ye(O.edition)), O.version !== void 0 && (j.version = O.version), O.protocol !== void 0 && (j.protocol = Math.round(O.protocol)), O.region !== void 0 && (j.region = O.region), O.nodeId !== void 0 && (j.nodeId = O.nodeId), O.debugInfo !== void 0 && (j.debugInfo = O.debugInfo), j;\n    },\n    fromPartial(O) {\n      var j, se, _e, ve, De, Ze;\n      const Qe = Pe();\n      return Qe.edition = (j = O.edition) !== null && j !== void 0 ? j : 0, Qe.version = (se = O.version) !== null && se !== void 0 ? se : \"\", Qe.protocol = (_e = O.protocol) !== null && _e !== void 0 ? _e : 0, Qe.region = (ve = O.region) !== null && ve !== void 0 ? ve : \"\", Qe.nodeId = (De = O.nodeId) !== null && De !== void 0 ? De : \"\", Qe.debugInfo = (Ze = O.debugInfo) !== null && Ze !== void 0 ? Ze : \"\", Qe;\n    }\n  };\n  function C() {\n    return {\n      sdk: 0,\n      version: \"\",\n      protocol: 0,\n      os: \"\",\n      osVersion: \"\",\n      deviceModel: \"\",\n      browser: \"\",\n      browserVersion: \"\",\n      address: \"\",\n      network: \"\"\n    };\n  }\n  a.ClientInfo = {\n    encode(O, j = l.default.Writer.create()) {\n      return O.sdk !== 0 && j.uint32(8).int32(O.sdk), O.version !== \"\" && j.uint32(18).string(O.version), O.protocol !== 0 && j.uint32(24).int32(O.protocol), O.os !== \"\" && j.uint32(34).string(O.os), O.osVersion !== \"\" && j.uint32(42).string(O.osVersion), O.deviceModel !== \"\" && j.uint32(50).string(O.deviceModel), O.browser !== \"\" && j.uint32(58).string(O.browser), O.browserVersion !== \"\" && j.uint32(66).string(O.browserVersion), O.address !== \"\" && j.uint32(74).string(O.address), O.network !== \"\" && j.uint32(82).string(O.network), j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = C();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.sdk = se.int32();\n            break;\n          case 2:\n            ve.version = se.string();\n            break;\n          case 3:\n            ve.protocol = se.int32();\n            break;\n          case 4:\n            ve.os = se.string();\n            break;\n          case 5:\n            ve.osVersion = se.string();\n            break;\n          case 6:\n            ve.deviceModel = se.string();\n            break;\n          case 7:\n            ve.browser = se.string();\n            break;\n          case 8:\n            ve.browserVersion = se.string();\n            break;\n          case 9:\n            ve.address = se.string();\n            break;\n          case 10:\n            ve.network = se.string();\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        sdk: ue(O.sdk) ? le(O.sdk) : 0,\n        version: ue(O.version) ? String(O.version) : \"\",\n        protocol: ue(O.protocol) ? Number(O.protocol) : 0,\n        os: ue(O.os) ? String(O.os) : \"\",\n        osVersion: ue(O.osVersion) ? String(O.osVersion) : \"\",\n        deviceModel: ue(O.deviceModel) ? String(O.deviceModel) : \"\",\n        browser: ue(O.browser) ? String(O.browser) : \"\",\n        browserVersion: ue(O.browserVersion) ? String(O.browserVersion) : \"\",\n        address: ue(O.address) ? String(O.address) : \"\",\n        network: ue(O.network) ? String(O.network) : \"\"\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.sdk !== void 0 && (j.sdk = we(O.sdk)), O.version !== void 0 && (j.version = O.version), O.protocol !== void 0 && (j.protocol = Math.round(O.protocol)), O.os !== void 0 && (j.os = O.os), O.osVersion !== void 0 && (j.osVersion = O.osVersion), O.deviceModel !== void 0 && (j.deviceModel = O.deviceModel), O.browser !== void 0 && (j.browser = O.browser), O.browserVersion !== void 0 && (j.browserVersion = O.browserVersion), O.address !== void 0 && (j.address = O.address), O.network !== void 0 && (j.network = O.network), j;\n    },\n    fromPartial(O) {\n      var j, se, _e, ve, De, Ze, Qe, ot, ft, Ce;\n      const I = C();\n      return I.sdk = (j = O.sdk) !== null && j !== void 0 ? j : 0, I.version = (se = O.version) !== null && se !== void 0 ? se : \"\", I.protocol = (_e = O.protocol) !== null && _e !== void 0 ? _e : 0, I.os = (ve = O.os) !== null && ve !== void 0 ? ve : \"\", I.osVersion = (De = O.osVersion) !== null && De !== void 0 ? De : \"\", I.deviceModel = (Ze = O.deviceModel) !== null && Ze !== void 0 ? Ze : \"\", I.browser = (Qe = O.browser) !== null && Qe !== void 0 ? Qe : \"\", I.browserVersion = (ot = O.browserVersion) !== null && ot !== void 0 ? ot : \"\", I.address = (ft = O.address) !== null && ft !== void 0 ? ft : \"\", I.network = (Ce = O.network) !== null && Ce !== void 0 ? Ce : \"\", I;\n    }\n  };\n  function x() {\n    return { video: void 0, screen: void 0, resumeConnection: 0, disabledCodecs: void 0, forceRelay: 0 };\n  }\n  a.ClientConfiguration = {\n    encode(O, j = l.default.Writer.create()) {\n      return O.video !== void 0 && a.VideoConfiguration.encode(O.video, j.uint32(10).fork()).ldelim(), O.screen !== void 0 && a.VideoConfiguration.encode(O.screen, j.uint32(18).fork()).ldelim(), O.resumeConnection !== 0 && j.uint32(24).int32(O.resumeConnection), O.disabledCodecs !== void 0 && a.DisabledCodecs.encode(O.disabledCodecs, j.uint32(34).fork()).ldelim(), O.forceRelay !== 0 && j.uint32(40).int32(O.forceRelay), j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = x();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.video = a.VideoConfiguration.decode(se, se.uint32());\n            break;\n          case 2:\n            ve.screen = a.VideoConfiguration.decode(se, se.uint32());\n            break;\n          case 3:\n            ve.resumeConnection = se.int32();\n            break;\n          case 4:\n            ve.disabledCodecs = a.DisabledCodecs.decode(se, se.uint32());\n            break;\n          case 5:\n            ve.forceRelay = se.int32();\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        video: ue(O.video) ? a.VideoConfiguration.fromJSON(O.video) : void 0,\n        screen: ue(O.screen) ? a.VideoConfiguration.fromJSON(O.screen) : void 0,\n        resumeConnection: ue(O.resumeConnection) ? B(O.resumeConnection) : 0,\n        disabledCodecs: ue(O.disabledCodecs) ? a.DisabledCodecs.fromJSON(O.disabledCodecs) : void 0,\n        forceRelay: ue(O.forceRelay) ? B(O.forceRelay) : 0\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.video !== void 0 && (j.video = O.video ? a.VideoConfiguration.toJSON(O.video) : void 0), O.screen !== void 0 && (j.screen = O.screen ? a.VideoConfiguration.toJSON(O.screen) : void 0), O.resumeConnection !== void 0 && (j.resumeConnection = Y(O.resumeConnection)), O.disabledCodecs !== void 0 && (j.disabledCodecs = O.disabledCodecs ? a.DisabledCodecs.toJSON(O.disabledCodecs) : void 0), O.forceRelay !== void 0 && (j.forceRelay = Y(O.forceRelay)), j;\n    },\n    fromPartial(O) {\n      var j, se;\n      const _e = x();\n      return _e.video = O.video !== void 0 && O.video !== null ? a.VideoConfiguration.fromPartial(O.video) : void 0, _e.screen = O.screen !== void 0 && O.screen !== null ? a.VideoConfiguration.fromPartial(O.screen) : void 0, _e.resumeConnection = (j = O.resumeConnection) !== null && j !== void 0 ? j : 0, _e.disabledCodecs = O.disabledCodecs !== void 0 && O.disabledCodecs !== null ? a.DisabledCodecs.fromPartial(O.disabledCodecs) : void 0, _e.forceRelay = (se = O.forceRelay) !== null && se !== void 0 ? se : 0, _e;\n    }\n  };\n  function Q() {\n    return { hardwareEncoder: 0 };\n  }\n  a.VideoConfiguration = {\n    encode(O, j = l.default.Writer.create()) {\n      return O.hardwareEncoder !== 0 && j.uint32(8).int32(O.hardwareEncoder), j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = Q();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.hardwareEncoder = se.int32();\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return { hardwareEncoder: ue(O.hardwareEncoder) ? B(O.hardwareEncoder) : 0 };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.hardwareEncoder !== void 0 && (j.hardwareEncoder = Y(O.hardwareEncoder)), j;\n    },\n    fromPartial(O) {\n      var j;\n      const se = Q();\n      return se.hardwareEncoder = (j = O.hardwareEncoder) !== null && j !== void 0 ? j : 0, se;\n    }\n  };\n  function Se() {\n    return { codecs: [] };\n  }\n  a.DisabledCodecs = {\n    encode(O, j = l.default.Writer.create()) {\n      for (const se of O.codecs)\n        a.Codec.encode(se, j.uint32(10).fork()).ldelim();\n      return j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = Se();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.codecs.push(a.Codec.decode(se, se.uint32()));\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return { codecs: Array.isArray(O == null ? void 0 : O.codecs) ? O.codecs.map((j) => a.Codec.fromJSON(j)) : [] };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.codecs ? j.codecs = O.codecs.map((se) => se ? a.Codec.toJSON(se) : void 0) : j.codecs = [], j;\n    },\n    fromPartial(O) {\n      var j;\n      const se = Se();\n      return se.codecs = ((j = O.codecs) === null || j === void 0 ? void 0 : j.map((_e) => a.Codec.fromPartial(_e))) || [], se;\n    }\n  };\n  function me() {\n    return {\n      startTime: void 0,\n      endTime: void 0,\n      duration: 0,\n      packets: 0,\n      packetRate: 0,\n      bytes: 0,\n      headerBytes: 0,\n      bitrate: 0,\n      packetsLost: 0,\n      packetLossRate: 0,\n      packetLossPercentage: 0,\n      packetsDuplicate: 0,\n      packetDuplicateRate: 0,\n      bytesDuplicate: 0,\n      headerBytesDuplicate: 0,\n      bitrateDuplicate: 0,\n      packetsPadding: 0,\n      packetPaddingRate: 0,\n      bytesPadding: 0,\n      headerBytesPadding: 0,\n      bitratePadding: 0,\n      packetsOutOfOrder: 0,\n      frames: 0,\n      frameRate: 0,\n      jitterCurrent: 0,\n      jitterMax: 0,\n      gapHistogram: {},\n      nacks: 0,\n      nackAcks: 0,\n      nackMisses: 0,\n      nackRepeated: 0,\n      plis: 0,\n      lastPli: void 0,\n      firs: 0,\n      lastFir: void 0,\n      rttCurrent: 0,\n      rttMax: 0,\n      keyFrames: 0,\n      lastKeyFrame: void 0,\n      layerLockPlis: 0,\n      lastLayerLockPli: void 0\n    };\n  }\n  a.RTPStats = {\n    encode(O, j = l.default.Writer.create()) {\n      return O.startTime !== void 0 && v.Timestamp.encode(Oe(O.startTime), j.uint32(10).fork()).ldelim(), O.endTime !== void 0 && v.Timestamp.encode(Oe(O.endTime), j.uint32(18).fork()).ldelim(), O.duration !== 0 && j.uint32(25).double(O.duration), O.packets !== 0 && j.uint32(32).uint32(O.packets), O.packetRate !== 0 && j.uint32(41).double(O.packetRate), O.bytes !== 0 && j.uint32(48).uint64(O.bytes), O.headerBytes !== 0 && j.uint32(312).uint64(O.headerBytes), O.bitrate !== 0 && j.uint32(57).double(O.bitrate), O.packetsLost !== 0 && j.uint32(64).uint32(O.packetsLost), O.packetLossRate !== 0 && j.uint32(73).double(O.packetLossRate), O.packetLossPercentage !== 0 && j.uint32(85).float(O.packetLossPercentage), O.packetsDuplicate !== 0 && j.uint32(88).uint32(O.packetsDuplicate), O.packetDuplicateRate !== 0 && j.uint32(97).double(O.packetDuplicateRate), O.bytesDuplicate !== 0 && j.uint32(104).uint64(O.bytesDuplicate), O.headerBytesDuplicate !== 0 && j.uint32(320).uint64(O.headerBytesDuplicate), O.bitrateDuplicate !== 0 && j.uint32(113).double(O.bitrateDuplicate), O.packetsPadding !== 0 && j.uint32(120).uint32(O.packetsPadding), O.packetPaddingRate !== 0 && j.uint32(129).double(O.packetPaddingRate), O.bytesPadding !== 0 && j.uint32(136).uint64(O.bytesPadding), O.headerBytesPadding !== 0 && j.uint32(328).uint64(O.headerBytesPadding), O.bitratePadding !== 0 && j.uint32(145).double(O.bitratePadding), O.packetsOutOfOrder !== 0 && j.uint32(152).uint32(O.packetsOutOfOrder), O.frames !== 0 && j.uint32(160).uint32(O.frames), O.frameRate !== 0 && j.uint32(169).double(O.frameRate), O.jitterCurrent !== 0 && j.uint32(177).double(O.jitterCurrent), O.jitterMax !== 0 && j.uint32(185).double(O.jitterMax), Object.entries(O.gapHistogram).forEach(([se, _e]) => {\n        a.RTPStats_GapHistogramEntry.encode({ key: se, value: _e }, j.uint32(194).fork()).ldelim();\n      }), O.nacks !== 0 && j.uint32(200).uint32(O.nacks), O.nackAcks !== 0 && j.uint32(296).uint32(O.nackAcks), O.nackMisses !== 0 && j.uint32(208).uint32(O.nackMisses), O.nackRepeated !== 0 && j.uint32(304).uint32(O.nackRepeated), O.plis !== 0 && j.uint32(216).uint32(O.plis), O.lastPli !== void 0 && v.Timestamp.encode(Oe(O.lastPli), j.uint32(226).fork()).ldelim(), O.firs !== 0 && j.uint32(232).uint32(O.firs), O.lastFir !== void 0 && v.Timestamp.encode(Oe(O.lastFir), j.uint32(242).fork()).ldelim(), O.rttCurrent !== 0 && j.uint32(248).uint32(O.rttCurrent), O.rttMax !== 0 && j.uint32(256).uint32(O.rttMax), O.keyFrames !== 0 && j.uint32(264).uint32(O.keyFrames), O.lastKeyFrame !== void 0 && v.Timestamp.encode(Oe(O.lastKeyFrame), j.uint32(274).fork()).ldelim(), O.layerLockPlis !== 0 && j.uint32(280).uint32(O.layerLockPlis), O.lastLayerLockPli !== void 0 && v.Timestamp.encode(Oe(O.lastLayerLockPli), j.uint32(290).fork()).ldelim(), j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = me();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.startTime = P(v.Timestamp.decode(se, se.uint32()));\n            break;\n          case 2:\n            ve.endTime = P(v.Timestamp.decode(se, se.uint32()));\n            break;\n          case 3:\n            ve.duration = se.double();\n            break;\n          case 4:\n            ve.packets = se.uint32();\n            break;\n          case 5:\n            ve.packetRate = se.double();\n            break;\n          case 6:\n            ve.bytes = ie(se.uint64());\n            break;\n          case 39:\n            ve.headerBytes = ie(se.uint64());\n            break;\n          case 7:\n            ve.bitrate = se.double();\n            break;\n          case 8:\n            ve.packetsLost = se.uint32();\n            break;\n          case 9:\n            ve.packetLossRate = se.double();\n            break;\n          case 10:\n            ve.packetLossPercentage = se.float();\n            break;\n          case 11:\n            ve.packetsDuplicate = se.uint32();\n            break;\n          case 12:\n            ve.packetDuplicateRate = se.double();\n            break;\n          case 13:\n            ve.bytesDuplicate = ie(se.uint64());\n            break;\n          case 40:\n            ve.headerBytesDuplicate = ie(se.uint64());\n            break;\n          case 14:\n            ve.bitrateDuplicate = se.double();\n            break;\n          case 15:\n            ve.packetsPadding = se.uint32();\n            break;\n          case 16:\n            ve.packetPaddingRate = se.double();\n            break;\n          case 17:\n            ve.bytesPadding = ie(se.uint64());\n            break;\n          case 41:\n            ve.headerBytesPadding = ie(se.uint64());\n            break;\n          case 18:\n            ve.bitratePadding = se.double();\n            break;\n          case 19:\n            ve.packetsOutOfOrder = se.uint32();\n            break;\n          case 20:\n            ve.frames = se.uint32();\n            break;\n          case 21:\n            ve.frameRate = se.double();\n            break;\n          case 22:\n            ve.jitterCurrent = se.double();\n            break;\n          case 23:\n            ve.jitterMax = se.double();\n            break;\n          case 24:\n            const Ze = a.RTPStats_GapHistogramEntry.decode(se, se.uint32());\n            Ze.value !== void 0 && (ve.gapHistogram[Ze.key] = Ze.value);\n            break;\n          case 25:\n            ve.nacks = se.uint32();\n            break;\n          case 37:\n            ve.nackAcks = se.uint32();\n            break;\n          case 26:\n            ve.nackMisses = se.uint32();\n            break;\n          case 38:\n            ve.nackRepeated = se.uint32();\n            break;\n          case 27:\n            ve.plis = se.uint32();\n            break;\n          case 28:\n            ve.lastPli = P(v.Timestamp.decode(se, se.uint32()));\n            break;\n          case 29:\n            ve.firs = se.uint32();\n            break;\n          case 30:\n            ve.lastFir = P(v.Timestamp.decode(se, se.uint32()));\n            break;\n          case 31:\n            ve.rttCurrent = se.uint32();\n            break;\n          case 32:\n            ve.rttMax = se.uint32();\n            break;\n          case 33:\n            ve.keyFrames = se.uint32();\n            break;\n          case 34:\n            ve.lastKeyFrame = P(v.Timestamp.decode(se, se.uint32()));\n            break;\n          case 35:\n            ve.layerLockPlis = se.uint32();\n            break;\n          case 36:\n            ve.lastLayerLockPli = P(v.Timestamp.decode(se, se.uint32()));\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        startTime: ue(O.startTime) ? X(O.startTime) : void 0,\n        endTime: ue(O.endTime) ? X(O.endTime) : void 0,\n        duration: ue(O.duration) ? Number(O.duration) : 0,\n        packets: ue(O.packets) ? Number(O.packets) : 0,\n        packetRate: ue(O.packetRate) ? Number(O.packetRate) : 0,\n        bytes: ue(O.bytes) ? Number(O.bytes) : 0,\n        headerBytes: ue(O.headerBytes) ? Number(O.headerBytes) : 0,\n        bitrate: ue(O.bitrate) ? Number(O.bitrate) : 0,\n        packetsLost: ue(O.packetsLost) ? Number(O.packetsLost) : 0,\n        packetLossRate: ue(O.packetLossRate) ? Number(O.packetLossRate) : 0,\n        packetLossPercentage: ue(O.packetLossPercentage) ? Number(O.packetLossPercentage) : 0,\n        packetsDuplicate: ue(O.packetsDuplicate) ? Number(O.packetsDuplicate) : 0,\n        packetDuplicateRate: ue(O.packetDuplicateRate) ? Number(O.packetDuplicateRate) : 0,\n        bytesDuplicate: ue(O.bytesDuplicate) ? Number(O.bytesDuplicate) : 0,\n        headerBytesDuplicate: ue(O.headerBytesDuplicate) ? Number(O.headerBytesDuplicate) : 0,\n        bitrateDuplicate: ue(O.bitrateDuplicate) ? Number(O.bitrateDuplicate) : 0,\n        packetsPadding: ue(O.packetsPadding) ? Number(O.packetsPadding) : 0,\n        packetPaddingRate: ue(O.packetPaddingRate) ? Number(O.packetPaddingRate) : 0,\n        bytesPadding: ue(O.bytesPadding) ? Number(O.bytesPadding) : 0,\n        headerBytesPadding: ue(O.headerBytesPadding) ? Number(O.headerBytesPadding) : 0,\n        bitratePadding: ue(O.bitratePadding) ? Number(O.bitratePadding) : 0,\n        packetsOutOfOrder: ue(O.packetsOutOfOrder) ? Number(O.packetsOutOfOrder) : 0,\n        frames: ue(O.frames) ? Number(O.frames) : 0,\n        frameRate: ue(O.frameRate) ? Number(O.frameRate) : 0,\n        jitterCurrent: ue(O.jitterCurrent) ? Number(O.jitterCurrent) : 0,\n        jitterMax: ue(O.jitterMax) ? Number(O.jitterMax) : 0,\n        gapHistogram: Ee(O.gapHistogram) ? Object.entries(O.gapHistogram).reduce((j, [se, _e]) => (j[Number(se)] = Number(_e), j), {}) : {},\n        nacks: ue(O.nacks) ? Number(O.nacks) : 0,\n        nackAcks: ue(O.nackAcks) ? Number(O.nackAcks) : 0,\n        nackMisses: ue(O.nackMisses) ? Number(O.nackMisses) : 0,\n        nackRepeated: ue(O.nackRepeated) ? Number(O.nackRepeated) : 0,\n        plis: ue(O.plis) ? Number(O.plis) : 0,\n        lastPli: ue(O.lastPli) ? X(O.lastPli) : void 0,\n        firs: ue(O.firs) ? Number(O.firs) : 0,\n        lastFir: ue(O.lastFir) ? X(O.lastFir) : void 0,\n        rttCurrent: ue(O.rttCurrent) ? Number(O.rttCurrent) : 0,\n        rttMax: ue(O.rttMax) ? Number(O.rttMax) : 0,\n        keyFrames: ue(O.keyFrames) ? Number(O.keyFrames) : 0,\n        lastKeyFrame: ue(O.lastKeyFrame) ? X(O.lastKeyFrame) : void 0,\n        layerLockPlis: ue(O.layerLockPlis) ? Number(O.layerLockPlis) : 0,\n        lastLayerLockPli: ue(O.lastLayerLockPli) ? X(O.lastLayerLockPli) : void 0\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.startTime !== void 0 && (j.startTime = O.startTime.toISOString()), O.endTime !== void 0 && (j.endTime = O.endTime.toISOString()), O.duration !== void 0 && (j.duration = O.duration), O.packets !== void 0 && (j.packets = Math.round(O.packets)), O.packetRate !== void 0 && (j.packetRate = O.packetRate), O.bytes !== void 0 && (j.bytes = Math.round(O.bytes)), O.headerBytes !== void 0 && (j.headerBytes = Math.round(O.headerBytes)), O.bitrate !== void 0 && (j.bitrate = O.bitrate), O.packetsLost !== void 0 && (j.packetsLost = Math.round(O.packetsLost)), O.packetLossRate !== void 0 && (j.packetLossRate = O.packetLossRate), O.packetLossPercentage !== void 0 && (j.packetLossPercentage = O.packetLossPercentage), O.packetsDuplicate !== void 0 && (j.packetsDuplicate = Math.round(O.packetsDuplicate)), O.packetDuplicateRate !== void 0 && (j.packetDuplicateRate = O.packetDuplicateRate), O.bytesDuplicate !== void 0 && (j.bytesDuplicate = Math.round(O.bytesDuplicate)), O.headerBytesDuplicate !== void 0 && (j.headerBytesDuplicate = Math.round(O.headerBytesDuplicate)), O.bitrateDuplicate !== void 0 && (j.bitrateDuplicate = O.bitrateDuplicate), O.packetsPadding !== void 0 && (j.packetsPadding = Math.round(O.packetsPadding)), O.packetPaddingRate !== void 0 && (j.packetPaddingRate = O.packetPaddingRate), O.bytesPadding !== void 0 && (j.bytesPadding = Math.round(O.bytesPadding)), O.headerBytesPadding !== void 0 && (j.headerBytesPadding = Math.round(O.headerBytesPadding)), O.bitratePadding !== void 0 && (j.bitratePadding = O.bitratePadding), O.packetsOutOfOrder !== void 0 && (j.packetsOutOfOrder = Math.round(O.packetsOutOfOrder)), O.frames !== void 0 && (j.frames = Math.round(O.frames)), O.frameRate !== void 0 && (j.frameRate = O.frameRate), O.jitterCurrent !== void 0 && (j.jitterCurrent = O.jitterCurrent), O.jitterMax !== void 0 && (j.jitterMax = O.jitterMax), j.gapHistogram = {}, O.gapHistogram && Object.entries(O.gapHistogram).forEach(([se, _e]) => {\n        j.gapHistogram[se] = Math.round(_e);\n      }), O.nacks !== void 0 && (j.nacks = Math.round(O.nacks)), O.nackAcks !== void 0 && (j.nackAcks = Math.round(O.nackAcks)), O.nackMisses !== void 0 && (j.nackMisses = Math.round(O.nackMisses)), O.nackRepeated !== void 0 && (j.nackRepeated = Math.round(O.nackRepeated)), O.plis !== void 0 && (j.plis = Math.round(O.plis)), O.lastPli !== void 0 && (j.lastPli = O.lastPli.toISOString()), O.firs !== void 0 && (j.firs = Math.round(O.firs)), O.lastFir !== void 0 && (j.lastFir = O.lastFir.toISOString()), O.rttCurrent !== void 0 && (j.rttCurrent = Math.round(O.rttCurrent)), O.rttMax !== void 0 && (j.rttMax = Math.round(O.rttMax)), O.keyFrames !== void 0 && (j.keyFrames = Math.round(O.keyFrames)), O.lastKeyFrame !== void 0 && (j.lastKeyFrame = O.lastKeyFrame.toISOString()), O.layerLockPlis !== void 0 && (j.layerLockPlis = Math.round(O.layerLockPlis)), O.lastLayerLockPli !== void 0 && (j.lastLayerLockPli = O.lastLayerLockPli.toISOString()), j;\n    },\n    fromPartial(O) {\n      var j, se, _e, ve, De, Ze, Qe, ot, ft, Ce, I, F, z, Te, fe, ke, it, mt, vt, st, ut, yt, gt, bt, St, Et, ct, Xe, Ct, Ot, Nt, Pt, wt, At, Dt, pe, ge, Re, Je, Fe, ze;\n      const Me = me();\n      return Me.startTime = (j = O.startTime) !== null && j !== void 0 ? j : void 0, Me.endTime = (se = O.endTime) !== null && se !== void 0 ? se : void 0, Me.duration = (_e = O.duration) !== null && _e !== void 0 ? _e : 0, Me.packets = (ve = O.packets) !== null && ve !== void 0 ? ve : 0, Me.packetRate = (De = O.packetRate) !== null && De !== void 0 ? De : 0, Me.bytes = (Ze = O.bytes) !== null && Ze !== void 0 ? Ze : 0, Me.headerBytes = (Qe = O.headerBytes) !== null && Qe !== void 0 ? Qe : 0, Me.bitrate = (ot = O.bitrate) !== null && ot !== void 0 ? ot : 0, Me.packetsLost = (ft = O.packetsLost) !== null && ft !== void 0 ? ft : 0, Me.packetLossRate = (Ce = O.packetLossRate) !== null && Ce !== void 0 ? Ce : 0, Me.packetLossPercentage = (I = O.packetLossPercentage) !== null && I !== void 0 ? I : 0, Me.packetsDuplicate = (F = O.packetsDuplicate) !== null && F !== void 0 ? F : 0, Me.packetDuplicateRate = (z = O.packetDuplicateRate) !== null && z !== void 0 ? z : 0, Me.bytesDuplicate = (Te = O.bytesDuplicate) !== null && Te !== void 0 ? Te : 0, Me.headerBytesDuplicate = (fe = O.headerBytesDuplicate) !== null && fe !== void 0 ? fe : 0, Me.bitrateDuplicate = (ke = O.bitrateDuplicate) !== null && ke !== void 0 ? ke : 0, Me.packetsPadding = (it = O.packetsPadding) !== null && it !== void 0 ? it : 0, Me.packetPaddingRate = (mt = O.packetPaddingRate) !== null && mt !== void 0 ? mt : 0, Me.bytesPadding = (vt = O.bytesPadding) !== null && vt !== void 0 ? vt : 0, Me.headerBytesPadding = (st = O.headerBytesPadding) !== null && st !== void 0 ? st : 0, Me.bitratePadding = (ut = O.bitratePadding) !== null && ut !== void 0 ? ut : 0, Me.packetsOutOfOrder = (yt = O.packetsOutOfOrder) !== null && yt !== void 0 ? yt : 0, Me.frames = (gt = O.frames) !== null && gt !== void 0 ? gt : 0, Me.frameRate = (bt = O.frameRate) !== null && bt !== void 0 ? bt : 0, Me.jitterCurrent = (St = O.jitterCurrent) !== null && St !== void 0 ? St : 0, Me.jitterMax = (Et = O.jitterMax) !== null && Et !== void 0 ? Et : 0, Me.gapHistogram = Object.entries((ct = O.gapHistogram) !== null && ct !== void 0 ? ct : {}).reduce((nt, [rt, Tt]) => (Tt !== void 0 && (nt[Number(rt)] = Number(Tt)), nt), {}), Me.nacks = (Xe = O.nacks) !== null && Xe !== void 0 ? Xe : 0, Me.nackAcks = (Ct = O.nackAcks) !== null && Ct !== void 0 ? Ct : 0, Me.nackMisses = (Ot = O.nackMisses) !== null && Ot !== void 0 ? Ot : 0, Me.nackRepeated = (Nt = O.nackRepeated) !== null && Nt !== void 0 ? Nt : 0, Me.plis = (Pt = O.plis) !== null && Pt !== void 0 ? Pt : 0, Me.lastPli = (wt = O.lastPli) !== null && wt !== void 0 ? wt : void 0, Me.firs = (At = O.firs) !== null && At !== void 0 ? At : 0, Me.lastFir = (Dt = O.lastFir) !== null && Dt !== void 0 ? Dt : void 0, Me.rttCurrent = (pe = O.rttCurrent) !== null && pe !== void 0 ? pe : 0, Me.rttMax = (ge = O.rttMax) !== null && ge !== void 0 ? ge : 0, Me.keyFrames = (Re = O.keyFrames) !== null && Re !== void 0 ? Re : 0, Me.lastKeyFrame = (Je = O.lastKeyFrame) !== null && Je !== void 0 ? Je : void 0, Me.layerLockPlis = (Fe = O.layerLockPlis) !== null && Fe !== void 0 ? Fe : 0, Me.lastLayerLockPli = (ze = O.lastLayerLockPli) !== null && ze !== void 0 ? ze : void 0, Me;\n    }\n  };\n  function Ie() {\n    return { key: 0, value: 0 };\n  }\n  a.RTPStats_GapHistogramEntry = {\n    encode(O, j = l.default.Writer.create()) {\n      return O.key !== 0 && j.uint32(8).int32(O.key), O.value !== 0 && j.uint32(16).uint32(O.value), j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = Ie();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.key = se.int32();\n            break;\n          case 2:\n            ve.value = se.uint32();\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return { key: ue(O.key) ? Number(O.key) : 0, value: ue(O.value) ? Number(O.value) : 0 };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.key !== void 0 && (j.key = Math.round(O.key)), O.value !== void 0 && (j.value = Math.round(O.value)), j;\n    },\n    fromPartial(O) {\n      var j, se;\n      const _e = Ie();\n      return _e.key = (j = O.key) !== null && j !== void 0 ? j : 0, _e.value = (se = O.value) !== null && se !== void 0 ? se : 0, _e;\n    }\n  };\n  function at() {\n    return { unixMicro: 0, ticks: 0 };\n  }\n  a.TimedVersion = {\n    encode(O, j = l.default.Writer.create()) {\n      return O.unixMicro !== 0 && j.uint32(8).int64(O.unixMicro), O.ticks !== 0 && j.uint32(16).int32(O.ticks), j;\n    },\n    decode(O, j) {\n      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);\n      let _e = j === void 0 ? se.len : se.pos + j;\n      const ve = at();\n      for (; se.pos < _e; ) {\n        const De = se.uint32();\n        switch (De >>> 3) {\n          case 1:\n            ve.unixMicro = ie(se.int64());\n            break;\n          case 2:\n            ve.ticks = se.int32();\n            break;\n          default:\n            se.skipType(De & 7);\n            break;\n        }\n      }\n      return ve;\n    },\n    fromJSON(O) {\n      return {\n        unixMicro: ue(O.unixMicro) ? Number(O.unixMicro) : 0,\n        ticks: ue(O.ticks) ? Number(O.ticks) : 0\n      };\n    },\n    toJSON(O) {\n      const j = {};\n      return O.unixMicro !== void 0 && (j.unixMicro = Math.round(O.unixMicro)), O.ticks !== void 0 && (j.ticks = Math.round(O.ticks)), j;\n    },\n    fromPartial(O) {\n      var j, se;\n      const _e = at();\n      return _e.unixMicro = (j = O.unixMicro) !== null && j !== void 0 ? j : 0, _e.ticks = (se = O.ticks) !== null && se !== void 0 ? se : 0, _e;\n    }\n  };\n  var Ye = (() => {\n    if (typeof Ye < \"u\")\n      return Ye;\n    if (typeof self < \"u\")\n      return self;\n    if (typeof window < \"u\")\n      return window;\n    if (typeof commonjsGlobal$1 < \"u\")\n      return commonjsGlobal$1;\n    throw \"Unable to locate global object\";\n  })();\n  function je(O) {\n    if (Ye.Buffer)\n      return Uint8Array.from(Ye.Buffer.from(O, \"base64\"));\n    {\n      const j = Ye.atob(O), se = new Uint8Array(j.length);\n      for (let _e = 0; _e < j.length; ++_e)\n        se[_e] = j.charCodeAt(_e);\n      return se;\n    }\n  }\n  function tt(O) {\n    if (Ye.Buffer)\n      return Ye.Buffer.from(O).toString(\"base64\");\n    {\n      const j = [];\n      return O.forEach((se) => {\n        j.push(String.fromCharCode(se));\n      }), Ye.btoa(j.join(\"\"));\n    }\n  }\n  function Oe(O) {\n    const j = O.getTime() / 1e3, se = O.getTime() % 1e3 * 1e6;\n    return { seconds: j, nanos: se };\n  }\n  function P(O) {\n    let j = O.seconds * 1e3;\n    return j += O.nanos / 1e6, new Date(j);\n  }\n  function X(O) {\n    return O instanceof Date ? O : typeof O == \"string\" ? new Date(O) : P(v.Timestamp.fromJSON(O));\n  }\n  function ie(O) {\n    if (O.gt(Number.MAX_SAFE_INTEGER))\n      throw new Ye.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n    return O.toNumber();\n  }\n  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());\n  function Ee(O) {\n    return typeof O == \"object\" && O !== null;\n  }\n  function ue(O) {\n    return O != null;\n  }\n})(livekit_models);\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(A) {\n    return A && A.__esModule ? A : { default: A };\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.DeleteIngressRequest = a.ListIngressResponse = a.ListIngressRequest = a.UpdateIngressRequest = a.InputAudioState = a.InputVideoState = a.IngressState = a.IngressInfo = a.IngressVideoOptions = a.IngressAudioOptions = a.CreateIngressRequest = a.ingressState_StatusToJSON = a.ingressState_StatusFromJSON = a.IngressState_Status = a.ingressInputToJSON = a.ingressInputFromJSON = a.IngressInput = a.protobufPackage = void 0;\n  const c = u(umdExports), l = u(minimal), v = livekit_models;\n  a.protobufPackage = \"livekit\";\n  var S;\n  (function(A) {\n    A[A.RTMP_INPUT = 0] = \"RTMP_INPUT\", A[A.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(S = a.IngressInput || (a.IngressInput = {}));\n  function g(A) {\n    switch (A) {\n      case 0:\n      case \"RTMP_INPUT\":\n        return S.RTMP_INPUT;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return S.UNRECOGNIZED;\n    }\n  }\n  a.ingressInputFromJSON = g;\n  function E(A) {\n    switch (A) {\n      case S.RTMP_INPUT:\n        return \"RTMP_INPUT\";\n      case S.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.ingressInputToJSON = E;\n  var _;\n  (function(A) {\n    A[A.ENDPOINT_INACTIVE = 0] = \"ENDPOINT_INACTIVE\", A[A.ENDPOINT_BUFFERING = 1] = \"ENDPOINT_BUFFERING\", A[A.ENDPOINT_PUBLISHING = 2] = \"ENDPOINT_PUBLISHING\", A[A.ENDPOINT_ERROR = 3] = \"ENDPOINT_ERROR\", A[A.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(_ = a.IngressState_Status || (a.IngressState_Status = {}));\n  function k(A) {\n    switch (A) {\n      case 0:\n      case \"ENDPOINT_INACTIVE\":\n        return _.ENDPOINT_INACTIVE;\n      case 1:\n      case \"ENDPOINT_BUFFERING\":\n        return _.ENDPOINT_BUFFERING;\n      case 2:\n      case \"ENDPOINT_PUBLISHING\":\n        return _.ENDPOINT_PUBLISHING;\n      case 3:\n      case \"ENDPOINT_ERROR\":\n        return _.ENDPOINT_ERROR;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return _.UNRECOGNIZED;\n    }\n  }\n  a.ingressState_StatusFromJSON = k;\n  function L(A) {\n    switch (A) {\n      case _.ENDPOINT_INACTIVE:\n        return \"ENDPOINT_INACTIVE\";\n      case _.ENDPOINT_BUFFERING:\n        return \"ENDPOINT_BUFFERING\";\n      case _.ENDPOINT_PUBLISHING:\n        return \"ENDPOINT_PUBLISHING\";\n      case _.ENDPOINT_ERROR:\n        return \"ENDPOINT_ERROR\";\n      case _.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.ingressState_StatusToJSON = L;\n  function M() {\n    return {\n      inputType: 0,\n      name: \"\",\n      roomName: \"\",\n      participantIdentity: \"\",\n      participantName: \"\",\n      audio: void 0,\n      video: void 0\n    };\n  }\n  a.CreateIngressRequest = {\n    encode(A, N = l.default.Writer.create()) {\n      return A.inputType !== void 0 && A.inputType !== 0 && N.uint32(8).int32(A.inputType), A.name !== void 0 && A.name !== \"\" && N.uint32(18).string(A.name), A.roomName !== void 0 && A.roomName !== \"\" && N.uint32(26).string(A.roomName), A.participantIdentity !== void 0 && A.participantIdentity !== \"\" && N.uint32(34).string(A.participantIdentity), A.participantName !== void 0 && A.participantName !== \"\" && N.uint32(42).string(A.participantName), A.audio !== void 0 && a.IngressAudioOptions.encode(A.audio, N.uint32(50).fork()).ldelim(), A.video !== void 0 && a.IngressVideoOptions.encode(A.video, N.uint32(58).fork()).ldelim(), N;\n    },\n    decode(A, N) {\n      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = M();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.inputType = D.int32();\n            break;\n          case 2:\n            ee.name = D.string();\n            break;\n          case 3:\n            ee.roomName = D.string();\n            break;\n          case 4:\n            ee.participantIdentity = D.string();\n            break;\n          case 5:\n            ee.participantName = D.string();\n            break;\n          case 6:\n            ee.audio = a.IngressAudioOptions.decode(D, D.uint32());\n            break;\n          case 7:\n            ee.video = a.IngressVideoOptions.decode(D, D.uint32());\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return {\n        inputType: de(A.inputType) ? g(A.inputType) : 0,\n        name: de(A.name) ? String(A.name) : \"\",\n        roomName: de(A.roomName) ? String(A.roomName) : \"\",\n        participantIdentity: de(A.participantIdentity) ? String(A.participantIdentity) : \"\",\n        participantName: de(A.participantName) ? String(A.participantName) : \"\",\n        audio: de(A.audio) ? a.IngressAudioOptions.fromJSON(A.audio) : void 0,\n        video: de(A.video) ? a.IngressVideoOptions.fromJSON(A.video) : void 0\n      };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.inputType !== void 0 && (N.inputType = E(A.inputType)), A.name !== void 0 && (N.name = A.name), A.roomName !== void 0 && (N.roomName = A.roomName), A.participantIdentity !== void 0 && (N.participantIdentity = A.participantIdentity), A.participantName !== void 0 && (N.participantName = A.participantName), A.audio !== void 0 && (N.audio = A.audio ? a.IngressAudioOptions.toJSON(A.audio) : void 0), A.video !== void 0 && (N.video = A.video ? a.IngressVideoOptions.toJSON(A.video) : void 0), N;\n    },\n    fromPartial(A) {\n      var N, D, W, ee, ae;\n      const ye = M();\n      return ye.inputType = (N = A.inputType) !== null && N !== void 0 ? N : 0, ye.name = (D = A.name) !== null && D !== void 0 ? D : \"\", ye.roomName = (W = A.roomName) !== null && W !== void 0 ? W : \"\", ye.participantIdentity = (ee = A.participantIdentity) !== null && ee !== void 0 ? ee : \"\", ye.participantName = (ae = A.participantName) !== null && ae !== void 0 ? ae : \"\", ye.audio = A.audio !== void 0 && A.audio !== null ? a.IngressAudioOptions.fromPartial(A.audio) : void 0, ye.video = A.video !== void 0 && A.video !== null ? a.IngressVideoOptions.fromPartial(A.video) : void 0, ye;\n    }\n  };\n  function $() {\n    return { name: \"\", source: 0, mimeType: \"\", bitrate: 0, disableDtx: !1, channels: 0 };\n  }\n  a.IngressAudioOptions = {\n    encode(A, N = l.default.Writer.create()) {\n      return A.name !== void 0 && A.name !== \"\" && N.uint32(10).string(A.name), A.source !== void 0 && A.source !== 0 && N.uint32(16).int32(A.source), A.mimeType !== void 0 && A.mimeType !== \"\" && N.uint32(26).string(A.mimeType), A.bitrate !== void 0 && A.bitrate !== 0 && N.uint32(32).uint32(A.bitrate), A.disableDtx === !0 && N.uint32(40).bool(A.disableDtx), A.channels !== void 0 && A.channels !== 0 && N.uint32(48).uint32(A.channels), N;\n    },\n    decode(A, N) {\n      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = $();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.name = D.string();\n            break;\n          case 2:\n            ee.source = D.int32();\n            break;\n          case 3:\n            ee.mimeType = D.string();\n            break;\n          case 4:\n            ee.bitrate = D.uint32();\n            break;\n          case 5:\n            ee.disableDtx = D.bool();\n            break;\n          case 6:\n            ee.channels = D.uint32();\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return {\n        name: de(A.name) ? String(A.name) : \"\",\n        source: de(A.source) ? v.trackSourceFromJSON(A.source) : 0,\n        mimeType: de(A.mimeType) ? String(A.mimeType) : \"\",\n        bitrate: de(A.bitrate) ? Number(A.bitrate) : 0,\n        disableDtx: de(A.disableDtx) ? !!A.disableDtx : !1,\n        channels: de(A.channels) ? Number(A.channels) : 0\n      };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.name !== void 0 && (N.name = A.name), A.source !== void 0 && (N.source = v.trackSourceToJSON(A.source)), A.mimeType !== void 0 && (N.mimeType = A.mimeType), A.bitrate !== void 0 && (N.bitrate = Math.round(A.bitrate)), A.disableDtx !== void 0 && (N.disableDtx = A.disableDtx), A.channels !== void 0 && (N.channels = Math.round(A.channels)), N;\n    },\n    fromPartial(A) {\n      var N, D, W, ee, ae, ye;\n      const he = $();\n      return he.name = (N = A.name) !== null && N !== void 0 ? N : \"\", he.source = (D = A.source) !== null && D !== void 0 ? D : 0, he.mimeType = (W = A.mimeType) !== null && W !== void 0 ? W : \"\", he.bitrate = (ee = A.bitrate) !== null && ee !== void 0 ? ee : 0, he.disableDtx = (ae = A.disableDtx) !== null && ae !== void 0 ? ae : !1, he.channels = (ye = A.channels) !== null && ye !== void 0 ? ye : 0, he;\n    }\n  };\n  function J() {\n    return { name: \"\", source: 0, mimeType: \"\", layers: [] };\n  }\n  a.IngressVideoOptions = {\n    encode(A, N = l.default.Writer.create()) {\n      if (A.name !== void 0 && A.name !== \"\" && N.uint32(10).string(A.name), A.source !== void 0 && A.source !== 0 && N.uint32(16).int32(A.source), A.mimeType !== void 0 && A.mimeType !== \"\" && N.uint32(26).string(A.mimeType), A.layers !== void 0 && A.layers.length !== 0)\n        for (const D of A.layers)\n          v.VideoLayer.encode(D, N.uint32(34).fork()).ldelim();\n      return N;\n    },\n    decode(A, N) {\n      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = J();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.name = D.string();\n            break;\n          case 2:\n            ee.source = D.int32();\n            break;\n          case 3:\n            ee.mimeType = D.string();\n            break;\n          case 4:\n            ee.layers.push(v.VideoLayer.decode(D, D.uint32()));\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return {\n        name: de(A.name) ? String(A.name) : \"\",\n        source: de(A.source) ? v.trackSourceFromJSON(A.source) : 0,\n        mimeType: de(A.mimeType) ? String(A.mimeType) : \"\",\n        layers: Array.isArray(A == null ? void 0 : A.layers) ? A.layers.map((N) => v.VideoLayer.fromJSON(N)) : []\n      };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.name !== void 0 && (N.name = A.name), A.source !== void 0 && (N.source = v.trackSourceToJSON(A.source)), A.mimeType !== void 0 && (N.mimeType = A.mimeType), A.layers ? N.layers = A.layers.map((D) => D ? v.VideoLayer.toJSON(D) : void 0) : N.layers = [], N;\n    },\n    fromPartial(A) {\n      var N, D, W, ee;\n      const ae = J();\n      return ae.name = (N = A.name) !== null && N !== void 0 ? N : \"\", ae.source = (D = A.source) !== null && D !== void 0 ? D : 0, ae.mimeType = (W = A.mimeType) !== null && W !== void 0 ? W : \"\", ae.layers = ((ee = A.layers) === null || ee === void 0 ? void 0 : ee.map((ye) => v.VideoLayer.fromPartial(ye))) || [], ae;\n    }\n  };\n  function V() {\n    return {\n      ingressId: \"\",\n      name: \"\",\n      streamKey: \"\",\n      url: \"\",\n      inputType: 0,\n      audio: void 0,\n      video: void 0,\n      roomName: \"\",\n      participantIdentity: \"\",\n      participantName: \"\",\n      reusable: !1,\n      state: void 0\n    };\n  }\n  a.IngressInfo = {\n    encode(A, N = l.default.Writer.create()) {\n      return A.ingressId !== void 0 && A.ingressId !== \"\" && N.uint32(10).string(A.ingressId), A.name !== void 0 && A.name !== \"\" && N.uint32(18).string(A.name), A.streamKey !== void 0 && A.streamKey !== \"\" && N.uint32(26).string(A.streamKey), A.url !== void 0 && A.url !== \"\" && N.uint32(34).string(A.url), A.inputType !== void 0 && A.inputType !== 0 && N.uint32(40).int32(A.inputType), A.audio !== void 0 && a.IngressAudioOptions.encode(A.audio, N.uint32(50).fork()).ldelim(), A.video !== void 0 && a.IngressVideoOptions.encode(A.video, N.uint32(58).fork()).ldelim(), A.roomName !== void 0 && A.roomName !== \"\" && N.uint32(66).string(A.roomName), A.participantIdentity !== void 0 && A.participantIdentity !== \"\" && N.uint32(74).string(A.participantIdentity), A.participantName !== void 0 && A.participantName !== \"\" && N.uint32(82).string(A.participantName), A.reusable === !0 && N.uint32(88).bool(A.reusable), A.state !== void 0 && a.IngressState.encode(A.state, N.uint32(98).fork()).ldelim(), N;\n    },\n    decode(A, N) {\n      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = V();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.ingressId = D.string();\n            break;\n          case 2:\n            ee.name = D.string();\n            break;\n          case 3:\n            ee.streamKey = D.string();\n            break;\n          case 4:\n            ee.url = D.string();\n            break;\n          case 5:\n            ee.inputType = D.int32();\n            break;\n          case 6:\n            ee.audio = a.IngressAudioOptions.decode(D, D.uint32());\n            break;\n          case 7:\n            ee.video = a.IngressVideoOptions.decode(D, D.uint32());\n            break;\n          case 8:\n            ee.roomName = D.string();\n            break;\n          case 9:\n            ee.participantIdentity = D.string();\n            break;\n          case 10:\n            ee.participantName = D.string();\n            break;\n          case 11:\n            ee.reusable = D.bool();\n            break;\n          case 12:\n            ee.state = a.IngressState.decode(D, D.uint32());\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return {\n        ingressId: de(A.ingressId) ? String(A.ingressId) : \"\",\n        name: de(A.name) ? String(A.name) : \"\",\n        streamKey: de(A.streamKey) ? String(A.streamKey) : \"\",\n        url: de(A.url) ? String(A.url) : \"\",\n        inputType: de(A.inputType) ? g(A.inputType) : 0,\n        audio: de(A.audio) ? a.IngressAudioOptions.fromJSON(A.audio) : void 0,\n        video: de(A.video) ? a.IngressVideoOptions.fromJSON(A.video) : void 0,\n        roomName: de(A.roomName) ? String(A.roomName) : \"\",\n        participantIdentity: de(A.participantIdentity) ? String(A.participantIdentity) : \"\",\n        participantName: de(A.participantName) ? String(A.participantName) : \"\",\n        reusable: de(A.reusable) ? !!A.reusable : !1,\n        state: de(A.state) ? a.IngressState.fromJSON(A.state) : void 0\n      };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.ingressId !== void 0 && (N.ingressId = A.ingressId), A.name !== void 0 && (N.name = A.name), A.streamKey !== void 0 && (N.streamKey = A.streamKey), A.url !== void 0 && (N.url = A.url), A.inputType !== void 0 && (N.inputType = E(A.inputType)), A.audio !== void 0 && (N.audio = A.audio ? a.IngressAudioOptions.toJSON(A.audio) : void 0), A.video !== void 0 && (N.video = A.video ? a.IngressVideoOptions.toJSON(A.video) : void 0), A.roomName !== void 0 && (N.roomName = A.roomName), A.participantIdentity !== void 0 && (N.participantIdentity = A.participantIdentity), A.participantName !== void 0 && (N.participantName = A.participantName), A.reusable !== void 0 && (N.reusable = A.reusable), A.state !== void 0 && (N.state = A.state ? a.IngressState.toJSON(A.state) : void 0), N;\n    },\n    fromPartial(A) {\n      var N, D, W, ee, ae, ye, he, le, we;\n      const Be = V();\n      return Be.ingressId = (N = A.ingressId) !== null && N !== void 0 ? N : \"\", Be.name = (D = A.name) !== null && D !== void 0 ? D : \"\", Be.streamKey = (W = A.streamKey) !== null && W !== void 0 ? W : \"\", Be.url = (ee = A.url) !== null && ee !== void 0 ? ee : \"\", Be.inputType = (ae = A.inputType) !== null && ae !== void 0 ? ae : 0, Be.audio = A.audio !== void 0 && A.audio !== null ? a.IngressAudioOptions.fromPartial(A.audio) : void 0, Be.video = A.video !== void 0 && A.video !== null ? a.IngressVideoOptions.fromPartial(A.video) : void 0, Be.roomName = (ye = A.roomName) !== null && ye !== void 0 ? ye : \"\", Be.participantIdentity = (he = A.participantIdentity) !== null && he !== void 0 ? he : \"\", Be.participantName = (le = A.participantName) !== null && le !== void 0 ? le : \"\", Be.reusable = (we = A.reusable) !== null && we !== void 0 ? we : !1, Be.state = A.state !== void 0 && A.state !== null ? a.IngressState.fromPartial(A.state) : void 0, Be;\n    }\n  };\n  function q() {\n    return { status: 0, error: \"\", video: void 0, audio: void 0, roomId: \"\", startedAt: 0, tracks: [] };\n  }\n  a.IngressState = {\n    encode(A, N = l.default.Writer.create()) {\n      if (A.status !== void 0 && A.status !== 0 && N.uint32(8).int32(A.status), A.error !== void 0 && A.error !== \"\" && N.uint32(18).string(A.error), A.video !== void 0 && a.InputVideoState.encode(A.video, N.uint32(26).fork()).ldelim(), A.audio !== void 0 && a.InputAudioState.encode(A.audio, N.uint32(34).fork()).ldelim(), A.roomId !== void 0 && A.roomId !== \"\" && N.uint32(42).string(A.roomId), A.startedAt !== void 0 && A.startedAt !== 0 && N.uint32(56).int64(A.startedAt), A.tracks !== void 0 && A.tracks.length !== 0)\n        for (const D of A.tracks)\n          v.TrackInfo.encode(D, N.uint32(50).fork()).ldelim();\n      return N;\n    },\n    decode(A, N) {\n      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = q();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.status = D.int32();\n            break;\n          case 2:\n            ee.error = D.string();\n            break;\n          case 3:\n            ee.video = a.InputVideoState.decode(D, D.uint32());\n            break;\n          case 4:\n            ee.audio = a.InputAudioState.decode(D, D.uint32());\n            break;\n          case 5:\n            ee.roomId = D.string();\n            break;\n          case 7:\n            ee.startedAt = oe(D.int64());\n            break;\n          case 6:\n            ee.tracks.push(v.TrackInfo.decode(D, D.uint32()));\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return {\n        status: de(A.status) ? k(A.status) : 0,\n        error: de(A.error) ? String(A.error) : \"\",\n        video: de(A.video) ? a.InputVideoState.fromJSON(A.video) : void 0,\n        audio: de(A.audio) ? a.InputAudioState.fromJSON(A.audio) : void 0,\n        roomId: de(A.roomId) ? String(A.roomId) : \"\",\n        startedAt: de(A.startedAt) ? Number(A.startedAt) : 0,\n        tracks: Array.isArray(A == null ? void 0 : A.tracks) ? A.tracks.map((N) => v.TrackInfo.fromJSON(N)) : []\n      };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.status !== void 0 && (N.status = L(A.status)), A.error !== void 0 && (N.error = A.error), A.video !== void 0 && (N.video = A.video ? a.InputVideoState.toJSON(A.video) : void 0), A.audio !== void 0 && (N.audio = A.audio ? a.InputAudioState.toJSON(A.audio) : void 0), A.roomId !== void 0 && (N.roomId = A.roomId), A.startedAt !== void 0 && (N.startedAt = Math.round(A.startedAt)), A.tracks ? N.tracks = A.tracks.map((D) => D ? v.TrackInfo.toJSON(D) : void 0) : N.tracks = [], N;\n    },\n    fromPartial(A) {\n      var N, D, W, ee, ae;\n      const ye = q();\n      return ye.status = (N = A.status) !== null && N !== void 0 ? N : 0, ye.error = (D = A.error) !== null && D !== void 0 ? D : \"\", ye.video = A.video !== void 0 && A.video !== null ? a.InputVideoState.fromPartial(A.video) : void 0, ye.audio = A.audio !== void 0 && A.audio !== null ? a.InputAudioState.fromPartial(A.audio) : void 0, ye.roomId = (W = A.roomId) !== null && W !== void 0 ? W : \"\", ye.startedAt = (ee = A.startedAt) !== null && ee !== void 0 ? ee : 0, ye.tracks = ((ae = A.tracks) === null || ae === void 0 ? void 0 : ae.map((he) => v.TrackInfo.fromPartial(he))) || [], ye;\n    }\n  };\n  function G() {\n    return { mimeType: 0, width: 0, height: 0, framerate: 0 };\n  }\n  a.InputVideoState = {\n    encode(A, N = l.default.Writer.create()) {\n      return A.mimeType !== void 0 && A.mimeType !== 0 && N.uint32(8).uint32(A.mimeType), A.width !== void 0 && A.width !== 0 && N.uint32(24).uint32(A.width), A.height !== void 0 && A.height !== 0 && N.uint32(32).uint32(A.height), A.framerate !== void 0 && A.framerate !== 0 && N.uint32(40).uint32(A.framerate), N;\n    },\n    decode(A, N) {\n      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = G();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.mimeType = D.uint32();\n            break;\n          case 3:\n            ee.width = D.uint32();\n            break;\n          case 4:\n            ee.height = D.uint32();\n            break;\n          case 5:\n            ee.framerate = D.uint32();\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return {\n        mimeType: de(A.mimeType) ? Number(A.mimeType) : 0,\n        width: de(A.width) ? Number(A.width) : 0,\n        height: de(A.height) ? Number(A.height) : 0,\n        framerate: de(A.framerate) ? Number(A.framerate) : 0\n      };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.mimeType !== void 0 && (N.mimeType = Math.round(A.mimeType)), A.width !== void 0 && (N.width = Math.round(A.width)), A.height !== void 0 && (N.height = Math.round(A.height)), A.framerate !== void 0 && (N.framerate = Math.round(A.framerate)), N;\n    },\n    fromPartial(A) {\n      var N, D, W, ee;\n      const ae = G();\n      return ae.mimeType = (N = A.mimeType) !== null && N !== void 0 ? N : 0, ae.width = (D = A.width) !== null && D !== void 0 ? D : 0, ae.height = (W = A.height) !== null && W !== void 0 ? W : 0, ae.framerate = (ee = A.framerate) !== null && ee !== void 0 ? ee : 0, ae;\n    }\n  };\n  function H() {\n    return { mimeType: 0, channels: 0, sampleRate: 0 };\n  }\n  a.InputAudioState = {\n    encode(A, N = l.default.Writer.create()) {\n      return A.mimeType !== void 0 && A.mimeType !== 0 && N.uint32(8).uint32(A.mimeType), A.channels !== void 0 && A.channels !== 0 && N.uint32(24).uint32(A.channels), A.sampleRate !== void 0 && A.sampleRate !== 0 && N.uint32(32).uint32(A.sampleRate), N;\n    },\n    decode(A, N) {\n      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = H();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.mimeType = D.uint32();\n            break;\n          case 3:\n            ee.channels = D.uint32();\n            break;\n          case 4:\n            ee.sampleRate = D.uint32();\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return {\n        mimeType: de(A.mimeType) ? Number(A.mimeType) : 0,\n        channels: de(A.channels) ? Number(A.channels) : 0,\n        sampleRate: de(A.sampleRate) ? Number(A.sampleRate) : 0\n      };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.mimeType !== void 0 && (N.mimeType = Math.round(A.mimeType)), A.channels !== void 0 && (N.channels = Math.round(A.channels)), A.sampleRate !== void 0 && (N.sampleRate = Math.round(A.sampleRate)), N;\n    },\n    fromPartial(A) {\n      var N, D, W;\n      const ee = H();\n      return ee.mimeType = (N = A.mimeType) !== null && N !== void 0 ? N : 0, ee.channels = (D = A.channels) !== null && D !== void 0 ? D : 0, ee.sampleRate = (W = A.sampleRate) !== null && W !== void 0 ? W : 0, ee;\n    }\n  };\n  function B() {\n    return {\n      ingressId: \"\",\n      name: \"\",\n      roomName: \"\",\n      participantIdentity: \"\",\n      participantName: \"\",\n      audio: void 0,\n      video: void 0\n    };\n  }\n  a.UpdateIngressRequest = {\n    encode(A, N = l.default.Writer.create()) {\n      return A.ingressId !== void 0 && A.ingressId !== \"\" && N.uint32(10).string(A.ingressId), A.name !== void 0 && A.name !== \"\" && N.uint32(18).string(A.name), A.roomName !== void 0 && A.roomName !== \"\" && N.uint32(26).string(A.roomName), A.participantIdentity !== void 0 && A.participantIdentity !== \"\" && N.uint32(34).string(A.participantIdentity), A.participantName !== void 0 && A.participantName !== \"\" && N.uint32(42).string(A.participantName), A.audio !== void 0 && a.IngressAudioOptions.encode(A.audio, N.uint32(50).fork()).ldelim(), A.video !== void 0 && a.IngressVideoOptions.encode(A.video, N.uint32(58).fork()).ldelim(), N;\n    },\n    decode(A, N) {\n      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = B();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.ingressId = D.string();\n            break;\n          case 2:\n            ee.name = D.string();\n            break;\n          case 3:\n            ee.roomName = D.string();\n            break;\n          case 4:\n            ee.participantIdentity = D.string();\n            break;\n          case 5:\n            ee.participantName = D.string();\n            break;\n          case 6:\n            ee.audio = a.IngressAudioOptions.decode(D, D.uint32());\n            break;\n          case 7:\n            ee.video = a.IngressVideoOptions.decode(D, D.uint32());\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return {\n        ingressId: de(A.ingressId) ? String(A.ingressId) : \"\",\n        name: de(A.name) ? String(A.name) : \"\",\n        roomName: de(A.roomName) ? String(A.roomName) : \"\",\n        participantIdentity: de(A.participantIdentity) ? String(A.participantIdentity) : \"\",\n        participantName: de(A.participantName) ? String(A.participantName) : \"\",\n        audio: de(A.audio) ? a.IngressAudioOptions.fromJSON(A.audio) : void 0,\n        video: de(A.video) ? a.IngressVideoOptions.fromJSON(A.video) : void 0\n      };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.ingressId !== void 0 && (N.ingressId = A.ingressId), A.name !== void 0 && (N.name = A.name), A.roomName !== void 0 && (N.roomName = A.roomName), A.participantIdentity !== void 0 && (N.participantIdentity = A.participantIdentity), A.participantName !== void 0 && (N.participantName = A.participantName), A.audio !== void 0 && (N.audio = A.audio ? a.IngressAudioOptions.toJSON(A.audio) : void 0), A.video !== void 0 && (N.video = A.video ? a.IngressVideoOptions.toJSON(A.video) : void 0), N;\n    },\n    fromPartial(A) {\n      var N, D, W, ee, ae;\n      const ye = B();\n      return ye.ingressId = (N = A.ingressId) !== null && N !== void 0 ? N : \"\", ye.name = (D = A.name) !== null && D !== void 0 ? D : \"\", ye.roomName = (W = A.roomName) !== null && W !== void 0 ? W : \"\", ye.participantIdentity = (ee = A.participantIdentity) !== null && ee !== void 0 ? ee : \"\", ye.participantName = (ae = A.participantName) !== null && ae !== void 0 ? ae : \"\", ye.audio = A.audio !== void 0 && A.audio !== null ? a.IngressAudioOptions.fromPartial(A.audio) : void 0, ye.video = A.video !== void 0 && A.video !== null ? a.IngressVideoOptions.fromPartial(A.video) : void 0, ye;\n    }\n  };\n  function Y() {\n    return { roomName: \"\" };\n  }\n  a.ListIngressRequest = {\n    encode(A, N = l.default.Writer.create()) {\n      return A.roomName !== void 0 && A.roomName !== \"\" && N.uint32(10).string(A.roomName), N;\n    },\n    decode(A, N) {\n      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = Y();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.roomName = D.string();\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return { roomName: de(A.roomName) ? String(A.roomName) : \"\" };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.roomName !== void 0 && (N.roomName = A.roomName), N;\n    },\n    fromPartial(A) {\n      var N;\n      const D = Y();\n      return D.roomName = (N = A.roomName) !== null && N !== void 0 ? N : \"\", D;\n    }\n  };\n  function ne() {\n    return { items: [] };\n  }\n  a.ListIngressResponse = {\n    encode(A, N = l.default.Writer.create()) {\n      if (A.items !== void 0 && A.items.length !== 0)\n        for (const D of A.items)\n          a.IngressInfo.encode(D, N.uint32(10).fork()).ldelim();\n      return N;\n    },\n    decode(A, N) {\n      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = ne();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.items.push(a.IngressInfo.decode(D, D.uint32()));\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return { items: Array.isArray(A == null ? void 0 : A.items) ? A.items.map((N) => a.IngressInfo.fromJSON(N)) : [] };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.items ? N.items = A.items.map((D) => D ? a.IngressInfo.toJSON(D) : void 0) : N.items = [], N;\n    },\n    fromPartial(A) {\n      var N;\n      const D = ne();\n      return D.items = ((N = A.items) === null || N === void 0 ? void 0 : N.map((W) => a.IngressInfo.fromPartial(W))) || [], D;\n    }\n  };\n  function Z() {\n    return { ingressId: \"\" };\n  }\n  a.DeleteIngressRequest = {\n    encode(A, N = l.default.Writer.create()) {\n      return A.ingressId !== void 0 && A.ingressId !== \"\" && N.uint32(10).string(A.ingressId), N;\n    },\n    decode(A, N) {\n      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);\n      let W = N === void 0 ? D.len : D.pos + N;\n      const ee = Z();\n      for (; D.pos < W; ) {\n        const ae = D.uint32();\n        switch (ae >>> 3) {\n          case 1:\n            ee.ingressId = D.string();\n            break;\n          default:\n            D.skipType(ae & 7);\n            break;\n        }\n      }\n      return ee;\n    },\n    fromJSON(A) {\n      return { ingressId: de(A.ingressId) ? String(A.ingressId) : \"\" };\n    },\n    toJSON(A) {\n      const N = {};\n      return A.ingressId !== void 0 && (N.ingressId = A.ingressId), N;\n    },\n    fromPartial(A) {\n      var N;\n      const D = Z();\n      return D.ingressId = (N = A.ingressId) !== null && N !== void 0 ? N : \"\", D;\n    }\n  };\n  var re = (() => {\n    if (typeof re < \"u\")\n      return re;\n    if (typeof self < \"u\")\n      return self;\n    if (typeof window < \"u\")\n      return window;\n    if (typeof commonjsGlobal$1 < \"u\")\n      return commonjsGlobal$1;\n    throw \"Unable to locate global object\";\n  })();\n  function oe(A) {\n    if (A.gt(Number.MAX_SAFE_INTEGER))\n      throw new re.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n    return A.toNumber();\n  }\n  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());\n  function de(A) {\n    return A != null;\n  }\n})(livekit_ingress);\nvar __awaiter$2 = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {\n  function v(S) {\n    return S instanceof c ? S : new c(function(g) {\n      g(S);\n    });\n  }\n  return new (c || (c = Promise))(function(S, g) {\n    function E(L) {\n      try {\n        k(l.next(L));\n      } catch (M) {\n        g(M);\n      }\n    }\n    function _(L) {\n      try {\n        k(l.throw(L));\n      } catch (M) {\n        g(M);\n      }\n    }\n    function k(L) {\n      L.done ? S(L.value) : v(L.value).then(E, _);\n    }\n    k((l = l.apply(a, u || [])).next());\n  });\n}, __importDefault$3 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(IngressClient$1, \"__esModule\", { value: !0 });\nIngressClient$1.IngressClient = void 0;\nconst livekit_ingress_1$1 = livekit_ingress, ServiceBase_1$1 = __importDefault$3(ServiceBase$1), TwirpRPC_1$1 = TwirpRPC, svc$1 = \"Ingress\";\nclass IngressClient extends ServiceBase_1$1.default {\n  /**\n   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'\n   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY\n   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET\n   */\n  constructor(u, c, l) {\n    super(c, l), this.rpc = new TwirpRPC_1$1.TwirpRpc(u, TwirpRPC_1$1.livekitPackage);\n  }\n  /**\n   * @param inputType protocol for the ingress\n   * @param opts CreateIngressOptions\n   */\n  createIngress(u, c) {\n    return __awaiter$2(this, void 0, void 0, function* () {\n      let l = \"\", v = \"\", S = \"\", g = \"\", E, _;\n      c !== void 0 && (l = c.name || \"\", v = c.roomName || \"\", S = c.participantName || \"\", g = c.participantIdentity || \"\", E = c.audioParams, _ = c.videoParams);\n      const k = livekit_ingress_1$1.CreateIngressRequest.toJSON({\n        inputType: u,\n        name: l,\n        roomName: v,\n        participantIdentity: g,\n        participantName: S,\n        audio: E,\n        video: _\n      }), L = yield this.rpc.request(svc$1, \"CreateIngress\", k, this.authHeader({ ingressAdmin: !0 }));\n      return livekit_ingress_1$1.IngressInfo.fromJSON(L);\n    });\n  }\n  /**\n   * @param ingressId ID of the ingress to update\n   * @param opts UpdateIngressOptions\n   */\n  updateIngress(u, c) {\n    return __awaiter$2(this, void 0, void 0, function* () {\n      const l = c.name || \"\", v = c.roomName || \"\", S = c.participantName || \"\", g = c.participantIdentity || \"\", E = c.audioParams, _ = c.videoParams, k = livekit_ingress_1$1.UpdateIngressRequest.toJSON({\n        ingressId: u,\n        name: l,\n        roomName: v,\n        participantIdentity: g,\n        participantName: S,\n        audio: E,\n        video: _\n      }), L = yield this.rpc.request(svc$1, \"UpdateIngress\", k, this.authHeader({ ingressAdmin: !0 }));\n      return livekit_ingress_1$1.IngressInfo.fromJSON(L);\n    });\n  }\n  /**\n   * @param roomName list ingress for one room only\n   */\n  listIngress(u) {\n    var c;\n    return __awaiter$2(this, void 0, void 0, function* () {\n      u ?? (u = \"\");\n      const l = yield this.rpc.request(svc$1, \"ListIngress\", livekit_ingress_1$1.ListIngressRequest.toJSON({ roomName: u }), this.authHeader({ ingressAdmin: !0 }));\n      return (c = livekit_ingress_1$1.ListIngressResponse.fromJSON(l).items) !== null && c !== void 0 ? c : [];\n    });\n  }\n  /**\n   * @param ingressId ingress to delete\n   */\n  deleteIngress(u) {\n    return __awaiter$2(this, void 0, void 0, function* () {\n      const c = yield this.rpc.request(svc$1, \"DeleteIngress\", livekit_ingress_1$1.DeleteIngressRequest.toJSON({ ingressId: u }), this.authHeader({ ingressAdmin: !0 }));\n      return livekit_ingress_1$1.IngressInfo.fromJSON(c);\n    });\n  }\n}\nIngressClient$1.IngressClient = IngressClient;\nvar RoomServiceClient$1 = {}, livekit_room = {};\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(D) {\n    return D && D.__esModule ? D : { default: D };\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.UpdateRoomMetadataRequest = a.SendDataResponse = a.SendDataRequest = a.UpdateSubscriptionsResponse = a.UpdateSubscriptionsRequest = a.UpdateParticipantRequest = a.MuteRoomTrackResponse = a.MuteRoomTrackRequest = a.RemoveParticipantResponse = a.RoomParticipantIdentity = a.ListParticipantsResponse = a.ListParticipantsRequest = a.DeleteRoomResponse = a.DeleteRoomRequest = a.ListRoomsResponse = a.ListRoomsRequest = a.RoomEgress = a.CreateRoomRequest = a.protobufPackage = void 0;\n  const c = u(minimal), l = livekit_egress, v = livekit_models;\n  a.protobufPackage = \"livekit\";\n  function S() {\n    return { name: \"\", emptyTimeout: 0, maxParticipants: 0, nodeId: \"\", metadata: \"\", egress: void 0 };\n  }\n  a.CreateRoomRequest = {\n    encode(D, W = c.default.Writer.create()) {\n      return D.name !== void 0 && D.name !== \"\" && W.uint32(10).string(D.name), D.emptyTimeout !== void 0 && D.emptyTimeout !== 0 && W.uint32(16).uint32(D.emptyTimeout), D.maxParticipants !== void 0 && D.maxParticipants !== 0 && W.uint32(24).uint32(D.maxParticipants), D.nodeId !== void 0 && D.nodeId !== \"\" && W.uint32(34).string(D.nodeId), D.metadata !== void 0 && D.metadata !== \"\" && W.uint32(42).string(D.metadata), D.egress !== void 0 && a.RoomEgress.encode(D.egress, W.uint32(50).fork()).ldelim(), W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = S();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          case 1:\n            ye.name = ee.string();\n            break;\n          case 2:\n            ye.emptyTimeout = ee.uint32();\n            break;\n          case 3:\n            ye.maxParticipants = ee.uint32();\n            break;\n          case 4:\n            ye.nodeId = ee.string();\n            break;\n          case 5:\n            ye.metadata = ee.string();\n            break;\n          case 6:\n            ye.egress = a.RoomEgress.decode(ee, ee.uint32());\n            break;\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return {\n        name: N(D.name) ? String(D.name) : \"\",\n        emptyTimeout: N(D.emptyTimeout) ? Number(D.emptyTimeout) : 0,\n        maxParticipants: N(D.maxParticipants) ? Number(D.maxParticipants) : 0,\n        nodeId: N(D.nodeId) ? String(D.nodeId) : \"\",\n        metadata: N(D.metadata) ? String(D.metadata) : \"\",\n        egress: N(D.egress) ? a.RoomEgress.fromJSON(D.egress) : void 0\n      };\n    },\n    toJSON(D) {\n      const W = {};\n      return D.name !== void 0 && (W.name = D.name), D.emptyTimeout !== void 0 && (W.emptyTimeout = Math.round(D.emptyTimeout)), D.maxParticipants !== void 0 && (W.maxParticipants = Math.round(D.maxParticipants)), D.nodeId !== void 0 && (W.nodeId = D.nodeId), D.metadata !== void 0 && (W.metadata = D.metadata), D.egress !== void 0 && (W.egress = D.egress ? a.RoomEgress.toJSON(D.egress) : void 0), W;\n    },\n    fromPartial(D) {\n      var W, ee, ae, ye, he;\n      const le = S();\n      return le.name = (W = D.name) !== null && W !== void 0 ? W : \"\", le.emptyTimeout = (ee = D.emptyTimeout) !== null && ee !== void 0 ? ee : 0, le.maxParticipants = (ae = D.maxParticipants) !== null && ae !== void 0 ? ae : 0, le.nodeId = (ye = D.nodeId) !== null && ye !== void 0 ? ye : \"\", le.metadata = (he = D.metadata) !== null && he !== void 0 ? he : \"\", le.egress = D.egress !== void 0 && D.egress !== null ? a.RoomEgress.fromPartial(D.egress) : void 0, le;\n    }\n  };\n  function g() {\n    return { room: void 0, tracks: void 0 };\n  }\n  a.RoomEgress = {\n    encode(D, W = c.default.Writer.create()) {\n      return D.room !== void 0 && l.RoomCompositeEgressRequest.encode(D.room, W.uint32(10).fork()).ldelim(), D.tracks !== void 0 && l.AutoTrackEgress.encode(D.tracks, W.uint32(18).fork()).ldelim(), W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = g();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          case 1:\n            ye.room = l.RoomCompositeEgressRequest.decode(ee, ee.uint32());\n            break;\n          case 2:\n            ye.tracks = l.AutoTrackEgress.decode(ee, ee.uint32());\n            break;\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return {\n        room: N(D.room) ? l.RoomCompositeEgressRequest.fromJSON(D.room) : void 0,\n        tracks: N(D.tracks) ? l.AutoTrackEgress.fromJSON(D.tracks) : void 0\n      };\n    },\n    toJSON(D) {\n      const W = {};\n      return D.room !== void 0 && (W.room = D.room ? l.RoomCompositeEgressRequest.toJSON(D.room) : void 0), D.tracks !== void 0 && (W.tracks = D.tracks ? l.AutoTrackEgress.toJSON(D.tracks) : void 0), W;\n    },\n    fromPartial(D) {\n      const W = g();\n      return W.room = D.room !== void 0 && D.room !== null ? l.RoomCompositeEgressRequest.fromPartial(D.room) : void 0, W.tracks = D.tracks !== void 0 && D.tracks !== null ? l.AutoTrackEgress.fromPartial(D.tracks) : void 0, W;\n    }\n  };\n  function E() {\n    return { names: [] };\n  }\n  a.ListRoomsRequest = {\n    encode(D, W = c.default.Writer.create()) {\n      if (D.names !== void 0 && D.names.length !== 0)\n        for (const ee of D.names)\n          W.uint32(10).string(ee);\n      return W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = E();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          case 1:\n            ye.names.push(ee.string());\n            break;\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return { names: Array.isArray(D == null ? void 0 : D.names) ? D.names.map((W) => String(W)) : [] };\n    },\n    toJSON(D) {\n      const W = {};\n      return D.names ? W.names = D.names.map((ee) => ee) : W.names = [], W;\n    },\n    fromPartial(D) {\n      var W;\n      const ee = E();\n      return ee.names = ((W = D.names) === null || W === void 0 ? void 0 : W.map((ae) => ae)) || [], ee;\n    }\n  };\n  function _() {\n    return { rooms: [] };\n  }\n  a.ListRoomsResponse = {\n    encode(D, W = c.default.Writer.create()) {\n      if (D.rooms !== void 0 && D.rooms.length !== 0)\n        for (const ee of D.rooms)\n          v.Room.encode(ee, W.uint32(10).fork()).ldelim();\n      return W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = _();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          case 1:\n            ye.rooms.push(v.Room.decode(ee, ee.uint32()));\n            break;\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return { rooms: Array.isArray(D == null ? void 0 : D.rooms) ? D.rooms.map((W) => v.Room.fromJSON(W)) : [] };\n    },\n    toJSON(D) {\n      const W = {};\n      return D.rooms ? W.rooms = D.rooms.map((ee) => ee ? v.Room.toJSON(ee) : void 0) : W.rooms = [], W;\n    },\n    fromPartial(D) {\n      var W;\n      const ee = _();\n      return ee.rooms = ((W = D.rooms) === null || W === void 0 ? void 0 : W.map((ae) => v.Room.fromPartial(ae))) || [], ee;\n    }\n  };\n  function k() {\n    return { room: \"\" };\n  }\n  a.DeleteRoomRequest = {\n    encode(D, W = c.default.Writer.create()) {\n      return D.room !== void 0 && D.room !== \"\" && W.uint32(10).string(D.room), W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = k();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          case 1:\n            ye.room = ee.string();\n            break;\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return { room: N(D.room) ? String(D.room) : \"\" };\n    },\n    toJSON(D) {\n      const W = {};\n      return D.room !== void 0 && (W.room = D.room), W;\n    },\n    fromPartial(D) {\n      var W;\n      const ee = k();\n      return ee.room = (W = D.room) !== null && W !== void 0 ? W : \"\", ee;\n    }\n  };\n  function L() {\n    return {};\n  }\n  a.DeleteRoomResponse = {\n    encode(D, W = c.default.Writer.create()) {\n      return W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = L();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return {};\n    },\n    toJSON(D) {\n      return {};\n    },\n    fromPartial(D) {\n      return L();\n    }\n  };\n  function M() {\n    return { room: \"\" };\n  }\n  a.ListParticipantsRequest = {\n    encode(D, W = c.default.Writer.create()) {\n      return D.room !== void 0 && D.room !== \"\" && W.uint32(10).string(D.room), W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = M();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          case 1:\n            ye.room = ee.string();\n            break;\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return { room: N(D.room) ? String(D.room) : \"\" };\n    },\n    toJSON(D) {\n      const W = {};\n      return D.room !== void 0 && (W.room = D.room), W;\n    },\n    fromPartial(D) {\n      var W;\n      const ee = M();\n      return ee.room = (W = D.room) !== null && W !== void 0 ? W : \"\", ee;\n    }\n  };\n  function $() {\n    return { participants: [] };\n  }\n  a.ListParticipantsResponse = {\n    encode(D, W = c.default.Writer.create()) {\n      if (D.participants !== void 0 && D.participants.length !== 0)\n        for (const ee of D.participants)\n          v.ParticipantInfo.encode(ee, W.uint32(10).fork()).ldelim();\n      return W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = $();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          case 1:\n            ye.participants.push(v.ParticipantInfo.decode(ee, ee.uint32()));\n            break;\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return {\n        participants: Array.isArray(D == null ? void 0 : D.participants) ? D.participants.map((W) => v.ParticipantInfo.fromJSON(W)) : []\n      };\n    },\n    toJSON(D) {\n      const W = {};\n      return D.participants ? W.participants = D.participants.map((ee) => ee ? v.ParticipantInfo.toJSON(ee) : void 0) : W.participants = [], W;\n    },\n    fromPartial(D) {\n      var W;\n      const ee = $();\n      return ee.participants = ((W = D.participants) === null || W === void 0 ? void 0 : W.map((ae) => v.ParticipantInfo.fromPartial(ae))) || [], ee;\n    }\n  };\n  function J() {\n    return { room: \"\", identity: \"\" };\n  }\n  a.RoomParticipantIdentity = {\n    encode(D, W = c.default.Writer.create()) {\n      return D.room !== void 0 && D.room !== \"\" && W.uint32(10).string(D.room), D.identity !== void 0 && D.identity !== \"\" && W.uint32(18).string(D.identity), W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = J();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          case 1:\n            ye.room = ee.string();\n            break;\n          case 2:\n            ye.identity = ee.string();\n            break;\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return {\n        room: N(D.room) ? String(D.room) : \"\",\n        identity: N(D.identity) ? String(D.identity) : \"\"\n      };\n    },\n    toJSON(D) {\n      const W = {};\n      return D.room !== void 0 && (W.room = D.room), D.identity !== void 0 && (W.identity = D.identity), W;\n    },\n    fromPartial(D) {\n      var W, ee;\n      const ae = J();\n      return ae.room = (W = D.room) !== null && W !== void 0 ? W : \"\", ae.identity = (ee = D.identity) !== null && ee !== void 0 ? ee : \"\", ae;\n    }\n  };\n  function V() {\n    return {};\n  }\n  a.RemoveParticipantResponse = {\n    encode(D, W = c.default.Writer.create()) {\n      return W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = V();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return {};\n    },\n    toJSON(D) {\n      return {};\n    },\n    fromPartial(D) {\n      return V();\n    }\n  };\n  function q() {\n    return { room: \"\", identity: \"\", trackSid: \"\", muted: !1 };\n  }\n  a.MuteRoomTrackRequest = {\n    encode(D, W = c.default.Writer.create()) {\n      return D.room !== void 0 && D.room !== \"\" && W.uint32(10).string(D.room), D.identity !== void 0 && D.identity !== \"\" && W.uint32(18).string(D.identity), D.trackSid !== void 0 && D.trackSid !== \"\" && W.uint32(26).string(D.trackSid), D.muted === !0 && W.uint32(32).bool(D.muted), W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = q();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          case 1:\n            ye.room = ee.string();\n            break;\n          case 2:\n            ye.identity = ee.string();\n            break;\n          case 3:\n            ye.trackSid = ee.string();\n            break;\n          case 4:\n            ye.muted = ee.bool();\n            break;\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return {\n        room: N(D.room) ? String(D.room) : \"\",\n        identity: N(D.identity) ? String(D.identity) : \"\",\n        trackSid: N(D.trackSid) ? String(D.trackSid) : \"\",\n        muted: N(D.muted) ? !!D.muted : !1\n      };\n    },\n    toJSON(D) {\n      const W = {};\n      return D.room !== void 0 && (W.room = D.room), D.identity !== void 0 && (W.identity = D.identity), D.trackSid !== void 0 && (W.trackSid = D.trackSid), D.muted !== void 0 && (W.muted = D.muted), W;\n    },\n    fromPartial(D) {\n      var W, ee, ae, ye;\n      const he = q();\n      return he.room = (W = D.room) !== null && W !== void 0 ? W : \"\", he.identity = (ee = D.identity) !== null && ee !== void 0 ? ee : \"\", he.trackSid = (ae = D.trackSid) !== null && ae !== void 0 ? ae : \"\", he.muted = (ye = D.muted) !== null && ye !== void 0 ? ye : !1, he;\n    }\n  };\n  function G() {\n    return { track: void 0 };\n  }\n  a.MuteRoomTrackResponse = {\n    encode(D, W = c.default.Writer.create()) {\n      return D.track !== void 0 && v.TrackInfo.encode(D.track, W.uint32(10).fork()).ldelim(), W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = G();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          case 1:\n            ye.track = v.TrackInfo.decode(ee, ee.uint32());\n            break;\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return { track: N(D.track) ? v.TrackInfo.fromJSON(D.track) : void 0 };\n    },\n    toJSON(D) {\n      const W = {};\n      return D.track !== void 0 && (W.track = D.track ? v.TrackInfo.toJSON(D.track) : void 0), W;\n    },\n    fromPartial(D) {\n      const W = G();\n      return W.track = D.track !== void 0 && D.track !== null ? v.TrackInfo.fromPartial(D.track) : void 0, W;\n    }\n  };\n  function H() {\n    return { room: \"\", identity: \"\", metadata: \"\", permission: void 0, name: \"\" };\n  }\n  a.UpdateParticipantRequest = {\n    encode(D, W = c.default.Writer.create()) {\n      return D.room !== void 0 && D.room !== \"\" && W.uint32(10).string(D.room), D.identity !== void 0 && D.identity !== \"\" && W.uint32(18).string(D.identity), D.metadata !== void 0 && D.metadata !== \"\" && W.uint32(26).string(D.metadata), D.permission !== void 0 && v.ParticipantPermission.encode(D.permission, W.uint32(34).fork()).ldelim(), D.name !== void 0 && D.name !== \"\" && W.uint32(42).string(D.name), W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = H();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          case 1:\n            ye.room = ee.string();\n            break;\n          case 2:\n            ye.identity = ee.string();\n            break;\n          case 3:\n            ye.metadata = ee.string();\n            break;\n          case 4:\n            ye.permission = v.ParticipantPermission.decode(ee, ee.uint32());\n            break;\n          case 5:\n            ye.name = ee.string();\n            break;\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return {\n        room: N(D.room) ? String(D.room) : \"\",\n        identity: N(D.identity) ? String(D.identity) : \"\",\n        metadata: N(D.metadata) ? String(D.metadata) : \"\",\n        permission: N(D.permission) ? v.ParticipantPermission.fromJSON(D.permission) : void 0,\n        name: N(D.name) ? String(D.name) : \"\"\n      };\n    },\n    toJSON(D) {\n      const W = {};\n      return D.room !== void 0 && (W.room = D.room), D.identity !== void 0 && (W.identity = D.identity), D.metadata !== void 0 && (W.metadata = D.metadata), D.permission !== void 0 && (W.permission = D.permission ? v.ParticipantPermission.toJSON(D.permission) : void 0), D.name !== void 0 && (W.name = D.name), W;\n    },\n    fromPartial(D) {\n      var W, ee, ae, ye;\n      const he = H();\n      return he.room = (W = D.room) !== null && W !== void 0 ? W : \"\", he.identity = (ee = D.identity) !== null && ee !== void 0 ? ee : \"\", he.metadata = (ae = D.metadata) !== null && ae !== void 0 ? ae : \"\", he.permission = D.permission !== void 0 && D.permission !== null ? v.ParticipantPermission.fromPartial(D.permission) : void 0, he.name = (ye = D.name) !== null && ye !== void 0 ? ye : \"\", he;\n    }\n  };\n  function B() {\n    return { room: \"\", identity: \"\", trackSids: [], subscribe: !1, participantTracks: [] };\n  }\n  a.UpdateSubscriptionsRequest = {\n    encode(D, W = c.default.Writer.create()) {\n      if (D.room !== void 0 && D.room !== \"\" && W.uint32(10).string(D.room), D.identity !== void 0 && D.identity !== \"\" && W.uint32(18).string(D.identity), D.trackSids !== void 0 && D.trackSids.length !== 0)\n        for (const ee of D.trackSids)\n          W.uint32(26).string(ee);\n      if (D.subscribe === !0 && W.uint32(32).bool(D.subscribe), D.participantTracks !== void 0 && D.participantTracks.length !== 0)\n        for (const ee of D.participantTracks)\n          v.ParticipantTracks.encode(ee, W.uint32(42).fork()).ldelim();\n      return W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = B();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          case 1:\n            ye.room = ee.string();\n            break;\n          case 2:\n            ye.identity = ee.string();\n            break;\n          case 3:\n            ye.trackSids.push(ee.string());\n            break;\n          case 4:\n            ye.subscribe = ee.bool();\n            break;\n          case 5:\n            ye.participantTracks.push(v.ParticipantTracks.decode(ee, ee.uint32()));\n            break;\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return {\n        room: N(D.room) ? String(D.room) : \"\",\n        identity: N(D.identity) ? String(D.identity) : \"\",\n        trackSids: Array.isArray(D == null ? void 0 : D.trackSids) ? D.trackSids.map((W) => String(W)) : [],\n        subscribe: N(D.subscribe) ? !!D.subscribe : !1,\n        participantTracks: Array.isArray(D == null ? void 0 : D.participantTracks) ? D.participantTracks.map((W) => v.ParticipantTracks.fromJSON(W)) : []\n      };\n    },\n    toJSON(D) {\n      const W = {};\n      return D.room !== void 0 && (W.room = D.room), D.identity !== void 0 && (W.identity = D.identity), D.trackSids ? W.trackSids = D.trackSids.map((ee) => ee) : W.trackSids = [], D.subscribe !== void 0 && (W.subscribe = D.subscribe), D.participantTracks ? W.participantTracks = D.participantTracks.map((ee) => ee ? v.ParticipantTracks.toJSON(ee) : void 0) : W.participantTracks = [], W;\n    },\n    fromPartial(D) {\n      var W, ee, ae, ye, he;\n      const le = B();\n      return le.room = (W = D.room) !== null && W !== void 0 ? W : \"\", le.identity = (ee = D.identity) !== null && ee !== void 0 ? ee : \"\", le.trackSids = ((ae = D.trackSids) === null || ae === void 0 ? void 0 : ae.map((we) => we)) || [], le.subscribe = (ye = D.subscribe) !== null && ye !== void 0 ? ye : !1, le.participantTracks = ((he = D.participantTracks) === null || he === void 0 ? void 0 : he.map((we) => v.ParticipantTracks.fromPartial(we))) || [], le;\n    }\n  };\n  function Y() {\n    return {};\n  }\n  a.UpdateSubscriptionsResponse = {\n    encode(D, W = c.default.Writer.create()) {\n      return W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = Y();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return {};\n    },\n    toJSON(D) {\n      return {};\n    },\n    fromPartial(D) {\n      return Y();\n    }\n  };\n  function ne() {\n    return { room: \"\", data: new Uint8Array(), kind: 0, destinationSids: [] };\n  }\n  a.SendDataRequest = {\n    encode(D, W = c.default.Writer.create()) {\n      if (D.room !== void 0 && D.room !== \"\" && W.uint32(10).string(D.room), D.data !== void 0 && D.data.length !== 0 && W.uint32(18).bytes(D.data), D.kind !== void 0 && D.kind !== 0 && W.uint32(24).int32(D.kind), D.destinationSids !== void 0 && D.destinationSids.length !== 0)\n        for (const ee of D.destinationSids)\n          W.uint32(34).string(ee);\n      return W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = ne();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          case 1:\n            ye.room = ee.string();\n            break;\n          case 2:\n            ye.data = ee.bytes();\n            break;\n          case 3:\n            ye.kind = ee.int32();\n            break;\n          case 4:\n            ye.destinationSids.push(ee.string());\n            break;\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return {\n        room: N(D.room) ? String(D.room) : \"\",\n        data: N(D.data) ? de(D.data) : new Uint8Array(),\n        kind: N(D.kind) ? v.dataPacket_KindFromJSON(D.kind) : 0,\n        destinationSids: Array.isArray(D == null ? void 0 : D.destinationSids) ? D.destinationSids.map((W) => String(W)) : []\n      };\n    },\n    toJSON(D) {\n      const W = {};\n      return D.room !== void 0 && (W.room = D.room), D.data !== void 0 && (W.data = A(D.data !== void 0 ? D.data : new Uint8Array())), D.kind !== void 0 && (W.kind = v.dataPacket_KindToJSON(D.kind)), D.destinationSids ? W.destinationSids = D.destinationSids.map((ee) => ee) : W.destinationSids = [], W;\n    },\n    fromPartial(D) {\n      var W, ee, ae, ye;\n      const he = ne();\n      return he.room = (W = D.room) !== null && W !== void 0 ? W : \"\", he.data = (ee = D.data) !== null && ee !== void 0 ? ee : new Uint8Array(), he.kind = (ae = D.kind) !== null && ae !== void 0 ? ae : 0, he.destinationSids = ((ye = D.destinationSids) === null || ye === void 0 ? void 0 : ye.map((le) => le)) || [], he;\n    }\n  };\n  function Z() {\n    return {};\n  }\n  a.SendDataResponse = {\n    encode(D, W = c.default.Writer.create()) {\n      return W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = Z();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return {};\n    },\n    toJSON(D) {\n      return {};\n    },\n    fromPartial(D) {\n      return Z();\n    }\n  };\n  function re() {\n    return { room: \"\", metadata: \"\" };\n  }\n  a.UpdateRoomMetadataRequest = {\n    encode(D, W = c.default.Writer.create()) {\n      return D.room !== void 0 && D.room !== \"\" && W.uint32(10).string(D.room), D.metadata !== void 0 && D.metadata !== \"\" && W.uint32(18).string(D.metadata), W;\n    },\n    decode(D, W) {\n      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);\n      let ae = W === void 0 ? ee.len : ee.pos + W;\n      const ye = re();\n      for (; ee.pos < ae; ) {\n        const he = ee.uint32();\n        switch (he >>> 3) {\n          case 1:\n            ye.room = ee.string();\n            break;\n          case 2:\n            ye.metadata = ee.string();\n            break;\n          default:\n            ee.skipType(he & 7);\n            break;\n        }\n      }\n      return ye;\n    },\n    fromJSON(D) {\n      return {\n        room: N(D.room) ? String(D.room) : \"\",\n        metadata: N(D.metadata) ? String(D.metadata) : \"\"\n      };\n    },\n    toJSON(D) {\n      const W = {};\n      return D.room !== void 0 && (W.room = D.room), D.metadata !== void 0 && (W.metadata = D.metadata), W;\n    },\n    fromPartial(D) {\n      var W, ee;\n      const ae = re();\n      return ae.room = (W = D.room) !== null && W !== void 0 ? W : \"\", ae.metadata = (ee = D.metadata) !== null && ee !== void 0 ? ee : \"\", ae;\n    }\n  };\n  var oe = (() => {\n    if (typeof oe < \"u\")\n      return oe;\n    if (typeof self < \"u\")\n      return self;\n    if (typeof window < \"u\")\n      return window;\n    if (typeof commonjsGlobal$1 < \"u\")\n      return commonjsGlobal$1;\n    throw \"Unable to locate global object\";\n  })();\n  function de(D) {\n    if (oe.Buffer)\n      return Uint8Array.from(oe.Buffer.from(D, \"base64\"));\n    {\n      const W = oe.atob(D), ee = new Uint8Array(W.length);\n      for (let ae = 0; ae < W.length; ++ae)\n        ee[ae] = W.charCodeAt(ae);\n      return ee;\n    }\n  }\n  function A(D) {\n    if (oe.Buffer)\n      return oe.Buffer.from(D).toString(\"base64\");\n    {\n      const W = [];\n      return D.forEach((ee) => {\n        W.push(String.fromCharCode(ee));\n      }), oe.btoa(W.join(\"\"));\n    }\n  }\n  function N(D) {\n    return D != null;\n  }\n})(livekit_room);\nvar __awaiter$1 = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {\n  function v(S) {\n    return S instanceof c ? S : new c(function(g) {\n      g(S);\n    });\n  }\n  return new (c || (c = Promise))(function(S, g) {\n    function E(L) {\n      try {\n        k(l.next(L));\n      } catch (M) {\n        g(M);\n      }\n    }\n    function _(L) {\n      try {\n        k(l.throw(L));\n      } catch (M) {\n        g(M);\n      }\n    }\n    function k(L) {\n      L.done ? S(L.value) : v(L.value).then(E, _);\n    }\n    k((l = l.apply(a, u || [])).next());\n  });\n}, __importDefault$2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(RoomServiceClient$1, \"__esModule\", { value: !0 });\nRoomServiceClient$1.RoomServiceClient = void 0;\nconst livekit_models_1$1 = livekit_models, livekit_room_1 = livekit_room, ServiceBase_1 = __importDefault$2(ServiceBase$1), TwirpRPC_1 = TwirpRPC, svc = \"RoomService\";\nclass RoomServiceClient extends ServiceBase_1.default {\n  /**\n   *\n   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'\n   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY\n   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET\n   * @param jwt JWT Token, a pregenerated JWT token for authentication.\n   * @param hostHeader A host header to send with the request.\n   *\n   */\n  constructor(u, c, l, v, S) {\n    super(c, l), this.jwt = v, this.rpc = new TwirpRPC_1.TwirpRpc(u, TwirpRPC_1.livekitPackage, void 0, S);\n  }\n  /**\n   * Creates a new room. Explicit room creation is not required, since rooms will\n   * be automatically created when the first participant joins. This method can be\n   * used to customize room settings.\n   * @param options\n   */\n  createRoom(u) {\n    return __awaiter$1(this, void 0, void 0, function* () {\n      const c = yield this.rpc.request(svc, \"CreateRoom\", livekit_room_1.CreateRoomRequest.toJSON(livekit_room_1.CreateRoomRequest.fromPartial(u)), this.authHeader({ roomCreate: !0 }));\n      return livekit_models_1$1.Room.fromJSON(c);\n    });\n  }\n  /**\n   * List active rooms\n   * @param names when undefined or empty, list all rooms.\n   *              otherwise returns rooms with matching names\n   * @returns\n   */\n  listRooms(u) {\n    var c;\n    return __awaiter$1(this, void 0, void 0, function* () {\n      const l = yield this.rpc.request(svc, \"ListRooms\", livekit_room_1.ListRoomsRequest.toJSON({ names: u ?? [] }), this.authHeader({ roomList: !0 }));\n      return (c = livekit_room_1.ListRoomsResponse.fromJSON(l).rooms) !== null && c !== void 0 ? c : [];\n    });\n  }\n  deleteRoom(u) {\n    return __awaiter$1(this, void 0, void 0, function* () {\n      yield this.rpc.request(svc, \"DeleteRoom\", livekit_room_1.DeleteRoomRequest.toJSON({ room: u }), this.authHeader({ roomCreate: !0 }));\n    });\n  }\n  /**\n   * Update metadata of a room\n   * @param room name of the room\n   * @param metadata the new metadata for the room\n   */\n  updateRoomMetadata(u, c) {\n    return __awaiter$1(this, void 0, void 0, function* () {\n      const l = yield this.rpc.request(svc, \"UpdateRoomMetadata\", livekit_room_1.UpdateRoomMetadataRequest.toJSON({ room: u, metadata: c }), this.authHeader({ roomAdmin: !0, room: u }));\n      return livekit_models_1$1.Room.fromJSON(l);\n    });\n  }\n  /**\n   * List participants in a room\n   * @param room name of the room\n   */\n  listParticipants(u) {\n    var c;\n    return __awaiter$1(this, void 0, void 0, function* () {\n      const l = yield this.rpc.request(svc, \"ListParticipants\", livekit_room_1.ListParticipantsRequest.toJSON({ room: u }), this.authHeader({ roomAdmin: !0, room: u }));\n      return (c = livekit_room_1.ListParticipantsResponse.fromJSON(l).participants) !== null && c !== void 0 ? c : [];\n    });\n  }\n  /**\n   * Get information on a specific participant, including the tracks that participant\n   * has published\n   * @param room name of the room\n   * @param identity identity of the participant to return\n   */\n  getParticipant(u, c) {\n    return __awaiter$1(this, void 0, void 0, function* () {\n      const l = yield this.rpc.request(svc, \"GetParticipant\", livekit_room_1.RoomParticipantIdentity.toJSON({ room: u, identity: c }), this.authHeader({ roomAdmin: !0, room: u }));\n      return livekit_models_1$1.ParticipantInfo.fromJSON(l);\n    });\n  }\n  /**\n   * Removes a participant in the room. This will disconnect the participant\n   * and will emit a Disconnected event for that participant.\n   * Even after being removed, the participant can still re-join the room.\n   * @param room\n   * @param identity\n   */\n  removeParticipant(u, c) {\n    return __awaiter$1(this, void 0, void 0, function* () {\n      yield this.rpc.request(svc, \"RemoveParticipant\", livekit_room_1.RoomParticipantIdentity.toJSON({ room: u, identity: c }), this.authHeader({ roomAdmin: !0, room: u }));\n    });\n  }\n  /**\n   * Mutes a track that the participant has published.\n   * @param room\n   * @param identity\n   * @param trackSid sid of the track to be muted\n   * @param muted true to mute, false to unmute\n   */\n  mutePublishedTrack(u, c, l, v) {\n    return __awaiter$1(this, void 0, void 0, function* () {\n      const S = livekit_room_1.MuteRoomTrackRequest.toJSON({\n        room: u,\n        identity: c,\n        trackSid: l,\n        muted: v\n      }), g = yield this.rpc.request(svc, \"MutePublishedTrack\", S, this.authHeader({ roomAdmin: !0, room: u }));\n      return livekit_room_1.MuteRoomTrackResponse.fromJSON(g).track;\n    });\n  }\n  /**\n   * Updates a participant's metadata or permissions\n   * @param room\n   * @param identity\n   * @param metadata optional, metadata to update\n   * @param permission optional, new permissions to assign to participant\n   * @param name optional, new name for participant\n   */\n  updateParticipant(u, c, l, v, S) {\n    return __awaiter$1(this, void 0, void 0, function* () {\n      const g = {\n        room: u,\n        identity: c,\n        metadata: l || \"\",\n        permission: v,\n        name: S || \"\"\n      }, E = yield this.rpc.request(svc, \"UpdateParticipant\", livekit_room_1.UpdateParticipantRequest.toJSON(g), this.authHeader({ roomAdmin: !0, room: u }));\n      return livekit_models_1$1.ParticipantInfo.fromJSON(E);\n    });\n  }\n  /**\n   * Updates a participant's subscription to tracks\n   * @param room\n   * @param identity\n   * @param trackSids\n   * @param subscribe true to subscribe, false to unsubscribe\n   */\n  updateSubscriptions(u, c, l, v) {\n    return __awaiter$1(this, void 0, void 0, function* () {\n      const S = livekit_room_1.UpdateSubscriptionsRequest.toJSON({\n        room: u,\n        identity: c,\n        trackSids: l,\n        subscribe: v,\n        participantTracks: []\n      });\n      yield this.rpc.request(svc, \"UpdateSubscriptions\", S, this.authHeader({ roomAdmin: !0, room: u }));\n    });\n  }\n  /**\n   * Sends data message to participants in the room\n   * @param room\n   * @param data opaque payload to send\n   * @param kind delivery reliability\n   * @param destinationSids optional. when empty, message is sent to everyone\n   */\n  sendData(u, c, l, v = []) {\n    return __awaiter$1(this, void 0, void 0, function* () {\n      const S = livekit_room_1.SendDataRequest.toJSON({\n        room: u,\n        data: c,\n        kind: l,\n        destinationSids: v\n      });\n      yield this.rpc.request(svc, \"SendData\", S, this.authHeader({ roomAdmin: !0, room: u }));\n    });\n  }\n  authHeader(u) {\n    return this.jwt ? { Authorization: `Bearer ${this.jwt}` } : super.authHeader(u);\n  }\n}\nRoomServiceClient$1.RoomServiceClient = RoomServiceClient;\nvar WebhookReceiver$1 = {}, livekit_webhook = {}, __importDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(livekit_webhook, \"__esModule\", { value: !0 });\nlivekit_webhook.WebhookEvent = livekit_webhook.protobufPackage = void 0;\nconst long_1 = __importDefault$1(umdExports), minimal_1 = __importDefault$1(minimal), livekit_egress_1 = livekit_egress, livekit_ingress_1 = livekit_ingress, livekit_models_1 = livekit_models;\nlivekit_webhook.protobufPackage = \"livekit\";\nfunction createBaseWebhookEvent() {\n  return {\n    event: \"\",\n    room: void 0,\n    participant: void 0,\n    egressInfo: void 0,\n    ingressInfo: void 0,\n    track: void 0,\n    id: \"\",\n    createdAt: 0\n  };\n}\nlivekit_webhook.WebhookEvent = {\n  encode(a, u = minimal_1.default.Writer.create()) {\n    return a.event !== void 0 && a.event !== \"\" && u.uint32(10).string(a.event), a.room !== void 0 && livekit_models_1.Room.encode(a.room, u.uint32(18).fork()).ldelim(), a.participant !== void 0 && livekit_models_1.ParticipantInfo.encode(a.participant, u.uint32(26).fork()).ldelim(), a.egressInfo !== void 0 && livekit_egress_1.EgressInfo.encode(a.egressInfo, u.uint32(74).fork()).ldelim(), a.ingressInfo !== void 0 && livekit_ingress_1.IngressInfo.encode(a.ingressInfo, u.uint32(82).fork()).ldelim(), a.track !== void 0 && livekit_models_1.TrackInfo.encode(a.track, u.uint32(66).fork()).ldelim(), a.id !== void 0 && a.id !== \"\" && u.uint32(50).string(a.id), a.createdAt !== void 0 && a.createdAt !== 0 && u.uint32(56).int64(a.createdAt), u;\n  },\n  decode(a, u) {\n    const c = a instanceof minimal_1.default.Reader ? a : new minimal_1.default.Reader(a);\n    let l = u === void 0 ? c.len : c.pos + u;\n    const v = createBaseWebhookEvent();\n    for (; c.pos < l; ) {\n      const S = c.uint32();\n      switch (S >>> 3) {\n        case 1:\n          v.event = c.string();\n          break;\n        case 2:\n          v.room = livekit_models_1.Room.decode(c, c.uint32());\n          break;\n        case 3:\n          v.participant = livekit_models_1.ParticipantInfo.decode(c, c.uint32());\n          break;\n        case 9:\n          v.egressInfo = livekit_egress_1.EgressInfo.decode(c, c.uint32());\n          break;\n        case 10:\n          v.ingressInfo = livekit_ingress_1.IngressInfo.decode(c, c.uint32());\n          break;\n        case 8:\n          v.track = livekit_models_1.TrackInfo.decode(c, c.uint32());\n          break;\n        case 6:\n          v.id = c.string();\n          break;\n        case 7:\n          v.createdAt = longToNumber(c.int64());\n          break;\n        default:\n          c.skipType(S & 7);\n          break;\n      }\n    }\n    return v;\n  },\n  fromJSON(a) {\n    return {\n      event: isSet(a.event) ? String(a.event) : \"\",\n      room: isSet(a.room) ? livekit_models_1.Room.fromJSON(a.room) : void 0,\n      participant: isSet(a.participant) ? livekit_models_1.ParticipantInfo.fromJSON(a.participant) : void 0,\n      egressInfo: isSet(a.egressInfo) ? livekit_egress_1.EgressInfo.fromJSON(a.egressInfo) : void 0,\n      ingressInfo: isSet(a.ingressInfo) ? livekit_ingress_1.IngressInfo.fromJSON(a.ingressInfo) : void 0,\n      track: isSet(a.track) ? livekit_models_1.TrackInfo.fromJSON(a.track) : void 0,\n      id: isSet(a.id) ? String(a.id) : \"\",\n      createdAt: isSet(a.createdAt) ? Number(a.createdAt) : 0\n    };\n  },\n  toJSON(a) {\n    const u = {};\n    return a.event !== void 0 && (u.event = a.event), a.room !== void 0 && (u.room = a.room ? livekit_models_1.Room.toJSON(a.room) : void 0), a.participant !== void 0 && (u.participant = a.participant ? livekit_models_1.ParticipantInfo.toJSON(a.participant) : void 0), a.egressInfo !== void 0 && (u.egressInfo = a.egressInfo ? livekit_egress_1.EgressInfo.toJSON(a.egressInfo) : void 0), a.ingressInfo !== void 0 && (u.ingressInfo = a.ingressInfo ? livekit_ingress_1.IngressInfo.toJSON(a.ingressInfo) : void 0), a.track !== void 0 && (u.track = a.track ? livekit_models_1.TrackInfo.toJSON(a.track) : void 0), a.id !== void 0 && (u.id = a.id), a.createdAt !== void 0 && (u.createdAt = Math.round(a.createdAt)), u;\n  },\n  fromPartial(a) {\n    var u, c, l;\n    const v = createBaseWebhookEvent();\n    return v.event = (u = a.event) !== null && u !== void 0 ? u : \"\", v.room = a.room !== void 0 && a.room !== null ? livekit_models_1.Room.fromPartial(a.room) : void 0, v.participant = a.participant !== void 0 && a.participant !== null ? livekit_models_1.ParticipantInfo.fromPartial(a.participant) : void 0, v.egressInfo = a.egressInfo !== void 0 && a.egressInfo !== null ? livekit_egress_1.EgressInfo.fromPartial(a.egressInfo) : void 0, v.ingressInfo = a.ingressInfo !== void 0 && a.ingressInfo !== null ? livekit_ingress_1.IngressInfo.fromPartial(a.ingressInfo) : void 0, v.track = a.track !== void 0 && a.track !== null ? livekit_models_1.TrackInfo.fromPartial(a.track) : void 0, v.id = (c = a.id) !== null && c !== void 0 ? c : \"\", v.createdAt = (l = a.createdAt) !== null && l !== void 0 ? l : 0, v;\n  }\n};\nvar globalThis$1 = (() => {\n  if (typeof globalThis$1 < \"u\")\n    return globalThis$1;\n  if (typeof self < \"u\")\n    return self;\n  if (typeof window < \"u\")\n    return window;\n  if (typeof commonjsGlobal$1 < \"u\")\n    return commonjsGlobal$1;\n  throw \"Unable to locate global object\";\n})();\nfunction longToNumber(a) {\n  if (a.gt(Number.MAX_SAFE_INTEGER))\n    throw new globalThis$1.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  return a.toNumber();\n}\nminimal_1.default.util.Long !== long_1.default && (minimal_1.default.util.Long = long_1.default, minimal_1.default.configure());\nfunction isSet(a) {\n  return a != null;\n}\nvar __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {\n  return a && a.__esModule ? a : { default: a };\n};\nObject.defineProperty(WebhookReceiver$1, \"__esModule\", { value: !0 });\nWebhookReceiver$1.WebhookReceiver = WebhookReceiver$1.authorizeHeader = void 0;\nconst crypto_1 = __importDefault(require$$0$1), AccessToken_1 = AccessToken$1, livekit_webhook_1 = livekit_webhook;\nWebhookReceiver$1.authorizeHeader = \"Authorize\";\nclass WebhookReceiver {\n  constructor(u, c) {\n    this.verifier = new AccessToken_1.TokenVerifier(u, c);\n  }\n  /**\n   *\n   * @param body string of the posted body\n   * @param authHeader `Authorization` header from the request\n   * @param skipAuth true to skip auth validation\n   * @returns\n   */\n  receive(u, c, l = !1) {\n    if (!l) {\n      if (!c)\n        throw new Error(\"authorization header is empty\");\n      const v = this.verifier.verify(c), S = crypto_1.default.createHash(\"sha256\");\n      if (S.update(u), v.sha256 !== S.digest(\"base64\"))\n        throw new Error(\"sha256 checksum of body does not match\");\n    }\n    return livekit_webhook_1.WebhookEvent.fromJSON(JSON.parse(u));\n  }\n}\nWebhookReceiver$1.WebhookReceiver = WebhookReceiver;\nvar livekit_internal = {}, livekit_rtc = {};\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(C) {\n    return C && C.__esModule ? C : { default: C };\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.SimulateScenario = a.DataChannelInfo = a.SyncState = a.SubscriptionPermissionUpdate = a.SubscriptionPermission = a.TrackPermission = a.SubscribedQualityUpdate = a.SubscribedCodec = a.SubscribedQuality = a.StreamStateUpdate = a.StreamStateInfo = a.ConnectionQualityUpdate = a.ConnectionQualityInfo = a.RoomUpdate = a.SpeakersChanged = a.ICEServer = a.UpdateVideoLayers = a.LeaveRequest = a.UpdateTrackSettings = a.UpdateSubscription = a.ParticipantUpdate = a.SessionDescription = a.TrackUnpublishedResponse = a.TrackPublishedResponse = a.JoinResponse = a.MuteTrackRequest = a.TrickleRequest = a.AddTrackRequest = a.SimulcastCodec = a.SignalResponse = a.SignalRequest = a.candidateProtocolToJSON = a.candidateProtocolFromJSON = a.CandidateProtocol = a.streamStateToJSON = a.streamStateFromJSON = a.StreamState = a.signalTargetToJSON = a.signalTargetFromJSON = a.SignalTarget = a.protobufPackage = void 0;\n  const c = u(umdExports), l = u(minimal), v = livekit_models;\n  a.protobufPackage = \"livekit\";\n  var S;\n  (function(C) {\n    C[C.PUBLISHER = 0] = \"PUBLISHER\", C[C.SUBSCRIBER = 1] = \"SUBSCRIBER\", C[C.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(S = a.SignalTarget || (a.SignalTarget = {}));\n  function g(C) {\n    switch (C) {\n      case 0:\n      case \"PUBLISHER\":\n        return S.PUBLISHER;\n      case 1:\n      case \"SUBSCRIBER\":\n        return S.SUBSCRIBER;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return S.UNRECOGNIZED;\n    }\n  }\n  a.signalTargetFromJSON = g;\n  function E(C) {\n    switch (C) {\n      case S.PUBLISHER:\n        return \"PUBLISHER\";\n      case S.SUBSCRIBER:\n        return \"SUBSCRIBER\";\n      case S.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.signalTargetToJSON = E;\n  var _;\n  (function(C) {\n    C[C.ACTIVE = 0] = \"ACTIVE\", C[C.PAUSED = 1] = \"PAUSED\", C[C.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(_ = a.StreamState || (a.StreamState = {}));\n  function k(C) {\n    switch (C) {\n      case 0:\n      case \"ACTIVE\":\n        return _.ACTIVE;\n      case 1:\n      case \"PAUSED\":\n        return _.PAUSED;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return _.UNRECOGNIZED;\n    }\n  }\n  a.streamStateFromJSON = k;\n  function L(C) {\n    switch (C) {\n      case _.ACTIVE:\n        return \"ACTIVE\";\n      case _.PAUSED:\n        return \"PAUSED\";\n      case _.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.streamStateToJSON = L;\n  var M;\n  (function(C) {\n    C[C.UDP = 0] = \"UDP\", C[C.TCP = 1] = \"TCP\", C[C.TLS = 2] = \"TLS\", C[C.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(M = a.CandidateProtocol || (a.CandidateProtocol = {}));\n  function $(C) {\n    switch (C) {\n      case 0:\n      case \"UDP\":\n        return M.UDP;\n      case 1:\n      case \"TCP\":\n        return M.TCP;\n      case 2:\n      case \"TLS\":\n        return M.TLS;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return M.UNRECOGNIZED;\n    }\n  }\n  a.candidateProtocolFromJSON = $;\n  function J(C) {\n    switch (C) {\n      case M.UDP:\n        return \"UDP\";\n      case M.TCP:\n        return \"TCP\";\n      case M.TLS:\n        return \"TLS\";\n      case M.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.candidateProtocolToJSON = J;\n  function V() {\n    return {\n      offer: void 0,\n      answer: void 0,\n      trickle: void 0,\n      addTrack: void 0,\n      mute: void 0,\n      subscription: void 0,\n      trackSetting: void 0,\n      leave: void 0,\n      updateLayers: void 0,\n      subscriptionPermission: void 0,\n      syncState: void 0,\n      simulate: void 0,\n      ping: void 0\n    };\n  }\n  a.SignalRequest = {\n    encode(C, x = l.default.Writer.create()) {\n      return C.offer !== void 0 && a.SessionDescription.encode(C.offer, x.uint32(10).fork()).ldelim(), C.answer !== void 0 && a.SessionDescription.encode(C.answer, x.uint32(18).fork()).ldelim(), C.trickle !== void 0 && a.TrickleRequest.encode(C.trickle, x.uint32(26).fork()).ldelim(), C.addTrack !== void 0 && a.AddTrackRequest.encode(C.addTrack, x.uint32(34).fork()).ldelim(), C.mute !== void 0 && a.MuteTrackRequest.encode(C.mute, x.uint32(42).fork()).ldelim(), C.subscription !== void 0 && a.UpdateSubscription.encode(C.subscription, x.uint32(50).fork()).ldelim(), C.trackSetting !== void 0 && a.UpdateTrackSettings.encode(C.trackSetting, x.uint32(58).fork()).ldelim(), C.leave !== void 0 && a.LeaveRequest.encode(C.leave, x.uint32(66).fork()).ldelim(), C.updateLayers !== void 0 && a.UpdateVideoLayers.encode(C.updateLayers, x.uint32(82).fork()).ldelim(), C.subscriptionPermission !== void 0 && a.SubscriptionPermission.encode(C.subscriptionPermission, x.uint32(90).fork()).ldelim(), C.syncState !== void 0 && a.SyncState.encode(C.syncState, x.uint32(98).fork()).ldelim(), C.simulate !== void 0 && a.SimulateScenario.encode(C.simulate, x.uint32(106).fork()).ldelim(), C.ping !== void 0 && x.uint32(112).int64(C.ping), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = V();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.offer = a.SessionDescription.decode(Q, Q.uint32());\n            break;\n          case 2:\n            me.answer = a.SessionDescription.decode(Q, Q.uint32());\n            break;\n          case 3:\n            me.trickle = a.TrickleRequest.decode(Q, Q.uint32());\n            break;\n          case 4:\n            me.addTrack = a.AddTrackRequest.decode(Q, Q.uint32());\n            break;\n          case 5:\n            me.mute = a.MuteTrackRequest.decode(Q, Q.uint32());\n            break;\n          case 6:\n            me.subscription = a.UpdateSubscription.decode(Q, Q.uint32());\n            break;\n          case 7:\n            me.trackSetting = a.UpdateTrackSettings.decode(Q, Q.uint32());\n            break;\n          case 8:\n            me.leave = a.LeaveRequest.decode(Q, Q.uint32());\n            break;\n          case 10:\n            me.updateLayers = a.UpdateVideoLayers.decode(Q, Q.uint32());\n            break;\n          case 11:\n            me.subscriptionPermission = a.SubscriptionPermission.decode(Q, Q.uint32());\n            break;\n          case 12:\n            me.syncState = a.SyncState.decode(Q, Q.uint32());\n            break;\n          case 13:\n            me.simulate = a.SimulateScenario.decode(Q, Q.uint32());\n            break;\n          case 14:\n            me.ping = xe(Q.int64());\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        offer: Pe(C.offer) ? a.SessionDescription.fromJSON(C.offer) : void 0,\n        answer: Pe(C.answer) ? a.SessionDescription.fromJSON(C.answer) : void 0,\n        trickle: Pe(C.trickle) ? a.TrickleRequest.fromJSON(C.trickle) : void 0,\n        addTrack: Pe(C.addTrack) ? a.AddTrackRequest.fromJSON(C.addTrack) : void 0,\n        mute: Pe(C.mute) ? a.MuteTrackRequest.fromJSON(C.mute) : void 0,\n        subscription: Pe(C.subscription) ? a.UpdateSubscription.fromJSON(C.subscription) : void 0,\n        trackSetting: Pe(C.trackSetting) ? a.UpdateTrackSettings.fromJSON(C.trackSetting) : void 0,\n        leave: Pe(C.leave) ? a.LeaveRequest.fromJSON(C.leave) : void 0,\n        updateLayers: Pe(C.updateLayers) ? a.UpdateVideoLayers.fromJSON(C.updateLayers) : void 0,\n        subscriptionPermission: Pe(C.subscriptionPermission) ? a.SubscriptionPermission.fromJSON(C.subscriptionPermission) : void 0,\n        syncState: Pe(C.syncState) ? a.SyncState.fromJSON(C.syncState) : void 0,\n        simulate: Pe(C.simulate) ? a.SimulateScenario.fromJSON(C.simulate) : void 0,\n        ping: Pe(C.ping) ? Number(C.ping) : void 0\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.offer !== void 0 && (x.offer = C.offer ? a.SessionDescription.toJSON(C.offer) : void 0), C.answer !== void 0 && (x.answer = C.answer ? a.SessionDescription.toJSON(C.answer) : void 0), C.trickle !== void 0 && (x.trickle = C.trickle ? a.TrickleRequest.toJSON(C.trickle) : void 0), C.addTrack !== void 0 && (x.addTrack = C.addTrack ? a.AddTrackRequest.toJSON(C.addTrack) : void 0), C.mute !== void 0 && (x.mute = C.mute ? a.MuteTrackRequest.toJSON(C.mute) : void 0), C.subscription !== void 0 && (x.subscription = C.subscription ? a.UpdateSubscription.toJSON(C.subscription) : void 0), C.trackSetting !== void 0 && (x.trackSetting = C.trackSetting ? a.UpdateTrackSettings.toJSON(C.trackSetting) : void 0), C.leave !== void 0 && (x.leave = C.leave ? a.LeaveRequest.toJSON(C.leave) : void 0), C.updateLayers !== void 0 && (x.updateLayers = C.updateLayers ? a.UpdateVideoLayers.toJSON(C.updateLayers) : void 0), C.subscriptionPermission !== void 0 && (x.subscriptionPermission = C.subscriptionPermission ? a.SubscriptionPermission.toJSON(C.subscriptionPermission) : void 0), C.syncState !== void 0 && (x.syncState = C.syncState ? a.SyncState.toJSON(C.syncState) : void 0), C.simulate !== void 0 && (x.simulate = C.simulate ? a.SimulateScenario.toJSON(C.simulate) : void 0), C.ping !== void 0 && (x.ping = Math.round(C.ping)), x;\n    },\n    fromPartial(C) {\n      var x;\n      const Q = V();\n      return Q.offer = C.offer !== void 0 && C.offer !== null ? a.SessionDescription.fromPartial(C.offer) : void 0, Q.answer = C.answer !== void 0 && C.answer !== null ? a.SessionDescription.fromPartial(C.answer) : void 0, Q.trickle = C.trickle !== void 0 && C.trickle !== null ? a.TrickleRequest.fromPartial(C.trickle) : void 0, Q.addTrack = C.addTrack !== void 0 && C.addTrack !== null ? a.AddTrackRequest.fromPartial(C.addTrack) : void 0, Q.mute = C.mute !== void 0 && C.mute !== null ? a.MuteTrackRequest.fromPartial(C.mute) : void 0, Q.subscription = C.subscription !== void 0 && C.subscription !== null ? a.UpdateSubscription.fromPartial(C.subscription) : void 0, Q.trackSetting = C.trackSetting !== void 0 && C.trackSetting !== null ? a.UpdateTrackSettings.fromPartial(C.trackSetting) : void 0, Q.leave = C.leave !== void 0 && C.leave !== null ? a.LeaveRequest.fromPartial(C.leave) : void 0, Q.updateLayers = C.updateLayers !== void 0 && C.updateLayers !== null ? a.UpdateVideoLayers.fromPartial(C.updateLayers) : void 0, Q.subscriptionPermission = C.subscriptionPermission !== void 0 && C.subscriptionPermission !== null ? a.SubscriptionPermission.fromPartial(C.subscriptionPermission) : void 0, Q.syncState = C.syncState !== void 0 && C.syncState !== null ? a.SyncState.fromPartial(C.syncState) : void 0, Q.simulate = C.simulate !== void 0 && C.simulate !== null ? a.SimulateScenario.fromPartial(C.simulate) : void 0, Q.ping = (x = C.ping) !== null && x !== void 0 ? x : void 0, Q;\n    }\n  };\n  function q() {\n    return {\n      join: void 0,\n      answer: void 0,\n      offer: void 0,\n      trickle: void 0,\n      update: void 0,\n      trackPublished: void 0,\n      leave: void 0,\n      mute: void 0,\n      speakersChanged: void 0,\n      roomUpdate: void 0,\n      connectionQuality: void 0,\n      streamStateUpdate: void 0,\n      subscribedQualityUpdate: void 0,\n      subscriptionPermissionUpdate: void 0,\n      refreshToken: void 0,\n      trackUnpublished: void 0,\n      pong: void 0\n    };\n  }\n  a.SignalResponse = {\n    encode(C, x = l.default.Writer.create()) {\n      return C.join !== void 0 && a.JoinResponse.encode(C.join, x.uint32(10).fork()).ldelim(), C.answer !== void 0 && a.SessionDescription.encode(C.answer, x.uint32(18).fork()).ldelim(), C.offer !== void 0 && a.SessionDescription.encode(C.offer, x.uint32(26).fork()).ldelim(), C.trickle !== void 0 && a.TrickleRequest.encode(C.trickle, x.uint32(34).fork()).ldelim(), C.update !== void 0 && a.ParticipantUpdate.encode(C.update, x.uint32(42).fork()).ldelim(), C.trackPublished !== void 0 && a.TrackPublishedResponse.encode(C.trackPublished, x.uint32(50).fork()).ldelim(), C.leave !== void 0 && a.LeaveRequest.encode(C.leave, x.uint32(66).fork()).ldelim(), C.mute !== void 0 && a.MuteTrackRequest.encode(C.mute, x.uint32(74).fork()).ldelim(), C.speakersChanged !== void 0 && a.SpeakersChanged.encode(C.speakersChanged, x.uint32(82).fork()).ldelim(), C.roomUpdate !== void 0 && a.RoomUpdate.encode(C.roomUpdate, x.uint32(90).fork()).ldelim(), C.connectionQuality !== void 0 && a.ConnectionQualityUpdate.encode(C.connectionQuality, x.uint32(98).fork()).ldelim(), C.streamStateUpdate !== void 0 && a.StreamStateUpdate.encode(C.streamStateUpdate, x.uint32(106).fork()).ldelim(), C.subscribedQualityUpdate !== void 0 && a.SubscribedQualityUpdate.encode(C.subscribedQualityUpdate, x.uint32(114).fork()).ldelim(), C.subscriptionPermissionUpdate !== void 0 && a.SubscriptionPermissionUpdate.encode(C.subscriptionPermissionUpdate, x.uint32(122).fork()).ldelim(), C.refreshToken !== void 0 && x.uint32(130).string(C.refreshToken), C.trackUnpublished !== void 0 && a.TrackUnpublishedResponse.encode(C.trackUnpublished, x.uint32(138).fork()).ldelim(), C.pong !== void 0 && x.uint32(144).int64(C.pong), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = q();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.join = a.JoinResponse.decode(Q, Q.uint32());\n            break;\n          case 2:\n            me.answer = a.SessionDescription.decode(Q, Q.uint32());\n            break;\n          case 3:\n            me.offer = a.SessionDescription.decode(Q, Q.uint32());\n            break;\n          case 4:\n            me.trickle = a.TrickleRequest.decode(Q, Q.uint32());\n            break;\n          case 5:\n            me.update = a.ParticipantUpdate.decode(Q, Q.uint32());\n            break;\n          case 6:\n            me.trackPublished = a.TrackPublishedResponse.decode(Q, Q.uint32());\n            break;\n          case 8:\n            me.leave = a.LeaveRequest.decode(Q, Q.uint32());\n            break;\n          case 9:\n            me.mute = a.MuteTrackRequest.decode(Q, Q.uint32());\n            break;\n          case 10:\n            me.speakersChanged = a.SpeakersChanged.decode(Q, Q.uint32());\n            break;\n          case 11:\n            me.roomUpdate = a.RoomUpdate.decode(Q, Q.uint32());\n            break;\n          case 12:\n            me.connectionQuality = a.ConnectionQualityUpdate.decode(Q, Q.uint32());\n            break;\n          case 13:\n            me.streamStateUpdate = a.StreamStateUpdate.decode(Q, Q.uint32());\n            break;\n          case 14:\n            me.subscribedQualityUpdate = a.SubscribedQualityUpdate.decode(Q, Q.uint32());\n            break;\n          case 15:\n            me.subscriptionPermissionUpdate = a.SubscriptionPermissionUpdate.decode(Q, Q.uint32());\n            break;\n          case 16:\n            me.refreshToken = Q.string();\n            break;\n          case 17:\n            me.trackUnpublished = a.TrackUnpublishedResponse.decode(Q, Q.uint32());\n            break;\n          case 18:\n            me.pong = xe(Q.int64());\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        join: Pe(C.join) ? a.JoinResponse.fromJSON(C.join) : void 0,\n        answer: Pe(C.answer) ? a.SessionDescription.fromJSON(C.answer) : void 0,\n        offer: Pe(C.offer) ? a.SessionDescription.fromJSON(C.offer) : void 0,\n        trickle: Pe(C.trickle) ? a.TrickleRequest.fromJSON(C.trickle) : void 0,\n        update: Pe(C.update) ? a.ParticipantUpdate.fromJSON(C.update) : void 0,\n        trackPublished: Pe(C.trackPublished) ? a.TrackPublishedResponse.fromJSON(C.trackPublished) : void 0,\n        leave: Pe(C.leave) ? a.LeaveRequest.fromJSON(C.leave) : void 0,\n        mute: Pe(C.mute) ? a.MuteTrackRequest.fromJSON(C.mute) : void 0,\n        speakersChanged: Pe(C.speakersChanged) ? a.SpeakersChanged.fromJSON(C.speakersChanged) : void 0,\n        roomUpdate: Pe(C.roomUpdate) ? a.RoomUpdate.fromJSON(C.roomUpdate) : void 0,\n        connectionQuality: Pe(C.connectionQuality) ? a.ConnectionQualityUpdate.fromJSON(C.connectionQuality) : void 0,\n        streamStateUpdate: Pe(C.streamStateUpdate) ? a.StreamStateUpdate.fromJSON(C.streamStateUpdate) : void 0,\n        subscribedQualityUpdate: Pe(C.subscribedQualityUpdate) ? a.SubscribedQualityUpdate.fromJSON(C.subscribedQualityUpdate) : void 0,\n        subscriptionPermissionUpdate: Pe(C.subscriptionPermissionUpdate) ? a.SubscriptionPermissionUpdate.fromJSON(C.subscriptionPermissionUpdate) : void 0,\n        refreshToken: Pe(C.refreshToken) ? String(C.refreshToken) : void 0,\n        trackUnpublished: Pe(C.trackUnpublished) ? a.TrackUnpublishedResponse.fromJSON(C.trackUnpublished) : void 0,\n        pong: Pe(C.pong) ? Number(C.pong) : void 0\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.join !== void 0 && (x.join = C.join ? a.JoinResponse.toJSON(C.join) : void 0), C.answer !== void 0 && (x.answer = C.answer ? a.SessionDescription.toJSON(C.answer) : void 0), C.offer !== void 0 && (x.offer = C.offer ? a.SessionDescription.toJSON(C.offer) : void 0), C.trickle !== void 0 && (x.trickle = C.trickle ? a.TrickleRequest.toJSON(C.trickle) : void 0), C.update !== void 0 && (x.update = C.update ? a.ParticipantUpdate.toJSON(C.update) : void 0), C.trackPublished !== void 0 && (x.trackPublished = C.trackPublished ? a.TrackPublishedResponse.toJSON(C.trackPublished) : void 0), C.leave !== void 0 && (x.leave = C.leave ? a.LeaveRequest.toJSON(C.leave) : void 0), C.mute !== void 0 && (x.mute = C.mute ? a.MuteTrackRequest.toJSON(C.mute) : void 0), C.speakersChanged !== void 0 && (x.speakersChanged = C.speakersChanged ? a.SpeakersChanged.toJSON(C.speakersChanged) : void 0), C.roomUpdate !== void 0 && (x.roomUpdate = C.roomUpdate ? a.RoomUpdate.toJSON(C.roomUpdate) : void 0), C.connectionQuality !== void 0 && (x.connectionQuality = C.connectionQuality ? a.ConnectionQualityUpdate.toJSON(C.connectionQuality) : void 0), C.streamStateUpdate !== void 0 && (x.streamStateUpdate = C.streamStateUpdate ? a.StreamStateUpdate.toJSON(C.streamStateUpdate) : void 0), C.subscribedQualityUpdate !== void 0 && (x.subscribedQualityUpdate = C.subscribedQualityUpdate ? a.SubscribedQualityUpdate.toJSON(C.subscribedQualityUpdate) : void 0), C.subscriptionPermissionUpdate !== void 0 && (x.subscriptionPermissionUpdate = C.subscriptionPermissionUpdate ? a.SubscriptionPermissionUpdate.toJSON(C.subscriptionPermissionUpdate) : void 0), C.refreshToken !== void 0 && (x.refreshToken = C.refreshToken), C.trackUnpublished !== void 0 && (x.trackUnpublished = C.trackUnpublished ? a.TrackUnpublishedResponse.toJSON(C.trackUnpublished) : void 0), C.pong !== void 0 && (x.pong = Math.round(C.pong)), x;\n    },\n    fromPartial(C) {\n      var x, Q;\n      const Se = q();\n      return Se.join = C.join !== void 0 && C.join !== null ? a.JoinResponse.fromPartial(C.join) : void 0, Se.answer = C.answer !== void 0 && C.answer !== null ? a.SessionDescription.fromPartial(C.answer) : void 0, Se.offer = C.offer !== void 0 && C.offer !== null ? a.SessionDescription.fromPartial(C.offer) : void 0, Se.trickle = C.trickle !== void 0 && C.trickle !== null ? a.TrickleRequest.fromPartial(C.trickle) : void 0, Se.update = C.update !== void 0 && C.update !== null ? a.ParticipantUpdate.fromPartial(C.update) : void 0, Se.trackPublished = C.trackPublished !== void 0 && C.trackPublished !== null ? a.TrackPublishedResponse.fromPartial(C.trackPublished) : void 0, Se.leave = C.leave !== void 0 && C.leave !== null ? a.LeaveRequest.fromPartial(C.leave) : void 0, Se.mute = C.mute !== void 0 && C.mute !== null ? a.MuteTrackRequest.fromPartial(C.mute) : void 0, Se.speakersChanged = C.speakersChanged !== void 0 && C.speakersChanged !== null ? a.SpeakersChanged.fromPartial(C.speakersChanged) : void 0, Se.roomUpdate = C.roomUpdate !== void 0 && C.roomUpdate !== null ? a.RoomUpdate.fromPartial(C.roomUpdate) : void 0, Se.connectionQuality = C.connectionQuality !== void 0 && C.connectionQuality !== null ? a.ConnectionQualityUpdate.fromPartial(C.connectionQuality) : void 0, Se.streamStateUpdate = C.streamStateUpdate !== void 0 && C.streamStateUpdate !== null ? a.StreamStateUpdate.fromPartial(C.streamStateUpdate) : void 0, Se.subscribedQualityUpdate = C.subscribedQualityUpdate !== void 0 && C.subscribedQualityUpdate !== null ? a.SubscribedQualityUpdate.fromPartial(C.subscribedQualityUpdate) : void 0, Se.subscriptionPermissionUpdate = C.subscriptionPermissionUpdate !== void 0 && C.subscriptionPermissionUpdate !== null ? a.SubscriptionPermissionUpdate.fromPartial(C.subscriptionPermissionUpdate) : void 0, Se.refreshToken = (x = C.refreshToken) !== null && x !== void 0 ? x : void 0, Se.trackUnpublished = C.trackUnpublished !== void 0 && C.trackUnpublished !== null ? a.TrackUnpublishedResponse.fromPartial(C.trackUnpublished) : void 0, Se.pong = (Q = C.pong) !== null && Q !== void 0 ? Q : void 0, Se;\n    }\n  };\n  function G() {\n    return { codec: \"\", cid: \"\", enableSimulcastLayers: !1 };\n  }\n  a.SimulcastCodec = {\n    encode(C, x = l.default.Writer.create()) {\n      return C.codec !== void 0 && C.codec !== \"\" && x.uint32(10).string(C.codec), C.cid !== void 0 && C.cid !== \"\" && x.uint32(18).string(C.cid), C.enableSimulcastLayers === !0 && x.uint32(24).bool(C.enableSimulcastLayers), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = G();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.codec = Q.string();\n            break;\n          case 2:\n            me.cid = Q.string();\n            break;\n          case 3:\n            me.enableSimulcastLayers = Q.bool();\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        codec: Pe(C.codec) ? String(C.codec) : \"\",\n        cid: Pe(C.cid) ? String(C.cid) : \"\",\n        enableSimulcastLayers: Pe(C.enableSimulcastLayers) ? !!C.enableSimulcastLayers : !1\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.codec !== void 0 && (x.codec = C.codec), C.cid !== void 0 && (x.cid = C.cid), C.enableSimulcastLayers !== void 0 && (x.enableSimulcastLayers = C.enableSimulcastLayers), x;\n    },\n    fromPartial(C) {\n      var x, Q, Se;\n      const me = G();\n      return me.codec = (x = C.codec) !== null && x !== void 0 ? x : \"\", me.cid = (Q = C.cid) !== null && Q !== void 0 ? Q : \"\", me.enableSimulcastLayers = (Se = C.enableSimulcastLayers) !== null && Se !== void 0 ? Se : !1, me;\n    }\n  };\n  function H() {\n    return {\n      cid: \"\",\n      name: \"\",\n      type: 0,\n      width: 0,\n      height: 0,\n      muted: !1,\n      disableDtx: !1,\n      source: 0,\n      layers: [],\n      simulcastCodecs: [],\n      sid: \"\",\n      stereo: !1,\n      disableRed: !1\n    };\n  }\n  a.AddTrackRequest = {\n    encode(C, x = l.default.Writer.create()) {\n      if (C.cid !== void 0 && C.cid !== \"\" && x.uint32(10).string(C.cid), C.name !== void 0 && C.name !== \"\" && x.uint32(18).string(C.name), C.type !== void 0 && C.type !== 0 && x.uint32(24).int32(C.type), C.width !== void 0 && C.width !== 0 && x.uint32(32).uint32(C.width), C.height !== void 0 && C.height !== 0 && x.uint32(40).uint32(C.height), C.muted === !0 && x.uint32(48).bool(C.muted), C.disableDtx === !0 && x.uint32(56).bool(C.disableDtx), C.source !== void 0 && C.source !== 0 && x.uint32(64).int32(C.source), C.layers !== void 0 && C.layers.length !== 0)\n        for (const Q of C.layers)\n          v.VideoLayer.encode(Q, x.uint32(74).fork()).ldelim();\n      if (C.simulcastCodecs !== void 0 && C.simulcastCodecs.length !== 0)\n        for (const Q of C.simulcastCodecs)\n          a.SimulcastCodec.encode(Q, x.uint32(82).fork()).ldelim();\n      return C.sid !== void 0 && C.sid !== \"\" && x.uint32(90).string(C.sid), C.stereo === !0 && x.uint32(96).bool(C.stereo), C.disableRed === !0 && x.uint32(104).bool(C.disableRed), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = H();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.cid = Q.string();\n            break;\n          case 2:\n            me.name = Q.string();\n            break;\n          case 3:\n            me.type = Q.int32();\n            break;\n          case 4:\n            me.width = Q.uint32();\n            break;\n          case 5:\n            me.height = Q.uint32();\n            break;\n          case 6:\n            me.muted = Q.bool();\n            break;\n          case 7:\n            me.disableDtx = Q.bool();\n            break;\n          case 8:\n            me.source = Q.int32();\n            break;\n          case 9:\n            me.layers.push(v.VideoLayer.decode(Q, Q.uint32()));\n            break;\n          case 10:\n            me.simulcastCodecs.push(a.SimulcastCodec.decode(Q, Q.uint32()));\n            break;\n          case 11:\n            me.sid = Q.string();\n            break;\n          case 12:\n            me.stereo = Q.bool();\n            break;\n          case 13:\n            me.disableRed = Q.bool();\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        cid: Pe(C.cid) ? String(C.cid) : \"\",\n        name: Pe(C.name) ? String(C.name) : \"\",\n        type: Pe(C.type) ? v.trackTypeFromJSON(C.type) : 0,\n        width: Pe(C.width) ? Number(C.width) : 0,\n        height: Pe(C.height) ? Number(C.height) : 0,\n        muted: Pe(C.muted) ? !!C.muted : !1,\n        disableDtx: Pe(C.disableDtx) ? !!C.disableDtx : !1,\n        source: Pe(C.source) ? v.trackSourceFromJSON(C.source) : 0,\n        layers: Array.isArray(C == null ? void 0 : C.layers) ? C.layers.map((x) => v.VideoLayer.fromJSON(x)) : [],\n        simulcastCodecs: Array.isArray(C == null ? void 0 : C.simulcastCodecs) ? C.simulcastCodecs.map((x) => a.SimulcastCodec.fromJSON(x)) : [],\n        sid: Pe(C.sid) ? String(C.sid) : \"\",\n        stereo: Pe(C.stereo) ? !!C.stereo : !1,\n        disableRed: Pe(C.disableRed) ? !!C.disableRed : !1\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.cid !== void 0 && (x.cid = C.cid), C.name !== void 0 && (x.name = C.name), C.type !== void 0 && (x.type = v.trackTypeToJSON(C.type)), C.width !== void 0 && (x.width = Math.round(C.width)), C.height !== void 0 && (x.height = Math.round(C.height)), C.muted !== void 0 && (x.muted = C.muted), C.disableDtx !== void 0 && (x.disableDtx = C.disableDtx), C.source !== void 0 && (x.source = v.trackSourceToJSON(C.source)), C.layers ? x.layers = C.layers.map((Q) => Q ? v.VideoLayer.toJSON(Q) : void 0) : x.layers = [], C.simulcastCodecs ? x.simulcastCodecs = C.simulcastCodecs.map((Q) => Q ? a.SimulcastCodec.toJSON(Q) : void 0) : x.simulcastCodecs = [], C.sid !== void 0 && (x.sid = C.sid), C.stereo !== void 0 && (x.stereo = C.stereo), C.disableRed !== void 0 && (x.disableRed = C.disableRed), x;\n    },\n    fromPartial(C) {\n      var x, Q, Se, me, Ie, at, Ye, je, tt, Oe, P, X, ie;\n      const Ee = H();\n      return Ee.cid = (x = C.cid) !== null && x !== void 0 ? x : \"\", Ee.name = (Q = C.name) !== null && Q !== void 0 ? Q : \"\", Ee.type = (Se = C.type) !== null && Se !== void 0 ? Se : 0, Ee.width = (me = C.width) !== null && me !== void 0 ? me : 0, Ee.height = (Ie = C.height) !== null && Ie !== void 0 ? Ie : 0, Ee.muted = (at = C.muted) !== null && at !== void 0 ? at : !1, Ee.disableDtx = (Ye = C.disableDtx) !== null && Ye !== void 0 ? Ye : !1, Ee.source = (je = C.source) !== null && je !== void 0 ? je : 0, Ee.layers = ((tt = C.layers) === null || tt === void 0 ? void 0 : tt.map((ue) => v.VideoLayer.fromPartial(ue))) || [], Ee.simulcastCodecs = ((Oe = C.simulcastCodecs) === null || Oe === void 0 ? void 0 : Oe.map((ue) => a.SimulcastCodec.fromPartial(ue))) || [], Ee.sid = (P = C.sid) !== null && P !== void 0 ? P : \"\", Ee.stereo = (X = C.stereo) !== null && X !== void 0 ? X : !1, Ee.disableRed = (ie = C.disableRed) !== null && ie !== void 0 ? ie : !1, Ee;\n    }\n  };\n  function B() {\n    return { candidateInit: \"\", target: 0 };\n  }\n  a.TrickleRequest = {\n    encode(C, x = l.default.Writer.create()) {\n      return C.candidateInit !== void 0 && C.candidateInit !== \"\" && x.uint32(10).string(C.candidateInit), C.target !== void 0 && C.target !== 0 && x.uint32(16).int32(C.target), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = B();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.candidateInit = Q.string();\n            break;\n          case 2:\n            me.target = Q.int32();\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        candidateInit: Pe(C.candidateInit) ? String(C.candidateInit) : \"\",\n        target: Pe(C.target) ? g(C.target) : 0\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.candidateInit !== void 0 && (x.candidateInit = C.candidateInit), C.target !== void 0 && (x.target = E(C.target)), x;\n    },\n    fromPartial(C) {\n      var x, Q;\n      const Se = B();\n      return Se.candidateInit = (x = C.candidateInit) !== null && x !== void 0 ? x : \"\", Se.target = (Q = C.target) !== null && Q !== void 0 ? Q : 0, Se;\n    }\n  };\n  function Y() {\n    return { sid: \"\", muted: !1 };\n  }\n  a.MuteTrackRequest = {\n    encode(C, x = l.default.Writer.create()) {\n      return C.sid !== void 0 && C.sid !== \"\" && x.uint32(10).string(C.sid), C.muted === !0 && x.uint32(16).bool(C.muted), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = Y();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.sid = Q.string();\n            break;\n          case 2:\n            me.muted = Q.bool();\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        sid: Pe(C.sid) ? String(C.sid) : \"\",\n        muted: Pe(C.muted) ? !!C.muted : !1\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.sid !== void 0 && (x.sid = C.sid), C.muted !== void 0 && (x.muted = C.muted), x;\n    },\n    fromPartial(C) {\n      var x, Q;\n      const Se = Y();\n      return Se.sid = (x = C.sid) !== null && x !== void 0 ? x : \"\", Se.muted = (Q = C.muted) !== null && Q !== void 0 ? Q : !1, Se;\n    }\n  };\n  function ne() {\n    return {\n      room: void 0,\n      participant: void 0,\n      otherParticipants: [],\n      serverVersion: \"\",\n      iceServers: [],\n      subscriberPrimary: !1,\n      alternativeUrl: \"\",\n      clientConfiguration: void 0,\n      serverRegion: \"\",\n      pingTimeout: 0,\n      pingInterval: 0,\n      serverInfo: void 0\n    };\n  }\n  a.JoinResponse = {\n    encode(C, x = l.default.Writer.create()) {\n      if (C.room !== void 0 && v.Room.encode(C.room, x.uint32(10).fork()).ldelim(), C.participant !== void 0 && v.ParticipantInfo.encode(C.participant, x.uint32(18).fork()).ldelim(), C.otherParticipants !== void 0 && C.otherParticipants.length !== 0)\n        for (const Q of C.otherParticipants)\n          v.ParticipantInfo.encode(Q, x.uint32(26).fork()).ldelim();\n      if (C.serverVersion !== void 0 && C.serverVersion !== \"\" && x.uint32(34).string(C.serverVersion), C.iceServers !== void 0 && C.iceServers.length !== 0)\n        for (const Q of C.iceServers)\n          a.ICEServer.encode(Q, x.uint32(42).fork()).ldelim();\n      return C.subscriberPrimary === !0 && x.uint32(48).bool(C.subscriberPrimary), C.alternativeUrl !== void 0 && C.alternativeUrl !== \"\" && x.uint32(58).string(C.alternativeUrl), C.clientConfiguration !== void 0 && v.ClientConfiguration.encode(C.clientConfiguration, x.uint32(66).fork()).ldelim(), C.serverRegion !== void 0 && C.serverRegion !== \"\" && x.uint32(74).string(C.serverRegion), C.pingTimeout !== void 0 && C.pingTimeout !== 0 && x.uint32(80).int32(C.pingTimeout), C.pingInterval !== void 0 && C.pingInterval !== 0 && x.uint32(88).int32(C.pingInterval), C.serverInfo !== void 0 && v.ServerInfo.encode(C.serverInfo, x.uint32(98).fork()).ldelim(), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = ne();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.room = v.Room.decode(Q, Q.uint32());\n            break;\n          case 2:\n            me.participant = v.ParticipantInfo.decode(Q, Q.uint32());\n            break;\n          case 3:\n            me.otherParticipants.push(v.ParticipantInfo.decode(Q, Q.uint32()));\n            break;\n          case 4:\n            me.serverVersion = Q.string();\n            break;\n          case 5:\n            me.iceServers.push(a.ICEServer.decode(Q, Q.uint32()));\n            break;\n          case 6:\n            me.subscriberPrimary = Q.bool();\n            break;\n          case 7:\n            me.alternativeUrl = Q.string();\n            break;\n          case 8:\n            me.clientConfiguration = v.ClientConfiguration.decode(Q, Q.uint32());\n            break;\n          case 9:\n            me.serverRegion = Q.string();\n            break;\n          case 10:\n            me.pingTimeout = Q.int32();\n            break;\n          case 11:\n            me.pingInterval = Q.int32();\n            break;\n          case 12:\n            me.serverInfo = v.ServerInfo.decode(Q, Q.uint32());\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        room: Pe(C.room) ? v.Room.fromJSON(C.room) : void 0,\n        participant: Pe(C.participant) ? v.ParticipantInfo.fromJSON(C.participant) : void 0,\n        otherParticipants: Array.isArray(C == null ? void 0 : C.otherParticipants) ? C.otherParticipants.map((x) => v.ParticipantInfo.fromJSON(x)) : [],\n        serverVersion: Pe(C.serverVersion) ? String(C.serverVersion) : \"\",\n        iceServers: Array.isArray(C == null ? void 0 : C.iceServers) ? C.iceServers.map((x) => a.ICEServer.fromJSON(x)) : [],\n        subscriberPrimary: Pe(C.subscriberPrimary) ? !!C.subscriberPrimary : !1,\n        alternativeUrl: Pe(C.alternativeUrl) ? String(C.alternativeUrl) : \"\",\n        clientConfiguration: Pe(C.clientConfiguration) ? v.ClientConfiguration.fromJSON(C.clientConfiguration) : void 0,\n        serverRegion: Pe(C.serverRegion) ? String(C.serverRegion) : \"\",\n        pingTimeout: Pe(C.pingTimeout) ? Number(C.pingTimeout) : 0,\n        pingInterval: Pe(C.pingInterval) ? Number(C.pingInterval) : 0,\n        serverInfo: Pe(C.serverInfo) ? v.ServerInfo.fromJSON(C.serverInfo) : void 0\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.room !== void 0 && (x.room = C.room ? v.Room.toJSON(C.room) : void 0), C.participant !== void 0 && (x.participant = C.participant ? v.ParticipantInfo.toJSON(C.participant) : void 0), C.otherParticipants ? x.otherParticipants = C.otherParticipants.map((Q) => Q ? v.ParticipantInfo.toJSON(Q) : void 0) : x.otherParticipants = [], C.serverVersion !== void 0 && (x.serverVersion = C.serverVersion), C.iceServers ? x.iceServers = C.iceServers.map((Q) => Q ? a.ICEServer.toJSON(Q) : void 0) : x.iceServers = [], C.subscriberPrimary !== void 0 && (x.subscriberPrimary = C.subscriberPrimary), C.alternativeUrl !== void 0 && (x.alternativeUrl = C.alternativeUrl), C.clientConfiguration !== void 0 && (x.clientConfiguration = C.clientConfiguration ? v.ClientConfiguration.toJSON(C.clientConfiguration) : void 0), C.serverRegion !== void 0 && (x.serverRegion = C.serverRegion), C.pingTimeout !== void 0 && (x.pingTimeout = Math.round(C.pingTimeout)), C.pingInterval !== void 0 && (x.pingInterval = Math.round(C.pingInterval)), C.serverInfo !== void 0 && (x.serverInfo = C.serverInfo ? v.ServerInfo.toJSON(C.serverInfo) : void 0), x;\n    },\n    fromPartial(C) {\n      var x, Q, Se, me, Ie, at, Ye, je;\n      const tt = ne();\n      return tt.room = C.room !== void 0 && C.room !== null ? v.Room.fromPartial(C.room) : void 0, tt.participant = C.participant !== void 0 && C.participant !== null ? v.ParticipantInfo.fromPartial(C.participant) : void 0, tt.otherParticipants = ((x = C.otherParticipants) === null || x === void 0 ? void 0 : x.map((Oe) => v.ParticipantInfo.fromPartial(Oe))) || [], tt.serverVersion = (Q = C.serverVersion) !== null && Q !== void 0 ? Q : \"\", tt.iceServers = ((Se = C.iceServers) === null || Se === void 0 ? void 0 : Se.map((Oe) => a.ICEServer.fromPartial(Oe))) || [], tt.subscriberPrimary = (me = C.subscriberPrimary) !== null && me !== void 0 ? me : !1, tt.alternativeUrl = (Ie = C.alternativeUrl) !== null && Ie !== void 0 ? Ie : \"\", tt.clientConfiguration = C.clientConfiguration !== void 0 && C.clientConfiguration !== null ? v.ClientConfiguration.fromPartial(C.clientConfiguration) : void 0, tt.serverRegion = (at = C.serverRegion) !== null && at !== void 0 ? at : \"\", tt.pingTimeout = (Ye = C.pingTimeout) !== null && Ye !== void 0 ? Ye : 0, tt.pingInterval = (je = C.pingInterval) !== null && je !== void 0 ? je : 0, tt.serverInfo = C.serverInfo !== void 0 && C.serverInfo !== null ? v.ServerInfo.fromPartial(C.serverInfo) : void 0, tt;\n    }\n  };\n  function Z() {\n    return { cid: \"\", track: void 0 };\n  }\n  a.TrackPublishedResponse = {\n    encode(C, x = l.default.Writer.create()) {\n      return C.cid !== void 0 && C.cid !== \"\" && x.uint32(10).string(C.cid), C.track !== void 0 && v.TrackInfo.encode(C.track, x.uint32(18).fork()).ldelim(), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = Z();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.cid = Q.string();\n            break;\n          case 2:\n            me.track = v.TrackInfo.decode(Q, Q.uint32());\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        cid: Pe(C.cid) ? String(C.cid) : \"\",\n        track: Pe(C.track) ? v.TrackInfo.fromJSON(C.track) : void 0\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.cid !== void 0 && (x.cid = C.cid), C.track !== void 0 && (x.track = C.track ? v.TrackInfo.toJSON(C.track) : void 0), x;\n    },\n    fromPartial(C) {\n      var x;\n      const Q = Z();\n      return Q.cid = (x = C.cid) !== null && x !== void 0 ? x : \"\", Q.track = C.track !== void 0 && C.track !== null ? v.TrackInfo.fromPartial(C.track) : void 0, Q;\n    }\n  };\n  function re() {\n    return { trackSid: \"\" };\n  }\n  a.TrackUnpublishedResponse = {\n    encode(C, x = l.default.Writer.create()) {\n      return C.trackSid !== void 0 && C.trackSid !== \"\" && x.uint32(10).string(C.trackSid), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = re();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.trackSid = Q.string();\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return { trackSid: Pe(C.trackSid) ? String(C.trackSid) : \"\" };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.trackSid !== void 0 && (x.trackSid = C.trackSid), x;\n    },\n    fromPartial(C) {\n      var x;\n      const Q = re();\n      return Q.trackSid = (x = C.trackSid) !== null && x !== void 0 ? x : \"\", Q;\n    }\n  };\n  function oe() {\n    return { type: \"\", sdp: \"\" };\n  }\n  a.SessionDescription = {\n    encode(C, x = l.default.Writer.create()) {\n      return C.type !== void 0 && C.type !== \"\" && x.uint32(10).string(C.type), C.sdp !== void 0 && C.sdp !== \"\" && x.uint32(18).string(C.sdp), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = oe();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.type = Q.string();\n            break;\n          case 2:\n            me.sdp = Q.string();\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return { type: Pe(C.type) ? String(C.type) : \"\", sdp: Pe(C.sdp) ? String(C.sdp) : \"\" };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.type !== void 0 && (x.type = C.type), C.sdp !== void 0 && (x.sdp = C.sdp), x;\n    },\n    fromPartial(C) {\n      var x, Q;\n      const Se = oe();\n      return Se.type = (x = C.type) !== null && x !== void 0 ? x : \"\", Se.sdp = (Q = C.sdp) !== null && Q !== void 0 ? Q : \"\", Se;\n    }\n  };\n  function de() {\n    return { participants: [] };\n  }\n  a.ParticipantUpdate = {\n    encode(C, x = l.default.Writer.create()) {\n      if (C.participants !== void 0 && C.participants.length !== 0)\n        for (const Q of C.participants)\n          v.ParticipantInfo.encode(Q, x.uint32(10).fork()).ldelim();\n      return x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = de();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.participants.push(v.ParticipantInfo.decode(Q, Q.uint32()));\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        participants: Array.isArray(C == null ? void 0 : C.participants) ? C.participants.map((x) => v.ParticipantInfo.fromJSON(x)) : []\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.participants ? x.participants = C.participants.map((Q) => Q ? v.ParticipantInfo.toJSON(Q) : void 0) : x.participants = [], x;\n    },\n    fromPartial(C) {\n      var x;\n      const Q = de();\n      return Q.participants = ((x = C.participants) === null || x === void 0 ? void 0 : x.map((Se) => v.ParticipantInfo.fromPartial(Se))) || [], Q;\n    }\n  };\n  function A() {\n    return { trackSids: [], subscribe: !1, participantTracks: [] };\n  }\n  a.UpdateSubscription = {\n    encode(C, x = l.default.Writer.create()) {\n      if (C.trackSids !== void 0 && C.trackSids.length !== 0)\n        for (const Q of C.trackSids)\n          x.uint32(10).string(Q);\n      if (C.subscribe === !0 && x.uint32(16).bool(C.subscribe), C.participantTracks !== void 0 && C.participantTracks.length !== 0)\n        for (const Q of C.participantTracks)\n          v.ParticipantTracks.encode(Q, x.uint32(26).fork()).ldelim();\n      return x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = A();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.trackSids.push(Q.string());\n            break;\n          case 2:\n            me.subscribe = Q.bool();\n            break;\n          case 3:\n            me.participantTracks.push(v.ParticipantTracks.decode(Q, Q.uint32()));\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        trackSids: Array.isArray(C == null ? void 0 : C.trackSids) ? C.trackSids.map((x) => String(x)) : [],\n        subscribe: Pe(C.subscribe) ? !!C.subscribe : !1,\n        participantTracks: Array.isArray(C == null ? void 0 : C.participantTracks) ? C.participantTracks.map((x) => v.ParticipantTracks.fromJSON(x)) : []\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.trackSids ? x.trackSids = C.trackSids.map((Q) => Q) : x.trackSids = [], C.subscribe !== void 0 && (x.subscribe = C.subscribe), C.participantTracks ? x.participantTracks = C.participantTracks.map((Q) => Q ? v.ParticipantTracks.toJSON(Q) : void 0) : x.participantTracks = [], x;\n    },\n    fromPartial(C) {\n      var x, Q, Se;\n      const me = A();\n      return me.trackSids = ((x = C.trackSids) === null || x === void 0 ? void 0 : x.map((Ie) => Ie)) || [], me.subscribe = (Q = C.subscribe) !== null && Q !== void 0 ? Q : !1, me.participantTracks = ((Se = C.participantTracks) === null || Se === void 0 ? void 0 : Se.map((Ie) => v.ParticipantTracks.fromPartial(Ie))) || [], me;\n    }\n  };\n  function N() {\n    return { trackSids: [], disabled: !1, quality: 0, width: 0, height: 0, fps: 0 };\n  }\n  a.UpdateTrackSettings = {\n    encode(C, x = l.default.Writer.create()) {\n      if (C.trackSids !== void 0 && C.trackSids.length !== 0)\n        for (const Q of C.trackSids)\n          x.uint32(10).string(Q);\n      return C.disabled === !0 && x.uint32(24).bool(C.disabled), C.quality !== void 0 && C.quality !== 0 && x.uint32(32).int32(C.quality), C.width !== void 0 && C.width !== 0 && x.uint32(40).uint32(C.width), C.height !== void 0 && C.height !== 0 && x.uint32(48).uint32(C.height), C.fps !== void 0 && C.fps !== 0 && x.uint32(56).uint32(C.fps), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = N();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.trackSids.push(Q.string());\n            break;\n          case 3:\n            me.disabled = Q.bool();\n            break;\n          case 4:\n            me.quality = Q.int32();\n            break;\n          case 5:\n            me.width = Q.uint32();\n            break;\n          case 6:\n            me.height = Q.uint32();\n            break;\n          case 7:\n            me.fps = Q.uint32();\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        trackSids: Array.isArray(C == null ? void 0 : C.trackSids) ? C.trackSids.map((x) => String(x)) : [],\n        disabled: Pe(C.disabled) ? !!C.disabled : !1,\n        quality: Pe(C.quality) ? v.videoQualityFromJSON(C.quality) : 0,\n        width: Pe(C.width) ? Number(C.width) : 0,\n        height: Pe(C.height) ? Number(C.height) : 0,\n        fps: Pe(C.fps) ? Number(C.fps) : 0\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.trackSids ? x.trackSids = C.trackSids.map((Q) => Q) : x.trackSids = [], C.disabled !== void 0 && (x.disabled = C.disabled), C.quality !== void 0 && (x.quality = v.videoQualityToJSON(C.quality)), C.width !== void 0 && (x.width = Math.round(C.width)), C.height !== void 0 && (x.height = Math.round(C.height)), C.fps !== void 0 && (x.fps = Math.round(C.fps)), x;\n    },\n    fromPartial(C) {\n      var x, Q, Se, me, Ie, at;\n      const Ye = N();\n      return Ye.trackSids = ((x = C.trackSids) === null || x === void 0 ? void 0 : x.map((je) => je)) || [], Ye.disabled = (Q = C.disabled) !== null && Q !== void 0 ? Q : !1, Ye.quality = (Se = C.quality) !== null && Se !== void 0 ? Se : 0, Ye.width = (me = C.width) !== null && me !== void 0 ? me : 0, Ye.height = (Ie = C.height) !== null && Ie !== void 0 ? Ie : 0, Ye.fps = (at = C.fps) !== null && at !== void 0 ? at : 0, Ye;\n    }\n  };\n  function D() {\n    return { canReconnect: !1, reason: 0 };\n  }\n  a.LeaveRequest = {\n    encode(C, x = l.default.Writer.create()) {\n      return C.canReconnect === !0 && x.uint32(8).bool(C.canReconnect), C.reason !== void 0 && C.reason !== 0 && x.uint32(16).int32(C.reason), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = D();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.canReconnect = Q.bool();\n            break;\n          case 2:\n            me.reason = Q.int32();\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        canReconnect: Pe(C.canReconnect) ? !!C.canReconnect : !1,\n        reason: Pe(C.reason) ? v.disconnectReasonFromJSON(C.reason) : 0\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.canReconnect !== void 0 && (x.canReconnect = C.canReconnect), C.reason !== void 0 && (x.reason = v.disconnectReasonToJSON(C.reason)), x;\n    },\n    fromPartial(C) {\n      var x, Q;\n      const Se = D();\n      return Se.canReconnect = (x = C.canReconnect) !== null && x !== void 0 ? x : !1, Se.reason = (Q = C.reason) !== null && Q !== void 0 ? Q : 0, Se;\n    }\n  };\n  function W() {\n    return { trackSid: \"\", layers: [] };\n  }\n  a.UpdateVideoLayers = {\n    encode(C, x = l.default.Writer.create()) {\n      if (C.trackSid !== void 0 && C.trackSid !== \"\" && x.uint32(10).string(C.trackSid), C.layers !== void 0 && C.layers.length !== 0)\n        for (const Q of C.layers)\n          v.VideoLayer.encode(Q, x.uint32(18).fork()).ldelim();\n      return x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = W();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.trackSid = Q.string();\n            break;\n          case 2:\n            me.layers.push(v.VideoLayer.decode(Q, Q.uint32()));\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        trackSid: Pe(C.trackSid) ? String(C.trackSid) : \"\",\n        layers: Array.isArray(C == null ? void 0 : C.layers) ? C.layers.map((x) => v.VideoLayer.fromJSON(x)) : []\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.trackSid !== void 0 && (x.trackSid = C.trackSid), C.layers ? x.layers = C.layers.map((Q) => Q ? v.VideoLayer.toJSON(Q) : void 0) : x.layers = [], x;\n    },\n    fromPartial(C) {\n      var x, Q;\n      const Se = W();\n      return Se.trackSid = (x = C.trackSid) !== null && x !== void 0 ? x : \"\", Se.layers = ((Q = C.layers) === null || Q === void 0 ? void 0 : Q.map((me) => v.VideoLayer.fromPartial(me))) || [], Se;\n    }\n  };\n  function ee() {\n    return { urls: [], username: \"\", credential: \"\" };\n  }\n  a.ICEServer = {\n    encode(C, x = l.default.Writer.create()) {\n      if (C.urls !== void 0 && C.urls.length !== 0)\n        for (const Q of C.urls)\n          x.uint32(10).string(Q);\n      return C.username !== void 0 && C.username !== \"\" && x.uint32(18).string(C.username), C.credential !== void 0 && C.credential !== \"\" && x.uint32(26).string(C.credential), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = ee();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.urls.push(Q.string());\n            break;\n          case 2:\n            me.username = Q.string();\n            break;\n          case 3:\n            me.credential = Q.string();\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        urls: Array.isArray(C == null ? void 0 : C.urls) ? C.urls.map((x) => String(x)) : [],\n        username: Pe(C.username) ? String(C.username) : \"\",\n        credential: Pe(C.credential) ? String(C.credential) : \"\"\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.urls ? x.urls = C.urls.map((Q) => Q) : x.urls = [], C.username !== void 0 && (x.username = C.username), C.credential !== void 0 && (x.credential = C.credential), x;\n    },\n    fromPartial(C) {\n      var x, Q, Se;\n      const me = ee();\n      return me.urls = ((x = C.urls) === null || x === void 0 ? void 0 : x.map((Ie) => Ie)) || [], me.username = (Q = C.username) !== null && Q !== void 0 ? Q : \"\", me.credential = (Se = C.credential) !== null && Se !== void 0 ? Se : \"\", me;\n    }\n  };\n  function ae() {\n    return { speakers: [] };\n  }\n  a.SpeakersChanged = {\n    encode(C, x = l.default.Writer.create()) {\n      if (C.speakers !== void 0 && C.speakers.length !== 0)\n        for (const Q of C.speakers)\n          v.SpeakerInfo.encode(Q, x.uint32(10).fork()).ldelim();\n      return x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = ae();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.speakers.push(v.SpeakerInfo.decode(Q, Q.uint32()));\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        speakers: Array.isArray(C == null ? void 0 : C.speakers) ? C.speakers.map((x) => v.SpeakerInfo.fromJSON(x)) : []\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.speakers ? x.speakers = C.speakers.map((Q) => Q ? v.SpeakerInfo.toJSON(Q) : void 0) : x.speakers = [], x;\n    },\n    fromPartial(C) {\n      var x;\n      const Q = ae();\n      return Q.speakers = ((x = C.speakers) === null || x === void 0 ? void 0 : x.map((Se) => v.SpeakerInfo.fromPartial(Se))) || [], Q;\n    }\n  };\n  function ye() {\n    return { room: void 0 };\n  }\n  a.RoomUpdate = {\n    encode(C, x = l.default.Writer.create()) {\n      return C.room !== void 0 && v.Room.encode(C.room, x.uint32(10).fork()).ldelim(), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = ye();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.room = v.Room.decode(Q, Q.uint32());\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return { room: Pe(C.room) ? v.Room.fromJSON(C.room) : void 0 };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.room !== void 0 && (x.room = C.room ? v.Room.toJSON(C.room) : void 0), x;\n    },\n    fromPartial(C) {\n      const x = ye();\n      return x.room = C.room !== void 0 && C.room !== null ? v.Room.fromPartial(C.room) : void 0, x;\n    }\n  };\n  function he() {\n    return { participantSid: \"\", quality: 0, score: 0 };\n  }\n  a.ConnectionQualityInfo = {\n    encode(C, x = l.default.Writer.create()) {\n      return C.participantSid !== void 0 && C.participantSid !== \"\" && x.uint32(10).string(C.participantSid), C.quality !== void 0 && C.quality !== 0 && x.uint32(16).int32(C.quality), C.score !== void 0 && C.score !== 0 && x.uint32(29).float(C.score), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = he();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.participantSid = Q.string();\n            break;\n          case 2:\n            me.quality = Q.int32();\n            break;\n          case 3:\n            me.score = Q.float();\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        participantSid: Pe(C.participantSid) ? String(C.participantSid) : \"\",\n        quality: Pe(C.quality) ? v.connectionQualityFromJSON(C.quality) : 0,\n        score: Pe(C.score) ? Number(C.score) : 0\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.participantSid !== void 0 && (x.participantSid = C.participantSid), C.quality !== void 0 && (x.quality = v.connectionQualityToJSON(C.quality)), C.score !== void 0 && (x.score = C.score), x;\n    },\n    fromPartial(C) {\n      var x, Q, Se;\n      const me = he();\n      return me.participantSid = (x = C.participantSid) !== null && x !== void 0 ? x : \"\", me.quality = (Q = C.quality) !== null && Q !== void 0 ? Q : 0, me.score = (Se = C.score) !== null && Se !== void 0 ? Se : 0, me;\n    }\n  };\n  function le() {\n    return { updates: [] };\n  }\n  a.ConnectionQualityUpdate = {\n    encode(C, x = l.default.Writer.create()) {\n      if (C.updates !== void 0 && C.updates.length !== 0)\n        for (const Q of C.updates)\n          a.ConnectionQualityInfo.encode(Q, x.uint32(10).fork()).ldelim();\n      return x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = le();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.updates.push(a.ConnectionQualityInfo.decode(Q, Q.uint32()));\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        updates: Array.isArray(C == null ? void 0 : C.updates) ? C.updates.map((x) => a.ConnectionQualityInfo.fromJSON(x)) : []\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.updates ? x.updates = C.updates.map((Q) => Q ? a.ConnectionQualityInfo.toJSON(Q) : void 0) : x.updates = [], x;\n    },\n    fromPartial(C) {\n      var x;\n      const Q = le();\n      return Q.updates = ((x = C.updates) === null || x === void 0 ? void 0 : x.map((Se) => a.ConnectionQualityInfo.fromPartial(Se))) || [], Q;\n    }\n  };\n  function we() {\n    return { participantSid: \"\", trackSid: \"\", state: 0 };\n  }\n  a.StreamStateInfo = {\n    encode(C, x = l.default.Writer.create()) {\n      return C.participantSid !== void 0 && C.participantSid !== \"\" && x.uint32(10).string(C.participantSid), C.trackSid !== void 0 && C.trackSid !== \"\" && x.uint32(18).string(C.trackSid), C.state !== void 0 && C.state !== 0 && x.uint32(24).int32(C.state), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = we();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.participantSid = Q.string();\n            break;\n          case 2:\n            me.trackSid = Q.string();\n            break;\n          case 3:\n            me.state = Q.int32();\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        participantSid: Pe(C.participantSid) ? String(C.participantSid) : \"\",\n        trackSid: Pe(C.trackSid) ? String(C.trackSid) : \"\",\n        state: Pe(C.state) ? k(C.state) : 0\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.participantSid !== void 0 && (x.participantSid = C.participantSid), C.trackSid !== void 0 && (x.trackSid = C.trackSid), C.state !== void 0 && (x.state = L(C.state)), x;\n    },\n    fromPartial(C) {\n      var x, Q, Se;\n      const me = we();\n      return me.participantSid = (x = C.participantSid) !== null && x !== void 0 ? x : \"\", me.trackSid = (Q = C.trackSid) !== null && Q !== void 0 ? Q : \"\", me.state = (Se = C.state) !== null && Se !== void 0 ? Se : 0, me;\n    }\n  };\n  function Be() {\n    return { streamStates: [] };\n  }\n  a.StreamStateUpdate = {\n    encode(C, x = l.default.Writer.create()) {\n      if (C.streamStates !== void 0 && C.streamStates.length !== 0)\n        for (const Q of C.streamStates)\n          a.StreamStateInfo.encode(Q, x.uint32(10).fork()).ldelim();\n      return x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = Be();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.streamStates.push(a.StreamStateInfo.decode(Q, Q.uint32()));\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        streamStates: Array.isArray(C == null ? void 0 : C.streamStates) ? C.streamStates.map((x) => a.StreamStateInfo.fromJSON(x)) : []\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.streamStates ? x.streamStates = C.streamStates.map((Q) => Q ? a.StreamStateInfo.toJSON(Q) : void 0) : x.streamStates = [], x;\n    },\n    fromPartial(C) {\n      var x;\n      const Q = Be();\n      return Q.streamStates = ((x = C.streamStates) === null || x === void 0 ? void 0 : x.map((Se) => a.StreamStateInfo.fromPartial(Se))) || [], Q;\n    }\n  };\n  function Ne() {\n    return { quality: 0, enabled: !1 };\n  }\n  a.SubscribedQuality = {\n    encode(C, x = l.default.Writer.create()) {\n      return C.quality !== void 0 && C.quality !== 0 && x.uint32(8).int32(C.quality), C.enabled === !0 && x.uint32(16).bool(C.enabled), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = Ne();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.quality = Q.int32();\n            break;\n          case 2:\n            me.enabled = Q.bool();\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        quality: Pe(C.quality) ? v.videoQualityFromJSON(C.quality) : 0,\n        enabled: Pe(C.enabled) ? !!C.enabled : !1\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.quality !== void 0 && (x.quality = v.videoQualityToJSON(C.quality)), C.enabled !== void 0 && (x.enabled = C.enabled), x;\n    },\n    fromPartial(C) {\n      var x, Q;\n      const Se = Ne();\n      return Se.quality = (x = C.quality) !== null && x !== void 0 ? x : 0, Se.enabled = (Q = C.enabled) !== null && Q !== void 0 ? Q : !1, Se;\n    }\n  };\n  function Le() {\n    return { codec: \"\", qualities: [] };\n  }\n  a.SubscribedCodec = {\n    encode(C, x = l.default.Writer.create()) {\n      if (C.codec !== void 0 && C.codec !== \"\" && x.uint32(10).string(C.codec), C.qualities !== void 0 && C.qualities.length !== 0)\n        for (const Q of C.qualities)\n          a.SubscribedQuality.encode(Q, x.uint32(18).fork()).ldelim();\n      return x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = Le();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.codec = Q.string();\n            break;\n          case 2:\n            me.qualities.push(a.SubscribedQuality.decode(Q, Q.uint32()));\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        codec: Pe(C.codec) ? String(C.codec) : \"\",\n        qualities: Array.isArray(C == null ? void 0 : C.qualities) ? C.qualities.map((x) => a.SubscribedQuality.fromJSON(x)) : []\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.codec !== void 0 && (x.codec = C.codec), C.qualities ? x.qualities = C.qualities.map((Q) => Q ? a.SubscribedQuality.toJSON(Q) : void 0) : x.qualities = [], x;\n    },\n    fromPartial(C) {\n      var x, Q;\n      const Se = Le();\n      return Se.codec = (x = C.codec) !== null && x !== void 0 ? x : \"\", Se.qualities = ((Q = C.qualities) === null || Q === void 0 ? void 0 : Q.map((me) => a.SubscribedQuality.fromPartial(me))) || [], Se;\n    }\n  };\n  function $e() {\n    return { trackSid: \"\", subscribedQualities: [], subscribedCodecs: [] };\n  }\n  a.SubscribedQualityUpdate = {\n    encode(C, x = l.default.Writer.create()) {\n      if (C.trackSid !== void 0 && C.trackSid !== \"\" && x.uint32(10).string(C.trackSid), C.subscribedQualities !== void 0 && C.subscribedQualities.length !== 0)\n        for (const Q of C.subscribedQualities)\n          a.SubscribedQuality.encode(Q, x.uint32(18).fork()).ldelim();\n      if (C.subscribedCodecs !== void 0 && C.subscribedCodecs.length !== 0)\n        for (const Q of C.subscribedCodecs)\n          a.SubscribedCodec.encode(Q, x.uint32(26).fork()).ldelim();\n      return x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = $e();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.trackSid = Q.string();\n            break;\n          case 2:\n            me.subscribedQualities.push(a.SubscribedQuality.decode(Q, Q.uint32()));\n            break;\n          case 3:\n            me.subscribedCodecs.push(a.SubscribedCodec.decode(Q, Q.uint32()));\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        trackSid: Pe(C.trackSid) ? String(C.trackSid) : \"\",\n        subscribedQualities: Array.isArray(C == null ? void 0 : C.subscribedQualities) ? C.subscribedQualities.map((x) => a.SubscribedQuality.fromJSON(x)) : [],\n        subscribedCodecs: Array.isArray(C == null ? void 0 : C.subscribedCodecs) ? C.subscribedCodecs.map((x) => a.SubscribedCodec.fromJSON(x)) : []\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.trackSid !== void 0 && (x.trackSid = C.trackSid), C.subscribedQualities ? x.subscribedQualities = C.subscribedQualities.map((Q) => Q ? a.SubscribedQuality.toJSON(Q) : void 0) : x.subscribedQualities = [], C.subscribedCodecs ? x.subscribedCodecs = C.subscribedCodecs.map((Q) => Q ? a.SubscribedCodec.toJSON(Q) : void 0) : x.subscribedCodecs = [], x;\n    },\n    fromPartial(C) {\n      var x, Q, Se;\n      const me = $e();\n      return me.trackSid = (x = C.trackSid) !== null && x !== void 0 ? x : \"\", me.subscribedQualities = ((Q = C.subscribedQualities) === null || Q === void 0 ? void 0 : Q.map((Ie) => a.SubscribedQuality.fromPartial(Ie))) || [], me.subscribedCodecs = ((Se = C.subscribedCodecs) === null || Se === void 0 ? void 0 : Se.map((Ie) => a.SubscribedCodec.fromPartial(Ie))) || [], me;\n    }\n  };\n  function Ue() {\n    return { participantSid: \"\", allTracks: !1, trackSids: [], participantIdentity: \"\" };\n  }\n  a.TrackPermission = {\n    encode(C, x = l.default.Writer.create()) {\n      if (C.participantSid !== void 0 && C.participantSid !== \"\" && x.uint32(10).string(C.participantSid), C.allTracks === !0 && x.uint32(16).bool(C.allTracks), C.trackSids !== void 0 && C.trackSids.length !== 0)\n        for (const Q of C.trackSids)\n          x.uint32(26).string(Q);\n      return C.participantIdentity !== void 0 && C.participantIdentity !== \"\" && x.uint32(34).string(C.participantIdentity), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = Ue();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.participantSid = Q.string();\n            break;\n          case 2:\n            me.allTracks = Q.bool();\n            break;\n          case 3:\n            me.trackSids.push(Q.string());\n            break;\n          case 4:\n            me.participantIdentity = Q.string();\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        participantSid: Pe(C.participantSid) ? String(C.participantSid) : \"\",\n        allTracks: Pe(C.allTracks) ? !!C.allTracks : !1,\n        trackSids: Array.isArray(C == null ? void 0 : C.trackSids) ? C.trackSids.map((x) => String(x)) : [],\n        participantIdentity: Pe(C.participantIdentity) ? String(C.participantIdentity) : \"\"\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.participantSid !== void 0 && (x.participantSid = C.participantSid), C.allTracks !== void 0 && (x.allTracks = C.allTracks), C.trackSids ? x.trackSids = C.trackSids.map((Q) => Q) : x.trackSids = [], C.participantIdentity !== void 0 && (x.participantIdentity = C.participantIdentity), x;\n    },\n    fromPartial(C) {\n      var x, Q, Se, me;\n      const Ie = Ue();\n      return Ie.participantSid = (x = C.participantSid) !== null && x !== void 0 ? x : \"\", Ie.allTracks = (Q = C.allTracks) !== null && Q !== void 0 ? Q : !1, Ie.trackSids = ((Se = C.trackSids) === null || Se === void 0 ? void 0 : Se.map((at) => at)) || [], Ie.participantIdentity = (me = C.participantIdentity) !== null && me !== void 0 ? me : \"\", Ie;\n    }\n  };\n  function Ge() {\n    return { allParticipants: !1, trackPermissions: [] };\n  }\n  a.SubscriptionPermission = {\n    encode(C, x = l.default.Writer.create()) {\n      if (C.allParticipants === !0 && x.uint32(8).bool(C.allParticipants), C.trackPermissions !== void 0 && C.trackPermissions.length !== 0)\n        for (const Q of C.trackPermissions)\n          a.TrackPermission.encode(Q, x.uint32(18).fork()).ldelim();\n      return x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = Ge();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.allParticipants = Q.bool();\n            break;\n          case 2:\n            me.trackPermissions.push(a.TrackPermission.decode(Q, Q.uint32()));\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        allParticipants: Pe(C.allParticipants) ? !!C.allParticipants : !1,\n        trackPermissions: Array.isArray(C == null ? void 0 : C.trackPermissions) ? C.trackPermissions.map((x) => a.TrackPermission.fromJSON(x)) : []\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.allParticipants !== void 0 && (x.allParticipants = C.allParticipants), C.trackPermissions ? x.trackPermissions = C.trackPermissions.map((Q) => Q ? a.TrackPermission.toJSON(Q) : void 0) : x.trackPermissions = [], x;\n    },\n    fromPartial(C) {\n      var x, Q;\n      const Se = Ge();\n      return Se.allParticipants = (x = C.allParticipants) !== null && x !== void 0 ? x : !1, Se.trackPermissions = ((Q = C.trackPermissions) === null || Q === void 0 ? void 0 : Q.map((me) => a.TrackPermission.fromPartial(me))) || [], Se;\n    }\n  };\n  function He() {\n    return { participantSid: \"\", trackSid: \"\", allowed: !1 };\n  }\n  a.SubscriptionPermissionUpdate = {\n    encode(C, x = l.default.Writer.create()) {\n      return C.participantSid !== void 0 && C.participantSid !== \"\" && x.uint32(10).string(C.participantSid), C.trackSid !== void 0 && C.trackSid !== \"\" && x.uint32(18).string(C.trackSid), C.allowed === !0 && x.uint32(24).bool(C.allowed), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = He();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.participantSid = Q.string();\n            break;\n          case 2:\n            me.trackSid = Q.string();\n            break;\n          case 3:\n            me.allowed = Q.bool();\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        participantSid: Pe(C.participantSid) ? String(C.participantSid) : \"\",\n        trackSid: Pe(C.trackSid) ? String(C.trackSid) : \"\",\n        allowed: Pe(C.allowed) ? !!C.allowed : !1\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.participantSid !== void 0 && (x.participantSid = C.participantSid), C.trackSid !== void 0 && (x.trackSid = C.trackSid), C.allowed !== void 0 && (x.allowed = C.allowed), x;\n    },\n    fromPartial(C) {\n      var x, Q, Se;\n      const me = He();\n      return me.participantSid = (x = C.participantSid) !== null && x !== void 0 ? x : \"\", me.trackSid = (Q = C.trackSid) !== null && Q !== void 0 ? Q : \"\", me.allowed = (Se = C.allowed) !== null && Se !== void 0 ? Se : !1, me;\n    }\n  };\n  function Ve() {\n    return { answer: void 0, subscription: void 0, publishTracks: [], dataChannels: [], offer: void 0 };\n  }\n  a.SyncState = {\n    encode(C, x = l.default.Writer.create()) {\n      if (C.answer !== void 0 && a.SessionDescription.encode(C.answer, x.uint32(10).fork()).ldelim(), C.subscription !== void 0 && a.UpdateSubscription.encode(C.subscription, x.uint32(18).fork()).ldelim(), C.publishTracks !== void 0 && C.publishTracks.length !== 0)\n        for (const Q of C.publishTracks)\n          a.TrackPublishedResponse.encode(Q, x.uint32(26).fork()).ldelim();\n      if (C.dataChannels !== void 0 && C.dataChannels.length !== 0)\n        for (const Q of C.dataChannels)\n          a.DataChannelInfo.encode(Q, x.uint32(34).fork()).ldelim();\n      return C.offer !== void 0 && a.SessionDescription.encode(C.offer, x.uint32(42).fork()).ldelim(), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = Ve();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.answer = a.SessionDescription.decode(Q, Q.uint32());\n            break;\n          case 2:\n            me.subscription = a.UpdateSubscription.decode(Q, Q.uint32());\n            break;\n          case 3:\n            me.publishTracks.push(a.TrackPublishedResponse.decode(Q, Q.uint32()));\n            break;\n          case 4:\n            me.dataChannels.push(a.DataChannelInfo.decode(Q, Q.uint32()));\n            break;\n          case 5:\n            me.offer = a.SessionDescription.decode(Q, Q.uint32());\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        answer: Pe(C.answer) ? a.SessionDescription.fromJSON(C.answer) : void 0,\n        subscription: Pe(C.subscription) ? a.UpdateSubscription.fromJSON(C.subscription) : void 0,\n        publishTracks: Array.isArray(C == null ? void 0 : C.publishTracks) ? C.publishTracks.map((x) => a.TrackPublishedResponse.fromJSON(x)) : [],\n        dataChannels: Array.isArray(C == null ? void 0 : C.dataChannels) ? C.dataChannels.map((x) => a.DataChannelInfo.fromJSON(x)) : [],\n        offer: Pe(C.offer) ? a.SessionDescription.fromJSON(C.offer) : void 0\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.answer !== void 0 && (x.answer = C.answer ? a.SessionDescription.toJSON(C.answer) : void 0), C.subscription !== void 0 && (x.subscription = C.subscription ? a.UpdateSubscription.toJSON(C.subscription) : void 0), C.publishTracks ? x.publishTracks = C.publishTracks.map((Q) => Q ? a.TrackPublishedResponse.toJSON(Q) : void 0) : x.publishTracks = [], C.dataChannels ? x.dataChannels = C.dataChannels.map((Q) => Q ? a.DataChannelInfo.toJSON(Q) : void 0) : x.dataChannels = [], C.offer !== void 0 && (x.offer = C.offer ? a.SessionDescription.toJSON(C.offer) : void 0), x;\n    },\n    fromPartial(C) {\n      var x, Q;\n      const Se = Ve();\n      return Se.answer = C.answer !== void 0 && C.answer !== null ? a.SessionDescription.fromPartial(C.answer) : void 0, Se.subscription = C.subscription !== void 0 && C.subscription !== null ? a.UpdateSubscription.fromPartial(C.subscription) : void 0, Se.publishTracks = ((x = C.publishTracks) === null || x === void 0 ? void 0 : x.map((me) => a.TrackPublishedResponse.fromPartial(me))) || [], Se.dataChannels = ((Q = C.dataChannels) === null || Q === void 0 ? void 0 : Q.map((me) => a.DataChannelInfo.fromPartial(me))) || [], Se.offer = C.offer !== void 0 && C.offer !== null ? a.SessionDescription.fromPartial(C.offer) : void 0, Se;\n    }\n  };\n  function be() {\n    return { label: \"\", id: 0, target: 0 };\n  }\n  a.DataChannelInfo = {\n    encode(C, x = l.default.Writer.create()) {\n      return C.label !== void 0 && C.label !== \"\" && x.uint32(10).string(C.label), C.id !== void 0 && C.id !== 0 && x.uint32(16).uint32(C.id), C.target !== void 0 && C.target !== 0 && x.uint32(24).int32(C.target), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = be();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.label = Q.string();\n            break;\n          case 2:\n            me.id = Q.uint32();\n            break;\n          case 3:\n            me.target = Q.int32();\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        label: Pe(C.label) ? String(C.label) : \"\",\n        id: Pe(C.id) ? Number(C.id) : 0,\n        target: Pe(C.target) ? g(C.target) : 0\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.label !== void 0 && (x.label = C.label), C.id !== void 0 && (x.id = Math.round(C.id)), C.target !== void 0 && (x.target = E(C.target)), x;\n    },\n    fromPartial(C) {\n      var x, Q, Se;\n      const me = be();\n      return me.label = (x = C.label) !== null && x !== void 0 ? x : \"\", me.id = (Q = C.id) !== null && Q !== void 0 ? Q : 0, me.target = (Se = C.target) !== null && Se !== void 0 ? Se : 0, me;\n    }\n  };\n  function Ae() {\n    return {\n      speakerUpdate: void 0,\n      nodeFailure: void 0,\n      migration: void 0,\n      serverLeave: void 0,\n      switchCandidateProtocol: void 0\n    };\n  }\n  a.SimulateScenario = {\n    encode(C, x = l.default.Writer.create()) {\n      return C.speakerUpdate !== void 0 && x.uint32(8).int32(C.speakerUpdate), C.nodeFailure !== void 0 && x.uint32(16).bool(C.nodeFailure), C.migration !== void 0 && x.uint32(24).bool(C.migration), C.serverLeave !== void 0 && x.uint32(32).bool(C.serverLeave), C.switchCandidateProtocol !== void 0 && x.uint32(40).int32(C.switchCandidateProtocol), x;\n    },\n    decode(C, x) {\n      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);\n      let Se = x === void 0 ? Q.len : Q.pos + x;\n      const me = Ae();\n      for (; Q.pos < Se; ) {\n        const Ie = Q.uint32();\n        switch (Ie >>> 3) {\n          case 1:\n            me.speakerUpdate = Q.int32();\n            break;\n          case 2:\n            me.nodeFailure = Q.bool();\n            break;\n          case 3:\n            me.migration = Q.bool();\n            break;\n          case 4:\n            me.serverLeave = Q.bool();\n            break;\n          case 5:\n            me.switchCandidateProtocol = Q.int32();\n            break;\n          default:\n            Q.skipType(Ie & 7);\n            break;\n        }\n      }\n      return me;\n    },\n    fromJSON(C) {\n      return {\n        speakerUpdate: Pe(C.speakerUpdate) ? Number(C.speakerUpdate) : void 0,\n        nodeFailure: Pe(C.nodeFailure) ? !!C.nodeFailure : void 0,\n        migration: Pe(C.migration) ? !!C.migration : void 0,\n        serverLeave: Pe(C.serverLeave) ? !!C.serverLeave : void 0,\n        switchCandidateProtocol: Pe(C.switchCandidateProtocol) ? $(C.switchCandidateProtocol) : void 0\n      };\n    },\n    toJSON(C) {\n      const x = {};\n      return C.speakerUpdate !== void 0 && (x.speakerUpdate = Math.round(C.speakerUpdate)), C.nodeFailure !== void 0 && (x.nodeFailure = C.nodeFailure), C.migration !== void 0 && (x.migration = C.migration), C.serverLeave !== void 0 && (x.serverLeave = C.serverLeave), C.switchCandidateProtocol !== void 0 && (x.switchCandidateProtocol = C.switchCandidateProtocol !== void 0 ? J(C.switchCandidateProtocol) : void 0), x;\n    },\n    fromPartial(C) {\n      var x, Q, Se, me, Ie;\n      const at = Ae();\n      return at.speakerUpdate = (x = C.speakerUpdate) !== null && x !== void 0 ? x : void 0, at.nodeFailure = (Q = C.nodeFailure) !== null && Q !== void 0 ? Q : void 0, at.migration = (Se = C.migration) !== null && Se !== void 0 ? Se : void 0, at.serverLeave = (me = C.serverLeave) !== null && me !== void 0 ? me : void 0, at.switchCandidateProtocol = (Ie = C.switchCandidateProtocol) !== null && Ie !== void 0 ? Ie : void 0, at;\n    }\n  };\n  var qe = (() => {\n    if (typeof qe < \"u\")\n      return qe;\n    if (typeof self < \"u\")\n      return self;\n    if (typeof window < \"u\")\n      return window;\n    if (typeof commonjsGlobal$1 < \"u\")\n      return commonjsGlobal$1;\n    throw \"Unable to locate global object\";\n  })();\n  function xe(C) {\n    if (C.gt(Number.MAX_SAFE_INTEGER))\n      throw new qe.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n    return C.toNumber();\n  }\n  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());\n  function Pe(C) {\n    return C != null;\n  }\n})(livekit_rtc);\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(N) {\n    return N && N.__esModule ? N : { default: N };\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.RoomInternal = a.KeepAlive = a.RemoveParticipant = a.EndSession = a.StartSession = a.SignalNodeMessage = a.RTCNodeMessage = a.NodeStats = a.Node = a.nodeStateToJSON = a.nodeStateFromJSON = a.NodeState = a.nodeTypeToJSON = a.nodeTypeFromJSON = a.NodeType = a.protobufPackage = void 0;\n  const c = u(umdExports), l = u(minimal), v = livekit_egress, S = livekit_models, g = livekit_room, E = livekit_rtc;\n  a.protobufPackage = \"livekit\";\n  var _;\n  (function(N) {\n    N[N.SERVER = 0] = \"SERVER\", N[N.CONTROLLER = 1] = \"CONTROLLER\", N[N.MEDIA = 2] = \"MEDIA\", N[N.TURN = 4] = \"TURN\", N[N.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(_ = a.NodeType || (a.NodeType = {}));\n  function k(N) {\n    switch (N) {\n      case 0:\n      case \"SERVER\":\n        return _.SERVER;\n      case 1:\n      case \"CONTROLLER\":\n        return _.CONTROLLER;\n      case 2:\n      case \"MEDIA\":\n        return _.MEDIA;\n      case 4:\n      case \"TURN\":\n        return _.TURN;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return _.UNRECOGNIZED;\n    }\n  }\n  a.nodeTypeFromJSON = k;\n  function L(N) {\n    switch (N) {\n      case _.SERVER:\n        return \"SERVER\";\n      case _.CONTROLLER:\n        return \"CONTROLLER\";\n      case _.MEDIA:\n        return \"MEDIA\";\n      case _.TURN:\n        return \"TURN\";\n      case _.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.nodeTypeToJSON = L;\n  var M;\n  (function(N) {\n    N[N.STARTING_UP = 0] = \"STARTING_UP\", N[N.SERVING = 1] = \"SERVING\", N[N.SHUTTING_DOWN = 2] = \"SHUTTING_DOWN\", N[N.UNRECOGNIZED = -1] = \"UNRECOGNIZED\";\n  })(M = a.NodeState || (a.NodeState = {}));\n  function $(N) {\n    switch (N) {\n      case 0:\n      case \"STARTING_UP\":\n        return M.STARTING_UP;\n      case 1:\n      case \"SERVING\":\n        return M.SERVING;\n      case 2:\n      case \"SHUTTING_DOWN\":\n        return M.SHUTTING_DOWN;\n      case -1:\n      case \"UNRECOGNIZED\":\n      default:\n        return M.UNRECOGNIZED;\n    }\n  }\n  a.nodeStateFromJSON = $;\n  function J(N) {\n    switch (N) {\n      case M.STARTING_UP:\n        return \"STARTING_UP\";\n      case M.SERVING:\n        return \"SERVING\";\n      case M.SHUTTING_DOWN:\n        return \"SHUTTING_DOWN\";\n      case M.UNRECOGNIZED:\n      default:\n        return \"UNRECOGNIZED\";\n    }\n  }\n  a.nodeStateToJSON = J;\n  function V() {\n    return { id: \"\", ip: \"\", numCpus: 0, stats: void 0, type: 0, state: 0, region: \"\" };\n  }\n  a.Node = {\n    encode(N, D = l.default.Writer.create()) {\n      return N.id !== void 0 && N.id !== \"\" && D.uint32(10).string(N.id), N.ip !== void 0 && N.ip !== \"\" && D.uint32(18).string(N.ip), N.numCpus !== void 0 && N.numCpus !== 0 && D.uint32(24).uint32(N.numCpus), N.stats !== void 0 && a.NodeStats.encode(N.stats, D.uint32(34).fork()).ldelim(), N.type !== void 0 && N.type !== 0 && D.uint32(40).int32(N.type), N.state !== void 0 && N.state !== 0 && D.uint32(48).int32(N.state), N.region !== void 0 && N.region !== \"\" && D.uint32(58).string(N.region), D;\n    },\n    decode(N, D) {\n      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);\n      let ee = D === void 0 ? W.len : W.pos + D;\n      const ae = V();\n      for (; W.pos < ee; ) {\n        const ye = W.uint32();\n        switch (ye >>> 3) {\n          case 1:\n            ae.id = W.string();\n            break;\n          case 2:\n            ae.ip = W.string();\n            break;\n          case 3:\n            ae.numCpus = W.uint32();\n            break;\n          case 4:\n            ae.stats = a.NodeStats.decode(W, W.uint32());\n            break;\n          case 5:\n            ae.type = W.int32();\n            break;\n          case 6:\n            ae.state = W.int32();\n            break;\n          case 7:\n            ae.region = W.string();\n            break;\n          default:\n            W.skipType(ye & 7);\n            break;\n        }\n      }\n      return ae;\n    },\n    fromJSON(N) {\n      return {\n        id: A(N.id) ? String(N.id) : \"\",\n        ip: A(N.ip) ? String(N.ip) : \"\",\n        numCpus: A(N.numCpus) ? Number(N.numCpus) : 0,\n        stats: A(N.stats) ? a.NodeStats.fromJSON(N.stats) : void 0,\n        type: A(N.type) ? k(N.type) : 0,\n        state: A(N.state) ? $(N.state) : 0,\n        region: A(N.region) ? String(N.region) : \"\"\n      };\n    },\n    toJSON(N) {\n      const D = {};\n      return N.id !== void 0 && (D.id = N.id), N.ip !== void 0 && (D.ip = N.ip), N.numCpus !== void 0 && (D.numCpus = Math.round(N.numCpus)), N.stats !== void 0 && (D.stats = N.stats ? a.NodeStats.toJSON(N.stats) : void 0), N.type !== void 0 && (D.type = L(N.type)), N.state !== void 0 && (D.state = J(N.state)), N.region !== void 0 && (D.region = N.region), D;\n    },\n    fromPartial(N) {\n      var D, W, ee, ae, ye, he;\n      const le = V();\n      return le.id = (D = N.id) !== null && D !== void 0 ? D : \"\", le.ip = (W = N.ip) !== null && W !== void 0 ? W : \"\", le.numCpus = (ee = N.numCpus) !== null && ee !== void 0 ? ee : 0, le.stats = N.stats !== void 0 && N.stats !== null ? a.NodeStats.fromPartial(N.stats) : void 0, le.type = (ae = N.type) !== null && ae !== void 0 ? ae : 0, le.state = (ye = N.state) !== null && ye !== void 0 ? ye : 0, le.region = (he = N.region) !== null && he !== void 0 ? he : \"\", le;\n    }\n  };\n  function q() {\n    return {\n      startedAt: 0,\n      updatedAt: 0,\n      numRooms: 0,\n      numClients: 0,\n      numTracksIn: 0,\n      numTracksOut: 0,\n      bytesIn: 0,\n      bytesOut: 0,\n      packetsIn: 0,\n      packetsOut: 0,\n      nackTotal: 0,\n      bytesInPerSec: 0,\n      bytesOutPerSec: 0,\n      packetsInPerSec: 0,\n      packetsOutPerSec: 0,\n      nackPerSec: 0,\n      numCpus: 0,\n      loadAvgLast1min: 0,\n      loadAvgLast5min: 0,\n      loadAvgLast15min: 0,\n      cpuLoad: 0,\n      memoryLoad: 0,\n      sysPacketsOut: 0,\n      sysPacketsDropped: 0,\n      sysPacketsOutPerSec: 0,\n      sysPacketsDroppedPerSec: 0,\n      sysPacketsDroppedPctPerSec: 0,\n      retransmitBytesOut: 0,\n      retransmitPacketsOut: 0,\n      retransmitBytesOutPerSec: 0,\n      retransmitPacketsOutPerSec: 0,\n      participantJoin: 0,\n      participantJoinPerSec: 0\n    };\n  }\n  a.NodeStats = {\n    encode(N, D = l.default.Writer.create()) {\n      return N.startedAt !== void 0 && N.startedAt !== 0 && D.uint32(8).int64(N.startedAt), N.updatedAt !== void 0 && N.updatedAt !== 0 && D.uint32(16).int64(N.updatedAt), N.numRooms !== void 0 && N.numRooms !== 0 && D.uint32(24).int32(N.numRooms), N.numClients !== void 0 && N.numClients !== 0 && D.uint32(32).int32(N.numClients), N.numTracksIn !== void 0 && N.numTracksIn !== 0 && D.uint32(40).int32(N.numTracksIn), N.numTracksOut !== void 0 && N.numTracksOut !== 0 && D.uint32(48).int32(N.numTracksOut), N.bytesIn !== void 0 && N.bytesIn !== 0 && D.uint32(56).uint64(N.bytesIn), N.bytesOut !== void 0 && N.bytesOut !== 0 && D.uint32(64).uint64(N.bytesOut), N.packetsIn !== void 0 && N.packetsIn !== 0 && D.uint32(72).uint64(N.packetsIn), N.packetsOut !== void 0 && N.packetsOut !== 0 && D.uint32(80).uint64(N.packetsOut), N.nackTotal !== void 0 && N.nackTotal !== 0 && D.uint32(88).uint64(N.nackTotal), N.bytesInPerSec !== void 0 && N.bytesInPerSec !== 0 && D.uint32(101).float(N.bytesInPerSec), N.bytesOutPerSec !== void 0 && N.bytesOutPerSec !== 0 && D.uint32(109).float(N.bytesOutPerSec), N.packetsInPerSec !== void 0 && N.packetsInPerSec !== 0 && D.uint32(117).float(N.packetsInPerSec), N.packetsOutPerSec !== void 0 && N.packetsOutPerSec !== 0 && D.uint32(125).float(N.packetsOutPerSec), N.nackPerSec !== void 0 && N.nackPerSec !== 0 && D.uint32(133).float(N.nackPerSec), N.numCpus !== void 0 && N.numCpus !== 0 && D.uint32(136).uint32(N.numCpus), N.loadAvgLast1min !== void 0 && N.loadAvgLast1min !== 0 && D.uint32(149).float(N.loadAvgLast1min), N.loadAvgLast5min !== void 0 && N.loadAvgLast5min !== 0 && D.uint32(157).float(N.loadAvgLast5min), N.loadAvgLast15min !== void 0 && N.loadAvgLast15min !== 0 && D.uint32(165).float(N.loadAvgLast15min), N.cpuLoad !== void 0 && N.cpuLoad !== 0 && D.uint32(173).float(N.cpuLoad), N.memoryLoad !== void 0 && N.memoryLoad !== 0 && D.uint32(269).float(N.memoryLoad), N.sysPacketsOut !== void 0 && N.sysPacketsOut !== 0 && D.uint32(224).uint32(N.sysPacketsOut), N.sysPacketsDropped !== void 0 && N.sysPacketsDropped !== 0 && D.uint32(232).uint32(N.sysPacketsDropped), N.sysPacketsOutPerSec !== void 0 && N.sysPacketsOutPerSec !== 0 && D.uint32(245).float(N.sysPacketsOutPerSec), N.sysPacketsDroppedPerSec !== void 0 && N.sysPacketsDroppedPerSec !== 0 && D.uint32(253).float(N.sysPacketsDroppedPerSec), N.sysPacketsDroppedPctPerSec !== void 0 && N.sysPacketsDroppedPctPerSec !== 0 && D.uint32(261).float(N.sysPacketsDroppedPctPerSec), N.retransmitBytesOut !== void 0 && N.retransmitBytesOut !== 0 && D.uint32(176).uint64(N.retransmitBytesOut), N.retransmitPacketsOut !== void 0 && N.retransmitPacketsOut !== 0 && D.uint32(184).uint64(N.retransmitPacketsOut), N.retransmitBytesOutPerSec !== void 0 && N.retransmitBytesOutPerSec !== 0 && D.uint32(197).float(N.retransmitBytesOutPerSec), N.retransmitPacketsOutPerSec !== void 0 && N.retransmitPacketsOutPerSec !== 0 && D.uint32(205).float(N.retransmitPacketsOutPerSec), N.participantJoin !== void 0 && N.participantJoin !== 0 && D.uint32(208).uint64(N.participantJoin), N.participantJoinPerSec !== void 0 && N.participantJoinPerSec !== 0 && D.uint32(221).float(N.participantJoinPerSec), D;\n    },\n    decode(N, D) {\n      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);\n      let ee = D === void 0 ? W.len : W.pos + D;\n      const ae = q();\n      for (; W.pos < ee; ) {\n        const ye = W.uint32();\n        switch (ye >>> 3) {\n          case 1:\n            ae.startedAt = de(W.int64());\n            break;\n          case 2:\n            ae.updatedAt = de(W.int64());\n            break;\n          case 3:\n            ae.numRooms = W.int32();\n            break;\n          case 4:\n            ae.numClients = W.int32();\n            break;\n          case 5:\n            ae.numTracksIn = W.int32();\n            break;\n          case 6:\n            ae.numTracksOut = W.int32();\n            break;\n          case 7:\n            ae.bytesIn = de(W.uint64());\n            break;\n          case 8:\n            ae.bytesOut = de(W.uint64());\n            break;\n          case 9:\n            ae.packetsIn = de(W.uint64());\n            break;\n          case 10:\n            ae.packetsOut = de(W.uint64());\n            break;\n          case 11:\n            ae.nackTotal = de(W.uint64());\n            break;\n          case 12:\n            ae.bytesInPerSec = W.float();\n            break;\n          case 13:\n            ae.bytesOutPerSec = W.float();\n            break;\n          case 14:\n            ae.packetsInPerSec = W.float();\n            break;\n          case 15:\n            ae.packetsOutPerSec = W.float();\n            break;\n          case 16:\n            ae.nackPerSec = W.float();\n            break;\n          case 17:\n            ae.numCpus = W.uint32();\n            break;\n          case 18:\n            ae.loadAvgLast1min = W.float();\n            break;\n          case 19:\n            ae.loadAvgLast5min = W.float();\n            break;\n          case 20:\n            ae.loadAvgLast15min = W.float();\n            break;\n          case 21:\n            ae.cpuLoad = W.float();\n            break;\n          case 33:\n            ae.memoryLoad = W.float();\n            break;\n          case 28:\n            ae.sysPacketsOut = W.uint32();\n            break;\n          case 29:\n            ae.sysPacketsDropped = W.uint32();\n            break;\n          case 30:\n            ae.sysPacketsOutPerSec = W.float();\n            break;\n          case 31:\n            ae.sysPacketsDroppedPerSec = W.float();\n            break;\n          case 32:\n            ae.sysPacketsDroppedPctPerSec = W.float();\n            break;\n          case 22:\n            ae.retransmitBytesOut = de(W.uint64());\n            break;\n          case 23:\n            ae.retransmitPacketsOut = de(W.uint64());\n            break;\n          case 24:\n            ae.retransmitBytesOutPerSec = W.float();\n            break;\n          case 25:\n            ae.retransmitPacketsOutPerSec = W.float();\n            break;\n          case 26:\n            ae.participantJoin = de(W.uint64());\n            break;\n          case 27:\n            ae.participantJoinPerSec = W.float();\n            break;\n          default:\n            W.skipType(ye & 7);\n            break;\n        }\n      }\n      return ae;\n    },\n    fromJSON(N) {\n      return {\n        startedAt: A(N.startedAt) ? Number(N.startedAt) : 0,\n        updatedAt: A(N.updatedAt) ? Number(N.updatedAt) : 0,\n        numRooms: A(N.numRooms) ? Number(N.numRooms) : 0,\n        numClients: A(N.numClients) ? Number(N.numClients) : 0,\n        numTracksIn: A(N.numTracksIn) ? Number(N.numTracksIn) : 0,\n        numTracksOut: A(N.numTracksOut) ? Number(N.numTracksOut) : 0,\n        bytesIn: A(N.bytesIn) ? Number(N.bytesIn) : 0,\n        bytesOut: A(N.bytesOut) ? Number(N.bytesOut) : 0,\n        packetsIn: A(N.packetsIn) ? Number(N.packetsIn) : 0,\n        packetsOut: A(N.packetsOut) ? Number(N.packetsOut) : 0,\n        nackTotal: A(N.nackTotal) ? Number(N.nackTotal) : 0,\n        bytesInPerSec: A(N.bytesInPerSec) ? Number(N.bytesInPerSec) : 0,\n        bytesOutPerSec: A(N.bytesOutPerSec) ? Number(N.bytesOutPerSec) : 0,\n        packetsInPerSec: A(N.packetsInPerSec) ? Number(N.packetsInPerSec) : 0,\n        packetsOutPerSec: A(N.packetsOutPerSec) ? Number(N.packetsOutPerSec) : 0,\n        nackPerSec: A(N.nackPerSec) ? Number(N.nackPerSec) : 0,\n        numCpus: A(N.numCpus) ? Number(N.numCpus) : 0,\n        loadAvgLast1min: A(N.loadAvgLast1min) ? Number(N.loadAvgLast1min) : 0,\n        loadAvgLast5min: A(N.loadAvgLast5min) ? Number(N.loadAvgLast5min) : 0,\n        loadAvgLast15min: A(N.loadAvgLast15min) ? Number(N.loadAvgLast15min) : 0,\n        cpuLoad: A(N.cpuLoad) ? Number(N.cpuLoad) : 0,\n        memoryLoad: A(N.memoryLoad) ? Number(N.memoryLoad) : 0,\n        sysPacketsOut: A(N.sysPacketsOut) ? Number(N.sysPacketsOut) : 0,\n        sysPacketsDropped: A(N.sysPacketsDropped) ? Number(N.sysPacketsDropped) : 0,\n        sysPacketsOutPerSec: A(N.sysPacketsOutPerSec) ? Number(N.sysPacketsOutPerSec) : 0,\n        sysPacketsDroppedPerSec: A(N.sysPacketsDroppedPerSec) ? Number(N.sysPacketsDroppedPerSec) : 0,\n        sysPacketsDroppedPctPerSec: A(N.sysPacketsDroppedPctPerSec) ? Number(N.sysPacketsDroppedPctPerSec) : 0,\n        retransmitBytesOut: A(N.retransmitBytesOut) ? Number(N.retransmitBytesOut) : 0,\n        retransmitPacketsOut: A(N.retransmitPacketsOut) ? Number(N.retransmitPacketsOut) : 0,\n        retransmitBytesOutPerSec: A(N.retransmitBytesOutPerSec) ? Number(N.retransmitBytesOutPerSec) : 0,\n        retransmitPacketsOutPerSec: A(N.retransmitPacketsOutPerSec) ? Number(N.retransmitPacketsOutPerSec) : 0,\n        participantJoin: A(N.participantJoin) ? Number(N.participantJoin) : 0,\n        participantJoinPerSec: A(N.participantJoinPerSec) ? Number(N.participantJoinPerSec) : 0\n      };\n    },\n    toJSON(N) {\n      const D = {};\n      return N.startedAt !== void 0 && (D.startedAt = Math.round(N.startedAt)), N.updatedAt !== void 0 && (D.updatedAt = Math.round(N.updatedAt)), N.numRooms !== void 0 && (D.numRooms = Math.round(N.numRooms)), N.numClients !== void 0 && (D.numClients = Math.round(N.numClients)), N.numTracksIn !== void 0 && (D.numTracksIn = Math.round(N.numTracksIn)), N.numTracksOut !== void 0 && (D.numTracksOut = Math.round(N.numTracksOut)), N.bytesIn !== void 0 && (D.bytesIn = Math.round(N.bytesIn)), N.bytesOut !== void 0 && (D.bytesOut = Math.round(N.bytesOut)), N.packetsIn !== void 0 && (D.packetsIn = Math.round(N.packetsIn)), N.packetsOut !== void 0 && (D.packetsOut = Math.round(N.packetsOut)), N.nackTotal !== void 0 && (D.nackTotal = Math.round(N.nackTotal)), N.bytesInPerSec !== void 0 && (D.bytesInPerSec = N.bytesInPerSec), N.bytesOutPerSec !== void 0 && (D.bytesOutPerSec = N.bytesOutPerSec), N.packetsInPerSec !== void 0 && (D.packetsInPerSec = N.packetsInPerSec), N.packetsOutPerSec !== void 0 && (D.packetsOutPerSec = N.packetsOutPerSec), N.nackPerSec !== void 0 && (D.nackPerSec = N.nackPerSec), N.numCpus !== void 0 && (D.numCpus = Math.round(N.numCpus)), N.loadAvgLast1min !== void 0 && (D.loadAvgLast1min = N.loadAvgLast1min), N.loadAvgLast5min !== void 0 && (D.loadAvgLast5min = N.loadAvgLast5min), N.loadAvgLast15min !== void 0 && (D.loadAvgLast15min = N.loadAvgLast15min), N.cpuLoad !== void 0 && (D.cpuLoad = N.cpuLoad), N.memoryLoad !== void 0 && (D.memoryLoad = N.memoryLoad), N.sysPacketsOut !== void 0 && (D.sysPacketsOut = Math.round(N.sysPacketsOut)), N.sysPacketsDropped !== void 0 && (D.sysPacketsDropped = Math.round(N.sysPacketsDropped)), N.sysPacketsOutPerSec !== void 0 && (D.sysPacketsOutPerSec = N.sysPacketsOutPerSec), N.sysPacketsDroppedPerSec !== void 0 && (D.sysPacketsDroppedPerSec = N.sysPacketsDroppedPerSec), N.sysPacketsDroppedPctPerSec !== void 0 && (D.sysPacketsDroppedPctPerSec = N.sysPacketsDroppedPctPerSec), N.retransmitBytesOut !== void 0 && (D.retransmitBytesOut = Math.round(N.retransmitBytesOut)), N.retransmitPacketsOut !== void 0 && (D.retransmitPacketsOut = Math.round(N.retransmitPacketsOut)), N.retransmitBytesOutPerSec !== void 0 && (D.retransmitBytesOutPerSec = N.retransmitBytesOutPerSec), N.retransmitPacketsOutPerSec !== void 0 && (D.retransmitPacketsOutPerSec = N.retransmitPacketsOutPerSec), N.participantJoin !== void 0 && (D.participantJoin = Math.round(N.participantJoin)), N.participantJoinPerSec !== void 0 && (D.participantJoinPerSec = N.participantJoinPerSec), D;\n    },\n    fromPartial(N) {\n      var D, W, ee, ae, ye, he, le, we, Be, Ne, Le, $e, Ue, Ge, He, Ve, be, Ae, qe, xe, Pe, C, x, Q, Se, me, Ie, at, Ye, je, tt, Oe, P;\n      const X = q();\n      return X.startedAt = (D = N.startedAt) !== null && D !== void 0 ? D : 0, X.updatedAt = (W = N.updatedAt) !== null && W !== void 0 ? W : 0, X.numRooms = (ee = N.numRooms) !== null && ee !== void 0 ? ee : 0, X.numClients = (ae = N.numClients) !== null && ae !== void 0 ? ae : 0, X.numTracksIn = (ye = N.numTracksIn) !== null && ye !== void 0 ? ye : 0, X.numTracksOut = (he = N.numTracksOut) !== null && he !== void 0 ? he : 0, X.bytesIn = (le = N.bytesIn) !== null && le !== void 0 ? le : 0, X.bytesOut = (we = N.bytesOut) !== null && we !== void 0 ? we : 0, X.packetsIn = (Be = N.packetsIn) !== null && Be !== void 0 ? Be : 0, X.packetsOut = (Ne = N.packetsOut) !== null && Ne !== void 0 ? Ne : 0, X.nackTotal = (Le = N.nackTotal) !== null && Le !== void 0 ? Le : 0, X.bytesInPerSec = ($e = N.bytesInPerSec) !== null && $e !== void 0 ? $e : 0, X.bytesOutPerSec = (Ue = N.bytesOutPerSec) !== null && Ue !== void 0 ? Ue : 0, X.packetsInPerSec = (Ge = N.packetsInPerSec) !== null && Ge !== void 0 ? Ge : 0, X.packetsOutPerSec = (He = N.packetsOutPerSec) !== null && He !== void 0 ? He : 0, X.nackPerSec = (Ve = N.nackPerSec) !== null && Ve !== void 0 ? Ve : 0, X.numCpus = (be = N.numCpus) !== null && be !== void 0 ? be : 0, X.loadAvgLast1min = (Ae = N.loadAvgLast1min) !== null && Ae !== void 0 ? Ae : 0, X.loadAvgLast5min = (qe = N.loadAvgLast5min) !== null && qe !== void 0 ? qe : 0, X.loadAvgLast15min = (xe = N.loadAvgLast15min) !== null && xe !== void 0 ? xe : 0, X.cpuLoad = (Pe = N.cpuLoad) !== null && Pe !== void 0 ? Pe : 0, X.memoryLoad = (C = N.memoryLoad) !== null && C !== void 0 ? C : 0, X.sysPacketsOut = (x = N.sysPacketsOut) !== null && x !== void 0 ? x : 0, X.sysPacketsDropped = (Q = N.sysPacketsDropped) !== null && Q !== void 0 ? Q : 0, X.sysPacketsOutPerSec = (Se = N.sysPacketsOutPerSec) !== null && Se !== void 0 ? Se : 0, X.sysPacketsDroppedPerSec = (me = N.sysPacketsDroppedPerSec) !== null && me !== void 0 ? me : 0, X.sysPacketsDroppedPctPerSec = (Ie = N.sysPacketsDroppedPctPerSec) !== null && Ie !== void 0 ? Ie : 0, X.retransmitBytesOut = (at = N.retransmitBytesOut) !== null && at !== void 0 ? at : 0, X.retransmitPacketsOut = (Ye = N.retransmitPacketsOut) !== null && Ye !== void 0 ? Ye : 0, X.retransmitBytesOutPerSec = (je = N.retransmitBytesOutPerSec) !== null && je !== void 0 ? je : 0, X.retransmitPacketsOutPerSec = (tt = N.retransmitPacketsOutPerSec) !== null && tt !== void 0 ? tt : 0, X.participantJoin = (Oe = N.participantJoin) !== null && Oe !== void 0 ? Oe : 0, X.participantJoinPerSec = (P = N.participantJoinPerSec) !== null && P !== void 0 ? P : 0, X;\n    }\n  };\n  function G() {\n    return {\n      participantKey: \"\",\n      senderTime: 0,\n      connectionId: \"\",\n      startSession: void 0,\n      request: void 0,\n      removeParticipant: void 0,\n      muteTrack: void 0,\n      updateParticipant: void 0,\n      deleteRoom: void 0,\n      updateSubscriptions: void 0,\n      sendData: void 0,\n      updateRoomMetadata: void 0,\n      keepAlive: void 0\n    };\n  }\n  a.RTCNodeMessage = {\n    encode(N, D = l.default.Writer.create()) {\n      return N.participantKey !== void 0 && N.participantKey !== \"\" && D.uint32(10).string(N.participantKey), N.senderTime !== void 0 && N.senderTime !== 0 && D.uint32(88).int64(N.senderTime), N.connectionId !== void 0 && N.connectionId !== \"\" && D.uint32(106).string(N.connectionId), N.startSession !== void 0 && a.StartSession.encode(N.startSession, D.uint32(18).fork()).ldelim(), N.request !== void 0 && E.SignalRequest.encode(N.request, D.uint32(26).fork()).ldelim(), N.removeParticipant !== void 0 && g.RoomParticipantIdentity.encode(N.removeParticipant, D.uint32(34).fork()).ldelim(), N.muteTrack !== void 0 && g.MuteRoomTrackRequest.encode(N.muteTrack, D.uint32(42).fork()).ldelim(), N.updateParticipant !== void 0 && g.UpdateParticipantRequest.encode(N.updateParticipant, D.uint32(50).fork()).ldelim(), N.deleteRoom !== void 0 && g.DeleteRoomRequest.encode(N.deleteRoom, D.uint32(58).fork()).ldelim(), N.updateSubscriptions !== void 0 && g.UpdateSubscriptionsRequest.encode(N.updateSubscriptions, D.uint32(66).fork()).ldelim(), N.sendData !== void 0 && g.SendDataRequest.encode(N.sendData, D.uint32(74).fork()).ldelim(), N.updateRoomMetadata !== void 0 && g.UpdateRoomMetadataRequest.encode(N.updateRoomMetadata, D.uint32(82).fork()).ldelim(), N.keepAlive !== void 0 && a.KeepAlive.encode(N.keepAlive, D.uint32(98).fork()).ldelim(), D;\n    },\n    decode(N, D) {\n      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);\n      let ee = D === void 0 ? W.len : W.pos + D;\n      const ae = G();\n      for (; W.pos < ee; ) {\n        const ye = W.uint32();\n        switch (ye >>> 3) {\n          case 1:\n            ae.participantKey = W.string();\n            break;\n          case 11:\n            ae.senderTime = de(W.int64());\n            break;\n          case 13:\n            ae.connectionId = W.string();\n            break;\n          case 2:\n            ae.startSession = a.StartSession.decode(W, W.uint32());\n            break;\n          case 3:\n            ae.request = E.SignalRequest.decode(W, W.uint32());\n            break;\n          case 4:\n            ae.removeParticipant = g.RoomParticipantIdentity.decode(W, W.uint32());\n            break;\n          case 5:\n            ae.muteTrack = g.MuteRoomTrackRequest.decode(W, W.uint32());\n            break;\n          case 6:\n            ae.updateParticipant = g.UpdateParticipantRequest.decode(W, W.uint32());\n            break;\n          case 7:\n            ae.deleteRoom = g.DeleteRoomRequest.decode(W, W.uint32());\n            break;\n          case 8:\n            ae.updateSubscriptions = g.UpdateSubscriptionsRequest.decode(W, W.uint32());\n            break;\n          case 9:\n            ae.sendData = g.SendDataRequest.decode(W, W.uint32());\n            break;\n          case 10:\n            ae.updateRoomMetadata = g.UpdateRoomMetadataRequest.decode(W, W.uint32());\n            break;\n          case 12:\n            ae.keepAlive = a.KeepAlive.decode(W, W.uint32());\n            break;\n          default:\n            W.skipType(ye & 7);\n            break;\n        }\n      }\n      return ae;\n    },\n    fromJSON(N) {\n      return {\n        participantKey: A(N.participantKey) ? String(N.participantKey) : \"\",\n        senderTime: A(N.senderTime) ? Number(N.senderTime) : 0,\n        connectionId: A(N.connectionId) ? String(N.connectionId) : \"\",\n        startSession: A(N.startSession) ? a.StartSession.fromJSON(N.startSession) : void 0,\n        request: A(N.request) ? E.SignalRequest.fromJSON(N.request) : void 0,\n        removeParticipant: A(N.removeParticipant) ? g.RoomParticipantIdentity.fromJSON(N.removeParticipant) : void 0,\n        muteTrack: A(N.muteTrack) ? g.MuteRoomTrackRequest.fromJSON(N.muteTrack) : void 0,\n        updateParticipant: A(N.updateParticipant) ? g.UpdateParticipantRequest.fromJSON(N.updateParticipant) : void 0,\n        deleteRoom: A(N.deleteRoom) ? g.DeleteRoomRequest.fromJSON(N.deleteRoom) : void 0,\n        updateSubscriptions: A(N.updateSubscriptions) ? g.UpdateSubscriptionsRequest.fromJSON(N.updateSubscriptions) : void 0,\n        sendData: A(N.sendData) ? g.SendDataRequest.fromJSON(N.sendData) : void 0,\n        updateRoomMetadata: A(N.updateRoomMetadata) ? g.UpdateRoomMetadataRequest.fromJSON(N.updateRoomMetadata) : void 0,\n        keepAlive: A(N.keepAlive) ? a.KeepAlive.fromJSON(N.keepAlive) : void 0\n      };\n    },\n    toJSON(N) {\n      const D = {};\n      return N.participantKey !== void 0 && (D.participantKey = N.participantKey), N.senderTime !== void 0 && (D.senderTime = Math.round(N.senderTime)), N.connectionId !== void 0 && (D.connectionId = N.connectionId), N.startSession !== void 0 && (D.startSession = N.startSession ? a.StartSession.toJSON(N.startSession) : void 0), N.request !== void 0 && (D.request = N.request ? E.SignalRequest.toJSON(N.request) : void 0), N.removeParticipant !== void 0 && (D.removeParticipant = N.removeParticipant ? g.RoomParticipantIdentity.toJSON(N.removeParticipant) : void 0), N.muteTrack !== void 0 && (D.muteTrack = N.muteTrack ? g.MuteRoomTrackRequest.toJSON(N.muteTrack) : void 0), N.updateParticipant !== void 0 && (D.updateParticipant = N.updateParticipant ? g.UpdateParticipantRequest.toJSON(N.updateParticipant) : void 0), N.deleteRoom !== void 0 && (D.deleteRoom = N.deleteRoom ? g.DeleteRoomRequest.toJSON(N.deleteRoom) : void 0), N.updateSubscriptions !== void 0 && (D.updateSubscriptions = N.updateSubscriptions ? g.UpdateSubscriptionsRequest.toJSON(N.updateSubscriptions) : void 0), N.sendData !== void 0 && (D.sendData = N.sendData ? g.SendDataRequest.toJSON(N.sendData) : void 0), N.updateRoomMetadata !== void 0 && (D.updateRoomMetadata = N.updateRoomMetadata ? g.UpdateRoomMetadataRequest.toJSON(N.updateRoomMetadata) : void 0), N.keepAlive !== void 0 && (D.keepAlive = N.keepAlive ? a.KeepAlive.toJSON(N.keepAlive) : void 0), D;\n    },\n    fromPartial(N) {\n      var D, W, ee;\n      const ae = G();\n      return ae.participantKey = (D = N.participantKey) !== null && D !== void 0 ? D : \"\", ae.senderTime = (W = N.senderTime) !== null && W !== void 0 ? W : 0, ae.connectionId = (ee = N.connectionId) !== null && ee !== void 0 ? ee : \"\", ae.startSession = N.startSession !== void 0 && N.startSession !== null ? a.StartSession.fromPartial(N.startSession) : void 0, ae.request = N.request !== void 0 && N.request !== null ? E.SignalRequest.fromPartial(N.request) : void 0, ae.removeParticipant = N.removeParticipant !== void 0 && N.removeParticipant !== null ? g.RoomParticipantIdentity.fromPartial(N.removeParticipant) : void 0, ae.muteTrack = N.muteTrack !== void 0 && N.muteTrack !== null ? g.MuteRoomTrackRequest.fromPartial(N.muteTrack) : void 0, ae.updateParticipant = N.updateParticipant !== void 0 && N.updateParticipant !== null ? g.UpdateParticipantRequest.fromPartial(N.updateParticipant) : void 0, ae.deleteRoom = N.deleteRoom !== void 0 && N.deleteRoom !== null ? g.DeleteRoomRequest.fromPartial(N.deleteRoom) : void 0, ae.updateSubscriptions = N.updateSubscriptions !== void 0 && N.updateSubscriptions !== null ? g.UpdateSubscriptionsRequest.fromPartial(N.updateSubscriptions) : void 0, ae.sendData = N.sendData !== void 0 && N.sendData !== null ? g.SendDataRequest.fromPartial(N.sendData) : void 0, ae.updateRoomMetadata = N.updateRoomMetadata !== void 0 && N.updateRoomMetadata !== null ? g.UpdateRoomMetadataRequest.fromPartial(N.updateRoomMetadata) : void 0, ae.keepAlive = N.keepAlive !== void 0 && N.keepAlive !== null ? a.KeepAlive.fromPartial(N.keepAlive) : void 0, ae;\n    }\n  };\n  function H() {\n    return { connectionId: \"\", response: void 0, endSession: void 0 };\n  }\n  a.SignalNodeMessage = {\n    encode(N, D = l.default.Writer.create()) {\n      return N.connectionId !== void 0 && N.connectionId !== \"\" && D.uint32(10).string(N.connectionId), N.response !== void 0 && E.SignalResponse.encode(N.response, D.uint32(18).fork()).ldelim(), N.endSession !== void 0 && a.EndSession.encode(N.endSession, D.uint32(26).fork()).ldelim(), D;\n    },\n    decode(N, D) {\n      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);\n      let ee = D === void 0 ? W.len : W.pos + D;\n      const ae = H();\n      for (; W.pos < ee; ) {\n        const ye = W.uint32();\n        switch (ye >>> 3) {\n          case 1:\n            ae.connectionId = W.string();\n            break;\n          case 2:\n            ae.response = E.SignalResponse.decode(W, W.uint32());\n            break;\n          case 3:\n            ae.endSession = a.EndSession.decode(W, W.uint32());\n            break;\n          default:\n            W.skipType(ye & 7);\n            break;\n        }\n      }\n      return ae;\n    },\n    fromJSON(N) {\n      return {\n        connectionId: A(N.connectionId) ? String(N.connectionId) : \"\",\n        response: A(N.response) ? E.SignalResponse.fromJSON(N.response) : void 0,\n        endSession: A(N.endSession) ? a.EndSession.fromJSON(N.endSession) : void 0\n      };\n    },\n    toJSON(N) {\n      const D = {};\n      return N.connectionId !== void 0 && (D.connectionId = N.connectionId), N.response !== void 0 && (D.response = N.response ? E.SignalResponse.toJSON(N.response) : void 0), N.endSession !== void 0 && (D.endSession = N.endSession ? a.EndSession.toJSON(N.endSession) : void 0), D;\n    },\n    fromPartial(N) {\n      var D;\n      const W = H();\n      return W.connectionId = (D = N.connectionId) !== null && D !== void 0 ? D : \"\", W.response = N.response !== void 0 && N.response !== null ? E.SignalResponse.fromPartial(N.response) : void 0, W.endSession = N.endSession !== void 0 && N.endSession !== null ? a.EndSession.fromPartial(N.endSession) : void 0, W;\n    }\n  };\n  function B() {\n    return {\n      roomName: \"\",\n      identity: \"\",\n      connectionId: \"\",\n      reconnect: !1,\n      autoSubscribe: !1,\n      hidden: !1,\n      client: void 0,\n      recorder: !1,\n      name: \"\",\n      grantsJson: \"\",\n      adaptiveStream: !1,\n      participantId: \"\"\n    };\n  }\n  a.StartSession = {\n    encode(N, D = l.default.Writer.create()) {\n      return N.roomName !== void 0 && N.roomName !== \"\" && D.uint32(10).string(N.roomName), N.identity !== void 0 && N.identity !== \"\" && D.uint32(18).string(N.identity), N.connectionId !== void 0 && N.connectionId !== \"\" && D.uint32(26).string(N.connectionId), N.reconnect === !0 && D.uint32(32).bool(N.reconnect), N.autoSubscribe === !0 && D.uint32(72).bool(N.autoSubscribe), N.hidden === !0 && D.uint32(80).bool(N.hidden), N.client !== void 0 && S.ClientInfo.encode(N.client, D.uint32(90).fork()).ldelim(), N.recorder === !0 && D.uint32(96).bool(N.recorder), N.name !== void 0 && N.name !== \"\" && D.uint32(106).string(N.name), N.grantsJson !== void 0 && N.grantsJson !== \"\" && D.uint32(114).string(N.grantsJson), N.adaptiveStream === !0 && D.uint32(120).bool(N.adaptiveStream), N.participantId !== void 0 && N.participantId !== \"\" && D.uint32(130).string(N.participantId), D;\n    },\n    decode(N, D) {\n      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);\n      let ee = D === void 0 ? W.len : W.pos + D;\n      const ae = B();\n      for (; W.pos < ee; ) {\n        const ye = W.uint32();\n        switch (ye >>> 3) {\n          case 1:\n            ae.roomName = W.string();\n            break;\n          case 2:\n            ae.identity = W.string();\n            break;\n          case 3:\n            ae.connectionId = W.string();\n            break;\n          case 4:\n            ae.reconnect = W.bool();\n            break;\n          case 9:\n            ae.autoSubscribe = W.bool();\n            break;\n          case 10:\n            ae.hidden = W.bool();\n            break;\n          case 11:\n            ae.client = S.ClientInfo.decode(W, W.uint32());\n            break;\n          case 12:\n            ae.recorder = W.bool();\n            break;\n          case 13:\n            ae.name = W.string();\n            break;\n          case 14:\n            ae.grantsJson = W.string();\n            break;\n          case 15:\n            ae.adaptiveStream = W.bool();\n            break;\n          case 16:\n            ae.participantId = W.string();\n            break;\n          default:\n            W.skipType(ye & 7);\n            break;\n        }\n      }\n      return ae;\n    },\n    fromJSON(N) {\n      return {\n        roomName: A(N.roomName) ? String(N.roomName) : \"\",\n        identity: A(N.identity) ? String(N.identity) : \"\",\n        connectionId: A(N.connectionId) ? String(N.connectionId) : \"\",\n        reconnect: A(N.reconnect) ? !!N.reconnect : !1,\n        autoSubscribe: A(N.autoSubscribe) ? !!N.autoSubscribe : !1,\n        hidden: A(N.hidden) ? !!N.hidden : !1,\n        client: A(N.client) ? S.ClientInfo.fromJSON(N.client) : void 0,\n        recorder: A(N.recorder) ? !!N.recorder : !1,\n        name: A(N.name) ? String(N.name) : \"\",\n        grantsJson: A(N.grantsJson) ? String(N.grantsJson) : \"\",\n        adaptiveStream: A(N.adaptiveStream) ? !!N.adaptiveStream : !1,\n        participantId: A(N.participantId) ? String(N.participantId) : \"\"\n      };\n    },\n    toJSON(N) {\n      const D = {};\n      return N.roomName !== void 0 && (D.roomName = N.roomName), N.identity !== void 0 && (D.identity = N.identity), N.connectionId !== void 0 && (D.connectionId = N.connectionId), N.reconnect !== void 0 && (D.reconnect = N.reconnect), N.autoSubscribe !== void 0 && (D.autoSubscribe = N.autoSubscribe), N.hidden !== void 0 && (D.hidden = N.hidden), N.client !== void 0 && (D.client = N.client ? S.ClientInfo.toJSON(N.client) : void 0), N.recorder !== void 0 && (D.recorder = N.recorder), N.name !== void 0 && (D.name = N.name), N.grantsJson !== void 0 && (D.grantsJson = N.grantsJson), N.adaptiveStream !== void 0 && (D.adaptiveStream = N.adaptiveStream), N.participantId !== void 0 && (D.participantId = N.participantId), D;\n    },\n    fromPartial(N) {\n      var D, W, ee, ae, ye, he, le, we, Be, Ne, Le;\n      const $e = B();\n      return $e.roomName = (D = N.roomName) !== null && D !== void 0 ? D : \"\", $e.identity = (W = N.identity) !== null && W !== void 0 ? W : \"\", $e.connectionId = (ee = N.connectionId) !== null && ee !== void 0 ? ee : \"\", $e.reconnect = (ae = N.reconnect) !== null && ae !== void 0 ? ae : !1, $e.autoSubscribe = (ye = N.autoSubscribe) !== null && ye !== void 0 ? ye : !1, $e.hidden = (he = N.hidden) !== null && he !== void 0 ? he : !1, $e.client = N.client !== void 0 && N.client !== null ? S.ClientInfo.fromPartial(N.client) : void 0, $e.recorder = (le = N.recorder) !== null && le !== void 0 ? le : !1, $e.name = (we = N.name) !== null && we !== void 0 ? we : \"\", $e.grantsJson = (Be = N.grantsJson) !== null && Be !== void 0 ? Be : \"\", $e.adaptiveStream = (Ne = N.adaptiveStream) !== null && Ne !== void 0 ? Ne : !1, $e.participantId = (Le = N.participantId) !== null && Le !== void 0 ? Le : \"\", $e;\n    }\n  };\n  function Y() {\n    return {};\n  }\n  a.EndSession = {\n    encode(N, D = l.default.Writer.create()) {\n      return D;\n    },\n    decode(N, D) {\n      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);\n      let ee = D === void 0 ? W.len : W.pos + D;\n      const ae = Y();\n      for (; W.pos < ee; ) {\n        const ye = W.uint32();\n        switch (ye >>> 3) {\n          default:\n            W.skipType(ye & 7);\n            break;\n        }\n      }\n      return ae;\n    },\n    fromJSON(N) {\n      return {};\n    },\n    toJSON(N) {\n      return {};\n    },\n    fromPartial(N) {\n      return Y();\n    }\n  };\n  function ne() {\n    return { participantId: \"\" };\n  }\n  a.RemoveParticipant = {\n    encode(N, D = l.default.Writer.create()) {\n      return N.participantId !== void 0 && N.participantId !== \"\" && D.uint32(10).string(N.participantId), D;\n    },\n    decode(N, D) {\n      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);\n      let ee = D === void 0 ? W.len : W.pos + D;\n      const ae = ne();\n      for (; W.pos < ee; ) {\n        const ye = W.uint32();\n        switch (ye >>> 3) {\n          case 1:\n            ae.participantId = W.string();\n            break;\n          default:\n            W.skipType(ye & 7);\n            break;\n        }\n      }\n      return ae;\n    },\n    fromJSON(N) {\n      return { participantId: A(N.participantId) ? String(N.participantId) : \"\" };\n    },\n    toJSON(N) {\n      const D = {};\n      return N.participantId !== void 0 && (D.participantId = N.participantId), D;\n    },\n    fromPartial(N) {\n      var D;\n      const W = ne();\n      return W.participantId = (D = N.participantId) !== null && D !== void 0 ? D : \"\", W;\n    }\n  };\n  function Z() {\n    return {};\n  }\n  a.KeepAlive = {\n    encode(N, D = l.default.Writer.create()) {\n      return D;\n    },\n    decode(N, D) {\n      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);\n      let ee = D === void 0 ? W.len : W.pos + D;\n      const ae = Z();\n      for (; W.pos < ee; ) {\n        const ye = W.uint32();\n        switch (ye >>> 3) {\n          default:\n            W.skipType(ye & 7);\n            break;\n        }\n      }\n      return ae;\n    },\n    fromJSON(N) {\n      return {};\n    },\n    toJSON(N) {\n      return {};\n    },\n    fromPartial(N) {\n      return Z();\n    }\n  };\n  function re() {\n    return { trackEgress: void 0 };\n  }\n  a.RoomInternal = {\n    encode(N, D = l.default.Writer.create()) {\n      return N.trackEgress !== void 0 && v.AutoTrackEgress.encode(N.trackEgress, D.uint32(10).fork()).ldelim(), D;\n    },\n    decode(N, D) {\n      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);\n      let ee = D === void 0 ? W.len : W.pos + D;\n      const ae = re();\n      for (; W.pos < ee; ) {\n        const ye = W.uint32();\n        switch (ye >>> 3) {\n          case 1:\n            ae.trackEgress = v.AutoTrackEgress.decode(W, W.uint32());\n            break;\n          default:\n            W.skipType(ye & 7);\n            break;\n        }\n      }\n      return ae;\n    },\n    fromJSON(N) {\n      return { trackEgress: A(N.trackEgress) ? v.AutoTrackEgress.fromJSON(N.trackEgress) : void 0 };\n    },\n    toJSON(N) {\n      const D = {};\n      return N.trackEgress !== void 0 && (D.trackEgress = N.trackEgress ? v.AutoTrackEgress.toJSON(N.trackEgress) : void 0), D;\n    },\n    fromPartial(N) {\n      const D = re();\n      return D.trackEgress = N.trackEgress !== void 0 && N.trackEgress !== null ? v.AutoTrackEgress.fromPartial(N.trackEgress) : void 0, D;\n    }\n  };\n  var oe = (() => {\n    if (typeof oe < \"u\")\n      return oe;\n    if (typeof self < \"u\")\n      return self;\n    if (typeof window < \"u\")\n      return window;\n    if (typeof commonjsGlobal$1 < \"u\")\n      return commonjsGlobal$1;\n    throw \"Unable to locate global object\";\n  })();\n  function de(N) {\n    if (N.gt(Number.MAX_SAFE_INTEGER))\n      throw new oe.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n    return N.toNumber();\n  }\n  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());\n  function A(N) {\n    return N != null;\n  }\n})(livekit_internal);\n(function(a) {\n  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(_, k, L, M) {\n    M === void 0 && (M = L), Object.defineProperty(_, M, { enumerable: !0, get: function() {\n      return k[L];\n    } });\n  } : function(_, k, L, M) {\n    M === void 0 && (M = L), _[M] = k[L];\n  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(_, k) {\n    Object.defineProperty(_, \"default\", { enumerable: !0, value: k });\n  } : function(_, k) {\n    _.default = k;\n  }), l = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(_, k) {\n    for (var L in _)\n      L !== \"default\" && !Object.prototype.hasOwnProperty.call(k, L) && u(k, _, L);\n  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(_) {\n    if (_ && _.__esModule)\n      return _;\n    var k = {};\n    if (_ != null)\n      for (var L in _)\n        L !== \"default\" && Object.prototype.hasOwnProperty.call(_, L) && u(k, _, L);\n    return c(k, _), k;\n  };\n  Object.defineProperty(a, \"__esModule\", { value: !0 }), a.LivekitInternal = a.TrackType = a.TrackInfo = a.Room = a.ParticipantPermission = a.ParticipantInfo_State = a.ParticipantInfo = a.DataPacket_Kind = a.IngressVideoOptions = a.IngressState = a.IngressInput = a.IngressInfo = a.IngressAudioOptions = a.StreamProtocol = a.StreamOutput = a.SegmentedFileProtocol = a.SegmentedFileOutput = a.EncodingOptionsPreset = a.EncodingOptions = a.EncodedFileType = a.EncodedFileOutput = a.EgressInfo = a.DirectFileOutput = void 0, l(AccessToken$1, a), l(EgressClient$1, a), l(grants, a), l(IngressClient$1, a);\n  var S = livekit_egress;\n  Object.defineProperty(a, \"DirectFileOutput\", { enumerable: !0, get: function() {\n    return S.DirectFileOutput;\n  } }), Object.defineProperty(a, \"EgressInfo\", { enumerable: !0, get: function() {\n    return S.EgressInfo;\n  } }), Object.defineProperty(a, \"EncodedFileOutput\", { enumerable: !0, get: function() {\n    return S.EncodedFileOutput;\n  } }), Object.defineProperty(a, \"EncodedFileType\", { enumerable: !0, get: function() {\n    return S.EncodedFileType;\n  } }), Object.defineProperty(a, \"EncodingOptions\", { enumerable: !0, get: function() {\n    return S.EncodingOptions;\n  } }), Object.defineProperty(a, \"EncodingOptionsPreset\", { enumerable: !0, get: function() {\n    return S.EncodingOptionsPreset;\n  } }), Object.defineProperty(a, \"SegmentedFileOutput\", { enumerable: !0, get: function() {\n    return S.SegmentedFileOutput;\n  } }), Object.defineProperty(a, \"SegmentedFileProtocol\", { enumerable: !0, get: function() {\n    return S.SegmentedFileProtocol;\n  } }), Object.defineProperty(a, \"StreamOutput\", { enumerable: !0, get: function() {\n    return S.StreamOutput;\n  } }), Object.defineProperty(a, \"StreamProtocol\", { enumerable: !0, get: function() {\n    return S.StreamProtocol;\n  } });\n  var g = livekit_ingress;\n  Object.defineProperty(a, \"IngressAudioOptions\", { enumerable: !0, get: function() {\n    return g.IngressAudioOptions;\n  } }), Object.defineProperty(a, \"IngressInfo\", { enumerable: !0, get: function() {\n    return g.IngressInfo;\n  } }), Object.defineProperty(a, \"IngressInput\", { enumerable: !0, get: function() {\n    return g.IngressInput;\n  } }), Object.defineProperty(a, \"IngressState\", { enumerable: !0, get: function() {\n    return g.IngressState;\n  } }), Object.defineProperty(a, \"IngressVideoOptions\", { enumerable: !0, get: function() {\n    return g.IngressVideoOptions;\n  } });\n  var E = livekit_models;\n  Object.defineProperty(a, \"DataPacket_Kind\", { enumerable: !0, get: function() {\n    return E.DataPacket_Kind;\n  } }), Object.defineProperty(a, \"ParticipantInfo\", { enumerable: !0, get: function() {\n    return E.ParticipantInfo;\n  } }), Object.defineProperty(a, \"ParticipantInfo_State\", { enumerable: !0, get: function() {\n    return E.ParticipantInfo_State;\n  } }), Object.defineProperty(a, \"ParticipantPermission\", { enumerable: !0, get: function() {\n    return E.ParticipantPermission;\n  } }), Object.defineProperty(a, \"Room\", { enumerable: !0, get: function() {\n    return E.Room;\n  } }), Object.defineProperty(a, \"TrackInfo\", { enumerable: !0, get: function() {\n    return E.TrackInfo;\n  } }), Object.defineProperty(a, \"TrackType\", { enumerable: !0, get: function() {\n    return E.TrackType;\n  } }), l(RoomServiceClient$1, a), l(WebhookReceiver$1, a), a.LivekitInternal = v(livekit_internal);\n})(dist);\nclass InvalidTokenError extends Error {\n}\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\nfunction b64DecodeUnicode(a) {\n  return decodeURIComponent(atob(a).replace(/(.)/g, (u, c) => {\n    let l = c.charCodeAt(0).toString(16).toUpperCase();\n    return l.length < 2 && (l = \"0\" + l), \"%\" + l;\n  }));\n}\nfunction base64UrlDecode(a) {\n  let u = a.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  switch (u.length % 4) {\n    case 0:\n      break;\n    case 2:\n      u += \"==\";\n      break;\n    case 3:\n      u += \"=\";\n      break;\n    default:\n      throw new Error(\"base64 string is not of the correct length\");\n  }\n  try {\n    return b64DecodeUnicode(u);\n  } catch {\n    return atob(u);\n  }\n}\nfunction jwtDecode(a, u) {\n  if (typeof a != \"string\")\n    throw new InvalidTokenError(\"Invalid token specified: must be a string\");\n  u || (u = {});\n  const c = u.header === !0 ? 0 : 1, l = a.split(\".\")[c];\n  if (typeof l != \"string\")\n    throw new InvalidTokenError(`Invalid token specified: missing part #${c + 1}`);\n  let v;\n  try {\n    v = base64UrlDecode(l);\n  } catch (S) {\n    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${c + 1} (${S.message})`);\n  }\n  try {\n    return JSON.parse(v);\n  } catch (S) {\n    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${c + 1} (${S.message})`);\n  }\n}\nfunction _mergeNamespaces(a, u) {\n  return u.forEach(function(c) {\n    c && typeof c != \"string\" && !Array.isArray(c) && Object.keys(c).forEach(function(l) {\n      if (l !== \"default\" && !(l in a)) {\n        var v = Object.getOwnPropertyDescriptor(c, l);\n        Object.defineProperty(a, l, v.get ? v : {\n          enumerable: !0,\n          get: function() {\n            return c[l];\n          }\n        });\n      }\n    });\n  }), Object.freeze(a);\n}\nvar commonjsGlobal = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction getDefaultExportFromCjs(a) {\n  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, \"default\") ? a.default : a;\n}\nvar loglevel = { exports: {} };\n(function(a) {\n  (function(u, c) {\n    a.exports ? a.exports = c() : u.log = c();\n  })(commonjsGlobal, function() {\n    var u = function() {\n    }, c = \"undefined\", l = typeof window !== c && typeof window.navigator !== c && /Trident\\/|MSIE /.test(window.navigator.userAgent), v = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n    function S(q, G) {\n      var H = q[G];\n      if (typeof H.bind == \"function\")\n        return H.bind(q);\n      try {\n        return Function.prototype.bind.call(H, q);\n      } catch {\n        return function() {\n          return Function.prototype.apply.apply(H, [q, arguments]);\n        };\n      }\n    }\n    function g() {\n      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();\n    }\n    function E(q) {\n      return q === \"debug\" && (q = \"log\"), typeof console === c ? !1 : q === \"trace\" && l ? g : console[q] !== void 0 ? S(console, q) : console.log !== void 0 ? S(console, \"log\") : u;\n    }\n    function _(q, G) {\n      for (var H = 0; H < v.length; H++) {\n        var B = v[H];\n        this[B] = H < q ? u : this.methodFactory(B, q, G);\n      }\n      this.log = this.debug;\n    }\n    function k(q, G, H) {\n      return function() {\n        typeof console !== c && (_.call(this, G, H), this[q].apply(this, arguments));\n      };\n    }\n    function L(q, G, H) {\n      return E(q) || k.apply(this, arguments);\n    }\n    function M(q, G, H) {\n      var B = this, Y;\n      G = G ?? \"WARN\";\n      var ne = \"loglevel\";\n      typeof q == \"string\" ? ne += \":\" + q : typeof q == \"symbol\" && (ne = void 0);\n      function Z(A) {\n        var N = (v[A] || \"silent\").toUpperCase();\n        if (!(typeof window === c || !ne)) {\n          try {\n            window.localStorage[ne] = N;\n            return;\n          } catch {\n          }\n          try {\n            window.document.cookie = encodeURIComponent(ne) + \"=\" + N + \";\";\n          } catch {\n          }\n        }\n      }\n      function re() {\n        var A;\n        if (!(typeof window === c || !ne)) {\n          try {\n            A = window.localStorage[ne];\n          } catch {\n          }\n          if (typeof A === c)\n            try {\n              var N = window.document.cookie, D = N.indexOf(encodeURIComponent(ne) + \"=\");\n              D !== -1 && (A = /^([^;]+)/.exec(N.slice(D))[1]);\n            } catch {\n            }\n          return B.levels[A] === void 0 && (A = void 0), A;\n        }\n      }\n      function oe() {\n        if (!(typeof window === c || !ne)) {\n          try {\n            window.localStorage.removeItem(ne);\n            return;\n          } catch {\n          }\n          try {\n            window.document.cookie = encodeURIComponent(ne) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch {\n          }\n        }\n      }\n      B.name = q, B.levels = {\n        TRACE: 0,\n        DEBUG: 1,\n        INFO: 2,\n        WARN: 3,\n        ERROR: 4,\n        SILENT: 5\n      }, B.methodFactory = H || L, B.getLevel = function() {\n        return Y;\n      }, B.setLevel = function(A, N) {\n        if (typeof A == \"string\" && B.levels[A.toUpperCase()] !== void 0 && (A = B.levels[A.toUpperCase()]), typeof A == \"number\" && A >= 0 && A <= B.levels.SILENT) {\n          if (Y = A, N !== !1 && Z(A), _.call(B, A, q), typeof console === c && A < B.levels.SILENT)\n            return \"No console available for logging\";\n        } else\n          throw \"log.setLevel() called with invalid level: \" + A;\n      }, B.setDefaultLevel = function(A) {\n        G = A, re() || B.setLevel(A, !1);\n      }, B.resetLevel = function() {\n        B.setLevel(G, !1), oe();\n      }, B.enableAll = function(A) {\n        B.setLevel(B.levels.TRACE, A);\n      }, B.disableAll = function(A) {\n        B.setLevel(B.levels.SILENT, A);\n      };\n      var de = re();\n      de == null && (de = G), B.setLevel(de, !1);\n    }\n    var $ = new M(), J = {};\n    $.getLogger = function(G) {\n      if (typeof G != \"symbol\" && typeof G != \"string\" || G === \"\")\n        throw new TypeError(\"You must supply a name when creating a logger.\");\n      var H = J[G];\n      return H || (H = J[G] = new M(G, $.getLevel(), $.methodFactory)), H;\n    };\n    var V = typeof window !== c ? window.log : void 0;\n    return $.noConflict = function() {\n      return typeof window !== c && window.log === $ && (window.log = V), $;\n    }, $.getLoggers = function() {\n      return J;\n    }, $.default = $, $;\n  });\n})(loglevel);\nvar loglevelExports = loglevel.exports, LogLevel;\n(function(a) {\n  a[a.trace = 0] = \"trace\", a[a.debug = 1] = \"debug\", a[a.info = 2] = \"info\", a[a.warn = 3] = \"warn\", a[a.error = 4] = \"error\", a[a.silent = 5] = \"silent\";\n})(LogLevel || (LogLevel = {}));\nvar LoggerNames;\n(function(a) {\n  a.Default = \"livekit\", a.Room = \"livekit-room\", a.Participant = \"livekit-participant\", a.Track = \"livekit-track\", a.Publication = \"livekit-track-publication\", a.Engine = \"livekit-engine\", a.Signal = \"livekit-signal\", a.PCManager = \"livekit-pc-manager\", a.PCTransport = \"livekit-pc-transport\", a.E2EE = \"lk-e2ee\";\n})(LoggerNames || (LoggerNames = {}));\nlet livekitLogger = loglevelExports.getLogger(\"livekit\");\nlivekitLogger.setDefaultLevel(LogLevel.info);\nfunction getLogger(a) {\n  const u = loglevelExports.getLogger(a);\n  return u.setDefaultLevel(livekitLogger.getLevel()), u;\n}\nfunction setLogLevel(a, u) {\n  u && loglevelExports.getLogger(u).setLevel(a);\n  for (const c of Object.entries(loglevelExports.getLoggers()).filter((l) => {\n    let [v] = l;\n    return v.startsWith(\"livekit\");\n  }).map((l) => {\n    let [, v] = l;\n    return v;\n  }))\n    c.setLevel(a);\n}\nloglevelExports.getLogger(\"lk-e2ee\");\nfunction assert(a, u) {\n  if (!a)\n    throw new Error(u);\n}\nconst FLOAT32_MAX = 34028234663852886e22, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 4294967295, INT32_MAX = 2147483647, INT32_MIN = -2147483648;\nfunction assertInt32(a) {\n  if (typeof a != \"number\")\n    throw new Error(\"invalid int 32: \" + typeof a);\n  if (!Number.isInteger(a) || a > INT32_MAX || a < INT32_MIN)\n    throw new Error(\"invalid int 32: \" + a);\n}\nfunction assertUInt32(a) {\n  if (typeof a != \"number\")\n    throw new Error(\"invalid uint 32: \" + typeof a);\n  if (!Number.isInteger(a) || a > UINT32_MAX || a < 0)\n    throw new Error(\"invalid uint 32: \" + a);\n}\nfunction assertFloat32(a) {\n  if (typeof a != \"number\")\n    throw new Error(\"invalid float 32: \" + typeof a);\n  if (Number.isFinite(a) && (a > FLOAT32_MAX || a < FLOAT32_MIN))\n    throw new Error(\"invalid float 32: \" + a);\n}\nconst enumTypeSymbol = Symbol(\"@bufbuild/protobuf/enum-type\");\nfunction getEnumType(a) {\n  const u = a[enumTypeSymbol];\n  return assert(u, \"missing enum type on enum object\"), u;\n}\nfunction setEnumType(a, u, c, l) {\n  a[enumTypeSymbol] = makeEnumType(u, c.map((v) => ({\n    no: v.no,\n    name: v.name,\n    localName: a[v.no]\n  })));\n}\nfunction makeEnumType(a, u, c) {\n  const l = /* @__PURE__ */ Object.create(null), v = /* @__PURE__ */ Object.create(null), S = [];\n  for (const g of u) {\n    const E = normalizeEnumValue(g);\n    S.push(E), l[g.name] = E, v[g.no] = E;\n  }\n  return {\n    typeName: a,\n    values: S,\n    // We do not surface options at this time\n    // options: opt?.options ?? Object.create(null),\n    findName(g) {\n      return l[g];\n    },\n    findNumber(g) {\n      return v[g];\n    }\n  };\n}\nfunction makeEnum(a, u, c) {\n  const l = {};\n  for (const v of u) {\n    const S = normalizeEnumValue(v);\n    l[S.localName] = S.no, l[S.no] = S.localName;\n  }\n  return setEnumType(l, a, u), l;\n}\nfunction normalizeEnumValue(a) {\n  return \"localName\" in a ? a : Object.assign(Object.assign({}, a), {\n    localName: a.name\n  });\n}\nclass Message {\n  /**\n   * Compare with a message of the same type.\n   */\n  equals(u) {\n    return this.getType().runtime.util.equals(this.getType(), this, u);\n  }\n  /**\n   * Create a deep copy.\n   */\n  clone() {\n    return this.getType().runtime.util.clone(this);\n  }\n  /**\n   * Parse from binary data, merging fields.\n   *\n   * Repeated fields are appended. Map entries are added, overwriting\n   * existing keys.\n   *\n   * If a message field is already present, it will be merged with the\n   * new data.\n   */\n  fromBinary(u, c) {\n    const l = this.getType(), v = l.runtime.bin, S = v.makeReadOptions(c);\n    return v.readMessage(this, S.readerFactory(u), u.byteLength, S), this;\n  }\n  /**\n   * Parse a message from a JSON value.\n   */\n  fromJson(u, c) {\n    const l = this.getType(), v = l.runtime.json, S = v.makeReadOptions(c);\n    return v.readMessage(l, u, S, this), this;\n  }\n  /**\n   * Parse a message from a JSON string.\n   */\n  fromJsonString(u, c) {\n    let l;\n    try {\n      l = JSON.parse(u);\n    } catch (v) {\n      throw new Error(\"cannot decode \".concat(this.getType().typeName, \" from JSON: \").concat(v instanceof Error ? v.message : String(v)));\n    }\n    return this.fromJson(l, c);\n  }\n  /**\n   * Serialize the message to binary data.\n   */\n  toBinary(u) {\n    const c = this.getType(), l = c.runtime.bin, v = l.makeWriteOptions(u), S = v.writerFactory();\n    return l.writeMessage(this, S, v), S.finish();\n  }\n  /**\n   * Serialize the message to a JSON value, a JavaScript value that can be\n   * passed to JSON.stringify().\n   */\n  toJson(u) {\n    const c = this.getType(), l = c.runtime.json, v = l.makeWriteOptions(u);\n    return l.writeMessage(this, v);\n  }\n  /**\n   * Serialize the message to a JSON string.\n   */\n  toJsonString(u) {\n    var c;\n    const l = this.toJson(u);\n    return JSON.stringify(l, null, (c = u == null ? void 0 : u.prettySpaces) !== null && c !== void 0 ? c : 0);\n  }\n  /**\n   * Override for serialization behavior. This will be invoked when calling\n   * JSON.stringify on this message (i.e. JSON.stringify(msg)).\n   *\n   * Note that this will not serialize google.protobuf.Any with a packed\n   * message because the protobuf JSON format specifies that it needs to be\n   * unpacked, and this is only possible with a type registry to look up the\n   * message type.  As a result, attempting to serialize a message with this\n   * type will throw an Error.\n   *\n   * This method is protected because you should not need to invoke it\n   * directly -- instead use JSON.stringify or toJsonString for\n   * stringified JSON.  Alternatively, if actual JSON is desired, you should\n   * use toJson.\n   */\n  toJSON() {\n    return this.toJson({\n      emitDefaultValues: !0\n    });\n  }\n  /**\n   * Retrieve the MessageType of this message - a singleton that represents\n   * the protobuf message declaration and provides metadata for reflection-\n   * based operations.\n   */\n  getType() {\n    return Object.getPrototypeOf(this).constructor;\n  }\n}\nfunction makeMessageType(a, u, c, l) {\n  var v;\n  const S = (v = l == null ? void 0 : l.localName) !== null && v !== void 0 ? v : u.substring(u.lastIndexOf(\".\") + 1), g = {\n    [S]: function(E) {\n      a.util.initFields(this), a.util.initPartial(E, this);\n    }\n  }[S];\n  return Object.setPrototypeOf(g.prototype, new Message()), Object.assign(g, {\n    runtime: a,\n    typeName: u,\n    fields: a.util.newFieldList(c),\n    fromBinary(E, _) {\n      return new g().fromBinary(E, _);\n    },\n    fromJson(E, _) {\n      return new g().fromJson(E, _);\n    },\n    fromJsonString(E, _) {\n      return new g().fromJsonString(E, _);\n    },\n    equals(E, _) {\n      return a.util.equals(g, E, _);\n    }\n  }), g;\n}\nfunction makeProtoRuntime(a, u, c, l) {\n  return {\n    syntax: a,\n    json: u,\n    bin: c,\n    util: l,\n    makeMessageType(v, S, g) {\n      return makeMessageType(this, v, S, g);\n    },\n    makeEnum,\n    makeEnumType,\n    getEnumType\n  };\n}\nvar ScalarType;\n(function(a) {\n  a[a.DOUBLE = 1] = \"DOUBLE\", a[a.FLOAT = 2] = \"FLOAT\", a[a.INT64 = 3] = \"INT64\", a[a.UINT64 = 4] = \"UINT64\", a[a.INT32 = 5] = \"INT32\", a[a.FIXED64 = 6] = \"FIXED64\", a[a.FIXED32 = 7] = \"FIXED32\", a[a.BOOL = 8] = \"BOOL\", a[a.STRING = 9] = \"STRING\", a[a.BYTES = 12] = \"BYTES\", a[a.UINT32 = 13] = \"UINT32\", a[a.SFIXED32 = 15] = \"SFIXED32\", a[a.SFIXED64 = 16] = \"SFIXED64\", a[a.SINT32 = 17] = \"SINT32\", a[a.SINT64 = 18] = \"SINT64\";\n})(ScalarType || (ScalarType = {}));\nvar LongType;\n(function(a) {\n  a[a.BIGINT = 0] = \"BIGINT\", a[a.STRING = 1] = \"STRING\";\n})(LongType || (LongType = {}));\nfunction varint64read() {\n  let a = 0, u = 0;\n  for (let l = 0; l < 28; l += 7) {\n    let v = this.buf[this.pos++];\n    if (a |= (v & 127) << l, !(v & 128))\n      return this.assertBounds(), [a, u];\n  }\n  let c = this.buf[this.pos++];\n  if (a |= (c & 15) << 28, u = (c & 112) >> 4, !(c & 128))\n    return this.assertBounds(), [a, u];\n  for (let l = 3; l <= 31; l += 7) {\n    let v = this.buf[this.pos++];\n    if (u |= (v & 127) << l, !(v & 128))\n      return this.assertBounds(), [a, u];\n  }\n  throw new Error(\"invalid varint\");\n}\nfunction varint64write(a, u, c) {\n  for (let S = 0; S < 28; S = S + 7) {\n    const g = a >>> S, E = !(!(g >>> 7) && u == 0), _ = (E ? g | 128 : g) & 255;\n    if (c.push(_), !E)\n      return;\n  }\n  const l = a >>> 28 & 15 | (u & 7) << 4, v = !!(u >> 3);\n  if (c.push((v ? l | 128 : l) & 255), !!v) {\n    for (let S = 3; S < 31; S = S + 7) {\n      const g = u >>> S, E = !!(g >>> 7), _ = (E ? g | 128 : g) & 255;\n      if (c.push(_), !E)\n        return;\n    }\n    c.push(u >>> 31 & 1);\n  }\n}\nconst TWO_PWR_32_DBL = 4294967296;\nfunction int64FromString(a) {\n  const u = a[0] === \"-\";\n  u && (a = a.slice(1));\n  const c = 1e6;\n  let l = 0, v = 0;\n  function S(g, E) {\n    const _ = Number(a.slice(g, E));\n    v *= c, l = l * c + _, l >= TWO_PWR_32_DBL && (v = v + (l / TWO_PWR_32_DBL | 0), l = l % TWO_PWR_32_DBL);\n  }\n  return S(-24, -18), S(-18, -12), S(-12, -6), S(-6), u ? negate(l, v) : newBits(l, v);\n}\nfunction int64ToString(a, u) {\n  let c = newBits(a, u);\n  const l = c.hi & 2147483648;\n  l && (c = negate(c.lo, c.hi));\n  const v = uInt64ToString(c.lo, c.hi);\n  return l ? \"-\" + v : v;\n}\nfunction uInt64ToString(a, u) {\n  if ({\n    lo: a,\n    hi: u\n  } = toUnsigned(a, u), u <= 2097151)\n    return String(TWO_PWR_32_DBL * u + a);\n  const c = a & 16777215, l = (a >>> 24 | u << 8) & 16777215, v = u >> 16 & 65535;\n  let S = c + l * 6777216 + v * 6710656, g = l + v * 8147497, E = v * 2;\n  const _ = 1e7;\n  return S >= _ && (g += Math.floor(S / _), S %= _), g >= _ && (E += Math.floor(g / _), g %= _), E.toString() + decimalFrom1e7WithLeadingZeros(g) + decimalFrom1e7WithLeadingZeros(S);\n}\nfunction toUnsigned(a, u) {\n  return {\n    lo: a >>> 0,\n    hi: u >>> 0\n  };\n}\nfunction newBits(a, u) {\n  return {\n    lo: a | 0,\n    hi: u | 0\n  };\n}\nfunction negate(a, u) {\n  return u = ~u, a ? a = ~a + 1 : u += 1, newBits(a, u);\n}\nconst decimalFrom1e7WithLeadingZeros = (a) => {\n  const u = String(a);\n  return \"0000000\".slice(u.length) + u;\n};\nfunction varint32write(a, u) {\n  if (a >= 0) {\n    for (; a > 127; )\n      u.push(a & 127 | 128), a = a >>> 7;\n    u.push(a);\n  } else {\n    for (let c = 0; c < 9; c++)\n      u.push(a & 127 | 128), a = a >> 7;\n    u.push(1);\n  }\n}\nfunction varint32read() {\n  let a = this.buf[this.pos++], u = a & 127;\n  if (!(a & 128))\n    return this.assertBounds(), u;\n  if (a = this.buf[this.pos++], u |= (a & 127) << 7, !(a & 128))\n    return this.assertBounds(), u;\n  if (a = this.buf[this.pos++], u |= (a & 127) << 14, !(a & 128))\n    return this.assertBounds(), u;\n  if (a = this.buf[this.pos++], u |= (a & 127) << 21, !(a & 128))\n    return this.assertBounds(), u;\n  a = this.buf[this.pos++], u |= (a & 15) << 28;\n  for (let c = 5; a & 128 && c < 10; c++)\n    a = this.buf[this.pos++];\n  if (a & 128)\n    throw new Error(\"invalid varint\");\n  return this.assertBounds(), u >>> 0;\n}\nfunction makeInt64Support() {\n  const a = new DataView(new ArrayBuffer(8));\n  if (typeof BigInt == \"function\" && typeof a.getBigInt64 == \"function\" && typeof a.getBigUint64 == \"function\" && typeof a.setBigInt64 == \"function\" && typeof a.setBigUint64 == \"function\" && (typeof process != \"object\" || typeof process.env != \"object\" || process.env.BUF_BIGINT_DISABLE !== \"1\")) {\n    const v = BigInt(\"-9223372036854775808\"), S = BigInt(\"9223372036854775807\"), g = BigInt(\"0\"), E = BigInt(\"18446744073709551615\");\n    return {\n      zero: BigInt(0),\n      supported: !0,\n      parse(_) {\n        const k = typeof _ == \"bigint\" ? _ : BigInt(_);\n        if (k > S || k < v)\n          throw new Error(\"int64 invalid: \".concat(_));\n        return k;\n      },\n      uParse(_) {\n        const k = typeof _ == \"bigint\" ? _ : BigInt(_);\n        if (k > E || k < g)\n          throw new Error(\"uint64 invalid: \".concat(_));\n        return k;\n      },\n      enc(_) {\n        return a.setBigInt64(0, this.parse(_), !0), {\n          lo: a.getInt32(0, !0),\n          hi: a.getInt32(4, !0)\n        };\n      },\n      uEnc(_) {\n        return a.setBigInt64(0, this.uParse(_), !0), {\n          lo: a.getInt32(0, !0),\n          hi: a.getInt32(4, !0)\n        };\n      },\n      dec(_, k) {\n        return a.setInt32(0, _, !0), a.setInt32(4, k, !0), a.getBigInt64(0, !0);\n      },\n      uDec(_, k) {\n        return a.setInt32(0, _, !0), a.setInt32(4, k, !0), a.getBigUint64(0, !0);\n      }\n    };\n  }\n  const c = (v) => assert(/^-?[0-9]+$/.test(v), \"int64 invalid: \".concat(v)), l = (v) => assert(/^[0-9]+$/.test(v), \"uint64 invalid: \".concat(v));\n  return {\n    zero: \"0\",\n    supported: !1,\n    parse(v) {\n      return typeof v != \"string\" && (v = v.toString()), c(v), v;\n    },\n    uParse(v) {\n      return typeof v != \"string\" && (v = v.toString()), l(v), v;\n    },\n    enc(v) {\n      return typeof v != \"string\" && (v = v.toString()), c(v), int64FromString(v);\n    },\n    uEnc(v) {\n      return typeof v != \"string\" && (v = v.toString()), l(v), int64FromString(v);\n    },\n    dec(v, S) {\n      return int64ToString(v, S);\n    },\n    uDec(v, S) {\n      return uInt64ToString(v, S);\n    }\n  };\n}\nconst protoInt64 = makeInt64Support();\nvar WireType;\n(function(a) {\n  a[a.Varint = 0] = \"Varint\", a[a.Bit64 = 1] = \"Bit64\", a[a.LengthDelimited = 2] = \"LengthDelimited\", a[a.StartGroup = 3] = \"StartGroup\", a[a.EndGroup = 4] = \"EndGroup\", a[a.Bit32 = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\nclass BinaryWriter {\n  constructor(u) {\n    this.stack = [], this.textEncoder = u ?? new TextEncoder(), this.chunks = [], this.buf = [];\n  }\n  /**\n   * Return all bytes written and reset this writer.\n   */\n  finish() {\n    this.chunks.push(new Uint8Array(this.buf));\n    let u = 0;\n    for (let v = 0; v < this.chunks.length; v++)\n      u += this.chunks[v].length;\n    let c = new Uint8Array(u), l = 0;\n    for (let v = 0; v < this.chunks.length; v++)\n      c.set(this.chunks[v], l), l += this.chunks[v].length;\n    return this.chunks = [], c;\n  }\n  /**\n   * Start a new fork for length-delimited data like a message\n   * or a packed repeated field.\n   *\n   * Must be joined later with `join()`.\n   */\n  fork() {\n    return this.stack.push({\n      chunks: this.chunks,\n      buf: this.buf\n    }), this.chunks = [], this.buf = [], this;\n  }\n  /**\n   * Join the last fork. Write its length and bytes, then\n   * return to the previous state.\n   */\n  join() {\n    let u = this.finish(), c = this.stack.pop();\n    if (!c)\n      throw new Error(\"invalid state, fork stack empty\");\n    return this.chunks = c.chunks, this.buf = c.buf, this.uint32(u.byteLength), this.raw(u);\n  }\n  /**\n   * Writes a tag (field number and wire type).\n   *\n   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n   *\n   * Generated code should compute the tag ahead of time and call `uint32()`.\n   */\n  tag(u, c) {\n    return this.uint32((u << 3 | c) >>> 0);\n  }\n  /**\n   * Write a chunk of raw bytes.\n   */\n  raw(u) {\n    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(u), this;\n  }\n  /**\n   * Write a `uint32` value, an unsigned 32 bit varint.\n   */\n  uint32(u) {\n    for (assertUInt32(u); u > 127; )\n      this.buf.push(u & 127 | 128), u = u >>> 7;\n    return this.buf.push(u), this;\n  }\n  /**\n   * Write a `int32` value, a signed 32 bit varint.\n   */\n  int32(u) {\n    return assertInt32(u), varint32write(u, this.buf), this;\n  }\n  /**\n   * Write a `bool` value, a variant.\n   */\n  bool(u) {\n    return this.buf.push(u ? 1 : 0), this;\n  }\n  /**\n   * Write a `bytes` value, length-delimited arbitrary data.\n   */\n  bytes(u) {\n    return this.uint32(u.byteLength), this.raw(u);\n  }\n  /**\n   * Write a `string` value, length-delimited data converted to UTF-8 text.\n   */\n  string(u) {\n    let c = this.textEncoder.encode(u);\n    return this.uint32(c.byteLength), this.raw(c);\n  }\n  /**\n   * Write a `float` value, 32-bit floating point number.\n   */\n  float(u) {\n    assertFloat32(u);\n    let c = new Uint8Array(4);\n    return new DataView(c.buffer).setFloat32(0, u, !0), this.raw(c);\n  }\n  /**\n   * Write a `double` value, a 64-bit floating point number.\n   */\n  double(u) {\n    let c = new Uint8Array(8);\n    return new DataView(c.buffer).setFloat64(0, u, !0), this.raw(c);\n  }\n  /**\n   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n   */\n  fixed32(u) {\n    assertUInt32(u);\n    let c = new Uint8Array(4);\n    return new DataView(c.buffer).setUint32(0, u, !0), this.raw(c);\n  }\n  /**\n   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n   */\n  sfixed32(u) {\n    assertInt32(u);\n    let c = new Uint8Array(4);\n    return new DataView(c.buffer).setInt32(0, u, !0), this.raw(c);\n  }\n  /**\n   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n   */\n  sint32(u) {\n    return assertInt32(u), u = (u << 1 ^ u >> 31) >>> 0, varint32write(u, this.buf), this;\n  }\n  /**\n   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n   */\n  sfixed64(u) {\n    let c = new Uint8Array(8), l = new DataView(c.buffer), v = protoInt64.enc(u);\n    return l.setInt32(0, v.lo, !0), l.setInt32(4, v.hi, !0), this.raw(c);\n  }\n  /**\n   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n   */\n  fixed64(u) {\n    let c = new Uint8Array(8), l = new DataView(c.buffer), v = protoInt64.uEnc(u);\n    return l.setInt32(0, v.lo, !0), l.setInt32(4, v.hi, !0), this.raw(c);\n  }\n  /**\n   * Write a `int64` value, a signed 64-bit varint.\n   */\n  int64(u) {\n    let c = protoInt64.enc(u);\n    return varint64write(c.lo, c.hi, this.buf), this;\n  }\n  /**\n   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n   */\n  sint64(u) {\n    let c = protoInt64.enc(u), l = c.hi >> 31, v = c.lo << 1 ^ l, S = (c.hi << 1 | c.lo >>> 31) ^ l;\n    return varint64write(v, S, this.buf), this;\n  }\n  /**\n   * Write a `uint64` value, an unsigned 64-bit varint.\n   */\n  uint64(u) {\n    let c = protoInt64.uEnc(u);\n    return varint64write(c.lo, c.hi, this.buf), this;\n  }\n}\nclass BinaryReader {\n  constructor(u, c) {\n    this.varint64 = varint64read, this.uint32 = varint32read, this.buf = u, this.len = u.length, this.pos = 0, this.view = new DataView(u.buffer, u.byteOffset, u.byteLength), this.textDecoder = c ?? new TextDecoder();\n  }\n  /**\n   * Reads a tag - field number and wire type.\n   */\n  tag() {\n    let u = this.uint32(), c = u >>> 3, l = u & 7;\n    if (c <= 0 || l < 0 || l > 5)\n      throw new Error(\"illegal tag: field no \" + c + \" wire type \" + l);\n    return [c, l];\n  }\n  /**\n   * Skip one element on the wire and return the skipped data.\n   * Supports WireType.StartGroup since v2.0.0-alpha.23.\n   */\n  skip(u) {\n    let c = this.pos;\n    switch (u) {\n      case WireType.Varint:\n        for (; this.buf[this.pos++] & 128; )\n          ;\n        break;\n      case WireType.Bit64:\n        this.pos += 4;\n      case WireType.Bit32:\n        this.pos += 4;\n        break;\n      case WireType.LengthDelimited:\n        let l = this.uint32();\n        this.pos += l;\n        break;\n      case WireType.StartGroup:\n        let v;\n        for (; (v = this.tag()[1]) !== WireType.EndGroup; )\n          this.skip(v);\n        break;\n      default:\n        throw new Error(\"cant skip wire type \" + u);\n    }\n    return this.assertBounds(), this.buf.subarray(c, this.pos);\n  }\n  /**\n   * Throws error if position in byte array is out of range.\n   */\n  assertBounds() {\n    if (this.pos > this.len)\n      throw new RangeError(\"premature EOF\");\n  }\n  /**\n   * Read a `int32` field, a signed 32 bit varint.\n   */\n  int32() {\n    return this.uint32() | 0;\n  }\n  /**\n   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n   */\n  sint32() {\n    let u = this.uint32();\n    return u >>> 1 ^ -(u & 1);\n  }\n  /**\n   * Read a `int64` field, a signed 64-bit varint.\n   */\n  int64() {\n    return protoInt64.dec(...this.varint64());\n  }\n  /**\n   * Read a `uint64` field, an unsigned 64-bit varint.\n   */\n  uint64() {\n    return protoInt64.uDec(...this.varint64());\n  }\n  /**\n   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n   */\n  sint64() {\n    let [u, c] = this.varint64(), l = -(u & 1);\n    return u = (u >>> 1 | (c & 1) << 31) ^ l, c = c >>> 1 ^ l, protoInt64.dec(u, c);\n  }\n  /**\n   * Read a `bool` field, a variant.\n   */\n  bool() {\n    let [u, c] = this.varint64();\n    return u !== 0 || c !== 0;\n  }\n  /**\n   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n   */\n  fixed32() {\n    return this.view.getUint32((this.pos += 4) - 4, !0);\n  }\n  /**\n   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n   */\n  sfixed32() {\n    return this.view.getInt32((this.pos += 4) - 4, !0);\n  }\n  /**\n   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n   */\n  fixed64() {\n    return protoInt64.uDec(this.sfixed32(), this.sfixed32());\n  }\n  /**\n   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n   */\n  sfixed64() {\n    return protoInt64.dec(this.sfixed32(), this.sfixed32());\n  }\n  /**\n   * Read a `float` field, 32-bit floating point number.\n   */\n  float() {\n    return this.view.getFloat32((this.pos += 4) - 4, !0);\n  }\n  /**\n   * Read a `double` field, a 64-bit floating point number.\n   */\n  double() {\n    return this.view.getFloat64((this.pos += 8) - 8, !0);\n  }\n  /**\n   * Read a `bytes` field, length-delimited arbitrary data.\n   */\n  bytes() {\n    let u = this.uint32(), c = this.pos;\n    return this.pos += u, this.assertBounds(), this.buf.subarray(c, c + u);\n  }\n  /**\n   * Read a `string` field, length-delimited data converted to UTF-8 text.\n   */\n  string() {\n    return this.textDecoder.decode(this.bytes());\n  }\n}\nfunction wrapField(a, u) {\n  return u instanceof Message || !a.fieldWrapper ? u : a.fieldWrapper.wrapField(u);\n}\nScalarType.DOUBLE, ScalarType.FLOAT, ScalarType.INT64, ScalarType.UINT64, ScalarType.INT32, ScalarType.UINT32, ScalarType.BOOL, ScalarType.STRING, ScalarType.BYTES;\nfunction scalarEquals(a, u, c) {\n  if (u === c)\n    return !0;\n  if (a == ScalarType.BYTES) {\n    if (!(u instanceof Uint8Array) || !(c instanceof Uint8Array) || u.length !== c.length)\n      return !1;\n    for (let l = 0; l < u.length; l++)\n      if (u[l] !== c[l])\n        return !1;\n    return !0;\n  }\n  switch (a) {\n    case ScalarType.UINT64:\n    case ScalarType.FIXED64:\n    case ScalarType.INT64:\n    case ScalarType.SFIXED64:\n    case ScalarType.SINT64:\n      return u == c;\n  }\n  return !1;\n}\nfunction scalarDefaultValue(a, u) {\n  switch (a) {\n    case ScalarType.BOOL:\n      return !1;\n    case ScalarType.UINT64:\n    case ScalarType.FIXED64:\n    case ScalarType.INT64:\n    case ScalarType.SFIXED64:\n    case ScalarType.SINT64:\n      return u == 0 ? protoInt64.zero : \"0\";\n    case ScalarType.DOUBLE:\n    case ScalarType.FLOAT:\n      return 0;\n    case ScalarType.BYTES:\n      return new Uint8Array(0);\n    case ScalarType.STRING:\n      return \"\";\n    default:\n      return 0;\n  }\n}\nfunction scalarTypeInfo(a, u) {\n  const c = u === void 0;\n  let l = WireType.Varint, v = u === 0;\n  switch (a) {\n    case ScalarType.STRING:\n      v = c || !u.length, l = WireType.LengthDelimited;\n      break;\n    case ScalarType.BOOL:\n      v = u === !1;\n      break;\n    case ScalarType.DOUBLE:\n      l = WireType.Bit64;\n      break;\n    case ScalarType.FLOAT:\n      l = WireType.Bit32;\n      break;\n    case ScalarType.INT64:\n      v = c || u == 0;\n      break;\n    case ScalarType.UINT64:\n      v = c || u == 0;\n      break;\n    case ScalarType.FIXED64:\n      v = c || u == 0, l = WireType.Bit64;\n      break;\n    case ScalarType.BYTES:\n      v = c || !u.byteLength, l = WireType.LengthDelimited;\n      break;\n    case ScalarType.FIXED32:\n      l = WireType.Bit32;\n      break;\n    case ScalarType.SFIXED32:\n      l = WireType.Bit32;\n      break;\n    case ScalarType.SFIXED64:\n      v = c || u == 0, l = WireType.Bit64;\n      break;\n    case ScalarType.SINT64:\n      v = c || u == 0;\n      break;\n  }\n  const S = ScalarType[a].toLowerCase();\n  return [l, S, c || v];\n}\nconst unknownFieldsSymbol = Symbol(\"@bufbuild/protobuf/unknown-fields\"), readDefaults = {\n  readUnknownFields: !0,\n  readerFactory: (a) => new BinaryReader(a)\n}, writeDefaults = {\n  writeUnknownFields: !0,\n  writerFactory: () => new BinaryWriter()\n};\nfunction makeReadOptions$1(a) {\n  return a ? Object.assign(Object.assign({}, readDefaults), a) : readDefaults;\n}\nfunction makeWriteOptions$1(a) {\n  return a ? Object.assign(Object.assign({}, writeDefaults), a) : writeDefaults;\n}\nfunction makeBinaryFormatCommon() {\n  return {\n    makeReadOptions: makeReadOptions$1,\n    makeWriteOptions: makeWriteOptions$1,\n    listUnknownFields(a) {\n      var u;\n      return (u = a[unknownFieldsSymbol]) !== null && u !== void 0 ? u : [];\n    },\n    discardUnknownFields(a) {\n      delete a[unknownFieldsSymbol];\n    },\n    writeUnknownFields(a, u) {\n      const l = a[unknownFieldsSymbol];\n      if (l)\n        for (const v of l)\n          u.tag(v.no, v.wireType).raw(v.data);\n    },\n    onUnknownField(a, u, c, l) {\n      const v = a;\n      Array.isArray(v[unknownFieldsSymbol]) || (v[unknownFieldsSymbol] = []), v[unknownFieldsSymbol].push({\n        no: u,\n        wireType: c,\n        data: l\n      });\n    },\n    readMessage(a, u, c, l) {\n      const v = a.getType(), S = c === void 0 ? u.len : u.pos + c;\n      for (; u.pos < S; ) {\n        const [g, E] = u.tag(), _ = v.fields.find(g);\n        if (!_) {\n          const $ = u.skip(E);\n          l.readUnknownFields && this.onUnknownField(a, g, E, $);\n          continue;\n        }\n        let k = a, L = _.repeated, M = _.localName;\n        switch (_.oneof && (k = k[_.oneof.localName], k.case != M && delete k.value, k.case = M, M = \"value\"), _.kind) {\n          case \"scalar\":\n          case \"enum\":\n            const $ = _.kind == \"enum\" ? ScalarType.INT32 : _.T;\n            let J = readScalar$1;\n            if (_.kind == \"scalar\" && _.L > 0 && (J = readScalarLTString), L) {\n              let H = k[M];\n              if (E == WireType.LengthDelimited && $ != ScalarType.STRING && $ != ScalarType.BYTES) {\n                let B = u.uint32() + u.pos;\n                for (; u.pos < B; )\n                  H.push(J(u, $));\n              } else\n                H.push(J(u, $));\n            } else\n              k[M] = J(u, $);\n            break;\n          case \"message\":\n            const V = _.T;\n            L ? k[M].push(readMessageField(u, new V(), l)) : k[M] instanceof Message ? readMessageField(u, k[M], l) : (k[M] = readMessageField(u, new V(), l), V.fieldWrapper && !_.oneof && !_.repeated && (k[M] = V.fieldWrapper.unwrapField(k[M])));\n            break;\n          case \"map\":\n            let [q, G] = readMapEntry(_, u, l);\n            k[M][q] = G;\n            break;\n        }\n      }\n    }\n  };\n}\nfunction readMessageField(a, u, c) {\n  return u.getType().runtime.bin.readMessage(u, a, a.uint32(), c), u;\n}\nfunction readMapEntry(a, u, c) {\n  const l = u.uint32(), v = u.pos + l;\n  let S, g;\n  for (; u.pos < v; ) {\n    let [E] = u.tag();\n    switch (E) {\n      case 1:\n        S = readScalar$1(u, a.K);\n        break;\n      case 2:\n        switch (a.V.kind) {\n          case \"scalar\":\n            g = readScalar$1(u, a.V.T);\n            break;\n          case \"enum\":\n            g = u.int32();\n            break;\n          case \"message\":\n            g = readMessageField(u, new a.V.T(), c);\n            break;\n        }\n        break;\n    }\n  }\n  if (S === void 0) {\n    let E = scalarDefaultValue(a.K, LongType.BIGINT);\n    S = a.K == ScalarType.BOOL ? E.toString() : E;\n  }\n  if (typeof S != \"string\" && typeof S != \"number\" && (S = S.toString()), g === void 0)\n    switch (a.V.kind) {\n      case \"scalar\":\n        g = scalarDefaultValue(a.V.T, LongType.BIGINT);\n        break;\n      case \"enum\":\n        g = 0;\n        break;\n      case \"message\":\n        g = new a.V.T();\n        break;\n    }\n  return [S, g];\n}\nfunction readScalarLTString(a, u) {\n  const c = readScalar$1(a, u);\n  return typeof c == \"bigint\" ? c.toString() : c;\n}\nfunction readScalar$1(a, u) {\n  switch (u) {\n    case ScalarType.STRING:\n      return a.string();\n    case ScalarType.BOOL:\n      return a.bool();\n    case ScalarType.DOUBLE:\n      return a.double();\n    case ScalarType.FLOAT:\n      return a.float();\n    case ScalarType.INT32:\n      return a.int32();\n    case ScalarType.INT64:\n      return a.int64();\n    case ScalarType.UINT64:\n      return a.uint64();\n    case ScalarType.FIXED64:\n      return a.fixed64();\n    case ScalarType.BYTES:\n      return a.bytes();\n    case ScalarType.FIXED32:\n      return a.fixed32();\n    case ScalarType.SFIXED32:\n      return a.sfixed32();\n    case ScalarType.SFIXED64:\n      return a.sfixed64();\n    case ScalarType.SINT64:\n      return a.sint64();\n    case ScalarType.UINT32:\n      return a.uint32();\n    case ScalarType.SINT32:\n      return a.sint32();\n  }\n}\nfunction writeMapEntry(a, u, c, l, v) {\n  a.tag(c.no, WireType.LengthDelimited), a.fork();\n  let S = l;\n  switch (c.K) {\n    case ScalarType.INT32:\n    case ScalarType.FIXED32:\n    case ScalarType.UINT32:\n    case ScalarType.SFIXED32:\n    case ScalarType.SINT32:\n      S = Number.parseInt(l);\n      break;\n    case ScalarType.BOOL:\n      assert(l == \"true\" || l == \"false\"), S = l == \"true\";\n      break;\n  }\n  switch (writeScalar$1(a, c.K, 1, S, !0), c.V.kind) {\n    case \"scalar\":\n      writeScalar$1(a, c.V.T, 2, v, !0);\n      break;\n    case \"enum\":\n      writeScalar$1(a, ScalarType.INT32, 2, v, !0);\n      break;\n    case \"message\":\n      writeMessageField(a, u, c.V.T, 2, v);\n      break;\n  }\n  a.join();\n}\nfunction writeMessageField(a, u, c, l, v) {\n  if (v !== void 0) {\n    const S = wrapField(c, v);\n    a.tag(l, WireType.LengthDelimited).bytes(S.toBinary(u));\n  }\n}\nfunction writeScalar$1(a, u, c, l, v) {\n  let [S, g, E] = scalarTypeInfo(u, l);\n  (!E || v) && a.tag(c, S)[g](l);\n}\nfunction writePacked(a, u, c, l) {\n  if (!l.length)\n    return;\n  a.tag(c, WireType.LengthDelimited).fork();\n  let [, v] = scalarTypeInfo(u);\n  for (let S = 0; S < l.length; S++)\n    a[v](l[S]);\n  a.join();\n}\nfunction makeBinaryFormatProto3() {\n  return Object.assign(Object.assign({}, makeBinaryFormatCommon()), {\n    writeMessage(a, u, c) {\n      const l = a.getType();\n      for (const v of l.fields.byNumber()) {\n        let S, g = v.repeated, E = v.localName;\n        if (v.oneof) {\n          const _ = a[v.oneof.localName];\n          if (_.case !== E)\n            continue;\n          S = _.value;\n        } else\n          S = a[E];\n        switch (v.kind) {\n          case \"scalar\":\n          case \"enum\":\n            let _ = v.kind == \"enum\" ? ScalarType.INT32 : v.T;\n            if (g)\n              if (v.packed)\n                writePacked(u, _, v.no, S);\n              else\n                for (const k of S)\n                  writeScalar$1(u, _, v.no, k, !0);\n            else\n              S !== void 0 && writeScalar$1(u, _, v.no, S, !!v.oneof || v.opt);\n            break;\n          case \"message\":\n            if (g)\n              for (const k of S)\n                writeMessageField(u, c, v.T, v.no, k);\n            else\n              writeMessageField(u, c, v.T, v.no, S);\n            break;\n          case \"map\":\n            for (const [k, L] of Object.entries(S))\n              writeMapEntry(u, c, v, k, L);\n            break;\n        }\n      }\n      return c.writeUnknownFields && this.writeUnknownFields(a, u), u;\n    }\n  });\n}\nlet encTable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\"), decTable = [];\nfor (let a = 0; a < encTable.length; a++)\n  decTable[encTable[a].charCodeAt(0)] = a;\ndecTable[45] = encTable.indexOf(\"+\");\ndecTable[95] = encTable.indexOf(\"/\");\nconst protoBase64 = {\n  /**\n   * Decodes a base64 string to a byte array.\n   *\n   * - ignores white-space, including line breaks and tabs\n   * - allows inner padding (can decode concatenated base64 strings)\n   * - does not require padding\n   * - understands base64url encoding:\n   *   \"-\" instead of \"+\",\n   *   \"_\" instead of \"/\",\n   *   no padding\n   */\n  dec(a) {\n    let u = a.length * 3 / 4;\n    a[a.length - 2] == \"=\" ? u -= 2 : a[a.length - 1] == \"=\" && (u -= 1);\n    let c = new Uint8Array(u), l = 0, v = 0, S, g = 0;\n    for (let E = 0; E < a.length; E++) {\n      if (S = decTable[a.charCodeAt(E)], S === void 0)\n        switch (a[E]) {\n          case \"=\":\n            v = 0;\n          case `\n`:\n          case \"\\r\":\n          case \"\t\":\n          case \" \":\n            continue;\n          default:\n            throw Error(\"invalid base64 string.\");\n        }\n      switch (v) {\n        case 0:\n          g = S, v = 1;\n          break;\n        case 1:\n          c[l++] = g << 2 | (S & 48) >> 4, g = S, v = 2;\n          break;\n        case 2:\n          c[l++] = (g & 15) << 4 | (S & 60) >> 2, g = S, v = 3;\n          break;\n        case 3:\n          c[l++] = (g & 3) << 6 | S, v = 0;\n          break;\n      }\n    }\n    if (v == 1)\n      throw Error(\"invalid base64 string.\");\n    return c.subarray(0, l);\n  },\n  /**\n   * Encode a byte array to a base64 string.\n   */\n  enc(a) {\n    let u = \"\", c = 0, l, v = 0;\n    for (let S = 0; S < a.length; S++)\n      switch (l = a[S], c) {\n        case 0:\n          u += encTable[l >> 2], v = (l & 3) << 4, c = 1;\n          break;\n        case 1:\n          u += encTable[v | l >> 4], v = (l & 15) << 2, c = 2;\n          break;\n        case 2:\n          u += encTable[v | l >> 6], u += encTable[l & 63], c = 0;\n          break;\n      }\n    return c && (u += encTable[v], u += \"=\", c == 1 && (u += \"=\")), u;\n  }\n}, jsonReadDefaults = {\n  ignoreUnknownFields: !1\n}, jsonWriteDefaults = {\n  emitDefaultValues: !1,\n  enumAsInteger: !1,\n  useProtoFieldName: !1,\n  prettySpaces: 0\n};\nfunction makeReadOptions(a) {\n  return a ? Object.assign(Object.assign({}, jsonReadDefaults), a) : jsonReadDefaults;\n}\nfunction makeWriteOptions(a) {\n  return a ? Object.assign(Object.assign({}, jsonWriteDefaults), a) : jsonWriteDefaults;\n}\nfunction makeJsonFormatCommon(a) {\n  const u = a(writeEnum, writeScalar);\n  return {\n    makeReadOptions,\n    makeWriteOptions,\n    readMessage(c, l, v, S) {\n      if (l == null || Array.isArray(l) || typeof l != \"object\")\n        throw new Error(\"cannot decode message \".concat(c.typeName, \" from JSON: \").concat(this.debug(l)));\n      S = S ?? new c();\n      const g = {};\n      for (const [E, _] of Object.entries(l)) {\n        const k = c.fields.findJsonName(E);\n        if (!k) {\n          if (!v.ignoreUnknownFields)\n            throw new Error(\"cannot decode message \".concat(c.typeName, ' from JSON: key \"').concat(E, '\" is unknown'));\n          continue;\n        }\n        let L = k.localName, M = S;\n        if (k.oneof) {\n          if (_ === null && k.kind == \"scalar\")\n            continue;\n          const $ = g[k.oneof.localName];\n          if ($)\n            throw new Error(\"cannot decode message \".concat(c.typeName, ' from JSON: multiple keys for oneof \"').concat(k.oneof.name, '\" present: \"').concat($, '\", \"').concat(E, '\"'));\n          g[k.oneof.localName] = E, M = M[k.oneof.localName] = {\n            case: L\n          }, L = \"value\";\n        }\n        if (k.repeated) {\n          if (_ === null)\n            continue;\n          if (!Array.isArray(_))\n            throw new Error(\"cannot decode field \".concat(c.typeName, \".\").concat(k.name, \" from JSON: \").concat(this.debug(_)));\n          const $ = M[L];\n          for (const J of _) {\n            if (J === null)\n              throw new Error(\"cannot decode field \".concat(c.typeName, \".\").concat(k.name, \" from JSON: \").concat(this.debug(J)));\n            let V;\n            switch (k.kind) {\n              case \"message\":\n                V = k.T.fromJson(J, v);\n                break;\n              case \"enum\":\n                if (V = readEnum(k.T, J, v.ignoreUnknownFields), V === void 0)\n                  continue;\n                break;\n              case \"scalar\":\n                try {\n                  V = readScalar(k.T, J, k.L);\n                } catch (q) {\n                  let G = \"cannot decode field \".concat(c.typeName, \".\").concat(k.name, \" from JSON: \").concat(this.debug(J));\n                  throw q instanceof Error && q.message.length > 0 && (G += \": \".concat(q.message)), new Error(G);\n                }\n                break;\n            }\n            $.push(V);\n          }\n        } else if (k.kind == \"map\") {\n          if (_ === null)\n            continue;\n          if (Array.isArray(_) || typeof _ != \"object\")\n            throw new Error(\"cannot decode field \".concat(c.typeName, \".\").concat(k.name, \" from JSON: \").concat(this.debug(_)));\n          const $ = M[L];\n          for (const [J, V] of Object.entries(_)) {\n            if (V === null)\n              throw new Error(\"cannot decode field \".concat(c.typeName, \".\").concat(k.name, \" from JSON: map value null\"));\n            let q;\n            switch (k.V.kind) {\n              case \"message\":\n                q = k.V.T.fromJson(V, v);\n                break;\n              case \"enum\":\n                if (q = readEnum(k.V.T, V, v.ignoreUnknownFields), q === void 0)\n                  continue;\n                break;\n              case \"scalar\":\n                try {\n                  q = readScalar(k.V.T, V, LongType.BIGINT);\n                } catch (G) {\n                  let H = \"cannot decode map value for field \".concat(c.typeName, \".\").concat(k.name, \" from JSON: \").concat(this.debug(_));\n                  throw G instanceof Error && G.message.length > 0 && (H += \": \".concat(G.message)), new Error(H);\n                }\n                break;\n            }\n            try {\n              $[readScalar(k.K, k.K == ScalarType.BOOL ? J == \"true\" ? !0 : J == \"false\" ? !1 : J : J, LongType.BIGINT).toString()] = q;\n            } catch (G) {\n              let H = \"cannot decode map key for field \".concat(c.typeName, \".\").concat(k.name, \" from JSON: \").concat(this.debug(_));\n              throw G instanceof Error && G.message.length > 0 && (H += \": \".concat(G.message)), new Error(H);\n            }\n          }\n        } else\n          switch (k.kind) {\n            case \"message\":\n              const $ = k.T;\n              if (_ === null && $.typeName != \"google.protobuf.Value\") {\n                if (k.oneof)\n                  throw new Error(\"cannot decode field \".concat(c.typeName, \".\").concat(k.name, ' from JSON: null is invalid for oneof field \"').concat(E, '\"'));\n                continue;\n              }\n              M[L] instanceof Message ? M[L].fromJson(_, v) : (M[L] = $.fromJson(_, v), $.fieldWrapper && !k.oneof && (M[L] = $.fieldWrapper.unwrapField(M[L])));\n              break;\n            case \"enum\":\n              const J = readEnum(k.T, _, v.ignoreUnknownFields);\n              J !== void 0 && (M[L] = J);\n              break;\n            case \"scalar\":\n              try {\n                M[L] = readScalar(k.T, _, k.L);\n              } catch (V) {\n                let q = \"cannot decode field \".concat(c.typeName, \".\").concat(k.name, \" from JSON: \").concat(this.debug(_));\n                throw V instanceof Error && V.message.length > 0 && (q += \": \".concat(V.message)), new Error(q);\n              }\n              break;\n          }\n      }\n      return S;\n    },\n    writeMessage(c, l) {\n      const v = c.getType(), S = {};\n      let g;\n      try {\n        for (const E of v.fields.byMember()) {\n          let _;\n          if (E.kind == \"oneof\") {\n            const k = c[E.localName];\n            if (k.value === void 0)\n              continue;\n            if (g = E.findField(k.case), !g)\n              throw \"oneof case not found: \" + k.case;\n            _ = u(g, k.value, l);\n          } else\n            g = E, _ = u(g, c[g.localName], l);\n          _ !== void 0 && (S[l.useProtoFieldName ? g.name : g.jsonName] = _);\n        }\n      } catch (E) {\n        const _ = g ? \"cannot encode field \".concat(v.typeName, \".\").concat(g.name, \" to JSON\") : \"cannot encode message \".concat(v.typeName, \" to JSON\"), k = E instanceof Error ? E.message : String(E);\n        throw new Error(_ + (k.length > 0 ? \": \".concat(k) : \"\"));\n      }\n      return S;\n    },\n    readScalar,\n    writeScalar,\n    debug: debugJsonValue\n  };\n}\nfunction debugJsonValue(a) {\n  if (a === null)\n    return \"null\";\n  switch (typeof a) {\n    case \"object\":\n      return Array.isArray(a) ? \"array\" : \"object\";\n    case \"string\":\n      return a.length > 100 ? \"string\" : '\"'.concat(a.split('\"').join('\\\\\"'), '\"');\n    default:\n      return String(a);\n  }\n}\nfunction readScalar(a, u, c) {\n  switch (a) {\n    case ScalarType.DOUBLE:\n    case ScalarType.FLOAT:\n      if (u === null)\n        return 0;\n      if (u === \"NaN\")\n        return Number.NaN;\n      if (u === \"Infinity\")\n        return Number.POSITIVE_INFINITY;\n      if (u === \"-Infinity\")\n        return Number.NEGATIVE_INFINITY;\n      if (u === \"\" || typeof u == \"string\" && u.trim().length !== u.length || typeof u != \"string\" && typeof u != \"number\")\n        break;\n      const l = Number(u);\n      if (Number.isNaN(l) || !Number.isFinite(l))\n        break;\n      return a == ScalarType.FLOAT && assertFloat32(l), l;\n    case ScalarType.INT32:\n    case ScalarType.FIXED32:\n    case ScalarType.SFIXED32:\n    case ScalarType.SINT32:\n    case ScalarType.UINT32:\n      if (u === null)\n        return 0;\n      let v;\n      if (typeof u == \"number\" ? v = u : typeof u == \"string\" && u.length > 0 && u.trim().length === u.length && (v = Number(u)), v === void 0)\n        break;\n      return a == ScalarType.UINT32 ? assertUInt32(v) : assertInt32(v), v;\n    case ScalarType.INT64:\n    case ScalarType.SFIXED64:\n    case ScalarType.SINT64:\n      if (u === null)\n        return protoInt64.zero;\n      if (typeof u != \"number\" && typeof u != \"string\")\n        break;\n      const S = protoInt64.parse(u);\n      return c ? S.toString() : S;\n    case ScalarType.FIXED64:\n    case ScalarType.UINT64:\n      if (u === null)\n        return protoInt64.zero;\n      if (typeof u != \"number\" && typeof u != \"string\")\n        break;\n      const g = protoInt64.uParse(u);\n      return c ? g.toString() : g;\n    case ScalarType.BOOL:\n      if (u === null)\n        return !1;\n      if (typeof u != \"boolean\")\n        break;\n      return u;\n    case ScalarType.STRING:\n      if (u === null)\n        return \"\";\n      if (typeof u != \"string\")\n        break;\n      try {\n        encodeURIComponent(u);\n      } catch {\n        throw new Error(\"invalid UTF8\");\n      }\n      return u;\n    case ScalarType.BYTES:\n      if (u === null || u === \"\")\n        return new Uint8Array(0);\n      if (typeof u != \"string\")\n        break;\n      return protoBase64.dec(u);\n  }\n  throw new Error();\n}\nfunction readEnum(a, u, c) {\n  if (u === null)\n    return 0;\n  switch (typeof u) {\n    case \"number\":\n      if (Number.isInteger(u))\n        return u;\n      break;\n    case \"string\":\n      const l = a.findName(u);\n      if (l || c)\n        return l == null ? void 0 : l.no;\n      break;\n  }\n  throw new Error(\"cannot decode enum \".concat(a.typeName, \" from JSON: \").concat(debugJsonValue(u)));\n}\nfunction writeEnum(a, u, c, l) {\n  var v;\n  if (u === void 0)\n    return u;\n  if (u === 0 && !c)\n    return;\n  if (l)\n    return u;\n  if (a.typeName == \"google.protobuf.NullValue\")\n    return null;\n  const S = a.findNumber(u);\n  return (v = S == null ? void 0 : S.name) !== null && v !== void 0 ? v : u;\n}\nfunction writeScalar(a, u, c) {\n  if (u !== void 0)\n    switch (a) {\n      case ScalarType.INT32:\n      case ScalarType.SFIXED32:\n      case ScalarType.SINT32:\n      case ScalarType.FIXED32:\n      case ScalarType.UINT32:\n        return assert(typeof u == \"number\"), u != 0 || c ? u : void 0;\n      case ScalarType.FLOAT:\n      case ScalarType.DOUBLE:\n        return assert(typeof u == \"number\"), Number.isNaN(u) ? \"NaN\" : u === Number.POSITIVE_INFINITY ? \"Infinity\" : u === Number.NEGATIVE_INFINITY ? \"-Infinity\" : u !== 0 || c ? u : void 0;\n      case ScalarType.STRING:\n        return assert(typeof u == \"string\"), u.length > 0 || c ? u : void 0;\n      case ScalarType.BOOL:\n        return assert(typeof u == \"boolean\"), u || c ? u : void 0;\n      case ScalarType.UINT64:\n      case ScalarType.FIXED64:\n      case ScalarType.INT64:\n      case ScalarType.SFIXED64:\n      case ScalarType.SINT64:\n        return assert(typeof u == \"bigint\" || typeof u == \"string\" || typeof u == \"number\"), c || u != 0 ? u.toString(10) : void 0;\n      case ScalarType.BYTES:\n        return assert(u instanceof Uint8Array), c || u.byteLength > 0 ? protoBase64.enc(u) : void 0;\n    }\n}\nfunction makeJsonFormatProto3() {\n  return makeJsonFormatCommon((a, u) => function(l, v, S) {\n    if (l.kind == \"map\") {\n      const g = {};\n      switch (l.V.kind) {\n        case \"scalar\":\n          for (const [_, k] of Object.entries(v)) {\n            const L = u(l.V.T, k, !0);\n            assert(L !== void 0), g[_.toString()] = L;\n          }\n          break;\n        case \"message\":\n          for (const [_, k] of Object.entries(v))\n            g[_.toString()] = k.toJson(S);\n          break;\n        case \"enum\":\n          const E = l.V.T;\n          for (const [_, k] of Object.entries(v)) {\n            assert(k === void 0 || typeof k == \"number\");\n            const L = a(E, k, !0, S.enumAsInteger);\n            assert(L !== void 0), g[_.toString()] = L;\n          }\n          break;\n      }\n      return S.emitDefaultValues || Object.keys(g).length > 0 ? g : void 0;\n    } else if (l.repeated) {\n      const g = [];\n      switch (l.kind) {\n        case \"scalar\":\n          for (let E = 0; E < v.length; E++)\n            g.push(u(l.T, v[E], !0));\n          break;\n        case \"enum\":\n          for (let E = 0; E < v.length; E++)\n            g.push(a(l.T, v[E], !0, S.enumAsInteger));\n          break;\n        case \"message\":\n          for (let E = 0; E < v.length; E++)\n            g.push(wrapField(l.T, v[E]).toJson(S));\n          break;\n      }\n      return S.emitDefaultValues || g.length > 0 ? g : void 0;\n    } else\n      switch (l.kind) {\n        case \"scalar\":\n          return u(l.T, v, !!l.oneof || l.opt || S.emitDefaultValues);\n        case \"enum\":\n          return a(l.T, v, !!l.oneof || l.opt || S.emitDefaultValues, S.enumAsInteger);\n        case \"message\":\n          return v !== void 0 ? wrapField(l.T, v).toJson(S) : void 0;\n      }\n  });\n}\nfunction makeUtilCommon() {\n  return {\n    setEnumType,\n    initPartial(a, u) {\n      if (a === void 0)\n        return;\n      const c = u.getType();\n      for (const l of c.fields.byMember()) {\n        const v = l.localName, S = u, g = a;\n        if (g[v] !== void 0)\n          switch (l.kind) {\n            case \"oneof\":\n              const E = g[v].case;\n              if (E === void 0)\n                continue;\n              const _ = l.findField(E);\n              let k = g[v].value;\n              _ && _.kind == \"message\" && !(k instanceof _.T) ? k = new _.T(k) : _ && _.kind === \"scalar\" && _.T === ScalarType.BYTES && (k = toU8Arr(k)), S[v] = {\n                case: E,\n                value: k\n              };\n              break;\n            case \"scalar\":\n            case \"enum\":\n              let L = g[v];\n              l.T === ScalarType.BYTES && (L = l.repeated ? L.map(toU8Arr) : toU8Arr(L)), S[v] = L;\n              break;\n            case \"map\":\n              switch (l.V.kind) {\n                case \"scalar\":\n                case \"enum\":\n                  if (l.V.T === ScalarType.BYTES)\n                    for (const [J, V] of Object.entries(g[v]))\n                      S[v][J] = toU8Arr(V);\n                  else\n                    Object.assign(S[v], g[v]);\n                  break;\n                case \"message\":\n                  const $ = l.V.T;\n                  for (const J of Object.keys(g[v])) {\n                    let V = g[v][J];\n                    $.fieldWrapper || (V = new $(V)), S[v][J] = V;\n                  }\n                  break;\n              }\n              break;\n            case \"message\":\n              const M = l.T;\n              if (l.repeated)\n                S[v] = g[v].map(($) => $ instanceof M ? $ : new M($));\n              else if (g[v] !== void 0) {\n                const $ = g[v];\n                M.fieldWrapper ? /* We can't use BytesValue.typeName as that will create a circular import */ M.typeName === \"google.protobuf.BytesValue\" ? S[v] = toU8Arr($) : S[v] = $ : S[v] = $ instanceof M ? $ : new M($);\n              }\n              break;\n          }\n      }\n    },\n    equals(a, u, c) {\n      return u === c ? !0 : !u || !c ? !1 : a.fields.byMember().every((l) => {\n        const v = u[l.localName], S = c[l.localName];\n        if (l.repeated) {\n          if (v.length !== S.length)\n            return !1;\n          switch (l.kind) {\n            case \"message\":\n              return v.every((g, E) => l.T.equals(g, S[E]));\n            case \"scalar\":\n              return v.every((g, E) => scalarEquals(l.T, g, S[E]));\n            case \"enum\":\n              return v.every((g, E) => scalarEquals(ScalarType.INT32, g, S[E]));\n          }\n          throw new Error(\"repeated cannot contain \".concat(l.kind));\n        }\n        switch (l.kind) {\n          case \"message\":\n            return l.T.equals(v, S);\n          case \"enum\":\n            return scalarEquals(ScalarType.INT32, v, S);\n          case \"scalar\":\n            return scalarEquals(l.T, v, S);\n          case \"oneof\":\n            if (v.case !== S.case)\n              return !1;\n            const g = l.findField(v.case);\n            if (g === void 0)\n              return !0;\n            switch (g.kind) {\n              case \"message\":\n                return g.T.equals(v.value, S.value);\n              case \"enum\":\n                return scalarEquals(ScalarType.INT32, v.value, S.value);\n              case \"scalar\":\n                return scalarEquals(g.T, v.value, S.value);\n            }\n            throw new Error(\"oneof cannot contain \".concat(g.kind));\n          case \"map\":\n            const E = Object.keys(v).concat(Object.keys(S));\n            switch (l.V.kind) {\n              case \"message\":\n                const _ = l.V.T;\n                return E.every((L) => _.equals(v[L], S[L]));\n              case \"enum\":\n                return E.every((L) => scalarEquals(ScalarType.INT32, v[L], S[L]));\n              case \"scalar\":\n                const k = l.V.T;\n                return E.every((L) => scalarEquals(k, v[L], S[L]));\n            }\n            break;\n        }\n      });\n    },\n    clone(a) {\n      const u = a.getType(), c = new u(), l = c;\n      for (const v of u.fields.byMember()) {\n        const S = a[v.localName];\n        let g;\n        if (v.repeated)\n          g = S.map(cloneSingularField);\n        else if (v.kind == \"map\") {\n          g = l[v.localName];\n          for (const [E, _] of Object.entries(S))\n            g[E] = cloneSingularField(_);\n        } else\n          v.kind == \"oneof\" ? g = v.findField(S.case) ? {\n            case: S.case,\n            value: cloneSingularField(S.value)\n          } : {\n            case: void 0\n          } : g = cloneSingularField(S);\n        l[v.localName] = g;\n      }\n      return c;\n    }\n  };\n}\nfunction cloneSingularField(a) {\n  if (a === void 0)\n    return a;\n  if (a instanceof Message)\n    return a.clone();\n  if (a instanceof Uint8Array) {\n    const u = new Uint8Array(a.byteLength);\n    return u.set(a), u;\n  }\n  return a;\n}\nfunction toU8Arr(a) {\n  return a instanceof Uint8Array ? a : new Uint8Array(a);\n}\nclass InternalFieldList {\n  constructor(u, c) {\n    this._fields = u, this._normalizer = c;\n  }\n  findJsonName(u) {\n    if (!this.jsonNames) {\n      const c = {};\n      for (const l of this.list())\n        c[l.jsonName] = c[l.name] = l;\n      this.jsonNames = c;\n    }\n    return this.jsonNames[u];\n  }\n  find(u) {\n    if (!this.numbers) {\n      const c = {};\n      for (const l of this.list())\n        c[l.no] = l;\n      this.numbers = c;\n    }\n    return this.numbers[u];\n  }\n  list() {\n    return this.all || (this.all = this._normalizer(this._fields)), this.all;\n  }\n  byNumber() {\n    return this.numbersAsc || (this.numbersAsc = this.list().concat().sort((u, c) => u.no - c.no)), this.numbersAsc;\n  }\n  byMember() {\n    if (!this.members) {\n      this.members = [];\n      const u = this.members;\n      let c;\n      for (const l of this.list())\n        l.oneof ? l.oneof !== c && (c = l.oneof, u.push(c)) : u.push(l);\n    }\n    return this.members;\n  }\n}\nfunction localFieldName(a, u) {\n  const c = protoCamelCase(a);\n  return u ? c : safeObjectProperty(safeMessageProperty(c));\n}\nfunction localOneofName(a) {\n  return localFieldName(a, !1);\n}\nconst fieldJsonName = protoCamelCase;\nfunction protoCamelCase(a) {\n  let u = !1;\n  const c = [];\n  for (let l = 0; l < a.length; l++) {\n    let v = a.charAt(l);\n    switch (v) {\n      case \"_\":\n        u = !0;\n        break;\n      case \"0\":\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        c.push(v), u = !1;\n        break;\n      default:\n        u && (u = !1, v = v.toUpperCase()), c.push(v);\n        break;\n    }\n  }\n  return c.join(\"\");\n}\nconst reservedObjectProperties = /* @__PURE__ */ new Set([\n  // names reserved by JavaScript\n  \"constructor\",\n  \"toString\",\n  \"toJSON\",\n  \"valueOf\"\n]), reservedMessageProperties = /* @__PURE__ */ new Set([\n  // names reserved by the runtime\n  \"getType\",\n  \"clone\",\n  \"equals\",\n  \"fromBinary\",\n  \"fromJson\",\n  \"fromJsonString\",\n  \"toBinary\",\n  \"toJson\",\n  \"toJsonString\",\n  // names reserved by the runtime for the future\n  \"toObject\"\n]), fallback = (a) => \"\".concat(a, \"$\"), safeMessageProperty = (a) => reservedMessageProperties.has(a) ? fallback(a) : a, safeObjectProperty = (a) => reservedObjectProperties.has(a) ? fallback(a) : a;\nclass InternalOneofInfo {\n  constructor(u) {\n    this.kind = \"oneof\", this.repeated = !1, this.packed = !1, this.opt = !1, this.default = void 0, this.fields = [], this.name = u, this.localName = localOneofName(u);\n  }\n  addField(u) {\n    assert(u.oneof === this, \"field \".concat(u.name, \" not one of \").concat(this.name)), this.fields.push(u);\n  }\n  findField(u) {\n    if (!this._lookup) {\n      this._lookup = /* @__PURE__ */ Object.create(null);\n      for (let c = 0; c < this.fields.length; c++)\n        this._lookup[this.fields[c].localName] = this.fields[c];\n    }\n    return this._lookup[u];\n  }\n}\nconst proto3 = makeProtoRuntime(\"proto3\", makeJsonFormatProto3(), makeBinaryFormatProto3(), Object.assign(Object.assign({}, makeUtilCommon()), {\n  newFieldList(a) {\n    return new InternalFieldList(a, normalizeFieldInfosProto3);\n  },\n  initFields(a) {\n    for (const u of a.getType().fields.byMember()) {\n      if (u.opt)\n        continue;\n      const c = u.localName, l = a;\n      if (u.repeated) {\n        l[c] = [];\n        continue;\n      }\n      switch (u.kind) {\n        case \"oneof\":\n          l[c] = {\n            case: void 0\n          };\n          break;\n        case \"enum\":\n          l[c] = 0;\n          break;\n        case \"map\":\n          l[c] = {};\n          break;\n        case \"scalar\":\n          l[c] = scalarDefaultValue(u.T, u.L);\n          break;\n      }\n    }\n  }\n}));\nfunction normalizeFieldInfosProto3(a) {\n  var u, c, l, v;\n  const S = [];\n  let g;\n  for (const E of typeof a == \"function\" ? a() : a) {\n    const _ = E;\n    if (_.localName = localFieldName(E.name, E.oneof !== void 0), _.jsonName = (u = E.jsonName) !== null && u !== void 0 ? u : fieldJsonName(E.name), _.repeated = (c = E.repeated) !== null && c !== void 0 ? c : !1, E.kind == \"scalar\" && (_.L = (l = E.L) !== null && l !== void 0 ? l : LongType.BIGINT), _.packed = (v = E.packed) !== null && v !== void 0 ? v : E.kind == \"enum\" || E.kind == \"scalar\" && E.T != ScalarType.BYTES && E.T != ScalarType.STRING, E.oneof !== void 0) {\n      const k = typeof E.oneof == \"string\" ? E.oneof : E.oneof.name;\n      (!g || g.name != k) && (g = new InternalOneofInfo(k)), _.oneof = g, g.addField(_);\n    }\n    S.push(_);\n  }\n  return S;\n}\nclass Timestamp extends Message {\n  constructor(u) {\n    super(), this.seconds = protoInt64.zero, this.nanos = 0, proto3.util.initPartial(u, this);\n  }\n  fromJson(u, c) {\n    if (typeof u != \"string\")\n      throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: \".concat(proto3.json.debug(u)));\n    const l = u.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n    if (!l)\n      throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n    const v = Date.parse(l[1] + \"-\" + l[2] + \"-\" + l[3] + \"T\" + l[4] + \":\" + l[5] + \":\" + l[6] + (l[8] ? l[8] : \"Z\"));\n    if (Number.isNaN(v))\n      throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n    if (v < Date.parse(\"0001-01-01T00:00:00Z\") || v > Date.parse(\"9999-12-31T23:59:59Z\"))\n      throw new Error(\"cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n    return this.seconds = protoInt64.parse(v / 1e3), this.nanos = 0, l[7] && (this.nanos = parseInt(\"1\" + l[7] + \"0\".repeat(9 - l[7].length)) - 1e9), this;\n  }\n  toJson(u) {\n    const c = Number(this.seconds) * 1e3;\n    if (c < Date.parse(\"0001-01-01T00:00:00Z\") || c > Date.parse(\"9999-12-31T23:59:59Z\"))\n      throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n    if (this.nanos < 0)\n      throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative\");\n    let l = \"Z\";\n    if (this.nanos > 0) {\n      const v = (this.nanos + 1e9).toString().substring(1);\n      v.substring(3) === \"000000\" ? l = \".\" + v.substring(0, 3) + \"Z\" : v.substring(6) === \"000\" ? l = \".\" + v.substring(0, 6) + \"Z\" : l = \".\" + v + \"Z\";\n    }\n    return new Date(c).toISOString().replace(\".000Z\", l);\n  }\n  toDate() {\n    return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));\n  }\n  static now() {\n    return Timestamp.fromDate(/* @__PURE__ */ new Date());\n  }\n  static fromDate(u) {\n    const c = u.getTime();\n    return new Timestamp({\n      seconds: protoInt64.parse(Math.floor(c / 1e3)),\n      nanos: c % 1e3 * 1e6\n    });\n  }\n  static fromBinary(u, c) {\n    return new Timestamp().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new Timestamp().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new Timestamp().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(Timestamp, u, c);\n  }\n}\nTimestamp.runtime = proto3;\nTimestamp.typeName = \"google.protobuf.Timestamp\";\nTimestamp.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"seconds\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 2,\n  name: \"nanos\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}]);\nvar AudioCodec$1;\n(function(a) {\n  a[a.DEFAULT_AC = 0] = \"DEFAULT_AC\", a[a.OPUS = 1] = \"OPUS\", a[a.AAC = 2] = \"AAC\";\n})(AudioCodec$1 || (AudioCodec$1 = {}));\nproto3.util.setEnumType(AudioCodec$1, \"livekit.AudioCodec\", [{\n  no: 0,\n  name: \"DEFAULT_AC\"\n}, {\n  no: 1,\n  name: \"OPUS\"\n}, {\n  no: 2,\n  name: \"AAC\"\n}]);\nvar VideoCodec$1;\n(function(a) {\n  a[a.DEFAULT_VC = 0] = \"DEFAULT_VC\", a[a.H264_BASELINE = 1] = \"H264_BASELINE\", a[a.H264_MAIN = 2] = \"H264_MAIN\", a[a.H264_HIGH = 3] = \"H264_HIGH\", a[a.VP8 = 4] = \"VP8\";\n})(VideoCodec$1 || (VideoCodec$1 = {}));\nproto3.util.setEnumType(VideoCodec$1, \"livekit.VideoCodec\", [{\n  no: 0,\n  name: \"DEFAULT_VC\"\n}, {\n  no: 1,\n  name: \"H264_BASELINE\"\n}, {\n  no: 2,\n  name: \"H264_MAIN\"\n}, {\n  no: 3,\n  name: \"H264_HIGH\"\n}, {\n  no: 4,\n  name: \"VP8\"\n}]);\nvar ImageCodec;\n(function(a) {\n  a[a.IC_DEFAULT = 0] = \"IC_DEFAULT\", a[a.IC_JPEG = 1] = \"IC_JPEG\";\n})(ImageCodec || (ImageCodec = {}));\nproto3.util.setEnumType(ImageCodec, \"livekit.ImageCodec\", [{\n  no: 0,\n  name: \"IC_DEFAULT\"\n}, {\n  no: 1,\n  name: \"IC_JPEG\"\n}]);\nvar TrackType;\n(function(a) {\n  a[a.AUDIO = 0] = \"AUDIO\", a[a.VIDEO = 1] = \"VIDEO\", a[a.DATA = 2] = \"DATA\";\n})(TrackType || (TrackType = {}));\nproto3.util.setEnumType(TrackType, \"livekit.TrackType\", [{\n  no: 0,\n  name: \"AUDIO\"\n}, {\n  no: 1,\n  name: \"VIDEO\"\n}, {\n  no: 2,\n  name: \"DATA\"\n}]);\nvar TrackSource;\n(function(a) {\n  a[a.UNKNOWN = 0] = \"UNKNOWN\", a[a.CAMERA = 1] = \"CAMERA\", a[a.MICROPHONE = 2] = \"MICROPHONE\", a[a.SCREEN_SHARE = 3] = \"SCREEN_SHARE\", a[a.SCREEN_SHARE_AUDIO = 4] = \"SCREEN_SHARE_AUDIO\";\n})(TrackSource || (TrackSource = {}));\nproto3.util.setEnumType(TrackSource, \"livekit.TrackSource\", [{\n  no: 0,\n  name: \"UNKNOWN\"\n}, {\n  no: 1,\n  name: \"CAMERA\"\n}, {\n  no: 2,\n  name: \"MICROPHONE\"\n}, {\n  no: 3,\n  name: \"SCREEN_SHARE\"\n}, {\n  no: 4,\n  name: \"SCREEN_SHARE_AUDIO\"\n}]);\nvar VideoQuality$1;\n(function(a) {\n  a[a.LOW = 0] = \"LOW\", a[a.MEDIUM = 1] = \"MEDIUM\", a[a.HIGH = 2] = \"HIGH\", a[a.OFF = 3] = \"OFF\";\n})(VideoQuality$1 || (VideoQuality$1 = {}));\nproto3.util.setEnumType(VideoQuality$1, \"livekit.VideoQuality\", [{\n  no: 0,\n  name: \"LOW\"\n}, {\n  no: 1,\n  name: \"MEDIUM\"\n}, {\n  no: 2,\n  name: \"HIGH\"\n}, {\n  no: 3,\n  name: \"OFF\"\n}]);\nvar ConnectionQuality$1;\n(function(a) {\n  a[a.POOR = 0] = \"POOR\", a[a.GOOD = 1] = \"GOOD\", a[a.EXCELLENT = 2] = \"EXCELLENT\", a[a.LOST = 3] = \"LOST\";\n})(ConnectionQuality$1 || (ConnectionQuality$1 = {}));\nproto3.util.setEnumType(ConnectionQuality$1, \"livekit.ConnectionQuality\", [{\n  no: 0,\n  name: \"POOR\"\n}, {\n  no: 1,\n  name: \"GOOD\"\n}, {\n  no: 2,\n  name: \"EXCELLENT\"\n}, {\n  no: 3,\n  name: \"LOST\"\n}]);\nvar ClientConfigSetting;\n(function(a) {\n  a[a.UNSET = 0] = \"UNSET\", a[a.DISABLED = 1] = \"DISABLED\", a[a.ENABLED = 2] = \"ENABLED\";\n})(ClientConfigSetting || (ClientConfigSetting = {}));\nproto3.util.setEnumType(ClientConfigSetting, \"livekit.ClientConfigSetting\", [{\n  no: 0,\n  name: \"UNSET\"\n}, {\n  no: 1,\n  name: \"DISABLED\"\n}, {\n  no: 2,\n  name: \"ENABLED\"\n}]);\nvar DisconnectReason;\n(function(a) {\n  a[a.UNKNOWN_REASON = 0] = \"UNKNOWN_REASON\", a[a.CLIENT_INITIATED = 1] = \"CLIENT_INITIATED\", a[a.DUPLICATE_IDENTITY = 2] = \"DUPLICATE_IDENTITY\", a[a.SERVER_SHUTDOWN = 3] = \"SERVER_SHUTDOWN\", a[a.PARTICIPANT_REMOVED = 4] = \"PARTICIPANT_REMOVED\", a[a.ROOM_DELETED = 5] = \"ROOM_DELETED\", a[a.STATE_MISMATCH = 6] = \"STATE_MISMATCH\", a[a.JOIN_FAILURE = 7] = \"JOIN_FAILURE\", a[a.MIGRATION = 8] = \"MIGRATION\", a[a.SIGNAL_CLOSE = 9] = \"SIGNAL_CLOSE\";\n})(DisconnectReason || (DisconnectReason = {}));\nproto3.util.setEnumType(DisconnectReason, \"livekit.DisconnectReason\", [{\n  no: 0,\n  name: \"UNKNOWN_REASON\"\n}, {\n  no: 1,\n  name: \"CLIENT_INITIATED\"\n}, {\n  no: 2,\n  name: \"DUPLICATE_IDENTITY\"\n}, {\n  no: 3,\n  name: \"SERVER_SHUTDOWN\"\n}, {\n  no: 4,\n  name: \"PARTICIPANT_REMOVED\"\n}, {\n  no: 5,\n  name: \"ROOM_DELETED\"\n}, {\n  no: 6,\n  name: \"STATE_MISMATCH\"\n}, {\n  no: 7,\n  name: \"JOIN_FAILURE\"\n}, {\n  no: 8,\n  name: \"MIGRATION\"\n}, {\n  no: 9,\n  name: \"SIGNAL_CLOSE\"\n}]);\nvar ReconnectReason;\n(function(a) {\n  a[a.RR_UNKNOWN = 0] = \"RR_UNKNOWN\", a[a.RR_SIGNAL_DISCONNECTED = 1] = \"RR_SIGNAL_DISCONNECTED\", a[a.RR_PUBLISHER_FAILED = 2] = \"RR_PUBLISHER_FAILED\", a[a.RR_SUBSCRIBER_FAILED = 3] = \"RR_SUBSCRIBER_FAILED\", a[a.RR_SWITCH_CANDIDATE = 4] = \"RR_SWITCH_CANDIDATE\";\n})(ReconnectReason || (ReconnectReason = {}));\nproto3.util.setEnumType(ReconnectReason, \"livekit.ReconnectReason\", [{\n  no: 0,\n  name: \"RR_UNKNOWN\"\n}, {\n  no: 1,\n  name: \"RR_SIGNAL_DISCONNECTED\"\n}, {\n  no: 2,\n  name: \"RR_PUBLISHER_FAILED\"\n}, {\n  no: 3,\n  name: \"RR_SUBSCRIBER_FAILED\"\n}, {\n  no: 4,\n  name: \"RR_SWITCH_CANDIDATE\"\n}]);\nvar SubscriptionError;\n(function(a) {\n  a[a.SE_UNKNOWN = 0] = \"SE_UNKNOWN\", a[a.SE_CODEC_UNSUPPORTED = 1] = \"SE_CODEC_UNSUPPORTED\", a[a.SE_TRACK_NOTFOUND = 2] = \"SE_TRACK_NOTFOUND\";\n})(SubscriptionError || (SubscriptionError = {}));\nproto3.util.setEnumType(SubscriptionError, \"livekit.SubscriptionError\", [{\n  no: 0,\n  name: \"SE_UNKNOWN\"\n}, {\n  no: 1,\n  name: \"SE_CODEC_UNSUPPORTED\"\n}, {\n  no: 2,\n  name: \"SE_TRACK_NOTFOUND\"\n}]);\nlet Room$1 = class Lt extends Message {\n  constructor(u) {\n    super(), this.sid = \"\", this.name = \"\", this.emptyTimeout = 0, this.maxParticipants = 0, this.creationTime = protoInt64.zero, this.turnPassword = \"\", this.enabledCodecs = [], this.metadata = \"\", this.numParticipants = 0, this.numPublishers = 0, this.activeRecording = !1, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new Lt().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new Lt().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new Lt().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(Lt, u, c);\n  }\n};\nRoom$1.runtime = proto3;\nRoom$1.typeName = \"livekit.Room\";\nRoom$1.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"empty_timeout\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 4,\n  name: \"max_participants\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 5,\n  name: \"creation_time\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 6,\n  name: \"turn_password\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 7,\n  name: \"enabled_codecs\",\n  kind: \"message\",\n  T: Codec,\n  repeated: !0\n}, {\n  no: 8,\n  name: \"metadata\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 9,\n  name: \"num_participants\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 11,\n  name: \"num_publishers\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 10,\n  name: \"active_recording\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 13,\n  name: \"version\",\n  kind: \"message\",\n  T: TimedVersion\n}]);\nclass Codec extends Message {\n  constructor(u) {\n    super(), this.mime = \"\", this.fmtpLine = \"\", proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new Codec().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new Codec().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new Codec().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(Codec, u, c);\n  }\n}\nCodec.runtime = proto3;\nCodec.typeName = \"livekit.Codec\";\nCodec.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"mime\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"fmtp_line\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nclass PlayoutDelay extends Message {\n  constructor(u) {\n    super(), this.enabled = !1, this.min = 0, this.max = 0, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new PlayoutDelay().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new PlayoutDelay().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new PlayoutDelay().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(PlayoutDelay, u, c);\n  }\n}\nPlayoutDelay.runtime = proto3;\nPlayoutDelay.typeName = \"livekit.PlayoutDelay\";\nPlayoutDelay.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"enabled\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 2,\n  name: \"min\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 3,\n  name: \"max\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nclass ParticipantPermission extends Message {\n  constructor(u) {\n    super(), this.canSubscribe = !1, this.canPublish = !1, this.canPublishData = !1, this.canPublishSources = [], this.hidden = !1, this.recorder = !1, this.canUpdateMetadata = !1, this.agent = !1, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new ParticipantPermission().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new ParticipantPermission().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new ParticipantPermission().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(ParticipantPermission, u, c);\n  }\n}\nParticipantPermission.runtime = proto3;\nParticipantPermission.typeName = \"livekit.ParticipantPermission\";\nParticipantPermission.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"can_subscribe\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 2,\n  name: \"can_publish\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 3,\n  name: \"can_publish_data\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 9,\n  name: \"can_publish_sources\",\n  kind: \"enum\",\n  T: proto3.getEnumType(TrackSource),\n  repeated: !0\n}, {\n  no: 7,\n  name: \"hidden\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 8,\n  name: \"recorder\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 10,\n  name: \"can_update_metadata\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 11,\n  name: \"agent\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nclass ParticipantInfo extends Message {\n  constructor(u) {\n    super(), this.sid = \"\", this.identity = \"\", this.state = ParticipantInfo_State.JOINING, this.tracks = [], this.metadata = \"\", this.joinedAt = protoInt64.zero, this.name = \"\", this.version = 0, this.region = \"\", this.isPublisher = !1, this.kind = ParticipantInfo_Kind.STANDARD, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new ParticipantInfo().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new ParticipantInfo().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new ParticipantInfo().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(ParticipantInfo, u, c);\n  }\n}\nParticipantInfo.runtime = proto3;\nParticipantInfo.typeName = \"livekit.ParticipantInfo\";\nParticipantInfo.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"identity\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"state\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ParticipantInfo_State)\n}, {\n  no: 4,\n  name: \"tracks\",\n  kind: \"message\",\n  T: TrackInfo,\n  repeated: !0\n}, {\n  no: 5,\n  name: \"metadata\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 6,\n  name: \"joined_at\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 9,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 10,\n  name: \"version\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 11,\n  name: \"permission\",\n  kind: \"message\",\n  T: ParticipantPermission\n}, {\n  no: 12,\n  name: \"region\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 13,\n  name: \"is_publisher\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 14,\n  name: \"kind\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ParticipantInfo_Kind)\n}]);\nvar ParticipantInfo_State;\n(function(a) {\n  a[a.JOINING = 0] = \"JOINING\", a[a.JOINED = 1] = \"JOINED\", a[a.ACTIVE = 2] = \"ACTIVE\", a[a.DISCONNECTED = 3] = \"DISCONNECTED\";\n})(ParticipantInfo_State || (ParticipantInfo_State = {}));\nproto3.util.setEnumType(ParticipantInfo_State, \"livekit.ParticipantInfo.State\", [{\n  no: 0,\n  name: \"JOINING\"\n}, {\n  no: 1,\n  name: \"JOINED\"\n}, {\n  no: 2,\n  name: \"ACTIVE\"\n}, {\n  no: 3,\n  name: \"DISCONNECTED\"\n}]);\nvar ParticipantInfo_Kind;\n(function(a) {\n  a[a.STANDARD = 0] = \"STANDARD\", a[a.INGRESS = 1] = \"INGRESS\", a[a.EGRESS = 2] = \"EGRESS\", a[a.SIP = 3] = \"SIP\", a[a.AGENT = 4] = \"AGENT\";\n})(ParticipantInfo_Kind || (ParticipantInfo_Kind = {}));\nproto3.util.setEnumType(ParticipantInfo_Kind, \"livekit.ParticipantInfo.Kind\", [{\n  no: 0,\n  name: \"STANDARD\"\n}, {\n  no: 1,\n  name: \"INGRESS\"\n}, {\n  no: 2,\n  name: \"EGRESS\"\n}, {\n  no: 3,\n  name: \"SIP\"\n}, {\n  no: 4,\n  name: \"AGENT\"\n}]);\nclass Encryption extends Message {\n  constructor(u) {\n    super(), proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new Encryption().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new Encryption().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new Encryption().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(Encryption, u, c);\n  }\n}\nEncryption.runtime = proto3;\nEncryption.typeName = \"livekit.Encryption\";\nEncryption.fields = proto3.util.newFieldList(() => []);\nvar Encryption_Type;\n(function(a) {\n  a[a.NONE = 0] = \"NONE\", a[a.GCM = 1] = \"GCM\", a[a.CUSTOM = 2] = \"CUSTOM\";\n})(Encryption_Type || (Encryption_Type = {}));\nproto3.util.setEnumType(Encryption_Type, \"livekit.Encryption.Type\", [{\n  no: 0,\n  name: \"NONE\"\n}, {\n  no: 1,\n  name: \"GCM\"\n}, {\n  no: 2,\n  name: \"CUSTOM\"\n}]);\nclass SimulcastCodecInfo extends Message {\n  constructor(u) {\n    super(), this.mimeType = \"\", this.mid = \"\", this.cid = \"\", this.layers = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new SimulcastCodecInfo().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new SimulcastCodecInfo().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new SimulcastCodecInfo().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(SimulcastCodecInfo, u, c);\n  }\n}\nSimulcastCodecInfo.runtime = proto3;\nSimulcastCodecInfo.typeName = \"livekit.SimulcastCodecInfo\";\nSimulcastCodecInfo.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"mime_type\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"mid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"cid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"layers\",\n  kind: \"message\",\n  T: VideoLayer,\n  repeated: !0\n}]);\nclass TrackInfo extends Message {\n  constructor(u) {\n    super(), this.sid = \"\", this.type = TrackType.AUDIO, this.name = \"\", this.muted = !1, this.width = 0, this.height = 0, this.simulcast = !1, this.disableDtx = !1, this.source = TrackSource.UNKNOWN, this.layers = [], this.mimeType = \"\", this.mid = \"\", this.codecs = [], this.stereo = !1, this.disableRed = !1, this.encryption = Encryption_Type.NONE, this.stream = \"\", proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new TrackInfo().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new TrackInfo().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new TrackInfo().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(TrackInfo, u, c);\n  }\n}\nTrackInfo.runtime = proto3;\nTrackInfo.typeName = \"livekit.TrackInfo\";\nTrackInfo.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"type\",\n  kind: \"enum\",\n  T: proto3.getEnumType(TrackType)\n}, {\n  no: 3,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 4,\n  name: \"muted\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 5,\n  name: \"width\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 6,\n  name: \"height\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 7,\n  name: \"simulcast\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 8,\n  name: \"disable_dtx\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 9,\n  name: \"source\",\n  kind: \"enum\",\n  T: proto3.getEnumType(TrackSource)\n}, {\n  no: 10,\n  name: \"layers\",\n  kind: \"message\",\n  T: VideoLayer,\n  repeated: !0\n}, {\n  no: 11,\n  name: \"mime_type\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 12,\n  name: \"mid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 13,\n  name: \"codecs\",\n  kind: \"message\",\n  T: SimulcastCodecInfo,\n  repeated: !0\n}, {\n  no: 14,\n  name: \"stereo\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 15,\n  name: \"disable_red\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 16,\n  name: \"encryption\",\n  kind: \"enum\",\n  T: proto3.getEnumType(Encryption_Type)\n}, {\n  no: 17,\n  name: \"stream\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 18,\n  name: \"version\",\n  kind: \"message\",\n  T: TimedVersion\n}]);\nclass VideoLayer extends Message {\n  constructor(u) {\n    super(), this.quality = VideoQuality$1.LOW, this.width = 0, this.height = 0, this.bitrate = 0, this.ssrc = 0, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new VideoLayer().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new VideoLayer().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new VideoLayer().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(VideoLayer, u, c);\n  }\n}\nVideoLayer.runtime = proto3;\nVideoLayer.typeName = \"livekit.VideoLayer\";\nVideoLayer.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"quality\",\n  kind: \"enum\",\n  T: proto3.getEnumType(VideoQuality$1)\n}, {\n  no: 2,\n  name: \"width\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 3,\n  name: \"height\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 4,\n  name: \"bitrate\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 5,\n  name: \"ssrc\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nclass DataPacket extends Message {\n  constructor(u) {\n    super(), this.kind = DataPacket_Kind.RELIABLE, this.value = {\n      case: void 0\n    }, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new DataPacket().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new DataPacket().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new DataPacket().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(DataPacket, u, c);\n  }\n}\nDataPacket.runtime = proto3;\nDataPacket.typeName = \"livekit.DataPacket\";\nDataPacket.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"kind\",\n  kind: \"enum\",\n  T: proto3.getEnumType(DataPacket_Kind)\n}, {\n  no: 2,\n  name: \"user\",\n  kind: \"message\",\n  T: UserPacket,\n  oneof: \"value\"\n}, {\n  no: 3,\n  name: \"speaker\",\n  kind: \"message\",\n  T: ActiveSpeakerUpdate,\n  oneof: \"value\"\n}]);\nvar DataPacket_Kind;\n(function(a) {\n  a[a.RELIABLE = 0] = \"RELIABLE\", a[a.LOSSY = 1] = \"LOSSY\";\n})(DataPacket_Kind || (DataPacket_Kind = {}));\nproto3.util.setEnumType(DataPacket_Kind, \"livekit.DataPacket.Kind\", [{\n  no: 0,\n  name: \"RELIABLE\"\n}, {\n  no: 1,\n  name: \"LOSSY\"\n}]);\nclass ActiveSpeakerUpdate extends Message {\n  constructor(u) {\n    super(), this.speakers = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new ActiveSpeakerUpdate().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new ActiveSpeakerUpdate().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new ActiveSpeakerUpdate().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(ActiveSpeakerUpdate, u, c);\n  }\n}\nActiveSpeakerUpdate.runtime = proto3;\nActiveSpeakerUpdate.typeName = \"livekit.ActiveSpeakerUpdate\";\nActiveSpeakerUpdate.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"speakers\",\n  kind: \"message\",\n  T: SpeakerInfo,\n  repeated: !0\n}]);\nclass SpeakerInfo extends Message {\n  constructor(u) {\n    super(), this.sid = \"\", this.level = 0, this.active = !1, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new SpeakerInfo().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new SpeakerInfo().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new SpeakerInfo().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(SpeakerInfo, u, c);\n  }\n}\nSpeakerInfo.runtime = proto3;\nSpeakerInfo.typeName = \"livekit.SpeakerInfo\";\nSpeakerInfo.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"level\",\n  kind: \"scalar\",\n  T: 2\n  /* ScalarType.FLOAT */\n}, {\n  no: 3,\n  name: \"active\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nclass UserPacket extends Message {\n  constructor(u) {\n    super(), this.participantSid = \"\", this.participantIdentity = \"\", this.payload = new Uint8Array(0), this.destinationSids = [], this.destinationIdentities = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new UserPacket().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new UserPacket().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new UserPacket().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(UserPacket, u, c);\n  }\n}\nUserPacket.runtime = proto3;\nUserPacket.typeName = \"livekit.UserPacket\";\nUserPacket.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"participant_identity\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"payload\",\n  kind: \"scalar\",\n  T: 12\n  /* ScalarType.BYTES */\n}, {\n  no: 3,\n  name: \"destination_sids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: !0\n}, {\n  no: 6,\n  name: \"destination_identities\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: !0\n}, {\n  no: 4,\n  name: \"topic\",\n  kind: \"scalar\",\n  T: 9,\n  opt: !0\n}]);\nclass ParticipantTracks extends Message {\n  constructor(u) {\n    super(), this.participantSid = \"\", this.trackSids = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new ParticipantTracks().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new ParticipantTracks().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new ParticipantTracks().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(ParticipantTracks, u, c);\n  }\n}\nParticipantTracks.runtime = proto3;\nParticipantTracks.typeName = \"livekit.ParticipantTracks\";\nParticipantTracks.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"track_sids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: !0\n}]);\nclass ServerInfo extends Message {\n  constructor(u) {\n    super(), this.edition = ServerInfo_Edition.Standard, this.version = \"\", this.protocol = 0, this.region = \"\", this.nodeId = \"\", this.debugInfo = \"\", proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new ServerInfo().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new ServerInfo().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new ServerInfo().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(ServerInfo, u, c);\n  }\n}\nServerInfo.runtime = proto3;\nServerInfo.typeName = \"livekit.ServerInfo\";\nServerInfo.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"edition\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ServerInfo_Edition)\n}, {\n  no: 2,\n  name: \"version\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"protocol\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 4,\n  name: \"region\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"node_id\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 6,\n  name: \"debug_info\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nvar ServerInfo_Edition;\n(function(a) {\n  a[a.Standard = 0] = \"Standard\", a[a.Cloud = 1] = \"Cloud\";\n})(ServerInfo_Edition || (ServerInfo_Edition = {}));\nproto3.util.setEnumType(ServerInfo_Edition, \"livekit.ServerInfo.Edition\", [{\n  no: 0,\n  name: \"Standard\"\n}, {\n  no: 1,\n  name: \"Cloud\"\n}]);\nclass ClientInfo extends Message {\n  constructor(u) {\n    super(), this.sdk = ClientInfo_SDK.UNKNOWN, this.version = \"\", this.protocol = 0, this.os = \"\", this.osVersion = \"\", this.deviceModel = \"\", this.browser = \"\", this.browserVersion = \"\", this.address = \"\", this.network = \"\", proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new ClientInfo().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new ClientInfo().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new ClientInfo().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(ClientInfo, u, c);\n  }\n}\nClientInfo.runtime = proto3;\nClientInfo.typeName = \"livekit.ClientInfo\";\nClientInfo.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"sdk\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ClientInfo_SDK)\n}, {\n  no: 2,\n  name: \"version\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"protocol\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 4,\n  name: \"os\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"os_version\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 6,\n  name: \"device_model\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 7,\n  name: \"browser\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 8,\n  name: \"browser_version\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 9,\n  name: \"address\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 10,\n  name: \"network\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nvar ClientInfo_SDK;\n(function(a) {\n  a[a.UNKNOWN = 0] = \"UNKNOWN\", a[a.JS = 1] = \"JS\", a[a.SWIFT = 2] = \"SWIFT\", a[a.ANDROID = 3] = \"ANDROID\", a[a.FLUTTER = 4] = \"FLUTTER\", a[a.GO = 5] = \"GO\", a[a.UNITY = 6] = \"UNITY\", a[a.REACT_NATIVE = 7] = \"REACT_NATIVE\", a[a.RUST = 8] = \"RUST\", a[a.PYTHON = 9] = \"PYTHON\", a[a.CPP = 10] = \"CPP\";\n})(ClientInfo_SDK || (ClientInfo_SDK = {}));\nproto3.util.setEnumType(ClientInfo_SDK, \"livekit.ClientInfo.SDK\", [{\n  no: 0,\n  name: \"UNKNOWN\"\n}, {\n  no: 1,\n  name: \"JS\"\n}, {\n  no: 2,\n  name: \"SWIFT\"\n}, {\n  no: 3,\n  name: \"ANDROID\"\n}, {\n  no: 4,\n  name: \"FLUTTER\"\n}, {\n  no: 5,\n  name: \"GO\"\n}, {\n  no: 6,\n  name: \"UNITY\"\n}, {\n  no: 7,\n  name: \"REACT_NATIVE\"\n}, {\n  no: 8,\n  name: \"RUST\"\n}, {\n  no: 9,\n  name: \"PYTHON\"\n}, {\n  no: 10,\n  name: \"CPP\"\n}]);\nclass ClientConfiguration extends Message {\n  constructor(u) {\n    super(), this.resumeConnection = ClientConfigSetting.UNSET, this.forceRelay = ClientConfigSetting.UNSET, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new ClientConfiguration().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new ClientConfiguration().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new ClientConfiguration().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(ClientConfiguration, u, c);\n  }\n}\nClientConfiguration.runtime = proto3;\nClientConfiguration.typeName = \"livekit.ClientConfiguration\";\nClientConfiguration.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"video\",\n  kind: \"message\",\n  T: VideoConfiguration\n}, {\n  no: 2,\n  name: \"screen\",\n  kind: \"message\",\n  T: VideoConfiguration\n}, {\n  no: 3,\n  name: \"resume_connection\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ClientConfigSetting)\n}, {\n  no: 4,\n  name: \"disabled_codecs\",\n  kind: \"message\",\n  T: DisabledCodecs\n}, {\n  no: 5,\n  name: \"force_relay\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ClientConfigSetting)\n}]);\nclass VideoConfiguration extends Message {\n  constructor(u) {\n    super(), this.hardwareEncoder = ClientConfigSetting.UNSET, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new VideoConfiguration().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new VideoConfiguration().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new VideoConfiguration().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(VideoConfiguration, u, c);\n  }\n}\nVideoConfiguration.runtime = proto3;\nVideoConfiguration.typeName = \"livekit.VideoConfiguration\";\nVideoConfiguration.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"hardware_encoder\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ClientConfigSetting)\n}]);\nclass DisabledCodecs extends Message {\n  constructor(u) {\n    super(), this.codecs = [], this.publish = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new DisabledCodecs().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new DisabledCodecs().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new DisabledCodecs().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(DisabledCodecs, u, c);\n  }\n}\nDisabledCodecs.runtime = proto3;\nDisabledCodecs.typeName = \"livekit.DisabledCodecs\";\nDisabledCodecs.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"codecs\",\n  kind: \"message\",\n  T: Codec,\n  repeated: !0\n}, {\n  no: 2,\n  name: \"publish\",\n  kind: \"message\",\n  T: Codec,\n  repeated: !0\n}]);\nclass RTPDrift extends Message {\n  constructor(u) {\n    super(), this.duration = 0, this.startTimestamp = protoInt64.zero, this.endTimestamp = protoInt64.zero, this.rtpClockTicks = protoInt64.zero, this.driftSamples = protoInt64.zero, this.driftMs = 0, this.clockRate = 0, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new RTPDrift().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new RTPDrift().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new RTPDrift().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(RTPDrift, u, c);\n  }\n}\nRTPDrift.runtime = proto3;\nRTPDrift.typeName = \"livekit.RTPDrift\";\nRTPDrift.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"start_time\",\n  kind: \"message\",\n  T: Timestamp\n}, {\n  no: 2,\n  name: \"end_time\",\n  kind: \"message\",\n  T: Timestamp\n}, {\n  no: 3,\n  name: \"duration\",\n  kind: \"scalar\",\n  T: 1\n  /* ScalarType.DOUBLE */\n}, {\n  no: 4,\n  name: \"start_timestamp\",\n  kind: \"scalar\",\n  T: 4\n  /* ScalarType.UINT64 */\n}, {\n  no: 5,\n  name: \"end_timestamp\",\n  kind: \"scalar\",\n  T: 4\n  /* ScalarType.UINT64 */\n}, {\n  no: 6,\n  name: \"rtp_clock_ticks\",\n  kind: \"scalar\",\n  T: 4\n  /* ScalarType.UINT64 */\n}, {\n  no: 7,\n  name: \"drift_samples\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 8,\n  name: \"drift_ms\",\n  kind: \"scalar\",\n  T: 1\n  /* ScalarType.DOUBLE */\n}, {\n  no: 9,\n  name: \"clock_rate\",\n  kind: \"scalar\",\n  T: 1\n  /* ScalarType.DOUBLE */\n}]);\nclass RTPStats extends Message {\n  constructor(u) {\n    super(), this.duration = 0, this.packets = 0, this.packetRate = 0, this.bytes = protoInt64.zero, this.headerBytes = protoInt64.zero, this.bitrate = 0, this.packetsLost = 0, this.packetLossRate = 0, this.packetLossPercentage = 0, this.packetsDuplicate = 0, this.packetDuplicateRate = 0, this.bytesDuplicate = protoInt64.zero, this.headerBytesDuplicate = protoInt64.zero, this.bitrateDuplicate = 0, this.packetsPadding = 0, this.packetPaddingRate = 0, this.bytesPadding = protoInt64.zero, this.headerBytesPadding = protoInt64.zero, this.bitratePadding = 0, this.packetsOutOfOrder = 0, this.frames = 0, this.frameRate = 0, this.jitterCurrent = 0, this.jitterMax = 0, this.gapHistogram = {}, this.nacks = 0, this.nackAcks = 0, this.nackMisses = 0, this.nackRepeated = 0, this.plis = 0, this.firs = 0, this.rttCurrent = 0, this.rttMax = 0, this.keyFrames = 0, this.layerLockPlis = 0, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new RTPStats().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new RTPStats().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new RTPStats().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(RTPStats, u, c);\n  }\n}\nRTPStats.runtime = proto3;\nRTPStats.typeName = \"livekit.RTPStats\";\nRTPStats.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"start_time\",\n  kind: \"message\",\n  T: Timestamp\n}, {\n  no: 2,\n  name: \"end_time\",\n  kind: \"message\",\n  T: Timestamp\n}, {\n  no: 3,\n  name: \"duration\",\n  kind: \"scalar\",\n  T: 1\n  /* ScalarType.DOUBLE */\n}, {\n  no: 4,\n  name: \"packets\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 5,\n  name: \"packet_rate\",\n  kind: \"scalar\",\n  T: 1\n  /* ScalarType.DOUBLE */\n}, {\n  no: 6,\n  name: \"bytes\",\n  kind: \"scalar\",\n  T: 4\n  /* ScalarType.UINT64 */\n}, {\n  no: 39,\n  name: \"header_bytes\",\n  kind: \"scalar\",\n  T: 4\n  /* ScalarType.UINT64 */\n}, {\n  no: 7,\n  name: \"bitrate\",\n  kind: \"scalar\",\n  T: 1\n  /* ScalarType.DOUBLE */\n}, {\n  no: 8,\n  name: \"packets_lost\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 9,\n  name: \"packet_loss_rate\",\n  kind: \"scalar\",\n  T: 1\n  /* ScalarType.DOUBLE */\n}, {\n  no: 10,\n  name: \"packet_loss_percentage\",\n  kind: \"scalar\",\n  T: 2\n  /* ScalarType.FLOAT */\n}, {\n  no: 11,\n  name: \"packets_duplicate\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 12,\n  name: \"packet_duplicate_rate\",\n  kind: \"scalar\",\n  T: 1\n  /* ScalarType.DOUBLE */\n}, {\n  no: 13,\n  name: \"bytes_duplicate\",\n  kind: \"scalar\",\n  T: 4\n  /* ScalarType.UINT64 */\n}, {\n  no: 40,\n  name: \"header_bytes_duplicate\",\n  kind: \"scalar\",\n  T: 4\n  /* ScalarType.UINT64 */\n}, {\n  no: 14,\n  name: \"bitrate_duplicate\",\n  kind: \"scalar\",\n  T: 1\n  /* ScalarType.DOUBLE */\n}, {\n  no: 15,\n  name: \"packets_padding\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 16,\n  name: \"packet_padding_rate\",\n  kind: \"scalar\",\n  T: 1\n  /* ScalarType.DOUBLE */\n}, {\n  no: 17,\n  name: \"bytes_padding\",\n  kind: \"scalar\",\n  T: 4\n  /* ScalarType.UINT64 */\n}, {\n  no: 41,\n  name: \"header_bytes_padding\",\n  kind: \"scalar\",\n  T: 4\n  /* ScalarType.UINT64 */\n}, {\n  no: 18,\n  name: \"bitrate_padding\",\n  kind: \"scalar\",\n  T: 1\n  /* ScalarType.DOUBLE */\n}, {\n  no: 19,\n  name: \"packets_out_of_order\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 20,\n  name: \"frames\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 21,\n  name: \"frame_rate\",\n  kind: \"scalar\",\n  T: 1\n  /* ScalarType.DOUBLE */\n}, {\n  no: 22,\n  name: \"jitter_current\",\n  kind: \"scalar\",\n  T: 1\n  /* ScalarType.DOUBLE */\n}, {\n  no: 23,\n  name: \"jitter_max\",\n  kind: \"scalar\",\n  T: 1\n  /* ScalarType.DOUBLE */\n}, {\n  no: 24,\n  name: \"gap_histogram\",\n  kind: \"map\",\n  K: 5,\n  V: {\n    kind: \"scalar\",\n    T: 13\n    /* ScalarType.UINT32 */\n  }\n}, {\n  no: 25,\n  name: \"nacks\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 37,\n  name: \"nack_acks\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 26,\n  name: \"nack_misses\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 38,\n  name: \"nack_repeated\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 27,\n  name: \"plis\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 28,\n  name: \"last_pli\",\n  kind: \"message\",\n  T: Timestamp\n}, {\n  no: 29,\n  name: \"firs\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 30,\n  name: \"last_fir\",\n  kind: \"message\",\n  T: Timestamp\n}, {\n  no: 31,\n  name: \"rtt_current\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 32,\n  name: \"rtt_max\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 33,\n  name: \"key_frames\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 34,\n  name: \"last_key_frame\",\n  kind: \"message\",\n  T: Timestamp\n}, {\n  no: 35,\n  name: \"layer_lock_plis\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 36,\n  name: \"last_layer_lock_pli\",\n  kind: \"message\",\n  T: Timestamp\n}, {\n  no: 44,\n  name: \"packet_drift\",\n  kind: \"message\",\n  T: RTPDrift\n}, {\n  no: 45,\n  name: \"report_drift\",\n  kind: \"message\",\n  T: RTPDrift\n}]);\nclass TimedVersion extends Message {\n  constructor(u) {\n    super(), this.unixMicro = protoInt64.zero, this.ticks = 0, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new TimedVersion().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new TimedVersion().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new TimedVersion().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(TimedVersion, u, c);\n  }\n}\nTimedVersion.runtime = proto3;\nTimedVersion.typeName = \"livekit.TimedVersion\";\nTimedVersion.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"unix_micro\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 2,\n  name: \"ticks\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}]);\nconst maxRetryDelay = 7e3, DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];\nclass DefaultReconnectPolicy {\n  constructor(u) {\n    this._retryDelays = u !== void 0 ? [...u] : DEFAULT_RETRY_DELAYS_IN_MS;\n  }\n  nextRetryDelayInMs(u) {\n    if (u.retryCount >= this._retryDelays.length)\n      return null;\n    const c = this._retryDelays[u.retryCount];\n    return u.retryCount <= 1 ? c : c + Math.random() * 1e3;\n  }\n}\nfunction __awaiter(a, u, c, l) {\n  function v(S) {\n    return S instanceof c ? S : new c(function(g) {\n      g(S);\n    });\n  }\n  return new (c || (c = Promise))(function(S, g) {\n    function E(L) {\n      try {\n        k(l.next(L));\n      } catch (M) {\n        g(M);\n      }\n    }\n    function _(L) {\n      try {\n        k(l.throw(L));\n      } catch (M) {\n        g(M);\n      }\n    }\n    function k(L) {\n      L.done ? S(L.value) : v(L.value).then(E, _);\n    }\n    k((l = l.apply(a, u || [])).next());\n  });\n}\nfunction __values(a) {\n  var u = typeof Symbol == \"function\" && Symbol.iterator, c = u && a[u], l = 0;\n  if (c)\n    return c.call(a);\n  if (a && typeof a.length == \"number\")\n    return {\n      next: function() {\n        return a && l >= a.length && (a = void 0), { value: a && a[l++], done: !a };\n      }\n    };\n  throw new TypeError(u ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __asyncValues(a) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var u = a[Symbol.asyncIterator], c;\n  return u ? u.call(a) : (a = typeof __values == \"function\" ? __values(a) : a[Symbol.iterator](), c = {}, l(\"next\"), l(\"throw\"), l(\"return\"), c[Symbol.asyncIterator] = function() {\n    return this;\n  }, c);\n  function l(S) {\n    c[S] = a[S] && function(g) {\n      return new Promise(function(E, _) {\n        g = a[S](g), v(E, _, g.done, g.value);\n      });\n    };\n  }\n  function v(S, g, E, _) {\n    Promise.resolve(_).then(function(k) {\n      S({ value: k, done: E });\n    }, g);\n  }\n}\ntypeof SuppressedError == \"function\" && SuppressedError;\nvar events = { exports: {} }, R = typeof Reflect == \"object\" ? Reflect : null, ReflectApply = R && typeof R.apply == \"function\" ? R.apply : function a(u, c, l) {\n  return Function.prototype.apply.call(u, c, l);\n}, ReflectOwnKeys;\nR && typeof R.ownKeys == \"function\" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(u) {\n  return Object.getOwnPropertyNames(u).concat(Object.getOwnPropertySymbols(u));\n} : ReflectOwnKeys = function(u) {\n  return Object.getOwnPropertyNames(u);\n};\nfunction ProcessEmitWarning(a) {\n  console && console.warn && console.warn(a);\n}\nvar NumberIsNaN = Number.isNaN || function a(u) {\n  return u !== u;\n};\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nevents.exports = EventEmitter;\nevents.exports.once = once;\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = void 0;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = void 0;\nvar defaultMaxListeners = 10;\nfunction checkListener(a) {\n  if (typeof a != \"function\")\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof a);\n}\nObject.defineProperty(EventEmitter, \"defaultMaxListeners\", {\n  enumerable: !0,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(a) {\n    if (typeof a != \"number\" || a < 0 || NumberIsNaN(a))\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + a + \".\");\n    defaultMaxListeners = a;\n  }\n});\nEventEmitter.init = function() {\n  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;\n};\nEventEmitter.prototype.setMaxListeners = function a(u) {\n  if (typeof u != \"number\" || u < 0 || NumberIsNaN(u))\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + u + \".\");\n  return this._maxListeners = u, this;\n};\nfunction _getMaxListeners(a) {\n  return a._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : a._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function a() {\n  return _getMaxListeners(this);\n};\nEventEmitter.prototype.emit = function a(u) {\n  for (var c = [], l = 1; l < arguments.length; l++)\n    c.push(arguments[l]);\n  var v = u === \"error\", S = this._events;\n  if (S !== void 0)\n    v = v && S.error === void 0;\n  else if (!v)\n    return !1;\n  if (v) {\n    var g;\n    if (c.length > 0 && (g = c[0]), g instanceof Error)\n      throw g;\n    var E = new Error(\"Unhandled error.\" + (g ? \" (\" + g.message + \")\" : \"\"));\n    throw E.context = g, E;\n  }\n  var _ = S[u];\n  if (_ === void 0)\n    return !1;\n  if (typeof _ == \"function\")\n    ReflectApply(_, this, c);\n  else\n    for (var k = _.length, L = arrayClone(_, k), l = 0; l < k; ++l)\n      ReflectApply(L[l], this, c);\n  return !0;\n};\nfunction _addListener(a, u, c, l) {\n  var v, S, g;\n  if (checkListener(c), S = a._events, S === void 0 ? (S = a._events = /* @__PURE__ */ Object.create(null), a._eventsCount = 0) : (S.newListener !== void 0 && (a.emit(\"newListener\", u, c.listener ? c.listener : c), S = a._events), g = S[u]), g === void 0)\n    g = S[u] = c, ++a._eventsCount;\n  else if (typeof g == \"function\" ? g = S[u] = l ? [c, g] : [g, c] : l ? g.unshift(c) : g.push(c), v = _getMaxListeners(a), v > 0 && g.length > v && !g.warned) {\n    g.warned = !0;\n    var E = new Error(\"Possible EventEmitter memory leak detected. \" + g.length + \" \" + String(u) + \" listeners added. Use emitter.setMaxListeners() to increase limit\");\n    E.name = \"MaxListenersExceededWarning\", E.emitter = a, E.type = u, E.count = g.length, ProcessEmitWarning(E);\n  }\n  return a;\n}\nEventEmitter.prototype.addListener = function a(u, c) {\n  return _addListener(this, u, c, !1);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function a(u, c) {\n  return _addListener(this, u, c, !0);\n};\nfunction onceWrapper() {\n  if (!this.fired)\n    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);\n}\nfunction _onceWrap(a, u, c) {\n  var l = {\n    fired: !1,\n    wrapFn: void 0,\n    target: a,\n    type: u,\n    listener: c\n  }, v = onceWrapper.bind(l);\n  return v.listener = c, l.wrapFn = v, v;\n}\nEventEmitter.prototype.once = function a(u, c) {\n  return checkListener(c), this.on(u, _onceWrap(this, u, c)), this;\n};\nEventEmitter.prototype.prependOnceListener = function a(u, c) {\n  return checkListener(c), this.prependListener(u, _onceWrap(this, u, c)), this;\n};\nEventEmitter.prototype.removeListener = function a(u, c) {\n  var l, v, S, g, E;\n  if (checkListener(c), v = this._events, v === void 0)\n    return this;\n  if (l = v[u], l === void 0)\n    return this;\n  if (l === c || l.listener === c)\n    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete v[u], v.removeListener && this.emit(\"removeListener\", u, l.listener || c));\n  else if (typeof l != \"function\") {\n    for (S = -1, g = l.length - 1; g >= 0; g--)\n      if (l[g] === c || l[g].listener === c) {\n        E = l[g].listener, S = g;\n        break;\n      }\n    if (S < 0)\n      return this;\n    S === 0 ? l.shift() : spliceOne(l, S), l.length === 1 && (v[u] = l[0]), v.removeListener !== void 0 && this.emit(\"removeListener\", u, E || c);\n  }\n  return this;\n};\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.removeAllListeners = function a(u) {\n  var c, l, v;\n  if (l = this._events, l === void 0)\n    return this;\n  if (l.removeListener === void 0)\n    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : l[u] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete l[u]), this;\n  if (arguments.length === 0) {\n    var S = Object.keys(l), g;\n    for (v = 0; v < S.length; ++v)\n      g = S[v], g !== \"removeListener\" && this.removeAllListeners(g);\n    return this.removeAllListeners(\"removeListener\"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;\n  }\n  if (c = l[u], typeof c == \"function\")\n    this.removeListener(u, c);\n  else if (c !== void 0)\n    for (v = c.length - 1; v >= 0; v--)\n      this.removeListener(u, c[v]);\n  return this;\n};\nfunction _listeners(a, u, c) {\n  var l = a._events;\n  if (l === void 0)\n    return [];\n  var v = l[u];\n  return v === void 0 ? [] : typeof v == \"function\" ? c ? [v.listener || v] : [v] : c ? unwrapListeners(v) : arrayClone(v, v.length);\n}\nEventEmitter.prototype.listeners = function a(u) {\n  return _listeners(this, u, !0);\n};\nEventEmitter.prototype.rawListeners = function a(u) {\n  return _listeners(this, u, !1);\n};\nEventEmitter.listenerCount = function(a, u) {\n  return typeof a.listenerCount == \"function\" ? a.listenerCount(u) : listenerCount.call(a, u);\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(a) {\n  var u = this._events;\n  if (u !== void 0) {\n    var c = u[a];\n    if (typeof c == \"function\")\n      return 1;\n    if (c !== void 0)\n      return c.length;\n  }\n  return 0;\n}\nEventEmitter.prototype.eventNames = function a() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\nfunction arrayClone(a, u) {\n  for (var c = new Array(u), l = 0; l < u; ++l)\n    c[l] = a[l];\n  return c;\n}\nfunction spliceOne(a, u) {\n  for (; u + 1 < a.length; u++)\n    a[u] = a[u + 1];\n  a.pop();\n}\nfunction unwrapListeners(a) {\n  for (var u = new Array(a.length), c = 0; c < u.length; ++c)\n    u[c] = a[c].listener || a[c];\n  return u;\n}\nfunction once(a, u) {\n  return new Promise(function(c, l) {\n    function v(g) {\n      a.removeListener(u, S), l(g);\n    }\n    function S() {\n      typeof a.removeListener == \"function\" && a.removeListener(\"error\", v), c([].slice.call(arguments));\n    }\n    eventTargetAgnosticAddListener(a, u, S, {\n      once: !0\n    }), u !== \"error\" && addErrorHandlerIfEventEmitter(a, v, {\n      once: !0\n    });\n  });\n}\nfunction addErrorHandlerIfEventEmitter(a, u, c) {\n  typeof a.on == \"function\" && eventTargetAgnosticAddListener(a, \"error\", u, c);\n}\nfunction eventTargetAgnosticAddListener(a, u, c, l) {\n  if (typeof a.on == \"function\")\n    l.once ? a.once(u, c) : a.on(u, c);\n  else if (typeof a.addEventListener == \"function\")\n    a.addEventListener(u, function v(S) {\n      l.once && a.removeEventListener(u, v), c(S);\n    });\n  else\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof a);\n}\nvar eventsExports = events.exports;\nlet logDisabled_ = !0, deprecationWarnings_ = !0;\nfunction extractVersion(a, u, c) {\n  const l = a.match(u);\n  return l && l.length >= c && parseInt(l[c], 10);\n}\nfunction wrapPeerConnectionEvent(a, u, c) {\n  if (!a.RTCPeerConnection)\n    return;\n  const l = a.RTCPeerConnection.prototype, v = l.addEventListener;\n  l.addEventListener = function(g, E) {\n    if (g !== u)\n      return v.apply(this, arguments);\n    const _ = (k) => {\n      const L = c(k);\n      L && (E.handleEvent ? E.handleEvent(L) : E(L));\n    };\n    return this._eventMap = this._eventMap || {}, this._eventMap[u] || (this._eventMap[u] = /* @__PURE__ */ new Map()), this._eventMap[u].set(E, _), v.apply(this, [g, _]);\n  };\n  const S = l.removeEventListener;\n  l.removeEventListener = function(g, E) {\n    if (g !== u || !this._eventMap || !this._eventMap[u])\n      return S.apply(this, arguments);\n    if (!this._eventMap[u].has(E))\n      return S.apply(this, arguments);\n    const _ = this._eventMap[u].get(E);\n    return this._eventMap[u].delete(E), this._eventMap[u].size === 0 && delete this._eventMap[u], Object.keys(this._eventMap).length === 0 && delete this._eventMap, S.apply(this, [g, _]);\n  }, Object.defineProperty(l, \"on\" + u, {\n    get() {\n      return this[\"_on\" + u];\n    },\n    set(g) {\n      this[\"_on\" + u] && (this.removeEventListener(u, this[\"_on\" + u]), delete this[\"_on\" + u]), g && this.addEventListener(u, this[\"_on\" + u] = g);\n    },\n    enumerable: !0,\n    configurable: !0\n  });\n}\nfunction disableLog(a) {\n  return typeof a != \"boolean\" ? new Error(\"Argument type: \" + typeof a + \". Please use a boolean.\") : (logDisabled_ = a, a ? \"adapter.js logging disabled\" : \"adapter.js logging enabled\");\n}\nfunction disableWarnings(a) {\n  return typeof a != \"boolean\" ? new Error(\"Argument type: \" + typeof a + \". Please use a boolean.\") : (deprecationWarnings_ = !a, \"adapter.js deprecation warnings \" + (a ? \"disabled\" : \"enabled\"));\n}\nfunction log() {\n  if (typeof window == \"object\") {\n    if (logDisabled_)\n      return;\n    typeof console < \"u\" && typeof console.log == \"function\" && console.log.apply(console, arguments);\n  }\n}\nfunction deprecated(a, u) {\n  deprecationWarnings_ && console.warn(a + \" is deprecated, please use \" + u + \" instead.\");\n}\nfunction detectBrowser(a) {\n  const u = {\n    browser: null,\n    version: null\n  };\n  if (typeof a > \"u\" || !a.navigator || !a.navigator.userAgent)\n    return u.browser = \"Not a browser.\", u;\n  const {\n    navigator: c\n  } = a;\n  if (c.mozGetUserMedia)\n    u.browser = \"firefox\", u.version = extractVersion(c.userAgent, /Firefox\\/(\\d+)\\./, 1);\n  else if (c.webkitGetUserMedia || a.isSecureContext === !1 && a.webkitRTCPeerConnection)\n    u.browser = \"chrome\", u.version = extractVersion(c.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n  else if (a.RTCPeerConnection && c.userAgent.match(/AppleWebKit\\/(\\d+)\\./))\n    u.browser = \"safari\", u.version = extractVersion(c.userAgent, /AppleWebKit\\/(\\d+)\\./, 1), u.supportsUnifiedPlan = a.RTCRtpTransceiver && \"currentDirection\" in a.RTCRtpTransceiver.prototype;\n  else\n    return u.browser = \"Not a supported browser.\", u;\n  return u;\n}\nfunction isObject(a) {\n  return Object.prototype.toString.call(a) === \"[object Object]\";\n}\nfunction compactObject(a) {\n  return isObject(a) ? Object.keys(a).reduce(function(u, c) {\n    const l = isObject(a[c]), v = l ? compactObject(a[c]) : a[c], S = l && !Object.keys(v).length;\n    return v === void 0 || S ? u : Object.assign(u, {\n      [c]: v\n    });\n  }, {}) : a;\n}\nfunction walkStats(a, u, c) {\n  !u || c.has(u.id) || (c.set(u.id, u), Object.keys(u).forEach((l) => {\n    l.endsWith(\"Id\") ? walkStats(a, a.get(u[l]), c) : l.endsWith(\"Ids\") && u[l].forEach((v) => {\n      walkStats(a, a.get(v), c);\n    });\n  }));\n}\nfunction filterStats(a, u, c) {\n  const l = c ? \"outbound-rtp\" : \"inbound-rtp\", v = /* @__PURE__ */ new Map();\n  if (u === null)\n    return v;\n  const S = [];\n  return a.forEach((g) => {\n    g.type === \"track\" && g.trackIdentifier === u.id && S.push(g);\n  }), S.forEach((g) => {\n    a.forEach((E) => {\n      E.type === l && E.trackId === g.id && walkStats(a, E, v);\n    });\n  }), v;\n}\nconst logging = log;\nfunction shimGetUserMedia$2(a, u) {\n  const c = a && a.navigator;\n  if (!c.mediaDevices)\n    return;\n  const l = function(E) {\n    if (typeof E != \"object\" || E.mandatory || E.optional)\n      return E;\n    const _ = {};\n    return Object.keys(E).forEach((k) => {\n      if (k === \"require\" || k === \"advanced\" || k === \"mediaSource\")\n        return;\n      const L = typeof E[k] == \"object\" ? E[k] : {\n        ideal: E[k]\n      };\n      L.exact !== void 0 && typeof L.exact == \"number\" && (L.min = L.max = L.exact);\n      const M = function($, J) {\n        return $ ? $ + J.charAt(0).toUpperCase() + J.slice(1) : J === \"deviceId\" ? \"sourceId\" : J;\n      };\n      if (L.ideal !== void 0) {\n        _.optional = _.optional || [];\n        let $ = {};\n        typeof L.ideal == \"number\" ? ($[M(\"min\", k)] = L.ideal, _.optional.push($), $ = {}, $[M(\"max\", k)] = L.ideal, _.optional.push($)) : ($[M(\"\", k)] = L.ideal, _.optional.push($));\n      }\n      L.exact !== void 0 && typeof L.exact != \"number\" ? (_.mandatory = _.mandatory || {}, _.mandatory[M(\"\", k)] = L.exact) : [\"min\", \"max\"].forEach(($) => {\n        L[$] !== void 0 && (_.mandatory = _.mandatory || {}, _.mandatory[M($, k)] = L[$]);\n      });\n    }), E.advanced && (_.optional = (_.optional || []).concat(E.advanced)), _;\n  }, v = function(E, _) {\n    if (u.version >= 61)\n      return _(E);\n    if (E = JSON.parse(JSON.stringify(E)), E && typeof E.audio == \"object\") {\n      const k = function(L, M, $) {\n        M in L && !($ in L) && (L[$] = L[M], delete L[M]);\n      };\n      E = JSON.parse(JSON.stringify(E)), k(E.audio, \"autoGainControl\", \"googAutoGainControl\"), k(E.audio, \"noiseSuppression\", \"googNoiseSuppression\"), E.audio = l(E.audio);\n    }\n    if (E && typeof E.video == \"object\") {\n      let k = E.video.facingMode;\n      k = k && (typeof k == \"object\" ? k : {\n        ideal: k\n      });\n      const L = u.version < 66;\n      if (k && (k.exact === \"user\" || k.exact === \"environment\" || k.ideal === \"user\" || k.ideal === \"environment\") && !(c.mediaDevices.getSupportedConstraints && c.mediaDevices.getSupportedConstraints().facingMode && !L)) {\n        delete E.video.facingMode;\n        let M;\n        if (k.exact === \"environment\" || k.ideal === \"environment\" ? M = [\"back\", \"rear\"] : (k.exact === \"user\" || k.ideal === \"user\") && (M = [\"front\"]), M)\n          return c.mediaDevices.enumerateDevices().then(($) => {\n            $ = $.filter((V) => V.kind === \"videoinput\");\n            let J = $.find((V) => M.some((q) => V.label.toLowerCase().includes(q)));\n            return !J && $.length && M.includes(\"back\") && (J = $[$.length - 1]), J && (E.video.deviceId = k.exact ? {\n              exact: J.deviceId\n            } : {\n              ideal: J.deviceId\n            }), E.video = l(E.video), logging(\"chrome: \" + JSON.stringify(E)), _(E);\n          });\n      }\n      E.video = l(E.video);\n    }\n    return logging(\"chrome: \" + JSON.stringify(E)), _(E);\n  }, S = function(E) {\n    return u.version >= 64 ? E : {\n      name: {\n        PermissionDeniedError: \"NotAllowedError\",\n        PermissionDismissedError: \"NotAllowedError\",\n        InvalidStateError: \"NotAllowedError\",\n        DevicesNotFoundError: \"NotFoundError\",\n        ConstraintNotSatisfiedError: \"OverconstrainedError\",\n        TrackStartError: \"NotReadableError\",\n        MediaDeviceFailedDueToShutdown: \"NotAllowedError\",\n        MediaDeviceKillSwitchOn: \"NotAllowedError\",\n        TabCaptureError: \"AbortError\",\n        ScreenCaptureError: \"AbortError\",\n        DeviceCaptureError: \"AbortError\"\n      }[E.name] || E.name,\n      message: E.message,\n      constraint: E.constraint || E.constraintName,\n      toString() {\n        return this.name + (this.message && \": \") + this.message;\n      }\n    };\n  }, g = function(E, _, k) {\n    v(E, (L) => {\n      c.webkitGetUserMedia(L, _, (M) => {\n        k && k(S(M));\n      });\n    });\n  };\n  if (c.getUserMedia = g.bind(c), c.mediaDevices.getUserMedia) {\n    const E = c.mediaDevices.getUserMedia.bind(c.mediaDevices);\n    c.mediaDevices.getUserMedia = function(_) {\n      return v(_, (k) => E(k).then((L) => {\n        if (k.audio && !L.getAudioTracks().length || k.video && !L.getVideoTracks().length)\n          throw L.getTracks().forEach((M) => {\n            M.stop();\n          }), new DOMException(\"\", \"NotFoundError\");\n        return L;\n      }, (L) => Promise.reject(S(L))));\n    };\n  }\n}\nfunction shimGetDisplayMedia$1(a, u) {\n  if (!(a.navigator.mediaDevices && \"getDisplayMedia\" in a.navigator.mediaDevices) && a.navigator.mediaDevices) {\n    if (typeof u != \"function\") {\n      console.error(\"shimGetDisplayMedia: getSourceId argument is not a function\");\n      return;\n    }\n    a.navigator.mediaDevices.getDisplayMedia = function(l) {\n      return u(l).then((v) => {\n        const S = l.video && l.video.width, g = l.video && l.video.height, E = l.video && l.video.frameRate;\n        return l.video = {\n          mandatory: {\n            chromeMediaSource: \"desktop\",\n            chromeMediaSourceId: v,\n            maxFrameRate: E || 3\n          }\n        }, S && (l.video.mandatory.maxWidth = S), g && (l.video.mandatory.maxHeight = g), a.navigator.mediaDevices.getUserMedia(l);\n      });\n    };\n  }\n}\nfunction shimMediaStream(a) {\n  a.MediaStream = a.MediaStream || a.webkitMediaStream;\n}\nfunction shimOnTrack$1(a) {\n  if (typeof a == \"object\" && a.RTCPeerConnection && !(\"ontrack\" in a.RTCPeerConnection.prototype)) {\n    Object.defineProperty(a.RTCPeerConnection.prototype, \"ontrack\", {\n      get() {\n        return this._ontrack;\n      },\n      set(c) {\n        this._ontrack && this.removeEventListener(\"track\", this._ontrack), this.addEventListener(\"track\", this._ontrack = c);\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n    const u = a.RTCPeerConnection.prototype.setRemoteDescription;\n    a.RTCPeerConnection.prototype.setRemoteDescription = function() {\n      return this._ontrackpoly || (this._ontrackpoly = (l) => {\n        l.stream.addEventListener(\"addtrack\", (v) => {\n          let S;\n          a.RTCPeerConnection.prototype.getReceivers ? S = this.getReceivers().find((E) => E.track && E.track.id === v.track.id) : S = {\n            track: v.track\n          };\n          const g = new Event(\"track\");\n          g.track = v.track, g.receiver = S, g.transceiver = {\n            receiver: S\n          }, g.streams = [l.stream], this.dispatchEvent(g);\n        }), l.stream.getTracks().forEach((v) => {\n          let S;\n          a.RTCPeerConnection.prototype.getReceivers ? S = this.getReceivers().find((E) => E.track && E.track.id === v.id) : S = {\n            track: v\n          };\n          const g = new Event(\"track\");\n          g.track = v, g.receiver = S, g.transceiver = {\n            receiver: S\n          }, g.streams = [l.stream], this.dispatchEvent(g);\n        });\n      }, this.addEventListener(\"addstream\", this._ontrackpoly)), u.apply(this, arguments);\n    };\n  } else\n    wrapPeerConnectionEvent(a, \"track\", (u) => (u.transceiver || Object.defineProperty(u, \"transceiver\", {\n      value: {\n        receiver: u.receiver\n      }\n    }), u));\n}\nfunction shimGetSendersWithDtmf(a) {\n  if (typeof a == \"object\" && a.RTCPeerConnection && !(\"getSenders\" in a.RTCPeerConnection.prototype) && \"createDTMFSender\" in a.RTCPeerConnection.prototype) {\n    const u = function(v, S) {\n      return {\n        track: S,\n        get dtmf() {\n          return this._dtmf === void 0 && (S.kind === \"audio\" ? this._dtmf = v.createDTMFSender(S) : this._dtmf = null), this._dtmf;\n        },\n        _pc: v\n      };\n    };\n    if (!a.RTCPeerConnection.prototype.getSenders) {\n      a.RTCPeerConnection.prototype.getSenders = function() {\n        return this._senders = this._senders || [], this._senders.slice();\n      };\n      const v = a.RTCPeerConnection.prototype.addTrack;\n      a.RTCPeerConnection.prototype.addTrack = function(E, _) {\n        let k = v.apply(this, arguments);\n        return k || (k = u(this, E), this._senders.push(k)), k;\n      };\n      const S = a.RTCPeerConnection.prototype.removeTrack;\n      a.RTCPeerConnection.prototype.removeTrack = function(E) {\n        S.apply(this, arguments);\n        const _ = this._senders.indexOf(E);\n        _ !== -1 && this._senders.splice(_, 1);\n      };\n    }\n    const c = a.RTCPeerConnection.prototype.addStream;\n    a.RTCPeerConnection.prototype.addStream = function(S) {\n      this._senders = this._senders || [], c.apply(this, [S]), S.getTracks().forEach((g) => {\n        this._senders.push(u(this, g));\n      });\n    };\n    const l = a.RTCPeerConnection.prototype.removeStream;\n    a.RTCPeerConnection.prototype.removeStream = function(S) {\n      this._senders = this._senders || [], l.apply(this, [S]), S.getTracks().forEach((g) => {\n        const E = this._senders.find((_) => _.track === g);\n        E && this._senders.splice(this._senders.indexOf(E), 1);\n      });\n    };\n  } else if (typeof a == \"object\" && a.RTCPeerConnection && \"getSenders\" in a.RTCPeerConnection.prototype && \"createDTMFSender\" in a.RTCPeerConnection.prototype && a.RTCRtpSender && !(\"dtmf\" in a.RTCRtpSender.prototype)) {\n    const u = a.RTCPeerConnection.prototype.getSenders;\n    a.RTCPeerConnection.prototype.getSenders = function() {\n      const l = u.apply(this, []);\n      return l.forEach((v) => v._pc = this), l;\n    }, Object.defineProperty(a.RTCRtpSender.prototype, \"dtmf\", {\n      get() {\n        return this._dtmf === void 0 && (this.track.kind === \"audio\" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;\n      }\n    });\n  }\n}\nfunction shimGetStats(a) {\n  if (!a.RTCPeerConnection)\n    return;\n  const u = a.RTCPeerConnection.prototype.getStats;\n  a.RTCPeerConnection.prototype.getStats = function() {\n    const [l, v, S] = arguments;\n    if (arguments.length > 0 && typeof l == \"function\")\n      return u.apply(this, arguments);\n    if (u.length === 0 && (arguments.length === 0 || typeof l != \"function\"))\n      return u.apply(this, []);\n    const g = function(_) {\n      const k = {};\n      return _.result().forEach((M) => {\n        const $ = {\n          id: M.id,\n          timestamp: M.timestamp,\n          type: {\n            localcandidate: \"local-candidate\",\n            remotecandidate: \"remote-candidate\"\n          }[M.type] || M.type\n        };\n        M.names().forEach((J) => {\n          $[J] = M.stat(J);\n        }), k[$.id] = $;\n      }), k;\n    }, E = function(_) {\n      return new Map(Object.keys(_).map((k) => [k, _[k]]));\n    };\n    if (arguments.length >= 2) {\n      const _ = function(k) {\n        v(E(g(k)));\n      };\n      return u.apply(this, [_, l]);\n    }\n    return new Promise((_, k) => {\n      u.apply(this, [function(L) {\n        _(E(g(L)));\n      }, k]);\n    }).then(v, S);\n  };\n}\nfunction shimSenderReceiverGetStats(a) {\n  if (!(typeof a == \"object\" && a.RTCPeerConnection && a.RTCRtpSender && a.RTCRtpReceiver))\n    return;\n  if (!(\"getStats\" in a.RTCRtpSender.prototype)) {\n    const c = a.RTCPeerConnection.prototype.getSenders;\n    c && (a.RTCPeerConnection.prototype.getSenders = function() {\n      const S = c.apply(this, []);\n      return S.forEach((g) => g._pc = this), S;\n    });\n    const l = a.RTCPeerConnection.prototype.addTrack;\n    l && (a.RTCPeerConnection.prototype.addTrack = function() {\n      const S = l.apply(this, arguments);\n      return S._pc = this, S;\n    }), a.RTCRtpSender.prototype.getStats = function() {\n      const S = this;\n      return this._pc.getStats().then((g) => (\n        /* Note: this will include stats of all senders that\n         *   send a track with the same id as sender.track as\n         *   it is not possible to identify the RTCRtpSender.\n         */\n        filterStats(g, S.track, !0)\n      ));\n    };\n  }\n  if (!(\"getStats\" in a.RTCRtpReceiver.prototype)) {\n    const c = a.RTCPeerConnection.prototype.getReceivers;\n    c && (a.RTCPeerConnection.prototype.getReceivers = function() {\n      const v = c.apply(this, []);\n      return v.forEach((S) => S._pc = this), v;\n    }), wrapPeerConnectionEvent(a, \"track\", (l) => (l.receiver._pc = l.srcElement, l)), a.RTCRtpReceiver.prototype.getStats = function() {\n      const v = this;\n      return this._pc.getStats().then((S) => filterStats(S, v.track, !1));\n    };\n  }\n  if (!(\"getStats\" in a.RTCRtpSender.prototype && \"getStats\" in a.RTCRtpReceiver.prototype))\n    return;\n  const u = a.RTCPeerConnection.prototype.getStats;\n  a.RTCPeerConnection.prototype.getStats = function() {\n    if (arguments.length > 0 && arguments[0] instanceof a.MediaStreamTrack) {\n      const l = arguments[0];\n      let v, S, g;\n      return this.getSenders().forEach((E) => {\n        E.track === l && (v ? g = !0 : v = E);\n      }), this.getReceivers().forEach((E) => (E.track === l && (S ? g = !0 : S = E), E.track === l)), g || v && S ? Promise.reject(new DOMException(\"There are more than one sender or receiver for the track.\", \"InvalidAccessError\")) : v ? v.getStats() : S ? S.getStats() : Promise.reject(new DOMException(\"There is no sender or receiver for the track.\", \"InvalidAccessError\"));\n    }\n    return u.apply(this, arguments);\n  };\n}\nfunction shimAddTrackRemoveTrackWithNative(a) {\n  a.RTCPeerConnection.prototype.getLocalStreams = function() {\n    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((g) => this._shimmedLocalStreams[g][0]);\n  };\n  const u = a.RTCPeerConnection.prototype.addTrack;\n  a.RTCPeerConnection.prototype.addTrack = function(g, E) {\n    if (!E)\n      return u.apply(this, arguments);\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    const _ = u.apply(this, arguments);\n    return this._shimmedLocalStreams[E.id] ? this._shimmedLocalStreams[E.id].indexOf(_) === -1 && this._shimmedLocalStreams[E.id].push(_) : this._shimmedLocalStreams[E.id] = [E, _], _;\n  };\n  const c = a.RTCPeerConnection.prototype.addStream;\n  a.RTCPeerConnection.prototype.addStream = function(g) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {}, g.getTracks().forEach((k) => {\n      if (this.getSenders().find((M) => M.track === k))\n        throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n    });\n    const E = this.getSenders();\n    c.apply(this, arguments);\n    const _ = this.getSenders().filter((k) => E.indexOf(k) === -1);\n    this._shimmedLocalStreams[g.id] = [g].concat(_);\n  };\n  const l = a.RTCPeerConnection.prototype.removeStream;\n  a.RTCPeerConnection.prototype.removeStream = function(g) {\n    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[g.id], l.apply(this, arguments);\n  };\n  const v = a.RTCPeerConnection.prototype.removeTrack;\n  a.RTCPeerConnection.prototype.removeTrack = function(g) {\n    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, g && Object.keys(this._shimmedLocalStreams).forEach((E) => {\n      const _ = this._shimmedLocalStreams[E].indexOf(g);\n      _ !== -1 && this._shimmedLocalStreams[E].splice(_, 1), this._shimmedLocalStreams[E].length === 1 && delete this._shimmedLocalStreams[E];\n    }), v.apply(this, arguments);\n  };\n}\nfunction shimAddTrackRemoveTrack(a, u) {\n  if (!a.RTCPeerConnection)\n    return;\n  if (a.RTCPeerConnection.prototype.addTrack && u.version >= 65)\n    return shimAddTrackRemoveTrackWithNative(a);\n  const c = a.RTCPeerConnection.prototype.getLocalStreams;\n  a.RTCPeerConnection.prototype.getLocalStreams = function() {\n    const L = c.apply(this);\n    return this._reverseStreams = this._reverseStreams || {}, L.map((M) => this._reverseStreams[M.id]);\n  };\n  const l = a.RTCPeerConnection.prototype.addStream;\n  a.RTCPeerConnection.prototype.addStream = function(L) {\n    if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, L.getTracks().forEach((M) => {\n      if (this.getSenders().find((J) => J.track === M))\n        throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n    }), !this._reverseStreams[L.id]) {\n      const M = new a.MediaStream(L.getTracks());\n      this._streams[L.id] = M, this._reverseStreams[M.id] = L, L = M;\n    }\n    l.apply(this, [L]);\n  };\n  const v = a.RTCPeerConnection.prototype.removeStream;\n  a.RTCPeerConnection.prototype.removeStream = function(L) {\n    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, v.apply(this, [this._streams[L.id] || L]), delete this._reverseStreams[this._streams[L.id] ? this._streams[L.id].id : L.id], delete this._streams[L.id];\n  }, a.RTCPeerConnection.prototype.addTrack = function(L, M) {\n    if (this.signalingState === \"closed\")\n      throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n    const $ = [].slice.call(arguments, 1);\n    if ($.length !== 1 || !$[0].getTracks().find((q) => q === L))\n      throw new DOMException(\"The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.\", \"NotSupportedError\");\n    if (this.getSenders().find((q) => q.track === L))\n      throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};\n    const V = this._streams[M.id];\n    if (V)\n      V.addTrack(L), Promise.resolve().then(() => {\n        this.dispatchEvent(new Event(\"negotiationneeded\"));\n      });\n    else {\n      const q = new a.MediaStream([L]);\n      this._streams[M.id] = q, this._reverseStreams[q.id] = M, this.addStream(q);\n    }\n    return this.getSenders().find((q) => q.track === L);\n  };\n  function S(k, L) {\n    let M = L.sdp;\n    return Object.keys(k._reverseStreams || []).forEach(($) => {\n      const J = k._reverseStreams[$], V = k._streams[J.id];\n      M = M.replace(new RegExp(V.id, \"g\"), J.id);\n    }), new RTCSessionDescription({\n      type: L.type,\n      sdp: M\n    });\n  }\n  function g(k, L) {\n    let M = L.sdp;\n    return Object.keys(k._reverseStreams || []).forEach(($) => {\n      const J = k._reverseStreams[$], V = k._streams[J.id];\n      M = M.replace(new RegExp(J.id, \"g\"), V.id);\n    }), new RTCSessionDescription({\n      type: L.type,\n      sdp: M\n    });\n  }\n  [\"createOffer\", \"createAnswer\"].forEach(function(k) {\n    const L = a.RTCPeerConnection.prototype[k], M = {\n      [k]() {\n        const $ = arguments;\n        return arguments.length && typeof arguments[0] == \"function\" ? L.apply(this, [(V) => {\n          const q = S(this, V);\n          $[0].apply(null, [q]);\n        }, (V) => {\n          $[1] && $[1].apply(null, V);\n        }, arguments[2]]) : L.apply(this, arguments).then((V) => S(this, V));\n      }\n    };\n    a.RTCPeerConnection.prototype[k] = M[k];\n  });\n  const E = a.RTCPeerConnection.prototype.setLocalDescription;\n  a.RTCPeerConnection.prototype.setLocalDescription = function() {\n    return !arguments.length || !arguments[0].type ? E.apply(this, arguments) : (arguments[0] = g(this, arguments[0]), E.apply(this, arguments));\n  };\n  const _ = Object.getOwnPropertyDescriptor(a.RTCPeerConnection.prototype, \"localDescription\");\n  Object.defineProperty(a.RTCPeerConnection.prototype, \"localDescription\", {\n    get() {\n      const k = _.get.apply(this);\n      return k.type === \"\" ? k : S(this, k);\n    }\n  }), a.RTCPeerConnection.prototype.removeTrack = function(L) {\n    if (this.signalingState === \"closed\")\n      throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n    if (!L._pc)\n      throw new DOMException(\"Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.\", \"TypeError\");\n    if (!(L._pc === this))\n      throw new DOMException(\"Sender was not created by this connection.\", \"InvalidAccessError\");\n    this._streams = this._streams || {};\n    let $;\n    Object.keys(this._streams).forEach((J) => {\n      this._streams[J].getTracks().find((q) => L.track === q) && ($ = this._streams[J]);\n    }), $ && ($.getTracks().length === 1 ? this.removeStream(this._reverseStreams[$.id]) : $.removeTrack(L.track), this.dispatchEvent(new Event(\"negotiationneeded\")));\n  };\n}\nfunction shimPeerConnection$1(a, u) {\n  !a.RTCPeerConnection && a.webkitRTCPeerConnection && (a.RTCPeerConnection = a.webkitRTCPeerConnection), a.RTCPeerConnection && u.version < 53 && [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"].forEach(function(c) {\n    const l = a.RTCPeerConnection.prototype[c], v = {\n      [c]() {\n        return arguments[0] = new (c === \"addIceCandidate\" ? a.RTCIceCandidate : a.RTCSessionDescription)(arguments[0]), l.apply(this, arguments);\n      }\n    };\n    a.RTCPeerConnection.prototype[c] = v[c];\n  });\n}\nfunction fixNegotiationNeeded(a, u) {\n  wrapPeerConnectionEvent(a, \"negotiationneeded\", (c) => {\n    const l = c.target;\n    if (!((u.version < 72 || l.getConfiguration && l.getConfiguration().sdpSemantics === \"plan-b\") && l.signalingState !== \"stable\"))\n      return c;\n  });\n}\nvar chromeShim = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  fixNegotiationNeeded,\n  shimAddTrackRemoveTrack,\n  shimAddTrackRemoveTrackWithNative,\n  shimGetDisplayMedia: shimGetDisplayMedia$1,\n  shimGetSendersWithDtmf,\n  shimGetStats,\n  shimGetUserMedia: shimGetUserMedia$2,\n  shimMediaStream,\n  shimOnTrack: shimOnTrack$1,\n  shimPeerConnection: shimPeerConnection$1,\n  shimSenderReceiverGetStats\n});\nfunction shimGetUserMedia$1(a, u) {\n  const c = a && a.navigator, l = a && a.MediaStreamTrack;\n  if (c.getUserMedia = function(v, S, g) {\n    deprecated(\"navigator.getUserMedia\", \"navigator.mediaDevices.getUserMedia\"), c.mediaDevices.getUserMedia(v).then(S, g);\n  }, !(u.version > 55 && \"autoGainControl\" in c.mediaDevices.getSupportedConstraints())) {\n    const v = function(g, E, _) {\n      E in g && !(_ in g) && (g[_] = g[E], delete g[E]);\n    }, S = c.mediaDevices.getUserMedia.bind(c.mediaDevices);\n    if (c.mediaDevices.getUserMedia = function(g) {\n      return typeof g == \"object\" && typeof g.audio == \"object\" && (g = JSON.parse(JSON.stringify(g)), v(g.audio, \"autoGainControl\", \"mozAutoGainControl\"), v(g.audio, \"noiseSuppression\", \"mozNoiseSuppression\")), S(g);\n    }, l && l.prototype.getSettings) {\n      const g = l.prototype.getSettings;\n      l.prototype.getSettings = function() {\n        const E = g.apply(this, arguments);\n        return v(E, \"mozAutoGainControl\", \"autoGainControl\"), v(E, \"mozNoiseSuppression\", \"noiseSuppression\"), E;\n      };\n    }\n    if (l && l.prototype.applyConstraints) {\n      const g = l.prototype.applyConstraints;\n      l.prototype.applyConstraints = function(E) {\n        return this.kind === \"audio\" && typeof E == \"object\" && (E = JSON.parse(JSON.stringify(E)), v(E, \"autoGainControl\", \"mozAutoGainControl\"), v(E, \"noiseSuppression\", \"mozNoiseSuppression\")), g.apply(this, [E]);\n      };\n    }\n  }\n}\nfunction shimGetDisplayMedia(a, u) {\n  a.navigator.mediaDevices && \"getDisplayMedia\" in a.navigator.mediaDevices || a.navigator.mediaDevices && (a.navigator.mediaDevices.getDisplayMedia = function(l) {\n    if (!(l && l.video)) {\n      const v = new DOMException(\"getDisplayMedia without video constraints is undefined\");\n      return v.name = \"NotFoundError\", v.code = 8, Promise.reject(v);\n    }\n    return l.video === !0 ? l.video = {\n      mediaSource: u\n    } : l.video.mediaSource = u, a.navigator.mediaDevices.getUserMedia(l);\n  });\n}\nfunction shimOnTrack(a) {\n  typeof a == \"object\" && a.RTCTrackEvent && \"receiver\" in a.RTCTrackEvent.prototype && !(\"transceiver\" in a.RTCTrackEvent.prototype) && Object.defineProperty(a.RTCTrackEvent.prototype, \"transceiver\", {\n    get() {\n      return {\n        receiver: this.receiver\n      };\n    }\n  });\n}\nfunction shimPeerConnection(a, u) {\n  if (typeof a != \"object\" || !(a.RTCPeerConnection || a.mozRTCPeerConnection))\n    return;\n  !a.RTCPeerConnection && a.mozRTCPeerConnection && (a.RTCPeerConnection = a.mozRTCPeerConnection), u.version < 53 && [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"].forEach(function(v) {\n    const S = a.RTCPeerConnection.prototype[v], g = {\n      [v]() {\n        return arguments[0] = new (v === \"addIceCandidate\" ? a.RTCIceCandidate : a.RTCSessionDescription)(arguments[0]), S.apply(this, arguments);\n      }\n    };\n    a.RTCPeerConnection.prototype[v] = g[v];\n  });\n  const c = {\n    inboundrtp: \"inbound-rtp\",\n    outboundrtp: \"outbound-rtp\",\n    candidatepair: \"candidate-pair\",\n    localcandidate: \"local-candidate\",\n    remotecandidate: \"remote-candidate\"\n  }, l = a.RTCPeerConnection.prototype.getStats;\n  a.RTCPeerConnection.prototype.getStats = function() {\n    const [S, g, E] = arguments;\n    return l.apply(this, [S || null]).then((_) => {\n      if (u.version < 53 && !g)\n        try {\n          _.forEach((k) => {\n            k.type = c[k.type] || k.type;\n          });\n        } catch (k) {\n          if (k.name !== \"TypeError\")\n            throw k;\n          _.forEach((L, M) => {\n            _.set(M, Object.assign({}, L, {\n              type: c[L.type] || L.type\n            }));\n          });\n        }\n      return _;\n    }).then(g, E);\n  };\n}\nfunction shimSenderGetStats(a) {\n  if (!(typeof a == \"object\" && a.RTCPeerConnection && a.RTCRtpSender) || a.RTCRtpSender && \"getStats\" in a.RTCRtpSender.prototype)\n    return;\n  const u = a.RTCPeerConnection.prototype.getSenders;\n  u && (a.RTCPeerConnection.prototype.getSenders = function() {\n    const v = u.apply(this, []);\n    return v.forEach((S) => S._pc = this), v;\n  });\n  const c = a.RTCPeerConnection.prototype.addTrack;\n  c && (a.RTCPeerConnection.prototype.addTrack = function() {\n    const v = c.apply(this, arguments);\n    return v._pc = this, v;\n  }), a.RTCRtpSender.prototype.getStats = function() {\n    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());\n  };\n}\nfunction shimReceiverGetStats(a) {\n  if (!(typeof a == \"object\" && a.RTCPeerConnection && a.RTCRtpSender) || a.RTCRtpSender && \"getStats\" in a.RTCRtpReceiver.prototype)\n    return;\n  const u = a.RTCPeerConnection.prototype.getReceivers;\n  u && (a.RTCPeerConnection.prototype.getReceivers = function() {\n    const l = u.apply(this, []);\n    return l.forEach((v) => v._pc = this), l;\n  }), wrapPeerConnectionEvent(a, \"track\", (c) => (c.receiver._pc = c.srcElement, c)), a.RTCRtpReceiver.prototype.getStats = function() {\n    return this._pc.getStats(this.track);\n  };\n}\nfunction shimRemoveStream(a) {\n  !a.RTCPeerConnection || \"removeStream\" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.removeStream = function(c) {\n    deprecated(\"removeStream\", \"removeTrack\"), this.getSenders().forEach((l) => {\n      l.track && c.getTracks().includes(l.track) && this.removeTrack(l);\n    });\n  });\n}\nfunction shimRTCDataChannel(a) {\n  a.DataChannel && !a.RTCDataChannel && (a.RTCDataChannel = a.DataChannel);\n}\nfunction shimAddTransceiver(a) {\n  if (!(typeof a == \"object\" && a.RTCPeerConnection))\n    return;\n  const u = a.RTCPeerConnection.prototype.addTransceiver;\n  u && (a.RTCPeerConnection.prototype.addTransceiver = function() {\n    this.setParametersPromises = [];\n    let l = arguments[1] && arguments[1].sendEncodings;\n    l === void 0 && (l = []), l = [...l];\n    const v = l.length > 0;\n    v && l.forEach((g) => {\n      if (\"rid\" in g && !/^[a-z0-9]{0,16}$/i.test(g.rid))\n        throw new TypeError(\"Invalid RID value provided.\");\n      if (\"scaleResolutionDownBy\" in g && !(parseFloat(g.scaleResolutionDownBy) >= 1))\n        throw new RangeError(\"scale_resolution_down_by must be >= 1.0\");\n      if (\"maxFramerate\" in g && !(parseFloat(g.maxFramerate) >= 0))\n        throw new RangeError(\"max_framerate must be >= 0.0\");\n    });\n    const S = u.apply(this, arguments);\n    if (v) {\n      const {\n        sender: g\n      } = S, E = g.getParameters();\n      (!(\"encodings\" in E) || // Avoid being fooled by patched getParameters() below.\n      E.encodings.length === 1 && Object.keys(E.encodings[0]).length === 0) && (E.encodings = l, g.sendEncodings = l, this.setParametersPromises.push(g.setParameters(E).then(() => {\n        delete g.sendEncodings;\n      }).catch(() => {\n        delete g.sendEncodings;\n      })));\n    }\n    return S;\n  });\n}\nfunction shimGetParameters(a) {\n  if (!(typeof a == \"object\" && a.RTCRtpSender))\n    return;\n  const u = a.RTCRtpSender.prototype.getParameters;\n  u && (a.RTCRtpSender.prototype.getParameters = function() {\n    const l = u.apply(this, arguments);\n    return \"encodings\" in l || (l.encodings = [].concat(this.sendEncodings || [{}])), l;\n  });\n}\nfunction shimCreateOffer(a) {\n  if (!(typeof a == \"object\" && a.RTCPeerConnection))\n    return;\n  const u = a.RTCPeerConnection.prototype.createOffer;\n  a.RTCPeerConnection.prototype.createOffer = function() {\n    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => u.apply(this, arguments)).finally(() => {\n      this.setParametersPromises = [];\n    }) : u.apply(this, arguments);\n  };\n}\nfunction shimCreateAnswer(a) {\n  if (!(typeof a == \"object\" && a.RTCPeerConnection))\n    return;\n  const u = a.RTCPeerConnection.prototype.createAnswer;\n  a.RTCPeerConnection.prototype.createAnswer = function() {\n    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => u.apply(this, arguments)).finally(() => {\n      this.setParametersPromises = [];\n    }) : u.apply(this, arguments);\n  };\n}\nvar firefoxShim = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  shimAddTransceiver,\n  shimCreateAnswer,\n  shimCreateOffer,\n  shimGetDisplayMedia,\n  shimGetParameters,\n  shimGetUserMedia: shimGetUserMedia$1,\n  shimOnTrack,\n  shimPeerConnection,\n  shimRTCDataChannel,\n  shimReceiverGetStats,\n  shimRemoveStream,\n  shimSenderGetStats\n});\nfunction shimLocalStreamsAPI(a) {\n  if (!(typeof a != \"object\" || !a.RTCPeerConnection)) {\n    if (\"getLocalStreams\" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.getLocalStreams = function() {\n      return this._localStreams || (this._localStreams = []), this._localStreams;\n    }), !(\"addStream\" in a.RTCPeerConnection.prototype)) {\n      const u = a.RTCPeerConnection.prototype.addTrack;\n      a.RTCPeerConnection.prototype.addStream = function(l) {\n        this._localStreams || (this._localStreams = []), this._localStreams.includes(l) || this._localStreams.push(l), l.getAudioTracks().forEach((v) => u.call(this, v, l)), l.getVideoTracks().forEach((v) => u.call(this, v, l));\n      }, a.RTCPeerConnection.prototype.addTrack = function(l) {\n        for (var v = arguments.length, S = new Array(v > 1 ? v - 1 : 0), g = 1; g < v; g++)\n          S[g - 1] = arguments[g];\n        return S && S.forEach((E) => {\n          this._localStreams ? this._localStreams.includes(E) || this._localStreams.push(E) : this._localStreams = [E];\n        }), u.apply(this, arguments);\n      };\n    }\n    \"removeStream\" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.removeStream = function(c) {\n      this._localStreams || (this._localStreams = []);\n      const l = this._localStreams.indexOf(c);\n      if (l === -1)\n        return;\n      this._localStreams.splice(l, 1);\n      const v = c.getTracks();\n      this.getSenders().forEach((S) => {\n        v.includes(S.track) && this.removeTrack(S);\n      });\n    });\n  }\n}\nfunction shimRemoteStreamsAPI(a) {\n  if (!(typeof a != \"object\" || !a.RTCPeerConnection) && (\"getRemoteStreams\" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.getRemoteStreams = function() {\n    return this._remoteStreams ? this._remoteStreams : [];\n  }), !(\"onaddstream\" in a.RTCPeerConnection.prototype))) {\n    Object.defineProperty(a.RTCPeerConnection.prototype, \"onaddstream\", {\n      get() {\n        return this._onaddstream;\n      },\n      set(c) {\n        this._onaddstream && (this.removeEventListener(\"addstream\", this._onaddstream), this.removeEventListener(\"track\", this._onaddstreampoly)), this.addEventListener(\"addstream\", this._onaddstream = c), this.addEventListener(\"track\", this._onaddstreampoly = (l) => {\n          l.streams.forEach((v) => {\n            if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(v))\n              return;\n            this._remoteStreams.push(v);\n            const S = new Event(\"addstream\");\n            S.stream = v, this.dispatchEvent(S);\n          });\n        });\n      }\n    });\n    const u = a.RTCPeerConnection.prototype.setRemoteDescription;\n    a.RTCPeerConnection.prototype.setRemoteDescription = function() {\n      const l = this;\n      return this._onaddstreampoly || this.addEventListener(\"track\", this._onaddstreampoly = function(v) {\n        v.streams.forEach((S) => {\n          if (l._remoteStreams || (l._remoteStreams = []), l._remoteStreams.indexOf(S) >= 0)\n            return;\n          l._remoteStreams.push(S);\n          const g = new Event(\"addstream\");\n          g.stream = S, l.dispatchEvent(g);\n        });\n      }), u.apply(l, arguments);\n    };\n  }\n}\nfunction shimCallbacksAPI(a) {\n  if (typeof a != \"object\" || !a.RTCPeerConnection)\n    return;\n  const u = a.RTCPeerConnection.prototype, c = u.createOffer, l = u.createAnswer, v = u.setLocalDescription, S = u.setRemoteDescription, g = u.addIceCandidate;\n  u.createOffer = function(k, L) {\n    const M = arguments.length >= 2 ? arguments[2] : arguments[0], $ = c.apply(this, [M]);\n    return L ? ($.then(k, L), Promise.resolve()) : $;\n  }, u.createAnswer = function(k, L) {\n    const M = arguments.length >= 2 ? arguments[2] : arguments[0], $ = l.apply(this, [M]);\n    return L ? ($.then(k, L), Promise.resolve()) : $;\n  };\n  let E = function(_, k, L) {\n    const M = v.apply(this, [_]);\n    return L ? (M.then(k, L), Promise.resolve()) : M;\n  };\n  u.setLocalDescription = E, E = function(_, k, L) {\n    const M = S.apply(this, [_]);\n    return L ? (M.then(k, L), Promise.resolve()) : M;\n  }, u.setRemoteDescription = E, E = function(_, k, L) {\n    const M = g.apply(this, [_]);\n    return L ? (M.then(k, L), Promise.resolve()) : M;\n  }, u.addIceCandidate = E;\n}\nfunction shimGetUserMedia(a) {\n  const u = a && a.navigator;\n  if (u.mediaDevices && u.mediaDevices.getUserMedia) {\n    const c = u.mediaDevices, l = c.getUserMedia.bind(c);\n    u.mediaDevices.getUserMedia = (v) => l(shimConstraints(v));\n  }\n  !u.getUserMedia && u.mediaDevices && u.mediaDevices.getUserMedia && (u.getUserMedia = (function(l, v, S) {\n    u.mediaDevices.getUserMedia(l).then(v, S);\n  }).bind(u));\n}\nfunction shimConstraints(a) {\n  return a && a.video !== void 0 ? Object.assign({}, a, {\n    video: compactObject(a.video)\n  }) : a;\n}\nfunction shimRTCIceServerUrls(a) {\n  if (!a.RTCPeerConnection)\n    return;\n  const u = a.RTCPeerConnection;\n  a.RTCPeerConnection = function(l, v) {\n    if (l && l.iceServers) {\n      const S = [];\n      for (let g = 0; g < l.iceServers.length; g++) {\n        let E = l.iceServers[g];\n        E.urls === void 0 && E.url ? (deprecated(\"RTCIceServer.url\", \"RTCIceServer.urls\"), E = JSON.parse(JSON.stringify(E)), E.urls = E.url, delete E.url, S.push(E)) : S.push(l.iceServers[g]);\n      }\n      l.iceServers = S;\n    }\n    return new u(l, v);\n  }, a.RTCPeerConnection.prototype = u.prototype, \"generateCertificate\" in u && Object.defineProperty(a.RTCPeerConnection, \"generateCertificate\", {\n    get() {\n      return u.generateCertificate;\n    }\n  });\n}\nfunction shimTrackEventTransceiver(a) {\n  typeof a == \"object\" && a.RTCTrackEvent && \"receiver\" in a.RTCTrackEvent.prototype && !(\"transceiver\" in a.RTCTrackEvent.prototype) && Object.defineProperty(a.RTCTrackEvent.prototype, \"transceiver\", {\n    get() {\n      return {\n        receiver: this.receiver\n      };\n    }\n  });\n}\nfunction shimCreateOfferLegacy(a) {\n  const u = a.RTCPeerConnection.prototype.createOffer;\n  a.RTCPeerConnection.prototype.createOffer = function(l) {\n    if (l) {\n      typeof l.offerToReceiveAudio < \"u\" && (l.offerToReceiveAudio = !!l.offerToReceiveAudio);\n      const v = this.getTransceivers().find((g) => g.receiver.track.kind === \"audio\");\n      l.offerToReceiveAudio === !1 && v ? v.direction === \"sendrecv\" ? v.setDirection ? v.setDirection(\"sendonly\") : v.direction = \"sendonly\" : v.direction === \"recvonly\" && (v.setDirection ? v.setDirection(\"inactive\") : v.direction = \"inactive\") : l.offerToReceiveAudio === !0 && !v && this.addTransceiver(\"audio\", {\n        direction: \"recvonly\"\n      }), typeof l.offerToReceiveVideo < \"u\" && (l.offerToReceiveVideo = !!l.offerToReceiveVideo);\n      const S = this.getTransceivers().find((g) => g.receiver.track.kind === \"video\");\n      l.offerToReceiveVideo === !1 && S ? S.direction === \"sendrecv\" ? S.setDirection ? S.setDirection(\"sendonly\") : S.direction = \"sendonly\" : S.direction === \"recvonly\" && (S.setDirection ? S.setDirection(\"inactive\") : S.direction = \"inactive\") : l.offerToReceiveVideo === !0 && !S && this.addTransceiver(\"video\", {\n        direction: \"recvonly\"\n      });\n    }\n    return u.apply(this, arguments);\n  };\n}\nfunction shimAudioContext(a) {\n  typeof a != \"object\" || a.AudioContext || (a.AudioContext = a.webkitAudioContext);\n}\nvar safariShim = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  shimAudioContext,\n  shimCallbacksAPI,\n  shimConstraints,\n  shimCreateOfferLegacy,\n  shimGetUserMedia,\n  shimLocalStreamsAPI,\n  shimRTCIceServerUrls,\n  shimRemoteStreamsAPI,\n  shimTrackEventTransceiver\n}), sdp$1 = { exports: {} };\n(function(a) {\n  const u = {};\n  u.generateIdentifier = function() {\n    return Math.random().toString(36).substring(2, 12);\n  }, u.localCName = u.generateIdentifier(), u.splitLines = function(c) {\n    return c.trim().split(`\n`).map((l) => l.trim());\n  }, u.splitSections = function(c) {\n    return c.split(`\nm=`).map((v, S) => (S > 0 ? \"m=\" + v : v).trim() + `\\r\n`);\n  }, u.getDescription = function(c) {\n    const l = u.splitSections(c);\n    return l && l[0];\n  }, u.getMediaSections = function(c) {\n    const l = u.splitSections(c);\n    return l.shift(), l;\n  }, u.matchPrefix = function(c, l) {\n    return u.splitLines(c).filter((v) => v.indexOf(l) === 0);\n  }, u.parseCandidate = function(c) {\n    let l;\n    c.indexOf(\"a=candidate:\") === 0 ? l = c.substring(12).split(\" \") : l = c.substring(10).split(\" \");\n    const v = {\n      foundation: l[0],\n      component: {\n        1: \"rtp\",\n        2: \"rtcp\"\n      }[l[1]] || l[1],\n      protocol: l[2].toLowerCase(),\n      priority: parseInt(l[3], 10),\n      ip: l[4],\n      address: l[4],\n      // address is an alias for ip.\n      port: parseInt(l[5], 10),\n      // skip parts[6] == 'typ'\n      type: l[7]\n    };\n    for (let S = 8; S < l.length; S += 2)\n      switch (l[S]) {\n        case \"raddr\":\n          v.relatedAddress = l[S + 1];\n          break;\n        case \"rport\":\n          v.relatedPort = parseInt(l[S + 1], 10);\n          break;\n        case \"tcptype\":\n          v.tcpType = l[S + 1];\n          break;\n        case \"ufrag\":\n          v.ufrag = l[S + 1], v.usernameFragment = l[S + 1];\n          break;\n        default:\n          v[l[S]] === void 0 && (v[l[S]] = l[S + 1]);\n          break;\n      }\n    return v;\n  }, u.writeCandidate = function(c) {\n    const l = [];\n    l.push(c.foundation);\n    const v = c.component;\n    v === \"rtp\" ? l.push(1) : v === \"rtcp\" ? l.push(2) : l.push(v), l.push(c.protocol.toUpperCase()), l.push(c.priority), l.push(c.address || c.ip), l.push(c.port);\n    const S = c.type;\n    return l.push(\"typ\"), l.push(S), S !== \"host\" && c.relatedAddress && c.relatedPort && (l.push(\"raddr\"), l.push(c.relatedAddress), l.push(\"rport\"), l.push(c.relatedPort)), c.tcpType && c.protocol.toLowerCase() === \"tcp\" && (l.push(\"tcptype\"), l.push(c.tcpType)), (c.usernameFragment || c.ufrag) && (l.push(\"ufrag\"), l.push(c.usernameFragment || c.ufrag)), \"candidate:\" + l.join(\" \");\n  }, u.parseIceOptions = function(c) {\n    return c.substring(14).split(\" \");\n  }, u.parseRtpMap = function(c) {\n    let l = c.substring(9).split(\" \");\n    const v = {\n      payloadType: parseInt(l.shift(), 10)\n      // was: id\n    };\n    return l = l[0].split(\"/\"), v.name = l[0], v.clockRate = parseInt(l[1], 10), v.channels = l.length === 3 ? parseInt(l[2], 10) : 1, v.numChannels = v.channels, v;\n  }, u.writeRtpMap = function(c) {\n    let l = c.payloadType;\n    c.preferredPayloadType !== void 0 && (l = c.preferredPayloadType);\n    const v = c.channels || c.numChannels || 1;\n    return \"a=rtpmap:\" + l + \" \" + c.name + \"/\" + c.clockRate + (v !== 1 ? \"/\" + v : \"\") + `\\r\n`;\n  }, u.parseExtmap = function(c) {\n    const l = c.substring(9).split(\" \");\n    return {\n      id: parseInt(l[0], 10),\n      direction: l[0].indexOf(\"/\") > 0 ? l[0].split(\"/\")[1] : \"sendrecv\",\n      uri: l[1],\n      attributes: l.slice(2).join(\" \")\n    };\n  }, u.writeExtmap = function(c) {\n    return \"a=extmap:\" + (c.id || c.preferredId) + (c.direction && c.direction !== \"sendrecv\" ? \"/\" + c.direction : \"\") + \" \" + c.uri + (c.attributes ? \" \" + c.attributes : \"\") + `\\r\n`;\n  }, u.parseFmtp = function(c) {\n    const l = {};\n    let v;\n    const S = c.substring(c.indexOf(\" \") + 1).split(\";\");\n    for (let g = 0; g < S.length; g++)\n      v = S[g].trim().split(\"=\"), l[v[0].trim()] = v[1];\n    return l;\n  }, u.writeFmtp = function(c) {\n    let l = \"\", v = c.payloadType;\n    if (c.preferredPayloadType !== void 0 && (v = c.preferredPayloadType), c.parameters && Object.keys(c.parameters).length) {\n      const S = [];\n      Object.keys(c.parameters).forEach((g) => {\n        c.parameters[g] !== void 0 ? S.push(g + \"=\" + c.parameters[g]) : S.push(g);\n      }), l += \"a=fmtp:\" + v + \" \" + S.join(\";\") + `\\r\n`;\n    }\n    return l;\n  }, u.parseRtcpFb = function(c) {\n    const l = c.substring(c.indexOf(\" \") + 1).split(\" \");\n    return {\n      type: l.shift(),\n      parameter: l.join(\" \")\n    };\n  }, u.writeRtcpFb = function(c) {\n    let l = \"\", v = c.payloadType;\n    return c.preferredPayloadType !== void 0 && (v = c.preferredPayloadType), c.rtcpFeedback && c.rtcpFeedback.length && c.rtcpFeedback.forEach((S) => {\n      l += \"a=rtcp-fb:\" + v + \" \" + S.type + (S.parameter && S.parameter.length ? \" \" + S.parameter : \"\") + `\\r\n`;\n    }), l;\n  }, u.parseSsrcMedia = function(c) {\n    const l = c.indexOf(\" \"), v = {\n      ssrc: parseInt(c.substring(7, l), 10)\n    }, S = c.indexOf(\":\", l);\n    return S > -1 ? (v.attribute = c.substring(l + 1, S), v.value = c.substring(S + 1)) : v.attribute = c.substring(l + 1), v;\n  }, u.parseSsrcGroup = function(c) {\n    const l = c.substring(13).split(\" \");\n    return {\n      semantics: l.shift(),\n      ssrcs: l.map((v) => parseInt(v, 10))\n    };\n  }, u.getMid = function(c) {\n    const l = u.matchPrefix(c, \"a=mid:\")[0];\n    if (l)\n      return l.substring(6);\n  }, u.parseFingerprint = function(c) {\n    const l = c.substring(14).split(\" \");\n    return {\n      algorithm: l[0].toLowerCase(),\n      // algorithm is case-sensitive in Edge.\n      value: l[1].toUpperCase()\n      // the definition is upper-case in RFC 4572.\n    };\n  }, u.getDtlsParameters = function(c, l) {\n    return {\n      role: \"auto\",\n      fingerprints: u.matchPrefix(c + l, \"a=fingerprint:\").map(u.parseFingerprint)\n    };\n  }, u.writeDtlsParameters = function(c, l) {\n    let v = \"a=setup:\" + l + `\\r\n`;\n    return c.fingerprints.forEach((S) => {\n      v += \"a=fingerprint:\" + S.algorithm + \" \" + S.value + `\\r\n`;\n    }), v;\n  }, u.parseCryptoLine = function(c) {\n    const l = c.substring(9).split(\" \");\n    return {\n      tag: parseInt(l[0], 10),\n      cryptoSuite: l[1],\n      keyParams: l[2],\n      sessionParams: l.slice(3)\n    };\n  }, u.writeCryptoLine = function(c) {\n    return \"a=crypto:\" + c.tag + \" \" + c.cryptoSuite + \" \" + (typeof c.keyParams == \"object\" ? u.writeCryptoKeyParams(c.keyParams) : c.keyParams) + (c.sessionParams ? \" \" + c.sessionParams.join(\" \") : \"\") + `\\r\n`;\n  }, u.parseCryptoKeyParams = function(c) {\n    if (c.indexOf(\"inline:\") !== 0)\n      return null;\n    const l = c.substring(7).split(\"|\");\n    return {\n      keyMethod: \"inline\",\n      keySalt: l[0],\n      lifeTime: l[1],\n      mkiValue: l[2] ? l[2].split(\":\")[0] : void 0,\n      mkiLength: l[2] ? l[2].split(\":\")[1] : void 0\n    };\n  }, u.writeCryptoKeyParams = function(c) {\n    return c.keyMethod + \":\" + c.keySalt + (c.lifeTime ? \"|\" + c.lifeTime : \"\") + (c.mkiValue && c.mkiLength ? \"|\" + c.mkiValue + \":\" + c.mkiLength : \"\");\n  }, u.getCryptoParameters = function(c, l) {\n    return u.matchPrefix(c + l, \"a=crypto:\").map(u.parseCryptoLine);\n  }, u.getIceParameters = function(c, l) {\n    const v = u.matchPrefix(c + l, \"a=ice-ufrag:\")[0], S = u.matchPrefix(c + l, \"a=ice-pwd:\")[0];\n    return v && S ? {\n      usernameFragment: v.substring(12),\n      password: S.substring(10)\n    } : null;\n  }, u.writeIceParameters = function(c) {\n    let l = \"a=ice-ufrag:\" + c.usernameFragment + `\\r\na=ice-pwd:` + c.password + `\\r\n`;\n    return c.iceLite && (l += `a=ice-lite\\r\n`), l;\n  }, u.parseRtpParameters = function(c) {\n    const l = {\n      codecs: [],\n      headerExtensions: [],\n      fecMechanisms: [],\n      rtcp: []\n    }, S = u.splitLines(c)[0].split(\" \");\n    l.profile = S[2];\n    for (let E = 3; E < S.length; E++) {\n      const _ = S[E], k = u.matchPrefix(c, \"a=rtpmap:\" + _ + \" \")[0];\n      if (k) {\n        const L = u.parseRtpMap(k), M = u.matchPrefix(c, \"a=fmtp:\" + _ + \" \");\n        switch (L.parameters = M.length ? u.parseFmtp(M[0]) : {}, L.rtcpFeedback = u.matchPrefix(c, \"a=rtcp-fb:\" + _ + \" \").map(u.parseRtcpFb), l.codecs.push(L), L.name.toUpperCase()) {\n          case \"RED\":\n          case \"ULPFEC\":\n            l.fecMechanisms.push(L.name.toUpperCase());\n            break;\n        }\n      }\n    }\n    u.matchPrefix(c, \"a=extmap:\").forEach((E) => {\n      l.headerExtensions.push(u.parseExtmap(E));\n    });\n    const g = u.matchPrefix(c, \"a=rtcp-fb:* \").map(u.parseRtcpFb);\n    return l.codecs.forEach((E) => {\n      g.forEach((_) => {\n        E.rtcpFeedback.find((L) => L.type === _.type && L.parameter === _.parameter) || E.rtcpFeedback.push(_);\n      });\n    }), l;\n  }, u.writeRtpDescription = function(c, l) {\n    let v = \"\";\n    v += \"m=\" + c + \" \", v += l.codecs.length > 0 ? \"9\" : \"0\", v += \" \" + (l.profile || \"UDP/TLS/RTP/SAVPF\") + \" \", v += l.codecs.map((g) => g.preferredPayloadType !== void 0 ? g.preferredPayloadType : g.payloadType).join(\" \") + `\\r\n`, v += `c=IN IP4 0.0.0.0\\r\n`, v += `a=rtcp:9 IN IP4 0.0.0.0\\r\n`, l.codecs.forEach((g) => {\n      v += u.writeRtpMap(g), v += u.writeFmtp(g), v += u.writeRtcpFb(g);\n    });\n    let S = 0;\n    return l.codecs.forEach((g) => {\n      g.maxptime > S && (S = g.maxptime);\n    }), S > 0 && (v += \"a=maxptime:\" + S + `\\r\n`), l.headerExtensions && l.headerExtensions.forEach((g) => {\n      v += u.writeExtmap(g);\n    }), v;\n  }, u.parseRtpEncodingParameters = function(c) {\n    const l = [], v = u.parseRtpParameters(c), S = v.fecMechanisms.indexOf(\"RED\") !== -1, g = v.fecMechanisms.indexOf(\"ULPFEC\") !== -1, E = u.matchPrefix(c, \"a=ssrc:\").map(($) => u.parseSsrcMedia($)).filter(($) => $.attribute === \"cname\"), _ = E.length > 0 && E[0].ssrc;\n    let k;\n    const L = u.matchPrefix(c, \"a=ssrc-group:FID\").map(($) => $.substring(17).split(\" \").map((V) => parseInt(V, 10)));\n    L.length > 0 && L[0].length > 1 && L[0][0] === _ && (k = L[0][1]), v.codecs.forEach(($) => {\n      if ($.name.toUpperCase() === \"RTX\" && $.parameters.apt) {\n        let J = {\n          ssrc: _,\n          codecPayloadType: parseInt($.parameters.apt, 10)\n        };\n        _ && k && (J.rtx = {\n          ssrc: k\n        }), l.push(J), S && (J = JSON.parse(JSON.stringify(J)), J.fec = {\n          ssrc: _,\n          mechanism: g ? \"red+ulpfec\" : \"red\"\n        }, l.push(J));\n      }\n    }), l.length === 0 && _ && l.push({\n      ssrc: _\n    });\n    let M = u.matchPrefix(c, \"b=\");\n    return M.length && (M[0].indexOf(\"b=TIAS:\") === 0 ? M = parseInt(M[0].substring(7), 10) : M[0].indexOf(\"b=AS:\") === 0 ? M = parseInt(M[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8 : M = void 0, l.forEach(($) => {\n      $.maxBitrate = M;\n    })), l;\n  }, u.parseRtcpParameters = function(c) {\n    const l = {}, v = u.matchPrefix(c, \"a=ssrc:\").map((E) => u.parseSsrcMedia(E)).filter((E) => E.attribute === \"cname\")[0];\n    v && (l.cname = v.value, l.ssrc = v.ssrc);\n    const S = u.matchPrefix(c, \"a=rtcp-rsize\");\n    l.reducedSize = S.length > 0, l.compound = S.length === 0;\n    const g = u.matchPrefix(c, \"a=rtcp-mux\");\n    return l.mux = g.length > 0, l;\n  }, u.writeRtcpParameters = function(c) {\n    let l = \"\";\n    return c.reducedSize && (l += `a=rtcp-rsize\\r\n`), c.mux && (l += `a=rtcp-mux\\r\n`), c.ssrc !== void 0 && c.cname && (l += \"a=ssrc:\" + c.ssrc + \" cname:\" + c.cname + `\\r\n`), l;\n  }, u.parseMsid = function(c) {\n    let l;\n    const v = u.matchPrefix(c, \"a=msid:\");\n    if (v.length === 1)\n      return l = v[0].substring(7).split(\" \"), {\n        stream: l[0],\n        track: l[1]\n      };\n    const S = u.matchPrefix(c, \"a=ssrc:\").map((g) => u.parseSsrcMedia(g)).filter((g) => g.attribute === \"msid\");\n    if (S.length > 0)\n      return l = S[0].value.split(\" \"), {\n        stream: l[0],\n        track: l[1]\n      };\n  }, u.parseSctpDescription = function(c) {\n    const l = u.parseMLine(c), v = u.matchPrefix(c, \"a=max-message-size:\");\n    let S;\n    v.length > 0 && (S = parseInt(v[0].substring(19), 10)), isNaN(S) && (S = 65536);\n    const g = u.matchPrefix(c, \"a=sctp-port:\");\n    if (g.length > 0)\n      return {\n        port: parseInt(g[0].substring(12), 10),\n        protocol: l.fmt,\n        maxMessageSize: S\n      };\n    const E = u.matchPrefix(c, \"a=sctpmap:\");\n    if (E.length > 0) {\n      const _ = E[0].substring(10).split(\" \");\n      return {\n        port: parseInt(_[0], 10),\n        protocol: _[1],\n        maxMessageSize: S\n      };\n    }\n  }, u.writeSctpDescription = function(c, l) {\n    let v = [];\n    return c.protocol !== \"DTLS/SCTP\" ? v = [\"m=\" + c.kind + \" 9 \" + c.protocol + \" \" + l.protocol + `\\r\n`, `c=IN IP4 0.0.0.0\\r\n`, \"a=sctp-port:\" + l.port + `\\r\n`] : v = [\"m=\" + c.kind + \" 9 \" + c.protocol + \" \" + l.port + `\\r\n`, `c=IN IP4 0.0.0.0\\r\n`, \"a=sctpmap:\" + l.port + \" \" + l.protocol + ` 65535\\r\n`], l.maxMessageSize !== void 0 && v.push(\"a=max-message-size:\" + l.maxMessageSize + `\\r\n`), v.join(\"\");\n  }, u.generateSessionId = function() {\n    return Math.random().toString().substr(2, 22);\n  }, u.writeSessionBoilerplate = function(c, l, v) {\n    let S;\n    const g = l !== void 0 ? l : 2;\n    return c ? S = c : S = u.generateSessionId(), `v=0\\r\no=` + (v || \"thisisadapterortc\") + \" \" + S + \" \" + g + ` IN IP4 127.0.0.1\\r\ns=-\\r\nt=0 0\\r\n`;\n  }, u.getDirection = function(c, l) {\n    const v = u.splitLines(c);\n    for (let S = 0; S < v.length; S++)\n      switch (v[S]) {\n        case \"a=sendrecv\":\n        case \"a=sendonly\":\n        case \"a=recvonly\":\n        case \"a=inactive\":\n          return v[S].substring(2);\n      }\n    return l ? u.getDirection(l) : \"sendrecv\";\n  }, u.getKind = function(c) {\n    return u.splitLines(c)[0].split(\" \")[0].substring(2);\n  }, u.isRejected = function(c) {\n    return c.split(\" \", 2)[1] === \"0\";\n  }, u.parseMLine = function(c) {\n    const v = u.splitLines(c)[0].substring(2).split(\" \");\n    return {\n      kind: v[0],\n      port: parseInt(v[1], 10),\n      protocol: v[2],\n      fmt: v.slice(3).join(\" \")\n    };\n  }, u.parseOLine = function(c) {\n    const v = u.matchPrefix(c, \"o=\")[0].substring(2).split(\" \");\n    return {\n      username: v[0],\n      sessionId: v[1],\n      sessionVersion: parseInt(v[2], 10),\n      netType: v[3],\n      addressType: v[4],\n      address: v[5]\n    };\n  }, u.isValidSDP = function(c) {\n    if (typeof c != \"string\" || c.length === 0)\n      return !1;\n    const l = u.splitLines(c);\n    for (let v = 0; v < l.length; v++)\n      if (l[v].length < 2 || l[v].charAt(1) !== \"=\")\n        return !1;\n    return !0;\n  }, a.exports = u;\n})(sdp$1);\nvar sdpExports = sdp$1.exports, SDPUtils = /* @__PURE__ */ getDefaultExportFromCjs(sdpExports), sdp = /* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  default: SDPUtils\n}, [sdpExports]);\nfunction shimRTCIceCandidate(a) {\n  if (!a.RTCIceCandidate || a.RTCIceCandidate && \"foundation\" in a.RTCIceCandidate.prototype)\n    return;\n  const u = a.RTCIceCandidate;\n  a.RTCIceCandidate = function(l) {\n    if (typeof l == \"object\" && l.candidate && l.candidate.indexOf(\"a=\") === 0 && (l = JSON.parse(JSON.stringify(l)), l.candidate = l.candidate.substring(2)), l.candidate && l.candidate.length) {\n      const v = new u(l), S = SDPUtils.parseCandidate(l.candidate);\n      for (const g in S)\n        g in v || Object.defineProperty(v, g, {\n          value: S[g]\n        });\n      return v.toJSON = function() {\n        return {\n          candidate: v.candidate,\n          sdpMid: v.sdpMid,\n          sdpMLineIndex: v.sdpMLineIndex,\n          usernameFragment: v.usernameFragment\n        };\n      }, v;\n    }\n    return new u(l);\n  }, a.RTCIceCandidate.prototype = u.prototype, wrapPeerConnectionEvent(a, \"icecandidate\", (c) => (c.candidate && Object.defineProperty(c, \"candidate\", {\n    value: new a.RTCIceCandidate(c.candidate),\n    writable: \"false\"\n  }), c));\n}\nfunction shimRTCIceCandidateRelayProtocol(a) {\n  !a.RTCIceCandidate || a.RTCIceCandidate && \"relayProtocol\" in a.RTCIceCandidate.prototype || wrapPeerConnectionEvent(a, \"icecandidate\", (u) => {\n    if (u.candidate) {\n      const c = SDPUtils.parseCandidate(u.candidate.candidate);\n      c.type === \"relay\" && (u.candidate.relayProtocol = {\n        0: \"tls\",\n        1: \"tcp\",\n        2: \"udp\"\n      }[c.priority >> 24]);\n    }\n    return u;\n  });\n}\nfunction shimMaxMessageSize(a, u) {\n  if (!a.RTCPeerConnection)\n    return;\n  \"sctp\" in a.RTCPeerConnection.prototype || Object.defineProperty(a.RTCPeerConnection.prototype, \"sctp\", {\n    get() {\n      return typeof this._sctp > \"u\" ? null : this._sctp;\n    }\n  });\n  const c = function(E) {\n    if (!E || !E.sdp)\n      return !1;\n    const _ = SDPUtils.splitSections(E.sdp);\n    return _.shift(), _.some((k) => {\n      const L = SDPUtils.parseMLine(k);\n      return L && L.kind === \"application\" && L.protocol.indexOf(\"SCTP\") !== -1;\n    });\n  }, l = function(E) {\n    const _ = E.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n    if (_ === null || _.length < 2)\n      return -1;\n    const k = parseInt(_[1], 10);\n    return k !== k ? -1 : k;\n  }, v = function(E) {\n    let _ = 65536;\n    return u.browser === \"firefox\" && (u.version < 57 ? E === -1 ? _ = 16384 : _ = 2147483637 : u.version < 60 ? _ = u.version === 57 ? 65535 : 65536 : _ = 2147483637), _;\n  }, S = function(E, _) {\n    let k = 65536;\n    u.browser === \"firefox\" && u.version === 57 && (k = 65535);\n    const L = SDPUtils.matchPrefix(E.sdp, \"a=max-message-size:\");\n    return L.length > 0 ? k = parseInt(L[0].substring(19), 10) : u.browser === \"firefox\" && _ !== -1 && (k = 2147483637), k;\n  }, g = a.RTCPeerConnection.prototype.setRemoteDescription;\n  a.RTCPeerConnection.prototype.setRemoteDescription = function() {\n    if (this._sctp = null, u.browser === \"chrome\" && u.version >= 76) {\n      const {\n        sdpSemantics: _\n      } = this.getConfiguration();\n      _ === \"plan-b\" && Object.defineProperty(this, \"sctp\", {\n        get() {\n          return typeof this._sctp > \"u\" ? null : this._sctp;\n        },\n        enumerable: !0,\n        configurable: !0\n      });\n    }\n    if (c(arguments[0])) {\n      const _ = l(arguments[0]), k = v(_), L = S(arguments[0], _);\n      let M;\n      k === 0 && L === 0 ? M = Number.POSITIVE_INFINITY : k === 0 || L === 0 ? M = Math.max(k, L) : M = Math.min(k, L);\n      const $ = {};\n      Object.defineProperty($, \"maxMessageSize\", {\n        get() {\n          return M;\n        }\n      }), this._sctp = $;\n    }\n    return g.apply(this, arguments);\n  };\n}\nfunction shimSendThrowTypeError(a) {\n  if (!(a.RTCPeerConnection && \"createDataChannel\" in a.RTCPeerConnection.prototype))\n    return;\n  function u(l, v) {\n    const S = l.send;\n    l.send = function() {\n      const E = arguments[0], _ = E.length || E.size || E.byteLength;\n      if (l.readyState === \"open\" && v.sctp && _ > v.sctp.maxMessageSize)\n        throw new TypeError(\"Message too large (can send a maximum of \" + v.sctp.maxMessageSize + \" bytes)\");\n      return S.apply(l, arguments);\n    };\n  }\n  const c = a.RTCPeerConnection.prototype.createDataChannel;\n  a.RTCPeerConnection.prototype.createDataChannel = function() {\n    const v = c.apply(this, arguments);\n    return u(v, this), v;\n  }, wrapPeerConnectionEvent(a, \"datachannel\", (l) => (u(l.channel, l.target), l));\n}\nfunction shimConnectionState(a) {\n  if (!a.RTCPeerConnection || \"connectionState\" in a.RTCPeerConnection.prototype)\n    return;\n  const u = a.RTCPeerConnection.prototype;\n  Object.defineProperty(u, \"connectionState\", {\n    get() {\n      return {\n        completed: \"connected\",\n        checking: \"connecting\"\n      }[this.iceConnectionState] || this.iceConnectionState;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), Object.defineProperty(u, \"onconnectionstatechange\", {\n    get() {\n      return this._onconnectionstatechange || null;\n    },\n    set(c) {\n      this._onconnectionstatechange && (this.removeEventListener(\"connectionstatechange\", this._onconnectionstatechange), delete this._onconnectionstatechange), c && this.addEventListener(\"connectionstatechange\", this._onconnectionstatechange = c);\n    },\n    enumerable: !0,\n    configurable: !0\n  }), [\"setLocalDescription\", \"setRemoteDescription\"].forEach((c) => {\n    const l = u[c];\n    u[c] = function() {\n      return this._connectionstatechangepoly || (this._connectionstatechangepoly = (v) => {\n        const S = v.target;\n        if (S._lastConnectionState !== S.connectionState) {\n          S._lastConnectionState = S.connectionState;\n          const g = new Event(\"connectionstatechange\", v);\n          S.dispatchEvent(g);\n        }\n        return v;\n      }, this.addEventListener(\"iceconnectionstatechange\", this._connectionstatechangepoly)), l.apply(this, arguments);\n    };\n  });\n}\nfunction removeExtmapAllowMixed(a, u) {\n  if (!a.RTCPeerConnection || u.browser === \"chrome\" && u.version >= 71 || u.browser === \"safari\" && u.version >= 605)\n    return;\n  const c = a.RTCPeerConnection.prototype.setRemoteDescription;\n  a.RTCPeerConnection.prototype.setRemoteDescription = function(v) {\n    if (v && v.sdp && v.sdp.indexOf(`\na=extmap-allow-mixed`) !== -1) {\n      const S = v.sdp.split(`\n`).filter((g) => g.trim() !== \"a=extmap-allow-mixed\").join(`\n`);\n      a.RTCSessionDescription && v instanceof a.RTCSessionDescription ? arguments[0] = new a.RTCSessionDescription({\n        type: v.type,\n        sdp: S\n      }) : v.sdp = S;\n    }\n    return c.apply(this, arguments);\n  };\n}\nfunction shimAddIceCandidateNullOrEmpty(a, u) {\n  if (!(a.RTCPeerConnection && a.RTCPeerConnection.prototype))\n    return;\n  const c = a.RTCPeerConnection.prototype.addIceCandidate;\n  !c || c.length === 0 || (a.RTCPeerConnection.prototype.addIceCandidate = function() {\n    return arguments[0] ? (u.browser === \"chrome\" && u.version < 78 || u.browser === \"firefox\" && u.version < 68 || u.browser === \"safari\") && arguments[0] && arguments[0].candidate === \"\" ? Promise.resolve() : c.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());\n  });\n}\nfunction shimParameterlessSetLocalDescription(a, u) {\n  if (!(a.RTCPeerConnection && a.RTCPeerConnection.prototype))\n    return;\n  const c = a.RTCPeerConnection.prototype.setLocalDescription;\n  !c || c.length === 0 || (a.RTCPeerConnection.prototype.setLocalDescription = function() {\n    let v = arguments[0] || {};\n    if (typeof v != \"object\" || v.type && v.sdp)\n      return c.apply(this, arguments);\n    if (v = {\n      type: v.type,\n      sdp: v.sdp\n    }, !v.type)\n      switch (this.signalingState) {\n        case \"stable\":\n        case \"have-local-offer\":\n        case \"have-remote-pranswer\":\n          v.type = \"offer\";\n          break;\n        default:\n          v.type = \"answer\";\n          break;\n      }\n    return v.sdp || v.type !== \"offer\" && v.type !== \"answer\" ? c.apply(this, [v]) : (v.type === \"offer\" ? this.createOffer : this.createAnswer).apply(this).then((g) => c.apply(this, [g]));\n  });\n}\nvar commonShim = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  removeExtmapAllowMixed,\n  shimAddIceCandidateNullOrEmpty,\n  shimConnectionState,\n  shimMaxMessageSize,\n  shimParameterlessSetLocalDescription,\n  shimRTCIceCandidate,\n  shimRTCIceCandidateRelayProtocol,\n  shimSendThrowTypeError\n});\nfunction adapterFactory() {\n  let {\n    window: a\n  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n    shimChrome: !0,\n    shimFirefox: !0,\n    shimSafari: !0\n  };\n  const c = log, l = detectBrowser(a), v = {\n    browserDetails: l,\n    commonShim,\n    extractVersion,\n    disableLog,\n    disableWarnings,\n    // Expose sdp as a convenience. For production apps include directly.\n    sdp\n  };\n  switch (l.browser) {\n    case \"chrome\":\n      if (!chromeShim || !shimPeerConnection$1 || !u.shimChrome)\n        return c(\"Chrome shim is not included in this adapter release.\"), v;\n      if (l.version === null)\n        return c(\"Chrome shim can not determine version, not shimming.\"), v;\n      c(\"adapter.js shimming chrome.\"), v.browserShim = chromeShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimGetUserMedia$2(a, l), shimMediaStream(a), shimPeerConnection$1(a, l), shimOnTrack$1(a), shimAddTrackRemoveTrack(a, l), shimGetSendersWithDtmf(a), shimGetStats(a), shimSenderReceiverGetStats(a), fixNegotiationNeeded(a, l), shimRTCIceCandidate(a), shimRTCIceCandidateRelayProtocol(a), shimConnectionState(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a), removeExtmapAllowMixed(a, l);\n      break;\n    case \"firefox\":\n      if (!firefoxShim || !shimPeerConnection || !u.shimFirefox)\n        return c(\"Firefox shim is not included in this adapter release.\"), v;\n      c(\"adapter.js shimming firefox.\"), v.browserShim = firefoxShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimGetUserMedia$1(a, l), shimPeerConnection(a, l), shimOnTrack(a), shimRemoveStream(a), shimSenderGetStats(a), shimReceiverGetStats(a), shimRTCDataChannel(a), shimAddTransceiver(a), shimGetParameters(a), shimCreateOffer(a), shimCreateAnswer(a), shimRTCIceCandidate(a), shimConnectionState(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a);\n      break;\n    case \"safari\":\n      if (!safariShim || !u.shimSafari)\n        return c(\"Safari shim is not included in this adapter release.\"), v;\n      c(\"adapter.js shimming safari.\"), v.browserShim = safariShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimRTCIceServerUrls(a), shimCreateOfferLegacy(a), shimCallbacksAPI(a), shimLocalStreamsAPI(a), shimRemoteStreamsAPI(a), shimTrackEventTransceiver(a), shimGetUserMedia(a), shimAudioContext(a), shimRTCIceCandidate(a), shimRTCIceCandidateRelayProtocol(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a), removeExtmapAllowMixed(a, l);\n      break;\n    default:\n      c(\"Unsupported browser!\");\n      break;\n  }\n  return v;\n}\nadapterFactory({\n  window: typeof window > \"u\" ? void 0 : window\n});\nconst DECRYPTION_FAILURE_TOLERANCE = 10, E2EE_FLAG = \"lk_e2ee\", SALT = \"LKFrameEncryptionKey\", KEY_PROVIDER_DEFAULTS = {\n  sharedKey: !1,\n  ratchetSalt: SALT,\n  ratchetWindowSize: 8,\n  failureTolerance: DECRYPTION_FAILURE_TOLERANCE\n};\nvar KeyProviderEvent;\n(function(a) {\n  a.SetKey = \"setKey\", a.RatchetRequest = \"ratchetRequest\", a.KeyRatcheted = \"keyRatcheted\";\n})(KeyProviderEvent || (KeyProviderEvent = {}));\nvar KeyHandlerEvent;\n(function(a) {\n  a.KeyRatcheted = \"keyRatcheted\";\n})(KeyHandlerEvent || (KeyHandlerEvent = {}));\nvar EncryptionEvent;\n(function(a) {\n  a.ParticipantEncryptionStatusChanged = \"participantEncryptionStatusChanged\", a.EncryptionError = \"encryptionError\";\n})(EncryptionEvent || (EncryptionEvent = {}));\nvar CryptorEvent;\n(function(a) {\n  a.Error = \"cryptorError\";\n})(CryptorEvent || (CryptorEvent = {}));\nfunction isE2EESupported() {\n  return isInsertableStreamSupported() || isScriptTransformSupported();\n}\nfunction isScriptTransformSupported() {\n  return typeof window.RTCRtpScriptTransform < \"u\";\n}\nfunction isInsertableStreamSupported() {\n  return typeof window.RTCRtpSender < \"u\" && // @ts-ignore\n  typeof window.RTCRtpSender.prototype.createEncodedStreams < \"u\";\n}\nclass BaseKeyProvider extends eventsExports.EventEmitter {\n  constructor() {\n    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    super(), this.onKeyRatcheted = (c, l) => {\n      livekitLogger.debug(\"key ratcheted event received\", {\n        material: c,\n        keyIndex: l\n      });\n    }, this.keyInfoMap = /* @__PURE__ */ new Map(), this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), u), this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);\n  }\n  /**\n   * callback to invoke once a key has been set for a participant\n   * @param key\n   * @param participantIdentity\n   * @param keyIndex\n   */\n  onSetEncryptionKey(u, c, l) {\n    const v = {\n      key: u,\n      participantIdentity: c,\n      keyIndex: l\n    };\n    this.keyInfoMap.set(\"\".concat(c ?? \"shared\", \"-\").concat(l ?? 0), v), this.emit(KeyProviderEvent.SetKey, v);\n  }\n  getKeys() {\n    return Array.from(this.keyInfoMap.values());\n  }\n  getOptions() {\n    return this.options;\n  }\n  ratchetKey(u, c) {\n    this.emit(KeyProviderEvent.RatchetRequest, u, c);\n  }\n}\nclass LivekitError extends Error {\n  constructor(u, c) {\n    super(c || \"an error has occured\"), this.code = u;\n  }\n}\nclass ConnectionError extends LivekitError {\n  constructor(u, c, l) {\n    super(1, u), this.status = l, this.reason = c;\n  }\n}\nclass DeviceUnsupportedError extends LivekitError {\n  constructor(u) {\n    super(21, u ?? \"device is unsupported\");\n  }\n}\nclass TrackInvalidError extends LivekitError {\n  constructor(u) {\n    super(20, u ?? \"track is invalid\");\n  }\n}\nclass UnsupportedServer extends LivekitError {\n  constructor(u) {\n    super(10, u ?? \"unsupported server\");\n  }\n}\nclass UnexpectedConnectionState extends LivekitError {\n  constructor(u) {\n    super(12, u ?? \"unexpected connection state\");\n  }\n}\nclass NegotiationError extends LivekitError {\n  constructor(u) {\n    super(13, u ?? \"unable to negotiate\");\n  }\n}\nvar MediaDeviceFailure;\n(function(a) {\n  a.PermissionDenied = \"PermissionDenied\", a.NotFound = \"NotFound\", a.DeviceInUse = \"DeviceInUse\", a.Other = \"Other\";\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n(function(a) {\n  function u(c) {\n    if (c && \"name\" in c)\n      return c.name === \"NotFoundError\" || c.name === \"DevicesNotFoundError\" ? a.NotFound : c.name === \"NotAllowedError\" || c.name === \"PermissionDeniedError\" ? a.PermissionDenied : c.name === \"NotReadableError\" || c.name === \"TrackStartError\" ? a.DeviceInUse : a.Other;\n  }\n  a.getFailure = u;\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\nvar RoomEvent;\n(function(a) {\n  a.Connected = \"connected\", a.Reconnecting = \"reconnecting\", a.Reconnected = \"reconnected\", a.Disconnected = \"disconnected\", a.ConnectionStateChanged = \"connectionStateChanged\", a.MediaDevicesChanged = \"mediaDevicesChanged\", a.ParticipantConnected = \"participantConnected\", a.ParticipantDisconnected = \"participantDisconnected\", a.TrackPublished = \"trackPublished\", a.TrackSubscribed = \"trackSubscribed\", a.TrackSubscriptionFailed = \"trackSubscriptionFailed\", a.TrackUnpublished = \"trackUnpublished\", a.TrackUnsubscribed = \"trackUnsubscribed\", a.TrackMuted = \"trackMuted\", a.TrackUnmuted = \"trackUnmuted\", a.LocalTrackPublished = \"localTrackPublished\", a.LocalTrackUnpublished = \"localTrackUnpublished\", a.LocalAudioSilenceDetected = \"localAudioSilenceDetected\", a.ActiveSpeakersChanged = \"activeSpeakersChanged\", a.ParticipantMetadataChanged = \"participantMetadataChanged\", a.ParticipantNameChanged = \"participantNameChanged\", a.RoomMetadataChanged = \"roomMetadataChanged\", a.DataReceived = \"dataReceived\", a.ConnectionQualityChanged = \"connectionQualityChanged\", a.TrackStreamStateChanged = \"trackStreamStateChanged\", a.TrackSubscriptionPermissionChanged = \"trackSubscriptionPermissionChanged\", a.TrackSubscriptionStatusChanged = \"trackSubscriptionStatusChanged\", a.AudioPlaybackStatusChanged = \"audioPlaybackChanged\", a.VideoPlaybackStatusChanged = \"videoPlaybackChanged\", a.MediaDevicesError = \"mediaDevicesError\", a.ParticipantPermissionsChanged = \"participantPermissionsChanged\", a.SignalConnected = \"signalConnected\", a.RecordingStatusChanged = \"recordingStatusChanged\", a.ParticipantEncryptionStatusChanged = \"participantEncryptionStatusChanged\", a.EncryptionError = \"encryptionError\", a.DCBufferStatusChanged = \"dcBufferStatusChanged\", a.ActiveDeviceChanged = \"activeDeviceChanged\";\n})(RoomEvent || (RoomEvent = {}));\nvar ParticipantEvent;\n(function(a) {\n  a.TrackPublished = \"trackPublished\", a.TrackSubscribed = \"trackSubscribed\", a.TrackSubscriptionFailed = \"trackSubscriptionFailed\", a.TrackUnpublished = \"trackUnpublished\", a.TrackUnsubscribed = \"trackUnsubscribed\", a.TrackMuted = \"trackMuted\", a.TrackUnmuted = \"trackUnmuted\", a.LocalTrackPublished = \"localTrackPublished\", a.LocalTrackUnpublished = \"localTrackUnpublished\", a.ParticipantMetadataChanged = \"participantMetadataChanged\", a.ParticipantNameChanged = \"participantNameChanged\", a.DataReceived = \"dataReceived\", a.IsSpeakingChanged = \"isSpeakingChanged\", a.ConnectionQualityChanged = \"connectionQualityChanged\", a.TrackStreamStateChanged = \"trackStreamStateChanged\", a.TrackSubscriptionPermissionChanged = \"trackSubscriptionPermissionChanged\", a.TrackSubscriptionStatusChanged = \"trackSubscriptionStatusChanged\", a.MediaDevicesError = \"mediaDevicesError\", a.AudioStreamAcquired = \"audioStreamAcquired\", a.ParticipantPermissionsChanged = \"participantPermissionsChanged\", a.PCTrackAdded = \"pcTrackAdded\";\n})(ParticipantEvent || (ParticipantEvent = {}));\nvar EngineEvent;\n(function(a) {\n  a.TransportsCreated = \"transportsCreated\", a.Connected = \"connected\", a.Disconnected = \"disconnected\", a.Resuming = \"resuming\", a.Resumed = \"resumed\", a.Restarting = \"restarting\", a.Restarted = \"restarted\", a.SignalResumed = \"signalResumed\", a.SignalRestarted = \"signalRestarted\", a.Closing = \"closing\", a.MediaTrackAdded = \"mediaTrackAdded\", a.ActiveSpeakersUpdate = \"activeSpeakersUpdate\", a.DataPacketReceived = \"dataPacketReceived\", a.RTPVideoMapUpdate = \"rtpVideoMapUpdate\", a.DCBufferStatusChanged = \"dcBufferStatusChanged\", a.ParticipantUpdate = \"participantUpdate\", a.RoomUpdate = \"roomUpdate\", a.SpeakersChanged = \"speakersChanged\", a.StreamStateChanged = \"streamStateChanged\", a.ConnectionQualityUpdate = \"connectionQualityUpdate\", a.SubscriptionError = \"subscriptionError\", a.SubscriptionPermissionUpdate = \"subscriptionPermissionUpdate\", a.RemoteMute = \"remoteMute\", a.SubscribedQualityUpdate = \"subscribedQualityUpdate\", a.LocalTrackUnpublished = \"localTrackUnpublished\";\n})(EngineEvent || (EngineEvent = {}));\nvar TrackEvent;\n(function(a) {\n  a.Message = \"message\", a.Muted = \"muted\", a.Unmuted = \"unmuted\", a.Restarted = \"restarted\", a.Ended = \"ended\", a.Subscribed = \"subscribed\", a.Unsubscribed = \"unsubscribed\", a.UpdateSettings = \"updateSettings\", a.UpdateSubscription = \"updateSubscription\", a.AudioPlaybackStarted = \"audioPlaybackStarted\", a.AudioPlaybackFailed = \"audioPlaybackFailed\", a.AudioSilenceDetected = \"audioSilenceDetected\", a.VisibilityChanged = \"visibilityChanged\", a.VideoDimensionsChanged = \"videoDimensionsChanged\", a.VideoPlaybackStarted = \"videoPlaybackStarted\", a.VideoPlaybackFailed = \"videoPlaybackFailed\", a.ElementAttached = \"elementAttached\", a.ElementDetached = \"elementDetached\", a.UpstreamPaused = \"upstreamPaused\", a.UpstreamResumed = \"upstreamResumed\", a.SubscriptionPermissionChanged = \"subscriptionPermissionChanged\", a.SubscriptionStatusChanged = \"subscriptionStatusChanged\", a.SubscriptionFailed = \"subscriptionFailed\";\n})(TrackEvent || (TrackEvent = {}));\nfunction r(a, u, c) {\n  var l, v, S;\n  u === void 0 && (u = 50), c === void 0 && (c = {});\n  var g = (l = c.isImmediate) != null && l, E = (v = c.callback) != null && v, _ = c.maxWait, k = Date.now(), L = [];\n  function M() {\n    if (_ !== void 0) {\n      var J = Date.now() - k;\n      if (J + u >= _)\n        return _ - J;\n    }\n    return u;\n  }\n  var $ = function() {\n    var J = [].slice.call(arguments), V = this;\n    return new Promise(function(q, G) {\n      var H = g && S === void 0;\n      if (S !== void 0 && clearTimeout(S), S = setTimeout(function() {\n        if (S = void 0, k = Date.now(), !g) {\n          var Y = a.apply(V, J);\n          E && E(Y), L.forEach(function(ne) {\n            return (0, ne.resolve)(Y);\n          }), L = [];\n        }\n      }, M()), H) {\n        var B = a.apply(V, J);\n        return E && E(B), q(B);\n      }\n      L.push({\n        resolve: q,\n        reject: G\n      });\n    });\n  };\n  return $.cancel = function(J) {\n    S !== void 0 && clearTimeout(S), L.forEach(function(V) {\n      return (0, V.reject)(J);\n    }), L = [];\n  }, $;\n}\nconst commonVersionIdentifier = /version\\/(\\d+(\\.?_?\\d+)+)/i;\nlet browserDetails;\nfunction getBrowser(a) {\n  let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;\n  if (typeof a > \"u\" && typeof navigator > \"u\")\n    return;\n  const c = (a ?? navigator.userAgent).toLowerCase();\n  if (browserDetails === void 0 || u) {\n    const l = browsersList.find((v) => {\n      let {\n        test: S\n      } = v;\n      return S.test(c);\n    });\n    browserDetails = l == null ? void 0 : l.describe(c);\n  }\n  return browserDetails;\n}\nconst browsersList = [\n  {\n    test: /firefox|iceweasel|fxios/i,\n    describe(a) {\n      return {\n        name: \"Firefox\",\n        version: getMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, a),\n        os: a.toLowerCase().includes(\"fxios\") ? \"iOS\" : void 0\n      };\n    }\n  },\n  {\n    test: /chrom|crios|crmo/i,\n    describe(a) {\n      return {\n        name: \"Chrome\",\n        version: getMatch(/(?:chrome|chromium|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, a),\n        os: a.toLowerCase().includes(\"crios\") ? \"iOS\" : void 0\n      };\n    }\n  },\n  /* Safari */\n  {\n    test: /safari|applewebkit/i,\n    describe(a) {\n      return {\n        name: \"Safari\",\n        version: getMatch(commonVersionIdentifier, a),\n        os: a.includes(\"mobile/\") ? \"iOS\" : \"macOS\"\n      };\n    }\n  }\n];\nfunction getMatch(a, u) {\n  let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n  const l = u.match(a);\n  return l && l.length >= c && l[c] || \"\";\n}\nvar version$1 = \"2.0.1\";\nconst version = version$1, protocolVersion = 12;\nclass CriticalTimers {\n}\nCriticalTimers.setTimeout = function() {\n  return setTimeout(...arguments);\n};\nCriticalTimers.setInterval = function() {\n  return setInterval(...arguments);\n};\nCriticalTimers.clearTimeout = function() {\n  return clearTimeout(...arguments);\n};\nCriticalTimers.clearInterval = function() {\n  return clearInterval(...arguments);\n};\nclass VideoPreset {\n  constructor(u, c, l, v, S) {\n    this.width = u, this.height = c, this.encoding = {\n      maxBitrate: l,\n      maxFramerate: v,\n      priority: S\n    };\n  }\n  get resolution() {\n    return {\n      width: this.width,\n      height: this.height,\n      frameRate: this.encoding.maxFramerate,\n      aspectRatio: this.width / this.height\n    };\n  }\n}\nconst backupCodecs = [\"vp8\", \"h264\"], videoCodecs = [\"vp8\", \"h264\", \"vp9\", \"av1\"];\nfunction isBackupCodec(a) {\n  return !!backupCodecs.find((u) => u === a);\n}\nvar AudioPresets;\n(function(a) {\n  a.telephone = {\n    maxBitrate: 12e3\n  }, a.speech = {\n    maxBitrate: 2e4\n  }, a.music = {\n    maxBitrate: 32e3\n  }, a.musicStereo = {\n    maxBitrate: 48e3\n  }, a.musicHighQuality = {\n    maxBitrate: 64e3\n  }, a.musicHighQualityStereo = {\n    maxBitrate: 96e3\n  };\n})(AudioPresets || (AudioPresets = {}));\nconst VideoPresets = {\n  h90: new VideoPreset(160, 90, 9e4, 20),\n  h180: new VideoPreset(320, 180, 16e4, 20),\n  h216: new VideoPreset(384, 216, 18e4, 20),\n  h360: new VideoPreset(640, 360, 45e4, 20),\n  h540: new VideoPreset(960, 540, 8e5, 25),\n  h720: new VideoPreset(1280, 720, 17e5, 30),\n  h1080: new VideoPreset(1920, 1080, 3e6, 30),\n  h1440: new VideoPreset(2560, 1440, 5e6, 30),\n  h2160: new VideoPreset(3840, 2160, 8e6, 30)\n}, VideoPresets43 = {\n  h120: new VideoPreset(160, 120, 7e4, 20),\n  h180: new VideoPreset(240, 180, 125e3, 20),\n  h240: new VideoPreset(320, 240, 14e4, 20),\n  h360: new VideoPreset(480, 360, 33e4, 20),\n  h480: new VideoPreset(640, 480, 5e5, 20),\n  h540: new VideoPreset(720, 540, 6e5, 25),\n  h720: new VideoPreset(960, 720, 13e5, 30),\n  h1080: new VideoPreset(1440, 1080, 23e5, 30),\n  h1440: new VideoPreset(1920, 1440, 38e5, 30)\n}, ScreenSharePresets = {\n  h360fps3: new VideoPreset(640, 360, 2e5, 3, \"medium\"),\n  h360fps15: new VideoPreset(640, 360, 4e5, 15, \"medium\"),\n  h720fps5: new VideoPreset(1280, 720, 8e5, 5, \"medium\"),\n  h720fps15: new VideoPreset(1280, 720, 15e5, 15, \"medium\"),\n  h720fps30: new VideoPreset(1280, 720, 2e6, 30, \"medium\"),\n  h1080fps15: new VideoPreset(1920, 1080, 25e5, 15, \"medium\"),\n  h1080fps30: new VideoPreset(1920, 1080, 5e6, 30, \"medium\"),\n  // original resolution, without resizing\n  original: new VideoPreset(0, 0, 7e6, 30, \"medium\")\n};\nvar SignalTarget;\n(function(a) {\n  a[a.PUBLISHER = 0] = \"PUBLISHER\", a[a.SUBSCRIBER = 1] = \"SUBSCRIBER\";\n})(SignalTarget || (SignalTarget = {}));\nproto3.util.setEnumType(SignalTarget, \"livekit.SignalTarget\", [{\n  no: 0,\n  name: \"PUBLISHER\"\n}, {\n  no: 1,\n  name: \"SUBSCRIBER\"\n}]);\nvar StreamState;\n(function(a) {\n  a[a.ACTIVE = 0] = \"ACTIVE\", a[a.PAUSED = 1] = \"PAUSED\";\n})(StreamState || (StreamState = {}));\nproto3.util.setEnumType(StreamState, \"livekit.StreamState\", [{\n  no: 0,\n  name: \"ACTIVE\"\n}, {\n  no: 1,\n  name: \"PAUSED\"\n}]);\nvar CandidateProtocol;\n(function(a) {\n  a[a.UDP = 0] = \"UDP\", a[a.TCP = 1] = \"TCP\", a[a.TLS = 2] = \"TLS\";\n})(CandidateProtocol || (CandidateProtocol = {}));\nproto3.util.setEnumType(CandidateProtocol, \"livekit.CandidateProtocol\", [{\n  no: 0,\n  name: \"UDP\"\n}, {\n  no: 1,\n  name: \"TCP\"\n}, {\n  no: 2,\n  name: \"TLS\"\n}]);\nclass SignalRequest extends Message {\n  constructor(u) {\n    super(), this.message = {\n      case: void 0\n    }, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new SignalRequest().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new SignalRequest().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new SignalRequest().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(SignalRequest, u, c);\n  }\n}\nSignalRequest.runtime = proto3;\nSignalRequest.typeName = \"livekit.SignalRequest\";\nSignalRequest.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"offer\",\n  kind: \"message\",\n  T: SessionDescription,\n  oneof: \"message\"\n}, {\n  no: 2,\n  name: \"answer\",\n  kind: \"message\",\n  T: SessionDescription,\n  oneof: \"message\"\n}, {\n  no: 3,\n  name: \"trickle\",\n  kind: \"message\",\n  T: TrickleRequest,\n  oneof: \"message\"\n}, {\n  no: 4,\n  name: \"add_track\",\n  kind: \"message\",\n  T: AddTrackRequest,\n  oneof: \"message\"\n}, {\n  no: 5,\n  name: \"mute\",\n  kind: \"message\",\n  T: MuteTrackRequest,\n  oneof: \"message\"\n}, {\n  no: 6,\n  name: \"subscription\",\n  kind: \"message\",\n  T: UpdateSubscription,\n  oneof: \"message\"\n}, {\n  no: 7,\n  name: \"track_setting\",\n  kind: \"message\",\n  T: UpdateTrackSettings,\n  oneof: \"message\"\n}, {\n  no: 8,\n  name: \"leave\",\n  kind: \"message\",\n  T: LeaveRequest,\n  oneof: \"message\"\n}, {\n  no: 10,\n  name: \"update_layers\",\n  kind: \"message\",\n  T: UpdateVideoLayers,\n  oneof: \"message\"\n}, {\n  no: 11,\n  name: \"subscription_permission\",\n  kind: \"message\",\n  T: SubscriptionPermission,\n  oneof: \"message\"\n}, {\n  no: 12,\n  name: \"sync_state\",\n  kind: \"message\",\n  T: SyncState,\n  oneof: \"message\"\n}, {\n  no: 13,\n  name: \"simulate\",\n  kind: \"message\",\n  T: SimulateScenario,\n  oneof: \"message\"\n}, {\n  no: 14,\n  name: \"ping\",\n  kind: \"scalar\",\n  T: 3,\n  oneof: \"message\"\n}, {\n  no: 15,\n  name: \"update_metadata\",\n  kind: \"message\",\n  T: UpdateParticipantMetadata,\n  oneof: \"message\"\n}, {\n  no: 16,\n  name: \"ping_req\",\n  kind: \"message\",\n  T: Ping,\n  oneof: \"message\"\n}]);\nclass SignalResponse extends Message {\n  constructor(u) {\n    super(), this.message = {\n      case: void 0\n    }, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new SignalResponse().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new SignalResponse().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new SignalResponse().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(SignalResponse, u, c);\n  }\n}\nSignalResponse.runtime = proto3;\nSignalResponse.typeName = \"livekit.SignalResponse\";\nSignalResponse.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"join\",\n  kind: \"message\",\n  T: JoinResponse,\n  oneof: \"message\"\n}, {\n  no: 2,\n  name: \"answer\",\n  kind: \"message\",\n  T: SessionDescription,\n  oneof: \"message\"\n}, {\n  no: 3,\n  name: \"offer\",\n  kind: \"message\",\n  T: SessionDescription,\n  oneof: \"message\"\n}, {\n  no: 4,\n  name: \"trickle\",\n  kind: \"message\",\n  T: TrickleRequest,\n  oneof: \"message\"\n}, {\n  no: 5,\n  name: \"update\",\n  kind: \"message\",\n  T: ParticipantUpdate,\n  oneof: \"message\"\n}, {\n  no: 6,\n  name: \"track_published\",\n  kind: \"message\",\n  T: TrackPublishedResponse,\n  oneof: \"message\"\n}, {\n  no: 8,\n  name: \"leave\",\n  kind: \"message\",\n  T: LeaveRequest,\n  oneof: \"message\"\n}, {\n  no: 9,\n  name: \"mute\",\n  kind: \"message\",\n  T: MuteTrackRequest,\n  oneof: \"message\"\n}, {\n  no: 10,\n  name: \"speakers_changed\",\n  kind: \"message\",\n  T: SpeakersChanged,\n  oneof: \"message\"\n}, {\n  no: 11,\n  name: \"room_update\",\n  kind: \"message\",\n  T: RoomUpdate,\n  oneof: \"message\"\n}, {\n  no: 12,\n  name: \"connection_quality\",\n  kind: \"message\",\n  T: ConnectionQualityUpdate,\n  oneof: \"message\"\n}, {\n  no: 13,\n  name: \"stream_state_update\",\n  kind: \"message\",\n  T: StreamStateUpdate,\n  oneof: \"message\"\n}, {\n  no: 14,\n  name: \"subscribed_quality_update\",\n  kind: \"message\",\n  T: SubscribedQualityUpdate,\n  oneof: \"message\"\n}, {\n  no: 15,\n  name: \"subscription_permission_update\",\n  kind: \"message\",\n  T: SubscriptionPermissionUpdate,\n  oneof: \"message\"\n}, {\n  no: 16,\n  name: \"refresh_token\",\n  kind: \"scalar\",\n  T: 9,\n  oneof: \"message\"\n}, {\n  no: 17,\n  name: \"track_unpublished\",\n  kind: \"message\",\n  T: TrackUnpublishedResponse,\n  oneof: \"message\"\n}, {\n  no: 18,\n  name: \"pong\",\n  kind: \"scalar\",\n  T: 3,\n  oneof: \"message\"\n}, {\n  no: 19,\n  name: \"reconnect\",\n  kind: \"message\",\n  T: ReconnectResponse,\n  oneof: \"message\"\n}, {\n  no: 20,\n  name: \"pong_resp\",\n  kind: \"message\",\n  T: Pong,\n  oneof: \"message\"\n}, {\n  no: 21,\n  name: \"subscription_response\",\n  kind: \"message\",\n  T: SubscriptionResponse,\n  oneof: \"message\"\n}]);\nclass SimulcastCodec extends Message {\n  constructor(u) {\n    super(), this.codec = \"\", this.cid = \"\", proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new SimulcastCodec().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new SimulcastCodec().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new SimulcastCodec().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(SimulcastCodec, u, c);\n  }\n}\nSimulcastCodec.runtime = proto3;\nSimulcastCodec.typeName = \"livekit.SimulcastCodec\";\nSimulcastCodec.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"codec\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"cid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nclass AddTrackRequest extends Message {\n  constructor(u) {\n    super(), this.cid = \"\", this.name = \"\", this.type = TrackType.AUDIO, this.width = 0, this.height = 0, this.muted = !1, this.disableDtx = !1, this.source = TrackSource.UNKNOWN, this.layers = [], this.simulcastCodecs = [], this.sid = \"\", this.stereo = !1, this.disableRed = !1, this.encryption = Encryption_Type.NONE, this.stream = \"\", proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new AddTrackRequest().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new AddTrackRequest().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new AddTrackRequest().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(AddTrackRequest, u, c);\n  }\n}\nAddTrackRequest.runtime = proto3;\nAddTrackRequest.typeName = \"livekit.AddTrackRequest\";\nAddTrackRequest.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"cid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"type\",\n  kind: \"enum\",\n  T: proto3.getEnumType(TrackType)\n}, {\n  no: 4,\n  name: \"width\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 5,\n  name: \"height\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 6,\n  name: \"muted\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 7,\n  name: \"disable_dtx\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 8,\n  name: \"source\",\n  kind: \"enum\",\n  T: proto3.getEnumType(TrackSource)\n}, {\n  no: 9,\n  name: \"layers\",\n  kind: \"message\",\n  T: VideoLayer,\n  repeated: !0\n}, {\n  no: 10,\n  name: \"simulcast_codecs\",\n  kind: \"message\",\n  T: SimulcastCodec,\n  repeated: !0\n}, {\n  no: 11,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 12,\n  name: \"stereo\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 13,\n  name: \"disable_red\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 14,\n  name: \"encryption\",\n  kind: \"enum\",\n  T: proto3.getEnumType(Encryption_Type)\n}, {\n  no: 15,\n  name: \"stream\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nclass TrickleRequest extends Message {\n  constructor(u) {\n    super(), this.candidateInit = \"\", this.target = SignalTarget.PUBLISHER, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new TrickleRequest().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new TrickleRequest().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new TrickleRequest().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(TrickleRequest, u, c);\n  }\n}\nTrickleRequest.runtime = proto3;\nTrickleRequest.typeName = \"livekit.TrickleRequest\";\nTrickleRequest.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"candidateInit\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"target\",\n  kind: \"enum\",\n  T: proto3.getEnumType(SignalTarget)\n}]);\nclass MuteTrackRequest extends Message {\n  constructor(u) {\n    super(), this.sid = \"\", this.muted = !1, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new MuteTrackRequest().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new MuteTrackRequest().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new MuteTrackRequest().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(MuteTrackRequest, u, c);\n  }\n}\nMuteTrackRequest.runtime = proto3;\nMuteTrackRequest.typeName = \"livekit.MuteTrackRequest\";\nMuteTrackRequest.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"muted\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nclass JoinResponse extends Message {\n  constructor(u) {\n    super(), this.otherParticipants = [], this.serverVersion = \"\", this.iceServers = [], this.subscriberPrimary = !1, this.alternativeUrl = \"\", this.serverRegion = \"\", this.pingTimeout = 0, this.pingInterval = 0, this.sifTrailer = new Uint8Array(0), proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new JoinResponse().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new JoinResponse().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new JoinResponse().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(JoinResponse, u, c);\n  }\n}\nJoinResponse.runtime = proto3;\nJoinResponse.typeName = \"livekit.JoinResponse\";\nJoinResponse.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"room\",\n  kind: \"message\",\n  T: Room$1\n}, {\n  no: 2,\n  name: \"participant\",\n  kind: \"message\",\n  T: ParticipantInfo\n}, {\n  no: 3,\n  name: \"other_participants\",\n  kind: \"message\",\n  T: ParticipantInfo,\n  repeated: !0\n}, {\n  no: 4,\n  name: \"server_version\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 5,\n  name: \"ice_servers\",\n  kind: \"message\",\n  T: ICEServer,\n  repeated: !0\n}, {\n  no: 6,\n  name: \"subscriber_primary\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 7,\n  name: \"alternative_url\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 8,\n  name: \"client_configuration\",\n  kind: \"message\",\n  T: ClientConfiguration\n}, {\n  no: 9,\n  name: \"server_region\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 10,\n  name: \"ping_timeout\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 11,\n  name: \"ping_interval\",\n  kind: \"scalar\",\n  T: 5\n  /* ScalarType.INT32 */\n}, {\n  no: 12,\n  name: \"server_info\",\n  kind: \"message\",\n  T: ServerInfo\n}, {\n  no: 13,\n  name: \"sif_trailer\",\n  kind: \"scalar\",\n  T: 12\n  /* ScalarType.BYTES */\n}]);\nclass ReconnectResponse extends Message {\n  constructor(u) {\n    super(), this.iceServers = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new ReconnectResponse().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new ReconnectResponse().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new ReconnectResponse().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(ReconnectResponse, u, c);\n  }\n}\nReconnectResponse.runtime = proto3;\nReconnectResponse.typeName = \"livekit.ReconnectResponse\";\nReconnectResponse.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"ice_servers\",\n  kind: \"message\",\n  T: ICEServer,\n  repeated: !0\n}, {\n  no: 2,\n  name: \"client_configuration\",\n  kind: \"message\",\n  T: ClientConfiguration\n}]);\nclass TrackPublishedResponse extends Message {\n  constructor(u) {\n    super(), this.cid = \"\", proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new TrackPublishedResponse().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new TrackPublishedResponse().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new TrackPublishedResponse().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(TrackPublishedResponse, u, c);\n  }\n}\nTrackPublishedResponse.runtime = proto3;\nTrackPublishedResponse.typeName = \"livekit.TrackPublishedResponse\";\nTrackPublishedResponse.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"cid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"track\",\n  kind: \"message\",\n  T: TrackInfo\n}]);\nclass TrackUnpublishedResponse extends Message {\n  constructor(u) {\n    super(), this.trackSid = \"\", proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new TrackUnpublishedResponse().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new TrackUnpublishedResponse().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new TrackUnpublishedResponse().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(TrackUnpublishedResponse, u, c);\n  }\n}\nTrackUnpublishedResponse.runtime = proto3;\nTrackUnpublishedResponse.typeName = \"livekit.TrackUnpublishedResponse\";\nTrackUnpublishedResponse.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nclass SessionDescription extends Message {\n  constructor(u) {\n    super(), this.type = \"\", this.sdp = \"\", proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new SessionDescription().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new SessionDescription().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new SessionDescription().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(SessionDescription, u, c);\n  }\n}\nSessionDescription.runtime = proto3;\nSessionDescription.typeName = \"livekit.SessionDescription\";\nSessionDescription.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"type\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"sdp\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nclass ParticipantUpdate extends Message {\n  constructor(u) {\n    super(), this.participants = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new ParticipantUpdate().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new ParticipantUpdate().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new ParticipantUpdate().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(ParticipantUpdate, u, c);\n  }\n}\nParticipantUpdate.runtime = proto3;\nParticipantUpdate.typeName = \"livekit.ParticipantUpdate\";\nParticipantUpdate.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"participants\",\n  kind: \"message\",\n  T: ParticipantInfo,\n  repeated: !0\n}]);\nclass UpdateSubscription extends Message {\n  constructor(u) {\n    super(), this.trackSids = [], this.subscribe = !1, this.participantTracks = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new UpdateSubscription().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new UpdateSubscription().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new UpdateSubscription().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(UpdateSubscription, u, c);\n  }\n}\nUpdateSubscription.runtime = proto3;\nUpdateSubscription.typeName = \"livekit.UpdateSubscription\";\nUpdateSubscription.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"track_sids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: !0\n}, {\n  no: 2,\n  name: \"subscribe\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 3,\n  name: \"participant_tracks\",\n  kind: \"message\",\n  T: ParticipantTracks,\n  repeated: !0\n}]);\nclass UpdateTrackSettings extends Message {\n  constructor(u) {\n    super(), this.trackSids = [], this.disabled = !1, this.quality = VideoQuality$1.LOW, this.width = 0, this.height = 0, this.fps = 0, this.priority = 0, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new UpdateTrackSettings().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new UpdateTrackSettings().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new UpdateTrackSettings().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(UpdateTrackSettings, u, c);\n  }\n}\nUpdateTrackSettings.runtime = proto3;\nUpdateTrackSettings.typeName = \"livekit.UpdateTrackSettings\";\nUpdateTrackSettings.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"track_sids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: !0\n}, {\n  no: 3,\n  name: \"disabled\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 4,\n  name: \"quality\",\n  kind: \"enum\",\n  T: proto3.getEnumType(VideoQuality$1)\n}, {\n  no: 5,\n  name: \"width\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 6,\n  name: \"height\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 7,\n  name: \"fps\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 8,\n  name: \"priority\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}]);\nclass LeaveRequest extends Message {\n  constructor(u) {\n    super(), this.canReconnect = !1, this.reason = DisconnectReason.UNKNOWN_REASON, this.action = LeaveRequest_Action.DISCONNECT, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new LeaveRequest().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new LeaveRequest().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new LeaveRequest().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(LeaveRequest, u, c);\n  }\n}\nLeaveRequest.runtime = proto3;\nLeaveRequest.typeName = \"livekit.LeaveRequest\";\nLeaveRequest.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"can_reconnect\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 2,\n  name: \"reason\",\n  kind: \"enum\",\n  T: proto3.getEnumType(DisconnectReason)\n}, {\n  no: 3,\n  name: \"action\",\n  kind: \"enum\",\n  T: proto3.getEnumType(LeaveRequest_Action)\n}, {\n  no: 4,\n  name: \"regions\",\n  kind: \"message\",\n  T: RegionSettings\n}]);\nvar LeaveRequest_Action;\n(function(a) {\n  a[a.DISCONNECT = 0] = \"DISCONNECT\", a[a.RESUME = 1] = \"RESUME\", a[a.RECONNECT = 2] = \"RECONNECT\";\n})(LeaveRequest_Action || (LeaveRequest_Action = {}));\nproto3.util.setEnumType(LeaveRequest_Action, \"livekit.LeaveRequest.Action\", [{\n  no: 0,\n  name: \"DISCONNECT\"\n}, {\n  no: 1,\n  name: \"RESUME\"\n}, {\n  no: 2,\n  name: \"RECONNECT\"\n}]);\nclass UpdateVideoLayers extends Message {\n  constructor(u) {\n    super(), this.trackSid = \"\", this.layers = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new UpdateVideoLayers().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new UpdateVideoLayers().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new UpdateVideoLayers().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(UpdateVideoLayers, u, c);\n  }\n}\nUpdateVideoLayers.runtime = proto3;\nUpdateVideoLayers.typeName = \"livekit.UpdateVideoLayers\";\nUpdateVideoLayers.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"layers\",\n  kind: \"message\",\n  T: VideoLayer,\n  repeated: !0\n}]);\nclass UpdateParticipantMetadata extends Message {\n  constructor(u) {\n    super(), this.metadata = \"\", this.name = \"\", proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new UpdateParticipantMetadata().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new UpdateParticipantMetadata().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new UpdateParticipantMetadata().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(UpdateParticipantMetadata, u, c);\n  }\n}\nUpdateParticipantMetadata.runtime = proto3;\nUpdateParticipantMetadata.typeName = \"livekit.UpdateParticipantMetadata\";\nUpdateParticipantMetadata.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"metadata\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"name\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nclass ICEServer extends Message {\n  constructor(u) {\n    super(), this.urls = [], this.username = \"\", this.credential = \"\", proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new ICEServer().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new ICEServer().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new ICEServer().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(ICEServer, u, c);\n  }\n}\nICEServer.runtime = proto3;\nICEServer.typeName = \"livekit.ICEServer\";\nICEServer.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"urls\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: !0\n}, {\n  no: 2,\n  name: \"username\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"credential\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nclass SpeakersChanged extends Message {\n  constructor(u) {\n    super(), this.speakers = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new SpeakersChanged().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new SpeakersChanged().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new SpeakersChanged().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(SpeakersChanged, u, c);\n  }\n}\nSpeakersChanged.runtime = proto3;\nSpeakersChanged.typeName = \"livekit.SpeakersChanged\";\nSpeakersChanged.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"speakers\",\n  kind: \"message\",\n  T: SpeakerInfo,\n  repeated: !0\n}]);\nclass RoomUpdate extends Message {\n  constructor(u) {\n    super(), proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new RoomUpdate().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new RoomUpdate().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new RoomUpdate().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(RoomUpdate, u, c);\n  }\n}\nRoomUpdate.runtime = proto3;\nRoomUpdate.typeName = \"livekit.RoomUpdate\";\nRoomUpdate.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"room\",\n  kind: \"message\",\n  T: Room$1\n}]);\nclass ConnectionQualityInfo extends Message {\n  constructor(u) {\n    super(), this.participantSid = \"\", this.quality = ConnectionQuality$1.POOR, this.score = 0, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new ConnectionQualityInfo().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new ConnectionQualityInfo().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new ConnectionQualityInfo().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(ConnectionQualityInfo, u, c);\n  }\n}\nConnectionQualityInfo.runtime = proto3;\nConnectionQualityInfo.typeName = \"livekit.ConnectionQualityInfo\";\nConnectionQualityInfo.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"quality\",\n  kind: \"enum\",\n  T: proto3.getEnumType(ConnectionQuality$1)\n}, {\n  no: 3,\n  name: \"score\",\n  kind: \"scalar\",\n  T: 2\n  /* ScalarType.FLOAT */\n}]);\nclass ConnectionQualityUpdate extends Message {\n  constructor(u) {\n    super(), this.updates = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new ConnectionQualityUpdate().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new ConnectionQualityUpdate().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new ConnectionQualityUpdate().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(ConnectionQualityUpdate, u, c);\n  }\n}\nConnectionQualityUpdate.runtime = proto3;\nConnectionQualityUpdate.typeName = \"livekit.ConnectionQualityUpdate\";\nConnectionQualityUpdate.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"updates\",\n  kind: \"message\",\n  T: ConnectionQualityInfo,\n  repeated: !0\n}]);\nclass StreamStateInfo extends Message {\n  constructor(u) {\n    super(), this.participantSid = \"\", this.trackSid = \"\", this.state = StreamState.ACTIVE, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new StreamStateInfo().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new StreamStateInfo().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new StreamStateInfo().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(StreamStateInfo, u, c);\n  }\n}\nStreamStateInfo.runtime = proto3;\nStreamStateInfo.typeName = \"livekit.StreamStateInfo\";\nStreamStateInfo.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"state\",\n  kind: \"enum\",\n  T: proto3.getEnumType(StreamState)\n}]);\nclass StreamStateUpdate extends Message {\n  constructor(u) {\n    super(), this.streamStates = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new StreamStateUpdate().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new StreamStateUpdate().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new StreamStateUpdate().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(StreamStateUpdate, u, c);\n  }\n}\nStreamStateUpdate.runtime = proto3;\nStreamStateUpdate.typeName = \"livekit.StreamStateUpdate\";\nStreamStateUpdate.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"stream_states\",\n  kind: \"message\",\n  T: StreamStateInfo,\n  repeated: !0\n}]);\nclass SubscribedQuality extends Message {\n  constructor(u) {\n    super(), this.quality = VideoQuality$1.LOW, this.enabled = !1, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new SubscribedQuality().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new SubscribedQuality().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new SubscribedQuality().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(SubscribedQuality, u, c);\n  }\n}\nSubscribedQuality.runtime = proto3;\nSubscribedQuality.typeName = \"livekit.SubscribedQuality\";\nSubscribedQuality.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"quality\",\n  kind: \"enum\",\n  T: proto3.getEnumType(VideoQuality$1)\n}, {\n  no: 2,\n  name: \"enabled\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nclass SubscribedCodec extends Message {\n  constructor(u) {\n    super(), this.codec = \"\", this.qualities = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new SubscribedCodec().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new SubscribedCodec().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new SubscribedCodec().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(SubscribedCodec, u, c);\n  }\n}\nSubscribedCodec.runtime = proto3;\nSubscribedCodec.typeName = \"livekit.SubscribedCodec\";\nSubscribedCodec.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"codec\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"qualities\",\n  kind: \"message\",\n  T: SubscribedQuality,\n  repeated: !0\n}]);\nclass SubscribedQualityUpdate extends Message {\n  constructor(u) {\n    super(), this.trackSid = \"\", this.subscribedQualities = [], this.subscribedCodecs = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new SubscribedQualityUpdate().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new SubscribedQualityUpdate().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new SubscribedQualityUpdate().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(SubscribedQualityUpdate, u, c);\n  }\n}\nSubscribedQualityUpdate.runtime = proto3;\nSubscribedQualityUpdate.typeName = \"livekit.SubscribedQualityUpdate\";\nSubscribedQualityUpdate.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"subscribed_qualities\",\n  kind: \"message\",\n  T: SubscribedQuality,\n  repeated: !0\n}, {\n  no: 3,\n  name: \"subscribed_codecs\",\n  kind: \"message\",\n  T: SubscribedCodec,\n  repeated: !0\n}]);\nclass TrackPermission extends Message {\n  constructor(u) {\n    super(), this.participantSid = \"\", this.allTracks = !1, this.trackSids = [], this.participantIdentity = \"\", proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new TrackPermission().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new TrackPermission().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new TrackPermission().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(TrackPermission, u, c);\n  }\n}\nTrackPermission.runtime = proto3;\nTrackPermission.typeName = \"livekit.TrackPermission\";\nTrackPermission.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"all_tracks\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 3,\n  name: \"track_sids\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: !0\n}, {\n  no: 4,\n  name: \"participant_identity\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}]);\nclass SubscriptionPermission extends Message {\n  constructor(u) {\n    super(), this.allParticipants = !1, this.trackPermissions = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new SubscriptionPermission().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new SubscriptionPermission().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new SubscriptionPermission().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(SubscriptionPermission, u, c);\n  }\n}\nSubscriptionPermission.runtime = proto3;\nSubscriptionPermission.typeName = \"livekit.SubscriptionPermission\";\nSubscriptionPermission.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"all_participants\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}, {\n  no: 2,\n  name: \"track_permissions\",\n  kind: \"message\",\n  T: TrackPermission,\n  repeated: !0\n}]);\nclass SubscriptionPermissionUpdate extends Message {\n  constructor(u) {\n    super(), this.participantSid = \"\", this.trackSid = \"\", this.allowed = !1, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new SubscriptionPermissionUpdate().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new SubscriptionPermissionUpdate().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new SubscriptionPermissionUpdate().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(SubscriptionPermissionUpdate, u, c);\n  }\n}\nSubscriptionPermissionUpdate.runtime = proto3;\nSubscriptionPermissionUpdate.typeName = \"livekit.SubscriptionPermissionUpdate\";\nSubscriptionPermissionUpdate.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"participant_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"allowed\",\n  kind: \"scalar\",\n  T: 8\n  /* ScalarType.BOOL */\n}]);\nclass SyncState extends Message {\n  constructor(u) {\n    super(), this.publishTracks = [], this.dataChannels = [], this.trackSidsDisabled = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new SyncState().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new SyncState().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new SyncState().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(SyncState, u, c);\n  }\n}\nSyncState.runtime = proto3;\nSyncState.typeName = \"livekit.SyncState\";\nSyncState.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"answer\",\n  kind: \"message\",\n  T: SessionDescription\n}, {\n  no: 2,\n  name: \"subscription\",\n  kind: \"message\",\n  T: UpdateSubscription\n}, {\n  no: 3,\n  name: \"publish_tracks\",\n  kind: \"message\",\n  T: TrackPublishedResponse,\n  repeated: !0\n}, {\n  no: 4,\n  name: \"data_channels\",\n  kind: \"message\",\n  T: DataChannelInfo,\n  repeated: !0\n}, {\n  no: 5,\n  name: \"offer\",\n  kind: \"message\",\n  T: SessionDescription\n}, {\n  no: 6,\n  name: \"track_sids_disabled\",\n  kind: \"scalar\",\n  T: 9,\n  repeated: !0\n}]);\nclass DataChannelInfo extends Message {\n  constructor(u) {\n    super(), this.label = \"\", this.id = 0, this.target = SignalTarget.PUBLISHER, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new DataChannelInfo().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new DataChannelInfo().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new DataChannelInfo().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(DataChannelInfo, u, c);\n  }\n}\nDataChannelInfo.runtime = proto3;\nDataChannelInfo.typeName = \"livekit.DataChannelInfo\";\nDataChannelInfo.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"label\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"id\",\n  kind: \"scalar\",\n  T: 13\n  /* ScalarType.UINT32 */\n}, {\n  no: 3,\n  name: \"target\",\n  kind: \"enum\",\n  T: proto3.getEnumType(SignalTarget)\n}]);\nclass SimulateScenario extends Message {\n  constructor(u) {\n    super(), this.scenario = {\n      case: void 0\n    }, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new SimulateScenario().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new SimulateScenario().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new SimulateScenario().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(SimulateScenario, u, c);\n  }\n}\nSimulateScenario.runtime = proto3;\nSimulateScenario.typeName = \"livekit.SimulateScenario\";\nSimulateScenario.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"speaker_update\",\n  kind: \"scalar\",\n  T: 5,\n  oneof: \"scenario\"\n}, {\n  no: 2,\n  name: \"node_failure\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}, {\n  no: 3,\n  name: \"migration\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}, {\n  no: 4,\n  name: \"server_leave\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}, {\n  no: 5,\n  name: \"switch_candidate_protocol\",\n  kind: \"enum\",\n  T: proto3.getEnumType(CandidateProtocol),\n  oneof: \"scenario\"\n}, {\n  no: 6,\n  name: \"subscriber_bandwidth\",\n  kind: \"scalar\",\n  T: 3,\n  oneof: \"scenario\"\n}, {\n  no: 7,\n  name: \"disconnect_signal_on_resume\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}, {\n  no: 8,\n  name: \"disconnect_signal_on_resume_no_messages\",\n  kind: \"scalar\",\n  T: 8,\n  oneof: \"scenario\"\n}]);\nclass Ping extends Message {\n  constructor(u) {\n    super(), this.timestamp = protoInt64.zero, this.rtt = protoInt64.zero, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new Ping().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new Ping().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new Ping().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(Ping, u, c);\n  }\n}\nPing.runtime = proto3;\nPing.typeName = \"livekit.Ping\";\nPing.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"timestamp\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 2,\n  name: \"rtt\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}]);\nclass Pong extends Message {\n  constructor(u) {\n    super(), this.lastPingTimestamp = protoInt64.zero, this.timestamp = protoInt64.zero, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new Pong().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new Pong().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new Pong().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(Pong, u, c);\n  }\n}\nPong.runtime = proto3;\nPong.typeName = \"livekit.Pong\";\nPong.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"last_ping_timestamp\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}, {\n  no: 2,\n  name: \"timestamp\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}]);\nclass RegionSettings extends Message {\n  constructor(u) {\n    super(), this.regions = [], proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new RegionSettings().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new RegionSettings().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new RegionSettings().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(RegionSettings, u, c);\n  }\n}\nRegionSettings.runtime = proto3;\nRegionSettings.typeName = \"livekit.RegionSettings\";\nRegionSettings.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"regions\",\n  kind: \"message\",\n  T: RegionInfo,\n  repeated: !0\n}]);\nclass RegionInfo extends Message {\n  constructor(u) {\n    super(), this.region = \"\", this.url = \"\", this.distance = protoInt64.zero, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new RegionInfo().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new RegionInfo().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new RegionInfo().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(RegionInfo, u, c);\n  }\n}\nRegionInfo.runtime = proto3;\nRegionInfo.typeName = \"livekit.RegionInfo\";\nRegionInfo.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"region\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"url\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 3,\n  name: \"distance\",\n  kind: \"scalar\",\n  T: 3\n  /* ScalarType.INT64 */\n}]);\nclass SubscriptionResponse extends Message {\n  constructor(u) {\n    super(), this.trackSid = \"\", this.err = SubscriptionError.SE_UNKNOWN, proto3.util.initPartial(u, this);\n  }\n  static fromBinary(u, c) {\n    return new SubscriptionResponse().fromBinary(u, c);\n  }\n  static fromJson(u, c) {\n    return new SubscriptionResponse().fromJson(u, c);\n  }\n  static fromJsonString(u, c) {\n    return new SubscriptionResponse().fromJsonString(u, c);\n  }\n  static equals(u, c) {\n    return proto3.util.equals(SubscriptionResponse, u, c);\n  }\n}\nSubscriptionResponse.runtime = proto3;\nSubscriptionResponse.typeName = \"livekit.SubscriptionResponse\";\nSubscriptionResponse.fields = proto3.util.newFieldList(() => [{\n  no: 1,\n  name: \"track_sid\",\n  kind: \"scalar\",\n  T: 9\n  /* ScalarType.STRING */\n}, {\n  no: 2,\n  name: \"err\",\n  kind: \"enum\",\n  T: proto3.getEnumType(SubscriptionError)\n}]);\nfunction cloneDeep(a) {\n  if (!(typeof a > \"u\"))\n    return typeof structuredClone == \"function\" ? structuredClone(a) : JSON.parse(JSON.stringify(a));\n}\nconst BACKGROUND_REACTION_DELAY = 5e3, recycledElements = [];\nvar VideoQuality;\n(function(a) {\n  a[a.LOW = 0] = \"LOW\", a[a.MEDIUM = 1] = \"MEDIUM\", a[a.HIGH = 2] = \"HIGH\";\n})(VideoQuality || (VideoQuality = {}));\nclass Track extends eventsExports.EventEmitter {\n  constructor(u, c) {\n    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var v;\n    super(), this.attachedElements = [], this.isMuted = !1, this.streamState = Track.StreamState.Active, this.isInBackground = !1, this._currentBitrate = 0, this.log = livekitLogger, this.appVisibilityChangedListener = () => {\n      this.backgroundTimeout && clearTimeout(this.backgroundTimeout), document.visibilityState === \"hidden\" ? this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY) : this.handleAppVisibilityChanged();\n    }, this.log = getLogger((v = l.loggerName) !== null && v !== void 0 ? v : LoggerNames.Track), this.loggerContextCb = l.loggerContextCb, this.setMaxListeners(100), this.kind = c, this._mediaStreamTrack = u, this._mediaStreamID = u.id, this.source = Track.Source.Unknown;\n  }\n  get logContext() {\n    var u;\n    return Object.assign(Object.assign({}, (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)), getLogContextFromTrack(this));\n  }\n  /** current receive bits per second */\n  get currentBitrate() {\n    return this._currentBitrate;\n  }\n  get mediaStreamTrack() {\n    return this._mediaStreamTrack;\n  }\n  /**\n   * @internal\n   * used for keep mediaStream's first id, since it's id might change\n   * if we disable/enable a track\n   */\n  get mediaStreamID() {\n    return this._mediaStreamID;\n  }\n  attach(u) {\n    let c = \"audio\";\n    this.kind === Track.Kind.Video && (c = \"video\"), this.attachedElements.length === 0 && Track.Kind.Video && this.addAppVisibilityListener(), u || (c === \"audio\" && (recycledElements.forEach((S) => {\n      S.parentElement === null && !u && (u = S);\n    }), u && recycledElements.splice(recycledElements.indexOf(u), 1)), u || (u = document.createElement(c))), this.attachedElements.includes(u) || this.attachedElements.push(u), attachToElement(this.mediaStreamTrack, u);\n    const l = u.srcObject.getTracks(), v = l.some((S) => S.kind === \"audio\");\n    return u.play().then(() => {\n      this.emit(v ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);\n    }).catch((S) => {\n      S.name === \"NotAllowedError\" ? this.emit(v ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, S) : S.name === \"AbortError\" ? livekitLogger.debug(\"\".concat(v ? \"audio\" : \"video\", \" playback aborted, likely due to new play request\")) : livekitLogger.warn(\"could not playback \".concat(v ? \"audio\" : \"video\"), S), v && u && l.some((g) => g.kind === \"video\") && S.name === \"NotAllowedError\" && (u.muted = !0, u.play().catch(() => {\n      }));\n    }), this.emit(TrackEvent.ElementAttached, u), u;\n  }\n  detach(u) {\n    try {\n      if (u) {\n        detachTrack(this.mediaStreamTrack, u);\n        const l = this.attachedElements.indexOf(u);\n        return l >= 0 && (this.attachedElements.splice(l, 1), this.recycleElement(u), this.emit(TrackEvent.ElementDetached, u)), u;\n      }\n      const c = [];\n      return this.attachedElements.forEach((l) => {\n        detachTrack(this.mediaStreamTrack, l), c.push(l), this.recycleElement(l), this.emit(TrackEvent.ElementDetached, l);\n      }), this.attachedElements = [], c;\n    } finally {\n      this.attachedElements.length === 0 && this.removeAppVisibilityListener();\n    }\n  }\n  stop() {\n    this.stopMonitor(), this._mediaStreamTrack.stop();\n  }\n  enable() {\n    this._mediaStreamTrack.enabled = !0;\n  }\n  disable() {\n    this._mediaStreamTrack.enabled = !1;\n  }\n  /* @internal */\n  stopMonitor() {\n    this.monitorInterval && clearInterval(this.monitorInterval);\n  }\n  /** @internal */\n  updateLoggerOptions(u) {\n    u.loggerName && (this.log = getLogger(u.loggerName)), u.loggerContextCb && (this.loggerContextCb = u.loggerContextCb);\n  }\n  recycleElement(u) {\n    if (u instanceof HTMLAudioElement) {\n      let c = !0;\n      u.pause(), recycledElements.forEach((l) => {\n        l.parentElement || (c = !1);\n      }), c && recycledElements.push(u);\n    }\n  }\n  handleAppVisibilityChanged() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.isInBackground = document.visibilityState === \"hidden\";\n    });\n  }\n  addAppVisibilityListener() {\n    isWeb() ? (this.isInBackground = document.visibilityState === \"hidden\", document.addEventListener(\"visibilitychange\", this.appVisibilityChangedListener)) : this.isInBackground = !1;\n  }\n  removeAppVisibilityListener() {\n    isWeb() && document.removeEventListener(\"visibilitychange\", this.appVisibilityChangedListener);\n  }\n}\nfunction attachToElement(a, u) {\n  let c;\n  u.srcObject instanceof MediaStream ? c = u.srcObject : c = new MediaStream();\n  let l;\n  a.kind === \"audio\" ? l = c.getAudioTracks() : l = c.getVideoTracks(), l.includes(a) || (l.forEach((v) => {\n    c.removeTrack(v);\n  }), c.addTrack(a)), (!isSafari() || !(u instanceof HTMLVideoElement)) && (u.autoplay = !0), u.muted = c.getAudioTracks().length === 0, u instanceof HTMLVideoElement && (u.playsInline = !0), u.srcObject !== c && (u.srcObject = c, (isSafari() || isFireFox()) && u instanceof HTMLVideoElement && setTimeout(() => {\n    u.srcObject = c, u.play().catch(() => {\n    });\n  }, 0));\n}\nfunction detachTrack(a, u) {\n  if (u.srcObject instanceof MediaStream) {\n    const c = u.srcObject;\n    c.removeTrack(a), c.getTracks().length > 0 ? u.srcObject = c : u.srcObject = null;\n  }\n}\n(function(a) {\n  let u;\n  (function(k) {\n    k.Audio = \"audio\", k.Video = \"video\", k.Unknown = \"unknown\";\n  })(u = a.Kind || (a.Kind = {}));\n  let c;\n  (function(k) {\n    k.Camera = \"camera\", k.Microphone = \"microphone\", k.ScreenShare = \"screen_share\", k.ScreenShareAudio = \"screen_share_audio\", k.Unknown = \"unknown\";\n  })(c = a.Source || (a.Source = {}));\n  let l;\n  (function(k) {\n    k.Active = \"active\", k.Paused = \"paused\", k.Unknown = \"unknown\";\n  })(l = a.StreamState || (a.StreamState = {}));\n  function v(k) {\n    switch (k) {\n      case u.Audio:\n        return TrackType.AUDIO;\n      case u.Video:\n        return TrackType.VIDEO;\n      default:\n        return TrackType.DATA;\n    }\n  }\n  a.kindToProto = v;\n  function S(k) {\n    switch (k) {\n      case TrackType.AUDIO:\n        return u.Audio;\n      case TrackType.VIDEO:\n        return u.Video;\n      default:\n        return u.Unknown;\n    }\n  }\n  a.kindFromProto = S;\n  function g(k) {\n    switch (k) {\n      case c.Camera:\n        return TrackSource.CAMERA;\n      case c.Microphone:\n        return TrackSource.MICROPHONE;\n      case c.ScreenShare:\n        return TrackSource.SCREEN_SHARE;\n      case c.ScreenShareAudio:\n        return TrackSource.SCREEN_SHARE_AUDIO;\n      default:\n        return TrackSource.UNKNOWN;\n    }\n  }\n  a.sourceToProto = g;\n  function E(k) {\n    switch (k) {\n      case TrackSource.CAMERA:\n        return c.Camera;\n      case TrackSource.MICROPHONE:\n        return c.Microphone;\n      case TrackSource.SCREEN_SHARE:\n        return c.ScreenShare;\n      case TrackSource.SCREEN_SHARE_AUDIO:\n        return c.ScreenShareAudio;\n      default:\n        return c.Unknown;\n    }\n  }\n  a.sourceFromProto = E;\n  function _(k) {\n    switch (k) {\n      case StreamState.ACTIVE:\n        return l.Active;\n      case StreamState.PAUSED:\n        return l.Paused;\n      default:\n        return l.Unknown;\n    }\n  }\n  a.streamStateFromProto = _;\n})(Track || (Track = {}));\nfunction mergeDefaultOptions(a, u, c) {\n  var l;\n  const v = (l = cloneDeep(a)) !== null && l !== void 0 ? l : {};\n  return v.audio === !0 && (v.audio = {}), v.video === !0 && (v.video = {}), v.audio && mergeObjectWithoutOverwriting(v.audio, u), v.video && mergeObjectWithoutOverwriting(v.video, c), v;\n}\nfunction mergeObjectWithoutOverwriting(a, u) {\n  return Object.keys(u).forEach((c) => {\n    a[c] === void 0 && (a[c] = u[c]);\n  }), a;\n}\nfunction constraintsForOptions(a) {\n  const u = {};\n  if (a.video)\n    if (typeof a.video == \"object\") {\n      const c = {}, l = c, v = a.video;\n      Object.keys(v).forEach((S) => {\n        switch (S) {\n          case \"resolution\":\n            mergeObjectWithoutOverwriting(l, v.resolution);\n            break;\n          default:\n            l[S] = v[S];\n        }\n      }), u.video = c;\n    } else\n      u.video = a.video;\n  else\n    u.video = !1;\n  return a.audio ? typeof a.audio == \"object\" ? u.audio = a.audio : u.audio = !0 : u.audio = !1, u;\n}\nfunction detectSilence(a) {\n  let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;\n  return __awaiter(this, void 0, void 0, function* () {\n    const c = getNewAudioContext();\n    if (c) {\n      const l = c.createAnalyser();\n      l.fftSize = 2048;\n      const v = l.frequencyBinCount, S = new Uint8Array(v);\n      c.createMediaStreamSource(new MediaStream([a.mediaStreamTrack])).connect(l), yield sleep(u), l.getByteTimeDomainData(S);\n      const E = S.some((_) => _ !== 128 && _ !== 0);\n      return c.close(), !E;\n    }\n    return !1;\n  });\n}\nfunction getNewAudioContext() {\n  const a = (\n    // @ts-ignore\n    typeof window < \"u\" && (window.AudioContext || window.webkitAudioContext)\n  );\n  if (a)\n    return new a({\n      latencyHint: \"interactive\"\n    });\n}\nfunction sourceToKind(a) {\n  return a === Track.Source.Microphone ? \"audioinput\" : a === Track.Source.Camera ? \"videoinput\" : void 0;\n}\nfunction screenCaptureToDisplayMediaStreamOptions(a) {\n  var u, c;\n  let l = (u = a.video) !== null && u !== void 0 ? u : !0;\n  return a.resolution && a.resolution.width > 0 && a.resolution.height > 0 && (l = typeof l == \"boolean\" ? {} : l, isSafari() ? l = Object.assign(Object.assign({}, l), {\n    width: {\n      max: a.resolution.width\n    },\n    height: {\n      max: a.resolution.height\n    },\n    frameRate: a.resolution.frameRate\n  }) : l = Object.assign(Object.assign({}, l), {\n    width: {\n      ideal: a.resolution.width\n    },\n    height: {\n      ideal: a.resolution.height\n    },\n    frameRate: a.resolution.frameRate\n  })), {\n    audio: (c = a.audio) !== null && c !== void 0 ? c : !1,\n    video: l,\n    // @ts-expect-error support for experimental display media features\n    controller: a.controller,\n    selfBrowserSurface: a.selfBrowserSurface,\n    surfaceSwitching: a.surfaceSwitching,\n    systemAudio: a.systemAudio\n  };\n}\nfunction mimeTypeToVideoCodecString(a) {\n  const u = a.split(\"/\")[1].toLowerCase();\n  if (!videoCodecs.includes(u))\n    throw Error(\"Video codec not supported: \".concat(u));\n  return u;\n}\nfunction getTrackPublicationInfo(a) {\n  const u = [];\n  return a.forEach((c) => {\n    c.track !== void 0 && u.push(new TrackPublishedResponse({\n      cid: c.track.mediaStreamID,\n      track: c.trackInfo\n    }));\n  }), u;\n}\nfunction getLogContextFromTrack(a) {\n  return a instanceof Track ? {\n    trackSid: a.sid,\n    trackSource: a.source,\n    trackMuted: a.isMuted,\n    trackEnabled: a.mediaStreamTrack.enabled,\n    trackKind: a.kind\n  } : {\n    trackSid: a.trackSid,\n    trackName: a.trackName,\n    track: a.track ? getLogContextFromTrack(a.track) : void 0,\n    trackEnabled: a.isEnabled,\n    trackEncrypted: a.isEncrypted,\n    trackMimeType: a.mimeType\n  };\n}\nconst separator = \"|\", ddExtensionURI = \"https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension\";\nfunction unpackStreamId(a) {\n  const u = a.split(separator);\n  return u.length > 1 ? [u[0], a.substr(u[0].length + 1)] : [a, \"\"];\n}\nfunction sleep(a) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((u) => CriticalTimers.setTimeout(u, a));\n  });\n}\nfunction supportsTransceiver() {\n  return \"addTransceiver\" in RTCPeerConnection.prototype;\n}\nfunction supportsAddTrack() {\n  return \"addTrack\" in RTCPeerConnection.prototype;\n}\nfunction supportsAV1() {\n  if (!(\"getCapabilities\" in RTCRtpSender) || isSafari())\n    return !1;\n  const a = RTCRtpSender.getCapabilities(\"video\");\n  let u = !1;\n  if (a) {\n    for (const c of a.codecs)\n      if (c.mimeType === \"video/AV1\") {\n        u = !0;\n        break;\n      }\n  }\n  return u;\n}\nfunction supportsVP9() {\n  if (!(\"getCapabilities\" in RTCRtpSender) || isFireFox())\n    return !1;\n  if (isSafari()) {\n    const c = getBrowser();\n    if (c != null && c.version && compareVersions(c.version, \"16\") < 0)\n      return !1;\n  }\n  const a = RTCRtpSender.getCapabilities(\"video\");\n  let u = !1;\n  if (a) {\n    for (const c of a.codecs)\n      if (c.mimeType === \"video/VP9\") {\n        u = !0;\n        break;\n      }\n  }\n  return u;\n}\nfunction isSVCCodec(a) {\n  return a === \"av1\" || a === \"vp9\";\n}\nfunction supportsSetSinkId(a) {\n  return document ? (a || (a = document.createElement(\"audio\")), \"setSinkId\" in a) : !1;\n}\nconst setCodecPreferencesVersions = {\n  Chrome: \"100\",\n  Safari: \"15\",\n  Firefox: \"100\"\n};\nfunction supportsSetCodecPreferences(a) {\n  if (!isWeb() || !(\"setCodecPreferences\" in a))\n    return !1;\n  const u = getBrowser();\n  if (!(u != null && u.name) || !u.version)\n    return !1;\n  const c = setCodecPreferencesVersions[u.name];\n  return c ? compareVersions(u.version, c) >= 0 : !1;\n}\nfunction isFireFox() {\n  var a;\n  return ((a = getBrowser()) === null || a === void 0 ? void 0 : a.name) === \"Firefox\";\n}\nfunction isSafari() {\n  var a;\n  return ((a = getBrowser()) === null || a === void 0 ? void 0 : a.name) === \"Safari\";\n}\nfunction isSafari17() {\n  const a = getBrowser();\n  return (a == null ? void 0 : a.name) === \"Safari\" && a.version.startsWith(\"17.\");\n}\nfunction isMobile() {\n  return isWeb() ? /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent) : !1;\n}\nfunction isWeb() {\n  return typeof document < \"u\";\n}\nfunction isReactNative() {\n  return navigator.product == \"ReactNative\";\n}\nfunction isCloud(a) {\n  return a.hostname.endsWith(\".livekit.cloud\") || a.hostname.endsWith(\".livekit.run\");\n}\nfunction getLKReactNativeInfo() {\n  if (global && global.LiveKitReactNativeGlobal)\n    return global.LiveKitReactNativeGlobal;\n}\nfunction getReactNativeOs() {\n  if (!isReactNative())\n    return;\n  let a = getLKReactNativeInfo();\n  if (a)\n    return a.platform;\n}\nfunction getDevicePixelRatio() {\n  if (isWeb())\n    return window.devicePixelRatio;\n  if (isReactNative()) {\n    let a = getLKReactNativeInfo();\n    if (a)\n      return a.devicePixelRatio;\n  }\n  return 1;\n}\nfunction compareVersions(a, u) {\n  const c = a.split(\".\"), l = u.split(\".\"), v = Math.min(c.length, l.length);\n  for (let S = 0; S < v; ++S) {\n    const g = parseInt(c[S], 10), E = parseInt(l[S], 10);\n    if (g > E)\n      return 1;\n    if (g < E)\n      return -1;\n    if (S === v - 1 && g === E)\n      return 0;\n  }\n  return a === \"\" && u !== \"\" ? -1 : u === \"\" ? 1 : c.length == l.length ? 0 : c.length < l.length ? -1 : 1;\n}\nfunction roDispatchCallback(a) {\n  for (const u of a)\n    u.target.handleResize(u);\n}\nfunction ioDispatchCallback(a) {\n  for (const u of a)\n    u.target.handleVisibilityChanged(u);\n}\nlet resizeObserver = null;\nconst getResizeObserver = () => (resizeObserver || (resizeObserver = new ResizeObserver(roDispatchCallback)), resizeObserver);\nlet intersectionObserver = null;\nconst getIntersectionObserver = () => (intersectionObserver || (intersectionObserver = new IntersectionObserver(ioDispatchCallback, {\n  root: null,\n  rootMargin: \"0px\"\n})), intersectionObserver);\nfunction getClientInfo() {\n  var a;\n  const u = new ClientInfo({\n    sdk: ClientInfo_SDK.JS,\n    protocol: protocolVersion,\n    version\n  });\n  return isReactNative() && (u.os = (a = getReactNativeOs()) !== null && a !== void 0 ? a : \"\"), u;\n}\nfunction createDummyVideoStreamTrack() {\n  let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16, u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16, c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;\n  const v = document.createElement(\"canvas\");\n  v.width = a, v.height = u;\n  const S = v.getContext(\"2d\");\n  S == null || S.fillRect(0, 0, v.width, v.height), l && S && (S.beginPath(), S.arc(a / 2, u / 2, 50, 0, Math.PI * 2, !0), S.closePath(), S.fillStyle = \"grey\", S.fill());\n  const g = v.captureStream(), [E] = g.getTracks();\n  if (!E)\n    throw Error(\"Could not get empty media stream video track\");\n  return E.enabled = c, E;\n}\nlet emptyAudioStreamTrack;\nfunction getEmptyAudioStreamTrack() {\n  if (!emptyAudioStreamTrack) {\n    const a = new AudioContext(), u = a.createOscillator(), c = a.createGain();\n    c.gain.setValueAtTime(0, 0);\n    const l = a.createMediaStreamDestination();\n    if (u.connect(c), c.connect(l), u.start(), [emptyAudioStreamTrack] = l.stream.getAudioTracks(), !emptyAudioStreamTrack)\n      throw Error(\"Could not get empty media stream audio track\");\n    emptyAudioStreamTrack.enabled = !1;\n  }\n  return emptyAudioStreamTrack.clone();\n}\nclass Future {\n  constructor(u, c) {\n    this.onFinally = c, this.promise = new Promise((l, v) => __awaiter(this, void 0, void 0, function* () {\n      this.resolve = l, this.reject = v, u && (yield u(l, v));\n    })).finally(() => {\n      var l;\n      return (l = this.onFinally) === null || l === void 0 ? void 0 : l.call(this);\n    });\n  }\n}\nclass Mutex {\n  constructor() {\n    this._locking = Promise.resolve(), this._locks = 0;\n  }\n  isLocked() {\n    return this._locks > 0;\n  }\n  lock() {\n    this._locks += 1;\n    let u;\n    const c = new Promise((v) => u = () => {\n      this._locks -= 1, v();\n    }), l = this._locking.then(() => u);\n    return this._locking = this._locking.then(() => c), l;\n  }\n}\nfunction isVideoCodec(a) {\n  return videoCodecs.includes(a);\n}\nfunction unwrapConstraint(a) {\n  if (typeof a == \"string\")\n    return a;\n  if (Array.isArray(a))\n    return a[0];\n  if (a.exact)\n    return Array.isArray(a.exact) ? a.exact[0] : a.exact;\n  if (a.ideal)\n    return Array.isArray(a.ideal) ? a.ideal[0] : a.ideal;\n  throw Error(\"could not unwrap constraint\");\n}\nfunction toWebsocketUrl(a) {\n  return a.startsWith(\"http\") ? a.replace(/^(http)/, \"ws\") : a;\n}\nfunction toHttpUrl(a) {\n  return a.startsWith(\"ws\") ? a.replace(/^(ws)/, \"http\") : a;\n}\nconst defaultId = \"default\";\nclass DeviceManager {\n  static getInstance() {\n    return this.instance === void 0 && (this.instance = new DeviceManager()), this.instance;\n  }\n  getDevices(u) {\n    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;\n    var l;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (((l = DeviceManager.userMediaPromiseMap) === null || l === void 0 ? void 0 : l.size) > 0) {\n        livekitLogger.debug(\"awaiting getUserMedia promise\");\n        try {\n          u ? yield DeviceManager.userMediaPromiseMap.get(u) : yield Promise.all(DeviceManager.userMediaPromiseMap.values());\n        } catch {\n          livekitLogger.warn(\"error waiting for media permissons\");\n        }\n      }\n      let v = yield navigator.mediaDevices.enumerateDevices();\n      if (c && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363\n      !(isSafari() && this.hasDeviceInUse(u)) && (v.length === 0 || v.some((g) => {\n        const E = g.label === \"\", _ = u ? g.kind === u : !0;\n        return E && _;\n      }))) {\n        const g = {\n          video: u !== \"audioinput\" && u !== \"audiooutput\",\n          audio: u !== \"videoinput\"\n        }, E = yield navigator.mediaDevices.getUserMedia(g);\n        v = yield navigator.mediaDevices.enumerateDevices(), E.getTracks().forEach((_) => {\n          _.stop();\n        });\n      }\n      return u && (v = v.filter((S) => S.kind === u)), v;\n    });\n  }\n  normalizeDeviceId(u, c, l) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (c !== defaultId)\n        return c;\n      const S = (yield this.getDevices(u)).find((g) => g.groupId === l && g.deviceId !== defaultId);\n      return S == null ? void 0 : S.deviceId;\n    });\n  }\n  hasDeviceInUse(u) {\n    return u ? DeviceManager.userMediaPromiseMap.has(u) : DeviceManager.userMediaPromiseMap.size > 0;\n  }\n}\nDeviceManager.mediaDeviceKinds = [\"audioinput\", \"audiooutput\", \"videoinput\"];\nDeviceManager.userMediaPromiseMap = /* @__PURE__ */ new Map();\nconst defaultDimensionsTimeout = 1e3;\nclass LocalTrack extends Track {\n  get constraints() {\n    return this._constraints;\n  }\n  /**\n   *\n   * @param mediaTrack\n   * @param kind\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */\n  constructor(u, c, l) {\n    let v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, S = arguments.length > 4 ? arguments[4] : void 0;\n    super(u, c, S), this._isUpstreamPaused = !1, this.handleTrackMuteEvent = () => this.debouncedTrackMuteHandler().catch(() => this.log.debug(\"track mute bounce got cancelled by an unmute event\", this.logContext)), this.debouncedTrackMuteHandler = r(() => __awaiter(this, void 0, void 0, function* () {\n      yield this.pauseUpstream();\n    }), 5e3), this.handleTrackUnmuteEvent = () => __awaiter(this, void 0, void 0, function* () {\n      this.debouncedTrackMuteHandler.cancel(\"unmute\"), yield this.resumeUpstream();\n    }), this.handleEnded = () => {\n      this.isInBackground && (this.reacquireTrack = !0), this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent), this.emit(TrackEvent.Ended, this);\n    }, this.reacquireTrack = !1, this.providedByUser = v, this.muteLock = new Mutex(), this.pauseUpstreamLock = new Mutex(), this.processorLock = new Mutex(), this.setMediaStreamTrack(u, !0), this._constraints = u.getConstraints(), l && (this._constraints = l);\n  }\n  get id() {\n    return this._mediaStreamTrack.id;\n  }\n  get dimensions() {\n    if (this.kind !== Track.Kind.Video)\n      return;\n    const {\n      width: u,\n      height: c\n    } = this._mediaStreamTrack.getSettings();\n    if (u && c)\n      return {\n        width: u,\n        height: c\n      };\n  }\n  get isUpstreamPaused() {\n    return this._isUpstreamPaused;\n  }\n  get isUserProvided() {\n    return this.providedByUser;\n  }\n  get mediaStreamTrack() {\n    var u, c;\n    return (c = (u = this.processor) === null || u === void 0 ? void 0 : u.processedTrack) !== null && c !== void 0 ? c : this._mediaStreamTrack;\n  }\n  setMediaStreamTrack(u, c) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (u === this._mediaStreamTrack && !c)\n        return;\n      this._mediaStreamTrack && (this.attachedElements.forEach((v) => {\n        detachTrack(this._mediaStreamTrack, v);\n      }), this.debouncedTrackMuteHandler.cancel(\"new-track\"), this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded), this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent)), this.mediaStream = new MediaStream([u]), u && (u.addEventListener(\"ended\", this.handleEnded), u.addEventListener(\"mute\", this.handleTrackMuteEvent), u.addEventListener(\"unmute\", this.handleTrackUnmuteEvent), this._constraints = u.getConstraints());\n      let l;\n      if (this.processor && u && this.processorElement) {\n        if (this.log.debug(\"restarting processor\", this.logContext), this.kind === \"unknown\")\n          throw TypeError(\"cannot set processor on track of unknown kind\");\n        attachToElement(u, this.processorElement), this.processorElement.muted = !0, yield this.processor.restart({\n          track: u,\n          kind: this.kind,\n          element: this.processorElement\n        }), l = this.processor.processedTrack;\n      }\n      this.sender && (yield this.sender.replaceTrack(l ?? u)), !this.providedByUser && this._mediaStreamTrack !== u && this._mediaStreamTrack.stop(), this._mediaStreamTrack = u, u && (this._mediaStreamTrack.enabled = !this.isMuted, yield this.resumeUpstream(), this.attachedElements.forEach((v) => {\n        attachToElement(l ?? u, v);\n      }));\n    });\n  }\n  waitForDimensions() {\n    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDimensionsTimeout;\n    var c;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.kind === Track.Kind.Audio)\n        throw new Error(\"cannot get dimensions for audio tracks\");\n      ((c = getBrowser()) === null || c === void 0 ? void 0 : c.os) === \"iOS\" && (yield sleep(10));\n      const l = Date.now();\n      for (; Date.now() - l < u; ) {\n        const v = this.dimensions;\n        if (v)\n          return v;\n        yield sleep(50);\n      }\n      throw new TrackInvalidError(\"unable to get track dimensions after timeout\");\n    });\n  }\n  /**\n   * @returns DeviceID of the device that is currently being used for this track\n   */\n  getDeviceId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.source === Track.Source.ScreenShare)\n        return;\n      const {\n        deviceId: u,\n        groupId: c\n      } = this._mediaStreamTrack.getSettings(), l = this.kind === Track.Kind.Audio ? \"audioinput\" : \"videoinput\";\n      return DeviceManager.getInstance().normalizeDeviceId(l, u, c);\n    });\n  }\n  mute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.setTrackMuted(!0), this;\n    });\n  }\n  unmute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.setTrackMuted(!1), this;\n    });\n  }\n  replaceTrack(u) {\n    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.sender)\n        throw new TrackInvalidError(\"unable to replace an unpublished track\");\n      return this.log.debug(\"replace MediaStreamTrack\", this.logContext), yield this.setMediaStreamTrack(u), this.providedByUser = c, this.processor && (yield this.stopProcessor()), this;\n    });\n  }\n  restart(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      u || (u = this._constraints), this.log.debug(\"restarting track with constraints\", Object.assign(Object.assign({}, this.logContext), {\n        constraints: u\n      }));\n      const c = {\n        audio: !1,\n        video: !1\n      };\n      this.kind === Track.Kind.Video ? c.video = u : c.audio = u, this.attachedElements.forEach((S) => {\n        detachTrack(this.mediaStreamTrack, S);\n      }), this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded), this._mediaStreamTrack.stop();\n      const v = (yield navigator.mediaDevices.getUserMedia(c)).getTracks()[0];\n      return v.addEventListener(\"ended\", this.handleEnded), this.log.debug(\"re-acquired MediaStreamTrack\", this.logContext), yield this.setMediaStreamTrack(v), this._constraints = u, this.emit(TrackEvent.Restarted, this), this;\n    });\n  }\n  setTrackMuted(u) {\n    this.log.debug(\"setting \".concat(this.kind, \" track \").concat(u ? \"muted\" : \"unmuted\"), this.logContext), !(this.isMuted === u && this._mediaStreamTrack.enabled !== u) && (this.isMuted = u, this._mediaStreamTrack.enabled = !u, this.emit(u ? TrackEvent.Muted : TrackEvent.Unmuted, this));\n  }\n  get needsReAcquisition() {\n    return this._mediaStreamTrack.readyState !== \"live\" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;\n  }\n  handleAppVisibilityChanged() {\n    const u = Object.create(null, {\n      handleAppVisibilityChanged: {\n        get: () => super.handleAppVisibilityChanged\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      yield u.handleAppVisibilityChanged.call(this), isMobile() && (this.log.debug(\"visibility changed, is in Background: \".concat(this.isInBackground), this.logContext), !this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted && (this.log.debug(\"track needs to be reacquired, restarting \".concat(this.source), this.logContext), yield this.restart(), this.reacquireTrack = !1));\n    });\n  }\n  stop() {\n    var u;\n    super.stop(), this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded), this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent), (u = this.processor) === null || u === void 0 || u.destroy(), this.processor = void 0;\n  }\n  /**\n   * pauses publishing to the server without disabling the local MediaStreamTrack\n   * this is used to display a user's own video locally while pausing publishing to\n   * the server.\n   * this API is unsupported on Safari < 12 due to a bug\n   **/\n  pauseUpstream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const u = yield this.pauseUpstreamLock.lock();\n      try {\n        if (this._isUpstreamPaused === !0)\n          return;\n        if (!this.sender) {\n          this.log.warn(\"unable to pause upstream for an unpublished track\", this.logContext);\n          return;\n        }\n        this._isUpstreamPaused = !0, this.emit(TrackEvent.UpstreamPaused, this);\n        const c = getBrowser();\n        if ((c == null ? void 0 : c.name) === \"Safari\" && compareVersions(c.version, \"12.0\") < 0)\n          throw new DeviceUnsupportedError(\"pauseUpstream is not supported on Safari < 12.\");\n        yield this.sender.replaceTrack(null);\n      } finally {\n        u();\n      }\n    });\n  }\n  resumeUpstream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const u = yield this.pauseUpstreamLock.lock();\n      try {\n        if (this._isUpstreamPaused === !1)\n          return;\n        if (!this.sender) {\n          this.log.warn(\"unable to resume upstream for an unpublished track\", this.logContext);\n          return;\n        }\n        this._isUpstreamPaused = !1, this.emit(TrackEvent.UpstreamResumed, this), yield this.sender.replaceTrack(this._mediaStreamTrack);\n      } finally {\n        u();\n      }\n    });\n  }\n  /**\n   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */\n  getRTCStatsReport() {\n    var u;\n    return __awaiter(this, void 0, void 0, function* () {\n      return !((u = this.sender) === null || u === void 0) && u.getStats ? yield this.sender.getStats() : void 0;\n    });\n  }\n  /**\n   * Sets a processor on this track.\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   *\n   * @param processor\n   * @param showProcessedStreamLocally\n   * @returns\n   */\n  setProcessor(u) {\n    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;\n    var l, v;\n    return __awaiter(this, void 0, void 0, function* () {\n      const S = yield this.processorLock.lock();\n      try {\n        if (this.log.debug(\"setting up processor\", this.logContext), this.processor && (yield this.stopProcessor()), this.kind === \"unknown\")\n          throw TypeError(\"cannot set processor on track of unknown kind\");\n        this.processorElement = (l = this.processorElement) !== null && l !== void 0 ? l : document.createElement(this.kind), attachToElement(this._mediaStreamTrack, this.processorElement), this.processorElement.muted = !0, this.processorElement.play().catch((E) => this.log.error(\"failed to play processor element\", Object.assign(Object.assign({}, this.logContext), {\n          error: E\n        })));\n        const g = {\n          kind: this.kind,\n          track: this._mediaStreamTrack,\n          element: this.processorElement\n        };\n        if (yield u.init(g), this.processor = u, this.processor.processedTrack) {\n          for (const E of this.attachedElements)\n            E !== this.processorElement && c && (detachTrack(this._mediaStreamTrack, E), attachToElement(this.processor.processedTrack, E));\n          yield (v = this.sender) === null || v === void 0 ? void 0 : v.replaceTrack(this.processor.processedTrack);\n        }\n      } finally {\n        S();\n      }\n    });\n  }\n  getProcessor() {\n    return this.processor;\n  }\n  /**\n   * Stops the track processor\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   * @returns\n   */\n  stopProcessor() {\n    var u, c;\n    return __awaiter(this, void 0, void 0, function* () {\n      this.processor && (this.log.debug(\"stopping processor\", this.logContext), (u = this.processor.processedTrack) === null || u === void 0 || u.stop(), yield this.processor.destroy(), this.processor = void 0, (c = this.processorElement) === null || c === void 0 || c.remove(), this.processorElement = void 0, yield this.restart());\n    });\n  }\n}\nclass E2EEManager extends eventsExports.EventEmitter {\n  constructor(u) {\n    super(), this.onWorkerMessage = (c) => {\n      var l, v;\n      const {\n        kind: S,\n        data: g\n      } = c.data;\n      switch (S) {\n        case \"error\":\n          livekitLogger.error(g.error.message), this.emit(EncryptionEvent.EncryptionError, g.error);\n          break;\n        case \"initAck\":\n          g.enabled && this.keyProvider.getKeys().forEach((E) => {\n            this.postKey(E);\n          });\n          break;\n        case \"enable\":\n          if (this.encryptionEnabled !== g.enabled && g.participantIdentity === ((l = this.room) === null || l === void 0 ? void 0 : l.localParticipant.identity))\n            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, g.enabled, this.room.localParticipant), this.encryptionEnabled = g.enabled;\n          else if (g.participantIdentity) {\n            const E = (v = this.room) === null || v === void 0 ? void 0 : v.getParticipantByIdentity(g.participantIdentity);\n            if (!E)\n              throw TypeError(\"couldn't set encryption status, participant not found\".concat(g.participantIdentity));\n            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, g.enabled, E);\n          }\n          this.encryptionEnabled && this.keyProvider.getKeys().forEach((E) => {\n            this.postKey(E);\n          });\n          break;\n        case \"ratchetKey\":\n          this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, g.material, g.keyIndex);\n          break;\n      }\n    }, this.onWorkerError = (c) => {\n      livekitLogger.error(\"e2ee worker encountered an error:\", {\n        error: c.error\n      }), this.emit(EncryptionEvent.EncryptionError, c.error);\n    }, this.keyProvider = u.keyProvider, this.worker = u.worker, this.encryptionEnabled = !1;\n  }\n  /**\n   * @internal\n   */\n  setup(u) {\n    if (!isE2EESupported())\n      throw new DeviceUnsupportedError(\"tried to setup end-to-end encryption on an unsupported browser\");\n    if (livekitLogger.info(\"setting up e2ee\"), u !== this.room) {\n      this.room = u, this.setupEventListeners(u, this.keyProvider);\n      const c = {\n        kind: \"init\",\n        data: {\n          keyProviderOptions: this.keyProvider.getOptions()\n        }\n      };\n      this.worker && (livekitLogger.info(\"initializing worker\", {\n        worker: this.worker\n      }), this.worker.onmessage = this.onWorkerMessage, this.worker.onerror = this.onWorkerError, this.worker.postMessage(c));\n    }\n  }\n  /**\n   * @internal\n   */\n  setParticipantCryptorEnabled(u, c) {\n    livekitLogger.debug(\"set e2ee to \".concat(u, \" for participant \").concat(c)), this.postEnable(u, c);\n  }\n  /**\n   * @internal\n   */\n  setSifTrailer(u) {\n    !u || u.length === 0 ? livekitLogger.warn(\"ignoring server sent trailer as it's empty\") : this.postSifTrailer(u);\n  }\n  setupEngine(u) {\n    u.on(EngineEvent.RTPVideoMapUpdate, (c) => {\n      this.postRTPMap(c);\n    });\n  }\n  setupEventListeners(u, c) {\n    u.on(RoomEvent.TrackPublished, (l, v) => this.setParticipantCryptorEnabled(l.trackInfo.encryption !== Encryption_Type.NONE, v.identity)), u.on(RoomEvent.ConnectionStateChanged, (l) => {\n      l === ConnectionState.Connected && u.remoteParticipants.forEach((v) => {\n        v.trackPublications.forEach((S) => {\n          this.setParticipantCryptorEnabled(S.trackInfo.encryption !== Encryption_Type.NONE, v.identity);\n        });\n      });\n    }).on(RoomEvent.TrackUnsubscribed, (l, v, S) => {\n      var g;\n      const E = {\n        kind: \"removeTransform\",\n        data: {\n          participantIdentity: S.identity,\n          trackId: l.mediaStreamID\n        }\n      };\n      (g = this.worker) === null || g === void 0 || g.postMessage(E);\n    }).on(RoomEvent.TrackSubscribed, (l, v, S) => {\n      this.setupE2EEReceiver(l, S.identity, v.trackInfo);\n    }).on(RoomEvent.SignalConnected, () => {\n      if (!this.room)\n        throw new TypeError(\"expected room to be present on signal connect\");\n      this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity), c.getKeys().forEach((l) => {\n        this.postKey(l);\n      });\n    }), u.localParticipant.on(ParticipantEvent.LocalTrackPublished, (l) => __awaiter(this, void 0, void 0, function* () {\n      this.setupE2EESender(l.track, l.track.sender);\n    })), c.on(KeyProviderEvent.SetKey, (l) => this.postKey(l)).on(KeyProviderEvent.RatchetRequest, (l, v) => this.postRatchetRequest(l, v));\n  }\n  postRatchetRequest(u, c) {\n    if (!this.worker)\n      throw Error(\"could not ratchet key, worker is missing\");\n    const l = {\n      kind: \"ratchetRequest\",\n      data: {\n        participantIdentity: u,\n        keyIndex: c\n      }\n    };\n    this.worker.postMessage(l);\n  }\n  postKey(u) {\n    let {\n      key: c,\n      participantIdentity: l,\n      keyIndex: v\n    } = u;\n    var S;\n    if (!this.worker)\n      throw Error(\"could not set key, worker is missing\");\n    const g = {\n      kind: \"setKey\",\n      data: {\n        participantIdentity: l,\n        isPublisher: l === ((S = this.room) === null || S === void 0 ? void 0 : S.localParticipant.identity),\n        key: c,\n        keyIndex: v\n      }\n    };\n    this.worker.postMessage(g);\n  }\n  postEnable(u, c) {\n    if (this.worker) {\n      const l = {\n        kind: \"enable\",\n        data: {\n          enabled: u,\n          participantIdentity: c\n        }\n      };\n      this.worker.postMessage(l);\n    } else\n      throw new ReferenceError(\"failed to enable e2ee, worker is not ready\");\n  }\n  postRTPMap(u) {\n    var c;\n    if (!this.worker)\n      throw TypeError(\"could not post rtp map, worker is missing\");\n    if (!(!((c = this.room) === null || c === void 0) && c.localParticipant.identity))\n      throw TypeError(\"could not post rtp map, local participant identity is missing\");\n    const l = {\n      kind: \"setRTPMap\",\n      data: {\n        map: u,\n        participantIdentity: this.room.localParticipant.identity\n      }\n    };\n    this.worker.postMessage(l);\n  }\n  postSifTrailer(u) {\n    if (!this.worker)\n      throw Error(\"could not post SIF trailer, worker is missing\");\n    const c = {\n      kind: \"setSifTrailer\",\n      data: {\n        trailer: u\n      }\n    };\n    this.worker.postMessage(c);\n  }\n  setupE2EEReceiver(u, c, l) {\n    if (u.receiver) {\n      if (!(l != null && l.mimeType) || l.mimeType === \"\")\n        throw new TypeError(\"MimeType missing from trackInfo, cannot set up E2EE cryptor\");\n      this.handleReceiver(u.receiver, u.mediaStreamID, c, u.kind === \"video\" ? mimeTypeToVideoCodecString(l.mimeType) : void 0);\n    }\n  }\n  setupE2EESender(u, c) {\n    if (!(u instanceof LocalTrack) || !c) {\n      c || livekitLogger.warn(\"early return because sender is not ready\");\n      return;\n    }\n    this.handleSender(c, u.mediaStreamID, void 0);\n  }\n  /**\n   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject\n   * a frame decoder.\n   *\n   */\n  handleReceiver(u, c, l, v) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.worker) {\n        if (isScriptTransformSupported()) {\n          const S = {\n            kind: \"decode\",\n            participantIdentity: l,\n            trackId: c,\n            codec: v\n          };\n          u.transform = new RTCRtpScriptTransform(this.worker, S);\n        } else {\n          if (E2EE_FLAG in u && v) {\n            const _ = {\n              kind: \"updateCodec\",\n              data: {\n                trackId: c,\n                codec: v,\n                participantIdentity: l\n              }\n            };\n            this.worker.postMessage(_);\n            return;\n          }\n          let S = u.writableStream, g = u.readableStream;\n          if (!S || !g) {\n            const _ = u.createEncodedStreams();\n            u.writableStream = _.writable, S = _.writable, u.readableStream = _.readable, g = _.readable;\n          }\n          const E = {\n            kind: \"decode\",\n            data: {\n              readableStream: g,\n              writableStream: S,\n              trackId: c,\n              codec: v,\n              participantIdentity: l\n            }\n          };\n          this.worker.postMessage(E, [g, S]);\n        }\n        u[E2EE_FLAG] = !0;\n      }\n    });\n  }\n  /**\n   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject\n   * a frame encoder.\n   *\n   */\n  handleSender(u, c, l) {\n    var v;\n    if (!(E2EE_FLAG in u || !this.worker)) {\n      if (!(!((v = this.room) === null || v === void 0) && v.localParticipant.identity) || this.room.localParticipant.identity === \"\")\n        throw TypeError(\"local identity needs to be known in order to set up encrypted sender\");\n      if (isScriptTransformSupported()) {\n        livekitLogger.info(\"initialize script transform\");\n        const S = {\n          kind: \"encode\",\n          participantIdentity: this.room.localParticipant.identity,\n          trackId: c,\n          codec: l\n        };\n        u.transform = new RTCRtpScriptTransform(this.worker, S);\n      } else {\n        livekitLogger.info(\"initialize encoded streams\");\n        const S = u.createEncodedStreams(), g = {\n          kind: \"encode\",\n          data: {\n            readableStream: S.readable,\n            writableStream: S.writable,\n            codec: l,\n            trackId: c,\n            participantIdentity: this.room.localParticipant.identity\n          }\n        };\n        this.worker.postMessage(g, [S.readable, S.writable]);\n      }\n      u[E2EE_FLAG] = !0;\n    }\n  }\n}\nvar QueueTaskStatus;\n(function(a) {\n  a[a.WAITING = 0] = \"WAITING\", a[a.RUNNING = 1] = \"RUNNING\", a[a.COMPLETED = 2] = \"COMPLETED\";\n})(QueueTaskStatus || (QueueTaskStatus = {}));\nclass AsyncQueue {\n  constructor() {\n    this.pendingTasks = /* @__PURE__ */ new Map(), this.taskMutex = new Mutex(), this.nextTaskIndex = 0;\n  }\n  run(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const c = {\n        id: this.nextTaskIndex++,\n        enqueuedAt: Date.now(),\n        status: QueueTaskStatus.WAITING\n      };\n      this.pendingTasks.set(c.id, c);\n      const l = yield this.taskMutex.lock();\n      try {\n        return c.executedAt = Date.now(), c.status = QueueTaskStatus.RUNNING, yield u();\n      } finally {\n        c.status = QueueTaskStatus.COMPLETED, this.pendingTasks.delete(c.id), l();\n      }\n    });\n  }\n  flush() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.run(() => __awaiter(this, void 0, void 0, function* () {\n      }));\n    });\n  }\n  snapshot() {\n    return Array.from(this.pendingTasks.values());\n  }\n}\nconst passThroughQueueSignals = [\"syncState\", \"trickle\", \"offer\", \"answer\", \"simulate\", \"leave\"];\nfunction canPassThroughQueue(a) {\n  const u = passThroughQueueSignals.indexOf(a.case) >= 0;\n  return livekitLogger.trace(\"request allowed to bypass queue:\", {\n    canPass: u,\n    req: a\n  }), u;\n}\nvar SignalConnectionState;\n(function(a) {\n  a[a.CONNECTING = 0] = \"CONNECTING\", a[a.CONNECTED = 1] = \"CONNECTED\", a[a.RECONNECTING = 2] = \"RECONNECTING\", a[a.DISCONNECTING = 3] = \"DISCONNECTING\", a[a.DISCONNECTED = 4] = \"DISCONNECTED\";\n})(SignalConnectionState || (SignalConnectionState = {}));\nclass SignalClient {\n  get currentState() {\n    return this.state;\n  }\n  get isDisconnected() {\n    return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;\n  }\n  get isEstablishingConnection() {\n    return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;\n  }\n  constructor() {\n    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var l;\n    this.rtt = 0, this.state = SignalConnectionState.DISCONNECTED, this.log = livekitLogger, this.resetCallbacks = () => {\n      this.onAnswer = void 0, this.onLeave = void 0, this.onLocalTrackPublished = void 0, this.onLocalTrackUnpublished = void 0, this.onNegotiateRequested = void 0, this.onOffer = void 0, this.onRemoteMuteChanged = void 0, this.onSubscribedQualityUpdate = void 0, this.onTokenRefresh = void 0, this.onTrickle = void 0, this.onClose = void 0;\n    }, this.log = getLogger((l = c.loggerName) !== null && l !== void 0 ? l : LoggerNames.Signal), this.loggerContextCb = c.loggerContextCb, this.useJSON = u, this.requestQueue = new AsyncQueue(), this.queuedRequests = [], this.closingLock = new Mutex(), this.connectionLock = new Mutex(), this.state = SignalConnectionState.DISCONNECTED;\n  }\n  get logContext() {\n    var u, c;\n    return (c = (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)) !== null && c !== void 0 ? c : {};\n  }\n  join(u, c, l, v) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.state = SignalConnectionState.CONNECTING, this.options = l, yield this.connect(u, c, l, v);\n    });\n  }\n  reconnect(u, c, l, v) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.options) {\n        this.log.warn(\"attempted to reconnect without signal options being set, ignoring\", this.logContext);\n        return;\n      }\n      return this.state = SignalConnectionState.RECONNECTING, this.clearPingInterval(), yield this.connect(u, c, Object.assign(Object.assign({}, this.options), {\n        reconnect: !0,\n        sid: l,\n        reconnectReason: v\n      }));\n    });\n  }\n  connect(u, c, l, v) {\n    this.connectOptions = l, u = toWebsocketUrl(u), u = u.replace(/\\/$/, \"\"), u += \"/rtc\";\n    const S = getClientInfo(), g = createConnectionParams(c, S, l);\n    return new Promise((E, _) => __awaiter(this, void 0, void 0, function* () {\n      const k = yield this.connectionLock.lock();\n      try {\n        const L = () => __awaiter(this, void 0, void 0, function* () {\n          this.close(), clearTimeout(M), _(new ConnectionError(\"room connection has been cancelled (signal)\"));\n        }), M = setTimeout(() => {\n          this.close(), _(new ConnectionError(\"room connection has timed out (signal)\"));\n        }, l.websocketTimeout);\n        v != null && v.aborted && L(), v == null || v.addEventListener(\"abort\", L), this.log.debug(\"connecting to \".concat(u + g), this.logContext), this.ws && (yield this.close(!1)), this.ws = new WebSocket(u + g), this.ws.binaryType = \"arraybuffer\", this.ws.onopen = () => {\n          clearTimeout(M);\n        }, this.ws.onerror = ($) => __awaiter(this, void 0, void 0, function* () {\n          if (this.state !== SignalConnectionState.CONNECTED) {\n            clearTimeout(M);\n            try {\n              const J = yield fetch(\"http\".concat(u.substring(2), \"/validate\").concat(g));\n              if (J.status.toFixed(0).startsWith(\"4\")) {\n                const V = yield J.text();\n                _(new ConnectionError(V, 0, J.status));\n              } else\n                _(new ConnectionError(\"Internal error\", 2, J.status));\n            } catch {\n              _(new ConnectionError(\n                \"server was not reachable\",\n                1\n                /* ConnectionErrorReason.ServerUnreachable */\n              ));\n            }\n            return;\n          }\n          this.handleWSError($);\n        }), this.ws.onmessage = ($) => __awaiter(this, void 0, void 0, function* () {\n          var J, V, q, G;\n          let H;\n          if (typeof $.data == \"string\") {\n            const B = JSON.parse($.data);\n            H = SignalResponse.fromJson(B);\n          } else if ($.data instanceof ArrayBuffer)\n            H = SignalResponse.fromBinary(new Uint8Array($.data));\n          else {\n            this.log.error(\"could not decode websocket message: \".concat(typeof $.data), this.logContext);\n            return;\n          }\n          if (this.state !== SignalConnectionState.CONNECTED) {\n            let B = !1;\n            if (((J = H.message) === null || J === void 0 ? void 0 : J.case) === \"join\" ? (this.state = SignalConnectionState.CONNECTED, v == null || v.removeEventListener(\"abort\", L), this.pingTimeoutDuration = H.message.value.pingTimeout, this.pingIntervalDuration = H.message.value.pingInterval, this.pingTimeoutDuration && this.pingTimeoutDuration > 0 && (this.log.debug(\"ping config\", Object.assign(Object.assign({}, this.logContext), {\n              timeout: this.pingTimeoutDuration,\n              interval: this.pingIntervalDuration\n            })), this.startPingInterval()), E(H.message.value)) : this.state === SignalConnectionState.RECONNECTING && H.message.case !== \"leave\" ? (this.state = SignalConnectionState.CONNECTED, v == null || v.removeEventListener(\"abort\", L), this.startPingInterval(), ((V = H.message) === null || V === void 0 ? void 0 : V.case) === \"reconnect\" ? E((q = H.message) === null || q === void 0 ? void 0 : q.value) : (E(), B = !0)) : this.isEstablishingConnection && H.message.case === \"leave\" ? _(new ConnectionError(\n              \"Received leave request while trying to (re)connect\",\n              4\n              /* ConnectionErrorReason.LeaveRequest */\n            )) : l.reconnect || _(new ConnectionError(\"did not receive join response, got \".concat((G = H.message) === null || G === void 0 ? void 0 : G.case, \" instead\"))), !B)\n              return;\n          }\n          this.signalLatency && (yield sleep(this.signalLatency)), this.handleSignalResponse(H);\n        }), this.ws.onclose = ($) => {\n          this.isEstablishingConnection && _(new ConnectionError(\"Websocket got closed during a (re)connection attempt\")), this.log.warn(\"websocket closed\", Object.assign(Object.assign({}, this.logContext), {\n            reason: $.reason,\n            code: $.code,\n            wasClean: $.wasClean,\n            state: this.state\n          })), this.handleOnClose($.reason);\n        };\n      } finally {\n        k();\n      }\n    }));\n  }\n  close() {\n    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;\n    return __awaiter(this, void 0, void 0, function* () {\n      const c = yield this.closingLock.lock();\n      try {\n        if (u && (this.state = SignalConnectionState.DISCONNECTING), this.ws) {\n          this.ws.onmessage = null, this.ws.onopen = null, this.ws.onclose = null;\n          const l = new Promise((v) => {\n            this.ws ? this.ws.onclose = () => {\n              v();\n            } : v();\n          });\n          this.ws.readyState < this.ws.CLOSING && (this.ws.close(), yield Promise.race([l, sleep(250)])), this.ws = void 0;\n        }\n      } finally {\n        u && (this.state = SignalConnectionState.DISCONNECTED), this.clearPingInterval(), c();\n      }\n    });\n  }\n  // initial offer after joining\n  sendOffer(u) {\n    this.log.debug(\"sending offer\", Object.assign(Object.assign({}, this.logContext), {\n      offerSdp: u.sdp\n    })), this.sendRequest({\n      case: \"offer\",\n      value: toProtoSessionDescription(u)\n    });\n  }\n  // answer a server-initiated offer\n  sendAnswer(u) {\n    return this.log.debug(\"sending answer\", Object.assign(Object.assign({}, this.logContext), {\n      answerSdp: u.sdp\n    })), this.sendRequest({\n      case: \"answer\",\n      value: toProtoSessionDescription(u)\n    });\n  }\n  sendIceCandidate(u, c) {\n    return this.log.trace(\"sending ice candidate\", Object.assign(Object.assign({}, this.logContext), {\n      candidate: u\n    })), this.sendRequest({\n      case: \"trickle\",\n      value: new TrickleRequest({\n        candidateInit: JSON.stringify(u),\n        target: c\n      })\n    });\n  }\n  sendMuteTrack(u, c) {\n    return this.sendRequest({\n      case: \"mute\",\n      value: new MuteTrackRequest({\n        sid: u,\n        muted: c\n      })\n    });\n  }\n  sendAddTrack(u) {\n    return this.sendRequest({\n      case: \"addTrack\",\n      value: u\n    });\n  }\n  sendUpdateLocalMetadata(u, c) {\n    return this.sendRequest({\n      case: \"updateMetadata\",\n      value: new UpdateParticipantMetadata({\n        metadata: u,\n        name: c\n      })\n    });\n  }\n  sendUpdateTrackSettings(u) {\n    this.sendRequest({\n      case: \"trackSetting\",\n      value: u\n    });\n  }\n  sendUpdateSubscription(u) {\n    return this.sendRequest({\n      case: \"subscription\",\n      value: u\n    });\n  }\n  sendSyncState(u) {\n    return this.sendRequest({\n      case: \"syncState\",\n      value: u\n    });\n  }\n  sendUpdateVideoLayers(u, c) {\n    return this.sendRequest({\n      case: \"updateLayers\",\n      value: new UpdateVideoLayers({\n        trackSid: u,\n        layers: c\n      })\n    });\n  }\n  sendUpdateSubscriptionPermissions(u, c) {\n    return this.sendRequest({\n      case: \"subscriptionPermission\",\n      value: new SubscriptionPermission({\n        allParticipants: u,\n        trackPermissions: c\n      })\n    });\n  }\n  sendSimulateScenario(u) {\n    return this.sendRequest({\n      case: \"simulate\",\n      value: u\n    });\n  }\n  sendPing() {\n    return Promise.all([this.sendRequest({\n      case: \"ping\",\n      value: protoInt64.parse(Date.now())\n    }), this.sendRequest({\n      case: \"pingReq\",\n      value: new Ping({\n        timestamp: protoInt64.parse(Date.now()),\n        rtt: protoInt64.parse(this.rtt)\n      })\n    })]);\n  }\n  sendLeave() {\n    return this.sendRequest({\n      case: \"leave\",\n      value: new LeaveRequest({\n        canReconnect: !1,\n        reason: DisconnectReason.CLIENT_INITIATED\n      })\n    });\n  }\n  sendRequest(u) {\n    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!c && !canPassThroughQueue(u) && this.state === SignalConnectionState.RECONNECTING) {\n        this.queuedRequests.push(() => __awaiter(this, void 0, void 0, function* () {\n          yield this.sendRequest(u, !0);\n        }));\n        return;\n      }\n      if (c || (yield this.requestQueue.flush()), this.signalLatency && (yield sleep(this.signalLatency)), !this.ws || this.ws.readyState !== this.ws.OPEN) {\n        this.log.error(\"cannot send signal request before connected, type: \".concat(u == null ? void 0 : u.case), this.logContext);\n        return;\n      }\n      const v = new SignalRequest({\n        message: u\n      });\n      try {\n        this.useJSON ? this.ws.send(v.toJsonString()) : this.ws.send(v.toBinary());\n      } catch (S) {\n        this.log.error(\"error sending signal message\", Object.assign(Object.assign({}, this.logContext), {\n          error: S\n        }));\n      }\n    });\n  }\n  handleSignalResponse(u) {\n    var c, l;\n    const v = u.message;\n    if (v == null) {\n      this.log.debug(\"received unsupported message\", this.logContext);\n      return;\n    }\n    let S = !1;\n    if (v.case === \"answer\") {\n      const g = fromProtoSessionDescription(v.value);\n      this.onAnswer && this.onAnswer(g);\n    } else if (v.case === \"offer\") {\n      const g = fromProtoSessionDescription(v.value);\n      this.onOffer && this.onOffer(g);\n    } else if (v.case === \"trickle\") {\n      const g = JSON.parse(v.value.candidateInit);\n      this.onTrickle && this.onTrickle(g, v.value.target);\n    } else\n      v.case === \"update\" ? this.onParticipantUpdate && this.onParticipantUpdate((c = v.value.participants) !== null && c !== void 0 ? c : []) : v.case === \"trackPublished\" ? this.onLocalTrackPublished && this.onLocalTrackPublished(v.value) : v.case === \"speakersChanged\" ? this.onSpeakersChanged && this.onSpeakersChanged((l = v.value.speakers) !== null && l !== void 0 ? l : []) : v.case === \"leave\" ? this.onLeave && this.onLeave(v.value) : v.case === \"mute\" ? this.onRemoteMuteChanged && this.onRemoteMuteChanged(v.value.sid, v.value.muted) : v.case === \"roomUpdate\" ? this.onRoomUpdate && v.value.room && this.onRoomUpdate(v.value.room) : v.case === \"connectionQuality\" ? this.onConnectionQuality && this.onConnectionQuality(v.value) : v.case === \"streamStateUpdate\" ? this.onStreamStateUpdate && this.onStreamStateUpdate(v.value) : v.case === \"subscribedQualityUpdate\" ? this.onSubscribedQualityUpdate && this.onSubscribedQualityUpdate(v.value) : v.case === \"subscriptionPermissionUpdate\" ? this.onSubscriptionPermissionUpdate && this.onSubscriptionPermissionUpdate(v.value) : v.case === \"refreshToken\" ? this.onTokenRefresh && this.onTokenRefresh(v.value) : v.case === \"trackUnpublished\" ? this.onLocalTrackUnpublished && this.onLocalTrackUnpublished(v.value) : v.case === \"subscriptionResponse\" ? this.onSubscriptionError && this.onSubscriptionError(v.value) : v.case === \"pong\" || (v.case === \"pongResp\" ? (this.rtt = Date.now() - Number.parseInt(v.value.lastPingTimestamp.toString()), this.resetPingTimeout(), S = !0) : this.log.debug(\"unsupported message\", Object.assign(Object.assign({}, this.logContext), {\n        msgCase: v.case\n      })));\n    S || this.resetPingTimeout();\n  }\n  setReconnected() {\n    for (; this.queuedRequests.length > 0; ) {\n      const u = this.queuedRequests.shift();\n      u && this.requestQueue.run(u);\n    }\n  }\n  handleOnClose(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.state === SignalConnectionState.DISCONNECTED)\n        return;\n      const c = this.onClose;\n      yield this.close(), this.log.debug(\"websocket connection closed: \".concat(u), Object.assign(Object.assign({}, this.logContext), {\n        reason: u\n      })), c && c(u);\n    });\n  }\n  handleWSError(u) {\n    this.log.error(\"websocket error\", Object.assign(Object.assign({}, this.logContext), {\n      error: u\n    }));\n  }\n  /**\n   * Resets the ping timeout and starts a new timeout.\n   * Call this after receiving a pong message\n   */\n  resetPingTimeout() {\n    if (this.clearPingTimeout(), !this.pingTimeoutDuration) {\n      this.log.warn(\"ping timeout duration not set\", this.logContext);\n      return;\n    }\n    this.pingTimeout = CriticalTimers.setTimeout(() => {\n      this.log.warn(\"ping timeout triggered. last pong received at: \".concat(new Date(Date.now() - this.pingTimeoutDuration * 1e3).toUTCString()), this.logContext), this.handleOnClose(\"ping timeout\");\n    }, this.pingTimeoutDuration * 1e3);\n  }\n  /**\n   * Clears ping timeout (does not start a new timeout)\n   */\n  clearPingTimeout() {\n    this.pingTimeout && CriticalTimers.clearTimeout(this.pingTimeout);\n  }\n  startPingInterval() {\n    if (this.clearPingInterval(), this.resetPingTimeout(), !this.pingIntervalDuration) {\n      this.log.warn(\"ping interval duration not set\", this.logContext);\n      return;\n    }\n    this.log.debug(\"start ping interval\", this.logContext), this.pingInterval = CriticalTimers.setInterval(() => {\n      this.sendPing();\n    }, this.pingIntervalDuration * 1e3);\n  }\n  clearPingInterval() {\n    this.log.debug(\"clearing ping interval\", this.logContext), this.clearPingTimeout(), this.pingInterval && CriticalTimers.clearInterval(this.pingInterval);\n  }\n}\nfunction fromProtoSessionDescription(a) {\n  const u = {\n    type: \"offer\",\n    sdp: a.sdp\n  };\n  switch (a.type) {\n    case \"answer\":\n    case \"offer\":\n    case \"pranswer\":\n    case \"rollback\":\n      u.type = a.type;\n      break;\n  }\n  return u;\n}\nfunction toProtoSessionDescription(a) {\n  return new SessionDescription({\n    sdp: a.sdp,\n    type: a.type\n  });\n}\nfunction createConnectionParams(a, u, c) {\n  var l;\n  const v = new URLSearchParams();\n  return v.set(\"access_token\", a), c.reconnect && (v.set(\"reconnect\", \"1\"), c.sid && v.set(\"sid\", c.sid)), v.set(\"auto_subscribe\", c.autoSubscribe ? \"1\" : \"0\"), v.set(\"sdk\", isReactNative() ? \"reactnative\" : \"js\"), v.set(\"version\", u.version), v.set(\"protocol\", u.protocol.toString()), u.deviceModel && v.set(\"device_model\", u.deviceModel), u.os && v.set(\"os\", u.os), u.osVersion && v.set(\"os_version\", u.osVersion), u.browser && v.set(\"browser\", u.browser), u.browserVersion && v.set(\"browser_version\", u.browserVersion), c.adaptiveStream && v.set(\"adaptive_stream\", \"1\"), c.reconnectReason && v.set(\"reconnect_reason\", c.reconnectReason.toString()), !((l = navigator.connection) === null || l === void 0) && l.type && v.set(\"network\", navigator.connection.type), \"?\".concat(v.toString());\n}\nvar parser$1 = {}, grammar$2 = { exports: {} }, grammar$1 = grammar$2.exports = {\n  v: [{\n    name: \"version\",\n    reg: /^(\\d*)$/\n  }],\n  o: [{\n    // o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: \"origin\",\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: [\"username\", \"sessionId\", \"sessionVersion\", \"netType\", \"ipVer\", \"address\"],\n    format: \"%s %s %d %s IP%d %s\"\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{\n    name: \"name\"\n  }],\n  i: [{\n    name: \"description\"\n  }],\n  u: [{\n    name: \"uri\"\n  }],\n  e: [{\n    name: \"email\"\n  }],\n  p: [{\n    name: \"phone\"\n  }],\n  z: [{\n    name: \"timezones\"\n  }],\n  // TODO: this one can actually be parsed properly...\n  r: [{\n    name: \"repeats\"\n  }],\n  // TODO: this one can also be parsed properly\n  // k: [{}], // outdated thing ignored\n  t: [{\n    // t=0 0\n    name: \"timing\",\n    reg: /^(\\d*) (\\d*)/,\n    names: [\"start\", \"stop\"],\n    format: \"%d %d\"\n  }],\n  c: [{\n    // c=IN IP4 10.47.197.26\n    name: \"connection\",\n    reg: /^IN IP(\\d) (\\S*)/,\n    names: [\"version\", \"ip\"],\n    format: \"IN IP%d %s\"\n  }],\n  b: [{\n    // b=AS:4000\n    push: \"bandwidth\",\n    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n    names: [\"type\", \"limit\"],\n    format: \"%s:%s\"\n  }],\n  m: [{\n    // m=video 51744 RTP/AVP 126 97 98 34 31\n    // NB: special - pushes to session\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\n    reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n    names: [\"type\", \"port\", \"protocol\", \"payloads\"],\n    format: \"%s %d %s %s\"\n  }],\n  a: [\n    {\n      // a=rtpmap:110 opus/48000/2\n      push: \"rtp\",\n      reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: [\"payload\", \"codec\", \"rate\", \"encoding\"],\n      format: function(a) {\n        return a.encoding ? \"rtpmap:%d %s/%s/%s\" : a.rate ? \"rtpmap:%d %s/%s\" : \"rtpmap:%d %s\";\n      }\n    },\n    {\n      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      // a=fmtp:111 minptime=10; useinbandfec=1\n      push: \"fmtp\",\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: [\"payload\", \"config\"],\n      format: \"fmtp:%d %s\"\n    },\n    {\n      // a=control:streamid=0\n      name: \"control\",\n      reg: /^control:(.*)/,\n      format: \"control:%s\"\n    },\n    {\n      // a=rtcp:65179 IN IP4 193.84.77.194\n      name: \"rtcp\",\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: [\"port\", \"netType\", \"ipVer\", \"address\"],\n      format: function(a) {\n        return a.address != null ? \"rtcp:%d %s IP%d %s\" : \"rtcp:%d\";\n      }\n    },\n    {\n      // a=rtcp-fb:98 trr-int 100\n      push: \"rtcpFbTrrInt\",\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: [\"payload\", \"value\"],\n      format: \"rtcp-fb:%s trr-int %d\"\n    },\n    {\n      // a=rtcp-fb:98 nack rpsi\n      push: \"rtcpFb\",\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: [\"payload\", \"type\", \"subtype\"],\n      format: function(a) {\n        return a.subtype != null ? \"rtcp-fb:%s %s %s\" : \"rtcp-fb:%s %s\";\n      }\n    },\n    {\n      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      // a=extmap:1/recvonly URI-gps-string\n      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n      push: \"ext\",\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n      names: [\"value\", \"direction\", \"encrypt-uri\", \"uri\", \"config\"],\n      format: function(a) {\n        return \"extmap:%d\" + (a.direction ? \"/%s\" : \"%v\") + (a[\"encrypt-uri\"] ? \" %s\" : \"%v\") + \" %s\" + (a.config ? \" %s\" : \"\");\n      }\n    },\n    {\n      // a=extmap-allow-mixed\n      name: \"extmapAllowMixed\",\n      reg: /^(extmap-allow-mixed)/\n    },\n    {\n      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: \"crypto\",\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: [\"id\", \"suite\", \"config\", \"sessionConfig\"],\n      format: function(a) {\n        return a.sessionConfig != null ? \"crypto:%d %s %s %s\" : \"crypto:%d %s %s\";\n      }\n    },\n    {\n      // a=setup:actpass\n      name: \"setup\",\n      reg: /^setup:(\\w*)/,\n      format: \"setup:%s\"\n    },\n    {\n      // a=connection:new\n      name: \"connectionType\",\n      reg: /^connection:(new|existing)/,\n      format: \"connection:%s\"\n    },\n    {\n      // a=mid:1\n      name: \"mid\",\n      reg: /^mid:([^\\s]*)/,\n      format: \"mid:%s\"\n    },\n    {\n      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: \"msid\",\n      reg: /^msid:(.*)/,\n      format: \"msid:%s\"\n    },\n    {\n      // a=ptime:20\n      name: \"ptime\",\n      reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n      format: \"ptime:%d\"\n    },\n    {\n      // a=maxptime:60\n      name: \"maxptime\",\n      reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n      format: \"maxptime:%d\"\n    },\n    {\n      // a=sendrecv\n      name: \"direction\",\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    },\n    {\n      // a=ice-lite\n      name: \"icelite\",\n      reg: /^(ice-lite)/\n    },\n    {\n      // a=ice-ufrag:F7gI\n      name: \"iceUfrag\",\n      reg: /^ice-ufrag:(\\S*)/,\n      format: \"ice-ufrag:%s\"\n    },\n    {\n      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: \"icePwd\",\n      reg: /^ice-pwd:(\\S*)/,\n      format: \"ice-pwd:%s\"\n    },\n    {\n      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: \"fingerprint\",\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: [\"type\", \"hash\"],\n      format: \"fingerprint:%s %s\"\n    },\n    {\n      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n      push: \"candidates\",\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n      names: [\"foundation\", \"component\", \"transport\", \"priority\", \"ip\", \"port\", \"type\", \"raddr\", \"rport\", \"tcptype\", \"generation\", \"network-id\", \"network-cost\"],\n      format: function(a) {\n        var u = \"candidate:%s %d %s %d %s %d typ %s\";\n        return u += a.raddr != null ? \" raddr %s rport %d\" : \"%v%v\", u += a.tcptype != null ? \" tcptype %s\" : \"%v\", a.generation != null && (u += \" generation %d\"), u += a[\"network-id\"] != null ? \" network-id %d\" : \"%v\", u += a[\"network-cost\"] != null ? \" network-cost %d\" : \"%v\", u;\n      }\n    },\n    {\n      // a=end-of-candidates (keep after the candidates line for readability)\n      name: \"endOfCandidates\",\n      reg: /^(end-of-candidates)/\n    },\n    {\n      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: \"remoteCandidates\",\n      reg: /^remote-candidates:(.*)/,\n      format: \"remote-candidates:%s\"\n    },\n    {\n      // a=ice-options:google-ice\n      name: \"iceOptions\",\n      reg: /^ice-options:(\\S*)/,\n      format: \"ice-options:%s\"\n    },\n    {\n      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: \"ssrcs\",\n      reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n      names: [\"id\", \"attribute\", \"value\"],\n      format: function(a) {\n        var u = \"ssrc:%d\";\n        return a.attribute != null && (u += \" %s\", a.value != null && (u += \":%s\")), u;\n      }\n    },\n    {\n      // a=ssrc-group:FEC 1 2\n      // a=ssrc-group:FEC-FR 3004364195 1080772241\n      push: \"ssrcGroups\",\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n      names: [\"semantics\", \"ssrcs\"],\n      format: \"ssrc-group:%s %s\"\n    },\n    {\n      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: \"msidSemantic\",\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: [\"semantic\", \"token\"],\n      format: \"msid-semantic: %s %s\"\n      // space after ':' is not accidental\n    },\n    {\n      // a=group:BUNDLE audio video\n      push: \"groups\",\n      reg: /^group:(\\w*) (.*)/,\n      names: [\"type\", \"mids\"],\n      format: \"group:%s %s\"\n    },\n    {\n      // a=rtcp-mux\n      name: \"rtcpMux\",\n      reg: /^(rtcp-mux)/\n    },\n    {\n      // a=rtcp-rsize\n      name: \"rtcpRsize\",\n      reg: /^(rtcp-rsize)/\n    },\n    {\n      // a=sctpmap:5000 webrtc-datachannel 1024\n      name: \"sctpmap\",\n      reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n      names: [\"sctpmapNumber\", \"app\", \"maxMessageSize\"],\n      format: function(a) {\n        return a.maxMessageSize != null ? \"sctpmap:%s %s %s\" : \"sctpmap:%s %s\";\n      }\n    },\n    {\n      // a=x-google-flag:conference\n      name: \"xGoogleFlag\",\n      reg: /^x-google-flag:([^\\s]*)/,\n      format: \"x-google-flag:%s\"\n    },\n    {\n      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n      push: \"rids\",\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n      names: [\"id\", \"direction\", \"params\"],\n      format: function(a) {\n        return a.params ? \"rid:%s %s %s\" : \"rid:%s %s\";\n      }\n    },\n    {\n      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n      // a=imageattr:* send [x=800,y=640] recv *\n      // a=imageattr:100 recv [x=320,y=240]\n      push: \"imageattrs\",\n      reg: new RegExp(\n        // a=imageattr:97\n        \"^imageattr:(\\\\d+|\\\\*)[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?\"\n      ),\n      names: [\"pt\", \"dir1\", \"attrs1\", \"dir2\", \"attrs2\"],\n      format: function(a) {\n        return \"imageattr:%s %s %s\" + (a.dir2 ? \" %s %s\" : \"\");\n      }\n    },\n    {\n      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n      // a=simulcast:recv 1;4,5 send 6;7\n      name: \"simulcast\",\n      reg: new RegExp(\n        // a=simulcast:\n        \"^simulcast:(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?$\"\n      ),\n      names: [\"dir1\", \"list1\", \"dir2\", \"list2\"],\n      format: function(a) {\n        return \"simulcast:%s %s\" + (a.dir2 ? \" %s %s\" : \"\");\n      }\n    },\n    {\n      // old simulcast draft 03 (implemented by Firefox)\n      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n      // a=simulcast: recv pt=97;98 send pt=97\n      // a=simulcast: send rid=5;6;7 paused=6,7\n      name: \"simulcast_03\",\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n      names: [\"value\"],\n      format: \"simulcast: %s\"\n    },\n    {\n      // a=framerate:25\n      // a=framerate:29.97\n      name: \"framerate\",\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n      format: \"framerate:%s\"\n    },\n    {\n      // RFC4570\n      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n      name: \"sourceFilter\",\n      reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n      names: [\"filterMode\", \"netType\", \"addressTypes\", \"destAddress\", \"srcList\"],\n      format: \"source-filter: %s %s %s %s %s\"\n    },\n    {\n      // a=bundle-only\n      name: \"bundleOnly\",\n      reg: /^(bundle-only)/\n    },\n    {\n      // a=label:1\n      name: \"label\",\n      reg: /^label:(.+)/,\n      format: \"label:%s\"\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n      name: \"sctpPort\",\n      reg: /^sctp-port:(\\d+)$/,\n      format: \"sctp-port:%s\"\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n      name: \"maxMessageSize\",\n      reg: /^max-message-size:(\\d+)$/,\n      format: \"max-message-size:%s\"\n    },\n    {\n      // RFC7273\n      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n      push: \"tsRefClocks\",\n      reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n      names: [\"clksrc\", \"clksrcExt\"],\n      format: function(a) {\n        return \"ts-refclk:%s\" + (a.clksrcExt != null ? \"=%s\" : \"\");\n      }\n    },\n    {\n      // RFC7273\n      // a=mediaclk:direct=963214424\n      name: \"mediaClk\",\n      reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n      names: [\"id\", \"mediaClockName\", \"mediaClockValue\", \"rateNumerator\", \"rateDenominator\"],\n      format: function(a) {\n        var u = \"mediaclk:\";\n        return u += a.id != null ? \"id=%s %s\" : \"%v%s\", u += a.mediaClockValue != null ? \"=%s\" : \"\", u += a.rateNumerator != null ? \" rate=%s\" : \"\", u += a.rateDenominator != null ? \"/%s\" : \"\", u;\n      }\n    },\n    {\n      // a=keywds:keywords\n      name: \"keywords\",\n      reg: /^keywds:(.+)$/,\n      format: \"keywds:%s\"\n    },\n    {\n      // a=content:main\n      name: \"content\",\n      reg: /^content:(.+)/,\n      format: \"content:%s\"\n    },\n    // BFCP https://tools.ietf.org/html/rfc4583\n    {\n      // a=floorctrl:c-s\n      name: \"bfcpFloorCtrl\",\n      reg: /^floorctrl:(c-only|s-only|c-s)/,\n      format: \"floorctrl:%s\"\n    },\n    {\n      // a=confid:1\n      name: \"bfcpConfId\",\n      reg: /^confid:(\\d+)/,\n      format: \"confid:%s\"\n    },\n    {\n      // a=userid:1\n      name: \"bfcpUserId\",\n      reg: /^userid:(\\d+)/,\n      format: \"userid:%s\"\n    },\n    {\n      // a=floorid:1\n      name: \"bfcpFloorId\",\n      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n      names: [\"id\", \"mStream\"],\n      format: \"floorid:%s mstrm:%s\"\n    },\n    {\n      // any a= that we don't understand is kept verbatim on media.invalid\n      push: \"invalid\",\n      names: [\"value\"]\n    }\n  ]\n};\nObject.keys(grammar$1).forEach(function(a) {\n  var u = grammar$1[a];\n  u.forEach(function(c) {\n    c.reg || (c.reg = /(.*)/), c.format || (c.format = \"%s\");\n  });\n});\nvar grammarExports = grammar$2.exports;\n(function(a) {\n  var u = function(E) {\n    return String(Number(E)) === E ? Number(E) : E;\n  }, c = function(E, _, k, L) {\n    if (L && !k)\n      _[L] = u(E[1]);\n    else\n      for (var M = 0; M < k.length; M += 1)\n        E[M + 1] != null && (_[k[M]] = u(E[M + 1]));\n  }, l = function(E, _, k) {\n    var L = E.name && E.names;\n    E.push && !_[E.push] ? _[E.push] = [] : L && !_[E.name] && (_[E.name] = {});\n    var M = E.push ? {} : (\n      // blank object that will be pushed\n      L ? _[E.name] : _\n    );\n    c(k.match(E.reg), M, E.names, E.name), E.push && _[E.push].push(M);\n  }, v = grammarExports, S = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n  a.parse = function(E) {\n    var _ = {}, k = [], L = _;\n    return E.split(/(\\r\\n|\\r|\\n)/).filter(S).forEach(function(M) {\n      var $ = M[0], J = M.slice(2);\n      $ === \"m\" && (k.push({\n        rtp: [],\n        fmtp: []\n      }), L = k[k.length - 1]);\n      for (var V = 0; V < (v[$] || []).length; V += 1) {\n        var q = v[$][V];\n        if (q.reg.test(J))\n          return l(q, L, J);\n      }\n    }), _.media = k, _;\n  };\n  var g = function(E, _) {\n    var k = _.split(/=(.+)/, 2);\n    return k.length === 2 ? E[k[0]] = u(k[1]) : k.length === 1 && _.length > 1 && (E[k[0]] = void 0), E;\n  };\n  a.parseParams = function(E) {\n    return E.split(/;\\s?/).reduce(g, {});\n  }, a.parseFmtpConfig = a.parseParams, a.parsePayloads = function(E) {\n    return E.toString().split(\" \").map(Number);\n  }, a.parseRemoteCandidates = function(E) {\n    for (var _ = [], k = E.split(\" \").map(u), L = 0; L < k.length; L += 3)\n      _.push({\n        component: k[L],\n        ip: k[L + 1],\n        port: k[L + 2]\n      });\n    return _;\n  }, a.parseImageAttributes = function(E) {\n    return E.split(\" \").map(function(_) {\n      return _.substring(1, _.length - 1).split(\",\").reduce(g, {});\n    });\n  }, a.parseSimulcastStreamList = function(E) {\n    return E.split(\";\").map(function(_) {\n      return _.split(\",\").map(function(k) {\n        var L, M = !1;\n        return k[0] !== \"~\" ? L = u(k) : (L = u(k.substring(1, k.length)), M = !0), {\n          scid: L,\n          paused: M\n        };\n      });\n    });\n  };\n})(parser$1);\nvar grammar = grammarExports, formatRegExp = /%[sdv%]/g, format = function(a) {\n  var u = 1, c = arguments, l = c.length;\n  return a.replace(formatRegExp, function(v) {\n    if (u >= l)\n      return v;\n    var S = c[u];\n    switch (u += 1, v) {\n      case \"%%\":\n        return \"%\";\n      case \"%s\":\n        return String(S);\n      case \"%d\":\n        return Number(S);\n      case \"%v\":\n        return \"\";\n    }\n  });\n}, makeLine = function(a, u, c) {\n  var l = u.format instanceof Function ? u.format(u.push ? c : c[u.name]) : u.format, v = [a + \"=\" + l];\n  if (u.names)\n    for (var S = 0; S < u.names.length; S += 1) {\n      var g = u.names[S];\n      u.name ? v.push(c[u.name][g]) : v.push(c[u.names[S]]);\n    }\n  else\n    v.push(c[u.name]);\n  return format.apply(null, v);\n}, defaultOuterOrder = [\"v\", \"o\", \"s\", \"i\", \"u\", \"e\", \"p\", \"c\", \"b\", \"t\", \"r\", \"z\", \"a\"], defaultInnerOrder = [\"i\", \"c\", \"b\", \"a\"], writer$1 = function(a, u) {\n  u = u || {}, a.version == null && (a.version = 0), a.name == null && (a.name = \" \"), a.media.forEach(function(S) {\n    S.payloads == null && (S.payloads = \"\");\n  });\n  var c = u.outerOrder || defaultOuterOrder, l = u.innerOrder || defaultInnerOrder, v = [];\n  return c.forEach(function(S) {\n    grammar[S].forEach(function(g) {\n      g.name in a && a[g.name] != null ? v.push(makeLine(S, g, a)) : g.push in a && a[g.push] != null && a[g.push].forEach(function(E) {\n        v.push(makeLine(S, g, E));\n      });\n    });\n  }), a.media.forEach(function(S) {\n    v.push(makeLine(\"m\", grammar.m[0], S)), l.forEach(function(g) {\n      grammar[g].forEach(function(E) {\n        E.name in S && S[E.name] != null ? v.push(makeLine(g, E, S)) : E.push in S && S[E.push] != null && S[E.push].forEach(function(_) {\n          v.push(makeLine(g, E, _));\n        });\n      });\n    });\n  }), v.join(`\\r\n`) + `\\r\n`;\n}, parser = parser$1, writer = writer$1, write = writer, parse$1 = parser.parse;\nconst startBitrateForSVC = 0.7, PCEvents = {\n  NegotiationStarted: \"negotiationStarted\",\n  NegotiationComplete: \"negotiationComplete\",\n  RTPVideoPayloadTypes: \"rtpVideoPayloadTypes\"\n};\nclass PCTransport extends eventsExports.EventEmitter {\n  get pc() {\n    return this._pc || (this._pc = this.createPC()), this._pc;\n  }\n  constructor(u) {\n    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var l;\n    super(), this.log = livekitLogger, this.pendingCandidates = [], this.restartingIce = !1, this.renegotiate = !1, this.trackBitrates = [], this.remoteStereoMids = [], this.remoteNackMids = [], this.negotiate = r((v) => __awaiter(this, void 0, void 0, function* () {\n      this.emit(PCEvents.NegotiationStarted);\n      try {\n        yield this.createAndSendOffer();\n      } catch (S) {\n        if (v)\n          v(S);\n        else\n          throw S;\n      }\n    }), 100), this.close = () => {\n      this._pc && (this._pc.close(), this._pc.onconnectionstatechange = null, this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.ondatachannel = null, this._pc.onnegotiationneeded = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ondatachannel = null, this._pc.ontrack = null, this._pc.onconnectionstatechange = null, this._pc.oniceconnectionstatechange = null, this._pc = null);\n    }, this.log = getLogger((l = c.loggerName) !== null && l !== void 0 ? l : LoggerNames.PCTransport), this.loggerOptions = c, this.config = u, this._pc = this.createPC();\n  }\n  createPC() {\n    const u = new RTCPeerConnection(this.config);\n    return u.onicecandidate = (c) => {\n      var l;\n      c.candidate && ((l = this.onIceCandidate) === null || l === void 0 || l.call(this, c.candidate));\n    }, u.onicecandidateerror = (c) => {\n      var l;\n      (l = this.onIceCandidateError) === null || l === void 0 || l.call(this, c);\n    }, u.oniceconnectionstatechange = () => {\n      var c;\n      (c = this.onIceConnectionStateChange) === null || c === void 0 || c.call(this, u.iceConnectionState);\n    }, u.onsignalingstatechange = () => {\n      var c;\n      (c = this.onSignalingStatechange) === null || c === void 0 || c.call(this, u.signalingState);\n    }, u.onconnectionstatechange = () => {\n      var c;\n      (c = this.onConnectionStateChange) === null || c === void 0 || c.call(this, u.connectionState);\n    }, u.ondatachannel = (c) => {\n      var l;\n      (l = this.onDataChannel) === null || l === void 0 || l.call(this, c);\n    }, u.ontrack = (c) => {\n      var l;\n      (l = this.onTrack) === null || l === void 0 || l.call(this, c);\n    }, u;\n  }\n  get logContext() {\n    var u, c;\n    return Object.assign({}, (c = (u = this.loggerOptions).loggerContextCb) === null || c === void 0 ? void 0 : c.call(u));\n  }\n  get isICEConnected() {\n    return this._pc !== null && (this.pc.iceConnectionState === \"connected\" || this.pc.iceConnectionState === \"completed\");\n  }\n  addIceCandidate(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.pc.remoteDescription && !this.restartingIce)\n        return this.pc.addIceCandidate(u);\n      this.pendingCandidates.push(u);\n    });\n  }\n  setRemoteDescription(u) {\n    var c;\n    return __awaiter(this, void 0, void 0, function* () {\n      let l;\n      if (u.type === \"offer\") {\n        let {\n          stereoMids: v,\n          nackMids: S\n        } = extractStereoAndNackAudioFromOffer(u);\n        this.remoteStereoMids = v, this.remoteNackMids = S;\n      } else if (u.type === \"answer\") {\n        const v = parse$1((c = u.sdp) !== null && c !== void 0 ? c : \"\");\n        v.media.forEach((S) => {\n          S.type === \"audio\" && this.trackBitrates.some((g) => {\n            if (!g.transceiver || S.mid != g.transceiver.mid)\n              return !1;\n            let E = 0;\n            if (S.rtp.some((k) => k.codec.toUpperCase() === g.codec.toUpperCase() ? (E = k.payload, !0) : !1), E === 0)\n              return !0;\n            let _ = !1;\n            for (const k of S.fmtp)\n              if (k.payload === E) {\n                k.config = k.config.split(\";\").filter((L) => !L.includes(\"maxaveragebitrate\")).join(\";\"), g.maxbr > 0 && (k.config += \";maxaveragebitrate=\".concat(g.maxbr * 1e3)), _ = !0;\n                break;\n              }\n            return _ || g.maxbr > 0 && S.fmtp.push({\n              payload: E,\n              config: \"maxaveragebitrate=\".concat(g.maxbr * 1e3)\n            }), !0;\n          });\n        }), l = write(v);\n      }\n      yield this.setMungedSDP(u, l, !0), this.pendingCandidates.forEach((v) => {\n        this.pc.addIceCandidate(v);\n      }), this.pendingCandidates = [], this.restartingIce = !1, this.renegotiate ? (this.renegotiate = !1, yield this.createAndSendOffer()) : u.type === \"answer\" && (this.emit(PCEvents.NegotiationComplete), u.sdp && parse$1(u.sdp).media.forEach((S) => {\n        S.type === \"video\" && this.emit(PCEvents.RTPVideoPayloadTypes, S.rtp);\n      }));\n    });\n  }\n  createAndSendOffer(u) {\n    var c;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.onOffer === void 0)\n        return;\n      if (u != null && u.iceRestart && (this.log.debug(\"restarting ICE\", this.logContext), this.restartingIce = !0), this._pc && this._pc.signalingState === \"have-local-offer\") {\n        const S = this._pc.remoteDescription;\n        if (u != null && u.iceRestart && S)\n          yield this._pc.setRemoteDescription(S);\n        else {\n          this.renegotiate = !0;\n          return;\n        }\n      } else if (!this._pc || this._pc.signalingState === \"closed\") {\n        this.log.warn(\"could not createOffer with closed peer connection\", this.logContext);\n        return;\n      }\n      this.log.debug(\"starting to negotiate\", this.logContext);\n      const l = yield this.pc.createOffer(u), v = parse$1((c = l.sdp) !== null && c !== void 0 ? c : \"\");\n      v.media.forEach((S) => {\n        S.type === \"audio\" ? ensureAudioNackAndStereo(S, [], []) : S.type === \"video\" && (ensureVideoDDExtensionForSVC(S), this.trackBitrates.some((g) => {\n          if (!S.msid || !g.cid || !S.msid.includes(g.cid))\n            return !1;\n          let E = 0;\n          if (S.rtp.some((k) => k.codec.toUpperCase() === g.codec.toUpperCase() ? (E = k.payload, !0) : !1), E === 0)\n            return !0;\n          let _ = !1;\n          for (const k of S.fmtp)\n            if (k.payload === E) {\n              k.config.includes(\"x-google-start-bitrate\") || (k.config += \";x-google-start-bitrate=\".concat(Math.round(g.maxbr * startBitrateForSVC))), k.config.includes(\"x-google-max-bitrate\") || (k.config += \";x-google-max-bitrate=\".concat(g.maxbr)), _ = !0;\n              break;\n            }\n          return _ || S.fmtp.push({\n            payload: E,\n            config: \"x-google-start-bitrate=\".concat(Math.round(g.maxbr * startBitrateForSVC), \";x-google-max-bitrate=\").concat(g.maxbr)\n          }), !0;\n        }));\n      }), yield this.setMungedSDP(l, write(v)), this.onOffer(l);\n    });\n  }\n  createAndSetAnswer() {\n    var u;\n    return __awaiter(this, void 0, void 0, function* () {\n      const c = yield this.pc.createAnswer(), l = parse$1((u = c.sdp) !== null && u !== void 0 ? u : \"\");\n      return l.media.forEach((v) => {\n        v.type === \"audio\" && ensureAudioNackAndStereo(v, this.remoteStereoMids, this.remoteNackMids);\n      }), yield this.setMungedSDP(c, write(l)), c;\n    });\n  }\n  createDataChannel(u, c) {\n    return this.pc.createDataChannel(u, c);\n  }\n  addTransceiver(u, c) {\n    return this.pc.addTransceiver(u, c);\n  }\n  addTrack(u) {\n    if (!this._pc)\n      throw new UnexpectedConnectionState(\"PC closed, cannot add track\");\n    return this._pc.addTrack(u);\n  }\n  setTrackCodecBitrate(u) {\n    this.trackBitrates.push(u);\n  }\n  setConfiguration(u) {\n    var c;\n    if (!this._pc)\n      throw new UnexpectedConnectionState(\"PC closed, cannot configure\");\n    return (c = this._pc) === null || c === void 0 ? void 0 : c.setConfiguration(u);\n  }\n  canRemoveTrack() {\n    var u;\n    return !!(!((u = this._pc) === null || u === void 0) && u.removeTrack);\n  }\n  removeTrack(u) {\n    var c;\n    return (c = this._pc) === null || c === void 0 ? void 0 : c.removeTrack(u);\n  }\n  getConnectionState() {\n    var u, c;\n    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.connectionState) !== null && c !== void 0 ? c : \"closed\";\n  }\n  getICEConnectionState() {\n    var u, c;\n    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.iceConnectionState) !== null && c !== void 0 ? c : \"closed\";\n  }\n  getSignallingState() {\n    var u, c;\n    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.signalingState) !== null && c !== void 0 ? c : \"closed\";\n  }\n  getTransceivers() {\n    var u, c;\n    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.getTransceivers()) !== null && c !== void 0 ? c : [];\n  }\n  getSenders() {\n    var u, c;\n    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.getSenders()) !== null && c !== void 0 ? c : [];\n  }\n  getLocalDescription() {\n    var u;\n    return (u = this._pc) === null || u === void 0 ? void 0 : u.localDescription;\n  }\n  getRemoteDescription() {\n    var u;\n    return (u = this.pc) === null || u === void 0 ? void 0 : u.remoteDescription;\n  }\n  getStats() {\n    return this.pc.getStats();\n  }\n  getConnectedAddress() {\n    var u;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._pc)\n        return;\n      let c = \"\";\n      const l = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Map();\n      if ((yield this._pc.getStats()).forEach((E) => {\n        switch (E.type) {\n          case \"transport\":\n            c = E.selectedCandidatePairId;\n            break;\n          case \"candidate-pair\":\n            c === \"\" && E.selected && (c = E.id), l.set(E.id, E);\n            break;\n          case \"remote-candidate\":\n            v.set(E.id, \"\".concat(E.address, \":\").concat(E.port));\n            break;\n        }\n      }), c === \"\")\n        return;\n      const g = (u = l.get(c)) === null || u === void 0 ? void 0 : u.remoteCandidateId;\n      if (g !== void 0)\n        return v.get(g);\n    });\n  }\n  setMungedSDP(u, c, l) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (c) {\n        const v = u.sdp;\n        u.sdp = c;\n        try {\n          this.log.debug(\"setting munged \".concat(l ? \"remote\" : \"local\", \" description\"), this.logContext), l ? yield this.pc.setRemoteDescription(u) : yield this.pc.setLocalDescription(u);\n          return;\n        } catch (S) {\n          this.log.warn(\"not able to set \".concat(u.type, \", falling back to unmodified sdp\"), Object.assign(Object.assign({}, this.logContext), {\n            error: S,\n            sdp: c\n          })), u.sdp = v;\n        }\n      }\n      try {\n        l ? yield this.pc.setRemoteDescription(u) : yield this.pc.setLocalDescription(u);\n      } catch (v) {\n        let S = \"unknown error\";\n        v instanceof Error ? S = v.message : typeof v == \"string\" && (S = v);\n        const g = {\n          error: S,\n          sdp: u.sdp\n        };\n        throw !l && this.pc.remoteDescription && (g.remoteSdp = this.pc.remoteDescription), this.log.error(\"unable to set \".concat(u.type), Object.assign(Object.assign({}, this.logContext), {\n          fields: g\n        })), new NegotiationError(S);\n      }\n    });\n  }\n}\nfunction ensureAudioNackAndStereo(a, u, c) {\n  let l = 0;\n  a.rtp.some((v) => v.codec === \"opus\" ? (l = v.payload, !0) : !1), l > 0 && (a.rtcpFb || (a.rtcpFb = []), c.includes(a.mid) && !a.rtcpFb.some((v) => v.payload === l && v.type === \"nack\") && a.rtcpFb.push({\n    payload: l,\n    type: \"nack\"\n  }), u.includes(a.mid) && a.fmtp.some((v) => v.payload === l ? (v.config.includes(\"stereo=1\") || (v.config += \";stereo=1\"), !0) : !1));\n}\nfunction ensureVideoDDExtensionForSVC(a) {\n  var u, c, l, v;\n  const S = (c = (u = a.rtp[0]) === null || u === void 0 ? void 0 : u.codec) === null || c === void 0 ? void 0 : c.toLowerCase();\n  if (!isSVCCodec(S))\n    return;\n  let g = 0;\n  ((l = a.ext) === null || l === void 0 ? void 0 : l.some((_) => _.uri === ddExtensionURI ? !0 : (_.value > g && (g = _.value), !1))) || (v = a.ext) === null || v === void 0 || v.push({\n    value: g + 1,\n    uri: ddExtensionURI\n  });\n}\nfunction extractStereoAndNackAudioFromOffer(a) {\n  var u;\n  const c = [], l = [], v = parse$1((u = a.sdp) !== null && u !== void 0 ? u : \"\");\n  let S = 0;\n  return v.media.forEach((g) => {\n    var E;\n    g.type === \"audio\" && (g.rtp.some((_) => _.codec === \"opus\" ? (S = _.payload, !0) : !1), !((E = g.rtcpFb) === null || E === void 0) && E.some((_) => _.payload === S && _.type === \"nack\") && l.push(g.mid), g.fmtp.some((_) => _.payload === S ? (_.config.includes(\"sprop-stereo=1\") && c.push(g.mid), !0) : !1));\n  }), {\n    stereoMids: c,\n    nackMids: l\n  };\n}\nconst defaultVideoCodec = \"vp8\", publishDefaults = {\n  audioPreset: AudioPresets.music,\n  dtx: !0,\n  red: !0,\n  forceStereo: !1,\n  simulcast: !0,\n  screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,\n  stopMicTrackOnMute: !1,\n  videoCodec: defaultVideoCodec,\n  backupCodec: !0\n}, audioDefaults = {\n  autoGainControl: !0,\n  echoCancellation: !0,\n  noiseSuppression: !0\n}, videoDefaults = {\n  resolution: VideoPresets.h720.resolution\n}, roomOptionDefaults = {\n  adaptiveStream: !1,\n  dynacast: !1,\n  stopLocalTrackOnUnpublish: !0,\n  reconnectPolicy: new DefaultReconnectPolicy(),\n  disconnectOnPageLeave: !0,\n  webAudioMix: !0\n}, roomConnectOptionDefaults = {\n  autoSubscribe: !0,\n  maxRetries: 1,\n  peerConnectionTimeout: 15e3,\n  websocketTimeout: 15e3\n};\nvar PCTransportState;\n(function(a) {\n  a[a.NEW = 0] = \"NEW\", a[a.CONNECTING = 1] = \"CONNECTING\", a[a.CONNECTED = 2] = \"CONNECTED\", a[a.FAILED = 3] = \"FAILED\", a[a.CLOSING = 4] = \"CLOSING\", a[a.CLOSED = 5] = \"CLOSED\";\n})(PCTransportState || (PCTransportState = {}));\nclass PCTransportManager {\n  get needsPublisher() {\n    return this.isPublisherConnectionRequired;\n  }\n  get needsSubscriber() {\n    return this.isSubscriberConnectionRequired;\n  }\n  get currentState() {\n    return this.state;\n  }\n  constructor(u, c, l) {\n    var v;\n    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout, this.log = livekitLogger, this.updateState = () => {\n      var S;\n      const g = this.state, E = this.requiredTransports.map((_) => _.getConnectionState());\n      E.every((_) => _ === \"connected\") ? this.state = PCTransportState.CONNECTED : E.some((_) => _ === \"failed\") ? this.state = PCTransportState.FAILED : E.some((_) => _ === \"connecting\") ? this.state = PCTransportState.CONNECTING : E.every((_) => _ === \"closed\") ? this.state = PCTransportState.CLOSED : E.some((_) => _ === \"closed\") ? this.state = PCTransportState.CLOSING : E.every((_) => _ === \"new\") && (this.state = PCTransportState.NEW), g !== this.state && (this.log.debug(\"pc state change: from \".concat(PCTransportState[g], \" to \").concat(PCTransportState[this.state]), this.logContext), (S = this.onStateChange) === null || S === void 0 || S.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState()));\n    }, this.log = getLogger((v = l.loggerName) !== null && v !== void 0 ? v : LoggerNames.PCManager), this.loggerOptions = l, this.isPublisherConnectionRequired = !c, this.isSubscriberConnectionRequired = c, this.publisher = new PCTransport(u, l), this.subscriber = new PCTransport(u, l), this.publisher.onConnectionStateChange = this.updateState, this.subscriber.onConnectionStateChange = this.updateState, this.publisher.onIceConnectionStateChange = this.updateState, this.subscriber.onIceConnectionStateChange = this.updateState, this.publisher.onSignalingStatechange = this.updateState, this.subscriber.onSignalingStatechange = this.updateState, this.publisher.onIceCandidate = (S) => {\n      var g;\n      (g = this.onIceCandidate) === null || g === void 0 || g.call(this, S, SignalTarget.PUBLISHER);\n    }, this.subscriber.onIceCandidate = (S) => {\n      var g;\n      (g = this.onIceCandidate) === null || g === void 0 || g.call(this, S, SignalTarget.SUBSCRIBER);\n    }, this.subscriber.onDataChannel = (S) => {\n      var g;\n      (g = this.onDataChannel) === null || g === void 0 || g.call(this, S);\n    }, this.subscriber.onTrack = (S) => {\n      var g;\n      (g = this.onTrack) === null || g === void 0 || g.call(this, S);\n    }, this.publisher.onOffer = (S) => {\n      var g;\n      (g = this.onPublisherOffer) === null || g === void 0 || g.call(this, S);\n    }, this.state = PCTransportState.NEW, this.connectionLock = new Mutex();\n  }\n  get logContext() {\n    var u, c;\n    return Object.assign({}, (c = (u = this.loggerOptions).loggerContextCb) === null || c === void 0 ? void 0 : c.call(u));\n  }\n  requirePublisher() {\n    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;\n    this.isPublisherConnectionRequired = u, this.updateState();\n  }\n  requireSubscriber() {\n    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;\n    this.isSubscriberConnectionRequired = u, this.updateState();\n  }\n  createAndSendPublisherOffer(u) {\n    return this.publisher.createAndSendOffer(u);\n  }\n  setPublisherAnswer(u) {\n    return this.publisher.setRemoteDescription(u);\n  }\n  removeTrack(u) {\n    return this.publisher.removeTrack(u);\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.publisher && this.publisher.getSignallingState() !== \"closed\") {\n        const u = this.publisher;\n        for (const c of u.getSenders())\n          try {\n            u.canRemoveTrack() && u.removeTrack(c);\n          } catch (l) {\n            this.log.warn(\"could not removeTrack\", Object.assign(Object.assign({}, this.logContext), {\n              error: l\n            }));\n          }\n      }\n      yield Promise.all([this.publisher.close(), this.subscriber.close()]), this.updateState();\n    });\n  }\n  triggerIceRestart() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.subscriber.restartingIce = !0, this.needsPublisher && (yield this.createAndSendPublisherOffer({\n        iceRestart: !0\n      }));\n    });\n  }\n  addIceCandidate(u, c) {\n    return __awaiter(this, void 0, void 0, function* () {\n      c === SignalTarget.PUBLISHER ? yield this.publisher.addIceCandidate(u) : yield this.subscriber.addIceCandidate(u);\n    });\n  }\n  createSubscriberAnswerFromOffer(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.log.debug(\"received server offer\", Object.assign(Object.assign({}, this.logContext), {\n        RTCSdpType: u.type,\n        sdp: u.sdp,\n        signalingState: this.subscriber.getSignallingState().toString()\n      })), yield this.subscriber.setRemoteDescription(u), yield this.subscriber.createAndSetAnswer();\n    });\n  }\n  updateConfiguration(u, c) {\n    this.publisher.setConfiguration(u), this.subscriber.setConfiguration(u), c && this.triggerIceRestart();\n  }\n  ensurePCTransportConnection(u, c) {\n    var l;\n    return __awaiter(this, void 0, void 0, function* () {\n      const v = yield this.connectionLock.lock();\n      try {\n        this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== \"connected\" && this.publisher.getConnectionState() !== \"connecting\" && (this.log.debug(\"negotiation required, start negotiating\", this.logContext), this.publisher.negotiate()), yield Promise.all((l = this.requiredTransports) === null || l === void 0 ? void 0 : l.map((S) => this.ensureTransportConnected(S, u, c)));\n      } finally {\n        v();\n      }\n    });\n  }\n  negotiate(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((c, l) => __awaiter(this, void 0, void 0, function* () {\n        const v = setTimeout(() => {\n          l(\"negotiation timed out\");\n        }, this.peerConnectionTimeout), S = () => {\n          clearTimeout(v), l(\"negotiation aborted\");\n        };\n        u.signal.addEventListener(\"abort\", S), this.publisher.once(PCEvents.NegotiationStarted, () => {\n          u.signal.aborted || this.publisher.once(PCEvents.NegotiationComplete, () => {\n            clearTimeout(v), c();\n          });\n        }), yield this.publisher.negotiate((g) => {\n          clearTimeout(v), l(g);\n        });\n      }));\n    });\n  }\n  addPublisherTransceiver(u, c) {\n    return this.publisher.addTransceiver(u, c);\n  }\n  addPublisherTrack(u) {\n    return this.publisher.addTrack(u);\n  }\n  createPublisherDataChannel(u, c) {\n    return this.publisher.createDataChannel(u, c);\n  }\n  /**\n   * Returns the first required transport's address if no explicit target is specified\n   */\n  getConnectedAddress(u) {\n    return u === SignalTarget.PUBLISHER ? this.publisher.getConnectedAddress() : u === SignalTarget.SUBSCRIBER ? this.publisher.getConnectedAddress() : this.requiredTransports[0].getConnectedAddress();\n  }\n  get requiredTransports() {\n    const u = [];\n    return this.isPublisherConnectionRequired && u.push(this.publisher), this.isSubscriberConnectionRequired && u.push(this.subscriber), u;\n  }\n  ensureTransportConnected(u, c) {\n    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.peerConnectionTimeout;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (u.getConnectionState() !== \"connected\")\n        return new Promise((S, g) => __awaiter(this, void 0, void 0, function* () {\n          const E = () => {\n            this.log.warn(\"abort transport connection\", this.logContext), CriticalTimers.clearTimeout(_), g(new ConnectionError(\n              \"room connection has been cancelled\",\n              3\n              /* ConnectionErrorReason.Cancelled */\n            ));\n          };\n          c != null && c.signal.aborted && E(), c == null || c.signal.addEventListener(\"abort\", E);\n          const _ = CriticalTimers.setTimeout(() => {\n            c == null || c.signal.removeEventListener(\"abort\", E), g(new ConnectionError(\"could not establish pc connection\"));\n          }, l);\n          for (; this.state !== PCTransportState.CONNECTED; )\n            if (yield sleep(50), c != null && c.signal.aborted) {\n              g(new ConnectionError(\n                \"room connection has been cancelled\",\n                3\n                /* ConnectionErrorReason.Cancelled */\n              ));\n              return;\n            }\n          CriticalTimers.clearTimeout(_), c == null || c.signal.removeEventListener(\"abort\", E), S();\n        }));\n    });\n  }\n}\nconst lossyDataChannel = \"_lossy\", reliableDataChannel = \"_reliable\", minReconnectWait = 2 * 1e3, leaveReconnect = \"leave-reconnect\";\nvar PCState;\n(function(a) {\n  a[a.New = 0] = \"New\", a[a.Connected = 1] = \"Connected\", a[a.Disconnected = 2] = \"Disconnected\", a[a.Reconnecting = 3] = \"Reconnecting\", a[a.Closed = 4] = \"Closed\";\n})(PCState || (PCState = {}));\nclass RTCEngine extends eventsExports.EventEmitter {\n  get isClosed() {\n    return this._isClosed;\n  }\n  get pendingReconnect() {\n    return !!this.reconnectTimeout;\n  }\n  constructor(u) {\n    var c;\n    super(), this.options = u, this.rtcConfig = {}, this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout, this.fullReconnectOnNext = !1, this.subscriberPrimary = !1, this.pcState = PCState.New, this._isClosed = !0, this.pendingTrackResolvers = {}, this.reconnectAttempts = 0, this.reconnectStart = 0, this.attemptingReconnect = !1, this.joinAttempts = 0, this.maxJoinAttempts = 1, this.shouldFailNext = !1, this.log = livekitLogger, this.handleDataChannel = (l) => {\n      let {\n        channel: v\n      } = l;\n      return __awaiter(this, void 0, void 0, function* () {\n        if (v) {\n          if (v.label === reliableDataChannel)\n            this.reliableDCSub = v;\n          else if (v.label === lossyDataChannel)\n            this.lossyDCSub = v;\n          else\n            return;\n          this.log.debug(\"on data channel \".concat(v.id, \", \").concat(v.label), this.logContext), v.onmessage = this.handleDataMessage;\n        }\n      });\n    }, this.handleDataMessage = (l) => __awaiter(this, void 0, void 0, function* () {\n      var v, S;\n      const g = yield this.dataProcessLock.lock();\n      try {\n        let E;\n        if (l.data instanceof ArrayBuffer)\n          E = l.data;\n        else if (l.data instanceof Blob)\n          E = yield l.data.arrayBuffer();\n        else {\n          this.log.error(\"unsupported data type\", Object.assign(Object.assign({}, this.logContext), {\n            data: l.data\n          }));\n          return;\n        }\n        const _ = DataPacket.fromBinary(new Uint8Array(E));\n        ((v = _.value) === null || v === void 0 ? void 0 : v.case) === \"speaker\" ? this.emit(EngineEvent.ActiveSpeakersUpdate, _.value.value.speakers) : ((S = _.value) === null || S === void 0 ? void 0 : S.case) === \"user\" && this.emit(EngineEvent.DataPacketReceived, _.value.value, _.kind);\n      } finally {\n        g();\n      }\n    }), this.handleDataError = (l) => {\n      const S = l.currentTarget.maxRetransmits === 0 ? \"lossy\" : \"reliable\";\n      if (l instanceof ErrorEvent && l.error) {\n        const {\n          error: g\n        } = l.error;\n        this.log.error(\"DataChannel error on \".concat(S, \": \").concat(l.message), Object.assign(Object.assign({}, this.logContext), {\n          error: g\n        }));\n      } else\n        this.log.error(\"Unknown DataChannel error on \".concat(S), Object.assign(Object.assign({}, this.logContext), {\n          event: l\n        }));\n    }, this.handleBufferedAmountLow = (l) => {\n      const S = l.currentTarget.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;\n      this.updateAndEmitDCBufferStatus(S);\n    }, this.handleDisconnect = (l, v) => {\n      if (this._isClosed)\n        return;\n      this.log.warn(\"\".concat(l, \" disconnected\"), this.logContext), this.reconnectAttempts === 0 && (this.reconnectStart = Date.now());\n      const S = (_) => {\n        this.log.warn(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(_, \"ms. giving up\"), this.logContext), this.emit(EngineEvent.Disconnected), this.close();\n      }, g = Date.now() - this.reconnectStart;\n      let E = this.getNextRetryDelay({\n        elapsedMs: g,\n        retryCount: this.reconnectAttempts\n      });\n      if (E === null) {\n        S(g);\n        return;\n      }\n      l === leaveReconnect && (E = 0), this.log.debug(\"reconnecting in \".concat(E, \"ms\"), this.logContext), this.clearReconnectTimeout(), this.token && this.regionUrlProvider && this.regionUrlProvider.updateToken(this.token), this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(v).finally(() => this.reconnectTimeout = void 0), E);\n    }, this.waitForRestarted = () => new Promise((l, v) => {\n      this.pcState === PCState.Connected && l();\n      const S = () => {\n        this.off(EngineEvent.Disconnected, g), l();\n      }, g = () => {\n        this.off(EngineEvent.Restarted, S), v();\n      };\n      this.once(EngineEvent.Restarted, S), this.once(EngineEvent.Disconnected, g);\n    }), this.updateAndEmitDCBufferStatus = (l) => {\n      const v = this.isBufferStatusLow(l);\n      typeof v < \"u\" && v !== this.dcBufferStatus.get(l) && (this.dcBufferStatus.set(l, v), this.emit(EngineEvent.DCBufferStatusChanged, v, l));\n    }, this.isBufferStatusLow = (l) => {\n      const v = this.dataChannelForKind(l);\n      if (v)\n        return v.bufferedAmount <= v.bufferedAmountLowThreshold;\n    }, this.handleBrowserOnLine = () => {\n      this.client.currentState === SignalConnectionState.RECONNECTING && (this.clearReconnectTimeout(), this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED));\n    }, this.log = getLogger((c = u.loggerName) !== null && c !== void 0 ? c : LoggerNames.Engine), this.loggerOptions = {\n      loggerName: u.loggerName,\n      loggerContextCb: () => this.logContext\n    }, this.client = new SignalClient(void 0, this.loggerOptions), this.client.signalLatency = this.options.expSignalLatency, this.reconnectPolicy = this.options.reconnectPolicy, this.registerOnLineListener(), this.closingLock = new Mutex(), this.dataProcessLock = new Mutex(), this.dcBufferStatus = /* @__PURE__ */ new Map([[DataPacket_Kind.LOSSY, !0], [DataPacket_Kind.RELIABLE, !0]]), this.client.onParticipantUpdate = (l) => this.emit(EngineEvent.ParticipantUpdate, l), this.client.onConnectionQuality = (l) => this.emit(EngineEvent.ConnectionQualityUpdate, l), this.client.onRoomUpdate = (l) => this.emit(EngineEvent.RoomUpdate, l), this.client.onSubscriptionError = (l) => this.emit(EngineEvent.SubscriptionError, l), this.client.onSubscriptionPermissionUpdate = (l) => this.emit(EngineEvent.SubscriptionPermissionUpdate, l), this.client.onSpeakersChanged = (l) => this.emit(EngineEvent.SpeakersChanged, l), this.client.onStreamStateUpdate = (l) => this.emit(EngineEvent.StreamStateChanged, l);\n  }\n  /** @internal */\n  get logContext() {\n    var u, c, l, v, S, g;\n    return {\n      room: (c = (u = this.latestJoinResponse) === null || u === void 0 ? void 0 : u.room) === null || c === void 0 ? void 0 : c.name,\n      roomSid: (v = (l = this.latestJoinResponse) === null || l === void 0 ? void 0 : l.room) === null || v === void 0 ? void 0 : v.sid,\n      identity: (g = (S = this.latestJoinResponse) === null || S === void 0 ? void 0 : S.participant) === null || g === void 0 ? void 0 : g.identity\n    };\n  }\n  join(u, c, l, v) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.url = u, this.token = c, this.signalOpts = l, this.maxJoinAttempts = l.maxRetries;\n      try {\n        this.joinAttempts += 1, this.setupSignalClientCallbacks();\n        const S = yield this.client.join(u, c, l, v);\n        return this._isClosed = !1, this.latestJoinResponse = S, this.subscriberPrimary = S.subscriberPrimary, this.pcManager || (yield this.configure(S)), this.subscriberPrimary || this.negotiate(), this.clientConfiguration = S.clientConfiguration, S;\n      } catch (S) {\n        if (S instanceof ConnectionError && S.reason === 1 && (this.log.warn(\"Couldn't connect to server, attempt \".concat(this.joinAttempts, \" of \").concat(this.maxJoinAttempts), this.logContext), this.joinAttempts < this.maxJoinAttempts))\n          return this.join(u, c, l, v);\n        throw S;\n      }\n    });\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const u = yield this.closingLock.lock();\n      if (this.isClosed) {\n        u();\n        return;\n      }\n      try {\n        this._isClosed = !0, this.emit(EngineEvent.Closing), this.removeAllListeners(), this.deregisterOnLineListener(), this.clearPendingReconnect(), yield this.cleanupPeerConnections(), yield this.cleanupClient();\n      } finally {\n        u();\n      }\n    });\n  }\n  cleanupPeerConnections() {\n    var u;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield (u = this.pcManager) === null || u === void 0 ? void 0 : u.close(), this.pcManager = void 0;\n      const c = (l) => {\n        l && (l.close(), l.onbufferedamountlow = null, l.onclose = null, l.onclosing = null, l.onerror = null, l.onmessage = null, l.onopen = null);\n      };\n      c(this.lossyDC), c(this.lossyDCSub), c(this.reliableDC), c(this.reliableDCSub), this.lossyDC = void 0, this.lossyDCSub = void 0, this.reliableDC = void 0, this.reliableDCSub = void 0;\n    });\n  }\n  cleanupClient() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.client.close(), this.client.resetCallbacks();\n    });\n  }\n  addTrack(u) {\n    if (this.pendingTrackResolvers[u.cid])\n      throw new TrackInvalidError(\"a track with the same ID has already been published\");\n    return new Promise((c, l) => {\n      const v = setTimeout(() => {\n        delete this.pendingTrackResolvers[u.cid], l(new ConnectionError(\"publication of local track timed out, no response from server\"));\n      }, 1e4);\n      this.pendingTrackResolvers[u.cid] = {\n        resolve: (S) => {\n          clearTimeout(v), c(S);\n        },\n        reject: () => {\n          clearTimeout(v), l(new Error(\"Cancelled publication by calling unpublish\"));\n        }\n      }, this.client.sendAddTrack(u);\n    });\n  }\n  /**\n   * Removes sender from PeerConnection, returning true if it was removed successfully\n   * and a negotiation is necessary\n   * @param sender\n   * @returns\n   */\n  removeTrack(u) {\n    if (u.track && this.pendingTrackResolvers[u.track.id]) {\n      const {\n        reject: c\n      } = this.pendingTrackResolvers[u.track.id];\n      c && c(), delete this.pendingTrackResolvers[u.track.id];\n    }\n    try {\n      return this.pcManager.removeTrack(u), !0;\n    } catch (c) {\n      this.log.warn(\"failed to remove track\", Object.assign(Object.assign({}, this.logContext), {\n        error: c\n      }));\n    }\n    return !1;\n  }\n  updateMuteStatus(u, c) {\n    this.client.sendMuteTrack(u, c);\n  }\n  get dataSubscriberReadyState() {\n    var u;\n    return (u = this.reliableDCSub) === null || u === void 0 ? void 0 : u.readyState;\n  }\n  getConnectedServerAddress() {\n    var u;\n    return __awaiter(this, void 0, void 0, function* () {\n      return (u = this.pcManager) === null || u === void 0 ? void 0 : u.getConnectedAddress();\n    });\n  }\n  /* @internal */\n  setRegionUrlProvider(u) {\n    this.regionUrlProvider = u;\n  }\n  configure(u) {\n    var c;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW)\n        return;\n      this.participantSid = (c = u.participant) === null || c === void 0 ? void 0 : c.sid;\n      const l = this.makeRTCConfiguration(u);\n      this.pcManager = new PCTransportManager(l, u.subscriberPrimary, this.loggerOptions), this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber), this.pcManager.onIceCandidate = (v, S) => {\n        this.client.sendIceCandidate(v, S);\n      }, this.pcManager.onPublisherOffer = (v) => {\n        this.client.sendOffer(v);\n      }, this.pcManager.onDataChannel = this.handleDataChannel, this.pcManager.onStateChange = (v, S, g) => __awaiter(this, void 0, void 0, function* () {\n        if (this.log.debug(\"primary PC state changed \".concat(v), this.logContext), v === PCTransportState.CONNECTED) {\n          const E = this.pcState === PCState.New;\n          this.pcState = PCState.Connected, E && this.emit(EngineEvent.Connected, u);\n        } else\n          v === PCTransportState.FAILED && this.pcState === PCState.Connected && (this.pcState = PCState.Disconnected, this.handleDisconnect(\"peerconnection failed\", g === \"failed\" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED));\n      }), this.pcManager.onTrack = (v) => {\n        this.emit(EngineEvent.MediaTrackAdded, v.track, v.streams[0], v.receiver);\n      }, this.createDataChannels();\n    });\n  }\n  setupSignalClientCallbacks() {\n    this.client.onAnswer = (u) => __awaiter(this, void 0, void 0, function* () {\n      this.pcManager && (this.log.debug(\"received server answer\", Object.assign(Object.assign({}, this.logContext), {\n        RTCSdpType: u.type\n      })), yield this.pcManager.setPublisherAnswer(u));\n    }), this.client.onTrickle = (u, c) => {\n      this.pcManager && (this.log.trace(\"got ICE candidate from peer\", Object.assign(Object.assign({}, this.logContext), {\n        candidate: u,\n        target: c\n      })), this.pcManager.addIceCandidate(u, c));\n    }, this.client.onOffer = (u) => __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager)\n        return;\n      const c = yield this.pcManager.createSubscriberAnswerFromOffer(u);\n      this.client.sendAnswer(c);\n    }), this.client.onLocalTrackPublished = (u) => {\n      var c;\n      if (this.log.debug(\"received trackPublishedResponse\", Object.assign(Object.assign({}, this.logContext), {\n        cid: u.cid,\n        track: (c = u.track) === null || c === void 0 ? void 0 : c.sid\n      })), !this.pendingTrackResolvers[u.cid]) {\n        this.log.error(\"missing track resolver for \".concat(u.cid), Object.assign(Object.assign({}, this.logContext), {\n          cid: u.cid\n        }));\n        return;\n      }\n      const {\n        resolve: l\n      } = this.pendingTrackResolvers[u.cid];\n      delete this.pendingTrackResolvers[u.cid], l(u.track);\n    }, this.client.onLocalTrackUnpublished = (u) => {\n      this.emit(EngineEvent.LocalTrackUnpublished, u);\n    }, this.client.onTokenRefresh = (u) => {\n      this.token = u;\n    }, this.client.onRemoteMuteChanged = (u, c) => {\n      this.emit(EngineEvent.RemoteMute, u, c);\n    }, this.client.onSubscribedQualityUpdate = (u) => {\n      this.emit(EngineEvent.SubscribedQualityUpdate, u);\n    }, this.client.onClose = () => {\n      this.handleDisconnect(\"signal\", ReconnectReason.RR_SIGNAL_DISCONNECTED);\n    }, this.client.onLeave = (u) => {\n      u != null && u.canReconnect ? (this.fullReconnectOnNext = !0, this.handleDisconnect(leaveReconnect)) : (this.emit(EngineEvent.Disconnected, u == null ? void 0 : u.reason), this.close()), this.log.debug(\"client leave request\", Object.assign(Object.assign({}, this.logContext), {\n        reason: u == null ? void 0 : u.reason\n      }));\n    };\n  }\n  makeRTCConfiguration(u) {\n    var c;\n    const l = Object.assign({}, this.rtcConfig);\n    if (!((c = this.signalOpts) === null || c === void 0) && c.e2eeEnabled && (this.log.debug(\"E2EE - setting up transports with insertable streams\", this.logContext), l.encodedInsertableStreams = !0), u.iceServers && !l.iceServers) {\n      const v = [];\n      u.iceServers.forEach((S) => {\n        const g = {\n          urls: S.urls\n        };\n        S.username && (g.username = S.username), S.credential && (g.credential = S.credential), v.push(g);\n      }), l.iceServers = v;\n    }\n    return u.clientConfiguration && u.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED && (l.iceTransportPolicy = \"relay\"), l.sdpSemantics = \"unified-plan\", l.continualGatheringPolicy = \"gather_continually\", l;\n  }\n  createDataChannels() {\n    this.pcManager && (this.lossyDC && (this.lossyDC.onmessage = null, this.lossyDC.onerror = null), this.reliableDC && (this.reliableDC.onmessage = null, this.reliableDC.onerror = null), this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {\n      // will drop older packets that arrive\n      ordered: !0,\n      maxRetransmits: 0\n    }), this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {\n      ordered: !0\n    }), this.lossyDC.onmessage = this.handleDataMessage, this.reliableDC.onmessage = this.handleDataMessage, this.lossyDC.onerror = this.handleDataError, this.reliableDC.onerror = this.handleDataError, this.lossyDC.bufferedAmountLowThreshold = 65535, this.reliableDC.bufferedAmountLowThreshold = 65535, this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow, this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow);\n  }\n  setPreferredCodec(u, c, l) {\n    if (!(\"getCapabilities\" in RTCRtpSender))\n      return;\n    const v = RTCRtpSender.getCapabilities(c);\n    if (!v)\n      return;\n    this.log.debug(\"get sender capabilities\", Object.assign(Object.assign({}, this.logContext), {\n      cap: v\n    }));\n    const S = [], g = [], E = [];\n    v.codecs.forEach((_) => {\n      const k = _.mimeType.toLowerCase();\n      if (k === \"audio/opus\") {\n        S.push(_);\n        return;\n      }\n      if (!(k === \"video/\".concat(l))) {\n        E.push(_);\n        return;\n      }\n      if (l === \"h264\") {\n        _.sdpFmtpLine && _.sdpFmtpLine.includes(\"profile-level-id=42e01f\") ? S.push(_) : g.push(_);\n        return;\n      }\n      S.push(_);\n    }), supportsSetCodecPreferences(u) && u.setCodecPreferences(S.concat(g, E));\n  }\n  createSender(u, c, l) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (supportsTransceiver())\n        return yield this.createTransceiverRTCRtpSender(u, c, l);\n      if (supportsAddTrack())\n        return this.log.warn(\"using add-track fallback\", this.logContext), yield this.createRTCRtpSender(u.mediaStreamTrack);\n      throw new UnexpectedConnectionState(\"Required webRTC APIs not supported on this device\");\n    });\n  }\n  createSimulcastSender(u, c, l, v) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (supportsTransceiver())\n        return this.createSimulcastTransceiverSender(u, c, l, v);\n      if (supportsAddTrack())\n        return this.log.debug(\"using add-track fallback\", this.logContext), this.createRTCRtpSender(u.mediaStreamTrack);\n      throw new UnexpectedConnectionState(\"Cannot stream on this device\");\n    });\n  }\n  createTransceiverRTCRtpSender(u, c, l) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager)\n        throw new UnexpectedConnectionState(\"publisher is closed\");\n      const v = [];\n      u.mediaStream && v.push(u.mediaStream);\n      const S = {\n        direction: \"sendonly\",\n        streams: v\n      };\n      l && (S.sendEncodings = l);\n      const g = yield this.pcManager.addPublisherTransceiver(u.mediaStreamTrack, S);\n      return u.kind === Track.Kind.Video && c.videoCodec && (this.setPreferredCodec(g, u.kind, c.videoCodec), u.codec = c.videoCodec), g.sender;\n    });\n  }\n  createSimulcastTransceiverSender(u, c, l, v) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager)\n        throw new UnexpectedConnectionState(\"publisher is closed\");\n      const S = {\n        direction: \"sendonly\"\n      };\n      v && (S.sendEncodings = v);\n      const g = yield this.pcManager.addPublisherTransceiver(c.mediaStreamTrack, S);\n      if (l.videoCodec)\n        return this.setPreferredCodec(g, u.kind, l.videoCodec), u.setSimulcastTrackSender(l.videoCodec, g.sender), g.sender;\n    });\n  }\n  createRTCRtpSender(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager)\n        throw new UnexpectedConnectionState(\"publisher is closed\");\n      return this.pcManager.addPublisherTrack(u);\n    });\n  }\n  attemptReconnect(u) {\n    var c, l, v;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._isClosed) {\n        if (this.attemptingReconnect) {\n          livekitLogger.warn(\"already attempting reconnect, returning early\", this.logContext);\n          return;\n        }\n        (((c = this.clientConfiguration) === null || c === void 0 ? void 0 : c.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep\n        // those connections cannot be resumed\n        ((v = (l = this.pcManager) === null || l === void 0 ? void 0 : l.currentState) !== null && v !== void 0 ? v : PCTransportState.NEW) === PCTransportState.NEW) && (this.fullReconnectOnNext = !0);\n        try {\n          this.attemptingReconnect = !0, this.fullReconnectOnNext ? yield this.restartConnection() : yield this.resumeConnection(u), this.clearPendingReconnect(), this.fullReconnectOnNext = !1;\n        } catch (S) {\n          this.reconnectAttempts += 1;\n          let g = !0;\n          S instanceof UnexpectedConnectionState ? (this.log.debug(\"received unrecoverable error\", Object.assign(Object.assign({}, this.logContext), {\n            error: S\n          })), g = !1) : S instanceof SignalReconnectError || (this.fullReconnectOnNext = !0), g ? this.handleDisconnect(\"reconnect\", ReconnectReason.RR_UNKNOWN) : (this.log.info(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(Date.now() - this.reconnectStart, \"ms. giving up\"), this.logContext), this.emit(EngineEvent.Disconnected), yield this.close());\n        } finally {\n          this.attemptingReconnect = !1;\n        }\n      }\n    });\n  }\n  getNextRetryDelay(u) {\n    try {\n      return this.reconnectPolicy.nextRetryDelayInMs(u);\n    } catch (c) {\n      this.log.warn(\"encountered error in reconnect policy\", Object.assign(Object.assign({}, this.logContext), {\n        error: c\n      }));\n    }\n    return null;\n  }\n  restartConnection(u) {\n    var c, l, v;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!this.url || !this.token)\n          throw new UnexpectedConnectionState(\"could not reconnect, url or token not saved\");\n        this.log.info(\"reconnecting, attempt: \".concat(this.reconnectAttempts), this.logContext), this.emit(EngineEvent.Restarting), this.client.isDisconnected || (yield this.client.sendLeave()), yield this.cleanupPeerConnections(), yield this.cleanupClient();\n        let S;\n        try {\n          if (!this.signalOpts)\n            throw this.log.warn(\"attempted connection restart, without signal options present\", this.logContext), new SignalReconnectError();\n          S = yield this.join(u ?? this.url, this.token, this.signalOpts);\n        } catch (g) {\n          throw g instanceof ConnectionError && g.reason === 0 ? new UnexpectedConnectionState(\"could not reconnect, token might be expired\") : new SignalReconnectError();\n        }\n        if (this.shouldFailNext)\n          throw this.shouldFailNext = !1, new Error(\"simulated failure\");\n        if (this.client.setReconnected(), this.emit(EngineEvent.SignalRestarted, S), yield this.waitForPCReconnected(), this.client.currentState !== SignalConnectionState.CONNECTED)\n          throw new SignalReconnectError(\"Signal connection got severed during reconnect\");\n        (c = this.regionUrlProvider) === null || c === void 0 || c.resetAttempts(), this.emit(EngineEvent.Restarted);\n      } catch (S) {\n        const g = yield (l = this.regionUrlProvider) === null || l === void 0 ? void 0 : l.getNextBestRegionUrl();\n        if (g) {\n          yield this.restartConnection(g);\n          return;\n        } else\n          throw (v = this.regionUrlProvider) === null || v === void 0 || v.resetAttempts(), S;\n      }\n    });\n  }\n  resumeConnection(u) {\n    var c;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.url || !this.token)\n        throw new UnexpectedConnectionState(\"could not reconnect, url or token not saved\");\n      if (!this.pcManager)\n        throw new UnexpectedConnectionState(\"publisher and subscriber connections unset\");\n      this.log.info(\"resuming signal connection, attempt \".concat(this.reconnectAttempts), this.logContext), this.emit(EngineEvent.Resuming);\n      try {\n        this.setupSignalClientCallbacks();\n        const l = yield this.client.reconnect(this.url, this.token, this.participantSid, u);\n        if (l) {\n          const v = this.makeRTCConfiguration(l);\n          this.pcManager.updateConfiguration(v);\n        }\n      } catch (l) {\n        let v = \"\";\n        throw l instanceof Error && (v = l.message, this.log.error(l.message, Object.assign(Object.assign({}, this.logContext), {\n          error: l\n        }))), l instanceof ConnectionError && l.reason === 0 ? new UnexpectedConnectionState(\"could not reconnect, token might be expired\") : l instanceof ConnectionError && l.reason === 4 ? l : new SignalReconnectError(v);\n      }\n      if (this.emit(EngineEvent.SignalResumed), this.shouldFailNext)\n        throw this.shouldFailNext = !1, new Error(\"simulated failure\");\n      if (yield this.pcManager.triggerIceRestart(), yield this.waitForPCReconnected(), this.client.currentState !== SignalConnectionState.CONNECTED)\n        throw new SignalReconnectError(\"Signal connection got severed during reconnect\");\n      this.client.setReconnected(), ((c = this.reliableDC) === null || c === void 0 ? void 0 : c.readyState) === \"open\" && this.reliableDC.id === null && this.createDataChannels(), this.emit(EngineEvent.Resumed);\n    });\n  }\n  waitForPCInitialConnection(u, c) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager)\n        throw new UnexpectedConnectionState(\"PC manager is closed\");\n      yield this.pcManager.ensurePCTransportConnection(c, u);\n    });\n  }\n  waitForPCReconnected() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.pcState = PCState.Reconnecting, this.log.debug(\"waiting for peer connection to reconnect\", this.logContext);\n      try {\n        if (yield sleep(minReconnectWait), !this.pcManager)\n          throw new UnexpectedConnectionState(\"PC manager is closed\");\n        yield this.pcManager.ensurePCTransportConnection(void 0, this.peerConnectionTimeout), this.pcState = PCState.Connected;\n      } catch (u) {\n        throw this.pcState = PCState.Disconnected, new ConnectionError(\"could not establish PC connection, \".concat(u.message));\n      }\n    });\n  }\n  /* @internal */\n  sendDataPacket(u, c) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const l = u.toBinary();\n      yield this.ensurePublisherConnected(c);\n      const v = this.dataChannelForKind(c);\n      v && v.send(l), this.updateAndEmitDCBufferStatus(c);\n    });\n  }\n  /**\n   * @internal\n   */\n  ensureDataTransportConnected(u) {\n    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.subscriberPrimary;\n    var l;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.pcManager)\n        throw new UnexpectedConnectionState(\"PC manager is closed\");\n      const v = c ? this.pcManager.subscriber : this.pcManager.publisher, S = c ? \"Subscriber\" : \"Publisher\";\n      if (!v)\n        throw new ConnectionError(\"\".concat(S, \" connection not set\"));\n      !c && !this.pcManager.publisher.isICEConnected && this.pcManager.publisher.getICEConnectionState() !== \"checking\" && this.negotiate();\n      const g = this.dataChannelForKind(u, c);\n      if ((g == null ? void 0 : g.readyState) === \"open\")\n        return;\n      const E = (/* @__PURE__ */ new Date()).getTime() + this.peerConnectionTimeout;\n      for (; (/* @__PURE__ */ new Date()).getTime() < E; ) {\n        if (v.isICEConnected && ((l = this.dataChannelForKind(u, c)) === null || l === void 0 ? void 0 : l.readyState) === \"open\")\n          return;\n        yield sleep(50);\n      }\n      throw new ConnectionError(\"could not establish \".concat(S, \" connection, state: \").concat(v.getICEConnectionState()));\n    });\n  }\n  ensurePublisherConnected(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.ensureDataTransportConnected(u, !1);\n    });\n  }\n  /* @internal */\n  verifyTransport() {\n    return !(!this.pcManager || this.pcManager.currentState !== PCTransportState.CONNECTED || !this.client.ws || this.client.ws.readyState === WebSocket.CLOSED);\n  }\n  /** @internal */\n  negotiate() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((u, c) => __awaiter(this, void 0, void 0, function* () {\n        if (!this.pcManager) {\n          c(new NegotiationError(\"PC manager is closed\"));\n          return;\n        }\n        this.pcManager.requirePublisher();\n        const l = new AbortController(), v = () => {\n          l.abort(), this.log.debug(\"engine disconnected while negotiation was ongoing\", this.logContext), u();\n        };\n        this.isClosed && c(\"cannot negotiate on closed engine\"), this.on(EngineEvent.Closing, v), this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (S) => {\n          const g = /* @__PURE__ */ new Map();\n          S.forEach((E) => {\n            const _ = E.codec.toLowerCase();\n            isVideoCodec(_) && g.set(E.payload, _);\n          }), this.emit(EngineEvent.RTPVideoMapUpdate, g);\n        });\n        try {\n          yield this.pcManager.negotiate(l), u();\n        } catch (S) {\n          S instanceof NegotiationError && (this.fullReconnectOnNext = !0), this.handleDisconnect(\"negotiation\", ReconnectReason.RR_UNKNOWN), c(S);\n        } finally {\n          this.off(EngineEvent.Closing, v);\n        }\n      }));\n    });\n  }\n  dataChannelForKind(u, c) {\n    if (c) {\n      if (u === DataPacket_Kind.LOSSY)\n        return this.lossyDCSub;\n      if (u === DataPacket_Kind.RELIABLE)\n        return this.reliableDCSub;\n    } else {\n      if (u === DataPacket_Kind.LOSSY)\n        return this.lossyDC;\n      if (u === DataPacket_Kind.RELIABLE)\n        return this.reliableDC;\n    }\n  }\n  /** @internal */\n  sendSyncState(u, c) {\n    var l, v;\n    if (!this.pcManager) {\n      this.log.warn(\"sync state cannot be sent without peer connection setup\", this.logContext);\n      return;\n    }\n    const S = this.pcManager.subscriber.getLocalDescription(), g = this.pcManager.subscriber.getRemoteDescription(), E = (v = (l = this.signalOpts) === null || l === void 0 ? void 0 : l.autoSubscribe) !== null && v !== void 0 ? v : !0, _ = new Array(), k = new Array();\n    u.forEach((L) => {\n      L.isDesired !== E && _.push(L.trackSid), L.isEnabled || k.push(L.trackSid);\n    }), this.client.sendSyncState(new SyncState({\n      answer: S ? toProtoSessionDescription({\n        sdp: S.sdp,\n        type: S.type\n      }) : void 0,\n      offer: g ? toProtoSessionDescription({\n        sdp: g.sdp,\n        type: g.type\n      }) : void 0,\n      subscription: new UpdateSubscription({\n        trackSids: _,\n        subscribe: !E,\n        participantTracks: []\n      }),\n      publishTracks: getTrackPublicationInfo(c),\n      dataChannels: this.dataChannelsInfo(),\n      trackSidsDisabled: k\n    }));\n  }\n  /* @internal */\n  failNext() {\n    this.shouldFailNext = !0;\n  }\n  dataChannelsInfo() {\n    const u = [], c = (l, v) => {\n      (l == null ? void 0 : l.id) !== void 0 && l.id !== null && u.push(new DataChannelInfo({\n        label: l.label,\n        id: l.id,\n        target: v\n      }));\n    };\n    return c(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER), c(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER), c(this.dataChannelForKind(DataPacket_Kind.LOSSY, !0), SignalTarget.SUBSCRIBER), c(this.dataChannelForKind(DataPacket_Kind.RELIABLE, !0), SignalTarget.SUBSCRIBER), u;\n  }\n  clearReconnectTimeout() {\n    this.reconnectTimeout && CriticalTimers.clearTimeout(this.reconnectTimeout);\n  }\n  clearPendingReconnect() {\n    this.clearReconnectTimeout(), this.reconnectAttempts = 0;\n  }\n  registerOnLineListener() {\n    isWeb() && window.addEventListener(\"online\", this.handleBrowserOnLine);\n  }\n  deregisterOnLineListener() {\n    isWeb() && window.removeEventListener(\"online\", this.handleBrowserOnLine);\n  }\n}\nclass SignalReconnectError extends Error {\n}\nclass RegionUrlProvider {\n  constructor(u, c) {\n    this.lastUpdateAt = 0, this.settingsCacheTime = 3e3, this.attemptedRegions = [], this.serverUrl = new URL(u), this.token = c;\n  }\n  updateToken(u) {\n    this.token = u;\n  }\n  isCloud() {\n    return isCloud(this.serverUrl);\n  }\n  getServerUrl() {\n    return this.serverUrl;\n  }\n  getNextBestRegionUrl(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isCloud())\n        throw Error(\"region availability is only supported for LiveKit Cloud domains\");\n      (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) && (this.regionSettings = yield this.fetchRegionSettings(u));\n      const c = this.regionSettings.regions.filter((l) => !this.attemptedRegions.find((v) => v.url === l.url));\n      if (c.length > 0) {\n        const l = c[0];\n        return this.attemptedRegions.push(l), livekitLogger.debug(\"next region: \".concat(l.region)), l.url;\n      } else\n        return null;\n    });\n  }\n  resetAttempts() {\n    this.attemptedRegions = [];\n  }\n  /* @internal */\n  fetchRegionSettings(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const c = yield fetch(\"\".concat(getCloudConfigUrl(this.serverUrl), \"/regions\"), {\n        headers: {\n          authorization: \"Bearer \".concat(this.token)\n        },\n        signal: u\n      });\n      if (c.ok) {\n        const l = yield c.json();\n        return this.lastUpdateAt = Date.now(), l;\n      } else\n        throw new ConnectionError(\"Could not fetch region settings: \".concat(c.statusText), c.status === 401 ? 0 : void 0, c.status);\n    });\n  }\n}\nfunction getCloudConfigUrl(a) {\n  return \"\".concat(a.protocol.replace(\"ws\", \"http\"), \"//\").concat(a.host, \"/settings\");\n}\nconst monitorFrequency = 2e3;\nfunction computeBitrate(a, u) {\n  if (!u)\n    return 0;\n  let c, l;\n  return \"bytesReceived\" in a ? (c = a.bytesReceived, l = u.bytesReceived) : \"bytesSent\" in a && (c = a.bytesSent, l = u.bytesSent), c === void 0 || l === void 0 || a.timestamp === void 0 || u.timestamp === void 0 ? 0 : (c - l) * 8 * 1e3 / (a.timestamp - u.timestamp);\n}\nclass LocalAudioTrack extends LocalTrack {\n  /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */\n  constructor(u, c) {\n    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, v = arguments.length > 3 ? arguments[3] : void 0, S = arguments.length > 4 ? arguments[4] : void 0;\n    super(u, Track.Kind.Audio, c, l, S), this.stopOnMute = !1, this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.sender) {\n        this._currentBitrate = 0;\n        return;\n      }\n      let g;\n      try {\n        g = yield this.getSenderStats();\n      } catch (E) {\n        this.log.error(\"could not get audio sender stats\", Object.assign(Object.assign({}, this.logContext), {\n          error: E\n        }));\n        return;\n      }\n      g && this.prevStats && (this._currentBitrate = computeBitrate(g, this.prevStats)), this.prevStats = g;\n    }), this.audioContext = v, this.checkForSilence();\n  }\n  setDeviceId(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this._constraints.deviceId === u ? !0 : (this._constraints.deviceId = u, this.isMuted || (yield this.restartTrack()), this.isMuted || unwrapConstraint(u) === this.mediaStreamTrack.getSettings().deviceId);\n    });\n  }\n  mute() {\n    const u = Object.create(null, {\n      mute: {\n        get: () => super.mute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const c = yield this.muteLock.lock();\n      try {\n        return this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided && (this.log.debug(\"stopping mic track\", this.logContext), this._mediaStreamTrack.stop()), yield u.mute.call(this), this;\n      } finally {\n        c();\n      }\n    });\n  }\n  unmute() {\n    const u = Object.create(null, {\n      unmute: {\n        get: () => super.unmute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const c = yield this.muteLock.lock();\n      try {\n        const l = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);\n        return this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === \"ended\" || l) && !this.isUserProvided && (this.log.debug(\"reacquiring mic track\", this.logContext), yield this.restartTrack()), yield u.unmute.call(this), this;\n      } finally {\n        c();\n      }\n    });\n  }\n  restartTrack(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let c;\n      if (u) {\n        const l = constraintsForOptions({\n          audio: u\n        });\n        typeof l.audio != \"boolean\" && (c = l.audio);\n      }\n      yield this.restart(c);\n    });\n  }\n  restart(u) {\n    const c = Object.create(null, {\n      restart: {\n        get: () => super.restart\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const l = yield c.restart.call(this, u);\n      return this.checkForSilence(), l;\n    });\n  }\n  /* @internal */\n  startMonitor() {\n    isWeb() && (this.monitorInterval || (this.monitorInterval = setInterval(() => {\n      this.monitorSender();\n    }, monitorFrequency)));\n  }\n  setProcessor(u) {\n    var c;\n    return __awaiter(this, void 0, void 0, function* () {\n      const l = yield this.processorLock.lock();\n      try {\n        if (!this.audioContext)\n          throw Error(\"Audio context needs to be set on LocalAudioTrack in order to enable processors\");\n        if (this.processor && (yield this.stopProcessor()), this.kind === \"unknown\")\n          throw TypeError(\"cannot set processor on track of unknown kind\");\n        const v = {\n          kind: this.kind,\n          track: this._mediaStreamTrack,\n          audioContext: this.audioContext\n        };\n        this.log.debug(\"setting up audio processor \".concat(u.name), this.logContext), yield u.init(v), this.processor = u, this.processor.processedTrack && (yield (c = this.sender) === null || c === void 0 ? void 0 : c.replaceTrack(this.processor.processedTrack));\n      } finally {\n        l();\n      }\n    });\n  }\n  /**\n   * @internal\n   * @experimental\n   */\n  setAudioContext(u) {\n    this.audioContext = u;\n  }\n  getSenderStats() {\n    var u;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!(!((u = this.sender) === null || u === void 0) && u.getStats))\n        return;\n      const c = yield this.sender.getStats();\n      let l;\n      return c.forEach((v) => {\n        v.type === \"outbound-rtp\" && (l = {\n          type: \"audio\",\n          streamId: v.id,\n          packetsSent: v.packetsSent,\n          packetsLost: v.packetsLost,\n          bytesSent: v.bytesSent,\n          timestamp: v.timestamp,\n          roundTripTime: v.roundTripTime,\n          jitter: v.jitter\n        });\n      }), l;\n    });\n  }\n  checkForSilence() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const u = yield detectSilence(this);\n      return u && (this.isMuted || this.log.warn(\"silence detected on local audio track\", this.logContext), this.emit(TrackEvent.AudioSilenceDetected)), u;\n    });\n  }\n}\nfunction mediaTrackToLocalTrack(a, u, c) {\n  switch (a.kind) {\n    case \"audio\":\n      return new LocalAudioTrack(a, u, !1, void 0, c);\n    case \"video\":\n      return new LocalVideoTrack(a, u, !1, c);\n    default:\n      throw new TrackInvalidError(\"unsupported track type: \".concat(a.kind));\n  }\n}\nconst presets169 = Object.values(VideoPresets), presets43 = Object.values(VideoPresets43), presetsScreenShare = Object.values(ScreenSharePresets), defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360], defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360], computeDefaultScreenShareSimulcastPresets = (a) => [{\n  scaleResolutionDownBy: 2,\n  fps: a.encoding.maxFramerate\n}].map((c) => {\n  var l, v;\n  return new VideoPreset(Math.floor(a.width / c.scaleResolutionDownBy), Math.floor(a.height / c.scaleResolutionDownBy), Math.max(15e4, Math.floor(a.encoding.maxBitrate / (Math.pow(c.scaleResolutionDownBy, 2) * (((l = a.encoding.maxFramerate) !== null && l !== void 0 ? l : 30) / ((v = c.fps) !== null && v !== void 0 ? v : 30))))), c.fps, a.encoding.priority);\n}), videoRids = [\"q\", \"h\", \"f\"];\nfunction computeVideoEncodings(a, u, c, l) {\n  var v, S;\n  let g = l == null ? void 0 : l.videoEncoding;\n  a && (g = l == null ? void 0 : l.screenShareEncoding);\n  const E = l == null ? void 0 : l.simulcast, _ = l == null ? void 0 : l.scalabilityMode, k = l == null ? void 0 : l.videoCodec;\n  if (!g && !E && !_ || !u || !c)\n    return [{}];\n  g || (g = determineAppropriateEncoding(a, u, c, k), livekitLogger.debug(\"using video encoding\", g));\n  const L = new VideoPreset(u, c, g.maxBitrate, g.maxFramerate, g.priority);\n  if (_ && isSVCCodec(k)) {\n    livekitLogger.debug(\"using svc with scalabilityMode \".concat(_));\n    const J = new ScalabilityMode(_), V = [];\n    if (J.spatial > 3)\n      throw new Error(\"unsupported scalabilityMode: \".concat(_));\n    for (let q = 0; q < J.spatial; q += 1)\n      V.push({\n        rid: videoRids[2 - q],\n        maxBitrate: g.maxBitrate / Math.pow(3, q),\n        /* @ts-ignore */\n        maxFramerate: L.encoding.maxFramerate\n      });\n    return V[0].scalabilityMode = _, livekitLogger.debug(\"encodings\", V), V;\n  }\n  if (!E)\n    return [g];\n  let M = [];\n  a ? M = (v = sortPresets(l == null ? void 0 : l.screenShareSimulcastLayers)) !== null && v !== void 0 ? v : defaultSimulcastLayers(a, L) : M = (S = sortPresets(l == null ? void 0 : l.videoSimulcastLayers)) !== null && S !== void 0 ? S : defaultSimulcastLayers(a, L);\n  let $;\n  if (M.length > 0) {\n    const J = M[0];\n    M.length > 1 && ([, $] = M);\n    const V = Math.max(u, c);\n    if (V >= 960 && $)\n      return encodingsFromPresets(u, c, [J, $, L]);\n    if (V >= 480)\n      return encodingsFromPresets(u, c, [J, L]);\n  }\n  return encodingsFromPresets(u, c, [L]);\n}\nfunction computeTrackBackupEncodings(a, u, c) {\n  var l, v, S, g;\n  if (!c.backupCodec || c.backupCodec === !0 || c.backupCodec.codec === c.videoCodec)\n    return;\n  u !== c.backupCodec.codec && livekitLogger.warn(\"requested a different codec than specified as backup\", {\n    serverRequested: u,\n    backup: c.backupCodec.codec\n  }), c.videoCodec = u, c.videoEncoding = c.backupCodec.encoding;\n  const E = a.mediaStreamTrack.getSettings(), _ = (l = E.width) !== null && l !== void 0 ? l : (v = a.dimensions) === null || v === void 0 ? void 0 : v.width, k = (S = E.height) !== null && S !== void 0 ? S : (g = a.dimensions) === null || g === void 0 ? void 0 : g.height;\n  return computeVideoEncodings(a.source === Track.Source.ScreenShare, _, k, c);\n}\nfunction determineAppropriateEncoding(a, u, c, l) {\n  const v = presetsForResolution(a, u, c);\n  let {\n    encoding: S\n  } = v[0];\n  const g = Math.max(u, c);\n  for (let E = 0; E < v.length; E += 1) {\n    const _ = v[E];\n    if (S = _.encoding, _.width >= g)\n      break;\n  }\n  if (l)\n    switch (l) {\n      case \"av1\":\n        S = Object.assign({}, S), S.maxBitrate = S.maxBitrate * 0.7;\n        break;\n      case \"vp9\":\n        S = Object.assign({}, S), S.maxBitrate = S.maxBitrate * 0.85;\n        break;\n    }\n  return S;\n}\nfunction presetsForResolution(a, u, c) {\n  if (a)\n    return presetsScreenShare;\n  const l = u > c ? u / c : c / u;\n  return Math.abs(l - 16 / 9) < Math.abs(l - 4 / 3) ? presets169 : presets43;\n}\nfunction defaultSimulcastLayers(a, u) {\n  if (a)\n    return computeDefaultScreenShareSimulcastPresets(u);\n  const {\n    width: c,\n    height: l\n  } = u, v = c > l ? c / l : l / c;\n  return Math.abs(v - 16 / 9) < Math.abs(v - 4 / 3) ? defaultSimulcastPresets169 : defaultSimulcastPresets43;\n}\nfunction encodingsFromPresets(a, u, c) {\n  const l = [];\n  if (c.forEach((v, S) => {\n    if (S >= videoRids.length)\n      return;\n    const g = Math.min(a, u), _ = {\n      rid: videoRids[S],\n      scaleResolutionDownBy: Math.max(1, g / Math.min(v.width, v.height)),\n      maxBitrate: v.encoding.maxBitrate\n    };\n    v.encoding.maxFramerate && (_.maxFramerate = v.encoding.maxFramerate);\n    const k = isFireFox() || S === 0;\n    v.encoding.priority && k && (_.priority = v.encoding.priority, _.networkPriority = v.encoding.priority), l.push(_);\n  }), isReactNative() && getReactNativeOs() === \"ios\") {\n    let v;\n    l.forEach((g) => {\n      v ? g.maxFramerate && g.maxFramerate > v && (v = g.maxFramerate) : v = g.maxFramerate;\n    });\n    let S = !0;\n    l.forEach((g) => {\n      var E;\n      g.maxFramerate != v && (S && (S = !1, livekitLogger.info(\"Simulcast on iOS React-Native requires all encodings to share the same framerate.\")), livekitLogger.info('Setting framerate of encoding \"'.concat((E = g.rid) !== null && E !== void 0 ? E : \"\", '\" to ').concat(v)), g.maxFramerate = v);\n    });\n  }\n  return l;\n}\nfunction sortPresets(a) {\n  if (a)\n    return a.sort((u, c) => {\n      const {\n        encoding: l\n      } = u, {\n        encoding: v\n      } = c;\n      return l.maxBitrate > v.maxBitrate ? 1 : l.maxBitrate < v.maxBitrate ? -1 : l.maxBitrate === v.maxBitrate && l.maxFramerate && v.maxFramerate ? l.maxFramerate > v.maxFramerate ? 1 : -1 : 0;\n    });\n}\nclass ScalabilityMode {\n  constructor(u) {\n    const c = u.match(/^L(\\d)T(\\d)(h|_KEY|_KEY_SHIFT){0,1}$/);\n    if (!c)\n      throw new Error(\"invalid scalability mode\");\n    if (this.spatial = parseInt(c[1]), this.temporal = parseInt(c[2]), c.length > 3)\n      switch (c[3]) {\n        case \"h\":\n        case \"_KEY\":\n        case \"_KEY_SHIFT\":\n          this.suffix = c[3];\n      }\n  }\n  toString() {\n    var u;\n    return \"L\".concat(this.spatial, \"T\").concat(this.temporal).concat((u = this.suffix) !== null && u !== void 0 ? u : \"\");\n  }\n}\nconst refreshSubscribedCodecAfterNewCodec = 5e3;\nclass LocalVideoTrack extends LocalTrack {\n  /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */\n  constructor(u, c) {\n    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, v = arguments.length > 3 ? arguments[3] : void 0;\n    super(u, Track.Kind.Video, c, l, v), this.simulcastCodecs = /* @__PURE__ */ new Map(), this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.sender) {\n        this._currentBitrate = 0;\n        return;\n      }\n      let S;\n      try {\n        S = yield this.getSenderStats();\n      } catch (E) {\n        this.log.error(\"could not get audio sender stats\", Object.assign(Object.assign({}, this.logContext), {\n          error: E\n        }));\n        return;\n      }\n      const g = new Map(S.map((E) => [E.rid, E]));\n      if (this.prevStats) {\n        let E = 0;\n        g.forEach((_, k) => {\n          var L;\n          const M = (L = this.prevStats) === null || L === void 0 ? void 0 : L.get(k);\n          E += computeBitrate(_, M);\n        }), this._currentBitrate = E;\n      }\n      this.prevStats = g;\n    }), this.senderLock = new Mutex();\n  }\n  get isSimulcast() {\n    return !!(this.sender && this.sender.getParameters().encodings.length > 1);\n  }\n  /* @internal */\n  startMonitor(u) {\n    var c;\n    if (this.signalClient = u, !isWeb())\n      return;\n    const l = (c = this.sender) === null || c === void 0 ? void 0 : c.getParameters();\n    l && (this.encodings = l.encodings), !this.monitorInterval && (this.monitorInterval = setInterval(() => {\n      this.monitorSender();\n    }, monitorFrequency));\n  }\n  stop() {\n    this._mediaStreamTrack.getConstraints(), this.simulcastCodecs.forEach((u) => {\n      u.mediaStreamTrack.stop();\n    }), super.stop();\n  }\n  pauseUpstream() {\n    const u = Object.create(null, {\n      pauseUpstream: {\n        get: () => super.pauseUpstream\n      }\n    });\n    var c, l, v, S, g;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield u.pauseUpstream.call(this);\n      try {\n        for (var E = !0, _ = __asyncValues(this.simulcastCodecs.values()), k; k = yield _.next(), c = k.done, !c; E = !0)\n          S = k.value, E = !1, yield (g = S.sender) === null || g === void 0 ? void 0 : g.replaceTrack(null);\n      } catch (L) {\n        l = {\n          error: L\n        };\n      } finally {\n        try {\n          !E && !c && (v = _.return) && (yield v.call(_));\n        } finally {\n          if (l)\n            throw l.error;\n        }\n      }\n    });\n  }\n  resumeUpstream() {\n    const u = Object.create(null, {\n      resumeUpstream: {\n        get: () => super.resumeUpstream\n      }\n    });\n    var c, l, v, S, g;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield u.resumeUpstream.call(this);\n      try {\n        for (var E = !0, _ = __asyncValues(this.simulcastCodecs.values()), k; k = yield _.next(), c = k.done, !c; E = !0) {\n          S = k.value, E = !1;\n          const L = S;\n          yield (g = L.sender) === null || g === void 0 ? void 0 : g.replaceTrack(L.mediaStreamTrack);\n        }\n      } catch (L) {\n        l = {\n          error: L\n        };\n      } finally {\n        try {\n          !E && !c && (v = _.return) && (yield v.call(_));\n        } finally {\n          if (l)\n            throw l.error;\n        }\n      }\n    });\n  }\n  mute() {\n    const u = Object.create(null, {\n      mute: {\n        get: () => super.mute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const c = yield this.muteLock.lock();\n      try {\n        return this.source === Track.Source.Camera && !this.isUserProvided && (this.log.debug(\"stopping camera track\", this.logContext), this._mediaStreamTrack.stop()), yield u.mute.call(this), this;\n      } finally {\n        c();\n      }\n    });\n  }\n  unmute() {\n    const u = Object.create(null, {\n      unmute: {\n        get: () => super.unmute\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const c = yield this.muteLock.lock();\n      try {\n        return this.source === Track.Source.Camera && !this.isUserProvided && (this.log.debug(\"reacquiring camera track\", this.logContext), yield this.restartTrack()), yield u.unmute.call(this), this;\n      } finally {\n        c();\n      }\n    });\n  }\n  setTrackMuted(u) {\n    super.setTrackMuted(u);\n    for (const c of this.simulcastCodecs.values())\n      c.mediaStreamTrack.enabled = !u;\n  }\n  getSenderStats() {\n    var u;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!(!((u = this.sender) === null || u === void 0) && u.getStats))\n        return [];\n      const c = [], l = yield this.sender.getStats();\n      return l.forEach((v) => {\n        var S;\n        if (v.type === \"outbound-rtp\") {\n          const g = {\n            type: \"video\",\n            streamId: v.id,\n            frameHeight: v.frameHeight,\n            frameWidth: v.frameWidth,\n            firCount: v.firCount,\n            pliCount: v.pliCount,\n            nackCount: v.nackCount,\n            packetsSent: v.packetsSent,\n            bytesSent: v.bytesSent,\n            framesSent: v.framesSent,\n            timestamp: v.timestamp,\n            rid: (S = v.rid) !== null && S !== void 0 ? S : v.id,\n            retransmittedPacketsSent: v.retransmittedPacketsSent,\n            qualityLimitationReason: v.qualityLimitationReason,\n            qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges\n          }, E = l.get(v.remoteId);\n          E && (g.jitter = E.jitter, g.packetsLost = E.packetsLost, g.roundTripTime = E.roundTripTime), c.push(g);\n        }\n      }), c;\n    });\n  }\n  setPublishingQuality(u) {\n    const c = [];\n    for (let l = VideoQuality.LOW; l <= VideoQuality.HIGH; l += 1)\n      c.push(new SubscribedQuality({\n        quality: l,\n        enabled: l <= u\n      }));\n    this.log.debug(\"setting publishing quality. max quality \".concat(u), this.logContext), this.setPublishingLayers(c);\n  }\n  setDeviceId(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this._constraints.deviceId === u && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(u) ? !0 : (this._constraints.deviceId = u, this.isMuted || (yield this.restartTrack()), this.isMuted || unwrapConstraint(u) === this._mediaStreamTrack.getSettings().deviceId);\n    });\n  }\n  restartTrack(u) {\n    var c, l, v, S;\n    return __awaiter(this, void 0, void 0, function* () {\n      let g;\n      if (u) {\n        const L = constraintsForOptions({\n          video: u\n        });\n        typeof L.video != \"boolean\" && (g = L.video);\n      }\n      yield this.restart(g);\n      try {\n        for (var E = !0, _ = __asyncValues(this.simulcastCodecs.values()), k; k = yield _.next(), c = k.done, !c; E = !0) {\n          S = k.value, E = !1;\n          const L = S;\n          L.sender && (L.mediaStreamTrack = this.mediaStreamTrack.clone(), yield L.sender.replaceTrack(L.mediaStreamTrack));\n        }\n      } catch (L) {\n        l = {\n          error: L\n        };\n      } finally {\n        try {\n          !E && !c && (v = _.return) && (yield v.call(_));\n        } finally {\n          if (l)\n            throw l.error;\n        }\n      }\n    });\n  }\n  setProcessor(u) {\n    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;\n    const l = Object.create(null, {\n      setProcessor: {\n        get: () => super.setProcessor\n      }\n    });\n    var v, S, g, E, _, k;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (yield l.setProcessor.call(this, u, c), !((_ = this.processor) === null || _ === void 0) && _.processedTrack)\n        try {\n          for (var L = !0, M = __asyncValues(this.simulcastCodecs.values()), $; $ = yield M.next(), v = $.done, !v; L = !0)\n            E = $.value, L = !1, yield (k = E.sender) === null || k === void 0 ? void 0 : k.replaceTrack(this.processor.processedTrack);\n        } catch (J) {\n          S = {\n            error: J\n          };\n        } finally {\n          try {\n            !L && !v && (g = M.return) && (yield g.call(M));\n          } finally {\n            if (S)\n              throw S.error;\n          }\n        }\n    });\n  }\n  addSimulcastTrack(u, c) {\n    if (this.simulcastCodecs.has(u)) {\n      this.log.error(\"\".concat(u, \" already added, skipping adding simulcast codec\"), this.logContext);\n      return;\n    }\n    const l = {\n      codec: u,\n      mediaStreamTrack: this.mediaStreamTrack.clone(),\n      sender: void 0,\n      encodings: c\n    };\n    return this.simulcastCodecs.set(u, l), l;\n  }\n  setSimulcastTrackSender(u, c) {\n    const l = this.simulcastCodecs.get(u);\n    l && (l.sender = c, setTimeout(() => {\n      this.subscribedCodecs && this.setPublishingCodecs(this.subscribedCodecs);\n    }, refreshSubscribedCodecAfterNewCodec));\n  }\n  /**\n   * @internal\n   * Sets codecs that should be publishing, returns new codecs that have not yet\n   * been published\n   */\n  setPublishingCodecs(u) {\n    var c, l, v, S, g, E, _;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.log.debug(\"setting publishing codecs\", Object.assign(Object.assign({}, this.logContext), {\n        codecs: u,\n        currentCodec: this.codec\n      })), !this.codec && u.length > 0)\n        return yield this.setPublishingLayers(u[0].qualities), [];\n      this.subscribedCodecs = u;\n      const k = [];\n      try {\n        for (c = !0, l = __asyncValues(u); v = yield l.next(), S = v.done, !S; c = !0) {\n          _ = v.value, c = !1;\n          const L = _;\n          if (!this.codec || this.codec === L.codec)\n            yield this.setPublishingLayers(L.qualities);\n          else {\n            const M = this.simulcastCodecs.get(L.codec);\n            if (this.log.debug(\"try setPublishingCodec for \".concat(L.codec), Object.assign(Object.assign({}, this.logContext), {\n              simulcastCodecInfo: M\n            })), !M || !M.sender) {\n              for (const $ of L.qualities)\n                if ($.enabled) {\n                  k.push(L.codec);\n                  break;\n                }\n            } else\n              M.encodings && (this.log.debug(\"try setPublishingLayersForSender \".concat(L.codec), this.logContext), yield setPublishingLayersForSender(M.sender, M.encodings, L.qualities, this.senderLock, this.log, this.logContext));\n          }\n        }\n      } catch (L) {\n        g = {\n          error: L\n        };\n      } finally {\n        try {\n          !c && !S && (E = l.return) && (yield E.call(l));\n        } finally {\n          if (g)\n            throw g.error;\n        }\n      }\n      return k;\n    });\n  }\n  /**\n   * @internal\n   * Sets layers that should be publishing\n   */\n  setPublishingLayers(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.log.debug(\"setting publishing layers\", Object.assign(Object.assign({}, this.logContext), {\n        qualities: u\n      })), !(!this.sender || !this.encodings) && (yield setPublishingLayersForSender(this.sender, this.encodings, u, this.senderLock, this.log, this.logContext));\n    });\n  }\n  handleAppVisibilityChanged() {\n    const u = Object.create(null, {\n      handleAppVisibilityChanged: {\n        get: () => super.handleAppVisibilityChanged\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      yield u.handleAppVisibilityChanged.call(this), isMobile() && this.isInBackground && this.source === Track.Source.Camera && (this._mediaStreamTrack.enabled = !1);\n    });\n  }\n}\nfunction setPublishingLayersForSender(a, u, c, l, v, S) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const g = yield l.lock();\n    v.debug(\"setPublishingLayersForSender\", Object.assign(Object.assign({}, S), {\n      sender: a,\n      qualities: c,\n      senderEncodings: u\n    }));\n    try {\n      const E = a.getParameters(), {\n        encodings: _\n      } = E;\n      if (!_)\n        return;\n      if (_.length !== u.length) {\n        v.warn(\"cannot set publishing layers, encodings mismatch\");\n        return;\n      }\n      let k = !1;\n      !1 && _[0].scalabilityMode || _.forEach((M, $) => {\n        var J;\n        let V = (J = M.rid) !== null && J !== void 0 ? J : \"\";\n        V === \"\" && (V = \"q\");\n        const q = videoQualityForRid(V), G = c.find((H) => H.quality === q);\n        G && M.active !== G.enabled && (k = !0, M.active = G.enabled, v.debug(\"setting layer \".concat(G.quality, \" to \").concat(M.active ? \"enabled\" : \"disabled\"), S), isFireFox() && (G.enabled ? (M.scaleResolutionDownBy = u[$].scaleResolutionDownBy, M.maxBitrate = u[$].maxBitrate, M.maxFrameRate = u[$].maxFrameRate) : (M.scaleResolutionDownBy = 4, M.maxBitrate = 10, M.maxFrameRate = 2)));\n      }), k && (E.encodings = _, v.debug(\"setting encodings\", Object.assign(Object.assign({}, S), {\n        encodings: E.encodings\n      })), yield a.setParameters(E));\n    } finally {\n      g();\n    }\n  });\n}\nfunction videoQualityForRid(a) {\n  switch (a) {\n    case \"f\":\n      return VideoQuality.HIGH;\n    case \"h\":\n      return VideoQuality.MEDIUM;\n    case \"q\":\n      return VideoQuality.LOW;\n    default:\n      return VideoQuality.HIGH;\n  }\n}\nfunction videoLayersFromEncodings(a, u, c, l) {\n  if (!c)\n    return [new VideoLayer({\n      quality: VideoQuality.HIGH,\n      width: a,\n      height: u,\n      bitrate: 0,\n      ssrc: 0\n    })];\n  if (l) {\n    const v = c[0].scalabilityMode, S = new ScalabilityMode(v), g = [];\n    for (let E = 0; E < S.spatial; E += 1)\n      g.push(new VideoLayer({\n        quality: VideoQuality.HIGH - E,\n        width: Math.ceil(a / Math.pow(2, E)),\n        height: Math.ceil(u / Math.pow(2, E)),\n        bitrate: c[0].maxBitrate ? Math.ceil(c[0].maxBitrate / Math.pow(3, E)) : 0,\n        ssrc: 0\n      }));\n    return g;\n  }\n  return c.map((v) => {\n    var S, g, E;\n    const _ = (S = v.scaleResolutionDownBy) !== null && S !== void 0 ? S : 1;\n    let k = videoQualityForRid((g = v.rid) !== null && g !== void 0 ? g : \"\");\n    return new VideoLayer({\n      quality: k,\n      width: Math.ceil(a / _),\n      height: Math.ceil(u / _),\n      bitrate: (E = v.maxBitrate) !== null && E !== void 0 ? E : 0,\n      ssrc: 0\n    });\n  });\n}\nclass RemoteTrack extends Track {\n  constructor(u, c, l, v, S) {\n    super(u, l, S), this.sid = c, this.receiver = v;\n  }\n  /** @internal */\n  setMuted(u) {\n    this.isMuted !== u && (this.isMuted = u, this._mediaStreamTrack.enabled = !u, this.emit(u ? TrackEvent.Muted : TrackEvent.Unmuted, this));\n  }\n  /** @internal */\n  setMediaStream(u) {\n    this.mediaStream = u;\n    const c = (l) => {\n      l.track === this._mediaStreamTrack && (u.removeEventListener(\"removetrack\", c), this.receiver = void 0, this._currentBitrate = 0, this.emit(TrackEvent.Ended, this));\n    };\n    u.addEventListener(\"removetrack\", c);\n  }\n  start() {\n    this.startMonitor(), super.enable();\n  }\n  stop() {\n    this.stopMonitor(), super.disable();\n  }\n  /**\n   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */\n  getRTCStatsReport() {\n    var u;\n    return __awaiter(this, void 0, void 0, function* () {\n      return !((u = this.receiver) === null || u === void 0) && u.getStats ? yield this.receiver.getStats() : void 0;\n    });\n  }\n  /* @internal */\n  startMonitor() {\n    this.monitorInterval || (this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency));\n  }\n}\nclass RemoteAudioTrack extends RemoteTrack {\n  constructor(u, c, l, v, S, g) {\n    super(u, c, Track.Kind.Audio, l, g), this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver) {\n        this._currentBitrate = 0;\n        return;\n      }\n      const E = yield this.getReceiverStats();\n      E && this.prevStats && this.receiver && (this._currentBitrate = computeBitrate(E, this.prevStats)), this.prevStats = E;\n    }), this.audioContext = v, this.webAudioPluginNodes = [], S && (this.sinkId = S.deviceId);\n  }\n  /**\n   * sets the volume for all attached audio elements\n   */\n  setVolume(u) {\n    var c;\n    for (const l of this.attachedElements)\n      this.audioContext ? (c = this.gainNode) === null || c === void 0 || c.gain.setTargetAtTime(u, 0, 0.1) : l.volume = u;\n    isReactNative() && this._mediaStreamTrack._setVolume(u), this.elementVolume = u;\n  }\n  /**\n   * gets the volume of attached audio elements (loudest)\n   */\n  getVolume() {\n    if (this.elementVolume)\n      return this.elementVolume;\n    if (isReactNative())\n      return 1;\n    let u = 0;\n    return this.attachedElements.forEach((c) => {\n      c.volume > u && (u = c.volume);\n    }), u;\n  }\n  /**\n   * calls setSinkId on all attached elements, if supported\n   * @param deviceId audio output device\n   */\n  setSinkId(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.sinkId = u, yield Promise.all(this.attachedElements.map((c) => {\n        if (supportsSetSinkId(c))\n          return c.setSinkId(u);\n      }));\n    });\n  }\n  attach(u) {\n    const c = this.attachedElements.length === 0;\n    return u ? super.attach(u) : u = super.attach(), this.sinkId && supportsSetSinkId(u) && u.setSinkId(this.sinkId), this.audioContext && c && (this.log.debug(\"using audio context mapping\", this.logContext), this.connectWebAudio(this.audioContext, u), u.volume = 0, u.muted = !0), this.elementVolume && this.setVolume(this.elementVolume), u;\n  }\n  detach(u) {\n    let c;\n    return u ? (c = super.detach(u), this.audioContext && (this.attachedElements.length > 0 ? this.connectWebAudio(this.audioContext, this.attachedElements[0]) : this.disconnectWebAudio())) : (c = super.detach(), this.disconnectWebAudio()), c;\n  }\n  /**\n   * @internal\n   * @experimental\n   */\n  setAudioContext(u) {\n    this.audioContext = u, u && this.attachedElements.length > 0 ? this.connectWebAudio(u, this.attachedElements[0]) : u || this.disconnectWebAudio();\n  }\n  /**\n   * @internal\n   * @experimental\n   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.\n   */\n  setWebAudioPlugins(u) {\n    this.webAudioPluginNodes = u, this.attachedElements.length > 0 && this.audioContext && this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n  }\n  connectWebAudio(u, c) {\n    this.disconnectWebAudio(), this.sourceNode = u.createMediaStreamSource(c.srcObject);\n    let l = this.sourceNode;\n    this.webAudioPluginNodes.forEach((v) => {\n      l.connect(v), l = v;\n    }), this.gainNode = u.createGain(), l.connect(this.gainNode), this.gainNode.connect(u.destination), this.elementVolume && this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1), u.state !== \"running\" && u.resume().then(() => {\n      u.state !== \"running\" && this.emit(TrackEvent.AudioPlaybackFailed, new Error(\"Audio Context couldn't be started automatically\"));\n    }).catch((v) => {\n      this.emit(TrackEvent.AudioPlaybackFailed, v);\n    });\n  }\n  disconnectWebAudio() {\n    var u, c;\n    (u = this.gainNode) === null || u === void 0 || u.disconnect(), (c = this.sourceNode) === null || c === void 0 || c.disconnect(), this.gainNode = void 0, this.sourceNode = void 0;\n  }\n  getReceiverStats() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver || !this.receiver.getStats)\n        return;\n      const u = yield this.receiver.getStats();\n      let c;\n      return u.forEach((l) => {\n        l.type === \"inbound-rtp\" && (c = {\n          type: \"audio\",\n          timestamp: l.timestamp,\n          jitter: l.jitter,\n          bytesReceived: l.bytesReceived,\n          concealedSamples: l.concealedSamples,\n          concealmentEvents: l.concealmentEvents,\n          silentConcealedSamples: l.silentConcealedSamples,\n          silentConcealmentEvents: l.silentConcealmentEvents,\n          totalAudioEnergy: l.totalAudioEnergy,\n          totalSamplesDuration: l.totalSamplesDuration\n        });\n      }), c;\n    });\n  }\n}\nconst REACTION_DELAY = 100;\nclass RemoteVideoTrack extends RemoteTrack {\n  constructor(u, c, l, v, S) {\n    super(u, c, Track.Kind.Video, l, S), this.elementInfos = [], this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver) {\n        this._currentBitrate = 0;\n        return;\n      }\n      const g = yield this.getReceiverStats();\n      g && this.prevStats && this.receiver && (this._currentBitrate = computeBitrate(g, this.prevStats)), this.prevStats = g;\n    }), this.debouncedHandleResize = r(() => {\n      this.updateDimensions();\n    }, REACTION_DELAY), this.adaptiveStreamSettings = v;\n  }\n  get isAdaptiveStream() {\n    return this.adaptiveStreamSettings !== void 0;\n  }\n  /**\n   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start\n   */\n  get mediaStreamTrack() {\n    return this._mediaStreamTrack;\n  }\n  /** @internal */\n  setMuted(u) {\n    super.setMuted(u), this.attachedElements.forEach((c) => {\n      u ? detachTrack(this._mediaStreamTrack, c) : attachToElement(this._mediaStreamTrack, c);\n    });\n  }\n  attach(u) {\n    if (u ? super.attach(u) : u = super.attach(), this.adaptiveStreamSettings && this.elementInfos.find((c) => c.element === u) === void 0) {\n      const c = new HTMLElementInfo(u);\n      this.observeElementInfo(c);\n    }\n    return u;\n  }\n  /**\n   * Observe an ElementInfo for changes when adaptive streaming.\n   * @param elementInfo\n   * @internal\n   */\n  observeElementInfo(u) {\n    this.adaptiveStreamSettings && this.elementInfos.find((c) => c === u) === void 0 ? (u.handleResize = () => {\n      this.debouncedHandleResize();\n    }, u.handleVisibilityChanged = () => {\n      this.updateVisibility();\n    }, this.elementInfos.push(u), u.observe(), this.debouncedHandleResize(), this.updateVisibility()) : this.log.warn(\"visibility resize observer not triggered\", this.logContext);\n  }\n  /**\n   * Stop observing an ElementInfo for changes.\n   * @param elementInfo\n   * @internal\n   */\n  stopObservingElementInfo(u) {\n    if (!this.isAdaptiveStream) {\n      this.log.warn(\"stopObservingElementInfo ignored\", this.logContext);\n      return;\n    }\n    const c = this.elementInfos.filter((l) => l === u);\n    for (const l of c)\n      l.stopObserving();\n    this.elementInfos = this.elementInfos.filter((l) => l !== u), this.updateVisibility(), this.debouncedHandleResize();\n  }\n  detach(u) {\n    let c = [];\n    if (u)\n      return this.stopObservingElement(u), super.detach(u);\n    c = super.detach();\n    for (const l of c)\n      this.stopObservingElement(l);\n    return c;\n  }\n  /** @internal */\n  getDecoderImplementation() {\n    var u;\n    return (u = this.prevStats) === null || u === void 0 ? void 0 : u.decoderImplementation;\n  }\n  getReceiverStats() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.receiver || !this.receiver.getStats)\n        return;\n      const u = yield this.receiver.getStats();\n      let c, l = \"\", v = /* @__PURE__ */ new Map();\n      return u.forEach((S) => {\n        S.type === \"inbound-rtp\" ? (l = S.codecId, c = {\n          type: \"video\",\n          framesDecoded: S.framesDecoded,\n          framesDropped: S.framesDropped,\n          framesReceived: S.framesReceived,\n          packetsReceived: S.packetsReceived,\n          packetsLost: S.packetsLost,\n          frameWidth: S.frameWidth,\n          frameHeight: S.frameHeight,\n          pliCount: S.pliCount,\n          firCount: S.firCount,\n          nackCount: S.nackCount,\n          jitter: S.jitter,\n          timestamp: S.timestamp,\n          bytesReceived: S.bytesReceived,\n          decoderImplementation: S.decoderImplementation\n        }) : S.type === \"codec\" && v.set(S.id, S);\n      }), c && l !== \"\" && v.get(l) && (c.mimeType = v.get(l).mimeType), c;\n    });\n  }\n  stopObservingElement(u) {\n    const c = this.elementInfos.filter((l) => l.element === u);\n    for (const l of c)\n      this.stopObservingElementInfo(l);\n  }\n  handleAppVisibilityChanged() {\n    const u = Object.create(null, {\n      handleAppVisibilityChanged: {\n        get: () => super.handleAppVisibilityChanged\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      yield u.handleAppVisibilityChanged.call(this), this.isAdaptiveStream && this.updateVisibility();\n    });\n  }\n  updateVisibility() {\n    var u, c;\n    const l = this.elementInfos.reduce((E, _) => Math.max(E, _.visibilityChangedAt || 0), 0), v = !((c = (u = this.adaptiveStreamSettings) === null || u === void 0 ? void 0 : u.pauseVideoInBackground) !== null && c !== void 0) || c ? this.isInBackground : !1, S = this.elementInfos.some((E) => E.pictureInPicture), g = this.elementInfos.some((E) => E.visible) && !v || S;\n    if (this.lastVisible !== g) {\n      if (!g && Date.now() - l < REACTION_DELAY) {\n        CriticalTimers.setTimeout(() => {\n          this.updateVisibility();\n        }, REACTION_DELAY);\n        return;\n      }\n      this.lastVisible = g, this.emit(TrackEvent.VisibilityChanged, g, this);\n    }\n  }\n  updateDimensions() {\n    var u, c;\n    let l = 0, v = 0;\n    const S = this.getPixelDensity();\n    for (const g of this.elementInfos) {\n      const E = g.width() * S, _ = g.height() * S;\n      E + _ > l + v && (l = E, v = _);\n    }\n    ((u = this.lastDimensions) === null || u === void 0 ? void 0 : u.width) === l && ((c = this.lastDimensions) === null || c === void 0 ? void 0 : c.height) === v || (this.lastDimensions = {\n      width: l,\n      height: v\n    }, this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this));\n  }\n  getPixelDensity() {\n    var u;\n    const c = (u = this.adaptiveStreamSettings) === null || u === void 0 ? void 0 : u.pixelDensity;\n    return c === \"screen\" ? getDevicePixelRatio() : c || (getDevicePixelRatio() > 2 ? 2 : 1);\n  }\n}\nclass HTMLElementInfo {\n  get visible() {\n    return this.isPiP || this.isIntersecting;\n  }\n  get pictureInPicture() {\n    return this.isPiP;\n  }\n  constructor(u, c) {\n    this.onVisibilityChanged = (l) => {\n      var v;\n      const {\n        target: S,\n        isIntersecting: g\n      } = l;\n      S === this.element && (this.isIntersecting = g, this.visibilityChangedAt = Date.now(), (v = this.handleVisibilityChanged) === null || v === void 0 || v.call(this));\n    }, this.onEnterPiP = () => {\n      var l;\n      this.isPiP = !0, (l = this.handleVisibilityChanged) === null || l === void 0 || l.call(this);\n    }, this.onLeavePiP = () => {\n      var l;\n      this.isPiP = !1, (l = this.handleVisibilityChanged) === null || l === void 0 || l.call(this);\n    }, this.element = u, this.isIntersecting = c ?? isElementInViewport(u), this.isPiP = isWeb() && document.pictureInPictureElement === u, this.visibilityChangedAt = 0;\n  }\n  width() {\n    return this.element.clientWidth;\n  }\n  height() {\n    return this.element.clientHeight;\n  }\n  observe() {\n    this.isIntersecting = isElementInViewport(this.element), this.isPiP = document.pictureInPictureElement === this.element, this.element.handleResize = () => {\n      var u;\n      (u = this.handleResize) === null || u === void 0 || u.call(this);\n    }, this.element.handleVisibilityChanged = this.onVisibilityChanged, getIntersectionObserver().observe(this.element), getResizeObserver().observe(this.element), this.element.addEventListener(\"enterpictureinpicture\", this.onEnterPiP), this.element.addEventListener(\"leavepictureinpicture\", this.onLeavePiP);\n  }\n  stopObserving() {\n    var u, c;\n    (u = getIntersectionObserver()) === null || u === void 0 || u.unobserve(this.element), (c = getResizeObserver()) === null || c === void 0 || c.unobserve(this.element), this.element.removeEventListener(\"enterpictureinpicture\", this.onEnterPiP), this.element.removeEventListener(\"leavepictureinpicture\", this.onLeavePiP);\n  }\n}\nfunction isElementInViewport(a) {\n  let u = a.offsetTop, c = a.offsetLeft;\n  const l = a.offsetWidth, v = a.offsetHeight, {\n    hidden: S\n  } = a, {\n    opacity: g,\n    display: E\n  } = getComputedStyle(a);\n  for (; a.offsetParent; )\n    a = a.offsetParent, u += a.offsetTop, c += a.offsetLeft;\n  return u < window.pageYOffset + window.innerHeight && c < window.pageXOffset + window.innerWidth && u + v > window.pageYOffset && c + l > window.pageXOffset && !S && (g !== \"\" ? parseFloat(g) > 0 : !0) && E !== \"none\";\n}\nclass TrackPublication extends eventsExports.EventEmitter {\n  constructor(u, c, l, v) {\n    var S;\n    super(), this.metadataMuted = !1, this.encryption = Encryption_Type.NONE, this.log = livekitLogger, this.handleMuted = () => {\n      this.emit(TrackEvent.Muted);\n    }, this.handleUnmuted = () => {\n      this.emit(TrackEvent.Unmuted);\n    }, this.log = getLogger((S = v == null ? void 0 : v.loggerName) !== null && S !== void 0 ? S : LoggerNames.Publication), this.loggerContextCb = this.loggerContextCb, this.setMaxListeners(100), this.kind = u, this.trackSid = c, this.trackName = l, this.source = Track.Source.Unknown;\n  }\n  /** @internal */\n  setTrack(u) {\n    this.track && (this.track.off(TrackEvent.Muted, this.handleMuted), this.track.off(TrackEvent.Unmuted, this.handleUnmuted)), this.track = u, u && (u.on(TrackEvent.Muted, this.handleMuted), u.on(TrackEvent.Unmuted, this.handleUnmuted));\n  }\n  get logContext() {\n    var u;\n    return Object.assign(Object.assign({}, (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)), getLogContextFromTrack(this));\n  }\n  get isMuted() {\n    return this.metadataMuted;\n  }\n  get isEnabled() {\n    return !0;\n  }\n  get isSubscribed() {\n    return this.track !== void 0;\n  }\n  get isEncrypted() {\n    return this.encryption !== Encryption_Type.NONE;\n  }\n  /**\n   * an [AudioTrack] if this publication holds an audio track\n   */\n  get audioTrack() {\n    if (this.track instanceof LocalAudioTrack || this.track instanceof RemoteAudioTrack)\n      return this.track;\n  }\n  /**\n   * an [VideoTrack] if this publication holds a video track\n   */\n  get videoTrack() {\n    if (this.track instanceof LocalVideoTrack || this.track instanceof RemoteVideoTrack)\n      return this.track;\n  }\n  /** @internal */\n  updateInfo(u) {\n    this.trackSid = u.sid, this.trackName = u.name, this.source = Track.sourceFromProto(u.source), this.mimeType = u.mimeType, this.kind === Track.Kind.Video && u.width > 0 && (this.dimensions = {\n      width: u.width,\n      height: u.height\n    }, this.simulcasted = u.simulcast), this.encryption = u.encryption, this.trackInfo = u, this.log.debug(\"update publication info\", Object.assign(Object.assign({}, this.logContext), {\n      info: u\n    }));\n  }\n}\n(function(a) {\n  (function(u) {\n    u.Desired = \"desired\", u.Subscribed = \"subscribed\", u.Unsubscribed = \"unsubscribed\";\n  })(a.SubscriptionStatus || (a.SubscriptionStatus = {})), function(u) {\n    u.Allowed = \"allowed\", u.NotAllowed = \"not_allowed\";\n  }(a.PermissionStatus || (a.PermissionStatus = {}));\n})(TrackPublication || (TrackPublication = {}));\nclass LocalTrackPublication extends TrackPublication {\n  get isUpstreamPaused() {\n    var u;\n    return (u = this.track) === null || u === void 0 ? void 0 : u.isUpstreamPaused;\n  }\n  constructor(u, c, l, v) {\n    super(u, c.sid, c.name, v), this.track = void 0, this.handleTrackEnded = () => {\n      this.emit(TrackEvent.Ended);\n    }, this.updateInfo(c), this.setTrack(l);\n  }\n  setTrack(u) {\n    this.track && this.track.off(TrackEvent.Ended, this.handleTrackEnded), super.setTrack(u), u && u.on(TrackEvent.Ended, this.handleTrackEnded);\n  }\n  get isMuted() {\n    return this.track ? this.track.isMuted : super.isMuted;\n  }\n  get audioTrack() {\n    return super.audioTrack;\n  }\n  get videoTrack() {\n    return super.videoTrack;\n  }\n  /**\n   * Mute the track associated with this publication\n   */\n  mute() {\n    var u;\n    return __awaiter(this, void 0, void 0, function* () {\n      return (u = this.track) === null || u === void 0 ? void 0 : u.mute();\n    });\n  }\n  /**\n   * Unmute track associated with this publication\n   */\n  unmute() {\n    var u;\n    return __awaiter(this, void 0, void 0, function* () {\n      return (u = this.track) === null || u === void 0 ? void 0 : u.unmute();\n    });\n  }\n  /**\n   * Pauses the media stream track associated with this publication from being sent to the server\n   * and signals \"muted\" event to other participants\n   * Useful if you want to pause the stream without pausing the local media stream track\n   */\n  pauseUpstream() {\n    var u;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield (u = this.track) === null || u === void 0 ? void 0 : u.pauseUpstream();\n    });\n  }\n  /**\n   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]\n   * and signals \"unmuted\" event to other participants (unless the track is explicitly muted)\n   */\n  resumeUpstream() {\n    var u;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield (u = this.track) === null || u === void 0 ? void 0 : u.resumeUpstream();\n    });\n  }\n}\nvar ConnectionQuality;\n(function(a) {\n  a.Excellent = \"excellent\", a.Good = \"good\", a.Poor = \"poor\", a.Lost = \"lost\", a.Unknown = \"unknown\";\n})(ConnectionQuality || (ConnectionQuality = {}));\nfunction qualityFromProto(a) {\n  switch (a) {\n    case ConnectionQuality$1.EXCELLENT:\n      return ConnectionQuality.Excellent;\n    case ConnectionQuality$1.GOOD:\n      return ConnectionQuality.Good;\n    case ConnectionQuality$1.POOR:\n      return ConnectionQuality.Poor;\n    case ConnectionQuality$1.LOST:\n      return ConnectionQuality.Lost;\n    default:\n      return ConnectionQuality.Unknown;\n  }\n}\nclass Participant extends eventsExports.EventEmitter {\n  get logContext() {\n    var u, c;\n    return Object.assign(Object.assign({}, (c = (u = this.loggerOptions) === null || u === void 0 ? void 0 : u.loggerContextCb) === null || c === void 0 ? void 0 : c.call(u)), {\n      participantSid: this.sid,\n      participantId: this.identity\n    });\n  }\n  get isEncrypted() {\n    return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every((u) => u.isEncrypted);\n  }\n  get isAgent() {\n    var u, c;\n    return (c = (u = this.permissions) === null || u === void 0 ? void 0 : u.agent) !== null && c !== void 0 ? c : !1;\n  }\n  /** @internal */\n  constructor(u, c, l, v, S) {\n    var g;\n    super(), this.audioLevel = 0, this.isSpeaking = !1, this._connectionQuality = ConnectionQuality.Unknown, this.log = livekitLogger, this.log = getLogger((g = S == null ? void 0 : S.loggerName) !== null && g !== void 0 ? g : LoggerNames.Participant), this.loggerOptions = S, this.setMaxListeners(100), this.sid = u, this.identity = c, this.name = l, this.metadata = v, this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.trackPublications = /* @__PURE__ */ new Map();\n  }\n  getTrackPublications() {\n    return Array.from(this.trackPublications.values());\n  }\n  /**\n   * Finds the first track that matches the source filter, for example, getting\n   * the user's camera track with getTrackBySource(Track.Source.Camera).\n   */\n  getTrackPublication(u) {\n    for (const [, c] of this.trackPublications)\n      if (c.source === u)\n        return c;\n  }\n  /**\n   * Finds the first track that matches the track's name.\n   */\n  getTrackPublicationByName(u) {\n    for (const [, c] of this.trackPublications)\n      if (c.trackName === u)\n        return c;\n  }\n  get connectionQuality() {\n    return this._connectionQuality;\n  }\n  get isCameraEnabled() {\n    var u;\n    const c = this.getTrackPublication(Track.Source.Camera);\n    return !(!((u = c == null ? void 0 : c.isMuted) !== null && u !== void 0) || u);\n  }\n  get isMicrophoneEnabled() {\n    var u;\n    const c = this.getTrackPublication(Track.Source.Microphone);\n    return !(!((u = c == null ? void 0 : c.isMuted) !== null && u !== void 0) || u);\n  }\n  get isScreenShareEnabled() {\n    return !!this.getTrackPublication(Track.Source.ScreenShare);\n  }\n  get isLocal() {\n    return !1;\n  }\n  /** when participant joined the room */\n  get joinedAt() {\n    return this.participantInfo ? new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1e3) : /* @__PURE__ */ new Date();\n  }\n  /** @internal */\n  updateInfo(u) {\n    return this.participantInfo && this.participantInfo.sid === u.sid && this.participantInfo.version > u.version ? !1 : (this.identity = u.identity, this.sid = u.sid, this._setName(u.name), this._setMetadata(u.metadata), u.permission && this.setPermissions(u.permission), this.participantInfo = u, this.log.trace(\"update participant info\", Object.assign(Object.assign({}, this.logContext), {\n      info: u\n    })), !0);\n  }\n  /**\n   * Updates metadata from server\n   **/\n  _setMetadata(u) {\n    const c = this.metadata !== u, l = this.metadata;\n    this.metadata = u, c && this.emit(ParticipantEvent.ParticipantMetadataChanged, l);\n  }\n  _setName(u) {\n    const c = this.name !== u;\n    this.name = u, c && this.emit(ParticipantEvent.ParticipantNameChanged, u);\n  }\n  /** @internal */\n  setPermissions(u) {\n    var c, l, v, S, g;\n    const E = this.permissions, _ = u.canPublish !== ((c = this.permissions) === null || c === void 0 ? void 0 : c.canPublish) || u.canSubscribe !== ((l = this.permissions) === null || l === void 0 ? void 0 : l.canSubscribe) || u.canPublishData !== ((v = this.permissions) === null || v === void 0 ? void 0 : v.canPublishData) || u.hidden !== ((S = this.permissions) === null || S === void 0 ? void 0 : S.hidden) || u.recorder !== ((g = this.permissions) === null || g === void 0 ? void 0 : g.recorder) || u.canPublishSources.length !== this.permissions.canPublishSources.length || u.canPublishSources.some((k, L) => {\n      var M;\n      return k !== ((M = this.permissions) === null || M === void 0 ? void 0 : M.canPublishSources[L]);\n    });\n    return this.permissions = u, _ && this.emit(ParticipantEvent.ParticipantPermissionsChanged, E), _;\n  }\n  /** @internal */\n  setIsSpeaking(u) {\n    u !== this.isSpeaking && (this.isSpeaking = u, u && (this.lastSpokeAt = /* @__PURE__ */ new Date()), this.emit(ParticipantEvent.IsSpeakingChanged, u));\n  }\n  /** @internal */\n  setConnectionQuality(u) {\n    const c = this._connectionQuality;\n    this._connectionQuality = qualityFromProto(u), c !== this._connectionQuality && this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);\n  }\n  /**\n   * @internal\n   */\n  setAudioContext(u) {\n    this.audioContext = u, this.audioTrackPublications.forEach((c) => (c.track instanceof RemoteAudioTrack || c.track instanceof LocalAudioTrack) && c.track.setAudioContext(u));\n  }\n  addTrackPublication(u) {\n    u.on(TrackEvent.Muted, () => {\n      this.emit(ParticipantEvent.TrackMuted, u);\n    }), u.on(TrackEvent.Unmuted, () => {\n      this.emit(ParticipantEvent.TrackUnmuted, u);\n    });\n    const c = u;\n    switch (c.track && (c.track.sid = u.trackSid), this.trackPublications.set(u.trackSid, u), u.kind) {\n      case Track.Kind.Audio:\n        this.audioTrackPublications.set(u.trackSid, u);\n        break;\n      case Track.Kind.Video:\n        this.videoTrackPublications.set(u.trackSid, u);\n        break;\n    }\n  }\n}\nfunction trackPermissionToProto(a) {\n  var u, c, l;\n  if (!a.participantSid && !a.participantIdentity)\n    throw new Error(\"Invalid track permission, must provide at least one of participantIdentity and participantSid\");\n  return new TrackPermission({\n    participantIdentity: (u = a.participantIdentity) !== null && u !== void 0 ? u : \"\",\n    participantSid: (c = a.participantSid) !== null && c !== void 0 ? c : \"\",\n    allTracks: (l = a.allowAll) !== null && l !== void 0 ? l : !1,\n    trackSids: a.allowedTrackSids || []\n  });\n}\nclass LocalParticipant extends Participant {\n  /** @internal */\n  constructor(u, c, l, v) {\n    super(u, c, void 0, void 0, {\n      loggerName: v.loggerName,\n      loggerContextCb: () => this.engine.logContext\n    }), this.pendingPublishing = /* @__PURE__ */ new Set(), this.pendingPublishPromises = /* @__PURE__ */ new Map(), this.participantTrackPermissions = [], this.allParticipantsAllowedToSubscribe = !0, this.encryptionType = Encryption_Type.NONE, this.handleReconnecting = () => {\n      this.reconnectFuture || (this.reconnectFuture = new Future());\n    }, this.handleReconnected = () => {\n      var S, g;\n      (g = (S = this.reconnectFuture) === null || S === void 0 ? void 0 : S.resolve) === null || g === void 0 || g.call(S), this.reconnectFuture = void 0, this.updateTrackSubscriptionPermissions();\n    }, this.handleDisconnected = () => {\n      var S, g;\n      this.reconnectFuture && (this.reconnectFuture.promise.catch((E) => this.log.warn(E.message, this.logContext)), (g = (S = this.reconnectFuture) === null || S === void 0 ? void 0 : S.reject) === null || g === void 0 || g.call(S, \"Got disconnected during reconnection attempt\"), this.reconnectFuture = void 0);\n    }, this.updateTrackSubscriptionPermissions = () => {\n      this.log.debug(\"updating track subscription permissions\", Object.assign(Object.assign({}, this.logContext), {\n        allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,\n        participantTrackPermissions: this.participantTrackPermissions\n      })), this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((S) => trackPermissionToProto(S)));\n    }, this.onTrackUnmuted = (S) => {\n      this.onTrackMuted(S, S.isUpstreamPaused);\n    }, this.onTrackMuted = (S, g) => {\n      if (g === void 0 && (g = !0), !S.sid) {\n        this.log.error(\"could not update mute status for unpublished track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(S)));\n        return;\n      }\n      this.engine.updateMuteStatus(S.sid, g);\n    }, this.onTrackUpstreamPaused = (S) => {\n      this.log.debug(\"upstream paused\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(S))), this.onTrackMuted(S, !0);\n    }, this.onTrackUpstreamResumed = (S) => {\n      this.log.debug(\"upstream resumed\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(S))), this.onTrackMuted(S, S.isMuted);\n    }, this.handleSubscribedQualityUpdate = (S) => __awaiter(this, void 0, void 0, function* () {\n      var g, E, _, k, L, M;\n      if (!(!((L = this.roomOptions) === null || L === void 0) && L.dynacast))\n        return;\n      const $ = this.videoTrackPublications.get(S.trackSid);\n      if (!$) {\n        this.log.warn(\"received subscribed quality update for unknown track\", Object.assign(Object.assign({}, this.logContext), {\n          trackSid: S.trackSid\n        }));\n        return;\n      }\n      if (S.subscribedCodecs.length > 0) {\n        if (!$.videoTrack)\n          return;\n        const G = yield $.videoTrack.setPublishingCodecs(S.subscribedCodecs);\n        try {\n          for (var J = !0, V = __asyncValues(G), q; q = yield V.next(), g = q.done, !g; J = !0) {\n            k = q.value, J = !1;\n            const H = k;\n            isBackupCodec(H) && (this.log.debug(\"publish \".concat(H, \" for \").concat($.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack($))), yield this.publishAdditionalCodecForTrack($.videoTrack, H, $.options));\n          }\n        } catch (H) {\n          E = {\n            error: H\n          };\n        } finally {\n          try {\n            !J && !g && (_ = V.return) && (yield _.call(V));\n          } finally {\n            if (E)\n              throw E.error;\n          }\n        }\n      } else\n        S.subscribedQualities.length > 0 && (yield (M = $.videoTrack) === null || M === void 0 ? void 0 : M.setPublishingLayers(S.subscribedQualities));\n    }), this.handleLocalTrackUnpublished = (S) => {\n      const g = this.trackPublications.get(S.trackSid);\n      if (!g) {\n        this.log.warn(\"received unpublished event for unknown track\", Object.assign(Object.assign({}, this.logContext), {\n          trackSid: S.trackSid\n        }));\n        return;\n      }\n      this.unpublishTrack(g.track);\n    }, this.handleTrackEnded = (S) => __awaiter(this, void 0, void 0, function* () {\n      if (S.source === Track.Source.ScreenShare || S.source === Track.Source.ScreenShareAudio)\n        this.log.debug(\"unpublishing local track due to TrackEnded\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(S))), this.unpublishTrack(S);\n      else if (S.isUserProvided)\n        yield S.mute();\n      else if (S instanceof LocalAudioTrack || S instanceof LocalVideoTrack)\n        try {\n          if (isWeb())\n            try {\n              const g = yield navigator == null ? void 0 : navigator.permissions.query({\n                // the permission query for camera and microphone currently not supported in Safari and Firefox\n                // @ts-ignore\n                name: S.source === Track.Source.Camera ? \"camera\" : \"microphone\"\n              });\n              if (g && g.state === \"denied\")\n                throw this.log.warn(\"user has revoked access to \".concat(S.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(S))), g.onchange = () => {\n                  g.state !== \"denied\" && (S.isMuted || S.restartTrack(), g.onchange = null);\n                }, new Error(\"GetUserMedia Permission denied\");\n            } catch {\n            }\n          S.isMuted || (this.log.debug(\"track ended, attempting to use a different device\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(S))), yield S.restartTrack());\n        } catch {\n          this.log.warn(\"could not restart track, muting instead\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(S))), yield S.mute();\n        }\n    }), this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.trackPublications = /* @__PURE__ */ new Map(), this.engine = l, this.roomOptions = v, this.setupEngine(l), this.activeDeviceMap = /* @__PURE__ */ new Map();\n  }\n  get lastCameraError() {\n    return this.cameraError;\n  }\n  get lastMicrophoneError() {\n    return this.microphoneError;\n  }\n  get isE2EEEnabled() {\n    return this.encryptionType !== Encryption_Type.NONE;\n  }\n  getTrackPublication(u) {\n    const c = super.getTrackPublication(u);\n    if (c)\n      return c;\n  }\n  getTrackPublicationByName(u) {\n    const c = super.getTrackPublicationByName(u);\n    if (c)\n      return c;\n  }\n  /**\n   * @internal\n   */\n  setupEngine(u) {\n    this.engine = u, this.engine.on(EngineEvent.RemoteMute, (c, l) => {\n      const v = this.trackPublications.get(c);\n      !v || !v.track || (l ? v.mute() : v.unmute());\n    }), this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected);\n  }\n  /**\n   * Sets and updates the metadata of the local participant.\n   * The change does not take immediate effect.\n   * If successful, a `ParticipantEvent.MetadataChanged` event will be emitted on the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param metadata\n   */\n  setMetadata(u) {\n    var c;\n    this.engine.client.sendUpdateLocalMetadata(u, (c = this.name) !== null && c !== void 0 ? c : \"\");\n  }\n  /**\n   * Sets and updates the name of the local participant.\n   * The change does not take immediate effect.\n   * If successful, a `ParticipantEvent.ParticipantNameChanged` event will be emitted on the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param metadata\n   */\n  setName(u) {\n    var c;\n    this.engine.client.sendUpdateLocalMetadata((c = this.metadata) !== null && c !== void 0 ? c : \"\", u);\n  }\n  /**\n   * Enable or disable a participant's camera track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */\n  setCameraEnabled(u, c, l) {\n    return this.setTrackEnabled(Track.Source.Camera, u, c, l);\n  }\n  /**\n   * Enable or disable a participant's microphone track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */\n  setMicrophoneEnabled(u, c, l) {\n    return this.setTrackEnabled(Track.Source.Microphone, u, c, l);\n  }\n  /**\n   * Start or stop sharing a participant's screen\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */\n  setScreenShareEnabled(u, c, l) {\n    return this.setTrackEnabled(Track.Source.ScreenShare, u, c, l);\n  }\n  /** @internal */\n  setPermissions(u) {\n    const c = this.permissions, l = super.setPermissions(u);\n    return l && c && this.emit(ParticipantEvent.ParticipantPermissionsChanged, c), l;\n  }\n  /** @internal */\n  setE2EEEnabled(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.encryptionType = u ? Encryption_Type.GCM : Encryption_Type.NONE, yield this.republishAllTracks(void 0, !1);\n    });\n  }\n  setTrackEnabled(u, c, l, v) {\n    var S, g;\n    return __awaiter(this, void 0, void 0, function* () {\n      this.log.debug(\"setTrackEnabled\", Object.assign(Object.assign({}, this.logContext), {\n        source: u,\n        enabled: c\n      }));\n      let E = this.getTrackPublication(u);\n      if (c)\n        if (E)\n          yield E.unmute();\n        else {\n          let _;\n          if (this.pendingPublishing.has(u)) {\n            this.log.info(\"skipping duplicate published source\", Object.assign(Object.assign({}, this.logContext), {\n              source: u\n            }));\n            return;\n          }\n          this.pendingPublishing.add(u);\n          try {\n            switch (u) {\n              case Track.Source.Camera:\n                _ = yield this.createTracks({\n                  video: (S = l) !== null && S !== void 0 ? S : !0\n                });\n                break;\n              case Track.Source.Microphone:\n                _ = yield this.createTracks({\n                  audio: (g = l) !== null && g !== void 0 ? g : !0\n                });\n                break;\n              case Track.Source.ScreenShare:\n                _ = yield this.createScreenTracks(Object.assign({}, l));\n                break;\n              default:\n                throw new TrackInvalidError(u);\n            }\n            const k = [];\n            for (const M of _)\n              this.log.info(\"publishing track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(M))), k.push(this.publishTrack(M, v));\n            [E] = yield Promise.all(k);\n          } catch (k) {\n            throw _ == null || _.forEach((L) => {\n              L.stop();\n            }), k instanceof Error && !(k instanceof TrackInvalidError) && this.emit(ParticipantEvent.MediaDevicesError, k), k;\n          } finally {\n            this.pendingPublishing.delete(u);\n          }\n        }\n      else if (E && E.track)\n        if (u === Track.Source.ScreenShare) {\n          E = yield this.unpublishTrack(E.track);\n          const _ = this.getTrackPublication(Track.Source.ScreenShareAudio);\n          _ && _.track && this.unpublishTrack(_.track);\n        } else\n          yield E.mute();\n      return E;\n    });\n  }\n  /**\n   * Publish both camera and microphone at the same time. This is useful for\n   * displaying a single Permission Dialog box to the end user.\n   */\n  enableCameraAndMicrophone() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!(this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone))) {\n        this.pendingPublishing.add(Track.Source.Camera), this.pendingPublishing.add(Track.Source.Microphone);\n        try {\n          const u = yield this.createTracks({\n            audio: !0,\n            video: !0\n          });\n          yield Promise.all(u.map((c) => this.publishTrack(c)));\n        } finally {\n          this.pendingPublishing.delete(Track.Source.Camera), this.pendingPublishing.delete(Track.Source.Microphone);\n        }\n      }\n    });\n  }\n  /**\n   * Create local camera and/or microphone tracks\n   * @param options\n   * @returns\n   */\n  createTracks(u) {\n    var c, l;\n    return __awaiter(this, void 0, void 0, function* () {\n      const v = mergeDefaultOptions(u, (c = this.roomOptions) === null || c === void 0 ? void 0 : c.audioCaptureDefaults, (l = this.roomOptions) === null || l === void 0 ? void 0 : l.videoCaptureDefaults), S = constraintsForOptions(v);\n      let g;\n      try {\n        g = yield navigator.mediaDevices.getUserMedia(S);\n      } catch (E) {\n        throw E instanceof Error && (S.audio && (this.microphoneError = E), S.video && (this.cameraError = E)), E;\n      }\n      return S.audio && (this.microphoneError = void 0, this.emit(ParticipantEvent.AudioStreamAcquired)), S.video && (this.cameraError = void 0), g.getTracks().map((E) => {\n        const _ = E.kind === \"audio\";\n        _ ? u.audio : u.video;\n        let k;\n        const L = _ ? S.audio : S.video;\n        typeof L != \"boolean\" && (k = L);\n        const M = mediaTrackToLocalTrack(E, k, {\n          loggerName: this.roomOptions.loggerName,\n          loggerContextCb: () => this.logContext\n        });\n        return M.kind === Track.Kind.Video ? M.source = Track.Source.Camera : M.kind === Track.Kind.Audio && (M.source = Track.Source.Microphone), M.mediaStream = g, M;\n      });\n    });\n  }\n  /**\n   * Creates a screen capture tracks with getDisplayMedia().\n   * A LocalVideoTrack is always created and returned.\n   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n   */\n  createScreenTracks(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (u === void 0 && (u = {}), navigator.mediaDevices.getDisplayMedia === void 0)\n        throw new DeviceUnsupportedError(\"getDisplayMedia not supported\");\n      u.resolution === void 0 && !isSafari17() && (u.resolution = ScreenSharePresets.h1080fps30.resolution);\n      const c = screenCaptureToDisplayMediaStreamOptions(u), l = yield navigator.mediaDevices.getDisplayMedia(c), v = l.getVideoTracks();\n      if (v.length === 0)\n        throw new TrackInvalidError(\"no video track found\");\n      const S = new LocalVideoTrack(v[0], void 0, !1, {\n        loggerName: this.roomOptions.loggerName,\n        loggerContextCb: () => this.logContext\n      });\n      S.source = Track.Source.ScreenShare, u.contentHint && (S.mediaStreamTrack.contentHint = u.contentHint);\n      const g = [S];\n      if (l.getAudioTracks().length > 0) {\n        this.emit(ParticipantEvent.AudioStreamAcquired);\n        const E = new LocalAudioTrack(l.getAudioTracks()[0], void 0, !1, this.audioContext, {\n          loggerName: this.roomOptions.loggerName,\n          loggerContextCb: () => this.logContext\n        });\n        E.source = Track.Source.ScreenShareAudio, g.push(E);\n      }\n      return g;\n    });\n  }\n  /**\n   * Publish a new track to the room\n   * @param track\n   * @param options\n   */\n  publishTrack(u, c) {\n    var l, v, S, g;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield (l = this.reconnectFuture) === null || l === void 0 ? void 0 : l.promise, u instanceof LocalTrack && this.pendingPublishPromises.has(u) && (yield this.pendingPublishPromises.get(u));\n      let E;\n      if (u instanceof MediaStreamTrack)\n        E = u.getConstraints();\n      else {\n        E = u.constraints;\n        let J;\n        switch (u.source) {\n          case Track.Source.Microphone:\n            J = \"audioinput\";\n            break;\n          case Track.Source.Camera:\n            J = \"videoinput\";\n        }\n        J && this.activeDeviceMap.has(J) && (E = Object.assign(Object.assign({}, E), {\n          deviceId: this.activeDeviceMap.get(J)\n        }));\n      }\n      if (u instanceof MediaStreamTrack)\n        switch (u.kind) {\n          case \"audio\":\n            u = new LocalAudioTrack(u, E, !0, this.audioContext, {\n              loggerName: this.roomOptions.loggerName,\n              loggerContextCb: () => this.logContext\n            });\n            break;\n          case \"video\":\n            u = new LocalVideoTrack(u, E, !0, {\n              loggerName: this.roomOptions.loggerName,\n              loggerContextCb: () => this.logContext\n            });\n            break;\n          default:\n            throw new TrackInvalidError(\"unsupported MediaStreamTrack kind \".concat(u.kind));\n        }\n      else\n        u.updateLoggerOptions({\n          loggerName: this.roomOptions.loggerName,\n          loggerContextCb: () => this.logContext\n        });\n      u instanceof LocalAudioTrack && u.setAudioContext(this.audioContext);\n      let _;\n      if (this.trackPublications.forEach((J) => {\n        J.track && J.track === u && (_ = J);\n      }), _)\n        return this.log.warn(\"track has already been published, skipping\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(_))), _;\n      const k = \"channelCount\" in u.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount\n      u.mediaStreamTrack.getSettings().channelCount === 2 || u.mediaStreamTrack.getConstraints().channelCount === 2, L = (v = c == null ? void 0 : c.forceStereo) !== null && v !== void 0 ? v : k;\n      L && (c || (c = {}), c.dtx === void 0 && this.log.info(\"Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), c.red === void 0 && this.log.info(\"Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.\"), (S = c.dtx) !== null && S !== void 0 || (c.dtx = !1), (g = c.red) !== null && g !== void 0 || (c.red = !1));\n      const M = Object.assign(Object.assign({}, this.roomOptions.publishDefaults), c);\n      isSafari() && this.roomOptions.e2ee && (this.log.info(\"End-to-end encryption is set up, simulcast publishing will be disabled on Safari\", Object.assign({}, this.logContext)), M.simulcast = !1), M.source && (u.source = M.source);\n      const $ = this.publish(u, M, L);\n      this.pendingPublishPromises.set(u, $);\n      try {\n        return yield $;\n      } catch (J) {\n        throw J;\n      } finally {\n        this.pendingPublishPromises.delete(u);\n      }\n    });\n  }\n  publish(u, c, l) {\n    var v, S, g, E, _, k, L, M, $, J, V, q;\n    return __awaiter(this, void 0, void 0, function* () {\n      Array.from(this.trackPublications.values()).find((oe) => u instanceof LocalTrack && oe.source === u.source) && u.source !== Track.Source.Unknown && this.log.info(\"publishing a second track with the same source: \".concat(u.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), c.stopMicTrackOnMute && u instanceof LocalAudioTrack && (u.stopOnMute = !0), u.source === Track.Source.ScreenShare && isFireFox() && (c.simulcast = !1), c.videoCodec === \"av1\" && !supportsAV1() && (c.videoCodec = void 0), c.videoCodec === \"vp9\" && !supportsVP9() && (c.videoCodec = void 0), c.videoCodec === void 0 && (c.videoCodec = defaultVideoCodec);\n      const H = c.videoCodec;\n      u.on(TrackEvent.Muted, this.onTrackMuted), u.on(TrackEvent.Unmuted, this.onTrackUnmuted), u.on(TrackEvent.Ended, this.handleTrackEnded), u.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused), u.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n      const B = new AddTrackRequest({\n        // get local track id for use during publishing\n        cid: u.mediaStreamTrack.id,\n        name: c.name,\n        type: Track.kindToProto(u.kind),\n        muted: u.isMuted,\n        source: Track.sourceToProto(u.source),\n        disableDtx: !(!((v = c.dtx) !== null && v !== void 0) || v),\n        encryption: this.encryptionType,\n        stereo: l,\n        disableRed: this.isE2EEEnabled || !(!((S = c.red) !== null && S !== void 0) || S),\n        stream: c == null ? void 0 : c.stream\n      });\n      let Y;\n      if (u.kind === Track.Kind.Video) {\n        let oe = {\n          width: 0,\n          height: 0\n        };\n        try {\n          oe = yield u.waitForDimensions();\n        } catch {\n          const A = (E = (g = this.roomOptions.videoCaptureDefaults) === null || g === void 0 ? void 0 : g.resolution) !== null && E !== void 0 ? E : VideoPresets.h720.resolution;\n          oe = {\n            width: A.width,\n            height: A.height\n          }, this.log.error(\"could not determine track dimensions, using defaults\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)), {\n            dims: oe\n          }));\n        }\n        B.width = oe.width, B.height = oe.height, u instanceof LocalVideoTrack && (isSVCCodec(H) && (u.source === Track.Source.ScreenShare && H === \"vp9\" && (c.scalabilityMode = \"L1T3\"), c.scalabilityMode = (_ = c.scalabilityMode) !== null && _ !== void 0 ? _ : \"L3T3_KEY\"), B.simulcastCodecs = [new SimulcastCodec({\n          codec: H,\n          cid: u.mediaStreamTrack.id\n        })], c.backupCodec === !0 && (c.backupCodec = {\n          codec: defaultVideoCodec\n        }), c.backupCodec && H !== c.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs\n        B.encryption === Encryption_Type.NONE && (this.roomOptions.dynacast || (this.roomOptions.dynacast = !0), B.simulcastCodecs.push(new SimulcastCodec({\n          codec: c.backupCodec.codec,\n          cid: \"\"\n        })))), Y = computeVideoEncodings(u.source === Track.Source.ScreenShare, B.width, B.height, c), B.layers = videoLayersFromEncodings(B.width, B.height, Y, isSVCCodec(c.videoCodec));\n      } else\n        u.kind === Track.Kind.Audio && (Y = [{\n          maxBitrate: (k = c.audioPreset) === null || k === void 0 ? void 0 : k.maxBitrate,\n          priority: (M = (L = c.audioPreset) === null || L === void 0 ? void 0 : L.priority) !== null && M !== void 0 ? M : \"high\",\n          networkPriority: (J = ($ = c.audioPreset) === null || $ === void 0 ? void 0 : $.priority) !== null && J !== void 0 ? J : \"high\"\n        }]);\n      if (!this.engine || this.engine.isClosed)\n        throw new UnexpectedConnectionState(\"cannot publish track when not connected\");\n      const ne = yield this.engine.addTrack(B);\n      let Z;\n      if (ne.codecs.forEach((oe) => {\n        Z === void 0 && (Z = oe.mimeType);\n      }), Z && u.kind === Track.Kind.Video) {\n        const oe = mimeTypeToVideoCodecString(Z);\n        oe !== H && (this.log.debug(\"falling back to server selected codec\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)), {\n          codec: oe\n        })), c.videoCodec = oe, Y = computeVideoEncodings(u.source === Track.Source.ScreenShare, B.width, B.height, c));\n      }\n      const re = new LocalTrackPublication(u.kind, ne, u, {\n        loggerName: this.roomOptions.loggerName,\n        loggerContextCb: () => this.logContext\n      });\n      if (re.options = c, u.sid = ne.sid, !this.engine.pcManager)\n        throw new UnexpectedConnectionState(\"pcManager is not ready\");\n      if (this.log.debug(\"publishing \".concat(u.kind, \" with encodings\"), Object.assign(Object.assign({}, this.logContext), {\n        encodings: Y,\n        trackInfo: ne\n      })), u.sender = yield this.engine.createSender(u, c, Y), Y)\n        if (isFireFox() && u.kind === Track.Kind.Audio) {\n          let oe;\n          for (const de of this.engine.pcManager.publisher.getTransceivers())\n            if (de.sender === u.sender) {\n              oe = de;\n              break;\n            }\n          oe && this.engine.pcManager.publisher.setTrackCodecBitrate({\n            transceiver: oe,\n            codec: \"opus\",\n            maxbr: !((V = Y[0]) === null || V === void 0) && V.maxBitrate ? Y[0].maxBitrate / 1e3 : 0\n          });\n        } else\n          u.codec && isSVCCodec(u.codec) && (!((q = Y[0]) === null || q === void 0) && q.maxBitrate) && this.engine.pcManager.publisher.setTrackCodecBitrate({\n            cid: B.cid,\n            codec: u.codec,\n            maxbr: Y[0].maxBitrate / 1e3\n          });\n      return yield this.engine.negotiate(), u instanceof LocalVideoTrack ? u.startMonitor(this.engine.client) : u instanceof LocalAudioTrack && u.startMonitor(), this.addTrackPublication(re), this.emit(ParticipantEvent.LocalTrackPublished, re), re;\n    });\n  }\n  get isLocal() {\n    return !0;\n  }\n  /** @internal\n   * publish additional codec to existing track\n   */\n  publishAdditionalCodecForTrack(u, c, l) {\n    var v;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.encryptionType !== Encryption_Type.NONE)\n        return;\n      let S;\n      if (this.trackPublications.forEach((M) => {\n        M.track && M.track === u && (S = M);\n      }), !S)\n        throw new TrackInvalidError(\"track is not published\");\n      if (!(u instanceof LocalVideoTrack))\n        throw new TrackInvalidError(\"track is not a video track\");\n      const g = Object.assign(Object.assign({}, (v = this.roomOptions) === null || v === void 0 ? void 0 : v.publishDefaults), l), E = computeTrackBackupEncodings(u, c, g);\n      if (!E) {\n        this.log.info(\"backup codec has been disabled, ignoring request to add additional codec for track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)));\n        return;\n      }\n      const _ = u.addSimulcastTrack(c, E);\n      if (!_)\n        return;\n      const k = new AddTrackRequest({\n        cid: _.mediaStreamTrack.id,\n        type: Track.kindToProto(u.kind),\n        muted: u.isMuted,\n        source: Track.sourceToProto(u.source),\n        sid: u.sid,\n        simulcastCodecs: [{\n          codec: g.videoCodec,\n          cid: _.mediaStreamTrack.id\n        }]\n      });\n      if (k.layers = videoLayersFromEncodings(k.width, k.height, E), !this.engine || this.engine.isClosed)\n        throw new UnexpectedConnectionState(\"cannot publish track when not connected\");\n      const L = yield this.engine.addTrack(k);\n      yield this.engine.createSimulcastSender(u, _, g, E), yield this.engine.negotiate(), this.log.debug(\"published \".concat(c, \" for track \").concat(u.sid), Object.assign(Object.assign({}, this.logContext), {\n        encodings: E,\n        trackInfo: L\n      }));\n    });\n  }\n  unpublishTrack(u, c) {\n    var l, v;\n    return __awaiter(this, void 0, void 0, function* () {\n      const S = this.getPublicationForTrack(u), g = S ? getLogContextFromTrack(S) : void 0;\n      if (this.log.debug(\"unpublishing track\", Object.assign(Object.assign({}, this.logContext), g)), !S || !S.track) {\n        this.log.warn(\"track was not unpublished because no publication was found\", Object.assign(Object.assign({}, this.logContext), g));\n        return;\n      }\n      u = S.track, u.off(TrackEvent.Muted, this.onTrackMuted), u.off(TrackEvent.Unmuted, this.onTrackUnmuted), u.off(TrackEvent.Ended, this.handleTrackEnded), u.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused), u.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed), c === void 0 && (c = (v = (l = this.roomOptions) === null || l === void 0 ? void 0 : l.stopLocalTrackOnUnpublish) !== null && v !== void 0 ? v : !0), c && u.stop();\n      let E = !1;\n      const _ = u.sender;\n      if (u.sender = void 0, this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && _)\n        try {\n          for (const k of this.engine.pcManager.publisher.getTransceivers())\n            k.sender === _ && (k.direction = \"inactive\", E = !0);\n          if (this.engine.removeTrack(_) && (E = !0), u instanceof LocalVideoTrack) {\n            for (const [, k] of u.simulcastCodecs)\n              k.sender && (this.engine.removeTrack(k.sender) && (E = !0), k.sender = void 0);\n            u.simulcastCodecs.clear();\n          }\n        } catch (k) {\n          this.log.warn(\"failed to unpublish track\", Object.assign(Object.assign(Object.assign({}, this.logContext), g), {\n            error: k\n          }));\n        }\n      switch (this.trackPublications.delete(S.trackSid), S.kind) {\n        case Track.Kind.Audio:\n          this.audioTrackPublications.delete(S.trackSid);\n          break;\n        case Track.Kind.Video:\n          this.videoTrackPublications.delete(S.trackSid);\n          break;\n      }\n      return this.emit(ParticipantEvent.LocalTrackUnpublished, S), S.setTrack(void 0), E && (yield this.engine.negotiate()), S;\n    });\n  }\n  unpublishTracks(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield Promise.all(u.map((l) => this.unpublishTrack(l)))).filter((l) => l instanceof LocalTrackPublication);\n    });\n  }\n  republishAllTracks(u) {\n    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;\n    return __awaiter(this, void 0, void 0, function* () {\n      const l = [];\n      this.trackPublications.forEach((v) => {\n        v.track && (u && (v.options = Object.assign(Object.assign({}, v.options), u)), l.push(v));\n      }), yield Promise.all(l.map((v) => __awaiter(this, void 0, void 0, function* () {\n        const S = v.track;\n        yield this.unpublishTrack(S, !1), c && !S.isMuted && S.source !== Track.Source.ScreenShare && S.source !== Track.Source.ScreenShareAudio && (S instanceof LocalAudioTrack || S instanceof LocalVideoTrack) && !S.isUserProvided && (this.log.debug(\"restarting existing track\", Object.assign(Object.assign({}, this.logContext), {\n          track: v.trackSid\n        })), yield S.restartTrack()), yield this.publishTrack(S, v.options);\n      })));\n    });\n  }\n  /**\n   * Publish a new data payload to the room. Data will be forwarded to each\n   * participant in the room if the destination field in publishOptions is empty\n   *\n   * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode\n   * @param options optionally specify a `reliable`, `topic` and `destination`\n   */\n  publishData(u) {\n    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      const l = c.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY, v = c.destinationIdentities, S = c.topic, g = new DataPacket({\n        kind: l,\n        value: {\n          case: \"user\",\n          value: new UserPacket({\n            participantIdentity: this.identity,\n            payload: u,\n            destinationIdentities: v,\n            topic: S\n          })\n        }\n      });\n      yield this.engine.sendDataPacket(g, l);\n    });\n  }\n  /**\n   * Control who can subscribe to LocalParticipant's published tracks.\n   *\n   * By default, all participants can subscribe. This allows fine-grained control over\n   * who is able to subscribe at a participant and track level.\n   *\n   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and\n   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks\n   * will not grant permissions to any participants and will require a subsequent\n   * permissions update to allow subscription.\n   *\n   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.\n   *  Takes precedence over [[participantTrackPermissions]] if set to true.\n   *  By default this is set to true.\n   * @param participantTrackPermissions Full list of individual permissions per\n   *  participant/track. Any omitted participants will not receive any permissions.\n   */\n  setTrackSubscriptionPermissions(u) {\n    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    this.participantTrackPermissions = c, this.allParticipantsAllowedToSubscribe = u, this.engine.client.isDisconnected || this.updateTrackSubscriptionPermissions();\n  }\n  /** @internal */\n  updateInfo(u) {\n    return u.sid !== this.sid || !super.updateInfo(u) ? !1 : (u.tracks.forEach((c) => {\n      var l, v;\n      const S = this.trackPublications.get(c.sid);\n      if (S) {\n        const g = S.isMuted || ((v = (l = S.track) === null || l === void 0 ? void 0 : l.isUpstreamPaused) !== null && v !== void 0 ? v : !1);\n        g !== c.muted && (this.log.debug(\"updating server mute state after reconcile\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(S)), {\n          mutedOnServer: g\n        })), this.engine.client.sendMuteTrack(c.sid, g));\n      }\n    }), !0);\n  }\n  getPublicationForTrack(u) {\n    let c;\n    return this.trackPublications.forEach((l) => {\n      const v = l.track;\n      v && (u instanceof MediaStreamTrack ? (v instanceof LocalAudioTrack || v instanceof LocalVideoTrack) && v.mediaStreamTrack === u && (c = l) : u === v && (c = l));\n    }), c;\n  }\n}\nclass RemoteTrackPublication extends TrackPublication {\n  constructor(u, c, l, v) {\n    super(u, c.sid, c.name, v), this.track = void 0, this.allowed = !0, this.disabled = !1, this.currentVideoQuality = VideoQuality.HIGH, this.handleEnded = (S) => {\n      this.setTrack(void 0), this.emit(TrackEvent.Ended, S);\n    }, this.handleVisibilityChange = (S) => {\n      this.log.debug(\"adaptivestream video visibility \".concat(this.trackSid, \", visible=\").concat(S), this.logContext), this.disabled = !S, this.emitTrackUpdate();\n    }, this.handleVideoDimensionsChange = (S) => {\n      this.log.debug(\"adaptivestream video dimensions \".concat(S.width, \"x\").concat(S.height), this.logContext), this.videoDimensions = S, this.emitTrackUpdate();\n    }, this.subscribed = l, this.updateInfo(c);\n  }\n  /**\n   * Subscribe or unsubscribe to this remote track\n   * @param subscribed true to subscribe to a track, false to unsubscribe\n   */\n  setSubscribed(u) {\n    const c = this.subscriptionStatus, l = this.permissionStatus;\n    this.subscribed = u, u && (this.allowed = !0);\n    const v = new UpdateSubscription({\n      trackSids: [this.trackSid],\n      subscribe: this.subscribed,\n      participantTracks: [new ParticipantTracks({\n        // sending an empty participant id since TrackPublication doesn't keep it\n        // this is filled in by the participant that receives this message\n        participantSid: \"\",\n        trackSids: [this.trackSid]\n      })]\n    });\n    this.emit(TrackEvent.UpdateSubscription, v), this.emitSubscriptionUpdateIfChanged(c), this.emitPermissionUpdateIfChanged(l);\n  }\n  get subscriptionStatus() {\n    return this.subscribed === !1 ? TrackPublication.SubscriptionStatus.Unsubscribed : super.isSubscribed ? TrackPublication.SubscriptionStatus.Subscribed : TrackPublication.SubscriptionStatus.Desired;\n  }\n  get permissionStatus() {\n    return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;\n  }\n  /**\n   * Returns true if track is subscribed, and ready for playback\n   */\n  get isSubscribed() {\n    return this.subscribed === !1 ? !1 : super.isSubscribed;\n  }\n  // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled\n  get isDesired() {\n    return this.subscribed !== !1;\n  }\n  get isEnabled() {\n    return !this.disabled;\n  }\n  /**\n   * disable server from sending down data for this track. this is useful when\n   * the participant is off screen, you may disable streaming down their video\n   * to reduce bandwidth requirements\n   * @param enabled\n   */\n  setEnabled(u) {\n    !this.isManualOperationAllowed() || this.disabled === !u || (this.disabled = !u, this.emitTrackUpdate());\n  }\n  /**\n   * for tracks that support simulcasting, adjust subscribed quality\n   *\n   * This indicates the highest quality the client can accept. if network\n   * bandwidth does not allow, server will automatically reduce quality to\n   * optimize for uninterrupted video\n   */\n  setVideoQuality(u) {\n    !this.isManualOperationAllowed() || this.currentVideoQuality === u || (this.currentVideoQuality = u, this.videoDimensions = void 0, this.emitTrackUpdate());\n  }\n  setVideoDimensions(u) {\n    var c, l;\n    this.isManualOperationAllowed() && (((c = this.videoDimensions) === null || c === void 0 ? void 0 : c.width) === u.width && ((l = this.videoDimensions) === null || l === void 0 ? void 0 : l.height) === u.height || (this.track instanceof RemoteVideoTrack && (this.videoDimensions = u), this.currentVideoQuality = void 0, this.emitTrackUpdate()));\n  }\n  setVideoFPS(u) {\n    this.isManualOperationAllowed() && this.track instanceof RemoteVideoTrack && this.fps !== u && (this.fps = u, this.emitTrackUpdate());\n  }\n  get videoQuality() {\n    return this.currentVideoQuality;\n  }\n  /** @internal */\n  setTrack(u) {\n    const c = this.subscriptionStatus, l = this.permissionStatus, v = this.track;\n    v !== u && (v && (v.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange), v.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange), v.off(TrackEvent.Ended, this.handleEnded), v.detach(), v.stopMonitor(), this.emit(TrackEvent.Unsubscribed, v)), super.setTrack(u), u && (u.sid = this.trackSid, u.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange), u.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange), u.on(TrackEvent.Ended, this.handleEnded), this.emit(TrackEvent.Subscribed, u)), this.emitPermissionUpdateIfChanged(l), this.emitSubscriptionUpdateIfChanged(c));\n  }\n  /** @internal */\n  setAllowed(u) {\n    const c = this.subscriptionStatus, l = this.permissionStatus;\n    this.allowed = u, this.emitPermissionUpdateIfChanged(l), this.emitSubscriptionUpdateIfChanged(c);\n  }\n  /** @internal */\n  setSubscriptionError(u) {\n    this.emit(TrackEvent.SubscriptionFailed, u);\n  }\n  /** @internal */\n  updateInfo(u) {\n    super.updateInfo(u);\n    const c = this.metadataMuted;\n    this.metadataMuted = u.muted, this.track ? this.track.setMuted(u.muted) : c !== u.muted && this.emit(u.muted ? TrackEvent.Muted : TrackEvent.Unmuted);\n  }\n  emitSubscriptionUpdateIfChanged(u) {\n    const c = this.subscriptionStatus;\n    u !== c && this.emit(TrackEvent.SubscriptionStatusChanged, c, u);\n  }\n  emitPermissionUpdateIfChanged(u) {\n    this.permissionStatus !== u && this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, u);\n  }\n  isManualOperationAllowed() {\n    return this.kind === Track.Kind.Video && this.isAdaptiveStream ? (this.log.warn(\"adaptive stream is enabled, cannot change video track settings\", this.logContext), !1) : this.isDesired ? !0 : (this.log.warn(\"cannot update track settings when not subscribed\", this.logContext), !1);\n  }\n  get isAdaptiveStream() {\n    return this.track instanceof RemoteVideoTrack && this.track.isAdaptiveStream;\n  }\n  /* @internal */\n  emitTrackUpdate() {\n    const u = new UpdateTrackSettings({\n      trackSids: [this.trackSid],\n      disabled: this.disabled,\n      fps: this.fps\n    });\n    this.videoDimensions ? (u.width = Math.ceil(this.videoDimensions.width), u.height = Math.ceil(this.videoDimensions.height)) : this.currentVideoQuality !== void 0 ? u.quality = this.currentVideoQuality : u.quality = VideoQuality.HIGH, this.emit(TrackEvent.UpdateSettings, u);\n  }\n}\nclass RemoteParticipant extends Participant {\n  /** @internal */\n  static fromParticipantInfo(u, c) {\n    return new RemoteParticipant(u, c.sid, c.identity, c.name, c.metadata);\n  }\n  /** @internal */\n  constructor(u, c, l, v, S, g) {\n    super(c, l || \"\", v, S, g), this.signalClient = u, this.trackPublications = /* @__PURE__ */ new Map(), this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.volumeMap = /* @__PURE__ */ new Map();\n  }\n  addTrackPublication(u) {\n    super.addTrackPublication(u), u.on(TrackEvent.UpdateSettings, (c) => {\n      this.log.debug(\"send update settings\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), this.signalClient.sendUpdateTrackSettings(c);\n    }), u.on(TrackEvent.UpdateSubscription, (c) => {\n      c.participantTracks.forEach((l) => {\n        l.participantSid = this.sid;\n      }), this.signalClient.sendUpdateSubscription(c);\n    }), u.on(TrackEvent.SubscriptionPermissionChanged, (c) => {\n      this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, u, c);\n    }), u.on(TrackEvent.SubscriptionStatusChanged, (c) => {\n      this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, u, c);\n    }), u.on(TrackEvent.Subscribed, (c) => {\n      this.emit(ParticipantEvent.TrackSubscribed, c, u);\n    }), u.on(TrackEvent.Unsubscribed, (c) => {\n      this.emit(ParticipantEvent.TrackUnsubscribed, c, u);\n    }), u.on(TrackEvent.SubscriptionFailed, (c) => {\n      this.emit(ParticipantEvent.TrackSubscriptionFailed, u.trackSid, c);\n    });\n  }\n  getTrackPublication(u) {\n    const c = super.getTrackPublication(u);\n    if (c)\n      return c;\n  }\n  getTrackPublicationByName(u) {\n    const c = super.getTrackPublicationByName(u);\n    if (c)\n      return c;\n  }\n  /**\n   * sets the volume on the participant's audio track\n   * by default, this affects the microphone publication\n   * a different source can be passed in as a second argument\n   * if no track exists the volume will be applied when the microphone track is added\n   */\n  setVolume(u) {\n    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Track.Source.Microphone;\n    this.volumeMap.set(c, u);\n    const l = this.getTrackPublication(c);\n    l && l.track && l.track.setVolume(u);\n  }\n  /**\n   * gets the volume on the participant's microphone track\n   */\n  getVolume() {\n    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Track.Source.Microphone;\n    const c = this.getTrackPublication(u);\n    return c && c.track ? c.track.getVolume() : this.volumeMap.get(u);\n  }\n  /** @internal */\n  addSubscribedMediaTrack(u, c, l, v, S, g) {\n    let E = this.getTrackPublicationBySid(c);\n    if (E || c.startsWith(\"TR\") || this.trackPublications.forEach((L) => {\n      !E && u.kind === L.kind.toString() && (E = L);\n    }), !E) {\n      if (g === 0) {\n        this.log.error(\"could not find published track\", Object.assign(Object.assign({}, this.logContext), {\n          trackSid: c\n        })), this.emit(ParticipantEvent.TrackSubscriptionFailed, c);\n        return;\n      }\n      g === void 0 && (g = 20), setTimeout(() => {\n        this.addSubscribedMediaTrack(u, c, l, v, S, g - 1);\n      }, 150);\n      return;\n    }\n    if (u.readyState === \"ended\") {\n      this.log.error(\"unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(E))), this.emit(ParticipantEvent.TrackSubscriptionFailed, c);\n      return;\n    }\n    const _ = u.kind === \"video\";\n    let k;\n    return _ ? k = new RemoteVideoTrack(u, c, v, S) : k = new RemoteAudioTrack(u, c, v, this.audioContext, this.audioOutput), k.source = E.source, k.isMuted = E.isMuted, k.setMediaStream(l), k.start(), E.setTrack(k), this.volumeMap.has(E.source) && k instanceof RemoteAudioTrack && k.setVolume(this.volumeMap.get(E.source)), E;\n  }\n  /** @internal */\n  get hasMetadata() {\n    return !!this.participantInfo;\n  }\n  /**\n   * @internal\n   */\n  getTrackPublicationBySid(u) {\n    return this.trackPublications.get(u);\n  }\n  /** @internal */\n  updateInfo(u) {\n    if (!super.updateInfo(u))\n      return !1;\n    const c = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map();\n    return u.tracks.forEach((v) => {\n      var S, g;\n      let E = this.getTrackPublicationBySid(v.sid);\n      if (E)\n        E.updateInfo(v);\n      else {\n        const _ = Track.kindFromProto(v.type);\n        if (!_)\n          return;\n        E = new RemoteTrackPublication(_, v, (S = this.signalClient.connectOptions) === null || S === void 0 ? void 0 : S.autoSubscribe, {\n          loggerContextCb: () => this.logContext,\n          loggerName: (g = this.loggerOptions) === null || g === void 0 ? void 0 : g.loggerName\n        }), E.updateInfo(v), l.set(v.sid, E);\n        const k = Array.from(this.trackPublications.values()).find((L) => L.source === (E == null ? void 0 : E.source));\n        k && E.source !== Track.Source.Unknown && this.log.debug(\"received a second track publication for \".concat(this.identity, \" with the same source: \").concat(E.source), Object.assign(Object.assign({}, this.logContext), {\n          oldTrack: getLogContextFromTrack(k),\n          newTrack: getLogContextFromTrack(E)\n        })), this.addTrackPublication(E);\n      }\n      c.set(v.sid, E);\n    }), this.trackPublications.forEach((v) => {\n      c.has(v.trackSid) || (this.log.trace(\"detected removed track on remote participant, unpublishing\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(v))), this.unpublishTrack(v.trackSid, !0));\n    }), l.forEach((v) => {\n      this.emit(ParticipantEvent.TrackPublished, v);\n    }), !0;\n  }\n  /** @internal */\n  unpublishTrack(u, c) {\n    const l = this.trackPublications.get(u);\n    if (!l)\n      return;\n    const {\n      track: v\n    } = l;\n    switch (v && (v.stop(), l.setTrack(void 0)), this.trackPublications.delete(u), l.kind) {\n      case Track.Kind.Audio:\n        this.audioTrackPublications.delete(u);\n        break;\n      case Track.Kind.Video:\n        this.videoTrackPublications.delete(u);\n        break;\n    }\n    c && this.emit(ParticipantEvent.TrackUnpublished, l);\n  }\n  /**\n   * @internal\n   */\n  setAudioOutput(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.audioOutput = u;\n      const c = [];\n      this.audioTrackPublications.forEach((l) => {\n        var v;\n        l.track instanceof RemoteAudioTrack && c.push(l.track.setSinkId((v = u.deviceId) !== null && v !== void 0 ? v : \"default\"));\n      }), yield Promise.all(c);\n    });\n  }\n  /** @internal */\n  emit(u) {\n    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)\n      l[v - 1] = arguments[v];\n    return this.log.trace(\"participant event\", Object.assign(Object.assign({}, this.logContext), {\n      event: u,\n      args: l\n    })), super.emit(u, ...l);\n  }\n}\nvar ConnectionState;\n(function(a) {\n  a.Disconnected = \"disconnected\", a.Connecting = \"connecting\", a.Connected = \"connected\", a.Reconnecting = \"reconnecting\";\n})(ConnectionState || (ConnectionState = {}));\nconst connectionReconcileFrequency = 2 * 1e3;\nclass Room extends eventsExports.EventEmitter {\n  /**\n   * Creates a new Room, the primary construct for a LiveKit session.\n   * @param options\n   */\n  constructor(u) {\n    var c, l, v;\n    super(), c = this, this.state = ConnectionState.Disconnected, this.activeSpeakers = [], this.isE2EEEnabled = !1, this.audioEnabled = !0, this.isVideoPlaybackBlocked = !1, this.log = livekitLogger, this.bufferedEvents = [], this.isResuming = !1, this.connect = (S, g, E) => __awaiter(this, void 0, void 0, function* () {\n      var _;\n      const k = yield this.disconnectLock.lock();\n      if (this.state === ConnectionState.Connected)\n        return this.log.info(\"already connected to room \".concat(this.name), this.logContext), k(), Promise.resolve();\n      if (this.connectFuture)\n        return k(), this.connectFuture.promise;\n      this.setAndEmitConnectionState(ConnectionState.Connecting), ((_ = this.regionUrlProvider) === null || _ === void 0 ? void 0 : _.getServerUrl().toString()) !== S && (this.regionUrl = void 0, this.regionUrlProvider = void 0), isCloud(new URL(S)) && (this.regionUrlProvider === void 0 ? this.regionUrlProvider = new RegionUrlProvider(S, g) : this.regionUrlProvider.updateToken(g), this.regionUrlProvider.fetchRegionSettings().catch(($) => {\n        this.log.warn(\"could not fetch region settings\", Object.assign(Object.assign({}, this.logContext), {\n          error: $\n        }));\n      }));\n      const L = ($, J, V) => __awaiter(this, void 0, void 0, function* () {\n        var q;\n        this.abortController && this.abortController.abort();\n        const G = new AbortController();\n        this.abortController = G, k == null || k();\n        try {\n          yield this.attemptConnection(V ?? S, g, E, G), this.abortController = void 0, $();\n        } catch (H) {\n          if (this.regionUrlProvider && H instanceof ConnectionError && H.reason !== 3 && H.reason !== 0) {\n            let B = null;\n            try {\n              B = yield this.regionUrlProvider.getNextBestRegionUrl((q = this.abortController) === null || q === void 0 ? void 0 : q.signal);\n            } catch (Y) {\n              if (Y instanceof ConnectionError && (Y.status === 401 || Y.reason === 3)) {\n                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), J(Y);\n                return;\n              }\n            }\n            B ? (this.log.info(\"Initial connection failed with ConnectionError: \".concat(H.message, \". Retrying with another region: \").concat(B), this.logContext), yield L($, J, B)) : (this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), J(H));\n          } else\n            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), J(H);\n        }\n      }), M = this.regionUrl;\n      return this.regionUrl = void 0, this.connectFuture = new Future(($, J) => {\n        L($, J, M);\n      }, () => {\n        this.clearConnectionFutures();\n      }), this.connectFuture.promise;\n    }), this.connectSignal = (S, g, E, _, k, L) => __awaiter(this, void 0, void 0, function* () {\n      var M, $, J;\n      const V = yield E.join(S, g, {\n        autoSubscribe: _.autoSubscribe,\n        adaptiveStream: typeof k.adaptiveStream == \"object\" ? !0 : k.adaptiveStream,\n        maxRetries: _.maxRetries,\n        e2eeEnabled: !!this.e2eeManager,\n        websocketTimeout: _.websocketTimeout\n      }, L.signal);\n      let q = V.serverInfo;\n      if (q || (q = {\n        version: V.serverVersion,\n        region: V.serverRegion\n      }), this.log.debug(\"connected to Livekit Server \".concat(Object.entries(q).map((G) => {\n        let [H, B] = G;\n        return \"\".concat(H, \": \").concat(B);\n      }).join(\", \")), {\n        room: (M = V.room) === null || M === void 0 ? void 0 : M.name,\n        roomSid: ($ = V.room) === null || $ === void 0 ? void 0 : $.sid,\n        identity: (J = V.participant) === null || J === void 0 ? void 0 : J.identity\n      }), !V.serverVersion)\n        throw new UnsupportedServer(\"unknown server version\");\n      return V.serverVersion === \"0.15.1\" && this.options.dynacast && (this.log.debug(\"disabling dynacast due to server version\", this.logContext), k.dynacast = !1), V;\n    }), this.applyJoinResponse = (S) => {\n      const g = S.participant;\n      this.localParticipant.sid = g.sid, this.localParticipant.identity = g.identity, this.handleParticipantUpdates([g, ...S.otherParticipants]), S.room && this.handleRoomUpdate(S.room), this.options.e2ee && this.e2eeManager && this.e2eeManager.setSifTrailer(S.sifTrailer);\n    }, this.attemptConnection = (S, g, E, _) => __awaiter(this, void 0, void 0, function* () {\n      var k, L, M;\n      this.state === ConnectionState.Reconnecting || this.isResuming || !((k = this.engine) === null || k === void 0) && k.pendingReconnect ? (this.log.info(\"Reconnection attempt replaced by new connection attempt\", this.logContext), this.recreateEngine()) : this.maybeCreateEngine(), !((L = this.regionUrlProvider) === null || L === void 0) && L.isCloud() && this.engine.setRegionUrlProvider(this.regionUrlProvider), this.acquireAudioContext(), this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), E), this.connOptions.rtcConfig && (this.engine.rtcConfig = this.connOptions.rtcConfig), this.connOptions.peerConnectionTimeout && (this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout);\n      try {\n        const $ = yield this.connectSignal(S, g, this.engine, this.connOptions, this.options, _);\n        this.applyJoinResponse($), this.setupLocalParticipantEvents(), this.emit(RoomEvent.SignalConnected);\n      } catch ($) {\n        yield this.engine.close(), this.recreateEngine();\n        const J = new ConnectionError(\"could not establish signal connection\");\n        throw $ instanceof Error && (J.message = \"\".concat(J.message, \": \").concat($.message)), $ instanceof ConnectionError && (J.reason = $.reason, J.status = $.status), this.log.debug(\"error trying to establish signal connection\", Object.assign(Object.assign({}, this.logContext), {\n          error: $\n        })), J;\n      }\n      if (_.signal.aborted)\n        throw yield this.engine.close(), this.recreateEngine(), new ConnectionError(\"Connection attempt aborted\");\n      try {\n        yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, _);\n      } catch ($) {\n        throw yield this.engine.close(), this.recreateEngine(), $;\n      }\n      isWeb() && this.options.disconnectOnPageLeave && (window.addEventListener(\"pagehide\", this.onPageLeave), window.addEventListener(\"beforeunload\", this.onPageLeave)), isWeb() && (document.addEventListener(\"freeze\", this.onPageLeave), (M = navigator.mediaDevices) === null || M === void 0 || M.addEventListener(\"devicechange\", this.handleDeviceChange)), this.setAndEmitConnectionState(ConnectionState.Connected), this.emit(RoomEvent.Connected), this.registerConnectionReconcile();\n    }), this.disconnect = function() {\n      let S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;\n      return __awaiter(c, void 0, void 0, function* () {\n        var g, E, _, k;\n        const L = yield this.disconnectLock.lock();\n        try {\n          if (this.state === ConnectionState.Disconnected) {\n            this.log.debug(\"already disconnected\", this.logContext);\n            return;\n          }\n          this.log.info(\"disconnect from room\", Object.assign({}, this.logContext)), (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting || this.isResuming) && (this.log.warn(\"abort connection attempt\", this.logContext), (g = this.abortController) === null || g === void 0 || g.abort(), (_ = (E = this.connectFuture) === null || E === void 0 ? void 0 : E.reject) === null || _ === void 0 || _.call(E, new ConnectionError(\"Client initiated disconnect\")), this.connectFuture = void 0), !((k = this.engine) === null || k === void 0) && k.client.isDisconnected || (yield this.engine.client.sendLeave()), this.engine && (yield this.engine.close()), this.handleDisconnect(S, DisconnectReason.CLIENT_INITIATED), this.engine = void 0;\n        } finally {\n          L();\n        }\n      });\n    }, this.onPageLeave = () => __awaiter(this, void 0, void 0, function* () {\n      yield this.disconnect();\n    }), this.startAudio = () => __awaiter(this, void 0, void 0, function* () {\n      const S = [], g = getBrowser();\n      if (g && g.os === \"iOS\") {\n        const E = \"livekit-dummy-audio-el\";\n        let _ = document.getElementById(E);\n        if (!_) {\n          _ = document.createElement(\"audio\"), _.id = E, _.autoplay = !0, _.hidden = !0;\n          const k = getEmptyAudioStreamTrack();\n          k.enabled = !0;\n          const L = new MediaStream([k]);\n          _.srcObject = L, document.addEventListener(\"visibilitychange\", () => {\n            _ && (_.srcObject = document.hidden ? null : L, document.hidden || (this.log.debug(\"page visible again, triggering startAudio to resume playback and update playback status\", this.logContext), this.startAudio()));\n          }), document.body.append(_), this.once(RoomEvent.Disconnected, () => {\n            _ == null || _.remove(), _ = null;\n          });\n        }\n        S.push(_);\n      }\n      this.remoteParticipants.forEach((E) => {\n        E.audioTrackPublications.forEach((_) => {\n          _.track && _.track.attachedElements.forEach((k) => {\n            S.push(k);\n          });\n        });\n      });\n      try {\n        yield Promise.all([this.acquireAudioContext(), ...S.map((E) => (E.muted = !1, E.play()))]), this.handleAudioPlaybackStarted();\n      } catch (E) {\n        throw this.handleAudioPlaybackFailed(E), E;\n      }\n    }), this.startVideo = () => __awaiter(this, void 0, void 0, function* () {\n      const S = [];\n      for (const g of this.remoteParticipants.values())\n        g.videoTrackPublications.forEach((E) => {\n          var _;\n          (_ = E.track) === null || _ === void 0 || _.attachedElements.forEach((k) => {\n            S.includes(k) || S.push(k);\n          });\n        });\n      yield Promise.all(S.map((g) => g.play())).then(() => {\n        this.handleVideoPlaybackStarted();\n      }).catch((g) => {\n        g.name === \"NotAllowedError\" ? this.handleVideoPlaybackFailed() : this.log.warn(\"Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler\", this.logContext);\n      });\n    }), this.handleRestarting = () => {\n      this.clearConnectionReconcile(), this.isResuming = !1;\n      for (const S of this.remoteParticipants.values())\n        this.handleParticipantDisconnected(S.identity, S);\n      this.setAndEmitConnectionState(ConnectionState.Reconnecting) && this.emit(RoomEvent.Reconnecting);\n    }, this.handleSignalRestarted = (S) => __awaiter(this, void 0, void 0, function* () {\n      this.log.debug(\"signal reconnected to server, region \".concat(S.serverRegion), Object.assign(Object.assign({}, this.logContext), {\n        region: S.serverRegion\n      })), this.bufferedEvents = [], this.applyJoinResponse(S);\n      try {\n        yield this.localParticipant.republishAllTracks(void 0, !0);\n      } catch (g) {\n        this.log.error(\"error trying to re-publish tracks after reconnection\", Object.assign(Object.assign({}, this.logContext), {\n          error: g\n        }));\n      }\n      try {\n        yield this.engine.waitForRestarted(), this.log.debug(\"fully reconnected to server\", Object.assign(Object.assign({}, this.logContext), {\n          region: S.serverRegion\n        }));\n      } catch {\n        return;\n      }\n      this.setAndEmitConnectionState(ConnectionState.Connected), this.emit(RoomEvent.Reconnected), this.registerConnectionReconcile(), this.emitBufferedEvents();\n    }), this.handleParticipantUpdates = (S) => {\n      S.forEach((g) => {\n        var E;\n        if (g.identity === this.localParticipant.identity) {\n          this.localParticipant.updateInfo(g);\n          return;\n        }\n        g.identity === \"\" && (g.identity = (E = this.sidToIdentity.get(g.sid)) !== null && E !== void 0 ? E : \"\");\n        let _ = this.remoteParticipants.get(g.identity);\n        g.state === ParticipantInfo_State.DISCONNECTED ? this.handleParticipantDisconnected(g.identity, _) : _ = this.getOrCreateParticipant(g.identity, g);\n      });\n    }, this.handleActiveSpeakersUpdate = (S) => {\n      const g = [], E = {};\n      S.forEach((_) => {\n        if (E[_.sid] = !0, _.sid === this.localParticipant.sid)\n          this.localParticipant.audioLevel = _.level, this.localParticipant.setIsSpeaking(!0), g.push(this.localParticipant);\n        else {\n          const k = this.getRemoteParticipantBySid(_.sid);\n          k && (k.audioLevel = _.level, k.setIsSpeaking(!0), g.push(k));\n        }\n      }), E[this.localParticipant.sid] || (this.localParticipant.audioLevel = 0, this.localParticipant.setIsSpeaking(!1)), this.remoteParticipants.forEach((_) => {\n        E[_.sid] || (_.audioLevel = 0, _.setIsSpeaking(!1));\n      }), this.activeSpeakers = g, this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, g);\n    }, this.handleSpeakersChanged = (S) => {\n      const g = /* @__PURE__ */ new Map();\n      this.activeSpeakers.forEach((_) => {\n        g.set(_.sid, _);\n      }), S.forEach((_) => {\n        let k = this.getRemoteParticipantBySid(_.sid);\n        _.sid === this.localParticipant.sid && (k = this.localParticipant), k && (k.audioLevel = _.level, k.setIsSpeaking(_.active), _.active ? g.set(_.sid, k) : g.delete(_.sid));\n      });\n      const E = Array.from(g.values());\n      E.sort((_, k) => k.audioLevel - _.audioLevel), this.activeSpeakers = E, this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, E);\n    }, this.handleStreamStateUpdate = (S) => {\n      S.streamStates.forEach((g) => {\n        const E = this.getRemoteParticipantBySid(g.participantSid);\n        if (!E)\n          return;\n        const _ = E.getTrackPublicationBySid(g.trackSid);\n        !_ || !_.track || (_.track.streamState = Track.streamStateFromProto(g.state), E.emit(ParticipantEvent.TrackStreamStateChanged, _, _.track.streamState), this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, _, _.track.streamState, E));\n      });\n    }, this.handleSubscriptionPermissionUpdate = (S) => {\n      const g = this.getRemoteParticipantBySid(S.participantSid);\n      if (!g)\n        return;\n      const E = g.getTrackPublicationBySid(S.trackSid);\n      E && E.setAllowed(S.allowed);\n    }, this.handleSubscriptionError = (S) => {\n      const g = Array.from(this.remoteParticipants.values()).find((_) => _.trackPublications.has(S.trackSid));\n      if (!g)\n        return;\n      const E = g.getTrackPublicationBySid(S.trackSid);\n      E && E.setSubscriptionError(S.err);\n    }, this.handleDataPacket = (S, g) => {\n      const E = this.remoteParticipants.get(S.participantIdentity);\n      this.emit(RoomEvent.DataReceived, S.payload, E, g, S.topic), E == null || E.emit(ParticipantEvent.DataReceived, S.payload, g);\n    }, this.handleAudioPlaybackStarted = () => {\n      this.canPlaybackAudio || (this.audioEnabled = !0, this.emit(RoomEvent.AudioPlaybackStatusChanged, !0));\n    }, this.handleAudioPlaybackFailed = (S) => {\n      this.log.warn(\"could not playback audio\", Object.assign(Object.assign({}, this.logContext), {\n        error: S\n      })), this.canPlaybackAudio && (this.audioEnabled = !1, this.emit(RoomEvent.AudioPlaybackStatusChanged, !1));\n    }, this.handleVideoPlaybackStarted = () => {\n      this.isVideoPlaybackBlocked && (this.isVideoPlaybackBlocked = !1, this.emit(RoomEvent.VideoPlaybackStatusChanged, !0));\n    }, this.handleVideoPlaybackFailed = () => {\n      this.isVideoPlaybackBlocked || (this.isVideoPlaybackBlocked = !0, this.emit(RoomEvent.VideoPlaybackStatusChanged, !1));\n    }, this.handleDeviceChange = () => __awaiter(this, void 0, void 0, function* () {\n      this.emit(RoomEvent.MediaDevicesChanged);\n    }), this.handleRoomUpdate = (S) => {\n      const g = this.roomInfo;\n      this.roomInfo = S, g && g.metadata !== S.metadata && this.emitWhenConnected(RoomEvent.RoomMetadataChanged, S.metadata), (g == null ? void 0 : g.activeRecording) !== S.activeRecording && this.emitWhenConnected(RoomEvent.RecordingStatusChanged, S.activeRecording);\n    }, this.handleConnectionQualityUpdate = (S) => {\n      S.updates.forEach((g) => {\n        if (g.participantSid === this.localParticipant.sid) {\n          this.localParticipant.setConnectionQuality(g.quality);\n          return;\n        }\n        const E = this.getRemoteParticipantBySid(g.participantSid);\n        E && E.setConnectionQuality(g.quality);\n      });\n    }, this.onLocalParticipantMetadataChanged = (S) => {\n      this.emit(RoomEvent.ParticipantMetadataChanged, S, this.localParticipant);\n    }, this.onLocalParticipantNameChanged = (S) => {\n      this.emit(RoomEvent.ParticipantNameChanged, S, this.localParticipant);\n    }, this.onLocalTrackMuted = (S) => {\n      this.emit(RoomEvent.TrackMuted, S, this.localParticipant);\n    }, this.onLocalTrackUnmuted = (S) => {\n      this.emit(RoomEvent.TrackUnmuted, S, this.localParticipant);\n    }, this.onLocalTrackPublished = (S) => __awaiter(this, void 0, void 0, function* () {\n      var g;\n      this.emit(RoomEvent.LocalTrackPublished, S, this.localParticipant), S.track instanceof LocalAudioTrack && (yield S.track.checkForSilence()) && this.emit(RoomEvent.LocalAudioSilenceDetected, S);\n      const E = yield (g = S.track) === null || g === void 0 ? void 0 : g.getDeviceId(), _ = sourceToKind(S.source);\n      _ && E && E !== this.localParticipant.activeDeviceMap.get(_) && (this.localParticipant.activeDeviceMap.set(_, E), this.emit(RoomEvent.ActiveDeviceChanged, _, E));\n    }), this.onLocalTrackUnpublished = (S) => {\n      this.emit(RoomEvent.LocalTrackUnpublished, S, this.localParticipant);\n    }, this.onLocalConnectionQualityChanged = (S) => {\n      this.emit(RoomEvent.ConnectionQualityChanged, S, this.localParticipant);\n    }, this.onMediaDevicesError = (S) => {\n      this.emit(RoomEvent.MediaDevicesError, S);\n    }, this.onLocalParticipantPermissionsChanged = (S) => {\n      this.emit(RoomEvent.ParticipantPermissionsChanged, S, this.localParticipant);\n    }, this.setMaxListeners(100), this.remoteParticipants = /* @__PURE__ */ new Map(), this.sidToIdentity = /* @__PURE__ */ new Map(), this.options = Object.assign(Object.assign({}, roomOptionDefaults), u), this.log = getLogger((l = this.options.loggerName) !== null && l !== void 0 ? l : LoggerNames.Room), this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), u == null ? void 0 : u.audioCaptureDefaults), this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), u == null ? void 0 : u.videoCaptureDefaults), this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), u == null ? void 0 : u.publishDefaults), this.maybeCreateEngine(), this.disconnectLock = new Mutex(), this.localParticipant = new LocalParticipant(\"\", \"\", this.engine, this.options), this.options.videoCaptureDefaults.deviceId && this.localParticipant.activeDeviceMap.set(\"videoinput\", unwrapConstraint(this.options.videoCaptureDefaults.deviceId)), this.options.audioCaptureDefaults.deviceId && this.localParticipant.activeDeviceMap.set(\"audioinput\", unwrapConstraint(this.options.audioCaptureDefaults.deviceId)), !((v = this.options.audioOutput) === null || v === void 0) && v.deviceId && this.switchActiveDevice(\"audiooutput\", unwrapConstraint(this.options.audioOutput.deviceId)).catch((S) => this.log.warn(\"Could not set audio output: \".concat(S.message), this.logContext)), this.options.e2ee && this.setupE2EE();\n  }\n  /**\n   * @experimental\n   */\n  setE2EEEnabled(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.e2eeManager)\n        yield Promise.all([this.localParticipant.setE2EEEnabled(u)]), this.localParticipant.identity !== \"\" && this.e2eeManager.setParticipantCryptorEnabled(u, this.localParticipant.identity);\n      else\n        throw Error(\"e2ee not configured, please set e2ee settings within the room options\");\n    });\n  }\n  setupE2EE() {\n    var u;\n    this.options.e2ee && (this.e2eeManager = new E2EEManager(this.options.e2ee), this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (c, l) => {\n      l instanceof LocalParticipant && (this.isE2EEEnabled = c), this.emit(RoomEvent.ParticipantEncryptionStatusChanged, c, l);\n    }), this.e2eeManager.on(EncryptionEvent.EncryptionError, (c) => this.emit(RoomEvent.EncryptionError, c)), (u = this.e2eeManager) === null || u === void 0 || u.setup(this));\n  }\n  get logContext() {\n    var u;\n    return {\n      room: this.name,\n      roomSid: (u = this.roomInfo) === null || u === void 0 ? void 0 : u.sid,\n      identity: this.localParticipant.identity\n    };\n  }\n  /**\n   * if the current room has a participant with `recorder: true` in its JWT grant\n   **/\n  get isRecording() {\n    var u, c;\n    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.activeRecording) !== null && c !== void 0 ? c : !1;\n  }\n  /**\n   * server assigned unique room id.\n   * returns once a sid has been issued by the server.\n   */\n  getSid() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.state === ConnectionState.Disconnected ? \"\" : this.roomInfo && this.roomInfo.sid !== \"\" ? this.roomInfo.sid : new Promise((u, c) => {\n        const l = (v) => {\n          v.sid !== \"\" && (this.engine.off(EngineEvent.RoomUpdate, l), u(v.sid));\n        };\n        this.engine.on(EngineEvent.RoomUpdate, l), this.once(RoomEvent.Disconnected, () => {\n          this.engine.off(EngineEvent.RoomUpdate, l), c(\"Room disconnected before room server id was available\");\n        });\n      });\n    });\n  }\n  /** user assigned name, derived from JWT token */\n  get name() {\n    var u, c;\n    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.name) !== null && c !== void 0 ? c : \"\";\n  }\n  /** room metadata */\n  get metadata() {\n    var u;\n    return (u = this.roomInfo) === null || u === void 0 ? void 0 : u.metadata;\n  }\n  get numParticipants() {\n    var u, c;\n    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.numParticipants) !== null && c !== void 0 ? c : 0;\n  }\n  get numPublishers() {\n    var u, c;\n    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.numPublishers) !== null && c !== void 0 ? c : 0;\n  }\n  maybeCreateEngine() {\n    this.engine && !this.engine.isClosed || (this.engine = new RTCEngine(this.options), this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (u, c, l) => {\n      this.onTrackAdded(u, c, l);\n    }).on(EngineEvent.Disconnected, (u) => {\n      this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, u);\n    }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {\n      this.clearConnectionReconcile(), this.isResuming = !0, this.log.info(\"Resuming signal connection\", this.logContext);\n    }).on(EngineEvent.Resumed, () => {\n      this.registerConnectionReconcile(), this.isResuming = !1, this.log.info(\"Resumed signal connection\", this.logContext), this.updateSubscriptions(), this.emitBufferedEvents();\n    }).on(EngineEvent.SignalResumed, () => {\n      this.bufferedEvents = [], (this.state === ConnectionState.Reconnecting || this.isResuming) && this.sendSyncState();\n    }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.DCBufferStatusChanged, (u, c) => {\n      this.emit(RoomEvent.DCBufferStatusChanged, u, c);\n    }), this.localParticipant && this.localParticipant.setupEngine(this.engine), this.e2eeManager && this.e2eeManager.setupEngine(this.engine));\n  }\n  /**\n   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.\n   * In particular, it handles Chrome's unique behavior of creating `default`\n   * devices. When encountered, it'll be removed from the list of devices.\n   * The actual default device will be placed at top.\n   * @param kind\n   * @returns a list of available local devices\n   */\n  static getLocalDevices(u) {\n    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;\n    return DeviceManager.getInstance().getDevices(u, c);\n  }\n  /**\n   * prepareConnection should be called as soon as the page is loaded, in order\n   * to speed up the connection attempt. This function will\n   * - perform DNS resolution and pre-warm the DNS cache\n   * - establish TLS connection and cache TLS keys\n   *\n   * With LiveKit Cloud, it will also determine the best edge data center for\n   * the current client to connect to if a token is provided.\n   */\n  prepareConnection(u, c) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.state === ConnectionState.Disconnected) {\n        this.log.debug(\"prepareConnection to \".concat(u), this.logContext);\n        try {\n          if (isCloud(new URL(u)) && c) {\n            this.regionUrlProvider = new RegionUrlProvider(u, c);\n            const l = yield this.regionUrlProvider.getNextBestRegionUrl();\n            l && this.state === ConnectionState.Disconnected && (this.regionUrl = l, yield fetch(toHttpUrl(l), {\n              method: \"HEAD\"\n            }), this.log.debug(\"prepared connection to \".concat(l), this.logContext));\n          } else\n            yield fetch(toHttpUrl(u), {\n              method: \"HEAD\"\n            });\n        } catch (l) {\n          this.log.warn(\"could not prepare connection\", Object.assign(Object.assign({}, this.logContext), {\n            error: l\n          }));\n        }\n      }\n    });\n  }\n  /**\n   * retrieves a participant by identity\n   * @param identity\n   * @returns\n   */\n  getParticipantByIdentity(u) {\n    return this.localParticipant.identity === u ? this.localParticipant : this.remoteParticipants.get(u);\n  }\n  clearConnectionFutures() {\n    this.connectFuture = void 0;\n  }\n  /**\n   * @internal for testing\n   */\n  simulateScenario(u, c) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let l = () => {\n      }, v;\n      switch (u) {\n        case \"signal-reconnect\":\n          yield this.engine.client.handleOnClose(\"simulate disconnect\");\n          break;\n        case \"speaker\":\n          v = new SimulateScenario({\n            scenario: {\n              case: \"speakerUpdate\",\n              value: 3\n            }\n          });\n          break;\n        case \"node-failure\":\n          v = new SimulateScenario({\n            scenario: {\n              case: \"nodeFailure\",\n              value: !0\n            }\n          });\n          break;\n        case \"server-leave\":\n          v = new SimulateScenario({\n            scenario: {\n              case: \"serverLeave\",\n              value: !0\n            }\n          });\n          break;\n        case \"migration\":\n          v = new SimulateScenario({\n            scenario: {\n              case: \"migration\",\n              value: !0\n            }\n          });\n          break;\n        case \"resume-reconnect\":\n          this.engine.failNext(), yield this.engine.client.handleOnClose(\"simulate resume-disconnect\");\n          break;\n        case \"disconnect-signal-on-resume\":\n          l = () => __awaiter(this, void 0, void 0, function* () {\n            yield this.engine.client.handleOnClose(\"simulate resume-disconnect\");\n          }), v = new SimulateScenario({\n            scenario: {\n              case: \"disconnectSignalOnResume\",\n              value: !0\n            }\n          });\n          break;\n        case \"disconnect-signal-on-resume-no-messages\":\n          l = () => __awaiter(this, void 0, void 0, function* () {\n            yield this.engine.client.handleOnClose(\"simulate resume-disconnect\");\n          }), v = new SimulateScenario({\n            scenario: {\n              case: \"disconnectSignalOnResumeNoMessages\",\n              value: !0\n            }\n          });\n          break;\n        case \"full-reconnect\":\n          this.engine.fullReconnectOnNext = !0, yield this.engine.client.handleOnClose(\"simulate full-reconnect\");\n          break;\n        case \"force-tcp\":\n        case \"force-tls\":\n          v = new SimulateScenario({\n            scenario: {\n              case: \"switchCandidateProtocol\",\n              value: u === \"force-tls\" ? 2 : 1\n            }\n          }), l = () => __awaiter(this, void 0, void 0, function* () {\n            const S = this.engine.client.onLeave;\n            S && S(new LeaveRequest({\n              reason: DisconnectReason.CLIENT_INITIATED,\n              canReconnect: !0\n            }));\n          });\n          break;\n        case \"subscriber-bandwidth\":\n          if (c === void 0 || typeof c != \"number\")\n            throw new Error(\"subscriber-bandwidth requires a number as argument\");\n          v = new SimulateScenario({\n            scenario: {\n              case: \"subscriberBandwidth\",\n              value: BigInt(c)\n            }\n          });\n          break;\n      }\n      v && (yield this.engine.client.sendSimulateScenario(v), yield l());\n    });\n  }\n  /**\n   * Returns true if audio playback is enabled\n   */\n  get canPlaybackAudio() {\n    return this.audioEnabled;\n  }\n  /**\n   * Returns true if video playback is enabled\n   */\n  get canPlaybackVideo() {\n    return !this.isVideoPlaybackBlocked;\n  }\n  getActiveDevice(u) {\n    return this.localParticipant.activeDeviceMap.get(u);\n  }\n  /**\n   * Switches all active devices used in this room to the given device.\n   *\n   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)\n   *\n   * @param kind use `videoinput` for camera track,\n   *  `audioinput` for microphone track,\n   *  `audiooutput` to set speaker for all incoming audio tracks\n   * @param deviceId\n   */\n  switchActiveDevice(u, c) {\n    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n    var v, S, g;\n    return __awaiter(this, void 0, void 0, function* () {\n      let E = !1, _ = !0;\n      const k = l ? {\n        exact: c\n      } : c;\n      if (u === \"audioinput\") {\n        const L = this.options.audioCaptureDefaults.deviceId;\n        this.options.audioCaptureDefaults.deviceId = k, E = L !== k;\n        const M = Array.from(this.localParticipant.audioTrackPublications.values()).filter(($) => $.source === Track.Source.Microphone);\n        try {\n          _ = (yield Promise.all(M.map(($) => {\n            var J;\n            return (J = $.audioTrack) === null || J === void 0 ? void 0 : J.setDeviceId(k);\n          }))).every(($) => $ === !0);\n        } catch ($) {\n          throw this.options.audioCaptureDefaults.deviceId = L, $;\n        }\n      } else if (u === \"videoinput\") {\n        const L = this.options.videoCaptureDefaults.deviceId;\n        this.options.videoCaptureDefaults.deviceId = k, E = L !== k;\n        const M = Array.from(this.localParticipant.videoTrackPublications.values()).filter(($) => $.source === Track.Source.Camera);\n        try {\n          _ = (yield Promise.all(M.map(($) => {\n            var J;\n            return (J = $.videoTrack) === null || J === void 0 ? void 0 : J.setDeviceId(k);\n          }))).every(($) => $ === !0);\n        } catch ($) {\n          throw this.options.videoCaptureDefaults.deviceId = L, $;\n        }\n      } else if (u === \"audiooutput\") {\n        if (!supportsSetSinkId() && !this.options.webAudioMix || this.options.webAudioMix && this.audioContext && !(\"setSinkId\" in this.audioContext))\n          throw new Error(\"cannot switch audio output, setSinkId not supported\");\n        (v = (g = this.options).audioOutput) !== null && v !== void 0 || (g.audioOutput = {});\n        const L = this.options.audioOutput.deviceId;\n        this.options.audioOutput.deviceId = c, E = L !== k;\n        try {\n          this.options.webAudioMix ? (S = this.audioContext) === null || S === void 0 || S.setSinkId(c) : yield Promise.all(Array.from(this.remoteParticipants.values()).map((M) => M.setAudioOutput({\n            deviceId: c\n          })));\n        } catch (M) {\n          throw this.options.audioOutput.deviceId = L, M;\n        }\n      }\n      return E && _ && (this.localParticipant.activeDeviceMap.set(u, c), this.emit(RoomEvent.ActiveDeviceChanged, u, c)), _;\n    });\n  }\n  setupLocalParticipantEvents() {\n    this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n  }\n  recreateEngine() {\n    var u;\n    (u = this.engine) === null || u === void 0 || u.close(), this.engine = void 0, this.isResuming = !1, this.remoteParticipants.clear(), this.sidToIdentity.clear(), this.bufferedEvents = [], this.maybeCreateEngine();\n  }\n  onTrackAdded(u, c, l) {\n    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n      const L = () => {\n        this.onTrackAdded(u, c, l), M();\n      }, M = () => {\n        this.off(RoomEvent.Reconnected, L), this.off(RoomEvent.Connected, L), this.off(RoomEvent.Disconnected, M);\n      };\n      this.once(RoomEvent.Reconnected, L), this.once(RoomEvent.Connected, L), this.once(RoomEvent.Disconnected, M);\n      return;\n    }\n    if (this.state === ConnectionState.Disconnected) {\n      this.log.warn(\"skipping incoming track after Room disconnected\", this.logContext);\n      return;\n    }\n    const v = unpackStreamId(c.id), S = v[0];\n    let g = v[1], E = u.id;\n    if (g && g.startsWith(\"TR\") && (E = g), S === this.localParticipant.sid) {\n      this.log.warn(\"tried to create RemoteParticipant for local participant\", this.logContext);\n      return;\n    }\n    const _ = Array.from(this.remoteParticipants.values()).find((L) => L.sid === S);\n    if (!_) {\n      this.log.error(\"Tried to add a track for a participant, that's not present. Sid: \".concat(S), this.logContext);\n      return;\n    }\n    let k;\n    this.options.adaptiveStream && (typeof this.options.adaptiveStream == \"object\" ? k = this.options.adaptiveStream : k = {}), _.addSubscribedMediaTrack(u, E, c, l, k);\n  }\n  handleDisconnect() {\n    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, c = arguments.length > 1 ? arguments[1] : void 0;\n    var l;\n    if (this.clearConnectionReconcile(), this.isResuming = !1, this.bufferedEvents = [], this.state !== ConnectionState.Disconnected) {\n      this.regionUrl = void 0;\n      try {\n        this.remoteParticipants.forEach((v) => {\n          v.trackPublications.forEach((S) => {\n            v.unpublishTrack(S.trackSid);\n          });\n        }), this.localParticipant.trackPublications.forEach((v) => {\n          var S, g;\n          v.track && this.localParticipant.unpublishTrack(v.track, u), u && ((S = v.track) === null || S === void 0 || S.detach(), (g = v.track) === null || g === void 0 || g.stop());\n        }), this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged), this.localParticipant.trackPublications.clear(), this.localParticipant.videoTrackPublications.clear(), this.localParticipant.audioTrackPublications.clear(), this.remoteParticipants.clear(), this.sidToIdentity.clear(), this.activeSpeakers = [], this.audioContext && typeof this.options.webAudioMix == \"boolean\" && (this.audioContext.close(), this.audioContext = void 0), isWeb() && (window.removeEventListener(\"beforeunload\", this.onPageLeave), window.removeEventListener(\"pagehide\", this.onPageLeave), window.removeEventListener(\"freeze\", this.onPageLeave), (l = navigator.mediaDevices) === null || l === void 0 || l.removeEventListener(\"devicechange\", this.handleDeviceChange));\n      } finally {\n        this.setAndEmitConnectionState(ConnectionState.Disconnected), this.emit(RoomEvent.Disconnected, c);\n      }\n    }\n  }\n  handleParticipantDisconnected(u, c) {\n    this.remoteParticipants.delete(u), c && (c.trackPublications.forEach((l) => {\n      c.unpublishTrack(l.trackSid, !0);\n    }), this.emit(RoomEvent.ParticipantDisconnected, c));\n  }\n  acquireAudioContext() {\n    var u, c;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof this.options.webAudioMix != \"boolean\" && this.options.webAudioMix.audioContext ? this.audioContext = this.options.webAudioMix.audioContext : (!this.audioContext || this.audioContext.state === \"closed\") && (this.audioContext = (u = getNewAudioContext()) !== null && u !== void 0 ? u : void 0), this.audioContext && this.audioContext.state === \"suspended\")\n        try {\n          yield this.audioContext.resume();\n        } catch (v) {\n          this.log.warn(\"Could not resume audio context\", Object.assign(Object.assign({}, this.logContext), {\n            error: v\n          }));\n        }\n      this.options.webAudioMix && this.remoteParticipants.forEach((v) => v.setAudioContext(this.audioContext)), this.localParticipant.setAudioContext(this.audioContext);\n      const l = ((c = this.audioContext) === null || c === void 0 ? void 0 : c.state) === \"running\";\n      l !== this.canPlaybackAudio && (this.audioEnabled = l, this.emit(RoomEvent.AudioPlaybackStatusChanged, l));\n    });\n  }\n  createParticipant(u, c) {\n    var l;\n    let v;\n    return c ? v = RemoteParticipant.fromParticipantInfo(this.engine.client, c) : v = new RemoteParticipant(this.engine.client, \"\", u, void 0, void 0, {\n      loggerContextCb: () => this.logContext,\n      loggerName: this.options.loggerName\n    }), this.options.webAudioMix && v.setAudioContext(this.audioContext), !((l = this.options.audioOutput) === null || l === void 0) && l.deviceId && v.setAudioOutput(this.options.audioOutput).catch((S) => this.log.warn(\"Could not set audio output: \".concat(S.message), this.logContext)), v;\n  }\n  getOrCreateParticipant(u, c) {\n    if (this.remoteParticipants.has(u)) {\n      const v = this.remoteParticipants.get(u);\n      return c && v.updateInfo(c) && this.sidToIdentity.set(c.sid, c.identity), v;\n    }\n    const l = this.createParticipant(u, c);\n    return this.remoteParticipants.set(u, l), this.sidToIdentity.set(c.sid, c.identity), this.emitWhenConnected(RoomEvent.ParticipantConnected, l), l.on(ParticipantEvent.TrackPublished, (v) => {\n      this.emitWhenConnected(RoomEvent.TrackPublished, v, l);\n    }).on(ParticipantEvent.TrackSubscribed, (v, S) => {\n      v.kind === Track.Kind.Audio ? (v.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted), v.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed)) : v.kind === Track.Kind.Video && (v.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed), v.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted)), this.emit(RoomEvent.TrackSubscribed, v, S, l);\n    }).on(ParticipantEvent.TrackUnpublished, (v) => {\n      this.emit(RoomEvent.TrackUnpublished, v, l);\n    }).on(ParticipantEvent.TrackUnsubscribed, (v, S) => {\n      this.emit(RoomEvent.TrackUnsubscribed, v, S, l);\n    }).on(ParticipantEvent.TrackSubscriptionFailed, (v) => {\n      this.emit(RoomEvent.TrackSubscriptionFailed, v, l);\n    }).on(ParticipantEvent.TrackMuted, (v) => {\n      this.emitWhenConnected(RoomEvent.TrackMuted, v, l);\n    }).on(ParticipantEvent.TrackUnmuted, (v) => {\n      this.emitWhenConnected(RoomEvent.TrackUnmuted, v, l);\n    }).on(ParticipantEvent.ParticipantMetadataChanged, (v) => {\n      this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, v, l);\n    }).on(ParticipantEvent.ParticipantNameChanged, (v) => {\n      this.emitWhenConnected(RoomEvent.ParticipantNameChanged, v, l);\n    }).on(ParticipantEvent.ConnectionQualityChanged, (v) => {\n      this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, v, l);\n    }).on(ParticipantEvent.ParticipantPermissionsChanged, (v) => {\n      this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, v, l);\n    }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (v, S) => {\n      this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, v, S, l);\n    }).on(ParticipantEvent.TrackSubscriptionFailed, (v, S) => {\n      this.emit(RoomEvent.TrackSubscriptionFailed, v, l, S);\n    }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (v, S) => {\n      this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, v, S, l);\n    }), c && l.updateInfo(c), l;\n  }\n  sendSyncState() {\n    const u = Array.from(this.remoteParticipants.values()).reduce((l, v) => (l.push(...v.getTrackPublications()), l), []), c = this.localParticipant.getTrackPublications();\n    this.engine.sendSyncState(u, c);\n  }\n  /**\n   * After resuming, we'll need to notify the server of the current\n   * subscription settings.\n   */\n  updateSubscriptions() {\n    for (const u of this.remoteParticipants.values())\n      for (const c of u.videoTrackPublications.values())\n        c.isSubscribed && c instanceof RemoteTrackPublication && c.emitTrackUpdate();\n  }\n  getRemoteParticipantBySid(u) {\n    const c = this.sidToIdentity.get(u);\n    if (c)\n      return this.remoteParticipants.get(c);\n  }\n  registerConnectionReconcile() {\n    this.clearConnectionReconcile();\n    let u = 0;\n    this.connectionReconcileInterval = CriticalTimers.setInterval(() => {\n      // ensure we didn't tear it down\n      !this.engine || // engine detected close, but Room missed it\n      this.engine.isClosed || // transports failed without notifying engine\n      !this.engine.verifyTransport() ? (u++, this.log.warn(\"detected connection state mismatch\", Object.assign(Object.assign({}, this.logContext), {\n        numFailures: u,\n        engine: {\n          closed: this.engine.isClosed,\n          transportsConnected: this.engine.verifyTransport()\n        }\n      })), u >= 3 && (this.recreateEngine(), this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH))) : u = 0;\n    }, connectionReconcileFrequency);\n  }\n  clearConnectionReconcile() {\n    this.connectionReconcileInterval && CriticalTimers.clearInterval(this.connectionReconcileInterval);\n  }\n  setAndEmitConnectionState(u) {\n    return u === this.state ? !1 : (this.state = u, this.emit(RoomEvent.ConnectionStateChanged, this.state), !0);\n  }\n  emitBufferedEvents() {\n    this.bufferedEvents.forEach((u) => {\n      let [c, l] = u;\n      this.emit(c, ...l);\n    }), this.bufferedEvents = [];\n  }\n  emitWhenConnected(u) {\n    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)\n      l[v - 1] = arguments[v];\n    if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect)\n      this.bufferedEvents.push([u, l]);\n    else if (this.state === ConnectionState.Connected)\n      return this.emit(u, ...l);\n    return !1;\n  }\n  /**\n   * Allows to populate a room with simulated participants.\n   * No actual connection to a server will be established, all state is\n   * @experimental\n   */\n  simulateParticipants(u) {\n    var c, l;\n    return __awaiter(this, void 0, void 0, function* () {\n      const v = Object.assign({\n        audio: !0,\n        video: !0,\n        useRealTracks: !1\n      }, u.publish), S = Object.assign({\n        count: 9,\n        audio: !1,\n        video: !0,\n        aspectRatios: [1.66, 1.7, 1.3]\n      }, u.participants);\n      if (this.handleDisconnect(), this.roomInfo = new Room$1({\n        sid: \"RM_SIMULATED\",\n        name: \"simulated-room\",\n        emptyTimeout: 0,\n        maxParticipants: 0,\n        creationTime: protoInt64.parse((/* @__PURE__ */ new Date()).getTime()),\n        metadata: \"\",\n        numParticipants: 1,\n        numPublishers: 1,\n        turnPassword: \"\",\n        enabledCodecs: [],\n        activeRecording: !1\n      }), this.localParticipant.updateInfo(new ParticipantInfo({\n        identity: \"simulated-local\",\n        name: \"local-name\"\n      })), this.setupLocalParticipantEvents(), this.emit(RoomEvent.SignalConnected), this.emit(RoomEvent.Connected), this.setAndEmitConnectionState(ConnectionState.Connected), v.video) {\n        const g = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({\n          source: TrackSource.CAMERA,\n          sid: Math.floor(Math.random() * 1e4).toString(),\n          type: TrackType.AUDIO,\n          name: \"video-dummy\"\n        }), new LocalVideoTrack(v.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({\n          video: !0\n        })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((c = S.aspectRatios[0]) !== null && c !== void 0 ? c : 1), 160, !0, !0), void 0, !1, {\n          loggerName: this.options.loggerName,\n          loggerContextCb: () => this.logContext\n        }), {\n          loggerName: this.options.loggerName,\n          loggerContextCb: () => this.logContext\n        });\n        this.localParticipant.addTrackPublication(g), this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, g);\n      }\n      if (v.audio) {\n        const g = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({\n          source: TrackSource.MICROPHONE,\n          sid: Math.floor(Math.random() * 1e4).toString(),\n          type: TrackType.AUDIO\n        }), new LocalAudioTrack(v.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\n          audio: !0\n        })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), void 0, !1, this.audioContext, {\n          loggerName: this.options.loggerName,\n          loggerContextCb: () => this.logContext\n        }), {\n          loggerName: this.options.loggerName,\n          loggerContextCb: () => this.logContext\n        });\n        this.localParticipant.addTrackPublication(g), this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, g);\n      }\n      for (let g = 0; g < S.count - 1; g += 1) {\n        let E = new ParticipantInfo({\n          sid: Math.floor(Math.random() * 1e4).toString(),\n          identity: \"simulated-\".concat(g),\n          state: ParticipantInfo_State.ACTIVE,\n          tracks: [],\n          joinedAt: protoInt64.parse(Date.now())\n        });\n        const _ = this.getOrCreateParticipant(E.identity, E);\n        if (S.video) {\n          const k = createDummyVideoStreamTrack(160 * ((l = S.aspectRatios[g % S.aspectRatios.length]) !== null && l !== void 0 ? l : 1), 160, !1, !0), L = new TrackInfo({\n            source: TrackSource.CAMERA,\n            sid: Math.floor(Math.random() * 1e4).toString(),\n            type: TrackType.AUDIO\n          });\n          _.addSubscribedMediaTrack(k, L.sid, new MediaStream([k])), E.tracks = [...E.tracks, L];\n        }\n        if (S.audio) {\n          const k = getEmptyAudioStreamTrack(), L = new TrackInfo({\n            source: TrackSource.MICROPHONE,\n            sid: Math.floor(Math.random() * 1e4).toString(),\n            type: TrackType.AUDIO\n          });\n          _.addSubscribedMediaTrack(k, L.sid, new MediaStream([k])), E.tracks = [...E.tracks, L];\n        }\n        _.updateInfo(E);\n      }\n    });\n  }\n  // /** @internal */\n  emit(u) {\n    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)\n      l[v - 1] = arguments[v];\n    if (u !== RoomEvent.ActiveSpeakersChanged) {\n      const S = mapArgs(l).filter((g) => g !== void 0);\n      this.log.debug(\"room event \".concat(u), Object.assign(Object.assign({}, this.logContext), {\n        event: u,\n        args: S\n      }));\n    }\n    return super.emit(u, ...l);\n  }\n}\nfunction mapArgs(a) {\n  return a.map((u) => {\n    if (u)\n      return Array.isArray(u) ? mapArgs(u) : typeof u == \"object\" ? \"logContext\" in u && u.logContext : u;\n  });\n}\nvar CheckStatus;\n(function(a) {\n  a[a.IDLE = 0] = \"IDLE\", a[a.RUNNING = 1] = \"RUNNING\", a[a.SKIPPED = 2] = \"SKIPPED\", a[a.SUCCESS = 3] = \"SUCCESS\", a[a.FAILED = 4] = \"FAILED\";\n})(CheckStatus || (CheckStatus = {}));\nclass Checker extends eventsExports.EventEmitter {\n  constructor(u, c) {\n    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    super(), this.status = CheckStatus.IDLE, this.logs = [], this.errorsAsWarnings = !1, this.url = u, this.token = c, this.name = this.constructor.name, this.room = new Room(l.roomOptions), this.connectOptions = l.connectOptions, l.errorsAsWarnings && (this.errorsAsWarnings = l.errorsAsWarnings);\n  }\n  run(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== CheckStatus.IDLE)\n        throw Error(\"check is running already\");\n      this.setStatus(CheckStatus.RUNNING);\n      try {\n        yield this.perform();\n      } catch (c) {\n        c instanceof Error && (this.errorsAsWarnings ? this.appendWarning(c.message) : this.appendError(c.message));\n      }\n      return yield this.disconnect(), yield new Promise((c) => setTimeout(c, 500)), this.status !== CheckStatus.SKIPPED && this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED), u && u(), this.getInfo();\n    });\n  }\n  isSuccess() {\n    return !this.logs.some((u) => u.level === \"error\");\n  }\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.room.state === ConnectionState.Connected ? this.room : (yield this.room.connect(this.url, this.token), this.room);\n    });\n  }\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.room && this.room.state !== ConnectionState.Disconnected && (yield this.room.disconnect(), yield new Promise((u) => setTimeout(u, 500)));\n    });\n  }\n  skip() {\n    this.setStatus(CheckStatus.SKIPPED);\n  }\n  appendMessage(u) {\n    this.logs.push({\n      level: \"info\",\n      message: u\n    }), this.emit(\"update\", this.getInfo());\n  }\n  appendWarning(u) {\n    this.logs.push({\n      level: \"warning\",\n      message: u\n    }), this.emit(\"update\", this.getInfo());\n  }\n  appendError(u) {\n    this.logs.push({\n      level: \"error\",\n      message: u\n    }), this.emit(\"update\", this.getInfo());\n  }\n  setStatus(u) {\n    this.status = u, this.emit(\"update\", this.getInfo());\n  }\n  get engine() {\n    var u;\n    return (u = this.room) === null || u === void 0 ? void 0 : u.engine;\n  }\n  getInfo() {\n    return {\n      logs: this.logs,\n      name: this.name,\n      status: this.status,\n      description: this.description\n    };\n  }\n}\nfunction createLocalTracks(a) {\n  var u, c;\n  return __awaiter(this, void 0, void 0, function* () {\n    a ?? (a = {}), (u = a.audio) !== null && u !== void 0 || (a.audio = !0), (c = a.video) !== null && c !== void 0 || (a.video = !0);\n    const l = mergeDefaultOptions(a, audioDefaults, videoDefaults), v = constraintsForOptions(l), S = navigator.mediaDevices.getUserMedia(v);\n    a.audio && (DeviceManager.userMediaPromiseMap.set(\"audioinput\", S), S.catch(() => DeviceManager.userMediaPromiseMap.delete(\"audioinput\"))), a.video && (DeviceManager.userMediaPromiseMap.set(\"videoinput\", S), S.catch(() => DeviceManager.userMediaPromiseMap.delete(\"videoinput\")));\n    const g = yield S;\n    return g.getTracks().map((E) => {\n      const _ = E.kind === \"audio\";\n      _ ? a.audio : a.video;\n      let k;\n      const L = _ ? v.audio : v.video;\n      typeof L != \"boolean\" && (k = L), k ? k.deviceId = E.getSettings().deviceId : k = {\n        deviceId: E.getSettings().deviceId\n      };\n      const M = mediaTrackToLocalTrack(E, k);\n      return M.kind === Track.Kind.Video ? M.source = Track.Source.Camera : M.kind === Track.Kind.Audio && (M.source = Track.Source.Microphone), M.mediaStream = g, M;\n    });\n  });\n}\nfunction createLocalVideoTrack(a) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return (yield createLocalTracks({\n      audio: !1,\n      video: a\n    }))[0];\n  });\n}\nfunction createLocalAudioTrack(a) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return (yield createLocalTracks({\n      audio: a,\n      video: !1\n    }))[0];\n  });\n}\nclass PublishAudioCheck extends Checker {\n  get description() {\n    return \"Can publish audio\";\n  }\n  perform() {\n    var u;\n    return __awaiter(this, void 0, void 0, function* () {\n      const c = yield this.connect(), l = yield createLocalAudioTrack();\n      c.localParticipant.publishTrack(l), yield new Promise((g) => setTimeout(g, 3e3));\n      const v = yield (u = l.sender) === null || u === void 0 ? void 0 : u.getStats();\n      if (!v)\n        throw new Error(\"Could not get RTCStats\");\n      let S = 0;\n      if (v.forEach((g) => {\n        g.type === \"outbound-rtp\" && g.mediaType === \"audio\" && (S = g.packetsSent);\n      }), S === 0)\n        throw new Error(\"Could not determine packets are sent\");\n      this.appendMessage(\"published \".concat(S, \" audio packets\"));\n    });\n  }\n}\nclass PublishVideoCheck extends Checker {\n  get description() {\n    return \"Can publish video\";\n  }\n  perform() {\n    var u;\n    return __awaiter(this, void 0, void 0, function* () {\n      const c = yield this.connect(), l = yield createLocalVideoTrack();\n      c.localParticipant.publishTrack(l), yield new Promise((g) => setTimeout(g, 3e3));\n      const v = yield (u = l.sender) === null || u === void 0 ? void 0 : u.getStats();\n      if (!v)\n        throw new Error(\"Could not get RTCStats\");\n      let S = 0;\n      if (v.forEach((g) => {\n        g.type === \"outbound-rtp\" && g.mediaType === \"video\" && (S = g.packetsSent);\n      }), S === 0)\n        throw new Error(\"Could not determine packets are sent\");\n      this.appendMessage(\"published \".concat(S, \" video packets\"));\n    });\n  }\n}\nclass ReconnectCheck extends Checker {\n  get description() {\n    return \"Resuming connection after interruption\";\n  }\n  perform() {\n    var u;\n    return __awaiter(this, void 0, void 0, function* () {\n      const c = yield this.connect();\n      let l = !1, v = !1, S;\n      const g = new Promise((_) => {\n        setTimeout(_, 5e3), S = _;\n      });\n      c.on(RoomEvent.Reconnecting, () => {\n        l = !0;\n      }).on(RoomEvent.Reconnected, () => {\n        v = !0, S(!0);\n      }), (u = c.engine.client.ws) === null || u === void 0 || u.close();\n      const E = c.engine.client.onClose;\n      if (E && E(\"\"), yield g, l) {\n        if (!v || c.state !== ConnectionState.Connected)\n          throw this.appendWarning(\"reconnection is only possible in Redis-based configurations\"), new Error(\"Not able to reconnect\");\n      } else\n        throw new Error(\"Did not attempt to reconnect\");\n    });\n  }\n}\nclass TURNCheck extends Checker {\n  get description() {\n    return \"Can connect via TURN\";\n  }\n  perform() {\n    var u, c;\n    return __awaiter(this, void 0, void 0, function* () {\n      const l = new SignalClient(), v = yield l.join(this.url, this.token, {\n        autoSubscribe: !0,\n        maxRetries: 0,\n        e2eeEnabled: !1,\n        websocketTimeout: 15e3\n      });\n      let S = !1, g = !1, E = !1;\n      for (let _ of v.iceServers)\n        for (let k of _.urls)\n          k.startsWith(\"turn:\") ? (g = !0, E = !0) : k.startsWith(\"turns:\") && (g = !0, E = !0, S = !0), k.startsWith(\"stun:\") && (E = !0);\n      E ? g && !S && this.appendWarning(\"TURN is configured server side, but TURN/TLS is unavailable.\") : this.appendWarning(\"No STUN servers configured on server side.\"), yield l.close(), !((c = (u = this.connectOptions) === null || u === void 0 ? void 0 : u.rtcConfig) === null || c === void 0) && c.iceServers || g ? yield this.room.connect(this.url, this.token, {\n        rtcConfig: {\n          iceTransportPolicy: \"relay\"\n        }\n      }) : (this.appendWarning(\"No TURN servers configured.\"), this.skip(), yield new Promise((_) => setTimeout(_, 0)));\n    });\n  }\n}\nclass WebRTCCheck extends Checker {\n  get description() {\n    return \"Establishing WebRTC connection\";\n  }\n  perform() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let u = !1, c = !1;\n      this.room.on(RoomEvent.SignalConnected, () => {\n        const l = this.room.engine.client.onTrickle;\n        this.room.engine.client.onTrickle = (v, S) => {\n          if (v.candidate) {\n            const g = new RTCIceCandidate(v);\n            let E = \"\".concat(g.protocol, \" \").concat(g.address, \":\").concat(g.port, \" \").concat(g.type);\n            g.address && (isIPPrivate(g.address) ? E += \" (private)\" : g.protocol === \"tcp\" && g.tcpType === \"passive\" ? (u = !0, E += \" (passive)\") : g.protocol === \"udp\" && (c = !0)), this.appendMessage(E);\n          }\n          l && l(v, S);\n        }, this.room.engine.pcManager && (this.room.engine.pcManager.subscriber.onIceCandidateError = (v) => {\n          v instanceof RTCPeerConnectionIceErrorEvent && this.appendWarning(\"error with ICE candidate: \".concat(v.errorCode, \" \").concat(v.errorText, \" \").concat(v.url));\n        });\n      });\n      try {\n        yield this.connect(), livekitLogger.info(\"now the room is connected\");\n      } catch (l) {\n        throw this.appendWarning(\"ports need to be open on firewall in order to connect.\"), l;\n      }\n      u || this.appendWarning(\"Server is not configured for ICE/TCP\"), c || this.appendWarning(\"No public IPv4 UDP candidates were found. Your server is likely not configured correctly\");\n    });\n  }\n}\nfunction isIPPrivate(a) {\n  const u = a.split(\".\");\n  if (u.length === 4) {\n    if (u[0] === \"10\")\n      return !0;\n    if (u[0] === \"192\" && u[1] === \"168\")\n      return !0;\n    if (u[0] === \"172\") {\n      const c = parseInt(u[1], 10);\n      if (c >= 16 && c <= 31)\n        return !0;\n    }\n  }\n  return !1;\n}\nclass WebSocketCheck extends Checker {\n  get description() {\n    return \"Connecting to signal connection via WebSocket\";\n  }\n  perform() {\n    var u, c, l;\n    return __awaiter(this, void 0, void 0, function* () {\n      (this.url.startsWith(\"ws:\") || this.url.startsWith(\"http:\")) && this.appendWarning(\"Server is insecure, clients may block connections to it\");\n      let v = new SignalClient();\n      const S = yield v.join(this.url, this.token, {\n        autoSubscribe: !0,\n        maxRetries: 0,\n        e2eeEnabled: !1,\n        websocketTimeout: 15e3\n      });\n      this.appendMessage(\"Connected to server, version \".concat(S.serverVersion, \".\")), ((u = S.serverInfo) === null || u === void 0 ? void 0 : u.edition) === ServerInfo_Edition.Cloud && (!((c = S.serverInfo) === null || c === void 0) && c.region) && this.appendMessage(\"LiveKit Cloud: \".concat((l = S.serverInfo) === null || l === void 0 ? void 0 : l.region)), yield v.close();\n    });\n  }\n}\nclass ConnectionCheck extends eventsExports.EventEmitter {\n  constructor(u, c) {\n    super(), this.checkResults = /* @__PURE__ */ new Map(), this.url = u, this.token = c;\n  }\n  getNextCheckId() {\n    const u = this.checkResults.size;\n    return this.checkResults.set(u, {\n      logs: [],\n      status: CheckStatus.IDLE,\n      name: \"\",\n      description: \"\"\n    }), u;\n  }\n  updateCheck(u, c) {\n    this.checkResults.set(u, c), this.emit(\"checkUpdate\", u, c);\n  }\n  isSuccess() {\n    return Array.from(this.checkResults.values()).every((u) => u.status !== CheckStatus.FAILED);\n  }\n  getResults() {\n    return Array.from(this.checkResults.values());\n  }\n  createAndRunCheck(u) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const c = this.getNextCheckId(), l = new u(this.url, this.token), v = (g) => {\n        this.updateCheck(c, g);\n      };\n      l.on(\"update\", v);\n      const S = yield l.run();\n      return l.off(\"update\", v), S;\n    });\n  }\n  checkWebsocket() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(WebSocketCheck);\n    });\n  }\n  checkWebRTC() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(WebRTCCheck);\n    });\n  }\n  checkTURN() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(TURNCheck);\n    });\n  }\n  checkReconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(ReconnectCheck);\n    });\n  }\n  checkPublishAudio() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(PublishAudioCheck);\n    });\n  }\n  checkPublishVideo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createAndRunCheck(PublishVideoCheck);\n    });\n  }\n}\nconst Rendering = lib$2.LiveApiModel.Rendering, VideoRendering = lib$2.LiveApiModel.VideoRendering, AudioRendering = lib$2.LiveApiModel.AudioRendering, RenderingQuality = lib$2.LiveApiModel.RenderingQuality, Encoding = lib$2.LiveApiModel.Encoding, VideoEncoding = lib$2.LiveApiModel.VideoEncoding, AudioEncoding = lib$2.LiveApiModel.AudioEncoding, ProjectBroadcastPhase = lib$2.LiveApiModel.ProjectBroadcastPhase, Role = lib$2.LiveApiModel.Role, DestinationAddress = lib$2.LiveApiModel.DestinationAddress, VideoCodec = lib$2.LiveApiModel.VideoCodec, AudioCodec = lib$2.LiveApiModel.AudioCodec, VideoCodecRateControl = lib$2.LiveApiModel.VideoCodecRateControl, VideoCodecProfile = lib$2.LiveApiModel.VideoCodecProfile, types$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  AudioCodec,\n  AudioEncoding,\n  AudioRendering,\n  DestinationAddress,\n  Encoding,\n  ProjectBroadcastPhase,\n  Rendering,\n  RenderingQuality,\n  Role,\n  VideoCodec,\n  VideoCodecProfile,\n  VideoCodecRateControl,\n  VideoEncoding,\n  VideoRendering\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar Permission = /* @__PURE__ */ ((a) => (a[a.ReadProject = 0] = \"ReadProject\", a[a.UpdateProject = 1] = \"UpdateProject\", a[a.JoinRoom = 2] = \"JoinRoom\", a[a.InviteGuests = 3] = \"InviteGuests\", a[a.ManageGuests = 4] = \"ManageGuests\", a[a.ManageBroadcast = 5] = \"ManageBroadcast\", a[a.ManageSelf = 6] = \"ManageSelf\", a))(Permission || {});\nconst permissions = {\n  [Role.ROLE_HOST]: [\n    0,\n    1,\n    2,\n    3,\n    4,\n    5\n    /* ManageBroadcast */\n  ],\n  [Role.ROLE_COHOST]: [\n    0,\n    1,\n    2,\n    3,\n    4,\n    5\n    /* ManageBroadcast */\n  ],\n  [Role.ROLE_CONTRIBUTOR]: [\n    0,\n    1,\n    2,\n    3\n    /* InviteGuests */\n  ],\n  [Role.ROLE_GUEST]: [\n    0,\n    2,\n    6\n    /* ManageSelf */\n  ],\n  [Role.ROLE_VIEWER]: [\n    0,\n    2\n    /* JoinRoom */\n  ],\n  [Role.ROLE_IMPERSONATE]: [\n    0,\n    1,\n    3,\n    4,\n    5\n    /* ManageBroadcast */\n  ]\n}, hasPermission = (a, u) => {\n  var c;\n  return a ? !!((c = permissions[a]) != null && c.find((l) => l === u)) : !1;\n};\nvar DataType = /* @__PURE__ */ ((a) => (a.ChatMessage = \"ChatMessage\", a.ParticipantMetadataUpdate = \"ParticipantMetadataUpdate\", a))(DataType || {}), SpecialEvent = /* @__PURE__ */ ((a) => (a.Chat = \"Chat\", a))(SpecialEvent || {});\nconst decoder$1 = new TextDecoder(), encoder$1 = new TextEncoder();\nclass RoomsManager {\n  constructor() {\n    ht(this, \"rooms\");\n    this.rooms = /* @__PURE__ */ new Map(), this.addRoom = this.addRoom.bind(this), this.ensureRoom = this.ensureRoom.bind(this), this.removeRoom = this.removeRoom.bind(this);\n  }\n  addRoom(u, c, l) {\n    const v = new RoomContext(u, c, l, this);\n    return this.rooms.set(c, v), v;\n  }\n  ensureRoom(u, c, l) {\n    return this.rooms.get(c) ? (this.rooms.get(c).token = l, this.rooms.get(c)) : this.addRoom(u, c, l);\n  }\n  async removeRoom(u) {\n    const c = this.rooms.get(u);\n    if (!Room)\n      throw new Error(\"room not found!\");\n    if (c.isConnecting)\n      throw new Error(\"Cannot remove room: Room is in connecting state\");\n    c.livekitRoom && await c.livekitRoom.disconnect(!0), this.rooms.delete(u);\n  }\n}\nclass RoomContext {\n  /**\n   * @param baseUrl base url for the webrtc server\n   * @param token get\n   */\n  constructor(u, c, l, v) {\n    /**\n     * base URL for the webrtc server\n     */\n    ht(this, \"_baseUrl\");\n    ht(this, \"_chatHistory\");\n    /**\n     * event listeners just for livekit room connect\n     */\n    ht(this, \"_connectListeners\");\n    /**\n     * Event listeners that are registered OR to be registered upon connection\n     * Keys are of type RoomEvent\n     */\n    ht(this, \"_roomEventListenerRegistry\");\n    /**\n     * Event listeners that are registered OR to be registered on the localParticipant upon connection\n     * Keys are of type ParticipantEvent\n     */\n    ht(this, \"_localParticipantEventListenerRegistry\");\n    /**\n     * Registry for special/custom events such as chat events\n     */\n    ht(this, \"_specialEventListenerRegistry\");\n    /**\n     * access token for our connection\n     * Should be acquired from vapi\n     */\n    ht(this, \"_jwt\");\n    /**\n     * reference to the rooms manager that contains it\n     */\n    ht(this, \"_manager\");\n    ht(this, \"_apiClient\");\n    ht(this, \"audioTracks\");\n    ht(this, \"isConnecting\");\n    ht(this, \"livekitRoom\");\n    ht(this, \"participants\");\n    ht(this, \"guestParticipantMetadata\");\n    ht(this, \"roomName\");\n    /**\n     * Livekit Room Service client, for performing admin functions\n     * Should only be defined if user is room admin\n     */\n    ht(this, \"_admin\");\n    let S = CoreContext.logLevel.toLowerCase();\n    setLogLevel(S), this.livekitRoom = new Room({\n      // automatically manage subscribed video quality\n      // adaptiveStream: true,\n      // optimize publishing bandwidth and CPU for published tracks\n      dynacast: !0,\n      // default capture settings\n      videoCaptureDefaults: {\n        resolution: VideoPresets.h720.resolution\n      }\n    }), this._baseUrl = u, this._connectListeners = [], this._roomEventListenerRegistry = {}, this._jwt = l, Object.values(RoomEvent).forEach((g) => {\n      this._roomEventListenerRegistry[g] = /* @__PURE__ */ new Set();\n    }), this._localParticipantEventListenerRegistry = {}, Object.values(ParticipantEvent).forEach((g) => {\n      this._localParticipantEventListenerRegistry[g] = /* @__PURE__ */ new Set();\n    }), this._specialEventListenerRegistry = {}, this._manager = v, this._chatHistory = [], this.roomName = c, this.audioTracks = [], this.participants = [], this.guestParticipantMetadata = [], this.isConnecting = !1, this.subscribeToRoomEvent(RoomEvent.DataReceived, (g, E) => {\n      var L;\n      const _ = decoder$1.decode(g);\n      switch (JSON.parse(_).type) {\n        case \"ChatMessage\":\n          return this._appendChat(g, E);\n        case \"ParticipantMetadataUpdate\": {\n          const M = decoder$1.decode(g), $ = JSON.parse(M);\n          hasPermission((L = $ == null ? void 0 : $.metadata) == null ? void 0 : L.participantRole, Permission.ManageSelf) && this._updateGuestParticipantsStore($);\n          return;\n        }\n        default:\n          return;\n      }\n    }), this.connect = this.connect.bind(this), this.subscribeToRoomEvent = this.subscribeToRoomEvent.bind(this), this.subscribeToConnect = this.subscribeToConnect.bind(this), this.subscribeToLocalParticipantEvent = this.subscribeToLocalParticipantEvent.bind(this), this.subscribeToSpecialEvent = this.subscribeToSpecialEvent.bind(this), this.unsubscribeFromRoomEvent = this.unsubscribeFromRoomEvent.bind(this), this.unsubscribeFromSpecialEvent = this.unsubscribeFromSpecialEvent.bind(this), this.unsubscribeFromConnect = this.unsubscribeFromConnect.bind(this), this.unsubscribeFromLocalParticipantEvent = this.unsubscribeFromLocalParticipantEvent.bind(this), this.sendChatMessage = this.sendChatMessage.bind(this), this.kickParticipant = this.kickParticipant.bind(this), this.updateParticipant = this.updateParticipant.bind(this), this.muteTrackAsAdmin = this.muteTrackAsAdmin.bind(this), this._updateParticipants = this._updateParticipants.bind(this), this.subscribeToRoomEvent(RoomEvent.ParticipantConnected, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.ParticipantDisconnected, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.TrackSubscribed, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.TrackUnsubscribed, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.LocalTrackPublished, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.LocalTrackUnpublished, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.Disconnected, () => {\n      this._updateParticipants();\n    }), this.subscribeToRoomEvent(RoomEvent.ParticipantMetadataChanged, (g, E) => {\n      if (g !== (E == null ? void 0 : E.metadata)) {\n        const _ = JSON.parse(E == null ? void 0 : E.metadata);\n        if (hasPermission(_ == null ? void 0 : _.participantRole, Permission.ManageSelf)) {\n          if (_.hasOwnProperty(\"isMirrored\")) {\n            const k = {\n              participantId: E == null ? void 0 : E.identity,\n              metadata: _,\n              type: \"ParticipantMetadataUpdate\"\n              /* ParticipantMetadataUpdate */\n            };\n            this._updateGuestParticipantsStore(k);\n          }\n          return;\n        }\n      }\n    });\n  }\n  bindApiClient(u) {\n    this._apiClient = u;\n  }\n  get isAdmin() {\n    return jwtDecode(this._jwt).video.roomAdmin;\n  }\n  set isAdmin(u) {\n    log$1.warn(\"isAdmin cannot be set\");\n  }\n  get token() {\n    return this._jwt;\n  }\n  set token(u) {\n    this._jwt = u;\n  }\n  get url() {\n    return this._baseUrl;\n  }\n  set url(u) {\n  }\n  get chatHistory() {\n    return this._chatHistory;\n  }\n  set chatHistory(u) {\n    this._chatHistory = u;\n  }\n  _updateGuestParticipantsStore(u) {\n    if (!this.guestParticipantMetadata.length)\n      this.guestParticipantMetadata.push(u);\n    else {\n      const c = this.guestParticipantMetadata.findIndex((l) => l.participantId === (u == null ? void 0 : u.participantId));\n      c > -1 ? this.guestParticipantMetadata[c] = u : this.guestParticipantMetadata.push(u);\n    }\n  }\n  _updateParticipants() {\n    if (!this.livekitRoom || this.livekitRoom.state === ConnectionState.Disconnected) {\n      this.participants = [];\n      return;\n    } else {\n      const u = Array.from(this.livekitRoom.remoteParticipants.values()), c = [this.livekitRoom.localParticipant];\n      c.push(...u), this.guestParticipantMetadata = this.guestParticipantMetadata.filter((l) => c.find((v) => (v == null ? void 0 : v.identity) === (l == null ? void 0 : l.participantId))), this.participants = c;\n    }\n  }\n  /**\n   * @param identity Identity of the user that you wish to kick\n   */\n  async kickParticipant(u) {\n    if (this._admin)\n      this._admin.removeParticipant(this.roomName, u);\n    else\n      throw new Error(\"no admin permissions\");\n  }\n  updateParticipant(u, c) {\n    if (this._admin) {\n      const l = JSON.stringify(c);\n      this._admin.updateParticipant(this.roomName, u, l);\n    } else\n      throw new Error(\"no admin permissions\");\n  }\n  muteTrackAsAdmin(u, c = !0) {\n    if (this._admin) {\n      const l = this.participants.find((v) => [...v.audioTrackPublications.values(), ...v.videoTrackPublications.values()].find((S) => S.trackSid === u));\n      if (!l) {\n        log$1.warn(\"Could not find participant for track:\", {\n          trackSid: u\n        });\n        return;\n      }\n      this._admin.mutePublishedTrack(this.roomName, l == null ? void 0 : l.identity, u, c);\n    } else\n      throw new Error(\"no admin permissions\");\n  }\n  _appendChat(u, c) {\n    const l = decoder$1.decode(u), v = JSON.parse(l), S = c.identity, g = c.name, E = {\n      ...v,\n      displayName: g,\n      sender: S\n    };\n    this.chatHistory = [...this.chatHistory, E], this._triggerSpecialEvents(\"Chat\", E);\n  }\n  subscribeToConnect(u) {\n    return this._connectListeners.push(u), () => this.unsubscribeFromConnect(u);\n  }\n  unsubscribeFromConnect(u) {\n    this._connectListeners = this._connectListeners.filter((c) => c !== u);\n  }\n  subscribeToSpecialEvent(u, c) {\n    return this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].add(c), () => {\n      this.unsubscribeFromSpecialEvent(u, c);\n    };\n  }\n  unsubscribeFromSpecialEvent(u, c) {\n    this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].delete(c);\n  }\n  _triggerSpecialEvents(u, ...c) {\n    this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].forEach((l) => {\n      l(...c);\n    });\n  }\n  /**\n   * connect to livekit webrtc room\n   * @param {string} identity unique user name to be displayed to other users\n   */\n  async connect(u = {}) {\n    var c, l;\n    try {\n      if (this.livekitRoom.state === \"connected\" || this.isConnecting)\n        return;\n      this.isConnecting = !0, await this.livekitRoom.connect(`wss://${this._baseUrl}`, this._jwt, {\n        ...u\n      }), this.isConnecting = !1, Object.values(RoomEvent).forEach((v) => {\n        this.livekitRoom.on(v, (...S) => {\n          this._roomEventListenerRegistry[v].forEach((g) => {\n            g(...S);\n          });\n        });\n      }), Object.values(ParticipantEvent).forEach((v) => {\n        this.livekitRoom.localParticipant.on(v, (...S) => {\n          this._localParticipantEventListenerRegistry[v].forEach((g) => {\n            g(...S);\n          });\n        });\n      }), this._updateParticipants(), this._connectListeners.forEach((v) => v(this.livekitRoom)), lib$2.LiveKitUtils.isRoomAdmin(this._jwt) ? (log$1.info(\"Room: Granting admin permissions\"), log$1.debug(\"Livekit server: \", (c = this._apiClient) == null ? void 0 : c.getLiveKitServer(!0)), this._admin = new dist.RoomServiceClient((l = this._apiClient) == null ? void 0 : l.getLiveKitServer(!0), void 0, void 0, this._jwt)) : log$1.debug(\"Room: Not an admin\");\n    } catch (v) {\n      this.isConnecting = !1, log$1.error(v);\n    }\n  }\n  subscribeToLocalParticipantEvent(u, c) {\n    return this._localParticipantEventListenerRegistry[u] || (this._localParticipantEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._localParticipantEventListenerRegistry[u].add(c), () => {\n      this.unsubscribeFromLocalParticipantEvent(u, c);\n    };\n  }\n  unsubscribeFromLocalParticipantEvent(u, c) {\n    this._localParticipantEventListenerRegistry[u] || (this._localParticipantEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._localParticipantEventListenerRegistry[u].delete(c);\n  }\n  subscribeToRoomEvent(u, c) {\n    return this._roomEventListenerRegistry[u] || (this._roomEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._roomEventListenerRegistry[u].add(c), () => {\n      this.unsubscribeFromRoomEvent(u, c);\n    };\n  }\n  unsubscribeFromRoomEvent(u, c) {\n    this._roomEventListenerRegistry[u] || (this._roomEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._roomEventListenerRegistry[u].delete(c);\n  }\n  /**\n   * Sends chat message to entire livekit room, or a private message (if specified) from local participant\n   * @param {string[]} [recipients] The identities of the recipient participants. If undefined, will send message to all participants in the chat.\n   * Only specify for private messages.\n   * Do not include the local participant's identity in this.\n   */\n  sendChatMessage(u) {\n    const {\n      message: c,\n      recipients: l,\n      metadata: v\n    } = u;\n    if (!this.livekitRoom || this.livekitRoom.state !== \"connected\")\n      return;\n    const S = {\n      type: \"ChatMessage\",\n      recipients: l,\n      metadata: v,\n      content: c,\n      timestamp: Date.now()\n    }, g = JSON.stringify(S), E = encoder$1.encode(g);\n    if ({\n      ...S,\n      sender: this.livekitRoom.localParticipant.identity,\n      displayName: this.livekitRoom.localParticipant.identity\n    }, l) {\n      const _ = l.map(this.livekitRoom.getParticipantByIdentity);\n      return this.livekitRoom.localParticipant.publishData(E, {\n        reliable: !0,\n        destinationIdentities: _.map((k) => k.identity)\n      }).then(() => {\n        this._appendChat(E, this.livekitRoom.localParticipant);\n      });\n    } else\n      return this.livekitRoom.localParticipant.publishData(E, {\n        reliable: !0\n      }).then(() => {\n        this._appendChat(E, this.livekitRoom.localParticipant);\n      });\n  }\n}\nconst webrtcManager = new RoomsManager(), index$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  webrtcManager\n}, Symbol.toStringTag, { value: \"Module\" })), encoder = new TextEncoder(), decoder = new TextDecoder(), simpleRooms = /* @__PURE__ */ new Map(), getRoom = (a) => {\n  if (!a)\n    return null;\n  if (simpleRooms.get(a))\n    return simpleRooms.get(a);\n  const u = webrtcManager.rooms.get(a);\n  if (!u)\n    return null;\n  const c = u.livekitRoom, l = c == null ? void 0 : c.localParticipant;\n  window.__StudioRoom = c, l || log$1.warn(\"No local participant!\");\n  const v = {\n    useTracks: /* @__PURE__ */ new Set(),\n    useTrack: /* @__PURE__ */ new Map(),\n    useParticipants: /* @__PURE__ */ new Set(),\n    useParticipant: /* @__PURE__ */ new Map(),\n    useChatHistory: /* @__PURE__ */ new Set()\n  };\n  let S = {\n    tracks: [],\n    participants: [],\n    result: {\n      participants: [],\n      tracks: []\n    },\n    chat: u.chatHistory\n  };\n  const g = () => {\n    const q = u.participants, G = u.guestParticipantMetadata, H = q.flatMap((Y) => Y.getTrackPublications().map((ne) => ({\n      ...ne,\n      participant: Y\n    }))), B = {\n      participants: q.map((Y) => {\n        const ne = G.find((re) => re.participantId === Y.identity);\n        if (ne) {\n          let re = JSON.parse(Y.metadata);\n          re = {\n            ...re,\n            ...ne.metadata\n          }, Y.metadata = JSON.stringify(re);\n        }\n        const Z = JSON.parse(Y.metadata);\n        return {\n          id: Y.identity,\n          isSelf: Y === l,\n          connectionQuality: Y.connectionQuality,\n          displayName: Z.displayName || Y.name,\n          joinedAt: Y.joinedAt,\n          role: Z.participantRole,\n          meta: Z,\n          trackIds: H.filter((re) => re.participant.sid === Y.sid).map((re) => re.trackSid)\n        };\n      }),\n      tracks: H.map((Y) => {\n        var Z, re, oe, de;\n        const ne = JSON.parse((Z = Y == null ? void 0 : Y.participant) == null ? void 0 : Z.metadata);\n        return {\n          mediaStreamTrack: (re = Y.track) == null ? void 0 : re.mediaStreamTrack,\n          id: Y.trackSid,\n          participantId: (oe = Y.participant) == null ? void 0 : oe.identity,\n          isMuted: (de = Y.track) == null ? void 0 : de.isMuted,\n          type: Y.source,\n          isExternal: !!(ne != null && ne[Y.trackSid])\n        };\n      })\n    };\n    S = {\n      tracks: H,\n      participants: q,\n      result: B,\n      chat: u.chatHistory\n    }, v.useTracks.forEach((Y) => Y(B.tracks)), v.useTrack.forEach((Y, ne) => {\n      ne(k(Y));\n    }), v.useParticipants.forEach((Y) => Y(B.participants)), v.useParticipant.forEach((Y, ne) => {\n      ne(L(Y));\n    }), v.useChatHistory.forEach((Y) => {\n      Y(S.chat);\n    });\n  }, E = [RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ParticipantMetadataChanged, RoomEvent.Disconnected, RoomEvent.TrackSubscribed, RoomEvent.TrackUnsubscribed, RoomEvent.LocalTrackPublished, RoomEvent.LocalTrackUnpublished, RoomEvent.ConnectionQualityChanged, RoomEvent.TrackMuted, RoomEvent.TrackUnmuted, RoomEvent.TrackStreamStateChanged];\n  u.subscribeToRoomEvent(RoomEvent.DataReceived, (q, G, H) => {\n    const B = decoder.decode(q);\n    JSON.parse(B).type === DataType.ParticipantMetadataUpdate && g();\n  }), E.map((q) => u.subscribeToRoomEvent(q, () => g())).push(u.subscribeToSpecialEvent(SpecialEvent.Chat, g));\n  const k = (q) => S.result.tracks.find((G) => G.id === q), L = (q) => S.result.participants.find((G) => G.id === q), M = (q, G) => {\n    const H = l.getTrackPublications().find((B) => B.trackSid === q);\n    H && (G ? H.mute() : H.unmute());\n  };\n  let $, J;\n  const V = {\n    id: u.roomName,\n    participantId: l.identity,\n    setTrackEnabled: M,\n    setCameraEnabled: (q = !0) => l.setCameraEnabled(q),\n    setMicrophoneEnabled: (q = !0) => l.setMicrophoneEnabled(q),\n    setCamera: async (q = {}) => {\n      var H;\n      if ($) {\n        log$1.warn(\"Cannot set camera until previous has resolved\");\n        return;\n      }\n      $ = !0;\n      let G;\n      try {\n        const Y = l.getTrackPublications().filter((Z) => (Z == null ? void 0 : Z.source) === Track.Source.Camera).find((Z) => !k(Z == null ? void 0 : Z.trackSid).isExternal), ne = await l.createTracks({\n          video: {\n            deviceId: q.deviceId,\n            resolution: q.resolution || {\n              width: 1280,\n              height: 720,\n              frameRate: 30,\n              aspectRatio: 16 / 9\n            }\n          }\n        });\n        Y != null && Y.isMuted && ne.forEach((Z) => {\n          Z.mute();\n        }), G = await Promise.all(ne.map((Z) => l.publishTrack(Z))), Y && l.unpublishTrack(Y.track);\n      } catch (B) {\n        throw B;\n      } finally {\n        return $ = !1, k((H = G[0]) == null ? void 0 : H.trackSid);\n      }\n    },\n    setMicrophone: async (q) => {\n      var H;\n      if (J) {\n        log$1.warn(\"Cannot set microphone until previous has resolved\");\n        return;\n      }\n      J = !0;\n      let G;\n      try {\n        const Y = l.getTrackPublications().filter((Z) => Z.source === Track.Source.Microphone).find((Z) => !k(Z == null ? void 0 : Z.trackSid).isExternal), ne = await l.createTracks({\n          audio: q || !0\n        });\n        Y != null && Y.isMuted && ne.forEach((Z) => {\n          Z.mute();\n        }), G = await Promise.all(ne.map((Z) => l.publishTrack(Z))), Y && l.unpublishTrack(Y.track);\n      } catch (B) {\n        throw B;\n      } finally {\n        return J = !1, k((H = G[0]) == null ? void 0 : H.trackSid);\n      }\n    },\n    addMicrophone: async (q) => {\n      var ne;\n      if (J) {\n        log$1.warn(\"Cannot set microphone until previous has resolved\");\n        return;\n      }\n      J = !0;\n      const G = await l.createTracks({\n        audio: q || !0\n      }), B = l.getTrackPublications().filter((Z) => Z.source === Track.Source.Microphone).find((Z) => {\n        var oe, de;\n        const re = k(Z == null ? void 0 : Z.trackSid);\n        ((de = (oe = re == null ? void 0 : re.mediaStreamTrack) == null ? void 0 : oe.getSettings()) == null ? void 0 : de.deviceId) === q.deviceId && (re == null || re.isExternal);\n      });\n      B != null && B.isMuted && G.forEach((Z) => {\n        Z.mute();\n      });\n      const Y = await Promise.all(G.map((Z) => l.publishTrack(Z)));\n      return B && l.unpublishTrack(B.track), J = !1, k((ne = Y[0]) == null ? void 0 : ne.trackSid);\n    },\n    addCamera: async (q = {}) => {\n      var Y;\n      const G = await l.createTracks({\n        video: {\n          deviceId: q.deviceId,\n          resolution: q.resolution || {\n            width: 1280,\n            height: 720,\n            frameRate: 30,\n            aspectRatio: 1.7777777777777777\n          }\n        }\n      }), H = l.getTrackPublications().find((ne) => {\n        var Z, re, oe;\n        return (ne == null ? void 0 : ne.source) === Track.Source.Camera && ((oe = (re = (Z = ne == null ? void 0 : ne.track) == null ? void 0 : Z.mediaStreamTrack) == null ? void 0 : re.getSettings()) == null ? void 0 : oe.deviceId) === q.deviceId;\n      });\n      H != null && H.isMuted && G.forEach((ne) => {\n        ne.mute();\n      });\n      const B = await Promise.all(G.map((ne) => l.publishTrack(ne)));\n      return H && l.unpublishTrack(H.track), J = !1, k((Y = B[0]) == null ? void 0 : Y.trackSid);\n    },\n    addScreen: async (q = {\n      audio: !1\n    }) => {\n      const G = await l.createScreenTracks(q), H = await Promise.all(G.map((ne) => l.publishTrack(ne))), B = H.find((ne) => ne.kind === \"video\"), Y = H.find((ne) => ne.kind === \"audio\");\n      return {\n        screen: k(B == null ? void 0 : B.trackSid),\n        audio: k(Y == null ? void 0 : Y.trackSid)\n      };\n    },\n    removeTrack: async (q) => {\n      const G = S.tracks.find((H) => H.trackSid === q);\n      l.unpublishTrack(G.track);\n    },\n    /* Setting the local participant metadata. */\n    setLocalParticipantMetadata: async (q, G) => {\n      const H = JSON.stringify(G), B = encoder.encode(JSON.stringify({\n        metadata: G,\n        type: DataType.ParticipantMetadataUpdate,\n        participantId: q\n      }));\n      return l.setMetadata(H), await l.publishData(B, {\n        reliable: !0\n      });\n    },\n    setParticipantMetadata: (q, G) => u.updateParticipant(q, G),\n    kickParticipant: u.kickParticipant,\n    muteTrackAsAdmin: u.muteTrackAsAdmin,\n    sendChatMessage: u.sendChatMessage,\n    // Callbacks\n    getTracks: () => S.result.tracks,\n    useTracks: (q) => (v.useTracks.add(q), q(S.result.tracks), () => {\n      v.useTracks.delete(q);\n    }),\n    getTrack: k,\n    useTrack: (q, G) => (v.useTrack.set(G, q), G(k(q)), () => {\n      v.useTrack.delete(G);\n    }),\n    getParticipant: L,\n    getParticipants: () => S.result.participants,\n    useParticipants: (q) => (v.useParticipants.add(q), q(S.result.participants), () => {\n      v.useParticipants.delete(q);\n    }),\n    useParticipant: (q, G) => (v.useParticipant.set(G, q), G(L(q)), () => {\n      v.useTrack.delete(G);\n    }),\n    useChatHistory: (q) => (v.useChatHistory.add(q), q(S.chat), () => {\n      v.useChatHistory.delete(q);\n    }),\n    useActiveSpeakers: (q) => {\n      var H, B;\n      const G = (Y) => {\n        q(Y.map((ne) => ne.identity));\n      };\n      return (H = u.livekitRoom) == null || H.on(RoomEvent.ActiveSpeakersChanged, G), G((B = u.livekitRoom) == null ? void 0 : B.activeSpeakers), () => {\n        var Y;\n        (Y = u.livekitRoom) == null || Y.off(RoomEvent.ActiveSpeakersChanged, G);\n      };\n    },\n    sendData: (q, G = []) => {\n      const H = encoder.encode(JSON.stringify(q)), B = G == null ? void 0 : G.map((Y) => {\n        var ne;\n        return (ne = u.livekitRoom) == null ? void 0 : ne.getParticipantByIdentity(Y);\n      }).filter(Boolean);\n      return l.publishData(H, {\n        reliable: !0,\n        destinationIdentities: B.map((Y) => Y.identity)\n      });\n    },\n    onData: (q) => {\n      var H;\n      const G = (B, Y) => {\n        const ne = JSON.parse(decoder.decode(B));\n        q(ne, Y == null ? void 0 : Y.identity);\n      };\n      return (H = u.livekitRoom) == null || H.on(RoomEvent.DataReceived, G), () => {\n        var B;\n        (B = u.livekitRoom) == null || B.off(RoomEvent.DataReceived, G);\n      };\n    },\n    connect: () => u.connect(),\n    disconnect: () => {\n      var q;\n      return (q = u.livekitRoom) == null ? void 0 : q.disconnect();\n    },\n    onDisconnected: (q) => {\n      var G;\n      return (G = u.livekitRoom) == null || G.on(RoomEvent.Disconnected, q), () => {\n        var H;\n        (H = u.livekitRoom) == null || H.off(RoomEvent.DataReceived, q);\n      };\n    },\n    setAudioOutput: (q) => {\n      var G;\n      return (G = u.livekitRoom) == null ? void 0 : G.switchActiveDevice(\"audiooutput\", q);\n    }\n  };\n  return g(), simpleRooms.set(a, V), V;\n}, {\n  state: state$1\n} = CoreContext, getAccessTokenData = () => {\n  var a;\n  return ((a = CoreContext.clients.accessTokenClaims) == null ? void 0 : a.user) || {};\n}, getBaseUser = () => state$1.user ? {\n  id: state$1.user.id,\n  props: state$1.user.props,\n  name: state$1.user.name,\n  projects: state$1.projects.map(toBaseProject),\n  sources: state$1.sources.map(toBaseSource)\n} : null, toBaseProject = (a) => {\n  const {\n    compositor: u,\n    videoApi: c,\n    props: l = {},\n    role: v\n  } = a, {\n    destinations: S,\n    encoding: g,\n    rendering: E,\n    sources: _\n  } = c.project, k = {\n    get: u.get,\n    getRoot: u.getRoot,\n    getParent: u.getParent\n  };\n  Object.defineProperty(k, \"nodes\", {\n    get() {\n      return u.nodes.filter(($) => !$._deleted);\n    }\n  });\n  const L = a.videoApi.phase, M = a.videoApi.broadcastId || null;\n  return {\n    broadcastPhase: L,\n    role: v,\n    broadcastId: M,\n    isLive: [ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING, ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STOPPING].includes(L),\n    scene: k,\n    joinRoom: async ($ = {}) => CoreContext.Command.joinRoom({\n      projectId: a.id,\n      ...$\n    }),\n    subscribe: ($) => CoreContext.subscribe((J, V) => {\n      V.projectId && (V == null ? void 0 : V.projectId) === a.id && $(J, V);\n    }),\n    destinations: S.map(toBaseDestination),\n    sources: _.map(toBaseSource),\n    encoding: g,\n    rendering: E,\n    id: a.id,\n    hostDisplayName: a.props.hostDisplayName,\n    props: l\n  };\n}, toBaseDestination = (a) => {\n  var u;\n  return {\n    id: a.destinationId,\n    enabled: a.enabled,\n    address: a.address,\n    // For backward compatibility, fall back to \"metadata\" as props.\n    //  All new projects have a dedicated \"props\" field\n    props: ((u = a.metadata) == null ? void 0 : u.props) || (a == null ? void 0 : a.metadata) || {}\n  };\n}, toBaseSource = (a) => {\n  var u;\n  return {\n    id: a.sourceId,\n    address: a.address,\n    props: ((u = a.metadata) == null ? void 0 : u.props) || {}\n  };\n}, hydrateProject = async (a, u, c) => {\n  const l = a.metadata || {}, v = {\n    collectionId: a.collectionId,\n    projectId: a.projectId,\n    updateMask: []\n  };\n  hasPermission(u, Permission.ManageBroadcast) && a.composition.studioSdk.version !== CoreContext.rendererVersion && (v.composition = {\n    studioSdk: {\n      version: CoreContext.rendererVersion\n    }\n  }, v.updateMask.push(\"composition.studioSdk.version\")), c && (v.rendering = {\n    video: {\n      width: c.x,\n      height: c.y,\n      framerate: 30\n    }\n  }, v.updateMask.push(\"rendering\")), v.updateMask.length && await CoreContext.clients.LiveApi().project.updateProject(v);\n  const g = await layoutToProject(l.layoutId, c);\n  return {\n    id: a.projectId,\n    compositor: g,\n    role: u,\n    videoApi: {\n      project: a,\n      phase: ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_UNSPECIFIED\n    },\n    layoutApi: {\n      layoutId: l.layoutId\n    },\n    // For backward compatibility, fall back to \"metadata\" as props.\n    //  All new projects have a dedicated \"props\" field\n    props: (l == null ? void 0 : l.props) || l\n  };\n}, sceneNodeToLayer = (a) => {\n  const {\n    id: u,\n    props: c = {},\n    children: l = []\n  } = a;\n  return {\n    ...u ? {\n      id: u\n    } : {},\n    type: c.type,\n    data: {\n      ...c\n    },\n    children: l.map((v) => v.id)\n  };\n}, nodeToLayer = (a) => ({\n  id: a.id,\n  type: a.props.type,\n  data: {\n    ...a.props\n  },\n  children: a.childIds.map((u) => u)\n}), layerToNode = (a) => ({\n  id: String(a.id),\n  props: {\n    type: a.type,\n    ...a.data\n  },\n  childIds: a.children.map((u) => String(u))\n}), layoutToProject = async (a, u) => {\n  const {\n    layers: c\n  } = await CoreContext.clients.LayoutApi().layer.listLayers({\n    layoutId: a\n  });\n  if (u && c) {\n    const {\n      x: g,\n      y: E\n    } = u, _ = c == null ? void 0 : c.reduce((k, L) => k ? k.data.isRoot ? k : L.data.isRoot || !c.some((M) => M.children.includes(L.id)) ? L : k : L, null);\n    if (_) {\n      const k = await CoreContext.clients.LayoutApi().layer.updateLayer({\n        layoutId: _.layoutId,\n        layerId: _.id,\n        layer: {\n          x: g,\n          y: E,\n          data: {\n            ..._.data,\n            size: {\n              x: g,\n              y: E\n            }\n          }\n        }\n      }), L = c.findIndex((M) => M.id === k.id);\n      c[L] = k;\n    }\n  }\n  const l = c.map(layerToNode), v = l.reduce((g, E) => g ? g.props.isRoot ? g : E.props.isRoot || !l.some((_) => _.childIds.includes(E.id)) ? E : g : E, null), S = v ? toSceneTree(l, v.id) : null;\n  return CoreContext.compositor.loadProject(S, a);\n}, getUser = () => {\n  const a = state$1.user;\n  if (!a)\n    throw new Error(\"User not loaded\");\n  return a;\n}, getProject = (a) => state$1.projects.find((u) => u.id === a), getProjectByLayoutId = (a) => state$1.projects.find((u) => u.compositor.id === a), getProjectRoom = (a) => {\n  var u;\n  return getRoom((u = getProject(a)) == null ? void 0 : u.roomId);\n}, {\n  connectionId\n} = CoreContext, latestUpdateVersion = {}, getNextNodeVersion = (a) => (latestUpdateVersion[a] || (latestUpdateVersion[a] = 0), ++latestUpdateVersion[a]), request = (a, u) => {\n  const c = u.map((l) => {\n    const [v, S] = l;\n    return {\n      [v]: S\n    };\n  });\n  return log$1.debug(\"Batch request\", c), CoreContext.clients.LayoutApi().layer.batch({\n    layoutId: a,\n    layers: c,\n    requestMetadata: {\n      connectionId,\n      layoutId: a,\n      updateVersions: u.filter(([l]) => l === \"update\").map(([l, v]) => ({\n        [v.id]: getNextNodeVersion(v.id)\n      })).reduce((l, v) => ({\n        ...v,\n        ...l\n      }), {})\n    }\n  });\n}, compositorAdapter = (a, u) => ({\n  async insert(c = {}, l, v) {\n    const S = nodeToLayer({\n      id: null,\n      props: c,\n      childIds: []\n    });\n    l ? S.type = \"child\" : S.type = \"root\", log$1.debug(\"Insert layer\", S);\n    const g = await CoreContext.clients.LayoutApi().layer.createLayer({\n      layoutId: a,\n      layer: {\n        ...S,\n        requestMetadata: {\n          connectionId,\n          layoutId: a\n        }\n      }\n    });\n    if (g.code)\n      throw new Error(g.message);\n    const E = await u.get(l);\n    if (l && !E)\n      throw Error(\"Parent not found with ID\");\n    if (E) {\n      const _ = nodeToLayer(E), k = insertAt$1(v, g.id, _.children), L = {\n        layoutId: a,\n        layerId: _.id,\n        layer: {\n          children: k,\n          requestMetadata: {\n            connectionId,\n            layoutId: a,\n            updateVersion: {\n              [S.id]: getNextNodeVersion(S.id)\n            }\n          }\n        }\n      };\n      await CoreContext.clients.LayoutApi().layer.updateLayer(L);\n    }\n    return String(g.id);\n  },\n  async update(c, l = {}) {\n    const v = u.get(c), S = nodeToLayer({\n      ...v,\n      props: {\n        ...v.props,\n        ...l\n      }\n    }), g = {\n      layoutId: a,\n      layerId: S.id,\n      layer: {\n        ...S,\n        requestMetadata: {\n          connectionId,\n          layoutId: a,\n          updateVersions: {\n            [S.id]: getNextNodeVersion(S.id)\n          }\n        }\n      }\n    };\n    log$1.debug(\"Update layer\", g), await CoreContext.clients.LayoutApi().layer.updateLayer(g);\n  },\n  async remove(c) {\n    const l = await u.getParent(c);\n    if (l) {\n      const v = nodeToLayer(l), S = v.children.filter((E) => E !== c), g = {\n        layoutId: a,\n        layerId: v.id,\n        layer: {\n          children: S,\n          requestMetadata: {\n            connectionId,\n            layoutId: a,\n            updateVersions: {\n              [v.id]: getNextNodeVersion(v.id)\n            }\n          }\n        }\n      };\n      await CoreContext.clients.LayoutApi().layer.updateLayer(g);\n    }\n    await CoreContext.clients.LayoutApi().layer.deleteLayer({\n      layoutId: a,\n      layerId: c,\n      payload: {\n        requestMetadata: {\n          connectionId,\n          layoutId: a\n        }\n      }\n    });\n  },\n  // @ts-ignore\n  async reorder(c, l) {\n    const v = u.get(c), S = nodeToLayer({\n      ...v,\n      childIds: l\n    });\n    log$1.debug(\"Reorder layer children\", S), await CoreContext.clients.LayoutApi().layer.updateLayer({\n      layoutId: a,\n      layerId: S.id,\n      layer: {\n        children: S.children,\n        requestMetadata: {\n          connectionId,\n          layoutId: a,\n          updateVersions: {\n            [S.id]: getNextNodeVersion(S.id)\n          }\n        }\n      }\n    });\n  },\n  // @ts-ignore\n  async move(c, l, v) {\n    const S = u.get(c), g = u.get(u.getParent(c).id), E = nodeToLayer({\n      ...g,\n      childIds: pull$1(g.childIds, S.id)\n    }), _ = u.get(l), k = nodeToLayer({\n      ..._,\n      childIds: insertAt$1(v, S.id, _.childIds)\n    });\n    log$1.debug(\"Move layers\"), await Promise.all([CoreContext.clients.LayoutApi().layer.updateLayer({\n      layoutId: a,\n      layerId: E.id,\n      layer: {\n        children: E.children,\n        requestMetadata: {\n          connectionId,\n          layoutId: a,\n          updateVersions: {\n            [E.id]: getNextNodeVersion(E.id)\n          }\n        }\n      }\n    }), CoreContext.clients.LayoutApi().layer.updateLayer({\n      layoutId: a,\n      layerId: k.id,\n      layer: {\n        children: k.children,\n        requestMetadata: {\n          connectionId,\n          layoutId: a,\n          updateVersions: {\n            [k.id]: getNextNodeVersion(k.id)\n          }\n        }\n      }\n    })]);\n  },\n  async batch(c) {\n    const l = c.map(([S, g]) => [S, sceneNodeToLayer(g)]), v = await request(a, l);\n    return log$1.debug(\"Batch response\", v), v;\n  }\n}), config$1 = (a) => ({\n  defaults: {\n    previewTokenDuration: 1e3 * 60 * 60,\n    guestTokenDuration: 1e3 * 60 * 60 * 12,\n    transforms: {\n      RoomParticipant: \"LS-Room-Participant\",\n      Image: \"LS-Image\",\n      Banner: \"LS-Banner\",\n      Text: \"LS-Text\"\n    }\n  }\n}), RoomParticipant$1 = {\n  name: \"LS-Room-Participant\",\n  sourceType: \"RoomParticipant\",\n  props: {\n    isMuted: {\n      type: Boolean,\n      required: !1,\n      default: !1\n    },\n    volume: {\n      type: Number,\n      required: !1,\n      default: 1\n    }\n  },\n  useSource(a, u) {\n    return a.find((c) => isMatch(c.props, u.sourceProps));\n  },\n  create({\n    onUpdate: a,\n    onNewSource: u,\n    onRemove: c\n  }, l) {\n    const v = document.createElement(\"div\"), S = getProject(CoreContext.state.activeProjectId), g = getProjectRoom(CoreContext.state.activeProjectId);\n    Object.assign(v.style, {\n      position: \"relative\"\n    });\n    let E, _ = l;\n    const k = ($, J) => {\n      const V = $ / J.width;\n      return V >= 0.5 ? 3 : V > 0.25 ? 2 : V > 0.15 ? 1 : 0;\n    }, L = ({\n      props: $,\n      source: J\n    }) => {\n      var re, oe, de;\n      const V = useRef(), {\n        volume: q = 1,\n        isHidden: G = !1\n      } = $ || {}, [H, B] = useState(0), ne = (J == null ? void 0 : J.id) === (g == null ? void 0 : g.participantId) || ((re = J == null ? void 0 : J.props) == null ? void 0 : re.participantId) === (g == null ? void 0 : g.participantId) || ($ == null ? void 0 : $.isMuted), Z = !($ != null && $.isHidden) && ((oe = J == null ? void 0 : J.props) == null ? void 0 : oe.videoEnabled);\n      return useEffect(() => {\n        V.current && (V.current.play().catch((A) => {\n          document.addEventListener(\"click\", () => {\n            var N;\n            return (N = V.current) == null ? void 0 : N.play();\n          }, {\n            once: !0\n          });\n        }), J != null && J.value && (J == null ? void 0 : J.value) !== V.current.srcObject ? V.current.srcObject = J == null ? void 0 : J.value : J != null && J.value || (V.current.srcObject = null));\n      }, [V.current, J == null ? void 0 : J.value]), useEffect(() => {\n        !$ && V.current && (V.current.srcObject = null, V.current = null);\n      }, [$]), useLayoutEffect(() => {\n        if (!V.current)\n          return;\n        const A = () => {\n          const D = V.current;\n          D && B(k(D.clientWidth, {\n            width: S.compositor.getRoot().props.size.x,\n            height: S.compositor.getRoot().props.size.y\n          }));\n        }, N = new ResizeObserver((D) => {\n          A();\n        });\n        return A(), N == null || N.observe(V.current), () => {\n          V.current && (N == null || N.unobserve(V.current), V.current.srcObject = null);\n        };\n      }, [V.current, S]), useEffect(() => {\n        V.current && (V.current.volume = q);\n      }, [V.current, q]), /* @__PURE__ */ React.createElement(\"div\", {\n        style: {\n          position: \"relative\",\n          display: \"flex\",\n          height: \"100%\",\n          width: \"100%\"\n        }\n      }, /* @__PURE__ */ React.createElement(\"div\", {\n        style: {\n          background: \"#222\",\n          position: \"absolute\",\n          height: \"100%\",\n          width: \"100%\",\n          fontSize: \"43px\",\n          color: \"rgba(255,255,255,0.6)\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          opacity: Z ? \"0\" : \"1\"\n        }\n      }, (J == null ? void 0 : J.props.displayName) && /* @__PURE__ */ React.createElement(\"div\", {\n        style: {\n          borderRadius: \"50%\",\n          background: \"#555\",\n          width: \"70px\",\n          height: \"70px\",\n          textTransform: \"uppercase\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          lineHeight: \"1em\"\n        }\n      }, (J == null ? void 0 : J.props.displayName.slice(0, 1)) || \"\")), /* @__PURE__ */ React.createElement(\"div\", {\n        style: {\n          position: \"relative\",\n          display: \"flex\",\n          height: \"100%\",\n          width: \"100%\",\n          ...!!((de = J == null ? void 0 : J.props) != null && de.mirrored) && {\n            transform: \"scaleX(-1)\"\n          }\n        }\n      }, /* @__PURE__ */ React.createElement(\"video\", {\n        ref: V,\n        autoPlay: !0,\n        muted: ne,\n        disablePictureInPicture: !0,\n        playsInline: !0,\n        style: {\n          left: \"50%\",\n          top: \"50%\",\n          position: \"relative\",\n          transform: \"translate3d(-50%, -50%, 0)\",\n          height: \"100%\",\n          opacity: Z ? \"1\" : \"0\",\n          objectFit: (J == null ? void 0 : J.props.type) === \"screen\" ? \"contain\" : \"cover\",\n          background: \"rgba(0,0,0,0.6)\"\n        }\n      })), (J == null ? void 0 : J.props.displayName) && /* @__PURE__ */ React.createElement(\"div\", {\n        className: \"NameBannerContainer\",\n        style: {\n          width: \"100%\",\n          height: \"100%\",\n          position: \"absolute\"\n        }\n      }, /* @__PURE__ */ React.createElement(\"div\", {\n        className: \"NameBanner\",\n        \"data-size\": H,\n        style: {\n          padding: \"12px 30px\",\n          width: \"fit-content\",\n          height: \"fit-content\",\n          top: \"100%\",\n          transform: \"translateY(-100%)\",\n          left: 0\n        }\n      }, /* @__PURE__ */ React.createElement(\"div\", {\n        className: \"NameBanner-body\"\n      }, J.props.displayName))));\n    }, M = () => ReactDOM.render(/* @__PURE__ */ React.createElement(L, {\n      source: E,\n      props: _\n    }), v);\n    return a(($) => {\n      _ = $, M();\n    }), u(($) => {\n      E = $, M();\n    }), c(($) => {\n      _ = $, M();\n    }), {\n      root: v\n    };\n  }\n}, Square = {\n  name: \"LS-Square\",\n  props: {\n    color: {\n      default: \"green\"\n    }\n  },\n  create({\n    onUpdate: a\n  }) {\n    const u = document.createElement(\"div\");\n    return a(({\n      color: c\n    }) => {\n      Object.assign(u.style, {\n        width: \"100%\",\n        height: \"100%\",\n        background: c || \"red\"\n      });\n    }), {\n      root: u\n    };\n  }\n}, Image$1 = {\n  name: \"LS-Image\",\n  props: {\n    src: {},\n    fit: {}\n  },\n  create({\n    onUpdate: a\n  }) {\n    const u = document.createElement(\"img\");\n    return a(({\n      src: c,\n      fit: l\n    }) => {\n      u.setAttribute(\"src\", c), Object.assign(u.style, {\n        width: \"100%\",\n        height: \"100%\",\n        objectFit: l\n      });\n    }), {\n      root: u\n    };\n  }\n}, Element$1 = {\n  name: \"Element\",\n  sourceType: \"Element\",\n  create({\n    onUpdate: a\n  }, {\n    tagName: u\n  }) {\n    const c = document.createElement(u);\n    return a(({\n      tagName: l,\n      attributes: v = {},\n      fields: S = {}\n    }) => {\n      l === \"img\" ? (c == null ? void 0 : c.src) !== v.src && Object.keys(v).forEach((g) => {\n        c.setAttribute(g, v[g]);\n      }) : Object.keys(v).forEach((g) => {\n        c.setAttribute(g, v[g]);\n      }), Object.keys(S).forEach((g) => {\n        Object.assign(c[g], S[g]);\n      });\n    }), {\n      root: c\n    };\n  }\n}, Video = {\n  name: \"LS-Video\",\n  sourceType: \"LS-Video\",\n  create({\n    onUpdate: a,\n    onEvent: u,\n    onRemove: c\n  }) {\n    c(() => {\n      clearInterval(v);\n    });\n    const l = document.createElement(\"video\");\n    let v;\n    return a(({\n      attributes: S = {},\n      fields: g = {},\n      sourceProps: E = {},\n      id: _\n    }) => {\n      (l.src !== S.src || l.id !== S.id && S.id) && (v && clearInterval(v), Object.keys(S).forEach((k) => {\n        l.setAttribute(k, S[k]);\n      }), l.onloadedmetadata = () => {\n        S.muted ? (l.muted = !0, l.play()) : l.muted = !1;\n      }, v = setInterval(() => {\n        if (l.duration) {\n          const k = l.duration - l.currentTime;\n          trigger$1(\"VideoTimeUpdate\", {\n            category: _,\n            id: E == null ? void 0 : E.id,\n            time: Math.floor(k)\n          });\n        }\n      }, 1e3), l.loop = !!S.loop, l.onended = () => {\n        v && clearInterval(v), trigger$1(\"VideoEnded\", {\n          id: E == null ? void 0 : E.id,\n          category: _\n        });\n      }, Object.keys(g).forEach((k) => {\n        Object.assign(l[k], g[k]);\n      }));\n    }), {\n      root: l\n    };\n  }\n}, Banner$1 = {\n  name: \"LS-Banner\",\n  sourceType: \"Banner\",\n  props: {\n    bannerId: {\n      type: String,\n      required: !0\n    }\n  },\n  useSource(a, u) {\n    return a.find((c) => c.id === u.bannerId);\n  },\n  create({\n    onUpdate: a,\n    onNewSource: u\n  }, c) {\n    const l = document.createElement(\"div\");\n    let v, S, g;\n    const E = ({\n      currentSource: k,\n      latestSource: L\n    }) => {\n      const [M, $] = useState(!1), {\n        headerText: J,\n        bodyText: V\n      } = (L == null ? void 0 : L.value) || {};\n      return useEffect(() => {\n        window.setTimeout(() => {\n          $(!!k);\n        }), k || $(!1);\n      }, [k]), /* @__PURE__ */ React.createElement(\"div\", {\n        className: \"BannerContainer\",\n        style: {\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          width: \"100%\",\n          height: \"100%\",\n          display: \"flex\",\n          flexDirection: \"row\",\n          justifyContent: \"flex-start\",\n          alignItems: \"flex-end\",\n          transition: \"200ms ease all\",\n          ...M ? {\n            zIndex: 2,\n            opacity: 1,\n            transform: \"translateX(0)\"\n          } : {\n            zIndex: 1,\n            opacity: 0,\n            transform: \"translateX(-200px)\"\n          }\n        }\n      }, /* @__PURE__ */ React.createElement(\"div\", {\n        className: \"Banner\",\n        style: {\n          padding: 10,\n          background: \"orange\",\n          width: \"fit-content\",\n          height: \"fit-content\",\n          maxWidth: \"84%\",\n          position: \"relative\"\n        }\n      }, J && /* @__PURE__ */ React.createElement(\"div\", {\n        className: \"Banner-header\",\n        style: {\n          marginBottom: 6\n        }\n      }, J), V && /* @__PURE__ */ React.createElement(\"div\", {\n        className: \"Banner-body\"\n      }, V)));\n    }, _ = () => ReactDOM.render(/* @__PURE__ */ React.createElement(React.Fragment, null, g && g.id !== S.id && /* @__PURE__ */ React.createElement(E, {\n      key: g == null ? void 0 : g.id,\n      currentSource: null,\n      latestSource: g\n    }), /* @__PURE__ */ React.createElement(E, {\n      key: S == null ? void 0 : S.id,\n      currentSource: v,\n      latestSource: S\n    })), l);\n    return a(() => {\n      _();\n    }), u((k) => {\n      g = v, v = k, v && (S = v), _();\n    }), {\n      root: l\n    };\n  }\n};\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function(a) {\n    for (var u = 1; u < arguments.length; u++) {\n      var c = arguments[u];\n      for (var l in c)\n        Object.prototype.hasOwnProperty.call(c, l) && (a[l] = c[l]);\n    }\n    return a;\n  }, _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(a, u) {\n  if (a == null)\n    return {};\n  var c = {}, l = Object.keys(a), v, S;\n  for (S = 0; S < l.length; S++)\n    v = l[S], !(u.indexOf(v) >= 0) && (c[v] = a[v]);\n  return c;\n}\nfunction _setPrototypeOf(a, u) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(l, v) {\n    return l.__proto__ = v, l;\n  }, _setPrototypeOf(a, u);\n}\nfunction _inheritsLoose(a, u) {\n  a.prototype = Object.create(u.prototype), a.prototype.constructor = a, _setPrototypeOf(a, u);\n}\nvar propTypes = { exports: {} }, reactIs = { exports: {} }, reactIs_production_min = {};\n/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar hasRequiredReactIs_production_min;\nfunction requireReactIs_production_min() {\n  if (hasRequiredReactIs_production_min)\n    return reactIs_production_min;\n  hasRequiredReactIs_production_min = 1;\n  var a = typeof Symbol == \"function\" && Symbol.for, u = a ? Symbol.for(\"react.element\") : 60103, c = a ? Symbol.for(\"react.portal\") : 60106, l = a ? Symbol.for(\"react.fragment\") : 60107, v = a ? Symbol.for(\"react.strict_mode\") : 60108, S = a ? Symbol.for(\"react.profiler\") : 60114, g = a ? Symbol.for(\"react.provider\") : 60109, E = a ? Symbol.for(\"react.context\") : 60110, _ = a ? Symbol.for(\"react.async_mode\") : 60111, k = a ? Symbol.for(\"react.concurrent_mode\") : 60111, L = a ? Symbol.for(\"react.forward_ref\") : 60112, M = a ? Symbol.for(\"react.suspense\") : 60113, $ = a ? Symbol.for(\"react.suspense_list\") : 60120, J = a ? Symbol.for(\"react.memo\") : 60115, V = a ? Symbol.for(\"react.lazy\") : 60116, q = a ? Symbol.for(\"react.block\") : 60121, G = a ? Symbol.for(\"react.fundamental\") : 60117, H = a ? Symbol.for(\"react.responder\") : 60118, B = a ? Symbol.for(\"react.scope\") : 60119;\n  function Y(Z) {\n    if (typeof Z == \"object\" && Z !== null) {\n      var re = Z.$$typeof;\n      switch (re) {\n        case u:\n          switch (Z = Z.type, Z) {\n            case _:\n            case k:\n            case l:\n            case S:\n            case v:\n            case M:\n              return Z;\n            default:\n              switch (Z = Z && Z.$$typeof, Z) {\n                case E:\n                case L:\n                case V:\n                case J:\n                case g:\n                  return Z;\n                default:\n                  return re;\n              }\n          }\n        case c:\n          return re;\n      }\n    }\n  }\n  function ne(Z) {\n    return Y(Z) === k;\n  }\n  return reactIs_production_min.AsyncMode = _, reactIs_production_min.ConcurrentMode = k, reactIs_production_min.ContextConsumer = E, reactIs_production_min.ContextProvider = g, reactIs_production_min.Element = u, reactIs_production_min.ForwardRef = L, reactIs_production_min.Fragment = l, reactIs_production_min.Lazy = V, reactIs_production_min.Memo = J, reactIs_production_min.Portal = c, reactIs_production_min.Profiler = S, reactIs_production_min.StrictMode = v, reactIs_production_min.Suspense = M, reactIs_production_min.isAsyncMode = function(Z) {\n    return ne(Z) || Y(Z) === _;\n  }, reactIs_production_min.isConcurrentMode = ne, reactIs_production_min.isContextConsumer = function(Z) {\n    return Y(Z) === E;\n  }, reactIs_production_min.isContextProvider = function(Z) {\n    return Y(Z) === g;\n  }, reactIs_production_min.isElement = function(Z) {\n    return typeof Z == \"object\" && Z !== null && Z.$$typeof === u;\n  }, reactIs_production_min.isForwardRef = function(Z) {\n    return Y(Z) === L;\n  }, reactIs_production_min.isFragment = function(Z) {\n    return Y(Z) === l;\n  }, reactIs_production_min.isLazy = function(Z) {\n    return Y(Z) === V;\n  }, reactIs_production_min.isMemo = function(Z) {\n    return Y(Z) === J;\n  }, reactIs_production_min.isPortal = function(Z) {\n    return Y(Z) === c;\n  }, reactIs_production_min.isProfiler = function(Z) {\n    return Y(Z) === S;\n  }, reactIs_production_min.isStrictMode = function(Z) {\n    return Y(Z) === v;\n  }, reactIs_production_min.isSuspense = function(Z) {\n    return Y(Z) === M;\n  }, reactIs_production_min.isValidElementType = function(Z) {\n    return typeof Z == \"string\" || typeof Z == \"function\" || Z === l || Z === k || Z === S || Z === v || Z === M || Z === $ || typeof Z == \"object\" && Z !== null && (Z.$$typeof === V || Z.$$typeof === J || Z.$$typeof === g || Z.$$typeof === E || Z.$$typeof === L || Z.$$typeof === G || Z.$$typeof === H || Z.$$typeof === B || Z.$$typeof === q);\n  }, reactIs_production_min.typeOf = Y, reactIs_production_min;\n}\nvar reactIs_development = {};\n/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar hasRequiredReactIs_development;\nfunction requireReactIs_development() {\n  return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, process.env.NODE_ENV !== \"production\" && function() {\n    var a = typeof Symbol == \"function\" && Symbol.for, u = a ? Symbol.for(\"react.element\") : 60103, c = a ? Symbol.for(\"react.portal\") : 60106, l = a ? Symbol.for(\"react.fragment\") : 60107, v = a ? Symbol.for(\"react.strict_mode\") : 60108, S = a ? Symbol.for(\"react.profiler\") : 60114, g = a ? Symbol.for(\"react.provider\") : 60109, E = a ? Symbol.for(\"react.context\") : 60110, _ = a ? Symbol.for(\"react.async_mode\") : 60111, k = a ? Symbol.for(\"react.concurrent_mode\") : 60111, L = a ? Symbol.for(\"react.forward_ref\") : 60112, M = a ? Symbol.for(\"react.suspense\") : 60113, $ = a ? Symbol.for(\"react.suspense_list\") : 60120, J = a ? Symbol.for(\"react.memo\") : 60115, V = a ? Symbol.for(\"react.lazy\") : 60116, q = a ? Symbol.for(\"react.block\") : 60121, G = a ? Symbol.for(\"react.fundamental\") : 60117, H = a ? Symbol.for(\"react.responder\") : 60118, B = a ? Symbol.for(\"react.scope\") : 60119;\n    function Y(C) {\n      return typeof C == \"string\" || typeof C == \"function\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n      C === l || C === k || C === S || C === v || C === M || C === $ || typeof C == \"object\" && C !== null && (C.$$typeof === V || C.$$typeof === J || C.$$typeof === g || C.$$typeof === E || C.$$typeof === L || C.$$typeof === G || C.$$typeof === H || C.$$typeof === B || C.$$typeof === q);\n    }\n    function ne(C) {\n      if (typeof C == \"object\" && C !== null) {\n        var x = C.$$typeof;\n        switch (x) {\n          case u:\n            var Q = C.type;\n            switch (Q) {\n              case _:\n              case k:\n              case l:\n              case S:\n              case v:\n              case M:\n                return Q;\n              default:\n                var Se = Q && Q.$$typeof;\n                switch (Se) {\n                  case E:\n                  case L:\n                  case V:\n                  case J:\n                  case g:\n                    return Se;\n                  default:\n                    return x;\n                }\n            }\n          case c:\n            return x;\n        }\n      }\n    }\n    var Z = _, re = k, oe = E, de = g, A = u, N = L, D = l, W = V, ee = J, ae = c, ye = S, he = v, le = M, we = !1;\n    function Be(C) {\n      return we || (we = !0, console.warn(\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.\")), Ne(C) || ne(C) === _;\n    }\n    function Ne(C) {\n      return ne(C) === k;\n    }\n    function Le(C) {\n      return ne(C) === E;\n    }\n    function $e(C) {\n      return ne(C) === g;\n    }\n    function Ue(C) {\n      return typeof C == \"object\" && C !== null && C.$$typeof === u;\n    }\n    function Ge(C) {\n      return ne(C) === L;\n    }\n    function He(C) {\n      return ne(C) === l;\n    }\n    function Ve(C) {\n      return ne(C) === V;\n    }\n    function be(C) {\n      return ne(C) === J;\n    }\n    function Ae(C) {\n      return ne(C) === c;\n    }\n    function qe(C) {\n      return ne(C) === S;\n    }\n    function xe(C) {\n      return ne(C) === v;\n    }\n    function Pe(C) {\n      return ne(C) === M;\n    }\n    reactIs_development.AsyncMode = Z, reactIs_development.ConcurrentMode = re, reactIs_development.ContextConsumer = oe, reactIs_development.ContextProvider = de, reactIs_development.Element = A, reactIs_development.ForwardRef = N, reactIs_development.Fragment = D, reactIs_development.Lazy = W, reactIs_development.Memo = ee, reactIs_development.Portal = ae, reactIs_development.Profiler = ye, reactIs_development.StrictMode = he, reactIs_development.Suspense = le, reactIs_development.isAsyncMode = Be, reactIs_development.isConcurrentMode = Ne, reactIs_development.isContextConsumer = Le, reactIs_development.isContextProvider = $e, reactIs_development.isElement = Ue, reactIs_development.isForwardRef = Ge, reactIs_development.isFragment = He, reactIs_development.isLazy = Ve, reactIs_development.isMemo = be, reactIs_development.isPortal = Ae, reactIs_development.isProfiler = qe, reactIs_development.isStrictMode = xe, reactIs_development.isSuspense = Pe, reactIs_development.isValidElementType = Y, reactIs_development.typeOf = ne;\n  }()), reactIs_development;\n}\nvar hasRequiredReactIs;\nfunction requireReactIs() {\n  return hasRequiredReactIs || (hasRequiredReactIs = 1, process.env.NODE_ENV === \"production\" ? reactIs.exports = requireReactIs_production_min() : reactIs.exports = requireReactIs_development()), reactIs.exports;\n}\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\nvar objectAssign, hasRequiredObjectAssign;\nfunction requireObjectAssign() {\n  if (hasRequiredObjectAssign)\n    return objectAssign;\n  hasRequiredObjectAssign = 1;\n  var a = Object.getOwnPropertySymbols, u = Object.prototype.hasOwnProperty, c = Object.prototype.propertyIsEnumerable;\n  function l(S) {\n    if (S == null)\n      throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n    return Object(S);\n  }\n  function v() {\n    try {\n      if (!Object.assign)\n        return !1;\n      var S = new String(\"abc\");\n      if (S[5] = \"de\", Object.getOwnPropertyNames(S)[0] === \"5\")\n        return !1;\n      for (var g = {}, E = 0; E < 10; E++)\n        g[\"_\" + String.fromCharCode(E)] = E;\n      var _ = Object.getOwnPropertyNames(g).map(function(L) {\n        return g[L];\n      });\n      if (_.join(\"\") !== \"0123456789\")\n        return !1;\n      var k = {};\n      return \"abcdefghijklmnopqrst\".split(\"\").forEach(function(L) {\n        k[L] = L;\n      }), Object.keys(Object.assign({}, k)).join(\"\") === \"abcdefghijklmnopqrst\";\n    } catch {\n      return !1;\n    }\n  }\n  return objectAssign = v() ? Object.assign : function(S, g) {\n    for (var E, _ = l(S), k, L = 1; L < arguments.length; L++) {\n      E = Object(arguments[L]);\n      for (var M in E)\n        u.call(E, M) && (_[M] = E[M]);\n      if (a) {\n        k = a(E);\n        for (var $ = 0; $ < k.length; $++)\n          c.call(E, k[$]) && (_[k[$]] = E[k[$]]);\n      }\n    }\n    return _;\n  }, objectAssign;\n}\nvar ReactPropTypesSecret_1, hasRequiredReactPropTypesSecret;\nfunction requireReactPropTypesSecret() {\n  if (hasRequiredReactPropTypesSecret)\n    return ReactPropTypesSecret_1;\n  hasRequiredReactPropTypesSecret = 1;\n  var a = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n  return ReactPropTypesSecret_1 = a, ReactPropTypesSecret_1;\n}\nvar has, hasRequiredHas;\nfunction requireHas() {\n  return hasRequiredHas || (hasRequiredHas = 1, has = Function.call.bind(Object.prototype.hasOwnProperty)), has;\n}\nvar checkPropTypes_1, hasRequiredCheckPropTypes;\nfunction requireCheckPropTypes() {\n  if (hasRequiredCheckPropTypes)\n    return checkPropTypes_1;\n  hasRequiredCheckPropTypes = 1;\n  var a = function() {\n  };\n  if (process.env.NODE_ENV !== \"production\") {\n    var u = requireReactPropTypesSecret(), c = {}, l = requireHas();\n    a = function(S) {\n      var g = \"Warning: \" + S;\n      typeof console < \"u\" && console.error(g);\n      try {\n        throw new Error(g);\n      } catch {\n      }\n    };\n  }\n  function v(S, g, E, _, k) {\n    if (process.env.NODE_ENV !== \"production\") {\n      for (var L in S)\n        if (l(S, L)) {\n          var M;\n          try {\n            if (typeof S[L] != \"function\") {\n              var $ = Error(\n                (_ || \"React class\") + \": \" + E + \" type `\" + L + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof S[L] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\"\n              );\n              throw $.name = \"Invariant Violation\", $;\n            }\n            M = S[L](g, L, _, E, null, u);\n          } catch (V) {\n            M = V;\n          }\n          if (M && !(M instanceof Error) && a(\n            (_ || \"React class\") + \": type specification of \" + E + \" `\" + L + \"` is invalid; the type checker function must return `null` or an `Error` but returned a \" + typeof M + \". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\"\n          ), M instanceof Error && !(M.message in c)) {\n            c[M.message] = !0;\n            var J = k ? k() : \"\";\n            a(\n              \"Failed \" + E + \" type: \" + M.message + (J ?? \"\")\n            );\n          }\n        }\n    }\n  }\n  return v.resetWarningCache = function() {\n    process.env.NODE_ENV !== \"production\" && (c = {});\n  }, checkPropTypes_1 = v, checkPropTypes_1;\n}\nvar factoryWithTypeCheckers, hasRequiredFactoryWithTypeCheckers;\nfunction requireFactoryWithTypeCheckers() {\n  if (hasRequiredFactoryWithTypeCheckers)\n    return factoryWithTypeCheckers;\n  hasRequiredFactoryWithTypeCheckers = 1;\n  var a = requireReactIs(), u = requireObjectAssign(), c = requireReactPropTypesSecret(), l = requireHas(), v = requireCheckPropTypes(), S = function() {\n  };\n  process.env.NODE_ENV !== \"production\" && (S = function(E) {\n    var _ = \"Warning: \" + E;\n    typeof console < \"u\" && console.error(_);\n    try {\n      throw new Error(_);\n    } catch {\n    }\n  });\n  function g() {\n    return null;\n  }\n  return factoryWithTypeCheckers = function(E, _) {\n    var k = typeof Symbol == \"function\" && Symbol.iterator, L = \"@@iterator\";\n    function M(Ne) {\n      var Le = Ne && (k && Ne[k] || Ne[L]);\n      if (typeof Le == \"function\")\n        return Le;\n    }\n    var $ = \"<<anonymous>>\", J = {\n      array: H(\"array\"),\n      bigint: H(\"bigint\"),\n      bool: H(\"boolean\"),\n      func: H(\"function\"),\n      number: H(\"number\"),\n      object: H(\"object\"),\n      string: H(\"string\"),\n      symbol: H(\"symbol\"),\n      any: B(),\n      arrayOf: Y,\n      element: ne(),\n      elementType: Z(),\n      instanceOf: re,\n      node: N(),\n      objectOf: de,\n      oneOf: oe,\n      oneOfType: A,\n      shape: W,\n      exact: ee\n    };\n    function V(Ne, Le) {\n      return Ne === Le ? Ne !== 0 || 1 / Ne === 1 / Le : Ne !== Ne && Le !== Le;\n    }\n    function q(Ne, Le) {\n      this.message = Ne, this.data = Le && typeof Le == \"object\" ? Le : {}, this.stack = \"\";\n    }\n    q.prototype = Error.prototype;\n    function G(Ne) {\n      if (process.env.NODE_ENV !== \"production\")\n        var Le = {}, $e = 0;\n      function Ue(He, Ve, be, Ae, qe, xe, Pe) {\n        if (Ae = Ae || $, xe = xe || be, Pe !== c) {\n          if (_) {\n            var C = new Error(\n              \"Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types\"\n            );\n            throw C.name = \"Invariant Violation\", C;\n          } else if (process.env.NODE_ENV !== \"production\" && typeof console < \"u\") {\n            var x = Ae + \":\" + be;\n            !Le[x] && // Avoid spamming the console because they are often not actionable except for lib authors\n            $e < 3 && (S(\n              \"You are manually calling a React.PropTypes validation function for the `\" + xe + \"` prop on `\" + Ae + \"`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.\"\n            ), Le[x] = !0, $e++);\n          }\n        }\n        return Ve[be] == null ? He ? Ve[be] === null ? new q(\"The \" + qe + \" `\" + xe + \"` is marked as required \" + (\"in `\" + Ae + \"`, but its value is `null`.\")) : new q(\"The \" + qe + \" `\" + xe + \"` is marked as required in \" + (\"`\" + Ae + \"`, but its value is `undefined`.\")) : null : Ne(Ve, be, Ae, qe, xe);\n      }\n      var Ge = Ue.bind(null, !1);\n      return Ge.isRequired = Ue.bind(null, !0), Ge;\n    }\n    function H(Ne) {\n      function Le($e, Ue, Ge, He, Ve, be) {\n        var Ae = $e[Ue], qe = he(Ae);\n        if (qe !== Ne) {\n          var xe = le(Ae);\n          return new q(\n            \"Invalid \" + He + \" `\" + Ve + \"` of type \" + (\"`\" + xe + \"` supplied to `\" + Ge + \"`, expected \") + (\"`\" + Ne + \"`.\"),\n            { expectedType: Ne }\n          );\n        }\n        return null;\n      }\n      return G(Le);\n    }\n    function B() {\n      return G(g);\n    }\n    function Y(Ne) {\n      function Le($e, Ue, Ge, He, Ve) {\n        if (typeof Ne != \"function\")\n          return new q(\"Property `\" + Ve + \"` of component `\" + Ge + \"` has invalid PropType notation inside arrayOf.\");\n        var be = $e[Ue];\n        if (!Array.isArray(be)) {\n          var Ae = he(be);\n          return new q(\"Invalid \" + He + \" `\" + Ve + \"` of type \" + (\"`\" + Ae + \"` supplied to `\" + Ge + \"`, expected an array.\"));\n        }\n        for (var qe = 0; qe < be.length; qe++) {\n          var xe = Ne(be, qe, Ge, He, Ve + \"[\" + qe + \"]\", c);\n          if (xe instanceof Error)\n            return xe;\n        }\n        return null;\n      }\n      return G(Le);\n    }\n    function ne() {\n      function Ne(Le, $e, Ue, Ge, He) {\n        var Ve = Le[$e];\n        if (!E(Ve)) {\n          var be = he(Ve);\n          return new q(\"Invalid \" + Ge + \" `\" + He + \"` of type \" + (\"`\" + be + \"` supplied to `\" + Ue + \"`, expected a single ReactElement.\"));\n        }\n        return null;\n      }\n      return G(Ne);\n    }\n    function Z() {\n      function Ne(Le, $e, Ue, Ge, He) {\n        var Ve = Le[$e];\n        if (!a.isValidElementType(Ve)) {\n          var be = he(Ve);\n          return new q(\"Invalid \" + Ge + \" `\" + He + \"` of type \" + (\"`\" + be + \"` supplied to `\" + Ue + \"`, expected a single ReactElement type.\"));\n        }\n        return null;\n      }\n      return G(Ne);\n    }\n    function re(Ne) {\n      function Le($e, Ue, Ge, He, Ve) {\n        if (!($e[Ue] instanceof Ne)) {\n          var be = Ne.name || $, Ae = Be($e[Ue]);\n          return new q(\"Invalid \" + He + \" `\" + Ve + \"` of type \" + (\"`\" + Ae + \"` supplied to `\" + Ge + \"`, expected \") + (\"instance of `\" + be + \"`.\"));\n        }\n        return null;\n      }\n      return G(Le);\n    }\n    function oe(Ne) {\n      if (!Array.isArray(Ne))\n        return process.env.NODE_ENV !== \"production\" && (arguments.length > 1 ? S(\n          \"Invalid arguments supplied to oneOf, expected an array, got \" + arguments.length + \" arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\"\n        ) : S(\"Invalid argument supplied to oneOf, expected an array.\")), g;\n      function Le($e, Ue, Ge, He, Ve) {\n        for (var be = $e[Ue], Ae = 0; Ae < Ne.length; Ae++)\n          if (V(be, Ne[Ae]))\n            return null;\n        var qe = JSON.stringify(Ne, function(Pe, C) {\n          var x = le(C);\n          return x === \"symbol\" ? String(C) : C;\n        });\n        return new q(\"Invalid \" + He + \" `\" + Ve + \"` of value `\" + String(be) + \"` \" + (\"supplied to `\" + Ge + \"`, expected one of \" + qe + \".\"));\n      }\n      return G(Le);\n    }\n    function de(Ne) {\n      function Le($e, Ue, Ge, He, Ve) {\n        if (typeof Ne != \"function\")\n          return new q(\"Property `\" + Ve + \"` of component `\" + Ge + \"` has invalid PropType notation inside objectOf.\");\n        var be = $e[Ue], Ae = he(be);\n        if (Ae !== \"object\")\n          return new q(\"Invalid \" + He + \" `\" + Ve + \"` of type \" + (\"`\" + Ae + \"` supplied to `\" + Ge + \"`, expected an object.\"));\n        for (var qe in be)\n          if (l(be, qe)) {\n            var xe = Ne(be, qe, Ge, He, Ve + \".\" + qe, c);\n            if (xe instanceof Error)\n              return xe;\n          }\n        return null;\n      }\n      return G(Le);\n    }\n    function A(Ne) {\n      if (!Array.isArray(Ne))\n        return process.env.NODE_ENV !== \"production\" && S(\"Invalid argument supplied to oneOfType, expected an instance of array.\"), g;\n      for (var Le = 0; Le < Ne.length; Le++) {\n        var $e = Ne[Le];\n        if (typeof $e != \"function\")\n          return S(\n            \"Invalid argument supplied to oneOfType. Expected an array of check functions, but received \" + we($e) + \" at index \" + Le + \".\"\n          ), g;\n      }\n      function Ue(Ge, He, Ve, be, Ae) {\n        for (var qe = [], xe = 0; xe < Ne.length; xe++) {\n          var Pe = Ne[xe], C = Pe(Ge, He, Ve, be, Ae, c);\n          if (C == null)\n            return null;\n          C.data && l(C.data, \"expectedType\") && qe.push(C.data.expectedType);\n        }\n        var x = qe.length > 0 ? \", expected one of type [\" + qe.join(\", \") + \"]\" : \"\";\n        return new q(\"Invalid \" + be + \" `\" + Ae + \"` supplied to \" + (\"`\" + Ve + \"`\" + x + \".\"));\n      }\n      return G(Ue);\n    }\n    function N() {\n      function Ne(Le, $e, Ue, Ge, He) {\n        return ae(Le[$e]) ? null : new q(\"Invalid \" + Ge + \" `\" + He + \"` supplied to \" + (\"`\" + Ue + \"`, expected a ReactNode.\"));\n      }\n      return G(Ne);\n    }\n    function D(Ne, Le, $e, Ue, Ge) {\n      return new q(\n        (Ne || \"React class\") + \": \" + Le + \" type `\" + $e + \".\" + Ue + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + Ge + \"`.\"\n      );\n    }\n    function W(Ne) {\n      function Le($e, Ue, Ge, He, Ve) {\n        var be = $e[Ue], Ae = he(be);\n        if (Ae !== \"object\")\n          return new q(\"Invalid \" + He + \" `\" + Ve + \"` of type `\" + Ae + \"` \" + (\"supplied to `\" + Ge + \"`, expected `object`.\"));\n        for (var qe in Ne) {\n          var xe = Ne[qe];\n          if (typeof xe != \"function\")\n            return D(Ge, He, Ve, qe, le(xe));\n          var Pe = xe(be, qe, Ge, He, Ve + \".\" + qe, c);\n          if (Pe)\n            return Pe;\n        }\n        return null;\n      }\n      return G(Le);\n    }\n    function ee(Ne) {\n      function Le($e, Ue, Ge, He, Ve) {\n        var be = $e[Ue], Ae = he(be);\n        if (Ae !== \"object\")\n          return new q(\"Invalid \" + He + \" `\" + Ve + \"` of type `\" + Ae + \"` \" + (\"supplied to `\" + Ge + \"`, expected `object`.\"));\n        var qe = u({}, $e[Ue], Ne);\n        for (var xe in qe) {\n          var Pe = Ne[xe];\n          if (l(Ne, xe) && typeof Pe != \"function\")\n            return D(Ge, He, Ve, xe, le(Pe));\n          if (!Pe)\n            return new q(\n              \"Invalid \" + He + \" `\" + Ve + \"` key `\" + xe + \"` supplied to `\" + Ge + \"`.\\nBad object: \" + JSON.stringify($e[Ue], null, \"  \") + `\nValid keys: ` + JSON.stringify(Object.keys(Ne), null, \"  \")\n            );\n          var C = Pe(be, xe, Ge, He, Ve + \".\" + xe, c);\n          if (C)\n            return C;\n        }\n        return null;\n      }\n      return G(Le);\n    }\n    function ae(Ne) {\n      switch (typeof Ne) {\n        case \"number\":\n        case \"string\":\n        case \"undefined\":\n          return !0;\n        case \"boolean\":\n          return !Ne;\n        case \"object\":\n          if (Array.isArray(Ne))\n            return Ne.every(ae);\n          if (Ne === null || E(Ne))\n            return !0;\n          var Le = M(Ne);\n          if (Le) {\n            var $e = Le.call(Ne), Ue;\n            if (Le !== Ne.entries) {\n              for (; !(Ue = $e.next()).done; )\n                if (!ae(Ue.value))\n                  return !1;\n            } else\n              for (; !(Ue = $e.next()).done; ) {\n                var Ge = Ue.value;\n                if (Ge && !ae(Ge[1]))\n                  return !1;\n              }\n          } else\n            return !1;\n          return !0;\n        default:\n          return !1;\n      }\n    }\n    function ye(Ne, Le) {\n      return Ne === \"symbol\" ? !0 : Le ? Le[\"@@toStringTag\"] === \"Symbol\" || typeof Symbol == \"function\" && Le instanceof Symbol : !1;\n    }\n    function he(Ne) {\n      var Le = typeof Ne;\n      return Array.isArray(Ne) ? \"array\" : Ne instanceof RegExp ? \"object\" : ye(Le, Ne) ? \"symbol\" : Le;\n    }\n    function le(Ne) {\n      if (typeof Ne > \"u\" || Ne === null)\n        return \"\" + Ne;\n      var Le = he(Ne);\n      if (Le === \"object\") {\n        if (Ne instanceof Date)\n          return \"date\";\n        if (Ne instanceof RegExp)\n          return \"regexp\";\n      }\n      return Le;\n    }\n    function we(Ne) {\n      var Le = le(Ne);\n      switch (Le) {\n        case \"array\":\n        case \"object\":\n          return \"an \" + Le;\n        case \"boolean\":\n        case \"date\":\n        case \"regexp\":\n          return \"a \" + Le;\n        default:\n          return Le;\n      }\n    }\n    function Be(Ne) {\n      return !Ne.constructor || !Ne.constructor.name ? $ : Ne.constructor.name;\n    }\n    return J.checkPropTypes = v, J.resetWarningCache = v.resetWarningCache, J.PropTypes = J, J;\n  }, factoryWithTypeCheckers;\n}\nvar factoryWithThrowingShims, hasRequiredFactoryWithThrowingShims;\nfunction requireFactoryWithThrowingShims() {\n  if (hasRequiredFactoryWithThrowingShims)\n    return factoryWithThrowingShims;\n  hasRequiredFactoryWithThrowingShims = 1;\n  var a = requireReactPropTypesSecret();\n  function u() {\n  }\n  function c() {\n  }\n  return c.resetWarningCache = u, factoryWithThrowingShims = function() {\n    function l(g, E, _, k, L, M) {\n      if (M !== a) {\n        var $ = new Error(\n          \"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types\"\n        );\n        throw $.name = \"Invariant Violation\", $;\n      }\n    }\n    l.isRequired = l;\n    function v() {\n      return l;\n    }\n    var S = {\n      array: l,\n      bigint: l,\n      bool: l,\n      func: l,\n      number: l,\n      object: l,\n      string: l,\n      symbol: l,\n      any: l,\n      arrayOf: v,\n      element: l,\n      elementType: l,\n      instanceOf: v,\n      node: l,\n      objectOf: v,\n      oneOf: v,\n      oneOfType: v,\n      shape: v,\n      exact: v,\n      checkPropTypes: c,\n      resetWarningCache: u\n    };\n    return S.PropTypes = S, S;\n  }, factoryWithThrowingShims;\n}\nif (process.env.NODE_ENV !== \"production\") {\n  var ReactIs = requireReactIs(), throwOnDirectAccess = !0;\n  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);\n} else\n  propTypes.exports = requireFactoryWithThrowingShims()();\nvar propTypesExports = propTypes.exports;\nconst PropTypes = /* @__PURE__ */ getDefaultExportFromCjs$1(propTypesExports);\nfunction hasClass(a, u) {\n  return a.classList ? !!u && a.classList.contains(u) : (\" \" + (a.className.baseVal || a.className) + \" \").indexOf(\" \" + u + \" \") !== -1;\n}\nfunction addClass(a, u) {\n  a.classList ? a.classList.add(u) : hasClass(a, u) || (typeof a.className == \"string\" ? a.className = a.className + \" \" + u : a.setAttribute(\"class\", (a.className && a.className.baseVal || \"\") + \" \" + u));\n}\nfunction replaceClassName(a, u) {\n  return a.replace(new RegExp(\"(^|\\\\s)\" + u + \"(?:\\\\s|$)\", \"g\"), \"$1\").replace(/\\s+/g, \" \").replace(/^\\s*|\\s*$/g, \"\");\n}\nfunction removeClass$1(a, u) {\n  a.classList ? a.classList.remove(u) : typeof a.className == \"string\" ? a.className = replaceClassName(a.className, u) : a.setAttribute(\"class\", replaceClassName(a.className && a.className.baseVal || \"\", u));\n}\nconst config = {\n  disabled: !1\n};\nvar timeoutsShape = process.env.NODE_ENV !== \"production\" ? PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n  enter: PropTypes.number,\n  exit: PropTypes.number,\n  appear: PropTypes.number\n}).isRequired]) : null, classNamesShape = process.env.NODE_ENV !== \"production\" ? PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n  enter: PropTypes.string,\n  exit: PropTypes.string,\n  active: PropTypes.string\n}), PropTypes.shape({\n  enter: PropTypes.string,\n  enterDone: PropTypes.string,\n  enterActive: PropTypes.string,\n  exit: PropTypes.string,\n  exitDone: PropTypes.string,\n  exitActive: PropTypes.string\n})]) : null;\nconst TransitionGroupContext = React.createContext(null);\nvar forceReflow = function a(u) {\n  return u.scrollTop;\n}, UNMOUNTED = \"unmounted\", EXITED = \"exited\", ENTERING = \"entering\", ENTERED = \"entered\", EXITING = \"exiting\", Transition = /* @__PURE__ */ function(a) {\n  _inheritsLoose(u, a);\n  function u(l, v) {\n    var S;\n    S = a.call(this, l, v) || this;\n    var g = v, E = g && !g.isMounting ? l.enter : l.appear, _;\n    return S.appearStatus = null, l.in ? E ? (_ = EXITED, S.appearStatus = ENTERING) : _ = ENTERED : l.unmountOnExit || l.mountOnEnter ? _ = UNMOUNTED : _ = EXITED, S.state = {\n      status: _\n    }, S.nextCallback = null, S;\n  }\n  u.getDerivedStateFromProps = function(v, S) {\n    var g = v.in;\n    return g && S.status === UNMOUNTED ? {\n      status: EXITED\n    } : null;\n  };\n  var c = u.prototype;\n  return c.componentDidMount = function() {\n    this.updateStatus(!0, this.appearStatus);\n  }, c.componentDidUpdate = function(v) {\n    var S = null;\n    if (v !== this.props) {\n      var g = this.state.status;\n      this.props.in ? g !== ENTERING && g !== ENTERED && (S = ENTERING) : (g === ENTERING || g === ENTERED) && (S = EXITING);\n    }\n    this.updateStatus(!1, S);\n  }, c.componentWillUnmount = function() {\n    this.cancelNextCallback();\n  }, c.getTimeouts = function() {\n    var v = this.props.timeout, S, g, E;\n    return S = g = E = v, v != null && typeof v != \"number\" && (S = v.exit, g = v.enter, E = v.appear !== void 0 ? v.appear : g), {\n      exit: S,\n      enter: g,\n      appear: E\n    };\n  }, c.updateStatus = function(v, S) {\n    if (v === void 0 && (v = !1), S !== null)\n      if (this.cancelNextCallback(), S === ENTERING) {\n        if (this.props.unmountOnExit || this.props.mountOnEnter) {\n          var g = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);\n          g && forceReflow(g);\n        }\n        this.performEnter(v);\n      } else\n        this.performExit();\n    else\n      this.props.unmountOnExit && this.state.status === EXITED && this.setState({\n        status: UNMOUNTED\n      });\n  }, c.performEnter = function(v) {\n    var S = this, g = this.props.enter, E = this.context ? this.context.isMounting : v, _ = this.props.nodeRef ? [E] : [ReactDOM.findDOMNode(this), E], k = _[0], L = _[1], M = this.getTimeouts(), $ = E ? M.appear : M.enter;\n    if (!v && !g || config.disabled) {\n      this.safeSetState({\n        status: ENTERED\n      }, function() {\n        S.props.onEntered(k);\n      });\n      return;\n    }\n    this.props.onEnter(k, L), this.safeSetState({\n      status: ENTERING\n    }, function() {\n      S.props.onEntering(k, L), S.onTransitionEnd($, function() {\n        S.safeSetState({\n          status: ENTERED\n        }, function() {\n          S.props.onEntered(k, L);\n        });\n      });\n    });\n  }, c.performExit = function() {\n    var v = this, S = this.props.exit, g = this.getTimeouts(), E = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);\n    if (!S || config.disabled) {\n      this.safeSetState({\n        status: EXITED\n      }, function() {\n        v.props.onExited(E);\n      });\n      return;\n    }\n    this.props.onExit(E), this.safeSetState({\n      status: EXITING\n    }, function() {\n      v.props.onExiting(E), v.onTransitionEnd(g.exit, function() {\n        v.safeSetState({\n          status: EXITED\n        }, function() {\n          v.props.onExited(E);\n        });\n      });\n    });\n  }, c.cancelNextCallback = function() {\n    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);\n  }, c.safeSetState = function(v, S) {\n    S = this.setNextCallback(S), this.setState(v, S);\n  }, c.setNextCallback = function(v) {\n    var S = this, g = !0;\n    return this.nextCallback = function(E) {\n      g && (g = !1, S.nextCallback = null, v(E));\n    }, this.nextCallback.cancel = function() {\n      g = !1;\n    }, this.nextCallback;\n  }, c.onTransitionEnd = function(v, S) {\n    this.setNextCallback(S);\n    var g = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this), E = v == null && !this.props.addEndListener;\n    if (!g || E) {\n      setTimeout(this.nextCallback, 0);\n      return;\n    }\n    if (this.props.addEndListener) {\n      var _ = this.props.nodeRef ? [this.nextCallback] : [g, this.nextCallback], k = _[0], L = _[1];\n      this.props.addEndListener(k, L);\n    }\n    v != null && setTimeout(this.nextCallback, v);\n  }, c.render = function() {\n    var v = this.state.status;\n    if (v === UNMOUNTED)\n      return null;\n    var S = this.props, g = S.children;\n    S.in, S.mountOnEnter, S.unmountOnExit, S.appear, S.enter, S.exit, S.timeout, S.addEndListener, S.onEnter, S.onEntering, S.onEntered, S.onExit, S.onExiting, S.onExited, S.nodeRef;\n    var E = _objectWithoutPropertiesLoose(S, [\"children\", \"in\", \"mountOnEnter\", \"unmountOnExit\", \"appear\", \"enter\", \"exit\", \"timeout\", \"addEndListener\", \"onEnter\", \"onEntering\", \"onEntered\", \"onExit\", \"onExiting\", \"onExited\", \"nodeRef\"]);\n    return (\n      // allows for nested Transitions\n      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {\n        value: null\n      }, typeof g == \"function\" ? g(v, E) : React.cloneElement(React.Children.only(g), E))\n    );\n  }, u;\n}(React.Component);\nTransition.contextType = TransitionGroupContext;\nTransition.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * A React reference to DOM element that need to transition:\n   * https://stackoverflow.com/a/51127130/4671932\n   *\n   *   - When `nodeRef` prop is used, `node` is not passed to callback functions\n   *      (e.g. `onEnter`) because user already has direct access to the node.\n   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new\n   *     `nodeRef` need to be provided to `Transition` with changed `key` prop\n   *     (see\n   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).\n   */\n  nodeRef: PropTypes.shape({\n    current: typeof Element > \"u\" ? PropTypes.any : function(a, u, c, l, v, S) {\n      var g = a[u];\n      return PropTypes.instanceOf(g && \"ownerDocument\" in g ? g.ownerDocument.defaultView.Element : Element)(a, u, c, l, v, S);\n    }\n  }),\n  /**\n   * A `function` child can be used instead of a React element. This function is\n   * called with the current transition status (`'entering'`, `'entered'`,\n   * `'exiting'`, `'exited'`), which can be used to apply context\n   * specific props to a component.\n   *\n   * ```jsx\n   * <Transition in={this.state.in} timeout={150}>\n   *   {state => (\n   *     <MyComponent className={`fade fade-${state}`} />\n   *   )}\n   * </Transition>\n   * ```\n   */\n  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,\n  /**\n   * Show the component; triggers the enter or exit states\n   */\n  in: PropTypes.bool,\n  /**\n   * By default the child component is mounted immediately along with\n   * the parent `Transition` component. If you want to \"lazy mount\" the component on the\n   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay\n   * mounted, even on \"exited\", unless you also specify `unmountOnExit`.\n   */\n  mountOnEnter: PropTypes.bool,\n  /**\n   * By default the child component stays mounted after it reaches the `'exited'` state.\n   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.\n   */\n  unmountOnExit: PropTypes.bool,\n  /**\n   * By default the child component does not perform the enter transition when\n   * it first mounts, regardless of the value of `in`. If you want this\n   * behavior, set both `appear` and `in` to `true`.\n   *\n   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop\n   * > only adds an additional enter transition. However, in the\n   * > `<CSSTransition>` component that first enter transition does result in\n   * > additional `.appear-*` classes, that way you can choose to style it\n   * > differently.\n   */\n  appear: PropTypes.bool,\n  /**\n   * Enable or disable enter transitions.\n   */\n  enter: PropTypes.bool,\n  /**\n   * Enable or disable exit transitions.\n   */\n  exit: PropTypes.bool,\n  /**\n   * The duration of the transition, in milliseconds.\n   * Required unless `addEndListener` is provided.\n   *\n   * You may specify a single timeout for all transitions:\n   *\n   * ```jsx\n   * timeout={500}\n   * ```\n   *\n   * or individually:\n   *\n   * ```jsx\n   * timeout={{\n   *  appear: 500,\n   *  enter: 300,\n   *  exit: 500,\n   * }}\n   * ```\n   *\n   * - `appear` defaults to the value of `enter`\n   * - `enter` defaults to `0`\n   * - `exit` defaults to `0`\n   *\n   * @type {number | { enter?: number, exit?: number, appear?: number }}\n   */\n  timeout: function a(u) {\n    var c = timeoutsShape;\n    u.addEndListener || (c = c.isRequired);\n    for (var l = arguments.length, v = new Array(l > 1 ? l - 1 : 0), S = 1; S < l; S++)\n      v[S - 1] = arguments[S];\n    return c.apply(void 0, [u].concat(v));\n  },\n  /**\n   * Add a custom transition end trigger. Called with the transitioning\n   * DOM node and a `done` callback. Allows for more fine grained transition end\n   * logic. Timeouts are still used as a fallback if provided.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * ```jsx\n   * addEndListener={(node, done) => {\n   *   // use the css transitionend event to mark the finish of a transition\n   *   node.addEventListener('transitionend', done, false);\n   * }}\n   * ```\n   */\n  addEndListener: PropTypes.func,\n  /**\n   * Callback fired before the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEnter: PropTypes.func,\n  /**\n   * Callback fired after the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEntering: PropTypes.func,\n  /**\n   * Callback fired after the \"entered\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEntered: PropTypes.func,\n  /**\n   * Callback fired before the \"exiting\" status is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExit: PropTypes.func,\n  /**\n   * Callback fired after the \"exiting\" status is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExiting: PropTypes.func,\n  /**\n   * Callback fired after the \"exited\" status is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExited: PropTypes.func\n} : {};\nfunction noop() {\n}\nTransition.defaultProps = {\n  in: !1,\n  mountOnEnter: !1,\n  unmountOnExit: !1,\n  appear: !1,\n  enter: !0,\n  exit: !0,\n  onEnter: noop,\n  onEntering: noop,\n  onEntered: noop,\n  onExit: noop,\n  onExiting: noop,\n  onExited: noop\n};\nTransition.UNMOUNTED = UNMOUNTED;\nTransition.EXITED = EXITED;\nTransition.ENTERING = ENTERING;\nTransition.ENTERED = ENTERED;\nTransition.EXITING = EXITING;\nconst Transition$1 = Transition;\nvar _addClass = function a(u, c) {\n  return u && c && c.split(\" \").forEach(function(l) {\n    return addClass(u, l);\n  });\n}, removeClass = function a(u, c) {\n  return u && c && c.split(\" \").forEach(function(l) {\n    return removeClass$1(u, l);\n  });\n}, CSSTransition = /* @__PURE__ */ function(a) {\n  _inheritsLoose(u, a);\n  function u() {\n    for (var l, v = arguments.length, S = new Array(v), g = 0; g < v; g++)\n      S[g] = arguments[g];\n    return l = a.call.apply(a, [this].concat(S)) || this, l.appliedClasses = {\n      appear: {},\n      enter: {},\n      exit: {}\n    }, l.onEnter = function(E, _) {\n      var k = l.resolveArguments(E, _), L = k[0], M = k[1];\n      l.removeClasses(L, \"exit\"), l.addClass(L, M ? \"appear\" : \"enter\", \"base\"), l.props.onEnter && l.props.onEnter(E, _);\n    }, l.onEntering = function(E, _) {\n      var k = l.resolveArguments(E, _), L = k[0], M = k[1], $ = M ? \"appear\" : \"enter\";\n      l.addClass(L, $, \"active\"), l.props.onEntering && l.props.onEntering(E, _);\n    }, l.onEntered = function(E, _) {\n      var k = l.resolveArguments(E, _), L = k[0], M = k[1], $ = M ? \"appear\" : \"enter\";\n      l.removeClasses(L, $), l.addClass(L, $, \"done\"), l.props.onEntered && l.props.onEntered(E, _);\n    }, l.onExit = function(E) {\n      var _ = l.resolveArguments(E), k = _[0];\n      l.removeClasses(k, \"appear\"), l.removeClasses(k, \"enter\"), l.addClass(k, \"exit\", \"base\"), l.props.onExit && l.props.onExit(E);\n    }, l.onExiting = function(E) {\n      var _ = l.resolveArguments(E), k = _[0];\n      l.addClass(k, \"exit\", \"active\"), l.props.onExiting && l.props.onExiting(E);\n    }, l.onExited = function(E) {\n      var _ = l.resolveArguments(E), k = _[0];\n      l.removeClasses(k, \"exit\"), l.addClass(k, \"exit\", \"done\"), l.props.onExited && l.props.onExited(E);\n    }, l.resolveArguments = function(E, _) {\n      return l.props.nodeRef ? [l.props.nodeRef.current, E] : [E, _];\n    }, l.getClassNames = function(E) {\n      var _ = l.props.classNames, k = typeof _ == \"string\", L = k && _ ? _ + \"-\" : \"\", M = k ? \"\" + L + E : _[E], $ = k ? M + \"-active\" : _[E + \"Active\"], J = k ? M + \"-done\" : _[E + \"Done\"];\n      return {\n        baseClassName: M,\n        activeClassName: $,\n        doneClassName: J\n      };\n    }, l;\n  }\n  var c = u.prototype;\n  return c.addClass = function(v, S, g) {\n    var E = this.getClassNames(S)[g + \"ClassName\"], _ = this.getClassNames(\"enter\"), k = _.doneClassName;\n    S === \"appear\" && g === \"done\" && k && (E += \" \" + k), g === \"active\" && v && forceReflow(v), E && (this.appliedClasses[S][g] = E, _addClass(v, E));\n  }, c.removeClasses = function(v, S) {\n    var g = this.appliedClasses[S], E = g.base, _ = g.active, k = g.done;\n    this.appliedClasses[S] = {}, E && removeClass(v, E), _ && removeClass(v, _), k && removeClass(v, k);\n  }, c.render = function() {\n    var v = this.props;\n    v.classNames;\n    var S = _objectWithoutPropertiesLoose(v, [\"classNames\"]);\n    return /* @__PURE__ */ React.createElement(Transition$1, _extends({}, S, {\n      onEnter: this.onEnter,\n      onEntered: this.onEntered,\n      onEntering: this.onEntering,\n      onExit: this.onExit,\n      onExiting: this.onExiting,\n      onExited: this.onExited\n    }));\n  }, u;\n}(React.Component);\nCSSTransition.defaultProps = {\n  classNames: \"\"\n};\nCSSTransition.propTypes = process.env.NODE_ENV !== \"production\" ? _extends({}, Transition$1.propTypes, {\n  /**\n   * The animation classNames applied to the component as it appears, enters,\n   * exits or has finished the transition. A single name can be provided, which\n   * will be suffixed for each stage, e.g. `classNames=\"fade\"` applies:\n   *\n   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`\n   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`\n   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`\n   *\n   * A few details to note about how these classes are applied:\n   *\n   * 1. They are _joined_ with the ones that are already defined on the child\n   *    component, so if you want to add some base styles, you can use\n   *    `className` without worrying that it will be overridden.\n   *\n   * 2. If the transition component mounts with `in={false}`, no classes are\n   *    applied yet. You might be expecting `*-exit-done`, but if you think\n   *    about it, a component cannot finish exiting if it hasn't entered yet.\n   *\n   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This\n   *    allows you to define different behavior for when appearing is done and\n   *    when regular entering is done, using selectors like\n   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply\n   *    an epic entrance animation when element first appears in the DOM using\n   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can\n   *    simply use `fade-enter-done` for defining both cases.\n   *\n   * Each individual classNames can also be specified independently like:\n   *\n   * ```js\n   * classNames={{\n   *  appear: 'my-appear',\n   *  appearActive: 'my-active-appear',\n   *  appearDone: 'my-done-appear',\n   *  enter: 'my-enter',\n   *  enterActive: 'my-active-enter',\n   *  enterDone: 'my-done-enter',\n   *  exit: 'my-exit',\n   *  exitActive: 'my-active-exit',\n   *  exitDone: 'my-done-exit',\n   * }}\n   * ```\n   *\n   * If you want to set these classes using CSS Modules:\n   *\n   * ```js\n   * import styles from './styles.css';\n   * ```\n   *\n   * you might want to use camelCase in your CSS file, that way could simply\n   * spread them instead of listing them one by one:\n   *\n   * ```js\n   * classNames={{ ...styles }}\n   * ```\n   *\n   * @type {string | {\n   *  appear?: string,\n   *  appearActive?: string,\n   *  appearDone?: string,\n   *  enter?: string,\n   *  enterActive?: string,\n   *  enterDone?: string,\n   *  exit?: string,\n   *  exitActive?: string,\n   *  exitDone?: string,\n   * }}\n   */\n  classNames: classNamesShape,\n  /**\n   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is\n   * applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEnter: PropTypes.func,\n  /**\n   * A `<Transition>` callback fired immediately after the 'enter-active' or\n   * 'appear-active' class is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEntering: PropTypes.func,\n  /**\n   * A `<Transition>` callback fired immediately after the 'enter' or\n   * 'appear' classes are **removed** and the `done` class is added to the DOM node.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed.\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEntered: PropTypes.func,\n  /**\n   * A `<Transition>` callback fired immediately after the 'exit' class is\n   * applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed\n   *\n   * @type Function(node: HtmlElement)\n   */\n  onExit: PropTypes.func,\n  /**\n   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed\n   *\n   * @type Function(node: HtmlElement)\n   */\n  onExiting: PropTypes.func,\n  /**\n   * A `<Transition>` callback fired immediately after the 'exit' classes\n   * are **removed** and the `exit-done` class is added to the DOM node.\n   *\n   * **Note**: when `nodeRef` prop is passed, `node` is not passed\n   *\n   * @type Function(node: HtmlElement)\n   */\n  onExited: PropTypes.func\n}) : {};\nconst CSSTransition$1 = CSSTransition;\nvar _leaveRenders, _enterRenders;\nfunction areChildrenDifferent(a, u) {\n  return !(a === u || React.isValidElement(a) && React.isValidElement(u) && a.key != null && a.key === u.key);\n}\nvar modes = {\n  out: \"out-in\",\n  in: \"in-out\"\n}, callHook = function a(u, c, l) {\n  return function() {\n    var v;\n    u.props[c] && (v = u.props)[c].apply(v, arguments), l();\n  };\n}, leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(a) {\n  var u = a.current, c = a.changeState;\n  return React.cloneElement(u, {\n    in: !1,\n    onExited: callHook(u, \"onExited\", function() {\n      c(ENTERING, null);\n    })\n  });\n}, _leaveRenders[modes.in] = function(a) {\n  var u = a.current, c = a.changeState, l = a.children;\n  return [u, React.cloneElement(l, {\n    in: !0,\n    onEntered: callHook(l, \"onEntered\", function() {\n      c(ENTERING);\n    })\n  })];\n}, _leaveRenders), enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(a) {\n  var u = a.children, c = a.changeState;\n  return React.cloneElement(u, {\n    in: !0,\n    onEntered: callHook(u, \"onEntered\", function() {\n      c(ENTERED, React.cloneElement(u, {\n        in: !0\n      }));\n    })\n  });\n}, _enterRenders[modes.in] = function(a) {\n  var u = a.current, c = a.children, l = a.changeState;\n  return [React.cloneElement(u, {\n    in: !1,\n    onExited: callHook(u, \"onExited\", function() {\n      l(ENTERED, React.cloneElement(c, {\n        in: !0\n      }));\n    })\n  }), React.cloneElement(c, {\n    in: !0\n  })];\n}, _enterRenders), SwitchTransition = /* @__PURE__ */ function(a) {\n  _inheritsLoose(u, a);\n  function u() {\n    for (var l, v = arguments.length, S = new Array(v), g = 0; g < v; g++)\n      S[g] = arguments[g];\n    return l = a.call.apply(a, [this].concat(S)) || this, l.state = {\n      status: ENTERED,\n      current: null\n    }, l.appeared = !1, l.changeState = function(E, _) {\n      _ === void 0 && (_ = l.state.current), l.setState({\n        status: E,\n        current: _\n      });\n    }, l;\n  }\n  var c = u.prototype;\n  return c.componentDidMount = function() {\n    this.appeared = !0;\n  }, u.getDerivedStateFromProps = function(v, S) {\n    return v.children == null ? {\n      current: null\n    } : S.status === ENTERING && v.mode === modes.in ? {\n      status: ENTERING\n    } : S.current && areChildrenDifferent(S.current, v.children) ? {\n      status: EXITING\n    } : {\n      current: React.cloneElement(v.children, {\n        in: !0\n      })\n    };\n  }, c.render = function() {\n    var v = this.props, S = v.children, g = v.mode, E = this.state, _ = E.status, k = E.current, L = {\n      children: S,\n      current: k,\n      changeState: this.changeState,\n      status: _\n    }, M;\n    switch (_) {\n      case ENTERING:\n        M = enterRenders[g](L);\n        break;\n      case EXITING:\n        M = leaveRenders[g](L);\n        break;\n      case ENTERED:\n        M = k;\n    }\n    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {\n      value: {\n        isMounting: !this.appeared\n      }\n    }, M);\n  }, u;\n}(React.Component);\nSwitchTransition.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * Transition modes.\n   * `out-in`: Current element transitions out first, then when complete, the new element transitions in.\n   * `in-out`: New element transitions in first, then when complete, the current element transitions out.\n   *\n   * @type {'out-in'|'in-out'}\n   */\n  mode: PropTypes.oneOf([modes.in, modes.out]),\n  /**\n   * Any `Transition` or `CSSTransition` component.\n   */\n  children: PropTypes.oneOfType([PropTypes.element.isRequired])\n} : {};\nSwitchTransition.defaultProps = {\n  mode: modes.out\n};\nconst SwitchTransition$1 = SwitchTransition, Animations = {\n  \"fade-in\": \".fade-in{-webkit-animation:fade-in;animation:fade-in}@-webkit-keyframes fade-in{0%{opacity:0}100%{opacity:1}}@keyframes fade-in{0%{opacity:0}100%{opacity:1}}\",\n  \"fade-out\": \".fade-out{-webkit-animation:fade-out;animation:fade-out}@-webkit-keyframes fade-out{0%{opacity:1}100%{opacity:0}}@keyframes fade-out{0%{opacity:1}100%{opacity:0}}\",\n  \"slide-in-blurred-top\": \".slide-in-blurred-top{-webkit-animation:slide-in-blurred-top .6s cubic-bezier(.23,1.000,.32,1.000) both;animation:slide-in-blurred-top .6s cubic-bezier(.23,1.000,.32,1.000) both}@-webkit-keyframes slide-in-blurred-top{0%{-webkit-transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform:translateY(-1000px) scaleY(2.5) scaleX(.2);-webkit-transform-origin:50% 0;transform-origin:50% 0;-webkit-filter:blur(40px);filter:blur(40px);opacity:0}100%{-webkit-transform:translateY(0) scaleY(1) scaleX(1);transform:translateY(0) scaleY(1) scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-filter:blur(0);filter:blur(0);opacity:1}}@keyframes slide-in-blurred-top{0%{-webkit-transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform:translateY(-1000px) scaleY(2.5) scaleX(.2);-webkit-transform-origin:50% 0;transform-origin:50% 0;-webkit-filter:blur(40px);filter:blur(40px);opacity:0}100%{-webkit-transform:translateY(0) scaleY(1) scaleX(1);transform:translateY(0) scaleY(1) scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-filter:blur(0);filter:blur(0);opacity:1}}\",\n  \"slide-in-left\": \".slide-in-left{-webkit-animation:slide-in-left .5s cubic-bezier(.25,.46,.45,.94) both;animation:slide-in-left .5s cubic-bezier(.25,.46,.45,.94) both}@-webkit-keyframes slide-in-left{0%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}100%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}}@keyframes slide-in-left{0%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}100%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}}\",\n  \"slide-out-left\": \".slide-out-left{-webkit-animation:slide-out-left .5s cubic-bezier(.55,.085,.68,.53) both;animation:slide-out-left .5s cubic-bezier(.55,.085,.68,.53) both}@-webkit-keyframes slide-out-left{0%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}100%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}}@keyframes slide-out-left{0%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}100%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}}\"\n}, APIKitAnimation = (a) => {\n  const {\n    enter: u,\n    exit: c,\n    children: l,\n    tag: v = \"div\",\n    direction: S = \"normal\",\n    duration: g = 500,\n    id: E,\n    type: _\n  } = a, k = E ? `${_}-${E}` : `${_}-api-kit-animation`;\n  return /* @__PURE__ */ React.createElement(\"div\", {\n    style: {\n      height: \"100%\",\n      width: \"100%\"\n    }\n  }, /* @__PURE__ */ React.createElement(\"style\", {\n    dangerouslySetInnerHTML: {\n      __html: renderStyle(_, u, c, g, S)\n    }\n  }), /* @__PURE__ */ React.createElement(SwitchTransition$1, {\n    mode: \"out-in\"\n  }, /* @__PURE__ */ React.createElement(CSSTransition$1, {\n    key: k,\n    addEndListener: (L, M) => {\n      L.addEventListener(\"transitionend\", M, !1);\n    },\n    classNames: {\n      enter: `${_}-default-enter`,\n      enterActive: u,\n      exit: `${_}-default-leave`,\n      exitActive: c\n    },\n    timeout: g\n  }, /* @__PURE__ */ React.createElement(\"div\", {\n    style: {\n      height: \"100%\",\n      width: \"100%\"\n    }\n  }, l))));\n}, renderStyle = (a, u, c, l, v) => `\n        body {\n          margin: 0;\n          padding: 0;\n        }\n        \n        ${Animations[u]}\n        \n        ${Animations[c]}\n\n        .${a}-transition {\n          transition: opacity ${l}ms ease-out};\n        }\n\n        .${a}-default-enter {\n          opacity: 0;\n        }\n\n        .${a}-default-enter.${u} {\n          animation-direction: ${v};\n          animation-duration: ${l / 1e3}s;\n          animation-fill-mode: both;\n          animation-timing-function: ease-out;\n        }\n\n        .${a}-default-leave {\n          opacity: 1;\n        }\n\n        .${a}-default-leave.${c} {\n          animation-direction: ${v};\n          animation-duration: ${l / 1e3}s;\n          animation-timing-function: ease-out;\n          animation-fill-mode: both;\n        }\n        `, APIKitAnimation$1 = APIKitAnimation;\nvar APIKitAnimationTypes = /* @__PURE__ */ ((a) => (a.FADE_IN = \"fade-in\", a.FADE_OUT = \"fade-out\", a.SLIDE_IN_BLURRED_TOP = \"slide-in-blurred-top\", a.SLIDE_IN_LEFT = \"slide-in-left\", a.SLIDE_OUT_LEFT = \"slide-out-left\", a))(APIKitAnimationTypes || {});\nconst Logo$1 = {\n  name: \"LS-Logo\",\n  sourceType: \"Logo\",\n  create({\n    onUpdate: a\n  }, {\n    sourceProps: u\n  }) {\n    const c = document.createElement(\"div\"), v = getProject(CoreContext.state.activeProjectId).compositor.getRoot(), {\n      x: S\n    } = v.props.size, g = (S ?? 1280) / 1920, E = (L) => L * g + \"px\", _ = ({\n      source: L\n    }) => {\n      var ne;\n      const {\n        src: M,\n        meta: $\n      } = (L == null ? void 0 : L.sourceProps) || {}, {\n        id: J\n      } = L || {}, [V, q] = React.useState(!1);\n      useEffect(() => {\n        q(!1);\n      }, [J]);\n      const {\n        offsetX: G = 40,\n        offsetY: H = 40,\n        height: B = 135,\n        width: Y = 240\n      } = ($ == null ? void 0 : $.style) || {};\n      return /* @__PURE__ */ React.createElement(APIKitAnimation$1, {\n        type: \"logo\",\n        id: J,\n        enter: APIKitAnimationTypes.FADE_IN,\n        exit: APIKitAnimationTypes.FADE_OUT,\n        duration: 400\n      }, /* @__PURE__ */ React.createElement(\"div\", {\n        style: {\n          opacity: V ? 1 : 0,\n          width: \"100%\",\n          height: \"100%\"\n        },\n        className: \"logo-transition\"\n      }, M && /* @__PURE__ */ React.createElement(\"div\", {\n        className: \"logo wrapper\",\n        style: {\n          padding: `${E(H)} ${E(G)}`\n        }\n      }, /* @__PURE__ */ React.createElement(\"img\", {\n        style: {\n          height: \"100%\",\n          width: \"100%\",\n          maxHeight: B ? E(B) : \"none\",\n          maxWidth: Y ? E(Y) : \"none\",\n          ...(ne = u == null ? void 0 : u.meta) == null ? void 0 : ne.style,\n          ...$ == null ? void 0 : $.style\n        },\n        src: M,\n        onLoad: () => q(!0)\n      }))));\n    }, k = (L) => ReactDOM.render(/* @__PURE__ */ React.createElement(_, {\n      source: L\n    }), c);\n    return a((L) => {\n      k({\n        ...L\n      });\n    }), {\n      root: c\n    };\n  }\n}, Iframe = ({\n  url: a,\n  allowFullScreen: u,\n  position: c,\n  display: l,\n  height: v,\n  width: S,\n  overflow: g,\n  styles: E,\n  onLoad: _,\n  id: k,\n  frameBorder: L,\n  className: M,\n  name: $,\n  target: J,\n  iframeRef: V,\n  children: q,\n  src: G\n}) => {\n  const H = Object.assign({\n    src: G || a,\n    target: J || null,\n    style: {\n      position: c || null,\n      display: l || \"block\",\n      overflow: g || null,\n      ...E\n    },\n    name: $ || null,\n    className: M || null,\n    id: k || null,\n    onLoad: _ || null,\n    height: v || \"100%\",\n    width: S || \"100%\",\n    allow: \"autoplay\"\n  });\n  let B = /* @__PURE__ */ Object.create(null);\n  for (let Y of Object.keys(H))\n    H[Y] != null && (B[Y] = H[Y]);\n  for (let Y of Object.keys(B.style))\n    B.style[Y] == null && delete B.style[Y];\n  if (u)\n    if (\"allow\" in B) {\n      const Y = B.allow.replace(\"fullscreen\", \"\");\n      B.allow = `fullscreen ${Y.trim()}`.trim();\n    } else\n      B.allow = \"fullscreen\";\n  return L >= 0 && (B.style.hasOwnProperty(\"border\") || (B.style.border = L)), /* @__PURE__ */ React.createElement(React.Fragment, null, q ? /* @__PURE__ */ React.createElement(\"iframe\", {\n    ref: V,\n    ...B\n  }, q) : /* @__PURE__ */ React.createElement(\"iframe\", {\n    ref: V,\n    ...B\n  }));\n}, Iframe$1 = Iframe, Overlay = {\n  name: \"LS-Overlay\",\n  sourceType: \"Overlay\",\n  create({\n    onUpdate: a,\n    onRemove: u\n  }, {\n    sourceProps: c\n  }) {\n    u(() => {\n      clearInterval(S);\n    });\n    const l = document.createElement(\"div\"), v = getProject(CoreContext.state.activeProjectId).role;\n    let S;\n    const g = ({\n      source: M,\n      setStartAnimation: $\n    }) => {\n      const {\n        src: J,\n        meta: V,\n        height: q,\n        width: G\n      } = (M == null ? void 0 : M.sourceProps) || {}, H = React.useRef(null);\n      useEffect(() => {\n        H.current && (H.current.style.removeProperty(\"transformOrigin\"), H.current.style.removeProperty(\"transform\"));\n      }, [J]);\n      const B = () => {\n        if (H.current) {\n          const ne = getProject(CoreContext.state.activeProjectId).compositor.getRoot(), {\n            x: Z,\n            y: re\n          } = ne.props.size;\n          let oe = H.current.clientWidth, de = H.current.clientHeight, A;\n          oe && de ? A = Math.min(Z / oe, re / de) : A = 1, H.current.style.willChange = \"transform\", H.current.style.transformOrigin = \"0 0\", H.current.style.transform = `scale(${A}) translateZ(0)`, $(!0);\n        }\n      };\n      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Iframe$1, {\n        key: M.id,\n        url: J,\n        frameBorder: 0,\n        iframeRef: H,\n        height: q,\n        width: G,\n        onLoad: B,\n        styles: {\n          ...V == null ? void 0 : V.style\n        }\n      }));\n    }, E = ({\n      source: M,\n      setStartAnimation: $\n    }) => {\n      var A;\n      const {\n        src: J,\n        type: V,\n        meta: q,\n        loop: G\n      } = (M == null ? void 0 : M.sourceProps) || {}, {\n        id: H,\n        sourceType: B\n      } = M || {}, [Y, ne] = React.useState(null), Z = React.useRef(null);\n      console.log(\"Updated current time\", (A = Z == null ? void 0 : Z.current) == null ? void 0 : A.currentTime);\n      const re = React.useCallback((N) => {\n        Z.current = N, ne(N ? N.id : null);\n      }, []), oe = React.useCallback(() => {\n        Z != null && Z.current && Z.current.play().catch(() => {\n          var N;\n          Z.current.muted = !0, (N = Z.current) == null || N.play();\n        });\n      }, [J]), de = React.useCallback(() => {\n        S && clearInterval(S), hasPermission(v, Permission.UpdateProject) && trigger$1(\"VideoEnded\", {\n          id: H,\n          category: V\n        });\n      }, [J]);\n      return React.useEffect(() => {\n        q && (Z != null && Z.current) && Y && hasPermission(v, Permission.ManageSelf) && q != null && q.time && (Z.current.currentTime = Number(q == null ? void 0 : q.time));\n      }, [q == null ? void 0 : q.time, Y]), React.useEffect(() => () => {\n        S && clearInterval(S);\n      }, [H]), React.useEffect(() => {\n        Y ? Z.current && (Z.current.src = J, Z.current.play().catch(() => {\n          Z.current.muted = !0, Z.current.play();\n        }), hasPermission(v, Permission.UpdateProject) && (S = setInterval(() => {\n          if (Z.current.duration) {\n            const N = Z.current.duration - Z.current.currentTime;\n            trigger$1(\"VideoTimeUpdate\", {\n              category: B,\n              id: H,\n              time: Math.floor(N)\n            });\n          }\n        }, 1e3))) : S && clearInterval(S);\n      }, [Y]), /* @__PURE__ */ React.createElement(React.Fragment, {\n        key: H\n      }, J && /* @__PURE__ */ React.createElement(\"video\", {\n        loop: G,\n        id: H,\n        ref: re,\n        style: {\n          ...c.meta.style,\n          ...q.style\n        },\n        onLoadedData: oe,\n        onEnded: de,\n        onCanPlay: () => $(!0)\n      }));\n    }, _ = ({\n      source: M,\n      setStartAnimation: $\n    }) => {\n      const {\n        src: J,\n        meta: V\n      } = (M == null ? void 0 : M.sourceProps) || {}, {\n        id: q\n      } = M || {};\n      return /* @__PURE__ */ React.createElement(React.Fragment, {\n        key: q\n      }, J && /* @__PURE__ */ React.createElement(\"img\", {\n        style: {\n          ...c.meta.style,\n          ...V.style\n        },\n        src: J,\n        onLoad: () => $(!0)\n      }));\n    }, k = ({\n      source: M\n    }) => {\n      const {\n        type: $\n      } = (M == null ? void 0 : M.sourceProps) || {}, {\n        id: J\n      } = M || {}, [V, q] = React.useState(!1);\n      return useEffect(() => {\n        q(!1);\n      }, [J]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {\n        id: J,\n        type: \"overlay\",\n        enter: APIKitAnimationTypes.FADE_IN,\n        exit: APIKitAnimationTypes.FADE_OUT,\n        duration: 400\n      }, /* @__PURE__ */ React.createElement(\"div\", {\n        style: {\n          opacity: V ? 1 : 0\n        },\n        className: \"overlayContainer overlay-transition\"\n      }, J && $ === \"image\" && /* @__PURE__ */ React.createElement(_, {\n        source: M,\n        setStartAnimation: q\n      }), J && $ === \"video\" && /* @__PURE__ */ React.createElement(E, {\n        source: M,\n        setStartAnimation: q\n      }), J && $ === \"custom\" && /* @__PURE__ */ React.createElement(g, {\n        source: M,\n        setStartAnimation: q\n      })));\n    }, L = (M) => ReactDOM.render(/* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(k, {\n      source: M\n    })), l);\n    return a((M) => {\n      L({\n        ...M\n      });\n    }), {\n      root: l\n    };\n  }\n};\nvar functionExpression = /[\\s]*([a-z-]+)[\\s]*\\([\\s]*([^\\)]+)[\\s]*\\)[\\s]*/i, floatExpression = /^(\\-?\\d+\\.?\\d{0,5})/, toFloat = parseFloat;\nfunction ensurePercent(a) {\n  return typeof a == \"number\" ? a : toFloat(a) * 0.01;\n}\nfunction formatPercent(a) {\n  return formatFloat(a * 100) + \"%\";\n}\nfunction formatFloat(a) {\n  return floatExpression.exec(a.toString())[1];\n}\nfunction parseCSSFunction(a) {\n  var u = functionExpression.exec(a);\n  if (!(!u || !u.length))\n    return [u[1]].concat(u[2].split(\",\"));\n}\nfunction cssFunction(a, u) {\n  var c = Array.prototype.join.call(u, \", \");\n  return a + \"(\" + c + \")\";\n}\nvar math = Math, round = math.round;\nfunction roundFloat(a, u) {\n  return round(a * u) / u;\n}\nvar _a, RGB = \"rgb\", HSL = \"hsl\", converters = (_a = {}, _a[RGB + HSL] = RGBtoHSL, _a[HSL + RGB] = HSLtoRGB, _a), maxChannelValues = {\n  r: 255,\n  g: 255,\n  b: 255,\n  h: 360,\n  s: 1,\n  l: 1,\n  a: 1\n};\nfunction color(a) {\n  return parseHexCode(a) || parseColorFunction(a) || rgb(255, 0, 0);\n}\nfunction rgb(a, u, c, l) {\n  return new ColorHelper(\n    RGB,\n    a,\n    u,\n    c,\n    l === void 0 ? 1 : ensurePercent(l),\n    l !== void 0\n    /* hasAlpha*/\n  );\n}\nfunction convertHelper(a, u, c) {\n  var l = u.f, v = u.r, S = u.g, g = u.b, E = u.a, _ = c === void 0 ? u.o : c;\n  return l !== a ? converters[l + a](v, S, g, E, _) : c === void 0 ? u : new ColorHelper(l, v, S, g, E, _);\n}\nvar ColorHelper = (\n  /** @class */\n  function() {\n    function a(u, c, l, v, S, g) {\n      var E = this;\n      E.f = u, E.o = g;\n      var _ = u === HSL;\n      E.r = clampColor(_ ? \"h\" : \"r\", c), E.g = clampColor(_ ? \"s\" : \"g\", l), E.b = clampColor(_ ? \"l\" : \"b\", v), E.a = clampColor(\"a\", S);\n    }\n    return a.prototype.toString = function() {\n      var u = this, c = u.o, l = u.f, v = u.r, S = u.g, g = u.b, E = u.a, _, k;\n      if (l === RGB)\n        _ = c ? \"rgba\" : RGB, k = [round(v), round(S), round(g)];\n      else if (l === HSL)\n        _ = c ? \"hsla\" : HSL, k = [round(v), formatPercent(roundFloat(S, 100)), formatPercent(roundFloat(g, 100))];\n      else\n        throw new Error(\"Invalid color format\");\n      return c && k.push(formatFloat(roundFloat(E, 1e5))), cssFunction(_, k);\n    }, a.prototype.toHexString = function() {\n      var u = convertHelper(RGB, this);\n      return \"#\" + (toHex(u.r) + toHex(u.g) + toHex(u.b)).toUpperCase();\n    }, a.prototype.toHSL = function() {\n      return convertHelper(HSL, this, !1);\n    }, a.prototype.toHSLA = function() {\n      return convertHelper(HSL, this, !0);\n    }, a.prototype.toRGB = function() {\n      return convertHelper(RGB, this, !1);\n    }, a.prototype.toRGBA = function() {\n      return convertHelper(RGB, this, !0);\n    }, a.prototype.red = function() {\n      var u = this;\n      return (u.f === RGB ? u : u.toRGB()).r;\n    }, a.prototype.green = function() {\n      var u = this;\n      return (u.f === RGB ? u : u.toRGB()).g;\n    }, a.prototype.blue = function() {\n      var u = this;\n      return (u.f === RGB ? u : u.toRGB()).b;\n    }, a.prototype.hue = function() {\n      var u = this;\n      return (u.f === HSL ? u : u.toHSL()).r;\n    }, a.prototype.saturation = function() {\n      var u = this;\n      return (u.f === HSL ? u : u.toHSL()).g;\n    }, a.prototype.lightness = function() {\n      var u = this;\n      return (u.f === HSL ? u : u.toHSL()).b;\n    }, a.prototype.alpha = function() {\n      return this.a;\n    }, a.prototype.opacity = function() {\n      return this.a;\n    }, a.prototype.invert = function() {\n      var u = this, c = convertHelper(RGB, u);\n      return convertHelper(u.f, new a(RGB, 255 - c.r, 255 - c.g, 255 - c.b, u.a, u.o));\n    }, a.prototype.lighten = function(u, c) {\n      var l = this, v = convertHelper(HSL, l), S = maxChannelValues.l, g = v.b + (c ? S - v.b : S) * ensurePercent(u);\n      return convertHelper(l.f, new a(HSL, v.r, v.g, g, l.a, l.o));\n    }, a.prototype.darken = function(u, c) {\n      var l = this, v = convertHelper(HSL, l), S = v.b - (c ? v.b : maxChannelValues.l) * ensurePercent(u);\n      return convertHelper(l.f, new a(HSL, v.r, v.g, S, l.a, l.o));\n    }, a.prototype.saturate = function(u, c) {\n      var l = this, v = convertHelper(HSL, l), S = maxChannelValues.s, g = v.g + (c ? S - v.g : S) * ensurePercent(u);\n      return convertHelper(l.f, new a(HSL, v.r, g, v.b, l.a, l.o));\n    }, a.prototype.desaturate = function(u, c) {\n      var l = this, v = convertHelper(HSL, l), S = maxChannelValues.s, g = v.g - (c ? v.g : S) * ensurePercent(u);\n      return convertHelper(l.f, new a(HSL, v.r, g, v.b, l.a, l.o));\n    }, a.prototype.grayscale = function() {\n      return this.desaturate(1);\n    }, a.prototype.fade = function(u) {\n      var c = this, l = clampColor(\"a\", ensurePercent(u));\n      return convertHelper(c.f, new a(c.f, c.r, c.g, c.b, l, !0));\n    }, a.prototype.fadeOut = function(u, c) {\n      var l = this, v = 1, S = clampColor(\"a\", l.a - (c ? l.a : v) * ensurePercent(u));\n      return convertHelper(l.f, new a(l.f, l.r, l.g, l.b, S, !0));\n    }, a.prototype.fadeIn = function(u, c) {\n      var l = this, v = 1, S = clampColor(\"a\", l.a + (c ? l.a : v) * ensurePercent(u));\n      return convertHelper(l.f, new a(l.f, l.r, l.g, l.b, S, !0));\n    }, a.prototype.mix = function(u, c) {\n      var l = this, v = ensureColor(u), S = convertHelper(RGB, l), g = convertHelper(RGB, v), E = c === void 0 ? 0.5 : c, _ = 2 * E - 1, k = Math.abs(S.a - g.a), L = ((_ * k === -1 ? _ : (_ + k) / (1 + _ * k)) + 1) / 2, M = 1 - L, $ = new a(RGB, round(S.r * L + g.r * M), round(S.g * L + g.g * M), round(S.b * L + g.b * M), S.a * E + g.a * (1 - E), l.o || v.o);\n      return convertHelper(this.f, $);\n    }, a.prototype.tint = function(u) {\n      return rgb(255, 255, 255).mix(this, u);\n    }, a.prototype.shade = function(u) {\n      return rgb(0, 0, 0).mix(this, u);\n    }, a.prototype.spin = function(u) {\n      var c = this, l = convertHelper(HSL, c);\n      return convertHelper(c.f, new a(HSL, modDegrees(l.r + u), l.g, l.b, c.a, c.o));\n    }, a;\n  }()\n);\nfunction toHex(a) {\n  var u = round(a);\n  return (u < 16 ? \"0\" : \"\") + u.toString(16);\n}\nfunction modDegrees(a) {\n  return ((a < 0 ? 360 : 0) + a % 360) % 360;\n}\nfunction RGBtoHSL(a, u, c, l, v) {\n  var S = a / 255, g = u / 255, E = c / 255, _ = Math.min(S, g, E), k = Math.max(S, g, E), L = (_ + k) / 2, M = k - _, $;\n  k === _ ? $ = 0 : S === k ? $ = (g - E) / M : g === k ? $ = 2 + (E - S) / M : E === k ? $ = 4 + (S - g) / M : $ = 0, $ = Math.min($ * 60, 360), $ < 0 && ($ += 360);\n  var J;\n  return k === _ ? J = 0 : L <= 0.5 ? J = M / (k + _) : J = M / (2 - k - _), new ColorHelper(HSL, $, J, L, l, v);\n}\nfunction HSLtoRGB(a, u, c, l, v) {\n  var S = a / 360, g = u, E = c;\n  if (g === 0) {\n    var _ = E * 255;\n    return new ColorHelper(RGB, _, _, _, l, v);\n  }\n  for (var k = E < 0.5 ? E * (1 + g) : E + g - E * g, L = 2 * E - k, M = 0, $ = 0, J = 0, V = 0; V < 3; V++) {\n    var q = S + 0.3333333333333333 * -(V - 1);\n    q < 0 && q++, q > 1 && q--;\n    var _ = void 0;\n    6 * q < 1 ? _ = L + (k - L) * 6 * q : 2 * q < 1 ? _ = k : 3 * q < 2 ? _ = L + (k - L) * (2 / 3 - q) * 6 : _ = L, _ *= 255, V === 0 ? M = _ : V === 1 ? $ = _ : J = _;\n  }\n  return new ColorHelper(RGB, M, $, J, l, v);\n}\nfunction clampColor(a, u) {\n  var c = 0, l = maxChannelValues[a];\n  return u < c ? c : u > l ? l : u;\n}\nfunction ensureColor(a) {\n  return a instanceof ColorHelper ? a : color(a);\n}\nfunction parseHexCode(a) {\n  var u = a.match(/#(([a-f0-9]{6})|([a-f0-9]{3}))$/i);\n  if (u) {\n    var c = u[1], l = parseInt(c.length === 3 ? c[0] + c[0] + c[1] + c[1] + c[2] + c[2] : c, 16), v = l >> 16 & 255, S = l >> 8 & 255, g = l & 255;\n    return new ColorHelper(RGB, v, S, g, 1, !1);\n  }\n}\nfunction parseColorFunction(a) {\n  var u = parseCSSFunction(a);\n  if (!(!u || !(u.length === 4 || u.length === 5))) {\n    var c = u[0], l = c === \"rgba\", v = c === \"hsla\", S = c === RGB, g = c === HSL, E = v || l, _;\n    if (S || l)\n      _ = RGB;\n    else if (g || v)\n      _ = HSL;\n    else\n      throw new Error(\"unsupported color string\");\n    var k = toFloat(u[1]), L = S || l ? toFloat(u[2]) : ensurePercent(u[2]), M = S || l ? toFloat(u[3]) : ensurePercent(u[3]), $ = E ? toFloat(u[4]) : 1;\n    return new ColorHelper(_, k, L, M, $, E);\n  }\n}\nconst of = color, transparent = color(\"rgba(0,0,0,0)\"), white = color(\"#ffffff\"), black = color(\"#000000\"), weights = {\n  primary: {\n    50: \"#EAFAF5\",\n    100: \"#D5F6EB\",\n    200: \"#ABEDD7\",\n    300: \"#82E3C3\",\n    400: \"#58DAAF\",\n    500: \"#26AD80\",\n    600: \"#25A77C\",\n    700: \"#1C7D5D\",\n    800: \"#12543E\"\n  },\n  secondary: {\n    50: \"#FBEAEA\",\n    100: \"#F7D4D4\",\n    200: \"#EFA9A9\",\n    300: \"#E77E7E\",\n    400: \"#FF6F64\",\n    500: \"#E9554A\",\n    600: \"#CB362B\",\n    700: \"#811818\",\n    800: \"#561010\"\n  },\n  neutral: {\n    0: \"#ffffff\",\n    10: \"#f5f5f5\",\n    200: \"#d9d9d9\",\n    300: \"#bababa\",\n    350: \"#999999\",\n    400: \"#9e9e9e\",\n    500: \"#808080\",\n    600: \"#666666\",\n    700: \"#4d4d4d\",\n    800: \"#303030\",\n    900: \"#141414\",\n    1e3: \"#000000\"\n  },\n  warning: {\n    400: \"#FFC28A\",\n    500: \"#FFAE64\",\n    600: \"#F29540\"\n  }\n}, types = Object.keys(weights), weight = (a) => (u) => {\n  const c = weights[a];\n  if (c[u])\n    return c[u];\n  const l = Object.keys(weights.primary).map(Number), v = l.find((S) => u <= S);\n  return v ? c[v] : c[l.slice(l.length - 1)[0]];\n}, primary = weight(\"primary\"), neutral = weight(\"neutral\"), secondary = weight(\"secondary\"), warning = weight(\"warning\"), lightstream = color(\"#26ad80\"), twitch = color(\"#9156ff\"), linkedin = color(\"#2867b2\"), youtube = color(\"#ff0000\"), facebook = color(\"#1877f2\"), twitter = color(\"#1da1f2\"), Color = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  black,\n  color,\n  facebook,\n  lightstream,\n  linkedin,\n  neutral,\n  of,\n  primary,\n  secondary,\n  transparent,\n  twitch,\n  twitter,\n  types,\n  warning,\n  white,\n  youtube\n}, Symbol.toStringTag, { value: \"Module\" })), YouTube = /* @__PURE__ */ React.createElement(\"svg\", {\n  style: {\n    flex: \"0 0 100%\"\n  },\n  viewBox: \"0 0 24 24\"\n}, /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M19.6465 8.53711C19.4707 7.83398 18.9141 7.27734 18.2402 7.10156C16.9805 6.75 12 6.75 12 6.75C12 6.75 6.99023 6.75 5.73047 7.10156C5.05664 7.27734 4.5 7.83398 4.32422 8.53711C3.97266 9.76758 3.97266 12.4043 3.97266 12.4043C3.97266 12.4043 3.97266 15.0117 4.32422 16.2715C4.5 16.9746 5.05664 17.502 5.73047 17.6777C6.99023 18 12 18 12 18C12 18 16.9805 18 18.2402 17.6777C18.9141 17.502 19.4707 16.9746 19.6465 16.2715C19.998 15.0117 19.998 12.4043 19.998 12.4043C19.998 12.4043 19.998 9.76758 19.6465 8.53711ZM10.3594 14.7773V10.0312L14.5195 12.4043L10.3594 14.7773Z\"\n})), YouTubeDuo = /* @__PURE__ */ React.createElement(\"svg\", {\n  style: {\n    flex: \"0 0 100%\"\n  },\n  viewBox: \"0 0 24 24\"\n}, /* @__PURE__ */ React.createElement(\"rect\", {\n  x: \"8\",\n  y: \"9\",\n  width: \"9\",\n  height: \"7\",\n  fill: neutral(0)\n}), /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M19.6465 8.53711C19.4707 7.83398 18.9141 7.27734 18.2402 7.10156C16.9805 6.75 12 6.75 12 6.75C12 6.75 6.99023 6.75 5.73047 7.10156C5.05664 7.27734 4.5 7.83398 4.32422 8.53711C3.97266 9.76758 3.97266 12.4043 3.97266 12.4043C3.97266 12.4043 3.97266 15.0117 4.32422 16.2715C4.5 16.9746 5.05664 17.502 5.73047 17.6777C6.99023 18 12 18 12 18C12 18 16.9805 18 18.2402 17.6777C18.9141 17.502 19.4707 16.9746 19.6465 16.2715C19.998 15.0117 19.998 12.4043 19.998 12.4043C19.998 12.4043 19.998 9.76758 19.6465 8.53711ZM10.3594 14.7773V10.0312L14.5195 12.4043L10.3594 14.7773Z\"\n})), Facebook = /* @__PURE__ */ React.createElement(\"svg\", {\n  style: {\n    flex: \"0 0 100%\"\n  },\n  viewBox: \"0 0 24 24\"\n}, /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M15.4863 13.3125L15.8965 10.6172H13.2891V8.85938C13.2891 8.09766 13.6406 7.39453 14.8125 7.39453H16.0137V5.08008C16.0137 5.08008 14.9297 4.875 13.9043 4.875C11.7656 4.875 10.3594 6.19336 10.3594 8.53711V10.6172H7.95703V13.3125H10.3594V19.875H13.2891V13.3125H15.4863Z\"\n})), FacebookCircle = /* @__PURE__ */ React.createElement(\"svg\", {\n  style: {\n    flex: \"0 0 100%\"\n  },\n  viewBox: \"0 0 24 24\"\n}, /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M19.2656 12.375C19.2656 8.36133 16.0137 5.10938 12 5.10938C7.98633 5.10938 4.73438 8.36133 4.73438 12.375C4.73438 16.0078 7.37109 19.0254 10.8574 19.5527V14.4844H9.01172V12.375H10.8574V10.793C10.8574 8.97656 11.9414 7.95117 13.582 7.95117C14.4023 7.95117 15.2227 8.09766 15.2227 8.09766V9.88477H14.3145C13.4062 9.88477 13.1133 10.4414 13.1133 11.0273V12.375H15.1348L14.8125 14.4844H13.1133V19.5527C16.5996 19.0254 19.2656 16.0078 19.2656 12.375Z\"\n})), Twitch = /* @__PURE__ */ React.createElement(\"svg\", {\n  style: {\n    flex: \"0 0 100%\"\n  },\n  viewBox: \"0 0 24 24\"\n}, /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M16.9551 8.92188H15.8125V12.1445H16.9551V8.92188ZM13.8496 8.89258H12.707V12.1152H13.8496V8.89258ZM9.01562 5.875L6.20312 8.57031V18.209H9.60156V20.875L12.4141 18.209H14.6699L19.7676 13.375V5.875H9.01562ZM18.6543 12.8477L16.3691 14.9863H14.1133L12.1504 16.8613V14.9863H9.60156V6.95898H18.6543V12.8477Z\"\n})), TwitchDuo = /* @__PURE__ */ React.createElement(\"svg\", {\n  style: {\n    flex: \"0 0 100%\"\n  },\n  viewBox: \"0 0 24 24\"\n}, /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M19 6.5H9L8.8125 17.5H13.5L19 13V6.5Z\",\n  fill: neutral(0)\n}), /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M16.9551 8.92188H15.8125V12.1445H16.9551V8.92188ZM13.8496 8.89258H12.707V12.1152H13.8496V8.89258ZM9.01562 5.875L6.20312 8.57031V18.209H9.60156V20.875L12.4141 18.209H14.6699L19.7676 13.375V5.875H9.01562ZM18.6543 12.8477L16.3691 14.9863H14.1133L12.1504 16.8613V14.9863H9.60156V6.95898H18.6543V12.8477Z\"\n})), Twitter = /* @__PURE__ */ React.createElement(\"svg\", {\n  style: {\n    flex: \"0 0 100%\"\n  },\n  viewBox: \"0 0 24 24\"\n}, /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M20.6681 7.98749C20.6806 8.16248 20.6806 8.33751 20.6806 8.5125C20.6806 13.85 16.6197 20 9.1976 20C6.91098 20 4.78681 19.3375 3 18.1875C3.32489 18.225 3.63723 18.2375 3.97462 18.2375C5.86136 18.2375 7.59821 17.6 8.98518 16.5125C7.21086 16.475 5.72393 15.3125 5.21162 13.7125C5.46155 13.75 5.71143 13.775 5.97386 13.775C6.33621 13.775 6.69859 13.725 7.03594 13.6375C5.18666 13.2625 3.79966 11.6375 3.79966 9.67499V9.62501C4.33693 9.92501 4.96174 10.1125 5.62393 10.1375C4.53685 9.41247 3.82466 8.17498 3.82466 6.77497C3.82466 6.02499 4.02454 5.33749 4.37443 4.73748C6.36117 7.18748 9.34753 8.78745 12.6962 8.96248C12.6337 8.66248 12.5962 8.35001 12.5962 8.03751C12.5962 5.81248 14.3955 4 16.6322 4C17.7942 4 18.8438 4.4875 19.581 5.275C20.4931 5.10001 21.3678 4.76249 22.1425 4.3C21.8426 5.23752 21.2054 6.02502 20.3682 6.52499C21.1804 6.43753 21.9676 6.21248 22.6923 5.90001C22.1426 6.69998 21.4553 7.41245 20.6681 7.98749Z\"\n})), LinkedIn = /* @__PURE__ */ React.createElement(\"svg\", {\n  style: {\n    flex: \"0 0 100%\"\n  },\n  viewBox: \"0 0 24 24\"\n}, /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M19.2 3H4.8C3.81 3 3.009 3.81 3.009 4.8L3 19.2C3 20.19 3.81 21 4.8 21H19.2C20.19 21 21 20.19 21 19.2V4.8C21 3.81 20.19 3 19.2 3ZM8.4 18.3H5.7V10.2H8.4V18.3ZM7.05 8.679C6.15 8.679 5.421 7.95 5.421 7.05C5.421 6.15 6.15 5.421 7.05 5.421C7.95 5.421 8.679 6.15 8.679 7.05C8.679 7.95 7.95 8.679 7.05 8.679ZM18.3 18.3H15.6V13.53C15.6 12.783 14.997 12.18 14.25 12.18C13.503 12.18 12.9 12.783 12.9 13.53V18.3H10.2V10.2H12.9V11.28C13.368 10.524 14.331 10.02 15.15 10.02C16.887 10.02 18.3 11.433 18.3 13.17V18.3Z\"\n})), Lightstream = /* @__PURE__ */ React.createElement(\"svg\", {\n  style: {\n    flex: \"0 0 100%\"\n  },\n  viewBox: \"0.144 0 27.712 24\"\n}, /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M16.0369 12.1232L14 15.6518L11.5642 11.4335L6.27356 10.6176L14 24L20.4627 12.805L16.0369 12.1232Z\"\n}), /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M9.74033 8.27418L7.37317 4.17409H20.6268L19.0921 6.83194L24.3827 6.01602L27.8558 0H0.144165L5.31453 8.95665L9.74033 8.27418Z\"\n})), LightstreamWithText = /* @__PURE__ */ React.createElement(\"svg\", {\n  style: {\n    flex: \"0 0 100%\"\n  },\n  viewBox: \"0 0 3000 524\"\n}, /* @__PURE__ */ React.createElement(\"polygon\", {\n  points: \"330.56 263.5 299.73 316.91 262.86 253.06 182.78 240.71 299.73 443.27 397.55 273.82 330.56 263.5\"\n}), /* @__PURE__ */ React.createElement(\"polygon\", {\n  points: \"235.25 205.24 199.42 143.18 400.03 143.18 376.8 183.41 456.88 171.06 509.45 80 90 80 168.26 215.57 235.25 205.24\"\n}), /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M646.32,345.72h94.91v13.73H630V167.26h16.36Z\"\n}), /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M846.24,359.45H830V167.26h16.23Z\"\n}), /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M1091.16,336.61q-8.45,12-26.46,18.74t-40.33,6.73q-22.57,0-40.13-10.82t-27.19-30.62q-9.64-19.8-9.77-45.41V250.95q0-40,20.2-63.16t54.25-23.17q29.69,0,47.78,15.11T1091,221.38h-16.24q-3.56-21.18-17.23-32.11t-35.7-10.92q-26.92,0-42.64,19.15t-15.71,54v22.72q0,21.93,7.46,38.77t21.38,26.09q13.92,9.25,32,9.25,21,0,36-6.6,9.76-4.36,14.52-10.16V282h-51.61V268.24h67.85Z\"\n}), /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M1333.71,359.45h-16.37V278.11H1207.53v81.33h-16.23V167.26h16.23v97.12h109.81V167.26h16.37Z\"\n}), /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M1563.2,181h-65.87V359.45H1481.1V181h-65.73V167.26H1563.2Z\"\n}), /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M1990.75,181h-65.87V359.45h-16.23V181h-65.73V167.26h147.83Z\"\n}), /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M2147.65,279.33h-55.84v80.12h-16.36V167.26h62.43q30.75,0,48,14.9t17.29,41.66a52,52,0,0,1-10.83,32.56q-10.82,14.11-29,19.51l48,81.83v1.72h-17.29Zm-55.84-13.73h49.76q20.45,0,32.86-11.63t12.41-30.14q0-20.36-12.93-31.59T2137.61,181h-45.8Z\"\n}), /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M2407.62,278.11h-89.88v67.61h103.35v13.73H2301.5V167.26h118.92V181H2317.73v83.39h89.88Z\"\n}), /* @__PURE__ */ React.createElement(\"polygon\", {\n  points: \"2892.79 183.67 2892.79 183.67 2816.23 326.97 2724.06 154.45 2724.06 189.54 2724.06 359.75 2739.67 359.75 2739.67 218.3 2816.26 359.42 2892.79 218.32 2892.79 359.75 2908.4 359.75 2908.4 189.54 2908.4 154.45 2892.79 183.67\"\n}), /* @__PURE__ */ React.createElement(\"polygon\", {\n  points: \"2649.77 359.45 2569.47 154.54 2569.47 154.53 2569.46 154.53 2569.46 154.53 2569.46 154.54 2489.16 359.45 2506.19 359.45 2569.46 194.32 2632.74 359.45 2649.77 359.45\"\n}), /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M1764.57,287q-6.73-10.56-20.06-18.15a131.55,131.55,0,0,0-21.47-9.18l-7.64,13.49q19.65,6.61,28.32,13.77,11.22,9.3,11.22,25.28,0,16.37-13.6,26.26t-36,9.9c-11.35,0-21.05-1.94-29.35-5.51l-7,12.33a94,94,0,0,0,36.33,6.91q29.7,0,47.85-13.73t18.15-36.43Q1771.3,297.55,1764.57,287Z\"\n}), /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M1659.11,250.93c7.28,5.25,18,10.18,32.13,14.79l7.72-13.38q-21-6.41-31.29-14.49Q1655.95,228.61,1656,214q0-15.83,13-25.66t35-9.83c13.12,0,23.78,3.19,32.26,9.21l7.23-12.51c-1.71-1-3.43-2.1-5.3-3q-15.09-7.38-34.18-7.38-28.19,0-46.31,13.76t-18.11,35.77Q1639.62,237,1659.11,250.93Z\"\n}), /* @__PURE__ */ React.createElement(\"path\", {\n  d: \"M1744.34,268.78a129.23,129.23,0,0,0-21.68-9.32l-7.79,13.49c13.28,4.44,22.87,9.06,28.68,13.88q11.2,9.29,11.2,25.23,0,16.33-13.57,26.21t-36,9.88c-11.8,0-21.85-2-30.34-5.91l-7.08,12.26.2.1a93.63,93.63,0,0,0,37.22,7.25q29.64,0,47.75-13.7t18.11-36.36q0-14.36-6.72-24.9T1744.34,268.78Z\"\n})), IconMap = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  Facebook,\n  FacebookCircle,\n  Lightstream,\n  LightstreamWithText,\n  LinkedIn,\n  Twitch,\n  TwitchDuo,\n  Twitter,\n  YouTube,\n  YouTubeDuo\n}, Symbol.toStringTag, { value: \"Module\" })), nudge = (a) => {\n  if (a.nudgeUp || a.nudgeDown || a.nudgeRight || a.nudgeLeft)\n    return {\n      position: \"relative\",\n      top: a.nudgeDown,\n      left: a.nudgeRight,\n      right: a.nudgeLeft,\n      bottom: a.nudgeUp\n    };\n}, SVGWrapper = ({\n  children: a,\n  width: u,\n  height: c,\n  color: l,\n  colorWeight: v = 0,\n  marginLeft: S,\n  marginTop: g,\n  marginRight: E,\n  marginBottom: _,\n  className: k,\n  ...L\n}) => (l && Color[l](v), /* @__PURE__ */ React.createElement(\"div\", {\n  className: k,\n  style: {\n    ...nudge(L),\n    display: \"flex\",\n    justifyContent: \"center\",\n    flexBasis: u || \"auto\",\n    flexShrink: 0,\n    width: u,\n    height: c || u && \"fit-content\",\n    marginLeft: S,\n    marginTop: g,\n    marginBottom: _,\n    marginRight: E\n  }\n}, a)), Icon = ({\n  name: a,\n  ...u\n}) => /* @__PURE__ */ React.createElement(SVGWrapper, {\n  ...u\n}, IconMap[a]), Icon$1 = Icon, dragImageSvg = `\n  <svg height=\"75\" width=\"120\" viewBox=\"0 0 120 75\" xmlns=\"http://www.w3.org/2000/svg\" style=\"\">\n    <rect width=\"120\" height=\"75\" rx=\"3\" style=\"\n      opacity: 0.4;\n      stroke: white;\n      stroke-width: 3px;\n      stroke-opacity: 0.7;\n    \"/>\n  </svg>`;\nlet dragImage;\nconst loadDragImage = () => dragImage || (dragImage = new Image(), dragImage.src = URL.createObjectURL(new Blob([dragImageSvg], {\n  type: \"image/svg+xml\"\n})), dragImage);\nclass ErrorBoundary extends React.Component {\n  constructor(u) {\n    super(u), this.state = {\n      error: null\n    };\n  }\n  componentDidCatch(u, c) {\n    log$1.warn(u, c);\n  }\n  static getDerivedStateFromError() {\n    return {\n      error: !0\n    };\n  }\n  render() {\n    return this.state.error ? null : this.props.children;\n  }\n}\nconst onDrop = async (a, u) => {\n  u.preventDefault(), u.stopPropagation();\n  const {\n    dropNodeId: c,\n    dropType: l,\n    project: v\n  } = a, S = u.dataTransfer.getData(\"text/plain\");\n  if (log$1.debug(\"Compositor: Dropping\", {\n    dropType: l,\n    dragNodeId: S,\n    dropNodeId: c\n  }), c === S)\n    return;\n  const [g, E, _, k] = await Promise.all([v.compositor.get(S), v.compositor.get(c), v.compositor.getParent(S), v.compositor.getParent(c)]);\n  if (l === \"layout\")\n    return _.id === c ? void 0 : CoreContext.Command.moveNode({\n      projectId: v.id,\n      nodeId: g.id,\n      parentId: E.id\n    });\n  if (_.id !== (k == null ? void 0 : k.id))\n    return CoreContext.Command.swapNodes({\n      projectId: v.id,\n      nodeAId: g.id,\n      nodeBId: E.id\n    });\n  const L = _.children.map((M) => M.id);\n  return CoreContext.Command.reorderNodes({\n    projectId: v.id,\n    parentId: _.id,\n    childIds: swapItems(g.id, E.id, L)\n  });\n};\nlet foundDropTarget = !1;\nconst ElementTree = (a) => {\n  var Y, ne;\n  const u = useRef(!1), c = useRef(), l = useRef(), v = useRef(), {\n    project: S,\n    interactive: g = !0,\n    onElementDoubleClick: E,\n    checkIsDragTarget: _,\n    checkIsDropTarget: k\n  } = useContext(CompositorContext), {\n    nodeId: L\n  } = a, M = S.compositor.get(L);\n  if (!M)\n    return null;\n  const $ = CoreContext.compositor.getElement(M), J = M.props.layout || \"Row\", V = g && _(M), q = g && k(M);\n  let G = q ? {\n    onDrop: (Z) => (foundDropTarget = !0, onDrop({\n      dropType: \"layout\",\n      dropNodeId: M.id,\n      project: S\n    }, Z)),\n    onDragOver: (Z) => {\n      var re;\n      Z.preventDefault(), Z.stopPropagation(), (re = v.current) == null || re.toggleAttribute(\"data-layout-drop-target-active\", !0);\n    },\n    onDragLeave: (Z) => {\n      var re;\n      Z.preventDefault(), Z.stopPropagation(), (re = v.current) == null || re.toggleAttribute(\"data-layout-drop-target-active\", !1);\n    }\n  } : {}, H = V ? {\n    draggable: !0,\n    // If a target is draggable, it will also be treated as\n    //  a drop target (swap element positions)\n    ondrop: (Z) => (foundDropTarget = !0, onDrop(\n      {\n        dropType: \"transform\",\n        dropNodeId: M.id,\n        project: S\n      },\n      // @ts-ignore TODO: Convert all to native drag events\n      Z\n    )),\n    ondragstart: (Z) => {\n      var re;\n      u.current = !0, wrapperEl.toggleAttribute(\"data-dragging\", !0), log$1.debug(\"Compositor: Dragging\", M.id), foundDropTarget = !1, Z.dataTransfer.setData(\"text/plain\", M.id), Z.dataTransfer.dropEffect = \"move\", Z.dataTransfer.setDragImage(dragImage, 10, 10), (re = v.current) == null || re.toggleAttribute(\"data-drag-target-active\", !0), window.__dragging = !0;\n    },\n    ondragend: (Z) => {\n      var re;\n      u.current = !1, foundDropTarget || (log$1.info(\"Compositor: No drop target - deleting node\", M), CoreContext.Command.deleteNode({\n        nodeId: M.id\n      })), wrapperEl.toggleAttribute(\"data-dragging\", !0), log$1.debug(\"Compositor: DragEnd\", Z), (re = v.current) == null || re.toggleAttribute(\"data-drag-target-active\", !1), wrapperEl.querySelectorAll(\"[data-item]\").forEach((oe) => {\n        oe.toggleAttribute(\"data-drag-target-active\", !1), oe.toggleAttribute(\"data-layout-drop-target-active\", !1), oe.toggleAttribute(\"data-transform-drop-target-active\", !1);\n      }), window.__dragging = !1;\n    },\n    ondragover: (Z) => {\n      var re;\n      Z.preventDefault(), Z.stopPropagation(), !u.current && ((re = v.current) == null || re.toggleAttribute(\"data-transform-drop-target-active\", !0));\n    },\n    ondragleave: (Z) => {\n      var re;\n      Z.preventDefault(), Z.stopPropagation(), (re = v.current) == null || re.toggleAttribute(\"data-transform-drop-target-active\", !1);\n    }\n  } : {};\n  useEffect(() => {\n    l.current && $ && (l.current.appendChild($.root), Object.assign(l.current.style, {\n      width: \"100%\",\n      height: \"100%\",\n      position: \"relative\",\n      overflow: \"hidden\"\n    }), Object.assign($.root.style, {\n      pointerEvents: V ? \"all\" : \"none\",\n      width: \"100%\",\n      height: \"100%\",\n      position: \"relative\",\n      ...M.props.style || {}\n    }));\n  }, [l.current, $]), useEffect(() => {\n    const Z = V ? () => E(M) : () => {\n    };\n    return c.current && (Object.assign(c.current, H), Object.assign(c.current.style, {\n      pointerEvents: V ? \"all\" : \"none\"\n    }), c.current.addEventListener(\"dblclick\", Z)), () => {\n      var re;\n      (re = c.current) == null || re.removeEventListener(\"dblclick\", Z);\n    };\n  }, [c.current]);\n  const B = {\n    layout: J,\n    ...M.props.layoutProps ?? {}\n  };\n  return /* @__PURE__ */ React.createElement(\"div\", {\n    ref: v,\n    \"data-id\": M.id + \"-x\",\n    \"data-item\": !0,\n    ...V && {\n      \"data-drag-target\": !0\n    },\n    ...q && {\n      \"data-drop-target\": !0\n    },\n    ...G,\n    style: {\n      position: \"relative\",\n      width: ((Y = M.props.size) == null ? void 0 : Y.x) || \"100%\",\n      height: ((ne = M.props.size) == null ? void 0 : ne.y) || \"100%\",\n      pointerEvents: \"none\"\n    }\n  }, /* @__PURE__ */ React.createElement(\"div\", {\n    className: \"interactive-overlay\",\n    ref: c,\n    style: {\n      height: \"100%\",\n      width: \"100%\",\n      position: \"absolute\",\n      zIndex: 2\n    }\n  }), /* @__PURE__ */ React.createElement(\"div\", {\n    className: \"item-element\",\n    style: {\n      display: \"flex\",\n      flex: \"0 0 auto\",\n      justifyContent: \"center\",\n      width: \"100%\",\n      height: \"100%\"\n    }\n  }, /* @__PURE__ */ React.createElement(\"div\", {\n    ref: l\n  }), /* @__PURE__ */ React.createElement(ErrorBoundary, null, /* @__PURE__ */ React.createElement(\"ls-layout\", {\n    \"data-id\": M.id + \"-x\",\n    props: JSON.stringify(B),\n    layout: J\n  }, M.children.map((Z) => /* @__PURE__ */ React.createElement(ElementTree, {\n    key: Z.id,\n    nodeId: Z.id\n  }))))));\n}, Root = (a) => {\n  const {\n    project: u\n  } = useContext(CompositorContext), [c, l] = useState(null);\n  return useEffect(() => (l(u.compositor.renderTree()), CoreContext.onInternal(\"NodeChanged\", () => {\n    l(u.compositor.renderTree());\n  })), []), useEffect(() => {\n    const v = u.compositor.getRoot(), {\n      x: S\n    } = v.props.size, g = () => {\n      var J, V, q;\n      const {\n        bannerStyle: E = \"default\",\n        primaryColor: _ = \"#ABABAB\",\n        showNameBanners: k\n      } = u.props ?? {}, L = ((J = u.props) == null ? void 0 : J.logoPosition) ?? ((q = (V = u.props) == null ? void 0 : V.logo) == null ? void 0 : q.logoPosition) ?? \"top-right\";\n      if (!E || !_ || !L)\n        return;\n      const M = themes[E](_, k, S / 1920), $ = themes[L](S / 1920);\n      a.setStyle(`${M} ${$}` || \"\");\n    };\n    return g(), CoreContext.onInternal(\"ProjectChanged\", g);\n  }, [u]), c ? /* @__PURE__ */ React.createElement(\"div\", {\n    onDrop: (v) => {\n      foundDropTarget = !0, v.preventDefault();\n    },\n    onDragOver: (v) => {\n      v.preventDefault();\n    },\n    onDragLeave: (v) => {\n      v.preventDefault();\n    },\n    style: {\n      userSelect: \"none\",\n      width: `${c.props.size.x + PADDING * 2}px`,\n      height: `${c.props.size.y + PADDING * 2}px`,\n      margin: PADDING + \"px\"\n    }\n  }, /* @__PURE__ */ React.createElement(\"div\", {\n    style: {\n      width: \"100%\",\n      height: \"100%\",\n      overflow: \"hidden\"\n    }\n  }, /* @__PURE__ */ React.createElement(ElementTree, {\n    nodeId: c.id\n  }))) : null;\n};\nlet wrapperEl, customStyleEl;\nconst PADDING = 0, render$1 = (a) => {\n  const {\n    containerEl: u,\n    projectId: c,\n    dragAndDrop: l = !1,\n    checkDragTarget: v = scenelessProjectDragCheck,\n    checkDropTarget: S = scenelessProjectDropCheck\n  } = a, g = getProject(c);\n  CoreContext.clients.LayoutApi().subscribeToLayout(g.layoutApi.layoutId), loadDragImage();\n  const E = a.onElementDoubleClick ?? (() => {\n  });\n  if (!u || !g)\n    return;\n  if (!u.shadowRoot) {\n    u.attachShadow({\n      mode: \"open\"\n    }), customStyleEl = document.createElement(\"style\");\n    const J = document.createElement(\"style\");\n    J.textContent = getStyle(), wrapperEl = document.createElement(\"div\"), wrapperEl.id = \"compositor-root\", Object.assign(wrapperEl.style, {\n      width: \"100%\",\n      height: \"100%\",\n      display: \"flex\",\n      alignItems: \"center\",\n      justifyContent: \"center\",\n      transformOrigin: \"center\"\n    }), u.shadowRoot.appendChild(J), u.shadowRoot.appendChild(customStyleEl), u.shadowRoot.appendChild(wrapperEl), new ResizeObserver((q) => {\n      M();\n    }).observe(u);\n  }\n  const _ = g.compositor.getRoot(), {\n    x: k,\n    y: L\n  } = _.props.size, M = () => {\n    let {\n      width: J,\n      height: V\n    } = u.getBoundingClientRect();\n    const q = J / V, G = k / L;\n    let H;\n    J && V ? G > q ? H = J / (k + PADDING * 2) : H = V / (L + PADDING * 2) : H = 1, wrapperEl.style.willChange = \"transform\", wrapperEl.style.transform = `scale(${H}) translateZ(0)`, window.__scale = H, $();\n  }, $ = () => {\n    ReactDOM.render(/* @__PURE__ */ React.createElement(CompositorProvider, {\n      project: g,\n      interactive: l,\n      onElementDoubleClick: E,\n      checkIsDropTarget: S,\n      checkIsDragTarget: v\n    }, /* @__PURE__ */ React.createElement(Root, {\n      setStyle: (J) => {\n        customStyleEl.textContent = J;\n      }\n    })), wrapperEl);\n  };\n  M();\n}, scenelessProjectDragCheck = (a) => a.props.name === \"Participant\" || a.props.sourceType === \"RoomParticipant\" || a.props.sourceType === \"RTMP\", scenelessProjectDropCheck = (a) => a.props.name === \"Content\", CompositorContext = React.createContext({\n  interactive: !1,\n  project: null,\n  checkIsDragTarget: () => !1,\n  checkIsDropTarget: () => !1,\n  onElementDoubleClick: () => {\n  }\n}), CompositorProvider = ({\n  children: a,\n  ...u\n}) => /* @__PURE__ */ React.createElement(CompositorContext.Provider, {\n  value: {\n    ...u\n  }\n}, a), getStyle = () => `\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n  font-family: 'Arial';\n}\n\nvideo {\n  width: 100%;\n  height: 100%;\n  object-fit: contain;\n}\n\n.NameBanner {\n  top: 100%;\n  transform: translateY(-100%);\n  left: 0;\n  height: 30px;\n  background: linear-gradient(90deg, rgba(0, 0, 0, 0.5) 50%, rgba(0, 0, 0, 0) 100%);\n  padding: 0px 0px 0px 10px;\n  color: rgba(255, 255, 255, 0.9);\n  font-weight: bold;\n  line-height: 30px;\n  width: 100%;\n  font-size: 28px;\n  position: absolute;\n}\n\nls-layout[layout=\"Presentation\"][props*=\"\\\\\"cover\\\\\"\\\\:true\"] > :first-child .NameBanner {\n  top: 0% !important;\n  transform: translateY(0%) !important;\n}\n\n[layout=\"Layered\"] > [data-item] {\n  transform: scale(1.003) !important;\n}\n[layout=\"Layered\"] > [data-item]:nth-child(2) {\n  transform: scale(1.0015) !important;\n}\n[layout=\"Layered\"] > [data-item]:nth-child(1) {\n  transform: scale(1) !important;\n}\n\n.logo {\n  position: absolute !important;\n}\n\n#compositor-root[data-dragging] {}\n\n[data-drag-target] {}\n[data-drag-target]:hover > .interactive-overlay {\n  box-shadow: 0 0 0 3px inset rgba(255, 255, 255, 0.5);\n  cursor: grab;\n}\n[data-drop-target] {}\n[data-drop-target]:hover {}\n[data-drag-target][data-drag-target-active] > .interactive-overlay {\n  box-shadow: 0 0 0 3px inset rgba(255, 255, 255, 0.2);\n}\n[data-drag-target][data-drag-target-active] > .item-element {\n  opacity: 0.8;\n}\n[data-layout-drop-target-active] > .interactive-overlay {\n  box-shadow: 0 0 0 3px inset yellow;\n}\n[data-transform-drop-target-active] > .interactive-overlay {\n  box-shadow: 0 0 0 3px inset white;\n}\n`;\nvar BannerStyle = /* @__PURE__ */ ((a) => (a.DEFAULT = \"default\", a.MINIMAL = \"minimal\", a.BUBBLE = \"bubble\", a))(BannerStyle || {});\nconst themes = {\n  \"top-left\": (a = 1280 / 1920) => `\n      .wrapper {\n       top:0;\n       left:0;\n    }`,\n  \"top-right\": (a = 1280 / 1920) => `\n      .wrapper {\n       top:0;\n       right:0;\n    }`,\n  \"bottom-left\": (a = 1280 / 1920) => `\n      .wrapper {\n       bottom:0;\n       left:0;\n    }`,\n  \"bottom-right\": (a = 1280 / 1920) => `\n      .wrapper {\n       bottom:0;\n       right:0;\n    }`,\n  default: (a = \"#ABABAB\", u = !0, c = 1280 / 1920) => {\n    const l = color(a).lightness() < 0.6 ? \"#FFF\" : \"#000\", v = color(a).lightness() < 0.6 ? \"#FFF\" : \"#000\", S = color(a).lightness() < 0.6 ? \"#000\" : \"#FFF\", g = (E) => E * c + \"px\";\n    return `\n      .ChatOverlay {\n        background: ${a} !important;\n        margin-bottom: ${g(40)} !important;\n        transition: 300ms ease all;\n        left: 0;\n\n        /* Default Size 4 */\n        font-size: ${g(44)} !important;\n        padding: ${g(40)} ${g(100)} !important;\n        border-radius: ${g(20)} !important;\n      }\n      \n      .ChatOverlay-badge-icon {\n          width:${g(32)};\n          height: ${g(32)};\n          fill: currentcolor;\n          color: ${S};\n      }\n\n       .ChatOverlay-badge-container {\n          background-color:${v};\n          display:flex;\n          flex-direction:row;\n          padding: ${g(6)} ${g(12)} ${g(6)} ${g(6)};\n          border-radius: ${g(10)};\n          align-items: center;\n          border-bottom-left-radius: 0px !important;\n          position: relative;\n          border: none;\n          cursor: pointer;\n       }\n      \n       .ChatOverlay-badge-username {\n          color:${S};\n          padding:${g(6)};\n          font-size:${g(18)};\n          font-weight:700;\n          text-transform: capitalize; \n       }\n       \n       .ChatOverlay-badge-container::before {\n          content:\"\";\n          width:15px;\n          height:15px;\n          background-color:${v};\n          position: absolute;\n          bottom:-14px;\n          left:0;\n          clip-path:polygon(0 100%, 12% 87%, 26% 73%, 45% 53%, 59% 40%, 71% 28%, 85% 14%, 100% 0, 0 0);\n        }\n       \n\n       .ChatOverlay-avatar {\n          height: ${g(120)};\n          width: ${g(120)};\n          left:0;\n          right:0;\n          top:0;\n          bottom:0;\n          border-radius:50%;\n       }\n\n      .Banner, .NameBanner, .ChatOverlay {\n        background: ${a} !important;\n        margin-bottom: ${g(40)} !important;\n        transition: 300ms ease all;\n        left: 0;\n\n        /* Default Size 4 */\n        font-size: ${g(44)} !important;\n        padding: ${g(40)} ${g(100)} !important;\n        border-top-right-radius: ${g(20)} !important;\n        border-bottom-right-radius: ${g(20)} !important;\n      }\n\n      .Banner-body, .NameBanner-body, .ChatOverlay-body {\n        color: ${l} !important;\n        font-family: 'Roboto' !important;\n        font-style: normal !important;\n        font-weight: 700 !important;\n        line-height: 120% !important;\n      }\n\n      .NameBanner {\n        transform-origin: 0 100%;\n        margin: 0 !important;\n        transform: translateX(-100%);\n        opacity: 0 !important;\n        white-space: nowrap;\n        ${u && `\n          opacity: 1 !important;\n          transform: translateX(0);\n        `}\n      }\n\n      .NameBanner[data-size=\"4\"] {\n        padding: ${g(40)} ${g(100)} !important;\n        font-size: ${g(44)} !important;\n        border-top-right-radius: ${g(20)} !important;\n        border-bottom-right-radius: ${g(20)} !important;\n      }\n      .NameBanner[data-size=\"3\"] {\n        padding: ${g(12)} ${g(30)} !important;\n        font-size: ${g(44)} !important;\n        border-top-right-radius: ${g(20)} !important;\n        border-bottom-right-radius: ${g(20)} !important;\n      }\n      .NameBanner[data-size=\"2\"] {\n        padding: ${g(12)} ${g(20)} !important;\n        font-size: ${g(28)} !important;\n        border-top-right-radius: ${g(16)} !important;\n        border-bottom-right-radius: ${g(16)} !important;\n      }\n      .NameBanner[data-size=\"1\"], .NameBanner[data-size=\"0\"] {\n        padding: ${g(8)} ${g(8)} !important;\n        font-size: ${g(20)} !important;\n        border-top-right-radius: ${g(8)} !important;\n        border-bottom-right-radius: ${g(8)} !important;\n      }\n      .NameBanner[data-size=\"0\"] {\n        opacity: 0;\n        transform: translateX(-100%);\n      }\n    `;\n  },\n  minimal: (a = \"#ABABAB\", u = !0, c = 1280 / 1920) => {\n    const l = \"white\", v = \"#fff\", S = \"#000\", g = (E) => E * c + \"px\";\n    return `\n\n      .ChatOverlay-badge-icon {\n          width:${g(32)};\n          height: ${g(32)};\n          fill: currentcolor;\n          color: ${S};\n      }\n\n       .ChatOverlay-badge-container {\n          background-color:${v};\n          display:flex;\n          flex-direction:row;\n          padding: ${g(6)} ${g(12)} ${g(6)} ${g(6)};\n          align-items: center;\n          position: relative;\n          border: none;\n          cursor: pointer;\n       }\n\n       .ChatOverlay-badge-username {\n          color:${S};\n          padding:${g(6)};\n          font-size:${g(18)};\n          font-weight:700;\n          text-transform: capitalize; \n       }\n\n       .ChatOverlay-avatar {\n          height: ${g(120)};\n          width: ${g(120)};\n          left:0;\n          right:0;\n          top:0;\n          bottom:0;\n          border-radius:50%;\n       }\n\n\n    .Banner, .NameBanner, .ChatOverlay {\n        background: ${color(a).fade(color(a).alpha() * 0.7).toString()} !important;\n        padding: ${g(40)} ${g(40)} ${g(40)} ${g(60)} !important;\n        position: relative !important;\n        margin-bottom: ${g(40)} !important;\n        transition: 300ms ease all;\n        font-size: ${g(34)} !important;\n        left: 0;\n      }\n\n      .Banner:before, .NameBanner:before, .ChatOverlay:before {\n        z-index: 1;\n        content: \"\";\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        background: rgba(0,0,0,0.6);\n        transition: 300ms ease all;\n        opacity: ${color(a).alpha()};\n      }\n      .Banner:after, .NameBanner:after, .ChatOverlay:after {\n        z-index: 1;\n        content: \"\";\n        position: absolute;\n        left: 0;\n        top: 0;\n        height: 100%;\n        transition: 300ms ease all;\n        width: ${g(20)};\n        background: ${color(a)};\n        opacity: ${color(a).alpha()};\n      }\n      .Banner-body, .NameBanner-body, .ChatOverlay-body {\n        color: ${l} !important;\n        font-family: 'Roboto' !important;\n        font-style: normal !important;\n        font-weight: 700 !important;\n        line-height: 120% !important;\n        position: relative;\n        z-index: 2;\n      }\n      .Banner-header {\n        font-size: ${g(90)};\n        position: relative;\n        z-index: 2;\n      }\n      .NameBanner {\n        transform-origin: 0 100%;\n        margin: 0 !important;\n        transform: translateX(-100%);\n        opacity: 0 !important;\n        white-space: nowrap;\n        ${u && `\n          opacity: 1 !important;\n          transform: translateX(0);\n        `}\n      }\n\n      .NameBanner[data-size=\"4\"] {\n        padding: ${g(40)} ${g(40)} ${g(40)} ${g(60)} !important;\n        font-size: ${g(34)} !important;\n      }\n      .NameBanner[data-size=\"3\"] {\n        padding: ${g(16)} ${g(40)} ${g(16)} ${g(60)} !important;\n        font-size: ${g(34)} !important;\n      }\n      .NameBanner[data-size=\"2\"] {\n        padding: ${g(12)} ${g(24)} ${g(12)} ${g(44)} !important;\n        font-size: ${g(24)} !important;\n      }\n      .NameBanner[data-size=\"1\"], .NameBanner[data-size=\"0\"] {\n        padding: ${g(12)} ${g(16)} ${g(12)} ${g(36)} !important;\n        font-size: ${g(18)} !important;\n      }\n      .NameBanner[data-size=\"0\"] {\n        opacity: 0 !important;\n        transform: translateX(-100%);\n      }\n    `;\n  },\n  bubble: (a = \"#ABABAB\", u = !0, c = 1280 / 1920) => {\n    const l = color(a).lightness() < 0.6 ? \"#FFF\" : \"#000\", v = color(a).lightness() < 0.6 ? \"#FFF\" : \"#000\", S = color(a).lightness() < 0.6 ? \"#000\" : \"#FFF\", g = (E) => E * c + \"px\";\n    return `\n      .ChatOverlay-badge-icon {\n          width:${g(32)};\n          height: ${g(32)};\n          fill: currentcolor;\n          color: ${S};\n      }\n\n\n       .ChatOverlay-badge-container {\n          background-color:${v};\n          display:flex;\n          flex-direction:row;\n          padding: ${g(6)} ${g(12)} ${g(6)} ${g(6)};\n          align-items: center;\n          z-index: 1;\n          border: none;\n          cursor: pointer;\n          top: 0;\n          margin-bottom: 2px;\n          margin-left: -${g(30)};\n          border-radius: 30px;\n       }\n\n       .ChatOverlay-badge-username {\n          color:${S};\n          padding:${g(6)};\n          font-size:${g(18)};\n          font-weight:700;\n          text-transform: capitalize; \n       }\n\n       .ChatOverlayAvatar-container {\n          height: ${g(120)};\n          width: ${g(120)};\n          top: 0;\n       }\n       .ChatOverlay-avatar {\n          height: ${g(120)};\n          width: ${g(120)};\n          left:0;\n          right:0;\n          top:0;\n          bottom:0;\n          border-radius:50%;\n       }\n\n\n      .Banner, .ChatOverlay {\n        transform: translateX(-50%);\n        left: 50%;\n        margin-bottom: ${g(40)} !important;\n      }\n\n      .Banner, .NameBanner, .ChatOverlay {\n        background: ${color(a)} !important;\n        color: ${l} !important;\n        border-radius: 500px !important;\n        transition: 300ms ease all;\n\n        /* Default Style */\n        border: 4px solid ${l} !important;\n        padding: ${g(40)} ${g(80)} !important;\n        font-size: ${g(40)} !important;\n      }\n      .Banner-body, .NameBanner-body, .ChatOverlay-body {\n        color: ${l} !important;\n        text-align: center !important;\n        font-family: 'Roboto' !important;\n        font-style: normal !important;\n        font-weight: 700 !important;\n        line-height: 120% !important;\n      }\n      .NameBanner {\n        transform-origin: 0% 100%;\n        transform: translateX(-100%);\n        opacity: 0 !important;\n        white-space: nowrap;\n        ${u && `\n          opacity: 1 !important;\n          transform: translateX(0);\n        `}\n      }\n\n      ls-layout[layout=\"Presentation\"][props*=\"\\\\\"cover\\\\\"\\\\:true\"] > :first-child .NameBanner {\n        top: 0% !important;\n        transform: translateY(0%) !important;\n        margin: ${g(20)} ${g(20)};\n      }\n\n\n      .NameBanner[data-size=\"4\"] {\n        padding: ${g(40)} ${g(80)} ${g(40)} ${g(80)} !important;\n        font-size: ${g(40)} !important;\n      }\n      .NameBanner[data-size=\"3\"] {\n        padding: ${g(12)} ${g(30)} ${g(12)} ${g(30)} !important;\n        font-size: ${g(40)} !important;\n        margin: -${g(20)} ${g(20)};\n      }\n      .NameBanner[data-size=\"2\"] {\n        padding: ${g(12)} ${g(30)} ${g(12)} ${g(30)} !important;\n        font-size: ${g(26)} !important;\n        margin: -${g(8)} ${g(8)};\n      }\n      .NameBanner[data-size=\"1\"], .NameBanner[data-size=\"0\"] {\n        padding: ${g(8)} ${g(16)} ${g(8)} ${g(16)} !important;\n        font-size: ${g(18)} !important;\n        border-width: ${g(2)} !important;\n        margin: -${g(16)} ${g(8)};\n      }\n      .NameBanner[data-size=\"0\"] {\n        opacity: 0 !important;\n        transform: translateX(-100%);\n      }\n    `;\n  }\n}, iconStyles = {\n  twitch: {\n    icon: \"Twitch\"\n  },\n  youtube: {\n    icon: \"YouTube\"\n  },\n  facebook: {\n    icon: \"Facebook\"\n  }\n}, fixLink = (a) => !a.startsWith(\"http:\") && !a.startsWith(\"https:\") ? `https://${a}` : a, ChatOverlay = {\n  name: \"LS-ChatOverlay\",\n  sourceType: \"ChatOverlay\",\n  create({\n    onUpdate: a,\n    onEvent: u\n  }, c) {\n    const l = document.createElement(\"div\"), v = getProject(CoreContext.state.activeProjectId), S = v.compositor.getRoot(), {\n      x: g\n    } = S.props.size, E = (g ?? 1280) / 1920, _ = (q) => q * E + \"px\";\n    let k;\n    const L = (q, G) => {\n      const H = q.width / G.width;\n      return q.height / G.height >= 0.25 && H >= 0.75 ? 4 : H >= 0.75 ? 1 : H >= 0.5 ? -2 : H > 0.25 ? -3 : -4;\n    };\n    CoreContext.onInternal(\"ProjectChanged\", () => {\n      const {\n        bannerStyle: q\n      } = v.props ?? {};\n      q && V({\n        ...k,\n        metadata: {\n          ...k.metadata,\n          bannerStyle: q\n        }\n      });\n    });\n    const M = React.memo((q) => {\n      var G, H, B;\n      return (q == null ? void 0 : q.type) === \"emoticon\" && ((G = q == null ? void 0 : q.data) == null ? void 0 : G.type) === \"direct\" ? /* @__PURE__ */ React.createElement(\"img\", {\n        src: (H = q == null ? void 0 : q.data) == null ? void 0 : H.url,\n        style: {\n          height: _(36)\n        },\n        alt: q == null ? void 0 : q.text\n      }) : (q == null ? void 0 : q.type) === \"link\" ? /* @__PURE__ */ React.createElement(\"a\", {\n        style: {\n          color: \"#FFF\",\n          wordBreak: \"break-all\"\n        },\n        target: \"_blank\",\n        rel: \"noreferrer\",\n        href: fixLink((B = q == null ? void 0 : q.data) == null ? void 0 : B.url)\n      }, q == null ? void 0 : q.text) : /* @__PURE__ */ React.createElement(\"span\", null, q == null ? void 0 : q.text);\n    }), $ = (q) => {\n      const G = {\n        height: `${q.height}`,\n        width: `${q.width}`,\n        background: q.background || \"transparent\",\n        display: \"inline-block\",\n        verticalAlign: \"middle\",\n        borderRadius: \"50%\",\n        fontSize: `${q.fontSize}`\n      };\n      return /* @__PURE__ */ React.createElement(\"div\", {\n        style: {\n          ...G,\n          position: \"relative\",\n          marginRight: q == null ? void 0 : q.marginRight\n        }\n      }, /* @__PURE__ */ React.createElement(\"div\", {\n        style: {\n          left: \"50%\",\n          position: \"absolute\",\n          top: \"50%\",\n          transform: \"translate(-50%, -50%)\"\n        }\n      }, q.username.substring(0, 2).toUpperCase()));\n    }, J = (q) => {\n      const {\n        message: G,\n        id: H,\n        username: B,\n        metadata: Y\n      } = q || {}, [ne, Z] = useState(0), {\n        index: re,\n        platform: oe,\n        avatar: de,\n        bannerStyle: A\n      } = Y || {}, N = useMemo(() => iconStyles[oe], [oe]), D = useRef();\n      return useLayoutEffect(() => {\n        if (!D.current)\n          return;\n        const W = () => {\n          const ae = D.current;\n          ae && Z(L({\n            width: ae.clientWidth,\n            height: ae.clientHeight\n          }, {\n            width: v.compositor.getRoot().props.size.x,\n            height: v.compositor.getRoot().props.size.y\n          }));\n        }, ee = new ResizeObserver((ae) => {\n          W();\n        });\n        return W(), ee.observe(D.current), () => {\n          D != null && D.current && ee.unobserve(D == null ? void 0 : D.current);\n        };\n      }, [D.current, v]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {\n        id: `${H}_${re}`,\n        type: \"chatoverlay\",\n        enter: APIKitAnimationTypes.SLIDE_IN_LEFT,\n        exit: APIKitAnimationTypes.SLIDE_OUT_LEFT,\n        duration: 200\n      }, /* @__PURE__ */ React.createElement(\"div\", {\n        className: \"ChatOverlayContainer\",\n        style: {\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          width: \"100%\",\n          height: \"100%\",\n          display: \"flex\",\n          flexDirection: \"row\",\n          justifyContent: \"flex-start\",\n          alignItems: \"flex-end\",\n          marginLeft: A !== BannerStyle.BUBBLE ? \"5%\" : \"0px\"\n        }\n      }, A !== BannerStyle.BUBBLE ? (\n        /* It's a ternary operator. If the style is not equal to BannerStyle.BUBBLE.toString(), then it will\n        render the first div. Otherwise, it will render the second div. */\n        /* @__PURE__ */ React.createElement(\"div\", {\n          style: {\n            width: \"100%\",\n            display: \"flex\"\n          }\n        }, de ? /* @__PURE__ */ React.createElement(\"span\", {\n          style: {\n            marginRight: \"20px\"\n          }\n        }, /* @__PURE__ */ React.createElement(\"img\", {\n          src: de,\n          className: \"ChatOverlay-avatar\"\n        })) : /* @__PURE__ */ React.createElement($, {\n          height: _(110),\n          width: _(120),\n          background: primary(500),\n          username: B,\n          marginRight: 20,\n          fontSize: _(30)\n        }), /* @__PURE__ */ React.createElement(\"div\", {\n          style: {\n            width: \"100%\"\n          }\n        }, B && /* @__PURE__ */ React.createElement(\"button\", {\n          className: \"ChatOverlay-badge-container\"\n        }, (N == null ? void 0 : N.icon) && /* @__PURE__ */ React.createElement(Icon$1, {\n          className: \"ChatOverlay-badge-icon\",\n          name: N == null ? void 0 : N.icon\n        }), /* @__PURE__ */ React.createElement(\"div\", {\n          className: \"ChatOverlay-badge-username\"\n        }, B)), /* @__PURE__ */ React.createElement(\"div\", {\n          className: \"ChatOverlay\",\n          style: {\n            padding: 10,\n            background: \"orange\",\n            width: \"fit-content\",\n            height: \"fit-content\",\n            maxWidth: \"84%\",\n            position: \"relative\"\n          }\n        }, G && /* @__PURE__ */ React.createElement(\"div\", {\n          className: \"ChatOverlay-body\",\n          style: {\n            gap: 10,\n            display: \"flex\",\n            alignItems: \"center\",\n            flexWrap: \"wrap\",\n            verticalAlign: \"middle\"\n          }\n        }, G.map((W, ee) => /* @__PURE__ */ React.createElement(M, {\n          key: ee,\n          ...W\n        }))))))\n      ) : (\n        /* It's a ternary operator. If the style is not equal to BannerStyle.BUBBLE.toString(), then it will\n        render the first div. Otherwise, it will render the second div. */\n        /* @__PURE__ */ React.createElement(\"div\", {\n          style: {\n            width: \"100%\",\n            display: \"flex\"\n          }\n        }, /* @__PURE__ */ React.createElement(\"div\", {\n          className: \"ChatOverlay\",\n          style: {\n            padding: 10,\n            background: \"orange\",\n            width: \"fit-content\",\n            height: \"fit-content\",\n            maxWidth: \"84%\",\n            position: \"relative\"\n          }\n        }, /* @__PURE__ */ React.createElement(\"div\", {\n          style: {\n            display: \"flex\",\n            marginTop: `-${_(160)}`,\n            alignItems: \"flex-end\",\n            padding: `${_(14)} ${_(0)} ${_(14)} ${_(0)}`,\n            marginLeft: `${ne * 10}px`\n          }\n        }, de ? /* @__PURE__ */ React.createElement(\"div\", {\n          className: \"ChatOverlayAvatar-container\"\n        }, /* @__PURE__ */ React.createElement(\"img\", {\n          src: de,\n          className: \"ChatOverlay-avatar\"\n        })) : /* @__PURE__ */ React.createElement(\"div\", {\n          className: \"ChatOverlayAvatar-container\"\n        }, /* @__PURE__ */ React.createElement($, {\n          height: _(120),\n          width: _(120),\n          background: primary(500),\n          username: B,\n          fontSize: _(30)\n        })), B && /* @__PURE__ */ React.createElement(\"button\", {\n          className: \"ChatOverlay-badge-container\"\n        }, (N == null ? void 0 : N.icon) && /* @__PURE__ */ React.createElement(Icon$1, {\n          className: \"ChatOverlay-badge-icon\",\n          name: N == null ? void 0 : N.icon\n        }), /* @__PURE__ */ React.createElement(\"div\", {\n          className: \"ChatOverlay-badge-username\"\n        }, B))), G && /* @__PURE__ */ React.createElement(\"div\", {\n          ref: D,\n          className: \"ChatOverlay-body\",\n          style: {\n            gap: 10,\n            alignItems: \"center\",\n            flexWrap: \"wrap\",\n            verticalAlign: \"middle\"\n          }\n        }, G.map((W, ee) => /* @__PURE__ */ React.createElement(M, {\n          key: ee,\n          ...W\n        })))))\n      )));\n    }, V = (q) => ReactDOM.render(/* @__PURE__ */ React.createElement(J, {\n      ...q\n    }), l);\n    return a((q) => {\n      const {\n        bannerStyle: G = BannerStyle.DEFAULT\n      } = v.props ?? {};\n      k = {\n        ...q,\n        metadata: {\n          ...q.metadata,\n          bannerStyle: G\n        }\n      }, V(k);\n    }), {\n      root: l\n    };\n  }\n}, Background$1 = {\n  name: \"LS-Background\",\n  sourceType: \"Background\",\n  create({\n    onUpdate: a,\n    onRemove: u\n  }, {\n    sourceProps: c\n  }) {\n    u(() => {\n      clearInterval(S);\n    });\n    const l = document.createElement(\"div\"), v = getProject(CoreContext.state.activeProjectId).role;\n    let S;\n    const g = ({\n      source: L,\n      setStartAnimation: M\n    }) => {\n      var de, A;\n      const {\n        src: $,\n        type: J,\n        meta: V,\n        loop: q\n      } = (L == null ? void 0 : L.sourceProps) || {}, {\n        id: G,\n        sourceType: H\n      } = L || {}, [B, Y] = React.useState(null), ne = React.useRef(null);\n      console.log(\"Updated current time\", (de = ne == null ? void 0 : ne.current) == null ? void 0 : de.currentTime);\n      const Z = React.useCallback((N) => {\n        ne.current = N, Y(N ? N.id : null);\n      }, []), re = React.useCallback(() => {\n        ne != null && ne.current && ne.current.play().catch(() => {\n          var N;\n          ne.current.muted = !0, (N = ne.current) == null || N.play();\n        });\n      }, [$]), oe = React.useCallback(() => {\n        S && clearInterval(S), hasPermission(v, Permission.UpdateProject) && trigger$1(\"VideoEnded\", {\n          id: G,\n          category: J\n        });\n      }, [$]);\n      return React.useEffect(() => {\n        V && (ne != null && ne.current) && B && hasPermission(v, Permission.ManageSelf) && V != null && V.time && (ne.current.currentTime = Number(V == null ? void 0 : V.time));\n      }, [V == null ? void 0 : V.time, B]), React.useEffect(() => () => {\n        S && clearInterval(S);\n      }, [G]), React.useEffect(() => {\n        B ? ne.current && (ne.current.src = $, ne.current.play().catch(() => {\n          ne.current.muted = !0, ne.current.play();\n        }), hasPermission(v, Permission.UpdateProject) && (S = setInterval(() => {\n          if (ne.current.duration) {\n            const N = ne.current.duration - ne.current.currentTime;\n            trigger$1(\"VideoTimeUpdate\", {\n              category: H,\n              id: G,\n              time: Math.floor(N)\n            });\n          }\n        }, 1e3))) : S && clearInterval(S);\n      }, [B]), /* @__PURE__ */ React.createElement(React.Fragment, {\n        key: G\n      }, $ && /* @__PURE__ */ React.createElement(\"video\", {\n        loop: q,\n        id: G,\n        ref: Z,\n        style: {\n          ...(A = c == null ? void 0 : c.meta) == null ? void 0 : A.style,\n          ...V.style\n        },\n        onLoadedData: re,\n        onEnded: oe,\n        onCanPlay: () => M(!0)\n      }));\n    }, E = ({\n      source: L,\n      setStartAnimation: M\n    }) => {\n      var G;\n      const {\n        src: $,\n        meta: J,\n        type: V\n      } = (L == null ? void 0 : L.sourceProps) || {}, {\n        id: q\n      } = L || {};\n      return /* @__PURE__ */ React.createElement(React.Fragment, {\n        key: q\n      }, $ && /* @__PURE__ */ React.createElement(\"img\", {\n        style: {\n          ...(G = c == null ? void 0 : c.meta) == null ? void 0 : G.style,\n          ...J == null ? void 0 : J.style\n        },\n        src: $,\n        onLoad: () => M(!0)\n      }));\n    }, _ = ({\n      source: L\n    }) => {\n      const {\n        type: M\n      } = L.sourceProps, {\n        id: $\n      } = L || {}, [J, V] = React.useState(!1);\n      return useEffect(() => {\n        V(!1);\n      }, [$]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {\n        id: $,\n        type: \"background\",\n        enter: APIKitAnimationTypes.FADE_IN,\n        exit: APIKitAnimationTypes.FADE_OUT,\n        duration: 400\n      }, /* @__PURE__ */ React.createElement(\"div\", {\n        style: {\n          opacity: J ? 1 : 0\n        },\n        className: \"backgroundContainer background-transition\"\n      }, $ && M === \"image\" && /* @__PURE__ */ React.createElement(E, {\n        source: L,\n        setStartAnimation: V\n      }), $ && M === \"video\" && /* @__PURE__ */ React.createElement(g, {\n        source: L,\n        setStartAnimation: V\n      })));\n    }, k = (L) => ReactDOM.render(/* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(_, {\n      source: L\n    })), l);\n    return a((L) => {\n      k({\n        ...L\n      });\n    }), {\n      root: l\n    };\n  }\n}, SourceTriggerMap = [{\n  sourceType: \"Overlay\",\n  trigger: \"OverlayMetadataUpdate\"\n}, {\n  sourceType: \"Background\",\n  trigger: \"BackgroundMetadataUpdate\"\n}], Video2 = {\n  name: \"LS-Video-2\",\n  sourceType: \"Video2\",\n  props: {\n    id: {\n      type: String,\n      required: !0\n    }\n  },\n  useSource(a, u) {\n    return a.find((c) => c.props.type === u.id);\n  },\n  create({\n    onUpdate: a,\n    onNewSource: u,\n    onRemove: c\n  }, l) {\n    c(() => {\n      clearInterval(_);\n    });\n    const v = document.createElement(\"div\"), S = getProjectRoom(CoreContext.state.activeProjectId), g = getProject(CoreContext.state.activeProjectId).role;\n    let E, _;\n    const k = ({\n      source: M\n    }) => {\n      var N;\n      const $ = SourceTriggerMap.find((D) => D.sourceType === l.proxySource), {\n        src: J,\n        type: V,\n        meta: q,\n        loop: G\n      } = (M == null ? void 0 : M.value) || {}, {\n        id: H\n      } = M || {}, [B, Y] = React.useState(null), ne = React.useRef(null), [Z, re] = React.useState(!1);\n      console.log(\"Updated current time\", (N = ne == null ? void 0 : ne.current) == null ? void 0 : N.currentTime), React.useEffect(() => {\n        re(!1);\n      }, [H]);\n      const oe = React.useCallback((D) => {\n        ne.current = D, Y(D ? D.id : null);\n      }, []), de = React.useCallback(() => {\n        ne != null && ne.current && ne.current.play().catch(() => {\n          var D;\n          ne.current.muted = !0, (D = ne.current) == null || D.play();\n        });\n      }, [J]), A = React.useCallback(() => {\n        _ && clearInterval(_), trigger$1(\"VideoEnded\", {\n          id: H,\n          category: V\n        });\n      }, [J]);\n      return React.useEffect(() => {\n        q && (ne != null && ne.current) && B && hasPermission(g, Permission.ManageSelf) && (ne.current.currentTime = Number(q == null ? void 0 : q.time));\n      }, [q == null ? void 0 : q.time, B]), React.useEffect(() => () => {\n        _ && clearInterval(_);\n      }, [H]), React.useEffect(() => {\n        if (!B)\n          _ && clearInterval(_);\n        else if (ne.current)\n          return ne.current.src = J, G && (ne.current.loop = !!G), ne.current.play().catch(() => {\n            ne.current.muted = !0, ne.current.play();\n          }), _ = setInterval(() => {\n            if (ne.current.duration) {\n              const D = ne.current.duration - ne.current.currentTime;\n              trigger$1(\"VideoTimeUpdate\", {\n                category: V,\n                id: H,\n                time: Math.floor(D)\n              });\n            }\n          }, 1e3), S == null ? void 0 : S.onData((D, W) => {\n            var ee, ae;\n            (ee = ne == null ? void 0 : ne.current) != null && ee.currentTime && D.type === \"UserJoined\" && hasPermission(g, Permission.ManageGuests) && triggerInternal$1($.trigger, {\n              projectId: CoreContext.state.activeProjectId,\n              role: g,\n              sourceId: B,\n              doTrigger: !0,\n              metadata: {\n                time: Math.floor((ae = ne == null ? void 0 : ne.current) == null ? void 0 : ae.currentTime) || 0,\n                owner: S == null ? void 0 : S.participantId,\n                guest: W\n              }\n            });\n          });\n      }, [B]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {\n        id: H,\n        type: \"video\",\n        enter: APIKitAnimationTypes.FADE_IN,\n        exit: APIKitAnimationTypes.FADE_OUT,\n        duration: 400\n      }, /* @__PURE__ */ React.createElement(\"div\", {\n        style: {\n          opacity: Z ? 1 : 0,\n          width: \"100%\",\n          height: \"100%\"\n        },\n        className: \"video-transition\"\n      }, J && /* @__PURE__ */ React.createElement(\"video\", {\n        id: H,\n        ref: oe,\n        style: l.style,\n        ...l.props,\n        onLoadedData: de,\n        onEnded: A,\n        onCanPlayThrough: () => re(!0)\n      })));\n    }, L = () => ReactDOM.render(/* @__PURE__ */ React.createElement(k, {\n      source: E\n    }), v);\n    return a(() => {\n      L();\n    }), u((M) => {\n      E = M, L();\n    }), {\n      root: v\n    };\n  }\n}, Image2 = {\n  name: \"LS-Image-2\",\n  sourceType: \"Image2\",\n  props: {\n    id: {\n      type: String,\n      required: !0\n    }\n  },\n  useSource(a, u) {\n    return a.find((c) => c.props.type === u.id);\n  },\n  create({\n    onUpdate: a,\n    onNewSource: u\n  }, c) {\n    const l = document.createElement(\"div\");\n    let v;\n    const S = ({\n      source: E\n    }) => {\n      const {\n        src: _,\n        meta: k\n      } = (E == null ? void 0 : E.value) || {}, {\n        id: L\n      } = E || {}, [M, $] = React.useState(!1);\n      return React.useEffect(() => {\n        $(!1);\n      }, [L]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {\n        id: L,\n        type: \"image\",\n        enter: APIKitAnimationTypes.FADE_IN,\n        exit: APIKitAnimationTypes.FADE_OUT,\n        duration: 400\n      }, /* @__PURE__ */ React.createElement(\"div\", {\n        style: {\n          opacity: M ? 1 : 0,\n          width: \"100%\",\n          height: \"100%\"\n        },\n        className: \"image-transition\"\n      }, _ && /* @__PURE__ */ React.createElement(\"img\", {\n        style: {\n          ...c == null ? void 0 : c.style,\n          ...k == null ? void 0 : k.style\n        },\n        src: _,\n        onLoad: () => $(!0)\n      })));\n    }, g = () => ReactDOM.render(/* @__PURE__ */ React.createElement(S, {\n      source: v\n    }), l);\n    return a(() => {\n      g();\n    }), u((E) => {\n      v = E, g();\n    }), {\n      root: l\n    };\n  }\n}, RTMPSource = {\n  name: \"LS-RTMP-Source\",\n  sourceType: \"RTMP\",\n  props: {},\n  useSource(a, u) {\n    return a.find((c) => isMatch(c.props, u.sourceProps));\n  },\n  create({\n    onUpdate: a,\n    onNewSource: u,\n    onRemove: c\n  }, l) {\n    const v = document.createElement(\"div\"), S = getProject(CoreContext.state.activeProjectId);\n    getProjectRoom(CoreContext.state.activeProjectId), Object.assign(v.style, {\n      position: \"relative\"\n    });\n    let g, E = l;\n    const _ = (M, $) => {\n      const J = M / $.width;\n      return J >= 0.5 ? 3 : J > 0.25 ? 2 : J > 0.15 ? 1 : 0;\n    }, k = ({\n      props: M,\n      source: $\n    }) => {\n      var ne, Z;\n      const J = useRef(), {\n        volume: V = 1,\n        isHidden: q = !1\n      } = M || {}, [G, H] = useState(0), B = M == null ? void 0 : M.isMuted, Y = !(M != null && M.isHidden) && ((ne = $ == null ? void 0 : $.props) == null ? void 0 : ne.videoEnabled);\n      return useEffect(() => {\n        J.current && (J.current.play().catch((re) => {\n          document.addEventListener(\"click\", () => {\n            var oe;\n            return (oe = J.current) == null ? void 0 : oe.play();\n          }, {\n            once: !0\n          });\n        }), $ != null && $.value && ($ == null ? void 0 : $.value) !== J.current.srcObject ? J.current.srcObject = $ == null ? void 0 : $.value : $ != null && $.value || (J.current.srcObject = null));\n      }, [J.current, $ == null ? void 0 : $.value]), useEffect(() => {\n        !M && J.current && (J.current.srcObject = null, J.current = null);\n      }, [M]), useLayoutEffect(() => {\n        if (!J.current)\n          return;\n        const re = () => {\n          const de = J.current;\n          de && H(_(de.clientWidth, {\n            width: S.compositor.getRoot().props.size.x,\n            height: S.compositor.getRoot().props.size.y\n          }));\n        }, oe = new ResizeObserver((de) => {\n          re();\n        });\n        return re(), oe == null || oe.observe(J.current), () => {\n          J.current && (oe == null || oe.unobserve(J.current), J.current.srcObject = null);\n        };\n      }, [J.current, S]), useEffect(() => {\n        J.current && (J.current.volume = V);\n      }, [J.current, V]), /* @__PURE__ */ React.createElement(\"div\", {\n        style: {\n          position: \"relative\",\n          display: \"flex\",\n          height: \"100%\",\n          width: \"100%\"\n        }\n      }, /* @__PURE__ */ React.createElement(\"div\", {\n        style: {\n          background: \"#222\",\n          position: \"absolute\",\n          height: \"100%\",\n          width: \"100%\",\n          fontSize: \"43px\",\n          color: \"rgba(255,255,255,0.6)\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          opacity: Y ? \"0\" : \"1\"\n        }\n      }, !!$ && /* @__PURE__ */ React.createElement(\"div\", {\n        style: {\n          borderRadius: \"50%\",\n          background: \"#555\",\n          width: \"70px\",\n          height: \"70px\",\n          textTransform: \"uppercase\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          lineHeight: \"1em\"\n        }\n      }, \"RTMP\")), /* @__PURE__ */ React.createElement(\"div\", {\n        style: {\n          position: \"relative\",\n          display: \"flex\",\n          height: \"100%\",\n          width: \"100%\",\n          ...!!((Z = $ == null ? void 0 : $.props) != null && Z.mirrored) && {\n            transform: \"scaleX(-1)\"\n          }\n        }\n      }, /* @__PURE__ */ React.createElement(\"video\", {\n        ref: J,\n        autoPlay: !0,\n        muted: B,\n        disablePictureInPicture: !0,\n        playsInline: !0,\n        style: {\n          left: \"50%\",\n          top: \"50%\",\n          position: \"relative\",\n          transform: \"translate3d(-50%, -50%, 0)\",\n          height: \"100%\",\n          opacity: Y ? \"1\" : \"0\",\n          objectFit: \"cover\",\n          background: \"rgba(0,0,0,0.6)\"\n        }\n      })), !!($ != null && $.props.displayName) && /* @__PURE__ */ React.createElement(\"div\", {\n        className: \"NameBannerContainer\",\n        style: {\n          width: \"100%\",\n          height: \"100%\",\n          position: \"absolute\"\n        }\n      }, /* @__PURE__ */ React.createElement(\"div\", {\n        className: \"NameBanner\",\n        \"data-size\": G,\n        style: {\n          padding: \"12px 30px\",\n          width: \"fit-content\",\n          height: \"fit-content\",\n          top: \"100%\",\n          transform: \"translateY(-100%)\",\n          left: 0\n        }\n      }, /* @__PURE__ */ React.createElement(\"div\", {\n        className: \"NameBanner-body\"\n      }, $ == null ? void 0 : $.props.displayName))));\n    }, L = () => ReactDOM.render(/* @__PURE__ */ React.createElement(k, {\n      source: g,\n      props: E\n    }), v);\n    return a((M) => {\n      E = M, L();\n    }), u((M) => {\n      g = M, L();\n    }), c((M) => {\n      E = M, L();\n    }), {\n      root: v\n    };\n  }\n}, Transforms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  Background: Background$1,\n  Banner: Banner$1,\n  ChatOverlay,\n  Element: Element$1,\n  Image: Image$1,\n  Image2,\n  Logo: Logo$1,\n  Overlay,\n  RTMPSource,\n  RoomParticipant: RoomParticipant$1,\n  Square,\n  Video,\n  Video2\n}, Symbol.toStringTag, { value: \"Module\" }));\n/*! (c) Andrea Giammarchi - ISC */\nvar self$1 = {};\ntry {\n  self$1.WeakMap = WeakMap;\n} catch (a) {\n  self$1.WeakMap = function(u, c) {\n    var l = c.defineProperty, v = c.hasOwnProperty, S = g.prototype;\n    return S.delete = function(_) {\n      return this.has(_) && delete _[this._];\n    }, S.get = function(_) {\n      return this.has(_) ? _[this._] : void 0;\n    }, S.has = function(_) {\n      return v.call(_, this._);\n    }, S.set = function(_, k) {\n      return l(_, this._, { configurable: !0, value: k }), this;\n    }, g;\n    function g(_) {\n      l(this, \"_\", { value: \"_@ungap/weakmap\" + u++ }), _ && _.forEach(E, this);\n    }\n    function E(_) {\n      this.set(_[0], _[1]);\n    }\n  }(Math.random(), Object);\n}\nconst WeakMap$1 = self$1.WeakMap;\n/*! (c) Andrea Giammarchi - ISC */\nvar UID = \"-\" + Math.random().toFixed(6) + \"%\", UID_IE = !1;\ntry {\n  (function(a, u, c) {\n    return u in a && (a.innerHTML = \"<p \" + c + '=\"' + UID + '\"></p>', a[u].childNodes[0].getAttribute(c) == UID);\n  })(document.createElement(\"template\"), \"content\", \"tabindex\") || (UID = \"_dt: \" + UID.slice(1, -1) + \";\", UID_IE = !0);\n} catch (a) {\n}\nvar UIDC = \"<!--\" + UID + \"-->\", COMMENT_NODE = 8, ELEMENT_NODE$1 = 1, TEXT_NODE = 3, SHOULD_USE_TEXT_CONTENT = /^(?:plaintext|script|style|textarea|title|xmp)$/i, VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\n/*! (c) Andrea Giammarchi - ISC */\nfunction domsanitizer(a) {\n  return a.join(UIDC).replace(selfClosing, fullClosing).replace(attrSeeker, attrReplacer);\n}\nvar spaces = \" \\\\f\\\\n\\\\r\\\\t\", almostEverything = \"[^\" + spaces + `\\\\/>\"'=]+`, attrName = \"[\" + spaces + \"]+\" + almostEverything, tagName = \"<([A-Za-z]+[A-Za-z0-9:._-]*)((?:\", attrPartials = `(?:\\\\s*=\\\\s*(?:'[^']*?'|\"[^\"]*?\"|<[^>]*?>|` + almostEverything.replace(\"\\\\/\", \"\") + \"))?)\", attrSeeker = new RegExp(tagName + attrName + attrPartials + \"+)([\" + spaces + \"]*/?>)\", \"g\"), selfClosing = new RegExp(tagName + attrName + attrPartials + \"*)([\" + spaces + \"]*/>)\", \"g\"), findAttributes = new RegExp(\"(\" + attrName + `\\\\s*=\\\\s*)(['\"]?)` + UIDC + \"\\\\2\", \"gi\");\nfunction attrReplacer(a, u, c, l) {\n  return \"<\" + u + c.replace(findAttributes, replaceAttributes) + l;\n}\nfunction replaceAttributes(a, u, c) {\n  return u + (c || '\"') + UID + (c || '\"');\n}\nfunction fullClosing(a, u, c) {\n  return VOID_ELEMENTS.test(u) ? a : \"<\" + u + c + \"></\" + u + \">\";\n}\nconst { isArray } = Array, { indexOf, slice } = [], umap = (a) => ({\n  // About: get: _.get.bind(_)\n  // It looks like WebKit/Safari didn't optimize bind at all,\n  // so that using bind slows it down by 60%.\n  // Firefox and Chrome are just fine in both cases,\n  // so let's use the approach that works fast everywhere 👍\n  get: (u) => a.get(u),\n  set: (u, c) => (a.set(u, c), c)\n}), ELEMENT_NODE = 1, nodeType = 111, remove = ({ firstChild: a, lastChild: u }) => {\n  const c = document.createRange();\n  return c.setStartAfter(a), c.setEndAfter(u), c.deleteContents(), a;\n}, diffable = (a, u) => a.nodeType === nodeType ? 1 / u < 0 ? u ? remove(a) : a.lastChild : u ? a.valueOf() : a.firstChild : a, persistent = (a) => {\n  const { childNodes: u } = a, { length: c } = u;\n  if (c < 2)\n    return c ? u[0] : a;\n  const l = slice.call(u, 0), v = l[0], S = l[c - 1];\n  return {\n    ELEMENT_NODE,\n    nodeType,\n    firstChild: v,\n    lastChild: S,\n    valueOf() {\n      if (u.length !== c) {\n        let g = 0;\n        for (; g < c; )\n          a.appendChild(l[g++]);\n      }\n      return a;\n    }\n  };\n};\n/*! (c) Andrea Giammarchi - ISC */\nvar createContent = function(a) {\n  var u = \"fragment\", c = \"template\", l = \"content\" in g(c), v = l ? function(_) {\n    var k = g(c);\n    return k.innerHTML = _, k.content;\n  } : function(_) {\n    var k = g(u), L = g(c), M = null;\n    if (/^[^\\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(_)) {\n      var $ = RegExp.$1;\n      L.innerHTML = \"<table>\" + _ + \"</table>\", M = L.querySelectorAll($);\n    } else\n      L.innerHTML = _, M = L.childNodes;\n    return S(k, M), k;\n  };\n  return function(k, L) {\n    return (L === \"svg\" ? E : v)(k);\n  };\n  function S(_, k) {\n    for (var L = k.length; L--; )\n      _.appendChild(k[0]);\n  }\n  function g(_) {\n    return _ === u ? a.createDocumentFragment() : a.createElementNS(\"http://www.w3.org/1999/xhtml\", _);\n  }\n  function E(_) {\n    var k = g(u), L = g(\"div\");\n    return L.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\">' + _ + \"</svg>\", S(k, L.firstChild.childNodes), k;\n  }\n}(document);\nconst udomdiff = (a, u, c, l, v) => {\n  const S = c.length;\n  let g = u.length, E = S, _ = 0, k = 0, L = null;\n  for (; _ < g || k < E; )\n    if (g === _) {\n      const M = E < S ? k ? l(c[k - 1], -0).nextSibling : l(c[E - k], 0) : v;\n      for (; k < E; )\n        a.insertBefore(l(c[k++], 1), M);\n    } else if (E === k)\n      for (; _ < g; )\n        (!L || !L.has(u[_])) && a.removeChild(l(u[_], -1)), _++;\n    else if (u[_] === c[k])\n      _++, k++;\n    else if (u[g - 1] === c[E - 1])\n      g--, E--;\n    else if (u[_] === c[E - 1] && c[k] === u[g - 1]) {\n      const M = l(u[--g], -1).nextSibling;\n      a.insertBefore(\n        l(c[k++], 1),\n        l(u[_++], -1).nextSibling\n      ), a.insertBefore(l(c[--E], 1), M), u[g] = c[E];\n    } else {\n      if (!L) {\n        L = /* @__PURE__ */ new Map();\n        let M = k;\n        for (; M < E; )\n          L.set(c[M], M++);\n      }\n      if (L.has(u[_])) {\n        const M = L.get(u[_]);\n        if (k < M && M < E) {\n          let $ = _, J = 1;\n          for (; ++$ < g && $ < E && L.get(u[$]) === M + J; )\n            J++;\n          if (J > M - k) {\n            const V = l(u[_], 0);\n            for (; k < M; )\n              a.insertBefore(l(c[k++], 1), V);\n          } else\n            a.replaceChild(\n              l(c[k++], 1),\n              l(u[_++], -1)\n            );\n        } else\n          _++;\n      } else\n        a.removeChild(l(u[_++], -1));\n    }\n  return c;\n};\n/*! (c) Andrea Giammarchi - ISC */\nvar importNode = function(a, u, c, l, v) {\n  var S = v in a, g = a.createDocumentFragment();\n  g[u](a[l](\"g\")), g[u](a[l](\"\"));\n  var E = S ? a[v](g, !0) : g[c](!0);\n  return E.childNodes.length < 2 ? function _(k, L) {\n    for (var M = k[c](), $ = k.childNodes || [], J = $.length, V = 0; L && V < J; V++)\n      M[u](_($[V], L));\n    return M;\n  } : (\n    /* istanbul ignore next */\n    S ? a[v] : function(_, k) {\n      return _[c](!!k);\n    }\n  );\n}(\n  document,\n  \"appendChild\",\n  \"cloneNode\",\n  \"createTextNode\",\n  \"importNode\"\n), trim = \"\".trim || /* istanbul ignore next */\nfunction() {\n  return String(this).replace(/^\\s+|\\s+/g, \"\");\n}, normalizeAttributes = UID_IE ? function(a, u) {\n  var c = u.join(\" \");\n  return u.slice.call(a, 0).sort(function(l, v) {\n    return c.indexOf(l.name) <= c.indexOf(v.name) ? -1 : 1;\n  });\n} : function(a, u) {\n  return u.slice.call(a, 0);\n};\nfunction find(a, u) {\n  for (var c = u.length, l = 0; l < c; )\n    a = a.childNodes[u[l++]];\n  return a;\n}\nfunction parse(a, u, c, l) {\n  for (var v = a.childNodes, S = v.length, g = 0; g < S; ) {\n    var E = v[g];\n    switch (E.nodeType) {\n      case ELEMENT_NODE$1:\n        var _ = l.concat(g);\n        parseAttributes(E, u, c, _), parse(E, u, c, _);\n        break;\n      case COMMENT_NODE:\n        var k = E.textContent;\n        if (k === UID)\n          c.shift(), u.push(\n            // basicHTML or other non standard engines\n            // might end up having comments in nodes\n            // where they shouldn't, hence this check.\n            SHOULD_USE_TEXT_CONTENT.test(a.nodeName) ? Text(a, l) : Any(E, l.concat(g))\n          );\n        else\n          switch (k.slice(0, 2)) {\n            case \"/*\":\n              if (k.slice(-2) !== \"*/\")\n                break;\n            case \"👻\":\n              a.removeChild(E), g--, S--;\n          }\n        break;\n      case TEXT_NODE:\n        SHOULD_USE_TEXT_CONTENT.test(a.nodeName) && trim.call(E.textContent) === UIDC && (c.shift(), u.push(Text(a, l)));\n        break;\n    }\n    g++;\n  }\n}\nfunction parseAttributes(a, u, c, l) {\n  for (var v = a.attributes, S = [], g = [], E = normalizeAttributes(v, c), _ = E.length, k = 0; k < _; ) {\n    var L = E[k++], M = L.value === UID, $;\n    if (M || 1 < ($ = L.value.split(UIDC)).length) {\n      var J = L.name;\n      if (S.indexOf(J) < 0) {\n        S.push(J);\n        var V = c.shift().replace(\n          M ? /^(?:|[\\S\\s]*?\\s)(\\S+?)\\s*=\\s*('|\")?$/ : new RegExp(\n            \"^(?:|[\\\\S\\\\s]*?\\\\s)(\" + J + `)\\\\s*=\\\\s*('|\")[\\\\S\\\\s]*`,\n            \"i\"\n          ),\n          \"$1\"\n        ), q = v[V] || // the following ignore is covered by browsers\n        // while basicHTML is already case-sensitive\n        /* istanbul ignore next */\n        v[V.toLowerCase()];\n        if (M)\n          u.push(Attr(q, l, V, null));\n        else {\n          for (var G = $.length - 2; G--; )\n            c.shift();\n          u.push(Attr(q, l, V, $));\n        }\n      }\n      g.push(L);\n    }\n  }\n  _ = g.length, k = 0;\n  for (var H = 0 < _ && UID_IE && !(\"ownerSVGElement\" in a); k < _; ) {\n    var B = g[k++];\n    H && (B.value = \"\"), a.removeAttribute(B.name);\n  }\n  var Y = a.nodeName;\n  if (/^script$/i.test(Y)) {\n    var ne = document.createElement(Y);\n    for (_ = v.length, k = 0; k < _; )\n      ne.setAttributeNode(v[k++].cloneNode(!0));\n    ne.textContent = a.textContent, a.parentNode.replaceChild(ne, a);\n  }\n}\nfunction Any(a, u) {\n  return {\n    type: \"any\",\n    node: a,\n    path: u\n  };\n}\nfunction Attr(a, u, c, l) {\n  return {\n    type: \"attr\",\n    node: a,\n    path: u,\n    name: c,\n    sparse: l\n  };\n}\nfunction Text(a, u) {\n  return {\n    type: \"text\",\n    node: a,\n    path: u\n  };\n}\nvar parsed = umap(new WeakMap$1());\nfunction createInfo(a, u) {\n  var c = (a.convert || domsanitizer)(u), l = a.transform;\n  l && (c = l(c));\n  var v = createContent(c, a.type);\n  cleanContent(v);\n  var S = [];\n  return parse(v, S, u.slice(0), []), {\n    content: v,\n    updates: function(g) {\n      for (var E = [], _ = S.length, k = 0, L = 0; k < _; ) {\n        var M = S[k++], $ = find(g, M.path);\n        switch (M.type) {\n          case \"any\":\n            E.push({ fn: a.any($, []), sparse: !1 });\n            break;\n          case \"attr\":\n            var J = M.sparse, V = a.attribute($, M.name, M.node);\n            J === null ? E.push({ fn: V, sparse: !1 }) : (L += J.length - 2, E.push({ fn: V, sparse: !0, values: J }));\n            break;\n          case \"text\":\n            E.push({ fn: a.text($), sparse: !1 }), $.textContent = \"\";\n            break;\n        }\n      }\n      return _ += L, function() {\n        var q = arguments.length;\n        if (_ !== q - 1)\n          throw new Error(\n            q - 1 + \" values instead of \" + _ + `\n` + u.join(\"${value}\")\n          );\n        for (var G = 1, H = 1; G < q; ) {\n          var B = E[G - H];\n          if (B.sparse) {\n            var Y = B.values, ne = Y[0], Z = 1, re = Y.length;\n            for (H += re - 2; Z < re; )\n              ne += arguments[G++] + Y[Z++];\n            B.fn(ne);\n          } else\n            B.fn(arguments[G++]);\n        }\n        return g;\n      };\n    }\n  };\n}\nfunction createDetails(a, u) {\n  var c = parsed.get(u) || parsed.set(u, createInfo(a, u));\n  return c.updates(importNode.call(document, c.content, !0));\n}\nvar empty = [];\nfunction domtagger(a) {\n  var u = empty, c = cleanContent;\n  return function(l) {\n    return u !== l && (c = createDetails(a, u = l)), c.apply(null, arguments);\n  };\n}\nfunction cleanContent(a) {\n  for (var u = a.childNodes, c = u.length; c--; ) {\n    var l = u[c];\n    l.nodeType !== 1 && trim.call(l.textContent).length === 0 && a.removeChild(l);\n  }\n}\n/*! (c) Andrea Giammarchi - ISC */\nvar hyperStyle = /* @__PURE__ */ function() {\n  var a = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i, u = /([^A-Z])([A-Z]+)/g;\n  return function(E, _) {\n    return \"ownerSVGElement\" in E ? l(E, _) : S(E.style, !1);\n  };\n  function c(g, E, _) {\n    return E + \"-\" + _.toLowerCase();\n  }\n  function l(g, E) {\n    var _;\n    return E ? _ = E.cloneNode(!0) : (g.setAttribute(\"style\", \"--hyper:style;\"), _ = g.getAttributeNode(\"style\")), _.value = \"\", g.setAttributeNode(_), S(_, !0);\n  }\n  function v(g) {\n    var E, _ = [];\n    for (E in g)\n      _.push(E.replace(u, c), \":\", g[E], \";\");\n    return _.join(\"\");\n  }\n  function S(g, E) {\n    var _, k;\n    return function(L) {\n      var M, $, J, V;\n      switch (typeof L) {\n        case \"object\":\n          if (L) {\n            if (_ === \"object\") {\n              if (!E && k !== L)\n                for ($ in k)\n                  $ in L || (g[$] = \"\");\n            } else\n              E ? g.value = \"\" : g.cssText = \"\";\n            M = E ? {} : g;\n            for ($ in L)\n              V = L[$], J = typeof V == \"number\" && !a.test($) ? V + \"px\" : V, !E && /^--/.test($) ? M.setProperty($, J) : M[$] = J;\n            _ = \"object\", E ? g.value = v(k = M) : k = L;\n            break;\n          }\n        default:\n          k != L && (_ = \"string\", k = L, E ? g.value = L || \"\" : g.cssText = L || \"\");\n          break;\n      }\n    };\n  }\n}();\nconst aria = (a) => (u) => {\n  for (const c in u) {\n    const l = c === \"role\" ? c : `aria-${c}`, v = u[c];\n    v == null ? a.removeAttribute(l) : a.setAttribute(l, v);\n  }\n}, attribute = (a, u) => {\n  let c, l = !0;\n  const v = document.createAttributeNS(null, u);\n  return (S) => {\n    c !== S && (c = S, c == null ? l || (a.removeAttributeNode(v), l = !0) : (v.value = S, l && (a.setAttributeNodeNS(v), l = !1)));\n  };\n}, boolean = (a, u, c) => (l) => {\n  c !== !!l && ((c = !!l) ? a.setAttribute(u, \"\") : a.removeAttribute(u));\n}, data = ({ dataset: a }) => (u) => {\n  for (const c in u) {\n    const l = u[c];\n    l == null ? delete a[c] : a[c] = l;\n  }\n}, event = (a, u) => {\n  let c, l = u.slice(2);\n  return !(u in a) && u.toLowerCase() in a && (l = l.toLowerCase()), (v) => {\n    const S = isArray(v) ? v : [v, !1];\n    c !== S[0] && (c && a.removeEventListener(l, c, S[1]), (c = S[0]) && a.addEventListener(l, c, S[1]));\n  };\n}, ref = (a) => (u) => {\n  typeof u == \"function\" ? u(a) : u.current = a;\n}, setter = (a, u) => u === \"dataset\" ? data(a) : (c) => {\n  a[u] = c;\n}, hyperProperty = (a, u) => {\n  let c;\n  return (l) => {\n    c !== l && (c = l, a[u] !== l && (l == null ? (a[u] = \"\", a.removeAttribute(u)) : a[u] = l));\n  };\n}, readOnly = /^(?:form|list)$/i, text = (a, u) => a.ownerDocument.createTextNode(u);\nfunction Tagger(a) {\n  return this.type = a, domtagger(this);\n}\nTagger.prototype = {\n  // there are four kind of attributes, and related behavior:\n  //  * events, with a name starting with `on`, to add/remove event listeners\n  //  * special, with a name present in their inherited prototype, accessed directly\n  //  * regular, accessed through get/setAttribute standard DOM methods\n  //  * style, the only regular attribute that also accepts an object as value\n  //    so that you can style=${{width: 120}}. In this case, the behavior has been\n  //    fully inspired by Preact library and its simplicity.\n  attribute(a, u, c) {\n    const l = this.type === \"svg\";\n    switch (u) {\n      case \"class\":\n        if (l)\n          return attribute(a, u);\n        u = \"className\";\n      case \"props\":\n        return setter(a, u);\n      case \"aria\":\n        return aria(a);\n      case \"style\":\n        return hyperStyle(a, c, l);\n      case \"ref\":\n        return ref(a);\n      case \".dataset\":\n        return data(a);\n      default:\n        return u.slice(0, 1) === \".\" ? setter(a, u.slice(1)) : u.slice(0, 1) === \"?\" ? boolean(a, u.slice(1)) : u.slice(0, 2) === \"on\" ? event(a, u) : u in a && !(l || readOnly.test(u)) ? hyperProperty(a, u) : attribute(a, u);\n    }\n  },\n  // in a hyper(node)`<div>${content}</div>` case\n  // everything could happen:\n  //  * it's a JS primitive, stored as text\n  //  * it's null or undefined, the node should be cleaned\n  //  * it's a promise, update the content once resolved\n  //  * it's an explicit intent, perform the desired operation\n  //  * it's an Array, resolve all values if Promises and/or\n  //    update the node with the resulting list of content\n  any(a, u) {\n    const { type: c } = this;\n    let l = !1, v;\n    const S = (g) => {\n      switch (typeof g) {\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n          l ? v !== g && (v = g, u[0].textContent = g) : (l = !0, v = g, u = udomdiff(\n            a.parentNode,\n            u,\n            [text(a, g)],\n            diffable,\n            a\n          ));\n          break;\n        case \"function\":\n          S(g(a));\n          break;\n        case \"object\":\n        case \"undefined\":\n          if (g == null) {\n            l = !1, u = udomdiff(\n              a.parentNode,\n              u,\n              [],\n              diffable,\n              a\n            );\n            break;\n          }\n        default:\n          if (l = !1, v = g, isArray(g))\n            if (g.length === 0)\n              u.length && (u = udomdiff(\n                a.parentNode,\n                u,\n                [],\n                diffable,\n                a\n              ));\n            else\n              switch (typeof g[0]) {\n                case \"string\":\n                case \"number\":\n                case \"boolean\":\n                  S(String(g));\n                  break;\n                case \"function\":\n                  S(g.map(invoke, a));\n                  break;\n                case \"object\":\n                  isArray(g[0]) && (g = g.concat.apply([], g));\n                default:\n                  u = udomdiff(\n                    a.parentNode,\n                    u,\n                    g,\n                    diffable,\n                    a\n                  );\n                  break;\n              }\n          else\n            \"ELEMENT_NODE\" in g ? u = udomdiff(\n              a.parentNode,\n              u,\n              g.nodeType === 11 ? slice.call(g.childNodes) : [g],\n              diffable,\n              a\n            ) : \"text\" in g ? S(String(g.text)) : \"any\" in g ? S(g.any) : \"html\" in g ? u = udomdiff(\n              a.parentNode,\n              u,\n              slice.call(\n                createContent(\n                  [].concat(g.html).join(\"\"),\n                  c\n                ).childNodes\n              ),\n              diffable,\n              a\n            ) : \"length\" in g && S(slice.call(g));\n          break;\n      }\n    };\n    return S;\n  },\n  // style or textareas don't accept HTML as content\n  // it's pointless to transform or analyze anything\n  // different from text there but it's worth checking\n  // for possible defined intents.\n  text(a) {\n    let u;\n    const c = (l) => {\n      if (u !== l) {\n        u = l;\n        const v = typeof l;\n        v === \"object\" && l ? \"text\" in l ? c(String(l.text)) : \"any\" in l ? c(l.any) : \"html\" in l ? c([].concat(l.html).join(\"\")) : \"length\" in l && c(slice.call(l).join(\"\")) : v === \"function\" ? c(l(a)) : a.textContent = l ?? \"\";\n      }\n    };\n    return c;\n  }\n};\nfunction invoke(a) {\n  return a(this);\n}\nconst { create: create$1, freeze, keys } = Object, cache = umap(new WeakMap$1()), createRender = (a) => ({\n  html: outer(\"html\", a),\n  svg: outer(\"svg\", a),\n  render(u, c) {\n    const l = typeof c == \"function\" ? c() : c, v = cache.get(u) || cache.set(u, createCache()), S = l instanceof LighterHole ? unroll(a, v, l) : l;\n    return S !== v.wire && (v.wire = S, u.textContent = \"\", u.appendChild(S.valueOf())), u;\n  }\n}), createCache = () => ({ stack: [], entry: null, wire: null }), outer = (a, u) => {\n  const c = umap(new WeakMap$1()), l = (S) => function() {\n    return unroll(u, S, v.apply(null, arguments));\n  };\n  return v.for = (S, g) => {\n    const E = c.get(S) || c.set(S, create$1(null));\n    return E[g] || (E[g] = l(createCache()));\n  }, v.node = function() {\n    return unroll(\n      u,\n      createCache(),\n      v.apply(null, arguments)\n    ).valueOf();\n  }, v;\n  function v() {\n    return new LighterHole(a, tta.apply(null, arguments));\n  }\n}, unroll = (a, u, { type: c, template: l, values: v }) => {\n  const { length: S } = v;\n  unrollValues(a, u, v, S);\n  let { entry: g } = u;\n  if (!g || g.template !== l || g.type !== c) {\n    const E = new a(c);\n    u.entry = g = {\n      type: c,\n      template: l,\n      tag: E,\n      wire: persistent(E(l, ...v))\n    };\n  } else\n    g.tag(l, ...v);\n  return g.wire;\n}, unrollValues = (a, { stack: u }, c, l) => {\n  for (let v = 0; v < l; v++) {\n    const S = c[v];\n    S instanceof Hole ? c[v] = unroll(\n      a,\n      u[v] || (u[v] = createCache()),\n      S\n    ) : isArray(S) ? unrollValues(\n      a,\n      u[v] || (u[v] = createCache()),\n      S,\n      S.length\n    ) : u[v] = null;\n  }\n  l < u.length && u.splice(l);\n};\nfreeze(LighterHole);\nfunction LighterHole(a, u) {\n  this.type = a, this.template = u.shift(), this.values = u;\n}\nconst Hole = LighterHole, { render, html, svg } = createRender(Tagger);\nfunction tta() {\n  let a = [], u = 0, { length: c } = arguments;\n  for (; u < c; )\n    a.push(arguments[u++]);\n  return a;\n}\nconst Free = {\n  name: \"Free\",\n  layout: ({\n    props: a,\n    children: u,\n    size: c\n  }) => u.reduce((l, v) => {\n    const {\n      size: S = {\n        x: \"100%\",\n        y: \"100%\"\n      },\n      position: g = {\n        x: 0,\n        y: 0\n      },\n      opacity: E = 1\n    } = v.props;\n    return {\n      ...l,\n      [v.id]: {\n        position: {\n          x: g.x,\n          y: g.y\n        },\n        size: {\n          x: S.x,\n          y: S.y\n        },\n        opacity: E\n      }\n    };\n  }, {})\n}, Column = {\n  name: \"Column\",\n  layout: ({\n    props: a = {},\n    children: u,\n    size: c\n  }) => {\n    let {\n      justify: l = \"center\",\n      align: v = \"center\",\n      cover: S = !1,\n      margin: g = {},\n      dimensions: E = 16 / 9,\n      reverse: _ = !1\n    } = a;\n    const k = S ? 0 : Math.min(c.y / 6, 12);\n    g = {\n      left: k,\n      right: k,\n      top: k,\n      bottom: k,\n      between: k,\n      ...g\n    };\n    const L = c.y - g.top - g.bottom, M = c.x - g.left - g.right, $ = g.between * ((u.length || 1) - 1), J = Math.min(M, (L - $) / (u.length || 1) * E), V = J / E;\n    return html.node`\n      <div style=${{\n      height: \"100%\",\n      width: S ? c.x + \"px\" : \"auto\",\n      display: \"flex\",\n      flexDirection: _ ? \"column-reverse\" : \"column\",\n      justifyContent: l,\n      alignItems: v,\n      paddingLeft: g.left + \"px\",\n      paddingTop: g.top + \"px\",\n      paddingBottom: g.bottom + \"px\",\n      paddingRight: g.right + \"px\"\n    }}>\n      ${u.map((q, G) => html.node`<div data-node-id=${q.id} .data=${{\n      entryTransition: {\n        delay: 400 + G * 100,\n        offset: {\n          x: 0,\n          y: \"100%\"\n        },\n        scale: {\n          x: 0.8,\n          y: 0.8\n        },\n        opacity: 0\n      },\n      exitTransition: {\n        offset: {\n          x: 0,\n          y: 1e3\n        },\n        scale: {\n          x: 0.8,\n          y: 0.8\n        },\n        opacity: 0\n      },\n      borderRadius: S ? 0 : 5\n    }} style=${{\n      display: \"flex\",\n      width: S ? \"100%\" : J + \"px\",\n      height: S ? V + \"px\" : \"auto\",\n      aspectRatio: E,\n      marginBottom: G === u.length - 1 ? 0 : g.between + \"px\",\n      flexGrow: 0,\n      flexShrink: 1,\n      flexBasis: V + \"px\"\n    }}></div>`)}\n      </div>\n    `;\n  }\n}, Row = {\n  name: \"Row\",\n  layout: ({\n    props: a = {},\n    children: u,\n    size: c\n  }) => {\n    let {\n      justify: l = \"center\",\n      align: v = \"center\",\n      cover: S = !1,\n      margin: g = {},\n      dimensions: E,\n      maxWidth: _ = 1,\n      reverse: k = !1\n    } = a;\n    const L = S ? 0 : Math.min(c.y / 6, 12);\n    g = {\n      left: L,\n      right: L,\n      top: L,\n      bottom: L,\n      between: L,\n      ...g\n    };\n    const M = c.y - g.top - g.bottom, $ = c.x - g.left - g.right, J = g.between * ((u.length || 1) - 1);\n    let V = M, q = Math.min(($ - J) / (u.length || 1), E ? M * E : $, _ * c.x);\n    return E && (V = q / E), html.node`\n      <div style=${{\n      height: S ? c.y + \"px\" : \"auto\",\n      width: \"100%\",\n      display: \"flex\",\n      flexDirection: k ? \"row-reverse\" : \"row\",\n      justifyContent: l,\n      alignItems: v,\n      paddingLeft: g.left + \"px\",\n      paddingTop: g.top + \"px\",\n      paddingBottom: g.bottom + \"px\",\n      paddingRight: g.right + \"px\"\n    }}>\n          ${u.map((G, H) => html.node`<div data-node-id=${G.id} .data=${{\n      entryTransition: {\n        delay: 400 + H * 100,\n        offset: {\n          x: 0,\n          y: \"100%\"\n        },\n        scale: {\n          x: 0.8,\n          y: 0.8\n        },\n        opacity: 0\n      },\n      exitTransition: {\n        offset: {\n          x: 0,\n          y: 1e3\n        },\n        scale: {\n          x: 0.8,\n          y: 0.8\n        },\n        opacity: 0\n      },\n      borderRadius: S ? 0 : 5\n    }} style=${{\n      display: \"flex\",\n      height: S ? \"100%\" : V + \"px\",\n      width: q + \"px\",\n      marginRight: H === u.length - 1 ? 0 : g.between + \"px\",\n      flexGrow: 0,\n      flexShrink: 1,\n      flexBasis: q + \"px\"\n    }}></div>`)}\n      </div>\n    `;\n  }\n}, toMatrix = (a, u) => a.reduce((c, l, v) => (v % u == 0 ? c.push([v]) : c[c.length - 1].push(v)) && c, []), Grid = {\n  name: \"Grid\",\n  layout: ({\n    props: a = {},\n    children: u,\n    size: c\n  }) => {\n    let {\n      dimensions: l,\n      numPerRow: v,\n      margin: S,\n      cover: g = !1,\n      maxWidth: E,\n      between: _\n    } = a;\n    const k = u.length === 0 || g ? 0 : _ || Math.min(c.y / u.length / 10, 30);\n    S = S ?? k;\n    const L = c.x < c.y;\n    _ = typeof _ == \"number\" ? _ : S;\n    let M = [];\n    v ? M = toMatrix(u, v) : M = L ? getTallGrid(u.length) : getWideGrid(u.length);\n    const $ = (c.y - (S * 2 + _ * (M.length - 1))) / M.length, J = c.x - S * 2;\n    return html.node`\n    <div style=${{\n      display: \"flex\",\n      width: \"100%\",\n      height: \"100%\",\n      flexDirection: \"column\",\n      justifyContent: \"center\",\n      padding: S + \"px\",\n      gap: _ + \"px\",\n      flexGrow: 0\n    }}>${M.map((V, q) => Row.layout({\n      props: {\n        justify: \"center\",\n        dimensions: l,\n        cover: g,\n        maxWidth: E || 1 / (M[0].length || 1),\n        margin: {\n          top: 0,\n          right: 0,\n          left: 0,\n          bottom: 0,\n          between: _\n        }\n      },\n      children: V.map((G) => u[G]),\n      size: {\n        y: $,\n        x: J\n      }\n    }))}</div>`;\n  }\n}, Presentation = {\n  name: \"Presentation\",\n  layout: ({\n    props: a = {},\n    children: u,\n    size: c\n  }) => {\n    let {\n      margin: l,\n      cover: v = !1,\n      barWidth: S = 0.2,\n      barPosition: g = \"side\",\n      presentationDimensions: E = 16 / 9,\n      viewerDimensions: _ = 16 / 9,\n      justifyViewers: k = \"center\",\n      useGrid: L = !1,\n      reverse: M = !1\n    } = a;\n    const $ = g === \"side\" ? c.x * S : c.y * S, J = u[0], V = u.filter((Z) => Z !== J), q = u.length <= 1 ? 0 : Math.min(c.x / 80, 30);\n    if (l = l ?? q, !J)\n      return Grid.layout({\n        props: a,\n        children: u,\n        size: c\n      });\n    const G = u[1], H = {\n      ...c\n    };\n    G && (g === \"side\" ? (H.x = c.x - $, H.y = H.x / E) : (H.y = c.y - $, H.x = H.y * E));\n    let B, Y = {};\n    L ? (B = Grid.layout, Y = {\n      cover: v,\n      ...v ? {\n        maxWidth: 1\n      } : {\n        margin: l\n      }\n    }) : (B = g === \"side\" ? Column.layout : Row.layout, Y = {\n      margin: {\n        top: l,\n        left: l,\n        bottom: l,\n        right: l,\n        between: l\n      },\n      dimensions: _,\n      justify: k,\n      align: \"flex-end\"\n    });\n    const ne = g === \"side\" ? M ? \"left\" : \"right\" : M ? \"top\" : \"bottom\";\n    return html.node`\n      <div style=${{\n      display: \"flex\",\n      flexDirection: (g === \"side\" ? \"row\" : \"column\") + (M ? \"-reverse\" : \"\"),\n      justifyContent: \"space-around\",\n      alignItems: \"center\",\n      position: \"relative\",\n      padding: v ? 0 : l,\n      [`padding-${ne}`]: 0\n    }}>\n        ${u[0] && html.node`<div style=${{\n      // aspectRatio: String(presentationDimensions),\n      width: H.x,\n      height: H.y,\n      display: \"flex\",\n      flexGrow: 1\n    }}>\n            <div data-node-id=${J.id} .data=${{\n      dimensions: E,\n      borderRadius: v ? 0 : 5,\n      entryTransition: {\n        delay: 0,\n        offset: {\n          x: 0,\n          y: 1e3\n        },\n        scale: {\n          x: 0.5,\n          y: 0.5\n        },\n        opacity: 0\n      },\n      exitTransition: {\n        offset: {\n          x: 0,\n          y: 1e3\n        },\n        scale: {\n          x: 2,\n          y: 2\n        },\n        opacity: 0\n      }\n    }} style=${{\n      width: \"100%\",\n      height: \"100%\",\n      ...v ? {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        width: L && G ? 100 - S * 100 + \"%\" : \"100%\",\n        height: \"100%\"\n      } : {}\n    }} />\n          </div>`}\n        ${html.node`<div style=${{\n      ...g === \"side\" ? {\n        maxWidth: S * 100 + \"%\",\n        height: \"100%\"\n      } : {\n        maxHeight: S * 100 + \"%\",\n        width: \"100%\"\n      }\n    }}>${G && B({\n      props: Y,\n      children: V,\n      size: g === \"side\" ? {\n        x: $,\n        y: c.y\n      } : {\n        x: c.x,\n        y: $\n      }\n    })}</div>`}\n      </div>\n    `;\n  }\n}, Layered = {\n  name: \"Layered\",\n  layout: ({\n    props: a = {},\n    children: u,\n    size: c\n  }) => html.node`<div style=${{\n    width: \"100%\",\n    height: \"100%\",\n    position: \"relative\"\n  }}>\n      ${u.map((l, v) => html.node`<div data-node-id=${l.id} .data=${{\n    zIndex: v + 1\n  }} style=${{\n    position: \"absolute\",\n    inset: \"0px\"\n  }}></div>`)}\n    </div>`\n}, getWideGrid = (a = 0) => {\n  switch (a) {\n    case 0:\n      return [[]];\n    case 1:\n      return [[0]];\n    case 2:\n      return [[0, 1]];\n    case 3:\n      return [[0, 1], [2]];\n    case 4:\n      return [[0, 1], [2, 3]];\n    case 5:\n      return [[0, 1, 2], [3, 4]];\n    case 6:\n      return [[0, 1, 2], [3, 4, 5]];\n    case 7:\n      return [[0, 1, 2], [3, 4, 5], [6]];\n    case 8:\n      return [[0, 1, 2], [3, 4, 5], [6, 7]];\n  }\n  const u = Array(a).fill(null).map((c, l) => l);\n  return toMatrix(u, Math.round(Math.sqrt(a)));\n}, getTallGrid = (a = 0) => {\n  switch (a) {\n    case 0:\n      return [[]];\n    case 1:\n      return [[0]];\n    case 2:\n      return [[0], [1]];\n    case 3:\n      return [[0, 1], [2]];\n    case 4:\n      return [[0, 1], [2, 3]];\n    case 5:\n      return [[0, 1], [2, 3], [4]];\n    case 6:\n      return [[0, 1], [2, 3], [4, 5]];\n    case 7:\n      return [[0, 1], [2, 3], [4, 5], [6]];\n    case 8:\n      return [[0, 1], [2, 3], [4, 5], [6, 7]];\n  }\n  const u = Array(a).fill(null).map((c, l) => l);\n  return toMatrix(u, Math.ceil(Math.sqrt(u.length)) - 1);\n}, Layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  Column,\n  Free,\n  Grid,\n  Layered,\n  Presentation,\n  Row\n}, Symbol.toStringTag, { value: \"Module\" })), deviceWatchers = /* @__PURE__ */ new Set(), updateMediaStreamTracks = (a, u) => {\n  const c = {\n    audio: a.getAudioTracks()[0],\n    video: a.getVideoTracks()[0]\n  };\n  c.audio !== u.audio && (c.audio && a.removeTrack(c.audio), u.audio && a.addTrack(u.audio)), c.video !== u.video && (c.video && a.removeTrack(c.video), u.video && a.addTrack(u.video));\n}, getDevicePermissions = async () => {\n  const a = {\n    audio: !0,\n    video: !0\n  };\n  return Promise.all([navigator.mediaDevices.getUserMedia({\n    video: !0\n  }).then((u) => {\n    u.getTracks().forEach((c) => c.stop());\n  }).catch((u) => {\n    u.name === \"NotAllowedError\" && (a.video = !1);\n  }), navigator.mediaDevices.getUserMedia({\n    audio: !0\n  }).then((u) => {\n    u.getTracks().forEach((c) => c.stop());\n  }).catch((u) => {\n    u.name === \"NotAllowedError\" && (a.audio = !1);\n  })]).then(() => a);\n}, ensureDevicePermissions = async () => getDevicePermissions(), watchDevices = (a) => (deviceWatchers.size === 0 && navigator.mediaDevices.addEventListener(\"devicechange\", reportDevices), deviceWatchers.add(a), reportDevices().catch(() => {\n}), () => {\n  deviceWatchers.delete(a), deviceWatchers.size === 0 && navigator.mediaDevices.removeEventListener(\"devicechange\", reportDevices);\n}), getUserMedia = async (...a) => {\n  const u = await navigator.mediaDevices.getUserMedia(...a);\n  return reportDevices(), u;\n}, deviceWithDefaultLabel = (a, u) => ({\n  deviceId: a.deviceId,\n  groupId: a.groupId,\n  kind: a.kind,\n  label: a.label || u\n}), reportDevices = async () => {\n  const a = await navigator.mediaDevices.enumerateDevices(), u = a.filter((v) => v.kind === \"videoinput\").map((v, S) => deviceWithDefaultLabel(v, \"Camera \" + (S + 1))), c = a.filter((v) => v.kind === \"audioinput\").map((v, S) => deviceWithDefaultLabel(v, \"Microphone \" + (S + 1))), l = a.filter((v) => v.kind === \"audiooutput\").map((v, S) => deviceWithDefaultLabel(v, \"Speaker \" + (S + 1)));\n  deviceWatchers.forEach((v) => v({\n    webcams: u,\n    microphones: c,\n    speakers: l\n  }));\n}, webrtc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  ensureDevicePermissions,\n  getDevicePermissions,\n  getUserMedia,\n  updateMediaStreamTracks,\n  watchDevices\n}, Symbol.toStringTag, { value: \"Module\" })), RoomParticipant = {\n  type: \"RoomParticipant\",\n  valueType: MediaStream,\n  props: {\n    id: {},\n    type: {},\n    // 'screen' | 'camera'\n    videoEnabled: {},\n    audioEnabled: {}\n  },\n  init({\n    addSource: a,\n    removeSource: u,\n    updateSource: c,\n    getSource: l\n  }) {\n    CoreContext.on(\"RoomJoined\", ({\n      room: v\n    }) => {\n      let S = {}, g = [], E = [], _ = {};\n      const k = () => {\n        g.filter((L) => (L == null ? void 0 : L.type) === \"camera\" && (L == null ? void 0 : L.isExternal) === !0).forEach((L) => {\n          var M, $, J;\n          if (L.type === \"camera\") {\n            const V = _[L.id], q = v.getParticipant(L.participantId), G = v.getTrack(L.id);\n            if (l(L == null ? void 0 : L.id)) {\n              const B = v.getTrack((M = q == null ? void 0 : q.meta[L.id]) == null ? void 0 : M.microphone);\n              updateMediaStreamTracks(V, {\n                video: G == null ? void 0 : G.mediaStreamTrack,\n                audio: B == null ? void 0 : B.mediaStreamTrack\n              }), c(L.id, {\n                videoEnabled: !!(G && !G.isMuted),\n                audioEnabled: !!(B && !B.isMuted),\n                displayName: (($ = q == null ? void 0 : q.meta[L.id]) == null ? void 0 : $.displayName) || \"External Track\",\n                mirrored: (J = q == null ? void 0 : q.meta[L.id]) == null ? void 0 : J.isMirrored,\n                microphone: B,\n                external: L == null ? void 0 : L.isExternal\n              });\n            }\n          }\n        }), E.forEach((L) => {\n          var Y;\n          const M = _[L.id], $ = _[L.id + \"-screen\"], J = L.trackIds.find((ne) => {\n            const Z = v.getTrack(ne);\n            return (Z == null ? void 0 : Z.type) === \"camera\" && !(Z != null && Z.isExternal);\n          }), V = L.trackIds.find((ne) => {\n            const Z = v.getTrack(ne);\n            return (Z == null ? void 0 : Z.type) === \"microphone\" && !(Z != null && Z.isExternal);\n          }), q = L.trackIds.find((ne) => {\n            const Z = v.getTrack(ne);\n            return (Z == null ? void 0 : Z.type) === \"screen_share\";\n          }), G = v.getTrack(J), H = v.getTrack(V), B = v.getTrack(q);\n          updateMediaStreamTracks(M, {\n            video: G == null ? void 0 : G.mediaStreamTrack,\n            audio: H == null ? void 0 : H.mediaStreamTrack\n          }), updateMediaStreamTracks($, {\n            video: B == null ? void 0 : B.mediaStreamTrack\n          }), c(L.id, {\n            videoEnabled: !!(G && !G.isMuted),\n            audioEnabled: !!(H && !H.isMuted),\n            displayName: L.displayName,\n            mirrored: (Y = L == null ? void 0 : L.meta) == null ? void 0 : Y.isMirrored,\n            external: G == null ? void 0 : G.isExternal\n          }), c(L.id + \"-screen\", {\n            videoEnabled: !!(B && !B.isMuted),\n            displayName: L.meta.screenDisplayName || `${L.displayName}'s Screen`\n          });\n        });\n      };\n      v.useTracks((L) => {\n        const M = L.filter((J) => !g.some((V) => V.id === J.id) && !!(J != null && J.mediaStreamTrack)), $ = g.filter((J) => !L.some((V) => V.id === J.id));\n        g = L.filter((J) => !!(J != null && J.mediaStreamTrack)), M.forEach((J) => {\n          const V = new MediaStream([]);\n          _[J.id] = V;\n          const {\n            id: q,\n            participantId: G,\n            type: H,\n            mediaStreamTrack: B\n          } = v.getTrack(J.id);\n          B && a({\n            id: q,\n            isActive: !0,\n            value: V,\n            props: {\n              id: q,\n              trackId: q,\n              participantId: G,\n              isMuted: J.isMuted,\n              type: H\n            }\n          });\n        }), $.forEach((J) => {\n          var V;\n          u(J.id), (V = S[J.id]) == null || V.call(S);\n        }), k();\n      }), v.useParticipants((L) => {\n        const M = L.filter((J) => !E.some((V) => V.id === J.id)), $ = E.filter((J) => !L.some((V) => V.id === J.id));\n        E = L, M.forEach((J) => {\n          var H;\n          const {\n            id: V\n          } = J, q = new MediaStream([]), G = new MediaStream([]);\n          _[V] = q, _[V + \"-screen\"] = G, a({\n            id: V,\n            isActive: !0,\n            value: q,\n            props: {\n              id: V,\n              type: \"camera\",\n              displayName: J.displayName || J.id,\n              audioEnabled: !1,\n              videoEnabled: !1,\n              mirrored: (H = J == null ? void 0 : J.meta) == null ? void 0 : H.isMirrored\n            }\n          }), a({\n            id: V + \"-screen\",\n            isActive: !0,\n            value: G,\n            props: {\n              id: V,\n              type: \"screen\",\n              displayName: J.displayName || J.id,\n              audioEnabled: !1,\n              videoEnabled: !1\n            }\n          });\n        }), k(), $.forEach((J) => {\n          var V;\n          u(J.id), (V = S[J.id]) == null || V.call(S);\n        });\n      });\n    });\n  }\n}, Banner = {\n  type: \"Banner\",\n  valueType: Object,\n  props: {},\n  init({\n    addSource: a,\n    removeSource: u,\n    updateSource: c,\n    getSource: l,\n    modifySourceValue: v\n  }) {\n    let S = [];\n    const g = (E = []) => {\n      const _ = E.filter((M) => !S.some(($) => $.id === M.id)), k = S.filter((M) => !E.some(($) => $.id === M.id)), L = E.filter((M) => {\n        const $ = S.find((J) => J.id === M.id);\n        return !deepEqual(M, $);\n      });\n      _.forEach((M) => a({\n        id: M.id,\n        value: {\n          headerText: M.props.headerText,\n          bodyText: M.props.bodyText\n        },\n        // TODO: It feels odd to have \"props\" match \"value\" exactly.\n        //  They probably shouldn't be necessary here.\n        props: M.props\n      })), k.forEach((M) => u(M.id)), L.forEach((M) => {\n        c(M.id, M.props), v(M.id, ($) => {\n          $.headerText = M.props.headerText, $.bodyText = M.props.bodyText;\n        });\n      }), S = E;\n    };\n    CoreContext.on(\"ActiveProjectChanged\", ({\n      projectId: E\n    }) => {\n      var k;\n      if (S = [], !E)\n        return;\n      const _ = getProject(E);\n      g(((k = _.props) == null ? void 0 : k.banners) ?? []);\n    }), CoreContext.on(\"ProjectChanged\", ({\n      project: E\n    }) => {\n      var _;\n      g(((_ = E.props) == null ? void 0 : _.banners) ?? []);\n    });\n  }\n}, Overlays = {\n  type: \"Overlay\",\n  valueType: Object,\n  props: {},\n  init({\n    addSource: a,\n    removeSource: u,\n    updateSource: c,\n    getSource: l,\n    modifySourceValue: v\n  }) {\n    let S = [];\n    const g = (E = []) => {\n      const _ = E.filter((M) => !S.some(($) => $.id === M.id)), k = S.filter((M) => !E.some(($) => $.id === M.id)), L = E.filter((M) => {\n        const $ = S.find((J) => J.id === M.id);\n        return !deepEqual(M, $);\n      });\n      _.forEach((M) => a({\n        id: M.id,\n        value: {\n          ...M.props\n        },\n        // TODO: It feels odd to have \"props\" match \"value\" exactly.\n        //  They probably shouldn't be necessary here.\n        props: M.props\n      })), k.forEach((M) => u(M.id)), L.forEach((M) => {\n        c(M.id, M.props), v(M.id, ($) => {\n          Object.keys(M.props).forEach((J) => {\n            $[J] = M.props[J];\n          });\n        });\n      }), S = JSON.parse(JSON.stringify(E));\n    };\n    CoreContext.on(\"ActiveProjectChanged\", ({\n      projectId: E\n    }) => {\n      if (S = [], !E)\n        return;\n      const _ = getProject(E);\n      g(_.props.overlays);\n    }), CoreContext.on(\"ProjectChanged\", ({\n      project: E\n    }) => {\n      g(E.props.overlays);\n    });\n  }\n}, Background = {\n  type: \"Background\",\n  valueType: Object,\n  props: {},\n  init({\n    addSource: a,\n    removeSource: u,\n    updateSource: c,\n    getSource: l,\n    modifySourceValue: v\n  }) {\n    let S;\n    const g = (E) => {\n      if (!E)\n        return;\n      const _ = (S == null ? void 0 : S.id) !== (E == null ? void 0 : E.id) ? E : null, k = deepEqual(E, S) ? null : E;\n      _ && (a({\n        id: _ == null ? void 0 : _.id,\n        value: {\n          ..._ == null ? void 0 : _.props\n        },\n        // TODO: It feels odd to have \"props\" match \"value\" exactly.\n        //  They probably shouldn't be necessary here.\n        props: _ == null ? void 0 : _.props\n      }), u(S == null ? void 0 : S.id)), k && (c(k == null ? void 0 : k.id, k == null ? void 0 : k.props), v(k == null ? void 0 : k.id, (L) => {\n        Object.keys(k == null ? void 0 : k.props).forEach((M) => {\n          L[M] = k == null ? void 0 : k.props[M];\n        });\n      })), S = JSON.parse(JSON.stringify(E));\n    };\n    CoreContext.on(\"ActiveProjectChanged\", ({\n      projectId: E\n    }) => {\n      if (S = null, !E)\n        return;\n      const _ = getProject(E);\n      g(_.props.background);\n    }), CoreContext.on(\"ProjectChanged\", ({\n      project: E\n    }) => {\n      g(E.props.background);\n    });\n  }\n}, Logo = {\n  type: \"Logo\",\n  valueType: Object,\n  props: {},\n  init({\n    addSource: a,\n    removeSource: u,\n    updateSource: c,\n    getSource: l,\n    modifySourceValue: v\n  }) {\n    let S;\n    const g = (E) => {\n      if (!E) {\n        S && (u(S == null ? void 0 : S.id), S = null);\n        return;\n      }\n      const _ = (S == null ? void 0 : S.id) !== (E == null ? void 0 : E.id) ? E : null, k = deepEqual(E, S) ? null : E;\n      _ && (a({\n        id: _ == null ? void 0 : _.id,\n        value: {\n          ..._ == null ? void 0 : _.props\n        },\n        // TODO: It feels odd to have \"props\" match \"value\" exactly.\n        //  They probably shouldn't be necessary here.\n        props: _ == null ? void 0 : _.props\n      }), u(S == null ? void 0 : S.id)), k && (c(k == null ? void 0 : k.id, k == null ? void 0 : k.props), v(k == null ? void 0 : k.id, (L) => {\n        Object.keys(k == null ? void 0 : k.props).forEach((M) => {\n          L[M] = k == null ? void 0 : k.props[M];\n        });\n      })), S = JSON.parse(JSON.stringify(E));\n    };\n    CoreContext.on(\"ActiveProjectChanged\", ({\n      projectId: E\n    }) => {\n      if (S = null, !E)\n        return;\n      const _ = getProject(E);\n      g(_.props.logo);\n    }), CoreContext.on(\"ProjectChanged\", ({\n      project: E\n    }) => {\n      g(E.props.logo);\n    });\n  }\n}, {\n  state\n} = CoreContext, updateUserProps = async (a) => {\n  const u = getUser();\n  if (!u)\n    return;\n  const c = {\n    ...u.props,\n    ...a.props\n  }, l = await CoreContext.clients.LiveApi().collection.updateCollection({\n    collectionId: u.id,\n    updateMask: [\"metadata\"],\n    metadata: {\n      ...u.metadata,\n      props: c\n    }\n  });\n  await triggerInternal$1(\"UserChanged\", l.collection);\n}, createSource = async (a) => {\n  const u = getUser().id, {\n    source: c\n  } = await CoreContext.clients.LiveApi().source.createSource({\n    metadata: {},\n    collectionId: u,\n    address: {\n      rtmpPush: {\n        enabled: !0\n      }\n    },\n    preview: {\n      webrtc: {\n        enabled: !0,\n        displayName: a.displayName || \"RTMP Source\"\n      }\n    }\n  });\n  await triggerInternal$1(\"SourceAdded\", c);\n  const l = await CoreContext.clients.LiveApi().source.addSourceToProject({\n    collectionId: u,\n    projectId: a.projectId,\n    sourceId: c.sourceId\n  });\n  return await triggerInternal$1(\"ProjectSourceAdded\", {\n    projectId: l.project.projectId,\n    source: c\n  }), c;\n}, updateSource = async (a) => {\n  const u = getUser().id;\n  let c = [], l = {};\n  a.metadata && (c.push(\"metadata\"), l.metadata = a.metadata), a.displayName && (c.push(\"preview.webrtc.displayName\"), l = {\n    ...l,\n    preview: {\n      webrtc: {\n        displayName: a.displayName\n      }\n    }\n  });\n  const {\n    source: v\n  } = await CoreContext.clients.LiveApi().source.updateSource({\n    collectionId: u,\n    updateMask: c,\n    sourceId: a.sourceId,\n    ...l\n  });\n  return await triggerInternal$1(\"SourceChanged\", v), v;\n}, deleteSource = async (a) => {\n  const u = getUser().id;\n  await CoreContext.clients.LiveApi().source.removeSourceFromProject({\n    collectionId: u,\n    projectId: a.projectId,\n    sourceId: a.sourceId\n  }), await triggerInternal$1(\"ProjectSourceRemoved\", {\n    projectId: a.projectId,\n    sourceId: a.sourceId\n  });\n  const c = await CoreContext.clients.LiveApi().source.deleteSource({\n    sourceId: a.sourceId,\n    collectionId: u\n  });\n  return await triggerInternal$1(\"SourceRemoved\", a.sourceId), c;\n}, createProject$1 = async (a = {}) => {\n  const {\n    props: u = {},\n    size: c,\n    settings: l = {}\n  } = a, v = await CoreContext.Request.createProject({\n    settings: l,\n    props: u,\n    size: c\n  });\n  await triggerInternal$1(\"ProjectAdded\", v.project);\n  const S = await hydrateProject(v.project, \"ROLE_HOST\");\n  return toBaseProject(S);\n}, recreateLayout = async (a) => {\n  const {\n    projectId: u,\n    props: c = {}\n  } = a, l = getUser().id, v = await CoreContext.clients.LiveApi().project.getProject({\n    collectionId: l,\n    projectId: u,\n    status: !0\n  });\n  if ([ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING, ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STARTING].includes(v.status.phase))\n    return;\n  const S = v.project.metadata || {}, {\n    layoutId: g\n  } = S, {\n    video: E\n  } = v.project.rendering, {\n    type: _\n  } = v.project.metadata.props || {}, k = await CoreContext.Request.createLayout({\n    collectionId: l,\n    projectId: u,\n    type: _ || \"sceneless\",\n    settings: {},\n    size: {\n      x: E.width,\n      y: E.height\n    }\n  }), L = await CoreContext.clients.LiveApi().project.updateProject({\n    collectionId: l,\n    projectId: u,\n    updateMask: [\"metadata\"],\n    metadata: {\n      ...S,\n      layoutId: k.id\n    }\n  });\n  CoreContext.log.debug(\"New layout assigned to project:\", {\n    layout: k\n  }), await triggerInternal$1(\"ProjectChanged\", {\n    project: L.project\n  }), await CoreContext.clients.LayoutApi().layout.deleteLayout({\n    layoutId: g\n  }), CoreContext.log.debug(\"Previous layout deleted:\", {\n    layoutId: g\n  });\n  const M = await hydrateProject(L.project, \"ROLE_HOST\");\n  return await M.compositor.update(M.compositor.getRoot().id, c), {\n    project: toBaseProject(M),\n    internalProject: M\n  };\n}, deleteProject$1 = async (a) => {\n  const {\n    projectId: u\n  } = a;\n  await CoreContext.Request.deleteProject({\n    projectId: u\n  }), await triggerInternal$1(\"ProjectRemoved\", {\n    projectId: u\n  });\n}, updateProjectProps = async (a) => {\n  const {\n    projectId: u\n  } = a, c = getUser().id, l = getProject(u), v = {\n    ...l.props,\n    ...a.props\n  }, S = await CoreContext.clients.LiveApi().project.updateProject({\n    collectionId: c,\n    projectId: u,\n    updateMask: [\"metadata\"],\n    metadata: {\n      ...l.videoApi.project.metadata,\n      props: v\n    }\n  });\n  await triggerInternal$1(\"ProjectChanged\", {\n    project: S.project\n  });\n}, updateProjectPropsWithoutTrigger = async (a) => {\n  const {\n    projectId: u\n  } = a, c = getUser().id, l = getProject(u), v = {\n    ...l.props,\n    ...a.props\n  };\n  await CoreContext.clients.LiveApi().project.updateProject({\n    collectionId: c,\n    projectId: u,\n    updateMask: [\"metadata\"],\n    metadata: {\n      ...l.videoApi.project.metadata,\n      props: v\n    }\n  });\n}, setActiveProject = async (a) => {\n  const u = state.projects.find((l) => l.id === a.projectId);\n  if (!u) {\n    state.activeProjectId = null, triggerInternal$1(\"ActiveProjectChanged\", {\n      projectId: null\n    });\n    return;\n  }\n  const c = state.projects.find((l) => l.id === state.activeProjectId);\n  if (u !== c)\n    return c && (Array.from(webrtcManager.rooms.keys()).map(webrtcManager.removeRoom), await CoreContext.clients.LayoutApi().unsubscribeFromLayout(c.layoutApi.layoutId), await CoreContext.clients.LiveApi().unsubscribeFromProject(c.videoApi.project.collectionId, c.videoApi.project.projectId)), await CoreContext.clients.LayoutApi().subscribeToLayout(u.layoutApi.layoutId), await CoreContext.clients.LiveApi().subscribeToProject(u.videoApi.project.collectionId, u.videoApi.project.projectId), CoreContext.clients.LiveApi().project.getProject({\n      collectionId: u.videoApi.project.collectionId,\n      projectId: u.videoApi.project.projectId,\n      status: !0\n    }).then((l) => {\n      var v, S;\n      triggerInternal$1(\"ProjectChanged\", {\n        project: l.project,\n        phase: (v = l.status) == null ? void 0 : v.phase,\n        broadcastId: (S = l.status) == null ? void 0 : S.broadcastId\n      });\n    }), triggerInternal$1(\"ActiveProjectChanged\", {\n      projectId: u.id\n    }), toBaseProject(u);\n}, joinRoom = async (a) => {\n  const {\n    projectId: u,\n    displayName: c = \"Guest\"\n  } = a, l = state.projects.find((M) => M.id === u);\n  let v = l.sfuToken;\n  if (!v) {\n    let {\n      webrtcAccess: M\n    } = await CoreContext.clients.LiveApi().authentication.createWebRtcAccessToken({\n      collectionId: l.videoApi.project.collectionId,\n      projectId: l.videoApi.project.projectId,\n      displayName: c\n    });\n    v = M.accessToken;\n  }\n  const g = jwtDecode(v).video.room, E = new URL(CoreContext.clients.getLiveKitServer()), _ = E.host + E.pathname, k = webrtcManager.ensureRoom(_, g, v);\n  k.bindApiClient(CoreContext.clients), await k.connect(), l.sfuToken = v, l.roomId = g;\n  const L = getRoom(g);\n  return trigger$1(\"RoomJoined\", {\n    projectId: l.id,\n    room: L\n  }), L;\n}, createNode = async (a) => {\n  let {\n    props: u = {},\n    parentId: c,\n    index: l,\n    projectId: v = state.activeProjectId\n  } = a;\n  const S = getProject(v), g = await S.compositor.insert(u, c, l);\n  return triggerInternal$1(\"NodeAdded\", {\n    projectId: v,\n    nodeId: g\n  }), triggerInternal$1(\"NodeChanged\", {\n    projectId: v,\n    nodeId: c\n  }), S.compositor.get(g);\n}, deleteNode = async (a) => {\n  var S;\n  let {\n    nodeId: u,\n    projectId: c = state.activeProjectId\n  } = a;\n  const l = getProject(c), v = (S = l.compositor.getParent(u)) == null ? void 0 : S.id;\n  l.compositor.remove(u), triggerInternal$1(\"NodeRemoved\", {\n    projectId: c,\n    nodeId: u\n  }), triggerInternal$1(\"NodeChanged\", {\n    projectId: c,\n    nodeId: v\n  });\n}, updateNode = async (a) => {\n  let {\n    nodeId: u,\n    props: c = {},\n    projectId: l = state.activeProjectId\n  } = a;\n  const v = getProject(l);\n  return delete c.type, delete c.sourceType, v.compositor.update(u, c), triggerInternal$1(\"NodeChanged\", {\n    projectId: l,\n    nodeId: u\n  }), v.compositor.get(u);\n}, setNodeLayout = async (a) => {\n  let {\n    nodeId: u,\n    layout: c,\n    projectId: l = state.activeProjectId,\n    layoutProps: v = {}\n  } = a;\n  getProject(l).compositor.update(u, {\n    layout: c,\n    layoutProps: v\n  }), triggerInternal$1(\"NodeChanged\", {\n    projectId: l,\n    nodeId: u\n  });\n}, moveNode = async (a) => {\n  const {\n    nodeId: u,\n    parentId: c,\n    projectId: l = state.activeProjectId,\n    index: v\n  } = a;\n  getProject(l).compositor.move(u, c, v), triggerInternal$1(\"NodeChanged\", {\n    projectId: l,\n    nodeId: u\n  });\n}, swapNodes = async (a) => {\n  var E, _;\n  const {\n    nodeAId: u,\n    nodeBId: c,\n    projectId: l = state.activeProjectId\n  } = a, v = getProject(l), S = (E = v.compositor.getParent(u)) == null ? void 0 : E.id, g = (_ = v.compositor.getParent(c)) == null ? void 0 : _.id;\n  v.compositor.swap(u, c), triggerInternal$1(\"NodeChanged\", {\n    projectId: l,\n    nodeId: S\n  }), triggerInternal$1(\"NodeChanged\", {\n    projectId: l,\n    nodeId: g\n  });\n}, reorderNodes = async (a) => {\n  const {\n    parentId: u,\n    childIds: c,\n    projectId: l = state.activeProjectId\n  } = a;\n  getProject(l).compositor.reorder(u, c), triggerInternal$1(\"NodeChanged\", {\n    projectId: l,\n    nodeId: u\n  });\n}, startBroadcast = async (a) => {\n  const {\n    projectId: u = state.activeProjectId\n  } = a, c = getProject(u);\n  await CoreContext.clients.LiveApi().project.startProjectBroadcast({\n    collectionId: c.videoApi.project.collectionId,\n    projectId: c.videoApi.project.projectId\n  });\n}, stopBroadcast = async (a) => {\n  const {\n    projectId: u = state.activeProjectId\n  } = a, c = getProject(u);\n  await CoreContext.clients.LiveApi().project.stopProjectBroadcast({\n    collectionId: c.videoApi.project.collectionId,\n    projectId: c.videoApi.project.projectId\n  });\n}, addDestination = async (a) => {\n  var k;\n  const {\n    rtmpUrl: u,\n    rtmpKey: c,\n    enabled: l,\n    projectId: v = state.activeProjectId,\n    props: S = {}\n  } = a, g = getProject(v), E = {\n    rtmpPush: {\n      key: c,\n      url: u\n    }\n  }, _ = await ((k = CoreContext.clients.LiveApi().destination) == null ? void 0 : k.createDestination({\n    collectionId: g.videoApi.project.collectionId,\n    projectId: g.videoApi.project.projectId,\n    address: E,\n    enabled: l,\n    metadata: {\n      props: S\n    }\n  }));\n  return await triggerInternal$1(\"DestinationAdded\", _.destination), toBaseDestination(_.destination);\n}, removeDestination = async (a) => {\n  var v;\n  const {\n    destinationId: u,\n    projectId: c = state.activeProjectId\n  } = a, l = getProject(c);\n  await ((v = CoreContext.clients.LiveApi().destination) == null ? void 0 : v.deleteDestination({\n    collectionId: l.videoApi.project.collectionId,\n    projectId: l.videoApi.project.projectId,\n    destinationId: u\n  })), await triggerInternal$1(\"DestinationRemoved\", {\n    projectId: c,\n    destinationId: u\n  });\n}, updateDestination = async (a) => {\n  var _;\n  const {\n    rtmpUrl: u,\n    rtmpKey: c,\n    destinationId: l,\n    projectId: v = state.activeProjectId\n  } = a, S = getProject(v), g = {\n    key: c,\n    url: u\n  }, E = await ((_ = CoreContext.clients.LiveApi().destination) == null ? void 0 : _.updateDestination({\n    collectionId: S.videoApi.project.collectionId,\n    projectId: S.videoApi.project.projectId,\n    destinationId: l,\n    updateMask: [\"address.rtmpPush\"],\n    address: {\n      rtmpPush: g\n    }\n  }));\n  await triggerInternal$1(\"DestinationChanged\", E.destination);\n}, updateDestinationProps = async (a) => {\n  var E, _;\n  const {\n    projectId: u = state.activeProjectId,\n    destinationId: c,\n    props: l = {}\n  } = a, v = getProject(u), S = v.videoApi.project.destinations.find((k) => k.destinationId === c);\n  if (!S)\n    return;\n  const g = await ((_ = CoreContext.clients.LiveApi().destination) == null ? void 0 : _.updateDestination({\n    collectionId: v.videoApi.project.collectionId,\n    projectId: v.videoApi.project.projectId,\n    destinationId: c,\n    updateMask: [\"metadata\"],\n    metadata: {\n      ...S.metadata || {},\n      props: {\n        ...((E = S.metadata) == null ? void 0 : E.props) || {},\n        ...l\n      }\n    }\n  }));\n  await triggerInternal$1(\"DestinationChanged\", g.destination);\n}, setDestinationEnabled = async (a) => {\n  var E;\n  const {\n    enabled: u,\n    destinationId: c,\n    projectId: l = state.activeProjectId\n  } = a, v = getProject(l);\n  if (v.videoApi.project.destinations.find((_) => c === _.destinationId).enabled === u)\n    return;\n  const g = await ((E = CoreContext.clients.LiveApi().destination) == null ? void 0 : E.updateDestination({\n    collectionId: v.videoApi.project.collectionId,\n    projectId: v.videoApi.project.projectId,\n    destinationId: c,\n    updateMask: [\"enabled\"],\n    enabled: u\n  }));\n  await triggerInternal$1(\"DestinationChanged\", g.destination);\n}, setDestination = async (a) => {\n  var E, _;\n  const {\n    rtmpUrl: u,\n    rtmpKey: c,\n    projectId: l = state.activeProjectId\n  } = a, v = getProject(l), S = {\n    key: c,\n    url: u\n  }, g = !0;\n  if (v.videoApi.project.destinations.length > 0) {\n    const k = await ((E = CoreContext.clients.LiveApi().destination) == null ? void 0 : E.updateDestination({\n      collectionId: v.videoApi.project.collectionId,\n      projectId: v.videoApi.project.projectId,\n      destinationId: v.videoApi.project.destinations[0].destinationId,\n      updateMask: [\"address.rtmpPush\"],\n      address: {\n        rtmpPush: S\n      }\n    }));\n    await triggerInternal$1(\"DestinationChanged\", k.destination);\n  } else {\n    const k = await ((_ = CoreContext.clients.LiveApi().destination) == null ? void 0 : _.createDestination({\n      collectionId: v.videoApi.project.collectionId,\n      projectId: v.videoApi.project.projectId,\n      address: {\n        rtmpPush: S\n      },\n      enabled: g\n    }));\n    await triggerInternal$1(\"DestinationAdded\", k.destination);\n  }\n}, commands$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  addDestination,\n  createNode,\n  createProject: createProject$1,\n  createSource,\n  deleteNode,\n  deleteProject: deleteProject$1,\n  deleteSource,\n  joinRoom,\n  moveNode,\n  recreateLayout,\n  removeDestination,\n  reorderNodes,\n  setActiveProject,\n  setDestination,\n  setDestinationEnabled,\n  setNodeLayout,\n  startBroadcast,\n  stopBroadcast,\n  swapNodes,\n  updateDestination,\n  updateDestinationProps,\n  updateNode,\n  updateProjectProps,\n  updateProjectPropsWithoutTrigger,\n  updateSource,\n  updateUserProps\n}, Symbol.toStringTag, { value: \"Module\" })), useActiveProjectRoom$1 = () => {\n  const [a, u] = useState(null);\n  return useEffect(() => useActiveProjectRoom(u), []), a;\n}, useDevices = () => {\n  const [a, u] = useState({\n    webcams: [],\n    microphones: [],\n    speakers: []\n  });\n  return useEffect(() => watchDevices(u), []), a;\n}, StudioContext = React.createContext({\n  studio: null,\n  project: null,\n  room: null,\n  webcamId: null,\n  microphoneId: null,\n  setStudio: () => {\n  },\n  setProject: () => {\n  },\n  setRoom: () => {\n  },\n  setWebcamId: () => {\n  },\n  setMicrophoneId: () => {\n  },\n  projectCommands: {}\n}), useStudio = () => useContext(StudioContext);\nlet stored = {\n  webcamId: null,\n  microphoneId: null\n};\ntry {\n  stored.webcamId = localStorage == null ? void 0 : localStorage.getItem(\"__LS_webcam\"), stored.microphoneId = localStorage == null ? void 0 : localStorage.getItem(\"__LS_microphone\");\n} catch {\n}\nconst StudioProvider = ({\n  children: a\n}) => {\n  const [u, c] = useState(), [l, v] = useState(), [S, g] = useState(), [E, _] = useState(stored.webcamId), [k, L] = useState(stored.microphoneId), M = useMemo(() => l ? commands(l) : null, [l]);\n  return useEffect(() => {\n  }, [l]), useEffect(() => {\n    u && (E && u.setCamera({\n      deviceId: E\n    }).catch(($) => {\n      console.warn($);\n    }), k && u.setMicrophone({\n      deviceId: k\n    }).catch(($) => {\n      console.warn($);\n    }));\n  }, [u, E, k]), /* @__PURE__ */ React.createElement(StudioContext.Provider, {\n    value: {\n      studio: S,\n      project: l,\n      room: u,\n      webcamId: E,\n      microphoneId: k,\n      setStudio: g,\n      setProject: v,\n      setRoom: c,\n      setWebcamId: ($) => {\n        try {\n          localStorage == null || localStorage.setItem(\"__LS_webcam\", $);\n        } catch {\n        }\n        _($);\n      },\n      setMicrophoneId: ($) => {\n        try {\n          localStorage == null || localStorage.setItem(\"__LS_microphone\", $);\n        } catch {\n        }\n        L($);\n      },\n      projectCommands: M\n    }\n  }, a);\n}, react = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  StudioContext,\n  StudioProvider,\n  useActiveProjectRoom: useActiveProjectRoom$1,\n  useDevices,\n  useStudio\n}, Symbol.toStringTag, { value: \"Module\" })), ForegroundLayers = [{\n  name: \"ImageIframeOverlayContainer\",\n  id: \"fg-image-iframe\",\n  layout: \"Free\"\n}, {\n  name: \"BannerContainer\",\n  id: \"fg-banners\",\n  layout: \"Column\",\n  layoutProps: {\n    cover: !0\n  }\n}, {\n  name: \"VideoOverlayContainer\",\n  id: \"fg-video\",\n  layout: \"Free\"\n}, {\n  name: \"LogoContainer\",\n  layout: \"Free\",\n  id: \"logo\"\n}], defaultStyles = {\n  custom: {\n    display: \"block\"\n  },\n  video: {\n    height: \"100%\",\n    width: \"100%\"\n  },\n  image: {\n    height: \"100%\",\n    width: \"100%\"\n  },\n  logo: {\n    objectFit: \"contain\",\n    position: \"unset\"\n  }\n}, validateEachChildren = (a, u) => {\n  let c = !0;\n  return a.forEach((l) => {\n    var v, S;\n    (v = l.props) != null && v.sourceType && !u.includes((S = l.props) == null ? void 0 : S.sourceType) ? c = !1 : l.children.length > 0 && (c = c && validateEachChildren(l.children, u));\n  }), c;\n}, addingCache = {\n  camera: /* @__PURE__ */ new Set(),\n  screen: /* @__PURE__ */ new Set(),\n  rtmp: /* @__PURE__ */ new Set()\n}, commands = (a) => {\n  var H, B, Y, ne;\n  const u = a.id, c = a.scene.getRoot(), {\n    Command: l\n  } = CoreContext, v = c.children.find((Z) => Z.props.id === \"bg\"), S = c.children.find((Z) => Z.props.id === \"content\"), g = c.children.find((Z) => Z.props.id === \"foreground\");\n  let E = (H = g == null ? void 0 : g.children) == null ? void 0 : H.find((Z) => Z.props.id === \"fg-image-iframe\"), _ = (B = g == null ? void 0 : g.children) == null ? void 0 : B.find((Z) => Z.props.id === \"logo\"), k = (Y = g == null ? void 0 : g.children) == null ? void 0 : Y.find((Z) => Z.props.id === \"fg-video\");\n  const L = getProject(a.id);\n  let M = (ne = g == null ? void 0 : g.children) == null ? void 0 : ne.find((Z) => Z.props.id === \"fg-banners\");\n  const $ = async () => {\n    var Z, re;\n    ((Z = v == null ? void 0 : v.props) == null ? void 0 : Z.layout) !== \"Layered\" && await L.compositor.update(v.id, {\n      name: \"Background\",\n      id: \"bg\",\n      layout: \"Layered\"\n    }), ((re = g == null ? void 0 : g.props) == null ? void 0 : re.layout) !== \"Layered\" && await L.compositor.update(g.id, {\n      id: \"foreground\",\n      name: \"Overlays\",\n      layout: \"Layered\"\n    });\n  }, J = async () => {\n    validateEachChildren(v.children, [\"Background\"]) || v.children.forEach(async (Z) => {\n      await CoreContext.Command.deleteNode({\n        nodeId: Z.id\n      });\n    });\n  }, V = async () => {\n    const Z = async () => {\n      var A;\n      if (M)\n        return M.id;\n      {\n        const N = await L.compositor.insert({\n          name: \"BannerContainer\",\n          id: \"fg-banners\",\n          layout: \"Column\",\n          layoutProps: {\n            cover: !0\n          }\n        }, g.id);\n        return M = (A = g == null ? void 0 : g.children) == null ? void 0 : A.find((D) => D.id === N), N;\n      }\n    }, re = async () => {\n      var A;\n      if (E)\n        return E.id;\n      {\n        const N = await L.compositor.insert({\n          name: \"ImageIframeOverlay\",\n          id: \"fg-image-iframe\",\n          layout: \"Free\"\n        }, g.id);\n        return E = (A = g == null ? void 0 : g.children) == null ? void 0 : A.find((D) => D.id === N), N;\n      }\n    }, oe = async () => {\n      var A;\n      if (k)\n        return k.id;\n      {\n        const N = await L.compositor.insert({\n          name: \"VideoOverlay\",\n          id: \"fg-video\",\n          layout: \"Free\"\n        }, g.id);\n        return k = (A = g == null ? void 0 : g.children) == null ? void 0 : A.find((D) => D.id === N), N;\n      }\n    }, de = async () => {\n      var A;\n      if (_)\n        return _.id;\n      {\n        const N = await L.compositor.insert({\n          name: \"Logo\",\n          layout: \"Free\",\n          sourceType: \"Logo\",\n          id: \"logo\",\n          style: {\n            width: \"100%\",\n            height: \"100%\",\n            objectFit: \"contain\",\n            position: \"unset\"\n          }\n        }, g.id);\n        return _ = (A = g == null ? void 0 : g.children) == null ? void 0 : A.find((D) => D.id === N), N;\n      }\n    };\n    try {\n      const A = await Promise.all([Z(), re(), oe(), de()]);\n      await L.compositor.reorder(g.id, A);\n    } catch {\n    }\n  }, q = {\n    getBackground() {\n      return v;\n    },\n    getContent() {\n      return S;\n    },\n    getForeground() {\n      return g;\n    },\n    getLayout() {\n      return S.props.layout;\n    },\n    getBanners() {\n      var Z;\n      return ((Z = getProject(a.id).props) == null ? void 0 : Z.banners) || [];\n    },\n    getOverlays() {\n      return getProject(a.id).props.overlays || [];\n    },\n    getParticipants() {\n      return S.children.filter((Z) => Z.props.sourceType === \"RoomParticipant\");\n    },\n    getLogo() {\n      var Z, re;\n      return (re = (Z = _ == null ? void 0 : _.children[0]) == null ? void 0 : Z.props) == null ? void 0 : re.id;\n    },\n    async removeLogo() {\n      const [Z, ...re] = (_ == null ? void 0 : _.children) || [];\n      re.forEach((oe) => {\n        CoreContext.Command.deleteNode({\n          nodeId: oe.id\n        });\n      }), Z && await CoreContext.Command.deleteNode({\n        nodeId: Z.id\n      });\n    },\n    getImageOverlay() {\n      var re, oe;\n      const Z = (re = E == null ? void 0 : E.children) == null ? void 0 : re.find((de) => {\n        var A, N;\n        return ((N = (A = de == null ? void 0 : de.props) == null ? void 0 : A.sourceProps) == null ? void 0 : N.type) === \"image\";\n      });\n      return (oe = Z == null ? void 0 : Z.props) == null ? void 0 : oe.id;\n    },\n    getVideoOverlay() {\n      var re, oe;\n      const Z = (re = k == null ? void 0 : k.children) == null ? void 0 : re.find((de) => {\n        var A, N;\n        return ((N = (A = de == null ? void 0 : de.props) == null ? void 0 : A.sourceProps) == null ? void 0 : N.type) === \"video\";\n      });\n      return (oe = Z == null ? void 0 : Z.props) == null ? void 0 : oe.id;\n    },\n    autoPlayBackgroundVideo(Z = {\n      muted: !0,\n      autoplay: !0\n    }) {\n      const re = v.children.find((oe) => oe.props.id === \"bg-video\");\n      re && CoreContext.Command.updateNode({\n        nodeId: re.id,\n        props: {\n          ...re.props,\n          attributes: {\n            ...re.props.attributes,\n            ...Z\n          }\n        }\n      });\n    },\n    autoPlayVideoOverlay(Z, re = {\n      muted: !0,\n      autoplay: !0\n    }) {\n      var de;\n      const oe = (de = k == null ? void 0 : k.children) == null ? void 0 : de.find((A) => {\n        var N, D;\n        return ((D = (N = A.props) == null ? void 0 : N.sourceProps) == null ? void 0 : D.id) === Z;\n      });\n      oe && oe.props.sourceProps.type === \"video\" && CoreContext.Command.updateNode({\n        nodeId: oe.id,\n        props: {\n          ...oe.props,\n          attributes: {\n            ...oe.props.attributes,\n            ...re\n          }\n        }\n      });\n    },\n    getBackgroundMedia() {\n      var re, oe;\n      return (oe = (re = v.children.filter((de) => de)[0]) == null ? void 0 : re.props) == null ? void 0 : oe.id;\n    },\n    getBackgroundImage() {\n      var re;\n      const Z = v.children.find((oe) => {\n        var de, A;\n        return ((A = (de = oe.props) == null ? void 0 : de.sourceProps) == null ? void 0 : A.type) === \"image\";\n      });\n      return (re = Z == null ? void 0 : Z.props) == null ? void 0 : re.id;\n    },\n    getBackgroundVideo() {\n      var re;\n      const Z = v.children.find((oe) => {\n        var de, A;\n        return ((A = (de = oe.props) == null ? void 0 : de.sourceProps) == null ? void 0 : A.type) === \"video\";\n      });\n      return (re = Z == null ? void 0 : Z.props) == null ? void 0 : re.id;\n    },\n    async addLogo(Z, re) {\n      const [oe, ...de] = (_ == null ? void 0 : _.children) || [];\n      de.forEach((A) => {\n        CoreContext.Command.deleteNode({\n          nodeId: A.id\n        });\n      }), oe ? await CoreContext.Command.updateNode({\n        nodeId: oe.id,\n        props: {\n          sourceType: \"Logo\",\n          id: Z,\n          sourceProps: {\n            ...re,\n            meta: {\n              style: {\n                ...defaultStyles.logo\n              },\n              ...re.meta\n            }\n          }\n        }\n      }) : await CoreContext.Command.createNode({\n        parentId: _ == null ? void 0 : _.id,\n        props: {\n          sourceType: \"Logo\",\n          id: Z,\n          sourceProps: {\n            ...re,\n            meta: {\n              style: {\n                ...defaultStyles.logo\n              },\n              ...re.meta\n            }\n          }\n        }\n      });\n    },\n    addBanner(Z = {}) {\n      var A;\n      const re = Z.meta || {}, oe = {\n        id: generateId(),\n        props: {\n          ...Z,\n          meta: re\n        }\n      }, de = ((A = getProject(u).props) == null ? void 0 : A.banners) || [];\n      return l.updateProjectProps({\n        projectId: u,\n        props: {\n          banners: [...de, oe]\n        }\n      });\n    },\n    editBanner(Z, re = {}) {\n      const de = q.getBanners().map((A) => A.id !== Z ? A : {\n        ...A,\n        props: re\n      });\n      return l.updateProjectProps({\n        projectId: u,\n        props: {\n          banners: de\n        }\n      });\n    },\n    removeBanner(Z) {\n      var oe;\n      const re = q.getBanners();\n      return (oe = M == null ? void 0 : M.children) == null || oe.forEach((de) => {\n        de.props.bannerId === Z && CoreContext.Command.deleteNode({\n          nodeId: de.id\n        });\n      }), l.updateProjectProps({\n        projectId: u,\n        props: {\n          banners: re.filter((de) => de.id !== Z)\n        }\n      });\n    },\n    async setActiveBanner(Z) {\n      var A, N;\n      const [re, ...{}] = (M == null ? void 0 : M.children) || [];\n      ((N = (A = re == null ? void 0 : re.props) == null ? void 0 : A.sourceType) == null ? void 0 : N.toLowerCase()) === \"chatoverlay\" && await CoreContext.Command.deleteNode({\n        nodeId: re.id\n      });\n      const [oe, ...de] = (M == null ? void 0 : M.children) || [];\n      if (de.forEach((D) => {\n        CoreContext.Command.deleteNode({\n          nodeId: D.id\n        });\n      }), oe)\n        CoreContext.Command.updateNode({\n          nodeId: oe.id,\n          props: {\n            sourceType: \"Banner\",\n            bannerId: Z\n          }\n        });\n      else\n        return CoreContext.Command.createNode({\n          parentId: M == null ? void 0 : M.id,\n          props: {\n            sourceType: \"Banner\",\n            bannerId: Z\n          }\n        });\n    },\n    getActiveBanner() {\n      var Z, re, oe;\n      return ((oe = (re = (Z = M.children) == null ? void 0 : Z[0]) == null ? void 0 : re.props) == null ? void 0 : oe.bannerId) ?? null;\n    },\n    async addChatOverlay(Z, re) {\n      var N, D;\n      const [oe, ...{}] = (M == null ? void 0 : M.children) || [];\n      ((D = (N = oe == null ? void 0 : oe.props) == null ? void 0 : N.sourceType) == null ? void 0 : D.toLowerCase()) === \"banner\" && await CoreContext.Command.deleteNode({\n        nodeId: oe.id\n      });\n      const [de, ...A] = (M == null ? void 0 : M.children) || [];\n      A.forEach((W) => {\n        CoreContext.Command.deleteNode({\n          nodeId: W.id\n        });\n      }), de ? await CoreContext.Command.updateNode({\n        nodeId: de.id,\n        props: {\n          sourceType: \"ChatOverlay\",\n          chatOverlayId: Z,\n          id: Z,\n          ...re\n        }\n      }) : await CoreContext.Command.createNode({\n        parentId: M == null ? void 0 : M.id,\n        props: {\n          sourceType: \"ChatOverlay\",\n          chatOverlayId: Z,\n          id: Z,\n          ...re\n        }\n      });\n    },\n    async removeChatOverlay(Z) {\n      var re;\n      (re = M == null ? void 0 : M.children) == null || re.forEach(async (oe) => {\n        oe.props.chatOverlayId === Z && await CoreContext.Command.deleteNode({\n          nodeId: oe.id\n        });\n      });\n    },\n    getChatOverlay() {\n      var Z, re, oe, de, A;\n      return (oe = (re = (Z = M.children) == null ? void 0 : Z[0]) == null ? void 0 : re.props) != null && oe.chatOverlayId && ((A = (de = M.children) == null ? void 0 : de[0]) == null ? void 0 : A.props) || null;\n    },\n    getCustomOverlay() {\n      var re, oe;\n      const Z = (re = E == null ? void 0 : E.children) == null ? void 0 : re.find((de) => {\n        var A, N;\n        return ((N = (A = de == null ? void 0 : de.props) == null ? void 0 : A.sourceProps) == null ? void 0 : N.type) === \"custom\";\n      });\n      return (oe = Z == null ? void 0 : Z.props) == null ? void 0 : oe.id;\n    },\n    async addImageOverlay(Z, re) {\n      const [oe, ...de] = (E == null ? void 0 : E.children) || [];\n      de.forEach((N) => {\n        CoreContext.Command.deleteNode({\n          nodeId: N.id\n        });\n      });\n      const A = {\n        ...defaultStyles.image,\n        ...(k == null ? void 0 : k.children.length) && {\n          opacity: 0\n        }\n      };\n      oe ? await CoreContext.Command.updateNode({\n        nodeId: oe == null ? void 0 : oe.id,\n        props: {\n          sourceType: \"Overlay\",\n          id: Z,\n          sourceProps: {\n            ...re,\n            type: \"image\",\n            meta: {\n              style: {\n                ...A\n              }\n            }\n          }\n        }\n      }) : await CoreContext.Command.createNode({\n        parentId: E == null ? void 0 : E.id,\n        props: {\n          sourceType: \"Overlay\",\n          id: Z,\n          sourceProps: {\n            ...re,\n            type: \"image\",\n            meta: {\n              style: {\n                ...A\n              }\n            }\n          }\n        }\n      });\n    },\n    async addVideoOverlay(Z, re) {\n      const [oe, ...de] = (k == null ? void 0 : k.children) || [];\n      de.forEach((A) => {\n        CoreContext.Command.deleteNode({\n          nodeId: A.id\n        });\n      }), E.children.forEach(({\n        id: A,\n        props: N\n      }) => {\n        var D, W;\n        if (((W = (D = N.sourceProps.meta) == null ? void 0 : D.style) == null ? void 0 : W.opacity) !== 0) {\n          const ee = N.sourceProps.type, ae = {\n            ...defaultStyles[ee],\n            opacity: 0\n          };\n          CoreContext.Command.updateNode({\n            nodeId: A,\n            props: {\n              ...N,\n              sourceProps: {\n                ...N.sourceProps,\n                meta: {\n                  style: {\n                    ...ae\n                  }\n                }\n              }\n            }\n          });\n        }\n      }), oe ? await CoreContext.Command.updateNode({\n        nodeId: oe == null ? void 0 : oe.id,\n        props: {\n          sourceType: \"Overlay\",\n          id: Z,\n          sourceProps: {\n            ...re,\n            type: \"video\",\n            meta: {\n              style: {\n                ...defaultStyles.video\n              },\n              ...re.meta\n            }\n          }\n        }\n      }) : await CoreContext.Command.createNode({\n        parentId: k == null ? void 0 : k.id,\n        props: {\n          sourceType: \"Overlay\",\n          id: Z,\n          sourceProps: {\n            ...re,\n            type: \"video\",\n            meta: {\n              style: {\n                ...defaultStyles.video\n              },\n              ...re.meta\n            }\n          }\n        }\n      });\n    },\n    async updateVideoOverlayProps(Z, re) {\n      var de, A;\n      const oe = ((de = k == null ? void 0 : k.children) == null ? void 0 : de.find((N) => {\n        var D;\n        return ((D = N == null ? void 0 : N.props) == null ? void 0 : D.id) === Z;\n      })) || null;\n      oe && await CoreContext.Command.updateNode({\n        nodeId: oe == null ? void 0 : oe.id,\n        props: {\n          sourceType: \"Overlay\",\n          id: Z,\n          sourceProps: {\n            ...(A = oe == null ? void 0 : oe.props) == null ? void 0 : A.sourceProps,\n            ...re,\n            meta: {\n              style: {\n                ...defaultStyles.video\n              },\n              ...re.meta\n            }\n          }\n        }\n      });\n    },\n    async addCustomOverlay(Z, re) {\n      const [oe, ...de] = (E == null ? void 0 : E.children) || [];\n      de.forEach((N) => {\n        CoreContext.Command.deleteNode({\n          nodeId: N.id\n        });\n      });\n      const A = {\n        ...defaultStyles.custom,\n        ...(k == null ? void 0 : k.children.length) && {\n          opacity: 0\n        }\n      };\n      oe ? await CoreContext.Command.updateNode({\n        nodeId: oe == null ? void 0 : oe.id,\n        props: {\n          sourceType: \"Overlay\",\n          id: Z,\n          sourceProps: {\n            ...re,\n            type: \"custom\",\n            meta: {\n              style: {\n                ...A\n              }\n            }\n          }\n        }\n      }) : await CoreContext.Command.createNode({\n        parentId: E == null ? void 0 : E.id,\n        props: {\n          sourceType: \"Overlay\",\n          id: Z,\n          sourceProps: {\n            ...re,\n            type: \"custom\",\n            meta: {\n              style: {\n                ...A\n              }\n            }\n          }\n        }\n      });\n    },\n    async removeCustomOverlay() {\n      var oe, de;\n      const [Z, ...re] = (E == null ? void 0 : E.children) || [];\n      re.forEach((A) => {\n        CoreContext.Command.deleteNode({\n          nodeId: A.id\n        });\n      }), Z && ((de = (oe = Z == null ? void 0 : Z.props) == null ? void 0 : oe.sourceProps) == null ? void 0 : de.type) === \"custom\" && await CoreContext.Command.deleteNode({\n        nodeId: Z.id\n      });\n    },\n    async removeImageOverlay() {\n      var oe, de;\n      const [Z, ...re] = (E == null ? void 0 : E.children) || [];\n      re.forEach((A) => {\n        CoreContext.Command.deleteNode({\n          nodeId: A.id\n        });\n      }), Z && ((de = (oe = Z == null ? void 0 : Z.props) == null ? void 0 : oe.sourceProps) == null ? void 0 : de.type) === \"image\" && await CoreContext.Command.deleteNode({\n        nodeId: Z.id\n      });\n    },\n    async removeVideoOverlay() {\n      const [Z, ...re] = (k == null ? void 0 : k.children) || [];\n      re.forEach((oe) => {\n        CoreContext.Command.deleteNode({\n          nodeId: oe.id\n        });\n      }), Z && await CoreContext.Command.deleteNode({\n        nodeId: Z.id\n      }), E == null || E.children.forEach(({\n        id: oe,\n        props: de\n      }) => {\n        var A, N;\n        if (((N = (A = de.sourceProps.meta) == null ? void 0 : A.style) == null ? void 0 : N.opacity) === 0) {\n          const D = de.sourceProps.type, W = {\n            ...defaultStyles[D],\n            opacity: 1\n          };\n          CoreContext.Command.updateNode({\n            nodeId: oe,\n            props: {\n              ...de,\n              sourceProps: {\n                ...de.sourceProps,\n                meta: {\n                  style: {\n                    ...W\n                  }\n                }\n              }\n            }\n          });\n        }\n      });\n    },\n    setLayout(Z, re = {}) {\n      const oe = S.props.layoutProps.showcase;\n      l.setNodeLayout({\n        nodeId: S.id,\n        layout: Z,\n        layoutProps: {\n          showcase: oe,\n          ...re\n        }\n      });\n    },\n    async setBackgroundImage(Z, re) {\n      const [oe, ...de] = (v == null ? void 0 : v.children) || [];\n      de.forEach((A) => {\n        CoreContext.Command.deleteNode({\n          nodeId: A.id\n        });\n      }), oe ? await CoreContext.Command.updateNode({\n        nodeId: oe.id,\n        props: {\n          id: Z,\n          sourceType: \"Background\",\n          sourceProps: {\n            ...re,\n            type: \"image\",\n            meta: {\n              style: {\n                ...defaultStyles.image\n              },\n              ...re == null ? void 0 : re.meta\n            }\n          }\n        }\n      }) : await CoreContext.Command.createNode({\n        parentId: v == null ? void 0 : v.id,\n        props: {\n          id: Z,\n          sourceType: \"Background\",\n          sourceProps: {\n            ...re,\n            type: \"image\",\n            meta: {\n              style: {\n                ...defaultStyles.image\n              },\n              ...re == null ? void 0 : re.meta\n            }\n          }\n        }\n      });\n    },\n    async setBackgroundVideo(Z, re) {\n      const [oe, ...de] = (v == null ? void 0 : v.children) || [];\n      de.forEach((A) => {\n        CoreContext.Command.deleteNode({\n          nodeId: A.id\n        });\n      }), oe ? await CoreContext.Command.updateNode({\n        nodeId: oe.id,\n        props: {\n          id: Z,\n          sourceType: \"Background\",\n          sourceProps: {\n            ...re,\n            type: \"video\",\n            meta: {\n              style: {\n                ...defaultStyles.video\n              },\n              ...re == null ? void 0 : re.meta\n            }\n          }\n        }\n      }) : await CoreContext.Command.createNode({\n        parentId: v == null ? void 0 : v.id,\n        props: {\n          id: Z,\n          sourceType: \"Background\",\n          sourceProps: {\n            ...re,\n            type: \"video\",\n            meta: {\n              style: {\n                ...defaultStyles.video\n              },\n              ...re == null ? void 0 : re.meta\n            }\n          }\n        }\n      });\n    },\n    async updateBackgroundVideoProps(Z, re) {\n      var de, A;\n      const oe = ((de = v == null ? void 0 : v.children) == null ? void 0 : de.find((N) => {\n        var D;\n        return ((D = N == null ? void 0 : N.props) == null ? void 0 : D.id) === Z;\n      })) || null;\n      oe && await CoreContext.Command.updateNode({\n        nodeId: oe == null ? void 0 : oe.id,\n        props: {\n          sourceType: \"Background\",\n          id: Z,\n          sourceProps: {\n            ...(A = oe == null ? void 0 : oe.props) == null ? void 0 : A.sourceProps,\n            ...re,\n            meta: {\n              style: {\n                ...defaultStyles.video\n              },\n              ...re.meta\n            }\n          }\n        }\n      });\n    },\n    async removeBackgroundImage() {\n      const [Z, ...re] = (v == null ? void 0 : v.children) || [];\n      re.forEach((oe) => {\n        CoreContext.Command.deleteNode({\n          nodeId: oe.id\n        });\n      }), Z && Z.props.sourceProps.type === \"image\" && await CoreContext.Command.deleteNode({\n        nodeId: Z.id\n      });\n    },\n    async removeBackgroundVideo() {\n      const [Z, ...re] = (v == null ? void 0 : v.children) || [];\n      re.forEach((oe) => {\n        CoreContext.Command.deleteNode({\n          nodeId: oe.id\n        });\n      }), Z && Z.props.sourceProps.type === \"video\" && await CoreContext.Command.deleteNode({\n        nodeId: Z.id\n      });\n    },\n    /* A function that takes in a sourceType and a callback function. It then creates a shallow copy of\n      the root node and finds all the nodes that have the same sourceType as the one passed in. It then\n      creates a listener for when the node changes, is added, or is removed. When any of these events\n      happen, it will call the callback function with the new state. */\n    useLayerState(Z, re) {\n      const oe = cloneDeep$1(c);\n      let de = findAll(oe, (ee) => ee.props.sourceType === Z);\n      const A = () => {\n        re((de == null ? void 0 : de.map((ee) => ee.props)) || {});\n      }, N = CoreContext.onInternal(\"NodeChanged\", (ee) => {\n        const ae = de == null ? void 0 : de.find((le) => le.id === ee.nodeId);\n        if (de != null && de.length && !ae)\n          return;\n        const ye = de, he = cloneDeep$1(c);\n        de = findAll(he, (le) => {\n          var we;\n          return ((we = le == null ? void 0 : le.props) == null ? void 0 : we.sourceType) === Z;\n        }), deepEqual(ye, de) || A();\n      }), D = CoreContext.onInternal(\"NodeAdded\", (ee) => {\n        var le;\n        if (de == null ? void 0 : de.find((we) => we.id === ee.nodeId))\n          return;\n        const ye = cloneDeep$1(c);\n        de = findAll(ye, (we) => {\n          var Be;\n          return ((Be = we == null ? void 0 : we.props) == null ? void 0 : Be.sourceType) === Z;\n        });\n        const he = de == null ? void 0 : de.find((we) => we.id === ee.nodeId);\n        ((le = he == null ? void 0 : he.props) == null ? void 0 : le.sourceType) === Z && A();\n      }), W = CoreContext.onInternal(\"NodeRemoved\", (ee) => {\n        var ye;\n        const ae = de == null ? void 0 : de.find((he) => he.id === ee.nodeId);\n        ae && (de = de == null ? void 0 : de.filter((he) => he.id !== ee.nodeId), ((ye = ae == null ? void 0 : ae.props) == null ? void 0 : ye.sourceType) === Z && A());\n      });\n      return A(), () => {\n        N(), D(), W();\n      };\n    },\n    setShowcase(Z, re = \"camera\") {\n      const oe = q.getParticipantNode(Z, re);\n      return CoreContext.Command.updateNode({\n        nodeId: S.id,\n        props: {\n          layoutProps: {\n            ...S.props.layoutProps,\n            showcase: (oe == null ? void 0 : oe.id) ?? null\n          }\n        }\n      });\n    },\n    useShowcase(Z) {\n      const re = () => {\n        const oe = S.props.layoutProps.showcase, de = S.children.find((N) => N.id === oe);\n        if (!de)\n          return Z({\n            participantId: null,\n            type: null\n          });\n        const {\n          sourceProps: A\n        } = de.props;\n        return Z({\n          participantId: A.id,\n          type: A.type\n        });\n      };\n      return re(), CoreContext.onInternal(\"NodeChanged\", (oe) => {\n        oe.nodeId === S.id && re();\n      });\n    },\n    getRTMPNode(Z) {\n      return S.children.find((re) => {\n        var oe, de;\n        return ((oe = re.props.sourceProps) == null ? void 0 : oe.id) === Z && ((de = re.props.sourceProps) == null ? void 0 : de.type) === \"rtmp\";\n      });\n    },\n    useRTMPNodes(Z) {\n      let re = [];\n      const oe = () => {\n        const N = S.children.filter((D) => {\n          var W, ee;\n          return ((ee = (W = D.props) == null ? void 0 : W.sourceProps) == null ? void 0 : ee.type) === \"rtmp\";\n        });\n        return re = N.map((D) => D.id), Z(N);\n      };\n      oe();\n      const de = CoreContext.onInternal(\"NodeAdded\", (N) => {\n        var W, ee;\n        const D = a.scene.get(N.nodeId);\n        ((ee = (W = D == null ? void 0 : D.props) == null ? void 0 : W.sourceProps) == null ? void 0 : ee.type) === \"rtmp\" && oe();\n      }), A = CoreContext.onInternal(\"NodeRemoved\", (N) => {\n        re.indexOf(N.nodeId) !== -1 && oe();\n      });\n      return () => {\n        de(), A();\n      };\n    },\n    async addRTMPSource(Z, re = {\n      isMuted: !0,\n      isHidden: !1,\n      volume: 0\n    }) {\n      const oe = \"rtmp\";\n      if (addingCache[oe].has(Z))\n        return;\n      const {\n        isMuted: de = !1,\n        isHidden: A = !1,\n        volume: N = 1\n      } = re;\n      if (S.children.find((ee) => {\n        var ae, ye;\n        return ((ae = ee.props.sourceProps) == null ? void 0 : ae.id) === Z && ((ye = ee.props.sourceProps) == null ? void 0 : ye.type) === oe;\n      }))\n        return;\n      addingCache[oe].add(Z), S.children[0];\n      let W = S.children.length;\n      await CoreContext.Command.createNode({\n        props: {\n          name: \"RTMP\",\n          sourceType: \"RTMP\",\n          sourceProps: {\n            type: oe,\n            id: Z\n          },\n          volume: N,\n          isMuted: de,\n          isHidden: A\n        },\n        parentId: S.id,\n        index: W\n      }).finally(() => {\n        addingCache[oe].delete(Z);\n      });\n    },\n    removeRTMPSource(Z) {\n      const re = \"rtmp\";\n      S.children.filter((oe) => {\n        var de, A;\n        return ((de = oe.props.sourceProps) == null ? void 0 : de.id) === Z && ((A = oe.props.sourceProps) == null ? void 0 : A.type) === re && oe.props.sourceType === \"RTMP\";\n      }).forEach((oe) => {\n        CoreContext.Command.deleteNode({\n          nodeId: oe.id\n        });\n      });\n    },\n    async addParticipantTrack(Z, re = {\n      isMuted: !0,\n      isHidden: !1,\n      volume: 0\n    }, oe = \"camera\") {\n      if (addingCache[oe].has(Z))\n        return;\n      const {\n        isMuted: de = !1,\n        isHidden: A = !1,\n        volume: N = 1\n      } = re;\n      if (S.children.find((ae) => {\n        var ye, he;\n        return ((ye = ae.props.sourceProps) == null ? void 0 : ye.id) === Z && ((he = ae.props.sourceProps) == null ? void 0 : he.type) === oe;\n      }))\n        return;\n      addingCache[oe].add(Z);\n      const W = S.children[0];\n      let ee = S.children.length;\n      oe === \"screen\" && (W == null ? void 0 : W.props.sourceProps.type) !== \"screen\" && (ee = 0), await CoreContext.Command.createNode({\n        props: {\n          name: \"Participant\",\n          sourceType: \"RoomParticipant\",\n          sourceProps: {\n            type: oe,\n            id: Z\n          },\n          volume: N,\n          isMuted: de,\n          isHidden: A\n        },\n        parentId: S.id,\n        index: ee\n      }).finally(() => {\n        addingCache[oe].delete(Z);\n      });\n    },\n    removeParticipantTrack(Z, re = \"camera\") {\n      S.children.filter((oe) => {\n        var de, A;\n        return ((de = oe.props.sourceProps) == null ? void 0 : de.id) === Z && ((A = oe.props.sourceProps) == null ? void 0 : A.type) === re && oe.props.sourceType === \"RoomParticipant\";\n      }).forEach((oe) => {\n        CoreContext.Command.deleteNode({\n          nodeId: oe.id\n        });\n      });\n    },\n    async addParticipant(Z, re = {}, oe = \"camera\") {\n      if (addingCache[oe].has(Z))\n        return;\n      const {\n        isMuted: de = !1,\n        isHidden: A = !1,\n        volume: N = 1\n      } = re;\n      if (S.children.find((ae) => {\n        var ye, he;\n        return ((ye = ae.props.sourceProps) == null ? void 0 : ye.id) === Z && ((he = ae.props.sourceProps) == null ? void 0 : he.type) === oe;\n      }))\n        return;\n      addingCache[oe].add(Z);\n      const W = S.children[0];\n      let ee = S.children.length;\n      oe === \"screen\" && (W == null ? void 0 : W.props.sourceProps.type) !== \"screen\" && (ee = 0), await CoreContext.Command.createNode({\n        props: {\n          name: \"Participant\",\n          sourceType: \"RoomParticipant\",\n          sourceProps: {\n            type: oe,\n            id: Z\n          },\n          volume: N,\n          isMuted: de,\n          isHidden: A\n        },\n        parentId: S.id,\n        index: ee\n      }).finally(() => {\n        addingCache[oe].delete(Z);\n      });\n    },\n    removeParticipant(Z, re = \"camera\") {\n      S.children.filter((oe) => {\n        var de, A;\n        return ((de = oe.props.sourceProps) == null ? void 0 : de.id) === Z && ((A = oe.props.sourceProps) == null ? void 0 : A.type) === re && oe.props.sourceType === \"RoomParticipant\";\n      }).forEach((oe) => {\n        CoreContext.Command.deleteNode({\n          nodeId: oe.id\n        });\n      });\n    },\n    getParticipantNode(Z, re = \"camera\") {\n      return S.children.find((oe) => {\n        var de, A;\n        return ((de = oe.props.sourceProps) == null ? void 0 : de.id) === Z && ((A = oe.props.sourceProps) == null ? void 0 : A.type) === re;\n      });\n    },\n    getParticipantState(Z, re = \"camera\") {\n      var oe;\n      return (oe = q.getParticipantNode(Z, re)) == null ? void 0 : oe.props;\n    },\n    useParticipantState(Z, re, oe = \"camera\") {\n      let de = q.getParticipantNode(Z, oe);\n      const A = () => {\n        re(de == null ? void 0 : de.props);\n      }, N = CoreContext.onInternal(\"NodeChanged\", (W) => {\n        if (W.nodeId !== S.id)\n          return;\n        const ee = de;\n        de = q.getParticipantNode(Z, oe), ee !== de && A();\n      }), D = CoreContext.onInternal(\"NodeChanged\", (W) => {\n        !de || W.nodeId !== de.id || A();\n      });\n      return A(), () => {\n        N(), D();\n      };\n    },\n    setParticipantVolume(Z, re) {\n      const oe = q.getParticipantNode(Z);\n      oe && CoreContext.Command.updateNode({\n        nodeId: oe.id,\n        props: {\n          volume: re\n        }\n      });\n    },\n    setParticipantMuted(Z, re) {\n      const oe = q.getParticipantNode(Z);\n      oe && CoreContext.Command.updateNode({\n        nodeId: oe.id,\n        props: {\n          isMuted: re\n        }\n      });\n    },\n    setParticipantHidden(Z, re) {\n      const oe = q.getParticipantNode(Z);\n      oe && CoreContext.Command.updateNode({\n        nodeId: oe.id,\n        props: {\n          isHidden: re\n        }\n      });\n    },\n    pruneParticipants() {\n      const Z = getProjectRoom(u);\n      Z && S.children.filter((re) => {\n        var W, ee, ae;\n        if (re.props.sourceType !== \"RoomParticipant\")\n          return !1;\n        const oe = (W = re.props.sourceProps) == null ? void 0 : W.type, de = Z.getParticipant((ee = re.props.sourceProps) == null ? void 0 : ee.id), A = Z.getTrack((ae = re.props.sourceProps) == null ? void 0 : ae.id);\n        return !de && !A ? !0 : oe === \"camera\" ? !1 : !de.trackIds.map((ye) => Z.getTrack(ye)).filter(Boolean).some((ye) => (ye.type === Track.Source.Camera || ye.type === Track.Source.Microphone ? \"camera\" : \"screen\") === oe);\n      }).forEach((re) => {\n        CoreContext.Command.deleteNode({\n          nodeId: re.id\n        });\n      });\n    },\n    getProp(Z) {\n      return getProject(a.id).props[Z];\n    },\n    setProp(Z, re) {\n      return l.updateProjectProps({\n        projectId: u,\n        props: {\n          [Z]: re\n        }\n      });\n    },\n    useProp(Z, re) {\n      return CoreContext.on(\"ProjectChanged\", (oe) => {\n        u === oe.project.id && re(oe.project.props[Z]);\n      });\n    },\n    createSource(Z) {\n      return CoreContext.Command.createSource(Z);\n    },\n    deleteSource(Z) {\n      const re = \"rtmp\";\n      return S.children.filter((oe) => {\n        var de, A;\n        return ((de = oe.props.sourceProps) == null ? void 0 : de.id) === Z.sourceId && ((A = oe.props.sourceProps) == null ? void 0 : A.type) === re && oe.props.sourceType === \"RTMP\";\n      }).forEach((oe) => {\n        CoreContext.Command.deleteNode({\n          nodeId: oe.id\n        });\n      }), CoreContext.Command.deleteSource(Z);\n    }\n  };\n  return (async () => {\n    await $(), await J(), await V();\n  })(), q;\n}, create = async (a = {}, u = {}, c) => CoreContext.Command.createProject({\n  settings: a,\n  props: u,\n  size: c\n}), createCompositor = async (a, u, c) => {\n  const {\n    layout: l,\n    layoutProps: v = {}\n  } = c, S = await CoreContext.compositor.createProject({\n    props: {\n      name: \"Root\",\n      type: \"sceneless-project\",\n      sourceType: \"Element\",\n      layout: \"Layered\",\n      size: u,\n      isRoot: !0,\n      tagName: \"div\",\n      version: \"beta\",\n      fields: {\n        style: {\n          background: \"black\"\n        }\n      }\n    }\n  }, a), g = S.getRoot(), E = await Promise.all([S.insert({\n    name: \"Background\",\n    id: \"bg\",\n    layout: \"Layered\"\n  }, g.id), S.insert({\n    id: \"content\",\n    name: \"Content\",\n    layout: l,\n    layoutProps: v\n  }, g.id), S.insert({\n    id: \"foreground\",\n    name: \"Overlays\",\n    layout: \"Layered\"\n  }, g.id)]);\n  await S.reorder(g.id, E);\n  const _ = g.children.find((M) => M.props.id === \"foreground\"), k = ForegroundLayers.map((M) => S.insert(M, _.id)), L = await Promise.all(k);\n  return await S.reorder(_.id, L), S;\n}, scenelessProject = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  commands,\n  create,\n  createCompositor\n}, Symbol.toStringTag, { value: \"Module\" })), useActiveProjectRoom = (a) => {\n  const u = getProject(CoreContext.state.activeProjectId);\n  return a(u ? getRoom(u.roomId) : null), CoreContext.on(\"RoomJoined\", () => {\n    const c = getProject(CoreContext.state.activeProjectId);\n    a(c ? getRoom(c.roomId) : null);\n  });\n}, callbacks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  useActiveProjectRoom\n}, Symbol.toStringTag, { value: \"Module\" })), index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  Callback: callbacks,\n  React: react,\n  Room: webrtc,\n  ScenelessProject: scenelessProject\n}, Symbol.toStringTag, { value: \"Module\" })), runFilters = (a, u = []) => u.reduce((c, l) => l(c), a), transforms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  runFilters\n}, Symbol.toStringTag, { value: \"Module\" })), createDefault = () => ({\n  root: document.createElement(\"div\")\n}), init$2 = (a = {}, u, c) => {\n  const l = {}, v = a.defaultTransforms || {}, S = (G) => {\n    asArray(G).forEach((H) => {\n      l[H.name] = H;\n    });\n  }, g = {}, E = {}, _ = {}, k = (G) => _[G] || [], L = (G) => E[G] || [], M = (G) => g[G], $ = (G) => l[G];\n  u.on(\"SourceChanged\", (G) => {\n    L(G.id).forEach((B) => {\n      const Y = u.getNode(B.nodeId);\n      B._onUpdateHandlers.forEach((ne) => ne(Y.props || {}));\n    });\n  }), u.on(\"AvailableSourcesChanged\", ({\n    type: G,\n    sources: H\n  }) => {\n    k(G).forEach((Y) => {\n      J(Y.nodeId);\n    });\n  });\n  const J = (G) => {\n    var A, N, D;\n    const H = M(G);\n    if (!H)\n      return;\n    const B = $(H.transformName);\n    if (!B.useSource)\n      return;\n    const Y = u.getNode(G), ne = H.proxySource ? H.proxySource : H.sourceType, Z = c.getSources(ne), re = B.useSource(Z, Y.props), oe = H.sourceValue, de = re == null ? void 0 : re.value;\n    H.source !== re && (E[(A = H.source) == null ? void 0 : A.id] && (E[(N = H.source) == null ? void 0 : N.id] = E[(D = H.source) == null ? void 0 : D.id].filter((W) => W.nodeId !== G)), E[re == null ? void 0 : re.id] = [...E[re == null ? void 0 : re.id] || [], H]), H.source = re, H.sourceValue = de, Object.is(oe, de) || H._onNewSourceHandlers.forEach((W) => W(re));\n  }, V = (G) => {\n    const H = q(G), Y = runFilters(G, []);\n    return J(G.id), H == null || H._onUpdateHandlers.forEach((ne) => ne(G.props || {})), {\n      ...Y,\n      children: Y.children.map(V)\n    };\n  }, q = (G) => {\n    if (g[G.id])\n      return g[G.id];\n    const {\n      props: H = {}\n    } = G, {\n      sourceType: B,\n      proxySource: Y\n    } = H;\n    if (!B)\n      return null;\n    let ne = v[B], Z;\n    if (ne ? Z = l[ne] : Z = Object.values(l).find((ae) => ae.sourceType === B), !Z)\n      throw new Error(\"Could not find matching transform for sourceType: \" + B);\n    const re = [], oe = [], de = [], A = [], D = {\n      ...(Z.create || createDefault)({\n        onEvent: (ae, ye, ...he) => {\n          const le = u.on(ae, ye, ...he);\n          return A.push(le), le;\n        },\n        onNewSource: (ae) => re.push(ae),\n        onUpdate: (ae) => oe.push(ae),\n        onRemove: (ae) => de.push(ae)\n      }, G.props),\n      proxySource: Y,\n      sourceType: B,\n      nodeId: G.id,\n      transformName: Z.name,\n      _onNewSourceHandlers: re,\n      _onUpdateHandlers: oe,\n      _disposables: A\n    };\n    g[G.id] = D;\n    const W = Y || B;\n    _[W] = [..._[W] || [], D], Z.useSource && J(G.id);\n    const ee = [\n      // Dispose when node is removed\n      u.on(\"NodeRemoved\", ({\n        nodeId: ae\n      }) => {\n        if (ae === G.id) {\n          const ye = u.getNode(ae), {\n            sourceType: he = \"Element\"\n          } = ye.props;\n          ee.forEach((we) => we == null ? void 0 : we()), A.forEach((we) => we == null ? void 0 : we()), de.forEach((we) => we == null ? void 0 : we()), delete g[ye.id];\n          const le = Y || he;\n          _[le] = _[le].filter((we) => we !== g[ye.id]);\n        }\n      })\n    ];\n    return D;\n  };\n  return {\n    transforms: l,\n    nodeElementIndex: g,\n    elementSourceTypeIndex: _,\n    registerTransform: S,\n    getElementsBySourceType: k,\n    getElementByNodeId: M,\n    getTransformByName: $,\n    updateSourceForNode: J,\n    renderTree: V,\n    getElement: q\n  };\n}, TRANSITION_DURATION = 300, findLayoutUp = (a, u, c = 0) => {\n  const v = a.parentElement;\n  return v instanceof Layout && (c = 0, !u || u(v)) ? v : v ? c > 4 ? null : findLayoutUp(v, u, c + 1) : null;\n}, TRANSITION_FIELDS = \"opacity, transform, width, height, left, right, top, bottom, inset\", layoutIndex = {}, parentIdIndex = {}, childIndex = {};\nlet rootLayout, _cid = 1;\nconst ignoredAttributes = [\"style\", \"id\", \"className\"];\nlet tickOps = {};\nconst tick = () => {\n  if (nextTick = null, window.__dragging) {\n    nextTick = nextTick || requestAnimationFrame(tick);\n    return;\n  }\n  const a = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();\n  Object.entries(tickOps).forEach(([l, v]) => {\n    v.forEach(([S, g, E]) => {\n      switch (S) {\n        case \"childInserted\": {\n          u.has(E) ? u.delete(E) : a.add(E);\n          break;\n        }\n        case \"childRemoved\": {\n          a.has(E) ? a.delete(E) : u.add(E);\n          break;\n        }\n        case \"childRemoveFinished\": {\n          c.add(E);\n          break;\n        }\n      }\n    });\n  });\n  try {\n    u.forEach((v) => {\n      var E, _, k;\n      const S = childIndex[v], g = Array.from(((E = S.parentEl) == null ? void 0 : E.children) || []);\n      S.nextSiblingEl && g.includes(S.nextSiblingEl) ? (_ = S.parentEl) == null || _.insertBefore(S, S.nextSiblingEl) : (S.nextSiblingEl = null, (k = S.parentEl) == null || k.append(S)), S.runRemove();\n    }), c.forEach((v) => {\n      const S = childIndex[v];\n      if (S.removed) {\n        S.previousSiblingEl && (S.previousSiblingEl.nextSiblingEl = S.nextSiblingEl), S.nextSiblingEl && (S.nextSiblingEl.previousSiblingEl = S.previousSiblingEl);\n        return;\n      }\n    });\n    const l = window.__scale;\n    Object.entries(tickOps).forEach(([v, S]) => {\n      const g = layoutIndex[v], E = g.getBoundingClientRect(), _ = {\n        x: E.width / l,\n        y: E.height / l\n      };\n      g.updatePositions({\n        size: _,\n        inserted: a,\n        removed: u\n      });\n    });\n  } catch (l) {\n    log$1.warn(\"Failed to run Layout ops\", l);\n  }\n  tickOps = {};\n};\nlet nextTick;\nconst queueOp = (a) => {\n  const [u, c] = a, l = tickOps[c] || [];\n  tickOps[c] = [...l, a], nextTick = nextTick || requestAnimationFrame(tick);\n};\nclass Layout extends HTMLElement {\n  constructor() {\n    super();\n    ht(this, \"parentEl\");\n    ht(this, \"slotEl\");\n    ht(this, \"parentLayout\");\n    ht(this, \"nodes\");\n    ht(this, \"mutationObserver\");\n    ht(this, \"latestSize\");\n    ht(this, \"isFirst\", !0);\n    ht(this, \"isUpdating\", !1);\n    ht(this, \"cid\");\n    this.cid = ++_cid;\n  }\n  log(...c) {\n    var l;\n    log$1.debug(...c, {\n      id: this.dataset.id,\n      parent: (l = this.parentLayout) == null ? void 0 : l.dataset.id\n    }, this);\n  }\n  connectedCallback() {\n    var c;\n    this.parentEl = this.parentElement, this.parentLayout = findLayoutUp(this), this.slotEl = this.closest(\"[data-layout-child]\"), Array.from(this.children).forEach((l) => this.initializeChild(l)), rootLayout || (rootLayout = this), layoutIndex[this.dataset.id] = this, parentIdIndex[this.dataset.id] = (c = this.parentLayout) == null ? void 0 : c.id, Object.assign(this.style, {\n      width: \"100%\",\n      height: \"100%\",\n      position: \"absolute\",\n      top: \"0px\",\n      left: \"0px\",\n      pointerEvents: \"none\",\n      boxSizing: \"border-box\"\n    }), this.mutationObserver && this.mutationObserver.disconnect(), this.mutationObserver = new MutationObserver((l) => {\n      this.isConnected && l.forEach((v) => {\n        v.type === \"attributes\" && !ignoredAttributes.includes(v.attributeName) ? queueOp([\"attributesChanged\", this.dataset.id]) : v.type === \"childList\" && (v.addedNodes.forEach((S) => {\n          const g = childIndex[S.dataset.id];\n          S.removed || (g ? g !== S && (this.initializeChild(S), S.setAttribute(\"style\", g.getAttribute(\"style\")), S.data = g.data) : this.initializeChild(S), queueOp([\"childInserted\", this.dataset.id, S.dataset.id]));\n        }), v.removedNodes.forEach((S) => {\n          S.removed || queueOp([\"childRemoved\", this.dataset.id, S.dataset.id]);\n        }));\n      });\n    }), this.mutationObserver.observe(this, {\n      childList: !0,\n      attributes: !0\n    }), this.latestSize || queueOp([\"attributesChanged\", this.dataset.id]);\n  }\n  disconnectedCallback() {\n  }\n  adoptedCallback() {\n  }\n  updatePositions(c) {\n    if (this.isUpdating)\n      return;\n    this.isUpdating = !0;\n    const {\n      size: l,\n      inserted: v = /* @__PURE__ */ new Set(),\n      removed: S = /* @__PURE__ */ new Set()\n    } = c;\n    this.nodes = Array.from(this.children || []).filter((k) => !k.removed).map((k, L) => {\n      const M = getElementAttributes(k);\n      return {\n        // TODO: Does this work well enough? Think through keying\n        id: k.dataset.id,\n        props: M,\n        children: []\n      };\n    });\n    const g = JSON.parse(this.getAttribute(\"props\") || \"{}\");\n    this.latestSize = l;\n    const E = {\n      id: this.dataset.id,\n      props: g,\n      children: this.nodes,\n      size: l\n    };\n    let _ = layoutChildren(E);\n    Promise.all(Object.entries(_).map(async ([k, L]) => {\n      var ne, Z, re, oe;\n      let M = childIndex[k] || this.querySelector(`[data-layout-child][data-id=\"${k}\"]`);\n      const $ = {\n        ...M.data,\n        ...L\n      };\n      M.data = $;\n      const {\n        size: J,\n        position: V,\n        zIndex: q = 1,\n        opacity: G = 1,\n        borderRadius: H = 0,\n        entryTransition: B = {},\n        exitTransition: Y = {}\n      } = $;\n      if (M) {\n        if (M.removed)\n          return;\n        Y && (M.data.exitTransition = Y), B && (M.data.entryTransition = B), M.data.size = J, M.data.position = V;\n        const de = window.__scale, A = this.getBoundingClientRect(), N = A.width / de, D = N - sizeToNum(V.x, N) - sizeToNum(J.x, N), W = A.height / de, ee = W - sizeToNum(V.y, W) - sizeToNum(J.y, W);\n        Object.assign(M.style, {\n          position: \"absolute\",\n          transformOrigin: \"50% 50%\",\n          transitionDuration: \"0ms\",\n          transitionDelay: \"0ms\",\n          transform: \"translate3d(0, 0, 0) scaleX(1) scaleY(1)\",\n          visibility: \"visible\",\n          boxSizing: \"border-box\",\n          overflow: \"hidden\",\n          borderRadius: H + \"px\",\n          width: \"auto\",\n          height: \"auto\"\n        });\n        let ae = \"0ms\", ye = this.isFirst ? asDuration(0) : asDuration(TRANSITION_DURATION);\n        if (v.has(k))\n          Object.assign(M.style, {\n            transitionProperty: TRANSITION_FIELDS,\n            transitionDuration: \"0ms\",\n            transitionTimingFunction: B.timingFn ?? \"ease\",\n            transform: `translate3d(calc(${asSize(((ne = B.offset) == null ? void 0 : ne.x) ?? 0)}), calc(${asSize(((Z = B.offset) == null ? void 0 : Z.y) ?? 0)}), 0) scaleX(${((re = B.scale) == null ? void 0 : re.x) ?? 1}) scaleY(${((oe = B.scale) == null ? void 0 : oe.y) ?? 1})`,\n            opacity: B.opacity ?? G,\n            left: asSize(V.x) || 0,\n            right: asSize(D) || 0,\n            top: asSize(V.y) || 0,\n            bottom: asSize(ee) || 0\n          }), ae = asDuration(B.delay ?? 0);\n        else if (M.data.rootOffset) {\n          const we = rootLayout.getBoundingClientRect(), Be = this.getBoundingClientRect(), Ne = {\n            x: Be.x / de - we.x / de,\n            y: Be.y / de - we.y / de\n          }, Le = Ne.x + Be.width / de, $e = M.data.rootOffset.x + Number(M.data.size.x), Ue = Ne.y + Be.height / de, Ge = M.data.rootOffset.y + Number(M.data.size.y);\n          M.data.rootOffset.x - Ne.x, M.data.rootOffset.y - Ne.y, Le - $e, Ue - Ge;\n        }\n        M.addEventListener(\"transitionstart\", () => {\n          M.style.zIndex = String(q + 1);\n        }), await new Promise((we) => window.setTimeout(we)), Object.assign(M.style, {\n          transitionProperty: TRANSITION_FIELDS,\n          transitionDuration: ye,\n          transitionDelay: ae,\n          transform: \"translate3d(0, 0, 0) scaleX(1) scaleY(1)\",\n          opacity: G,\n          left: asSize(V.x) || 0,\n          top: asSize(V.y) || 0,\n          width: N ? \"auto\" : J.x,\n          right: N ? asSize(D) || 0 : \"auto\",\n          height: W ? \"auto\" : J.y,\n          bottom: W ? asSize(ee) || 0 : \"auto\",\n          zIndex: q\n        });\n        const le = () => {\n          const we = rootLayout.getBoundingClientRect(), Be = M.getBoundingClientRect();\n          M.data.rootOffset = {\n            x: Be.x / de - we.x / de,\n            y: Be.y / de - we.y / de\n          };\n        };\n        le(), M.addEventListener(\"transitionend\", () => {\n          M.style.zIndex = String(q), le();\n        });\n      }\n    })).then(() => {\n      this.isUpdating = !1;\n    }), this.isFirst = !1, Array.from(this.querySelectorAll(\"ls-layout\")).forEach((k) => {\n      if (!_[k.dataset.id])\n        return;\n      const L = _[k.dataset.id].size;\n      k.updatePositions({\n        size: {\n          x: sizeToNum(L.x, l.x),\n          y: sizeToNum(L.y, l.y)\n        }\n      });\n    });\n  }\n  initializeChild(c) {\n    var v;\n    if (!((v = c.dataset) != null && v.id))\n      return log$1.warn(\"Layout: Child requires `data-id` at the time it is added to a Layout\");\n    c._remove = c.remove, c.remove = () => {\n      this.removeChild(c);\n    }, c.mutationObserver || (c.mutationObserver = new MutationObserver((S) => {\n      S.forEach((g) => {\n        if (g.type === \"attributes\") {\n          if (g.attributeName === \"style\")\n            return;\n          queueOp([\"childAttributesChanged\", this.dataset.id, c.dataset.id]);\n        }\n      });\n    }), c.mutationObserver.observe(c, {\n      childList: !0,\n      attributes: !0\n    }));\n    const l = {\n      entryTransition: {\n        delay: 0,\n        opacity: 0,\n        scale: {\n          x: 1,\n          y: 1\n        },\n        offset: {\n          x: 0,\n          y: 0\n        }\n      },\n      exitTransition: {\n        delay: 0,\n        opacity: 0,\n        scale: {\n          x: 1,\n          y: 1\n        },\n        offset: {\n          x: 0,\n          y: 0\n        }\n      },\n      position: {\n        x: 0,\n        y: 0\n      },\n      size: {\n        x: 0,\n        y: 0\n      },\n      opacity: 0,\n      fit: \"cover\",\n      borderRadius: 0,\n      zIndex: 1\n    };\n    c.data = l, c.parentEl = c.parentElement, c.nextSiblingEl = c.nextSibling, c.previousSiblingEl = c.previousSibling, c.previousSiblingEl && (c.previousSiblingEl.nextSiblingEl = c), c.toggleAttribute(\"data-layout-child\", !0), childIndex[c.dataset.id] = c, c.runRemove = async () => {\n      var g, E, _, k;\n      c.removed = !0;\n      const S = TRANSITION_DURATION;\n      return await new Promise((L) => window.setTimeout(L)), Object.assign(c.style, {\n        zIndex: 0,\n        transitionDelay: asDuration(0),\n        transitionDuration: asDuration(S),\n        transitionProperty: TRANSITION_FIELDS,\n        transitionTimingFunction: l.exitTransition.timingFn ?? \"ease\",\n        transform: `translate3d(calc(${asSize(((g = l.exitTransition.offset) == null ? void 0 : g.x) ?? 0)}), calc( ${asSize(((E = l.exitTransition.offset) == null ? void 0 : E.y) ?? 0)}), 0) scaleX(${((_ = l.exitTransition.scale) == null ? void 0 : _.x) ?? 1}) scaleY(${((k = l.exitTransition.scale) == null ? void 0 : k.y) ?? 1})`,\n        opacity: l.exitTransition.opacity ?? 0\n      }), c.removed = !0, c.transition = new Promise((L) => {\n        const M = () => {\n          c.transition = null, c._remove(), queueOp([\"childRemoveFinished\", this.dataset.id, c.dataset.id]), clearTimeout($), L();\n        }, $ = window.setTimeout(M, parseInt(String(S)) + 600);\n        c.addEventListener(\"transitionend\", M, {\n          once: !0\n        });\n      }), c.transition;\n    };\n  }\n}\nconst ensureLayoutContainer = (a) => {\n  const u = document.getElementById(\"__ls-layout-container\");\n  if (u)\n    return Object.assign(u.style, {\n      width: a.x + \"px\",\n      height: a.y + \"px\"\n    }), u;\n  const c = document.createElement(\"div\");\n  return c.id = \"__ls-layout-container\", Object.assign(c.style, {\n    position: \"fixed\",\n    // pointerEvents: 'none',\n    visibility: \"hidden\",\n    top: \"0px\",\n    left: \"0px\",\n    zIndex: -1,\n    width: a.x + \"px\",\n    height: a.y + \"px\"\n  }), document.body.append(c), c;\n}, layoutChildren = ({\n  id: a,\n  props: u = {},\n  children: c,\n  size: l\n}) => {\n  const v = {\n    props: u,\n    children: c,\n    size: l\n  }, S = htmlLayouts[u.layout] ? htmlLayouts[u.layout].layout(v) : htmlLayouts.Free.layout(v);\n  if (!(S instanceof HTMLElement))\n    return S;\n  const g = Array.from(S.querySelectorAll(\"[data-node-id]\")), E = document.createElement(\"div\");\n  E.style.height = S.style.height = l.y + \"px\", E.style.width = S.style.width = l.x + \"px\", E.style.position = \"absolute\", E.style.top = \"0px\", E.style.left = \"0px\", E.style.boxSizing = \"border-box\", E.setAttribute(\"data-wrapper-id\", a), E.append(S);\n  const _ = ensureLayoutContainer(l), k = _.querySelector(`[data-wrapper-id=\"${a}\"]`);\n  k ? k.replaceWith(E) : _.append(E);\n  const L = S.getBoundingClientRect(), M = {};\n  return g.forEach(($) => {\n    var H, B, Y, ne;\n    const J = $.dataset.nodeId;\n    if (!J)\n      return;\n    const V = Number($.dataset.opacity ?? ($.style.opacity || 1)), q = $.getBoundingClientRect();\n    let G = {\n      position: {\n        x: q.x - L.x + \"px\",\n        y: q.y - L.y + \"px\"\n      },\n      size: {\n        x: q.width + \"px\",\n        y: q.height + \"px\"\n      },\n      opacity: V,\n      zIndex: (H = $.data) == null ? void 0 : H.zIndex,\n      entryTransition: ((B = $.data) == null ? void 0 : B.entryTransition) ?? {},\n      exitTransition: ((Y = $.data) == null ? void 0 : Y.exitTransition) ?? {},\n      borderRadius: ((ne = $.data) == null ? void 0 : ne.borderRadius) ?? 0\n    };\n    `${u.showcase}-x` === J && (G.position = {\n      x: L.x + \"px\",\n      y: L.y + \"px\"\n    }, G.size = {\n      x: L.width + \"px\",\n      y: L.height + \"px\"\n    }, G.zIndex = 10), M[J] = G, positionIndex[$.dataset.nodeId] = G;\n  }), M;\n}, positionIndex = {}, htmlLayouts = {}, registerLayout = (a) => {\n  asArray(a).forEach((u) => {\n    htmlLayouts[u.name] = u;\n  });\n}, sourceTypes = {}, init$1 = (a = {}, u) => {\n  const c = {}, l = {}, v = (_) => {\n    u.triggerEvent(\"SourceChanged\", _);\n  }, S = (_) => {\n    u.triggerEvent(\"AvailableSourcesChanged\", {\n      type: _,\n      sources: l[_]\n    });\n  }, E = {\n    sourceIndex: c,\n    sourceTypeIndex: l,\n    registerSource: (_) => {\n      asArray(_).forEach((k) => {\n        var M;\n        const L = ($) => {\n          const J = c[$];\n          if (J && J.type !== k.type)\n            throw new Error(`Attempted to modify source of type ${J.type} from ${k.type}`);\n        };\n        (M = k.init) == null || M.call(k, {\n          getSource: ($) => E.getSource($),\n          removeSource: ($) => (L($), E.removeSource($)),\n          setSourceActive: ($, J) => (L($), E.setSourceActive($, J)),\n          updateSource: ($, J) => (L($), E.updateSource($, J)),\n          modifySourceValue($, J) {\n            return L($), E.modifySourceValue($, J);\n          },\n          addSource: ($) => E.addSource(k.type, $)\n        }), sourceTypes[k.type] = k;\n      });\n    },\n    getSource: (_) => c[_],\n    getSources: (_) => l[_] || [],\n    useSource: (_, k) => (k(c[_]), u.on(\"SourceChanged\", (L) => {\n      L.id === _ && k(L);\n    })),\n    useSources: (_, k) => (k(l[_] || []), u.on(\"AvailableSourcesChanged\", (L) => {\n      L.type === _ && k(L.sources);\n    })),\n    addSource: (_, k) => {\n      if (!k.id)\n        throw new Error('Cannot add source without field \"id\"');\n      if (c[k.id])\n        return;\n      if (!k.value)\n        throw new Error('Cannot add source with an empty field \"value\"');\n      if (!sourceTypes[_])\n        throw new Error(\"Could not find definition for source type: \" + _);\n      const {\n        id: M,\n        value: $ = null,\n        props: J = {},\n        isActive: V = !0\n      } = k;\n      c[M] = {\n        id: M,\n        type: _,\n        props: J,\n        value: $,\n        isActive: V\n      }, l[_] = [...l[_] || [], c[M]], v(c[M]), S(_);\n    },\n    removeSource: (_) => {\n      const k = c[_];\n      k && (delete c[_], l[k.type] = l[k.type].filter((L) => L.id !== _), S(k.type));\n    },\n    updateSource: (_, k) => {\n      const L = c[_];\n      L.props = {\n        ...L.props,\n        ...k\n      }, v(L), S(L.type);\n    },\n    /**\n     * Imperatively update a Source's value.\n     * Triggers an event to inform elements to re-render.\n     */\n    modifySourceValue: async (_, k) => {\n      const L = c[_];\n      await k(L.value), v(L);\n    },\n    setSourceActive: (_, k = !0) => {\n      const L = c[_];\n      L.isActive = k, S(L.type);\n    }\n  };\n  return E;\n}, sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  init: init$1,\n  sourceTypes\n}, Symbol.toStringTag, { value: \"Module\" })), layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null\n}, Symbol.toStringTag, { value: \"Module\" })), {\n  forEachDown,\n  insertAt,\n  toDataNode,\n  pull,\n  replaceItem\n} = Logic;\nlet compositor;\nconst start = (a) => {\n  if (compositor)\n    return compositor;\n  const {\n    dbAdapter: u,\n    transformSettings: c = {},\n    sourceSettings: l = {}\n  } = a, v = {}, S = {};\n  try {\n    customElements.define(\"ls-layout\", Layout);\n  } catch (H) {\n    log$1.warn(H);\n  }\n  const g = {}, E = {}, _ = {};\n  let k = 0;\n  const L = /* @__PURE__ */ new Map(), M = (H, B) => {\n    if (typeof H != \"function\")\n      return;\n    const Y = ++k;\n    return L.set(Y, H), H.nodeId = B, () => {\n      L.delete(Y);\n    };\n  }, $ = (H, B, Y) => M((ne, Z) => {\n    ne === H && B(Z);\n  }, Y), J = (H, B) => {\n    L.forEach((Y) => {\n      Y.nodeId ? B != null && B.nodeId && (B == null ? void 0 : B.nodeId) === Y.nodeId && Y(H, B) : Y(H, B);\n    });\n  }, V = {\n    projects: S,\n    subscribe: M,\n    on: $,\n    triggerEvent: J,\n    getProject: (H) => S[H],\n    getNodeProject: (H) => S[g[H]],\n    getNodeParent: (H) => _[E[H]],\n    getNode: (H) => _[H],\n    createProject: async (H = {}, B) => {\n      const {\n        id: Y,\n        props: ne = {},\n        children: Z = []\n      } = H, re = await u(B, {\n        get: () => null,\n        getParent: () => null\n      }).insert(ne), oe = {\n        id: re,\n        props: ne,\n        children: Z\n      };\n      return forEachDown(H, (de) => {\n      }), _[re] = oe, compositor.loadProject(oe, B);\n    },\n    loadProject: (H, B) => {\n      if (!H)\n        return;\n      if (B = B || H.id, S[B])\n        return S[B];\n      forEachDown(H, (re, oe) => {\n        _[re.id] = re, E[re.id] = oe == null ? void 0 : oe.id, g[re.id] = B;\n      });\n      const Y = {\n        insert: async (re, oe, de = 0) => {\n          if (re.id && _[re.id])\n            return _[re.id];\n          if (re.children || (re.children = []), re.props || (re.props = {}), oe) {\n            const A = _[oe];\n            if (!A)\n              throw \"Parent node not found with ID\";\n            A.children = insertAt(de, re, A.children || []), E[re.id] = oe;\n          }\n          return _[re.id] = re, g[re.id] = B, re.id;\n        },\n        update: async (re, oe = {}, de) => {\n          const A = _[re];\n          if (de) {\n            const N = de.map((D) => {\n              const W = _[D];\n              return E[W.id] = re, W;\n            });\n            A.children = N;\n          }\n          A.props = {\n            ...A.props,\n            ...oe\n          };\n        },\n        remove: async (re) => {\n          const oe = _[E[re]];\n          oe && (oe.children = oe.children.filter((A) => A.id !== re));\n          const de = _[re];\n          forEachDown(de, (A) => {\n            _[A.id] && (_[A.id]._deleted = !0), J(\"NodeRemoved\", {\n              projectId: ne.id,\n              nodeId: A.id\n            });\n          });\n        }\n      }, ne = {\n        id: B,\n        getRoot: () => H,\n        get(re) {\n          return _[re];\n        },\n        getParent(re) {\n          return _[E[re]];\n        },\n        renderTree() {\n          return G.renderTree(H);\n        },\n        local: Y,\n        insert: async (re = {}, oe, de = 0) => {\n          const N = {\n            id: await Z.insert(re, oe, de),\n            props: re,\n            children: []\n          };\n          return Y.insert(N, oe, de);\n        },\n        update: async (re, oe) => (await Y.update(re, oe), Z.update(re, oe)),\n        remove: async (re) => {\n          await Y.remove(re);\n          const oe = _[E[re]], de = oe.children.filter((A) => A.id !== re);\n          return Z.batch([[\"delete\", {\n            id: re\n          }], [\"update\", {\n            ...oe,\n            children: de\n          }]]);\n        },\n        reorder: async (re, oe) => {\n          const de = _[re];\n          return de.children = oe.map((A) => de.children.find((N) => N.id === A)), Z.batch([[\"update\", de]]);\n        },\n        move: async (re, oe, de = 0) => {\n          const A = _[re], N = _[E[re]], D = _[oe];\n          N.children = pull(N.children, A), D.children = insertAt(de, A, D.children), Z.batch([[\"update\", D], [\"update\", N]]), E[re] = oe;\n        },\n        swap: async (re, oe) => {\n          const de = _[re], A = _[oe], N = _[E[re]], D = _[E[oe]];\n          N.children = replaceItem((W) => W.id === re, A, N.children), D.children = replaceItem((W) => W.id === oe, de, D.children), E[re] = D.id, E[oe] = N.id, Z.batch([[\"update\", N], [\"update\", D]]);\n        }\n      };\n      Object.defineProperty(ne, \"nodes\", {\n        get() {\n          return Object.values(_).filter((re) => g[re.id] === ne.id);\n        }\n      });\n      const Z = v[B] || u(B, {\n        get: (re) => toDataNode(ne.get(re)),\n        getParent: (re) => toDataNode(ne.getParent(re))\n      });\n      return v[B] = Z, S[B] = ne, ne;\n    }\n  }, q = init$1(l, V), G = init$2(c, V, q);\n  return compositor = {\n    registerLayout,\n    registerTransform: G.registerTransform,\n    registerSource: q.registerSource,\n    getElement: G.getElement,\n    getSource: q.getSource,\n    getSources: q.getSources,\n    useSource: q.useSource,\n    useSources: q.useSources,\n    ...V\n  }, compositor;\n}, index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  Layout: layouts,\n  Source: sources,\n  Transform: transforms,\n  start\n}, Symbol.toStringTag, { value: \"Module\" })), createProject = async (a) => {\n  const u = getUser().id, c = a.type || \"sceneless\", l = a.size || {\n    x: 1280,\n    y: 720\n  }, v = a.settings || {};\n  let S = await CoreContext.clients.LiveApi().project.createProject({\n    collectionId: u,\n    rendering: {\n      video: {\n        width: l.x,\n        height: l.y,\n        framerate: 30\n      }\n    },\n    composition: {\n      studioSdk: {\n        version: CoreContext.rendererVersion\n      }\n    },\n    metadata: {},\n    webrtc: {\n      hosted: {}\n    }\n  });\n  const g = await createLayout({\n    projectId: S.project.projectId,\n    collectionId: S.project.collectionId,\n    settings: v,\n    size: l,\n    type: c\n  }), {\n    displayName: E\n  } = getAccessTokenData(), _ = {\n    type: c,\n    layoutId: g.id,\n    hostDisplayName: E,\n    props: a.props || {}\n  };\n  let k = await CoreContext.clients.LiveApi().project.updateProject({\n    collectionId: u,\n    projectId: S.project.projectId,\n    updateMask: [\"metadata\"],\n    metadata: _\n  });\n  return S.project = k.project, S.project.metadata = _, S;\n}, deleteProject = async (a) => {\n  const {\n    projectId: u\n  } = a, c = getProject(u), l = getUser().id;\n  await Promise.all([CoreContext.clients.LiveApi().project.deleteProject({\n    collectionId: l,\n    projectId: u\n  }), CoreContext.clients.LayoutApi().layout.deleteLayout({\n    layoutId: c.layoutApi.layoutId\n  })]);\n}, loadUser = async (a) => {\n  var g;\n  const u = await loadCollections();\n  let c;\n  const {\n    displayName: l,\n    serviceUserId: v\n  } = getAccessTokenData();\n  u.length === 0 ? c = (await CoreContext.clients.LiveApi().collection.createCollection({\n    metadata: {\n      serviceUserId: v,\n      displayName: l,\n      props: {}\n    }\n  })).collection : c = u[0], await CoreContext.clients.LiveApi().subscribeToCollection(c.collectionId);\n  const S = await Promise.all(c.projects.filter((E) => {\n    var _;\n    return !!((_ = E.metadata) != null && _.layoutId);\n  }).map((E) => hydrateProject(E, \"ROLE_HOST\", a)));\n  return {\n    user: {\n      id: c.collectionId,\n      metadata: c.metadata,\n      props: ((g = c.metadata) == null ? void 0 : g.props) || {},\n      name: l\n    },\n    projects: S,\n    sources: c.sources\n  };\n}, loadCollections = async () => (await CoreContext.clients.LiveApi().collection.getCollections({})).collections, createLayout = async (a) => {\n  const {\n    settings: u,\n    size: c,\n    type: l,\n    projectId: v,\n    collectionId: S\n  } = a, g = await CoreContext.clients.LayoutApi().layout.createLayout({\n    layout: {\n      projectId: v,\n      collectionId: S\n    }\n  });\n  return l === \"sceneless\" ? await createCompositor(g.id, c, u) : await CoreContext.compositor.createProject({\n    props: {\n      name: \"Root\",\n      layout: \"Free\",\n      ...u,\n      isRoot: !0,\n      size: c\n    }\n  }, g.id), g;\n}, requests = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  createLayout,\n  createProject,\n  deleteProject,\n  loadCollections,\n  loadUser\n}, Symbol.toStringTag, { value: \"Module\" }));\nclass EngineWebsocket {\n  constructor(u, c) {\n    ht(this, \"ws\", null);\n    ht(this, \"sources\", /* @__PURE__ */ new Set());\n    this.connectSource = u, this.disconnectSource = c, this.connect = this.connect.bind(this), this.handleMessage = this.handleMessage.bind(this);\n  }\n  connect() {\n    const u = this.handleMessage.bind(this);\n    this.ws = new WebSocket(\"ws://127.0.0.1:8000\"), this.ws.addEventListener(\"message\", u), this.ws.addEventListener(\"error\", (c) => {\n      console.error(\"Unable to connect to websocket\", c);\n    }), this.ws.addEventListener(\"close\", () => {\n      var c, l;\n      (c = this.ws) == null || c.removeEventListener(\"message\", u);\n      try {\n        (l = this.ws) == null || l.close(), this.ws = null;\n      } catch {\n      }\n      setTimeout(() => {\n        this.connect();\n      }, 1e3);\n    });\n  }\n  handleMessage(u) {\n    try {\n      const c = JSON.parse(u.data);\n      if (c.name === \"state\") {\n        this.sources.clear(), console.info(\"[Engine]: state\", c.payload);\n        for (const l of c.payload.sources)\n          l.connected && (this.sources.has(l.id) || (this.sources.add(l.id), this.connectSource(l.id)));\n      } else\n        c.name === \"source.disconnect\" ? (console.info(\"[Engine]: source disconnect\", c.payload.id), this.sources.delete(c.payload.id), this.disconnectSource(c.payload.id)) : c.name === \"source.connect\" && (console.info(\"[Engine]: source connect\", c.payload.id), this.sources.add(c.payload.id), this.connectSource(c.payload.id));\n    } catch (c) {\n      console.error(\"unable to handle message: \", c);\n    }\n  }\n}\nfunction setupEngineWebsocket(a, u) {\n  return new EngineWebsocket(a, u);\n}\nconst lookupDevice = (a, u) => {\n  const c = a.find((v) => v.label === u && v.kind === \"videoinput\"), l = a.find((v) => v.label === `Monitor of ${u}` && v.kind === \"audioinput\");\n  if (c && l)\n    return {\n      videoDevice: c,\n      audioDevice: l\n    };\n  if (c) {\n    if (c.label === \"Logitech BRIO (046d:085e)\") {\n      const v = a.find((S) => (\n        /*(device.groupId === videoDevice.groupId) &&*/\n        S.kind === \"audioinput\" && S.label === \"Loopback Audio 2 (Virtual)\"\n      ));\n      return {\n        videoDevice: c,\n        audioDevice: v\n      };\n    }\n    if (c.label === \"OBS Virtual Camera (m-de:vice)\") {\n      const v = a.find((S) => (\n        /*(device.groupId === videoDevice.groupId) &&*/\n        S.kind === \"audioinput\" && S.label === \"Loopback Audio (Virtual)\"\n      ));\n      return {\n        videoDevice: c,\n        audioDevice: v\n      };\n    }\n    return {\n      videoDevice: c,\n      audioDevice: null\n    };\n  }\n  return null;\n}, connectDevice = async (a) => {\n  new MediaStream([]);\n  const u = await navigator.mediaDevices.enumerateDevices(), c = lookupDevice(u, a);\n  if (c) {\n    const l = {\n      video: {\n        width: 999999,\n        height: 999999,\n        deviceId: {\n          exact: c.videoDevice.deviceId\n        }\n      }\n    };\n    c.audioDevice && (l.audio = {\n      autoGainControl: !1,\n      channelCount: 2,\n      echoCancellation: !1,\n      // @ts-ignore: https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/latency\n      latency: 0,\n      noiseSuppression: !1,\n      sampleRate: 128e3,\n      sampleSize: 16,\n      deviceId: {\n        exact: c.audioDevice.deviceId\n      }\n    });\n    const v = await navigator.mediaDevices.getUserMedia(l);\n    if (v)\n      return v;\n    console.warn(`No stream found for source ${a}.`);\n  } else\n    console.warn(`No device found for source ${a}.`);\n}, RTMP = {\n  type: \"RTMP\",\n  valueType: MediaStream,\n  props: {\n    id: {},\n    type: {},\n    videoEnabled: {},\n    audioEnabled: {}\n  },\n  init({\n    addSource: a,\n    removeSource: u,\n    updateSource: c,\n    getSource: l\n  }) {\n    let v, S = {}, g = [], E = [];\n    const _ = (k) => {\n      const L = k.filter(($) => !E.some((J) => J.id === $.id)), M = E.filter(($) => !k.some((J) => J.id === $.id));\n      E = k, L.forEach(async ($) => {\n        const J = new MediaStream([]);\n        S[$.id] = J;\n        const V = J.getVideoTracks();\n        a({\n          id: `rtmp-${$.id}`,\n          isActive: !0,\n          value: J,\n          props: {\n            id: $.id,\n            isMuted: !1,\n            participantId: $.id,\n            type: \"rtmp\",\n            videoEnabled: !!V.length,\n            audioEnabled: !0\n          }\n        });\n      }), M.forEach(($) => {\n        u(`rtmp-${$.id}`);\n      });\n    };\n    CoreContext.on(\"ActiveProjectChanged\", ({\n      projectId: k\n    }) => {\n      const L = toBaseProject(getProject(k));\n      _(L.sources), L.role === Role.ROLE_RENDERER && (v || (v = setupEngineWebsocket(async function($) {\n        const J = S[$];\n        toBaseProject(getProject(k));\n        const V = await connectDevice($);\n        if (l(`rtmp-${$}`) && V) {\n          const G = V.getAudioTracks()[0], H = V.getVideoTracks()[0];\n          updateMediaStreamTracks(J, {\n            video: H,\n            audio: G\n          }), c(`rtmp-${$}`, {\n            videoEnabled: !!H,\n            audioEnabled: !!G,\n            mirrored: !1,\n            external: !0\n          });\n        }\n      }, async function($) {\n        toBaseProject(getProject(k)).sources.find((G) => G.id === $);\n        const V = S[$];\n        (V == null ? void 0 : V.getTracks()).forEach((G) => {\n          S[$].removeTrack(G);\n        });\n      }), v.connect()));\n    }), CoreContext.on(\"RoomJoined\", ({\n      projectId: k,\n      room: L\n    }) => {\n      if (toBaseProject(getProject(k)).role !== Role.ROLE_RENDERER) {\n        const $ = () => {\n          g.filter((J) => (J == null ? void 0 : J.type) === \"screen_share\" && (J == null ? void 0 : J.isExternal) === !0).forEach((J) => {\n            var V;\n            if (J.type === \"screen_share\") {\n              const q = S[J.participantId], G = L.getParticipant(J.participantId);\n              if (E.some((H) => H.id === G.id)) {\n                const H = L.getTrack(J.id);\n                if (l(`rtmp-${G == null ? void 0 : G.id}`)) {\n                  const Y = L.getTracks().find((ne) => ne.participantId === G.id && ne.mediaStreamTrack.kind === \"audio\");\n                  updateMediaStreamTracks(q, {\n                    video: H == null ? void 0 : H.mediaStreamTrack,\n                    audio: Y == null ? void 0 : Y.mediaStreamTrack\n                  }), c(`rtmp-${G == null ? void 0 : G.id}`, {\n                    videoEnabled: !!(H != null && H.mediaStreamTrack && !H.isMuted),\n                    audioEnabled: !!(Y && !Y.isMuted),\n                    mirrored: (V = G == null ? void 0 : G.meta[J.id]) == null ? void 0 : V.isMirrored,\n                    external: J == null ? void 0 : J.isExternal\n                  });\n                }\n              }\n            }\n          });\n        };\n        L.useTracks((J) => {\n          const V = J.filter((H) => E.some((B) => B.id === H.participantId)).filter((H) => [\"screen_share\"].includes(H.type)), q = V.filter((H) => !g.some((B) => B.id === H.id) && !!(H != null && H.mediaStreamTrack)), G = g.filter((H) => !V.some((B) => B.id === H.id));\n          g = V.filter((H) => !!(H != null && H.mediaStreamTrack)), G.forEach((H) => {\n            const B = S[H.participantId];\n            H.mediaStreamTrack.kind === \"video\" && (updateMediaStreamTracks(B, {\n              video: null\n            }), c(`rtmp-${H.participantId}`, {\n              videoEnabled: !1\n            })), H.mediaStreamTrack.kind === \"audio\" && (updateMediaStreamTracks(B, {\n              audio: null\n            }), c(`rtmp-${H.participantId}`, {\n              audioEnabled: !1\n            }));\n          }), q.forEach((H) => {\n            if (H.type === \"screen_share\" && H.mediaStreamTrack.kind === \"video\") {\n              const B = S[H.participantId], Y = g.find((ne) => {\n                var Z;\n                return ne.participantId === H.participantId && ((Z = ne.mediaStreamTrack) == null ? void 0 : Z.kind) === \"audio\";\n              });\n              updateMediaStreamTracks(B, {\n                video: H == null ? void 0 : H.mediaStreamTrack,\n                audio: Y == null ? void 0 : Y.mediaStreamTrack\n              }), c(`rtmp-${H.participantId}`, {\n                videoEnabled: !!(H && !(H != null && H.isMuted)),\n                audioEnabled: !!(Y && !(Y != null && Y.isMuted))\n              });\n            }\n          }), $();\n        });\n      }\n    }), CoreContext.on(\"ProjectSourceAdded\", ({\n      source: k,\n      projectId: L\n    }) => {\n      const M = toBaseProject(getProject(L));\n      _(M == null ? void 0 : M.sources);\n    }), CoreContext.on(\"ProjectSourceRemoved\", ({\n      sourceId: k,\n      projectId: L\n    }) => {\n      const M = toBaseProject(getProject(L));\n      _(M == null ? void 0 : M.sources);\n    });\n  }\n}, Sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  Background,\n  Banner,\n  Logo,\n  Overlays,\n  RTMP,\n  RoomParticipant\n}, Symbol.toStringTag, { value: \"Module\" })), BroadcastPhase = lib$2.LiveApiModel.ProjectBroadcastPhase, {\n  trigger,\n  triggerInternal\n} = CoreContext, EventType = lib$2.LiveApiModel.EventType, EventSubType = lib$2.LiveApiModel.EventSubType, init = async (a = {}) => {\n  const u = a.env || \"prod\", c = a.logLevel || \"Warn\";\n  log$1.getLogger(\"livekit\").setLevel(c), log$1.setLevel(c), log$1.info(\"Initializing Studio SDK...\");\n  const {\n    layouts: v = [],\n    transforms: S = [],\n    sources: g = [],\n    defaultTransforms: E = {},\n    useLatestRenderer: _ = !1,\n    guestToken: k,\n    rendererVersion: L\n  } = a, M = new lib$2.ApiStream({\n    sdkVersion: CoreContext.version,\n    env: u,\n    logLevel: c\n  }), $ = config$1(), J = start({\n    dbAdapter: compositorAdapter,\n    transformSettings: {\n      defaultTransforms: {\n        ...E,\n        ...$.defaults.transforms\n      }\n    }\n  });\n  CoreContext.config = $, CoreContext.clients = M, CoreContext.compositor = J, CoreContext.logLevel = c, CoreContext.Request = await Promise.resolve().then(() => requests), CoreContext.Command = await Promise.resolve().then(() => commands$1), CoreContext.rendererVersion = _ ? \"latest-v2\" : L || CoreContext.version, window.__StudioKit = {\n    ...CoreContext\n  }, J && (J.registerSource([...Object.values(Sources), ...g]), J.registerTransform([...Object.values(Transforms), ...S]), J.registerLayout([...Object.values(Layouts), ...v]));\n  const V = await M.load(k);\n  let q;\n  V && await M.LiveApi().project.getProject({\n    ...V\n  }).then((H) => hydrateProject(H.project, V.role)).then(async (H) => {\n    setAppState({\n      // As a contributor, `user` refers to the collection\n      //  that the project belongs to. This will be referenced\n      //  when making requests requiring `collectionId`.\n      user: {\n        id: V.collectionId,\n        props: {},\n        name: null,\n        metadata: {}\n      },\n      // TODO: Populate\n      sources: [],\n      projects: [H],\n      activeProjectId: null\n    }), H.isInitial = !0, q = await CoreContext.Command.setActiveProject({\n      projectId: H.id\n    });\n  }), M.LiveApi().on(EventType.EVENT_TYPE_COLLECTION, (H, B) => {\n    switch (log$1.info(\"Received: Collection event\", B, H), B) {\n      case EventSubType.EVENT_SUB_TYPE_UPDATE: {\n        triggerInternal(\"UserChanged\", H.update.collection);\n        return;\n      }\n    }\n  }), M.LiveApi().on(EventType.EVENT_TYPE_DESTINATION, (H, B) => {\n    switch (log$1.info(\"Received: Destination event\", B, H), B) {\n      case EventSubType.EVENT_SUB_TYPE_CREATE: {\n        const {\n          destination: Y\n        } = H.create;\n        triggerInternal(\"DestinationAdded\", Y);\n        return;\n      }\n      case EventSubType.EVENT_SUB_TYPE_UPDATE: {\n        const {\n          destination: Y\n        } = H.update;\n        triggerInternal(\"DestinationChanged\", Y);\n        return;\n      }\n      case EventSubType.EVENT_SUB_TYPE_DELETE: {\n        triggerInternal(\"DestinationRemoved\", H.delete);\n        return;\n      }\n    }\n  }), M.LiveApi().on(EventType.EVENT_TYPE_SOURCE, (H, B) => {\n    switch (log$1.info(\"Received: Source event\", B, H), B) {\n      case EventSubType.EVENT_SUB_TYPE_CREATE: {\n        triggerInternal(\"SourceAdded\", H.create.source);\n        return;\n      }\n      case EventSubType.EVENT_SUB_TYPE_UPDATE: {\n        triggerInternal(\"SourceChanged\", H.update.source);\n        return;\n      }\n      case EventSubType.EVENT_SUB_TYPE_DELETE: {\n        triggerInternal(\"SourceRemoved\", H.delete.sourceId);\n        return;\n      }\n      case EventSubType.EVENT_SUB_TYPE_ADD: {\n        triggerInternal(\"ProjectSourceAdded\", {\n          projectId: H.add.projectId,\n          source: H.add.source\n        });\n        return;\n      }\n      case EventSubType.EVENT_SUB_TYPE_REMOVE: {\n        triggerInternal(\"ProjectSourceRemoved\", {\n          projectId: H.add.projectId,\n          sourceId: H.add.sourceId\n        });\n        return;\n      }\n    }\n  }), M.LiveApi().on(EventType.EVENT_TYPE_PROJECT, (H, B) => {\n    var Y;\n    switch (log$1.info(\"Received: Project event\", B, H), B) {\n      case EventSubType.EVENT_SUB_TYPE_CREATE: {\n        const ne = H.create.project;\n        if (getProject(ne.projectId))\n          return;\n        triggerInternal(\"ProjectAdded\", ne);\n        return;\n      }\n      case EventSubType.EVENT_SUB_TYPE_UPDATE: {\n        const {\n          project: ne\n        } = H.update, Z = getProject(ne.projectId);\n        if (!Z)\n          return;\n        triggerInternal(\"ProjectChanged\", {\n          project: ne,\n          phase: Z.videoApi.phase\n        });\n        return;\n      }\n      case EventSubType.EVENT_SUB_TYPE_DELETE: {\n        triggerInternal(\"ProjectRemoved\", {\n          projectId: H.delete.projectId\n        });\n        return;\n      }\n      case EventSubType.EVENT_SUB_TYPE_STATE: {\n        const ne = getProject((Y = H.state) == null ? void 0 : Y.projectId);\n        if (!ne)\n          return;\n        let Z = H.state.broadcastId;\n        if (H.state.error && trigger(\"BroadcastError\", {\n          projectId: ne.id,\n          broadcastId: H.state.broadcastId,\n          error: H.state.error\n        }), H.state.phase) {\n          const re = H.state.phase;\n          re === BroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING ? trigger(\"BroadcastStarted\", {\n            projectId: ne.id,\n            broadcastId: H.state.broadcastId\n          }) : re === BroadcastPhase.PROJECT_BROADCAST_PHASE_STOPPED && (Z = null, trigger(\"BroadcastStopped\", {\n            projectId: ne.id,\n            broadcastId: H.state.broadcastId\n          }));\n        }\n        triggerInternal(\"ProjectChanged\", {\n          project: ne.videoApi.project,\n          phase: H.state.phase,\n          broadcastId: Z\n        });\n        return;\n      }\n    }\n  }), M.LayoutApi().on(lib$2.LayoutApiModel.EventType.EVENT_TYPE_LAYER, (H, B) => {\n    var Y;\n    if (B === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_CREATE) {\n      log$1.debug(\"Received: Node Insert\", H.create);\n      const {\n        connectionId: ne,\n        layoutId: Z\n      } = H.create.requestMetadata;\n      if (CoreContext.connectionId === ne)\n        return;\n      const re = layerToNode(H.create), oe = getProjectByLayoutId(Z), de = [re, ...oe.compositor.nodes.map(toDataNode$1)], A = toSceneTree(de, re.id);\n      oe.compositor.local.insert(A), triggerInternal(\"NodeAdded\", {\n        projectId: oe.id,\n        nodeId: re.id\n      });\n    } else if (B === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_UPDATE) {\n      log$1.debug(\"Received: Node Update\", H.update);\n      const {\n        connectionId: ne,\n        layoutId: Z,\n        updateVersions: re = {}\n      } = ((Y = H.update) == null ? void 0 : Y.requestMetadata) || {};\n      if (CoreContext.connectionId === ne)\n        return;\n      const oe = layerToNode(H.update);\n      if ((latestUpdateVersion[oe.id] || 0) > re[oe.id])\n        return log$1.info(\"Ignoring node update - updateID is less than latest.\");\n      latestUpdateVersion[oe.id] = re[oe.id];\n      const A = getProjectByLayoutId(Z);\n      A.compositor.local.update(H.update.id, oe.props, oe.childIds), triggerInternal(\"NodeChanged\", {\n        projectId: A.id,\n        nodeId: oe.id\n      });\n    } else if (B === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_DELETE) {\n      log$1.debug(\"Received: Node Delete\", H.delete);\n      const {\n        connectionId: ne,\n        layoutId: Z\n      } = H.delete.requestMetadata;\n      if (CoreContext.connectionId === ne)\n        return;\n      const re = getProjectByLayoutId(Z);\n      re.compositor.local.remove(H.delete.id), triggerInternal(\"NodeRemoved\", {\n        projectId: re.id,\n        nodeId: H.delete.id\n      });\n    } else if (B === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_BATCH) {\n      log$1.debug(\"Received: Node Batch Update\", H.batch);\n      const {\n        connectionId: ne,\n        layoutId: Z,\n        updateVersions: re = {}\n      } = H.batch.requestMetadata;\n      if (CoreContext.connectionId === ne)\n        return;\n      const oe = getProjectByLayoutId(Z);\n      H.batch.layers.forEach((de) => {\n        try {\n          const [A, N] = Object.entries(de)[0];\n          if (A === \"create\") {\n            const D = layerToNode(N);\n            oe.compositor.local.insert(D), triggerInternal(\"NodeAdded\", {\n              projectId: oe.id,\n              nodeId: D.id\n            });\n          } else if (A === \"update\") {\n            const D = layerToNode(N);\n            if ((latestUpdateVersion[D.id] || 0) > re[D.id])\n              return log$1.info(\"Ignoring node update - updateID is less than latest.\");\n            latestUpdateVersion[D.id] = re[D.id], oe.compositor.local.update(D.id, D.props, D.childIds), triggerInternal(\"NodeChanged\", {\n              projectId: oe.id,\n              nodeId: D.id\n            });\n          } else\n            A === \"delete\" && (oe.compositor.local.remove(N.id), triggerInternal(\"NodeRemoved\", {\n              projectId: oe.id,\n              nodeId: N.id\n            }));\n        } catch (A) {\n          log$1.warn(\"Error handling batch item\", A, {\n            item: de\n          });\n        }\n      }), oe && triggerInternal(\"NodeChanged\", {\n        projectId: oe.id,\n        nodeId: oe.compositor.getRoot().id\n      });\n    }\n  });\n  const G = (H = {}, B) => {\n    const {\n      displayName: Y,\n      role: ne,\n      maxDuration: Z = CoreContext.config.defaults.guestTokenDuration,\n      projectId: re = CoreContext.state.activeProjectId\n    } = H, oe = getProject(re), de = Y ? {\n      direct: {\n        displayName: Y\n      }\n    } : {\n      exchange: {\n        maxDuration: Z\n      }\n    };\n    return M.LiveApi().authentication.createGuestAccessToken({\n      projectId: re,\n      token: de,\n      url: B,\n      collectionId: oe.videoApi.project.collectionId,\n      maxDuration: Z,\n      role: ne || lib$2.LiveApiModel.Role.ROLE_GUEST\n    });\n  };\n  return {\n    ...omit(CoreContext, [\"clients\", \"config\", \"connectionId\", \"Request\", \"state\", \"trigger\"]),\n    createDemoToken: async () => (console.warn(\"createDemoToken() is currently unavailable.\"), \"\"),\n    createPreviewLink: async (H = {}) => {\n      const {\n        maxDuration: B,\n        projectId: Y = CoreContext.state.activeProjectId\n      } = H, ne = getProject(Y), Z = ne.videoApi.project.composition.studioSdk.rendererUrl;\n      return (await M.LiveApi().authentication.createGuestAccessToken({\n        projectId: Y,\n        token: {\n          direct: {\n            displayName: \"Preview\"\n          }\n        },\n        url: Z,\n        collectionId: ne.videoApi.project.collectionId,\n        maxDuration: B || CoreContext.config.defaults.previewTokenDuration,\n        role: lib$2.LiveApiModel.Role.ROLE_VIEWER\n      })).url;\n    },\n    createGuestLink: async (H, B = {}) => (await G(B, H)).url,\n    createGuestToken: async (H = {}) => (await G(H)).accessToken,\n    initialProject: q,\n    load,\n    render: render$1\n  };\n}, load = async (a, u) => {\n  let c = getBaseUser();\n  if (c)\n    return log$1.info(\"Attempted to load user again - returning existing user\"), c;\n  if (!a) {\n    log$1.warn(\"Access token required for load()\");\n    return;\n  }\n  log$1.info(\"Loading user...\"), await CoreContext.clients.load(a);\n  const v = await CoreContext.Request.loadUser(u);\n  return setAppState({\n    user: v.user,\n    sources: v.sources,\n    projects: v.projects,\n    activeProjectId: null\n  }), c = getBaseUser(), trigger(\"UserLoaded\", c), c;\n};\nexport {\n  commands$1 as Command,\n  index as Compositor,\n  context as Context,\n  events$1 as Events,\n  index$1 as Helpers,\n  requests as Request,\n  index$2 as Room,\n  types$1 as SDK,\n  init\n};\n//# sourceMappingURL=index.js.map\n","/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\nimport React from 'react'\n\ntype Context = {\n  isHost: boolean\n}\n\nexport const AppContext = React.createContext<Context>({\n  isHost: false,\n})\n\nexport const AppProvider = ({\n  isHost,\n  children,\n}: {\n  isHost: boolean\n  children: React.ReactChild\n}) => {\n  return (\n    <AppContext.Provider\n      value={{\n        isHost,\n      }}\n    >\n      {children}\n    </AppContext.Provider>\n  )\n}\n","/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\nimport { Helpers, SDK } from '@api.stream/studio-kit'\nimport { useContext, useEffect, useMemo, useRef, useState } from 'react'\nimport { AppContext } from './context'\nimport Style from './shared.module.css'\n\nconst { Room } = Helpers\nconst { useStudio } = Helpers.React\n\n\nexport const Participants = ({room , projectCommands ,studio} : {room:SDK.Room ,projectCommands:Helpers.ScenelessProject.Commands ,studio:any}) => {\n\n  const { isHost } = useContext(AppContext)\n  const { project } = useStudio()\n  const [participants, setParticipants] = useState<SDK.Participant[]>([])\n\n  // Listen for room participants\n  useEffect(() => {\n    if (!room) return\n    return room.useParticipants((participants) => {\n      const sourceIds = project.sources.map((s) => s.id)\n      setParticipants(\n        participants\n          .filter((p) => sourceIds.some((id) => id === p.id))\n      )\n      // Prune non-existent guests from the project\n      if (isHost) projectCommands.pruneParticipants()\n    })\n  }, [room])\n\n\n\n\n  return (\n    <div className={Style.column}>\n      {participants.map((x) => (\n        <div key={x.id} style={{ marginBottom: 10 }}>\n          <Participant participant={x} room={room} projectCommands={projectCommands} />\n        </div>\n      ))}\n    </div>\n  )\n}\n\ntype ParticipantProps = {\n  participant: SDK.Participant\n  room?: any\n  projectCommands?: Helpers.ScenelessProject.Commands\n  studio?: any\n}\nexport const ParticipantCamera = ({\n  participant,\n  webcam,\n  microphone,\n  projectCommands,\n  room\n}: ParticipantProps & { webcam: SDK.Track; microphone: SDK.Track }) => {\n  const { isHost } = useContext(AppContext)\n  const { id, displayName } = participant\n  const ref = useRef<HTMLVideoElement>()\n  const [srcObject] = useState(new MediaStream([]))\n  const isEnabled = webcam?.mediaStreamTrack && !webcam?.isMuted\n\n  useEffect(() => {\n    // Replace the tracks on the existing MediaStream\n    Room.updateMediaStreamTracks(srcObject, {\n      video: webcam?.mediaStreamTrack,\n      audio: microphone?.mediaStreamTrack,\n    })\n  }, [webcam?.mediaStreamTrack, microphone?.mediaStreamTrack])\n\n  useEffect(() => {\n    if (ref.current) {\n      ref.current.srcObject = srcObject\n    }\n  }, [ref?.current, srcObject, isEnabled])\n\n  return (\n    <div\n      className={Style.column}\n      style={{\n        padding: 6,\n        borderRadius: 3,\n        background: '#000000cc',\n        border: '1px solid rgba(255, 255, 255, 0.2)',\n      }}\n    >\n      <div>{displayName}</div>\n      <div\n        style={{\n          height: 160,\n          width: (160 * 16) / 9,\n          position: 'relative',\n        }}\n      >\n        <div\n          // Background to show when webcam is not enabled\n          style={{\n            background: '#222',\n            height: '100%',\n            width: '100%',\n            position: 'absolute',\n            zIndex: -1,\n          }}\n        />\n        {isEnabled && (\n          <video\n            // Mute because audio is only communicated through the compositor\n            muted={true}\n            autoPlay={true}\n            ref={ref}\n            style={{\n              background: 'transparent',\n              objectFit: 'cover',\n              height: '100%',\n              width: '100%',\n            }}\n          />\n        )}\n      </div>\n      {isHost && <HostControls participant={participant} room={room} projectCommands={projectCommands} type=\"camera\" />}\n    </div>\n  )\n}\n\nexport const ParticipantScreenshare = ({\n  participant,\n  screenshare,\n}: ParticipantProps & { screenshare: SDK.Track }) => {\n  const { isHost } = useContext(AppContext)\n  const { projectCommands } = useStudio()\n  const { id, displayName } = participant\n  const ref = useRef<HTMLVideoElement>()\n  const [srcObject] = useState(new MediaStream([]))\n\n  useEffect(() => {\n    // Replace the tracks on the existing MediaStream\n    Room.updateMediaStreamTracks(srcObject, {\n      video: screenshare?.mediaStreamTrack,\n    })\n  }, [screenshare?.mediaStreamTrack])\n\n  useEffect(() => {\n    if (ref.current) {\n      ref.current.srcObject = srcObject\n    }\n  }, [ref?.current, srcObject])\n\n  return (\n    <div\n      className={Style.column}\n      style={{\n        padding: 6,\n        borderRadius: 3,\n        background: '#000000cc',\n        border: '1px solid rgba(255, 255, 255, 0.2)',\n      }}\n    >\n      <div>{displayName} (Screen)</div>\n      <div\n        style={{\n          height: 160,\n          width: (160 * 16) / 9,\n          position: 'relative',\n        }}\n      >\n        <video\n          // Mute because audio is only communicated through the compositor\n          muted={true}\n          autoPlay={true}\n          ref={ref}\n          style={{\n            background: 'transparent',\n            objectFit: 'cover',\n            height: '100%',\n            width: '100%',\n          }}\n        />\n      </div>\n      {isHost && <HostControls participant={participant} type=\"screen\" />}\n    </div>\n  )\n}\n\nexport const Participant = ({ participant , room , projectCommands}: ParticipantProps) => {\n  const [tracks, setTracks] = useState([])\n  const screenshare = tracks.find((x) => x.type === 'screen_share')\n  const webcam = tracks.find((x) => x.type === 'camera')\n  const microphone = tracks.find((x) => x.type === 'microphone')\n\n  useEffect(() => {\n    if (!room) return\n    setTracks(participant.trackIds.map(room.getTrack).filter(Boolean))\n  }, [participant?.trackIds, room])\n\n  return (\n    <>\n      <ParticipantCamera\n        projectCommands={projectCommands}\n        participant={participant}\n        webcam={webcam}\n        room={room}\n        microphone={microphone}\n      />\n      {screenshare && (\n        <div style={{ marginTop: 10 }}>\n          <ParticipantScreenshare\n            participant={participant}\n            screenshare={screenshare}\n          />\n        </div>\n      )}\n    </>\n  )\n}\n\nconst HostControls = ({\n  participant,\n  type,\n  projectCommands,\n  room\n}: ParticipantProps & { type: 'screen' | 'camera' }) => {\n  const { project } = useStudio()\n  const { id } = participant\n\n  // Get the initial props in case the participant is on stream\n  const projectParticipant = useMemo(\n    () => projectCommands?.getParticipantState(id, type),\n    [],\n  )\n\n\n  const [onStream, setOnStream] = useState(Boolean(projectParticipant))\n  const [isMuted, setIsMuted] = useState(projectParticipant?.isMuted ?? false)\n  const [volume, setVolume] = useState(projectParticipant?.volume ?? 1)\n  const [isShowcase, setIsShowcase] = useState(false)\n\n  // Monitor whether the participant has been removed from the stream\n  //  from some other means (e.g. dragged off canvas by host)\n  useEffect(() => {\n    return projectCommands?.useParticipantState(\n      id,\n      (x:any) => {\n        setOnStream(Boolean(x))\n      },\n      type,\n    )\n  }, [])\n\n  // Monitor the project's showcase to determine whether this\n  //  participant/type is active\n  useEffect(\n    () =>\n      projectCommands?.useShowcase((showcase:any) => {\n        setIsShowcase(showcase.participantId === id && showcase.type === type)\n      }),\n\n    [],\n  )\n\n  return (\n    <div\n      style={{\n        display: 'flex',\n        justifyContent: 'space-between',\n        alignItems: 'center',\n        width: '100%',\n        marginTop: 4,\n      }}\n    >\n      <div\n        style={{\n          display: 'flex',\n          flexDirection: 'column',\n        }}\n      >\n        {/* <video onCanPlayThrough={function() {\n          this.muted = true ,\n          this.play()\n        }} /> */}\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={onStream}\n            style={{ marginTop: 0, marginBottom: 0 }}\n            onChange={(e) => {\n              const checked = e.target.checked\n              if (checked) {\n                if (project.sources.some((source) => source.id === id)) {\n                  projectCommands?.addRTMPSource(id, {})\n                } else {\n                  projectCommands?.addParticipant(id, { isMuted, volume }, type)\n                }\n              } else {\n                if (project.sources.some((source) => source.id === id)) {\n                  projectCommands?.removeRTMPSource(id)\n                } else {\n                  projectCommands?.removeParticipant(id, type)\n                }\n              }\n              setOnStream(checked)\n            }}\n          />\n          On stream\n        </label>\n         <label>\n          <input\n            type=\"checkbox\"\n            checked={onStream}\n            style={{ marginTop: 0, marginBottom: 0 }}\n            onChange={(e) => {\n              const checked = e.target.checked\n              if (checked) {\n                 room.setLocalParticipantMetadata(room?.participantId , { ...participant.meta , isMirrored: true })\n              } else {\n                room.setLocalParticipantMetadata(room?.participantId , { ...participant.meta , isMirrored: false })\n              }\n              setOnStream(checked)\n            }}\n          />\n          On Mirror\n        </label>\n\n        <label style={{ opacity: onStream ? 1 : 0.5 }}>\n          <input\n            type=\"checkbox\"\n            style={{ marginTop: 0, marginBottom: 0 }}\n            disabled={!onStream}\n            checked={isShowcase}\n            onChange={() => {\n              if (isShowcase) {\n                projectCommands?.setShowcase(null)\n              } else {\n                projectCommands?.setShowcase(id, type)\n              }\n            }}\n          />\n          Showcase\n        </label>\n      </div>\n      <span>\n        {type === 'camera' && (\n          <>\n            <input\n              type=\"range\"\n              min={0}\n              max={1}\n              step={0.01}\n              value={volume}\n              style={{ opacity: isMuted ? 0.4 : 1 }}\n              onChange={(e) => {\n                const value = Number(e.target.value)\n                projectCommands?.setParticipantVolume(id, value)\n                setVolume(value)\n\n                // Unmute when user changes the volume slider\n                if (isMuted) {\n                  projectCommands?.setParticipantMuted(id, false)\n                  setIsMuted(false)\n                }\n              }}\n            />\n            <input\n              type=\"checkbox\"\n              // Invert because \"checked\" means \"enabled\" (not muted) in this case\n              checked={!isMuted}\n              onChange={(e) => {\n                const checked = e.target.checked\n                projectCommands?.setParticipantMuted(id, !checked)\n                setIsMuted(!checked)\n              }}\n            />\n          </>\n        )}\n      </span>\n    </div>\n  )\n}\n","/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\nimport { useEffect, useState } from 'react'\nimport { Helpers, SDK } from '@api.stream/studio-kit'\nimport Style from '../shared/shared.module.css'\n\nconst { useStudio, useDevices } = Helpers.React\n\nexport const DeviceSelection = () => {\n  const { webcamId, microphoneId, setWebcamId, setMicrophoneId } = useStudio()\n  const devices = useDevices()\n\n  useEffect(() => {\n    if (!webcamId) setWebcamId(devices.webcams[0]?.deviceId)\n  }, [webcamId, devices])\n\n  useEffect(() => {\n    if (!microphoneId) setMicrophoneId(devices.microphones[0]?.deviceId)\n  }, [microphoneId, devices])\n\n  return (\n    <div>\n      <div className={Style.column}>\n        <label>Webcam</label>\n        <select\n          value={webcamId}\n          onChange={(e) => {\n            setWebcamId(e.target.value)\n          }}\n        >\n          {devices.webcams.map((x) => (\n            <option key={x.deviceId} value={x.deviceId}>\n              {x.label}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div className={Style.column}>\n        <label>Microphone</label>\n        <select\n          value={microphoneId}\n          onChange={(e) => {\n            setMicrophoneId(e.target.value)\n          }}\n        >\n          {devices.microphones.map((x) => (\n            <option key={x.deviceId} value={x.deviceId}>\n              {x.label}\n            </option>\n          ))}\n        </select>\n      </div>\n    </div>\n  )\n}\n\nexport const ControlPanel = ({\n  room,\n  projectCommands,\n}: {\n  room: any\n  projectCommands: any\n}) => {\n  const [isSharingScreen, setIsSharingScreen] = useState(false)\n  const [participant, setParticipant] = useState<SDK.Participant>()\n\n  // Listen for room participants\n  useEffect(() => {\n    if (!room) return\n    return room.useParticipant(room.participantId, setParticipant)\n  }, [room])\n\n  useEffect(() => {\n    if (!participant) return\n    const screenshare = participant.trackIds.find(\n      (x) => room.getTrack(x)?.type === 'screen_share',\n    )\n    if (!screenshare) {\n      projectCommands.removeParticipant(room.participantId, 'screen')\n    }\n    setIsSharingScreen(Boolean(screenshare))\n  }, [participant?.trackIds])\n\n  return (\n    <div>\n      <label>\n        <input\n          type=\"checkbox\"\n          onChange={async (e) => {\n            const track = await room.addCamera({\n              deviceId:\n                '7360456cb5f177a56d708c3dc4981b540ecc5197ec79fb67ee5e573bf434a760',\n            })\n            setTimeout(() => {\n              projectCommands.addParticipantTrack(track.id, {}, 'camera')\n            }, 5000)\n          }}\n        />\n        Add Additional Camera\n      </label>\n      <label>\n        <input\n          type=\"checkbox\"\n          onChange={(e) => {\n            const muted = e.target.checked\n            room.setMicrophoneEnabled(!muted)\n          }}\n        />\n        Mute microphone\n      </label>\n      <label>\n        <input\n          type=\"checkbox\"\n          onChange={(e) => {\n            const hidden = e.target.checked\n            room.setCameraEnabled(!hidden)\n          }}\n        />\n        Hide webcam\n      </label>\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={isSharingScreen}\n          onChange={(e) => {\n            const enabled = e.target.checked\n            if (enabled) {\n              room.addScreen()\n            } else {\n              room\n                .getParticipant(room.participantId)\n                .trackIds.forEach((x: any) => {\n                  if (room.getTrack(x).type === 'screen_share') {\n                    room.removeTrack(x)\n                  }\n                })\n            }\n          }}\n        />\n        Screenshare\n      </label>\n    </div>\n  )\n}\n","/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\nimport { useContext, useEffect, useRef, useState } from 'react'\nimport { Helpers, SDK } from '@api.stream/studio-kit'\nimport Style from './chat.module.css'\n\nconst { StudioContext } = Helpers.React\n\nconst displayTimeComponent = (component: number) =>\n  component < 10 ? `0${component}` : String(component)\n\nconst displayTime = (time: Date) =>\n  `${time.getHours()}:${displayTimeComponent(\n    time.getMinutes(),\n  )}:${displayTimeComponent(time.getSeconds())}`\n\nconst ChatMessage = ({ message }: { message: SDK.ChatObject }) => {\n  const sent = new Date(message.timestamp)\n  return (\n    <div className={Style.chatItem}>\n      <div className={Style.chatTop}>\n        <span className={Style.chatUsernameCell}>{message.displayName}</span>\n        <span className={Style.chatTimeCell}>{displayTime(sent)}</span>\n      </div>\n      <div className={Style.chatMessageContent}>{message.content}</div>\n    </div>\n  )\n}\n\nexport const Chat = () => {\n  const { room } = useContext(StudioContext)\n  const [chatHistory, setChatHistory] = useState<SDK.ChatObject[]>([])\n  const [draft, setDraft] = useState('')\n\n  const scrollbox = useRef<HTMLDivElement>(null)\n\n  const onSendMessage = () => {\n    if (!draft.trim()) {\n      return\n    }\n    room.sendChatMessage({\n      message: draft.trim(),\n    })\n    setDraft('')\n  }\n\n  useEffect(() => {\n    if (!room) return\n    return room.useChatHistory((history) => {\n      const scrollY =\n        scrollbox.current.scrollHeight - scrollbox.current.clientHeight\n      setChatHistory(history)\n      if (scrollbox.current.scrollTop === scrollY) {\n        scrollbox.current.scrollTo({\n          top: scrollbox.current.scrollHeight - scrollbox.current.clientHeight,\n        })\n      }\n    })\n  }, [room])\n\n  return (\n    <div className={Style.chatbox}>\n      <div ref={scrollbox} className={Style.scrollbox}>\n        {chatHistory.length === 0 && (\n          <div className={Style.emptyMessage}>\n            Private chat between host and guests.\n          </div>\n        )}\n        {chatHistory.map((chat, i) => {\n          return <ChatMessage key={i} message={chat} />\n        })}\n      </div>\n      <textarea\n        placeholder=\"Write a message...\"\n        className={Style.textarea}\n        value={draft}\n        onChange={(e) => {\n          setDraft(e.target.value)\n        }}\n      />\n      <button onClick={onSendMessage}>Send Message</button>\n    </div>\n  )\n}\n","/* ---------------------------------------------------------------------------------------------\n * Copyright (c) Infiniscene, Inc. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * -------------------------------------------------------------------------------------------- */\ntype Config = {\n  env: 'stage' | 'prod'\n  logLevel: 'Debug' | 'Info' | 'Warn' | 'Error'\n  recaptchaKey: string\n}\n\nconst LOCAL_ENV: Config['env'] = 'stage'\n\nexport default {\n  env: location.hostname === 'live.api.stream' ? 'prod' : LOCAL_ENV,\n  logLevel: 'Debug',\n  recaptchaKey: '6Lc0HIUfAAAAAIdsyq7vB_3c3skiVvltzdUTCUSx',\n} as Config\n","export default \"__VITE_ASSET__DacSPZ0B__\""],"names":["hasOwnProperty","i","n","from","s","require$$0","p","q","r","t","w","y","a","B","D","E","F","G","H","I","e","d","h","g","f","m","M","N","O","P","b","R","S","T","reactModule","l","exports","u","x","z","A","C","J","K","v","L","Q","U","V","W","schedulerModule","require$$1","require$$2","k","of","c","ok","reactDomModule","jsxRuntimeModule","jsxRuntime.jsx","jsxRuntime.jsxs","jsxRuntime.Fragment","AppContext","React","createContext","isHost","AppProvider","children","_jsx","Provider","value","Room","Helpers","useStudio","Participants","room","projectCommands","studio","useContext","project","participants","setParticipants","useState","useEffect","useParticipants","sourceIds","sources","map","id","filter","some","pruneParticipants","className","Style","column","style","marginBottom","Participant","participant","ParticipantCamera","webcam","microphone","displayName","ref","useRef","srcObject","MediaStream","isEnabled","mediaStreamTrack","isMuted","updateMediaStreamTracks","video","audio","current","padding","borderRadius","background","border","_jsxs","height","width","position","zIndex","muted","autoPlay","objectFit","HostControls","type","ParticipantScreenshare","screenshare","tracks","setTracks","find","trackIds","getTrack","Boolean","_Fragment","marginTop","projectParticipant","useMemo","getParticipantState","onStream","setOnStream","setIsMuted","volume","setVolume","isShowcase","setIsShowcase","useParticipantState","useShowcase","showcase","participantId","display","justifyContent","alignItems","flexDirection","checked","onChange","target","source","addRTMPSource","addParticipant","removeRTMPSource","removeParticipant","setLocalParticipantMetadata","meta","isMirrored","opacity","disabled","setShowcase","min","max","step","Number","setParticipantVolume","setParticipantMuted","useDevices","DeviceSelection","webcamId","microphoneId","setWebcamId","setMicrophoneId","devices","webcams","deviceId","microphones","label","ControlPanel","isSharingScreen","setIsSharingScreen","setParticipant","useParticipant","track","addCamera","setTimeout","addParticipantTrack","setMicrophoneEnabled","hidden","setCameraEnabled","enabled","addScreen","getParticipant","forEach","removeTrack","StudioContext","displayTimeComponent","component","String","displayTime","time","getHours","getMinutes","getSeconds","ChatMessage","message","sent","Date","timestamp","chatItem","chatTop","chatUsernameCell","chatTimeCell","chatMessageContent","content","Chat","chatHistory","setChatHistory","draft","setDraft","scrollbox","onSendMessage","trim","sendChatMessage","useChatHistory","history","scrollY","scrollHeight","clientHeight","scrollTop","scrollTo","top","chatbox","length","emptyMessage","chat","placeholder","textarea","onClick","LOCAL_ENV","env","location","hostname","logLevel","recaptchaKey"],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8]}