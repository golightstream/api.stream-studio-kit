const p$2 = function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
};
p$2();
var reactDom = { exports: {} };
var reactDom_production_min = {};
var react$1 = { exports: {} };
var react_production_min = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$e = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i2 = 0; i2 < 10; i2++) {
      test2["_" + String.fromCharCode(i2)] = i2;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source2) {
  var from3;
  var to = toObject(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from3 = Object(arguments[s]);
    for (var key in from3) {
      if (hasOwnProperty$e.call(from3, key)) {
        to[key] = from3[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from3);
      for (var i2 = 0; i2 < symbols.length; i2++) {
        if (propIsEnumerable.call(from3, symbols[i2])) {
          to[symbols[i2]] = from3[symbols[i2]];
        }
      }
    }
  }
  return to;
};
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l = objectAssign, n$2 = 60103, p$1 = 60106;
react_production_min.Fragment = 60107;
react_production_min.StrictMode = 60108;
react_production_min.Profiler = 60114;
var q$1 = 60109, r$3 = 60110, t$1 = 60112;
react_production_min.Suspense = 60113;
var u = 60115, v = 60116;
if ("function" === typeof Symbol && Symbol.for) {
  var w = Symbol.for;
  n$2 = w("react.element");
  p$1 = w("react.portal");
  react_production_min.Fragment = w("react.fragment");
  react_production_min.StrictMode = w("react.strict_mode");
  react_production_min.Profiler = w("react.profiler");
  q$1 = w("react.provider");
  r$3 = w("react.context");
  t$1 = w("react.forward_ref");
  react_production_min.Suspense = w("react.suspense");
  u = w("react.memo");
  v = w("react.lazy");
}
var x = "function" === typeof Symbol && Symbol.iterator;
function y$1(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = x && a[x] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
function z(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var A = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, B$1 = {};
function C(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B$1;
  this.updater = c || A;
}
C.prototype.isReactComponent = {};
C.prototype.setState = function(a, b) {
  if ("object" !== typeof a && "function" !== typeof a && null != a)
    throw Error(z(85));
  this.updater.enqueueSetState(this, a, b, "setState");
};
C.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function D$1() {
}
D$1.prototype = C.prototype;
function E$1(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B$1;
  this.updater = c || A;
}
var F$1 = E$1.prototype = new D$1();
F$1.constructor = E$1;
l(F$1, C.prototype);
F$1.isPureReactComponent = true;
var G$1 = { current: null }, H$1 = Object.prototype.hasOwnProperty, I$1 = { key: true, ref: true, __self: true, __source: true };
function J(a, b, c) {
  var e2, d = {}, k = null, h2 = null;
  if (null != b)
    for (e2 in void 0 !== b.ref && (h2 = b.ref), void 0 !== b.key && (k = "" + b.key), b)
      H$1.call(b, e2) && !I$1.hasOwnProperty(e2) && (d[e2] = b[e2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    d.children = c;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    d.children = f2;
  }
  if (a && a.defaultProps)
    for (e2 in g2 = a.defaultProps, g2)
      void 0 === d[e2] && (d[e2] = g2[e2]);
  return { $$typeof: n$2, type: a, key: k, ref: h2, props: d, _owner: G$1.current };
}
function K(a, b) {
  return { $$typeof: n$2, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
}
function L(a) {
  return "object" === typeof a && null !== a && a.$$typeof === n$2;
}
function escape(a) {
  var b = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b[a2];
  });
}
var M$1 = /\/+/g;
function N$1(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}
function O$1(a, b, c, e2, d) {
  var k = typeof a;
  if ("undefined" === k || "boolean" === k)
    a = null;
  var h2 = false;
  if (null === a)
    h2 = true;
  else
    switch (k) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case n$2:
          case p$1:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a, d = d(h2), a = "" === e2 ? "." + N$1(h2, 0) : e2, Array.isArray(d) ? (c = "", null != a && (c = a.replace(M$1, "$&/") + "/"), O$1(d, b, c, "", function(a2) {
      return a2;
    })) : null != d && (L(d) && (d = K(d, c + (!d.key || h2 && h2.key === d.key ? "" : ("" + d.key).replace(M$1, "$&/") + "/") + a)), b.push(d)), 1;
  h2 = 0;
  e2 = "" === e2 ? "." : e2 + ":";
  if (Array.isArray(a))
    for (var g2 = 0; g2 < a.length; g2++) {
      k = a[g2];
      var f2 = e2 + N$1(k, g2);
      h2 += O$1(k, b, c, f2, d);
    }
  else if (f2 = y$1(a), "function" === typeof f2)
    for (a = f2.call(a), g2 = 0; !(k = a.next()).done; )
      k = k.value, f2 = e2 + N$1(k, g2++), h2 += O$1(k, b, c, f2, d);
  else if ("object" === k)
    throw b = "" + a, Error(z(31, "[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
  return h2;
}
function P$1(a, b, c) {
  if (null == a)
    return a;
  var e2 = [], d = 0;
  O$1(a, e2, "", "", function(a2) {
    return b.call(c, a2, d++);
  });
  return e2;
}
function Q(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    a._status = 0;
    a._result = b;
    b.then(function(b2) {
      0 === a._status && (b2 = b2.default, a._status = 1, a._result = b2);
    }, function(b2) {
      0 === a._status && (a._status = 2, a._result = b2);
    });
  }
  if (1 === a._status)
    return a._result;
  throw a._result;
}
var R$2 = { current: null };
function S$1() {
  var a = R$2.current;
  if (null === a)
    throw Error(z(321));
  return a;
}
var T$1 = { ReactCurrentDispatcher: R$2, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G$1, IsSomeRendererActing: { current: false }, assign: l };
react_production_min.Children = { map: P$1, forEach: function(a, b, c) {
  P$1(a, function() {
    b.apply(this, arguments);
  }, c);
}, count: function(a) {
  var b = 0;
  P$1(a, function() {
    b++;
  });
  return b;
}, toArray: function(a) {
  return P$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!L(a))
    throw Error(z(143));
  return a;
} };
react_production_min.Component = C;
react_production_min.PureComponent = E$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T$1;
react_production_min.cloneElement = function(a, b, c) {
  if (null === a || void 0 === a)
    throw Error(z(267, a));
  var e2 = l({}, a.props), d = a.key, k = a.ref, h2 = a._owner;
  if (null != b) {
    void 0 !== b.ref && (k = b.ref, h2 = G$1.current);
    void 0 !== b.key && (d = "" + b.key);
    if (a.type && a.type.defaultProps)
      var g2 = a.type.defaultProps;
    for (f2 in b)
      H$1.call(b, f2) && !I$1.hasOwnProperty(f2) && (e2[f2] = void 0 === b[f2] && void 0 !== g2 ? g2[f2] : b[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    e2.children = c;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    e2.children = g2;
  }
  return {
    $$typeof: n$2,
    type: a.type,
    key: d,
    ref: k,
    props: e2,
    _owner: h2
  };
};
react_production_min.createContext = function(a, b) {
  void 0 === b && (b = null);
  a = { $$typeof: r$3, _calculateChangedBits: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null };
  a.Provider = { $$typeof: q$1, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = J;
react_production_min.createFactory = function(a) {
  var b = J.bind(null, a);
  b.type = a;
  return b;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: t$1, render: a };
};
react_production_min.isValidElement = L;
react_production_min.lazy = function(a) {
  return { $$typeof: v, _payload: { _status: -1, _result: a }, _init: Q };
};
react_production_min.memo = function(a, b) {
  return { $$typeof: u, type: a, compare: void 0 === b ? null : b };
};
react_production_min.useCallback = function(a, b) {
  return S$1().useCallback(a, b);
};
react_production_min.useContext = function(a, b) {
  return S$1().useContext(a, b);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useEffect = function(a, b) {
  return S$1().useEffect(a, b);
};
react_production_min.useImperativeHandle = function(a, b, c) {
  return S$1().useImperativeHandle(a, b, c);
};
react_production_min.useLayoutEffect = function(a, b) {
  return S$1().useLayoutEffect(a, b);
};
react_production_min.useMemo = function(a, b) {
  return S$1().useMemo(a, b);
};
react_production_min.useReducer = function(a, b, c) {
  return S$1().useReducer(a, b, c);
};
react_production_min.useRef = function(a) {
  return S$1().useRef(a);
};
react_production_min.useState = function(a) {
  return S$1().useState(a);
};
react_production_min.version = "17.0.2";
{
  react$1.exports = react_production_min;
}
var React = react$1.exports;
var scheduler = { exports: {} };
var scheduler_production_min = {};
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports2) {
  var f2, g2, h2, k;
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports2.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports2.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
    var t2 = null, u2 = null, w2 = function() {
      if (null !== t2)
        try {
          var a = exports2.unstable_now();
          t2(true, a);
          t2 = null;
        } catch (b) {
          throw setTimeout(w2, 0), b;
        }
    };
    f2 = function(a) {
      null !== t2 ? setTimeout(f2, 0, a) : (t2 = a, setTimeout(w2, 0));
    };
    g2 = function(a, b) {
      u2 = setTimeout(a, b);
    };
    h2 = function() {
      clearTimeout(u2);
    };
    exports2.unstable_shouldYield = function() {
      return false;
    };
    k = exports2.unstable_forceFrameRate = function() {
    };
  } else {
    var x2 = window.setTimeout, y2 = window.clearTimeout;
    if ("undefined" !== typeof console) {
      var z2 = window.cancelAnimationFrame;
      "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      "function" !== typeof z2 && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }
    var A2 = false, B2 = null, C2 = -1, D2 = 5, E2 = 0;
    exports2.unstable_shouldYield = function() {
      return exports2.unstable_now() >= E2;
    };
    k = function() {
    };
    exports2.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    var F2 = new MessageChannel(), G2 = F2.port2;
    F2.port1.onmessage = function() {
      if (null !== B2) {
        var a = exports2.unstable_now();
        E2 = a + D2;
        try {
          B2(true, a) ? G2.postMessage(null) : (A2 = false, B2 = null);
        } catch (b) {
          throw G2.postMessage(null), b;
        }
      } else
        A2 = false;
    };
    f2 = function(a) {
      B2 = a;
      A2 || (A2 = true, G2.postMessage(null));
    };
    g2 = function(a, b) {
      C2 = x2(function() {
        a(exports2.unstable_now());
      }, b);
    };
    h2 = function() {
      y2(C2);
      C2 = -1;
    };
  }
  function H2(a, b) {
    var c = a.length;
    a.push(b);
    a:
      for (; ; ) {
        var d = c - 1 >>> 1, e2 = a[d];
        if (void 0 !== e2 && 0 < I2(e2, b))
          a[d] = b, a[c] = e2, c = d;
        else
          break a;
      }
  }
  function J2(a) {
    a = a[0];
    return void 0 === a ? null : a;
  }
  function K2(a) {
    var b = a[0];
    if (void 0 !== b) {
      var c = a.pop();
      if (c !== b) {
        a[0] = c;
        a:
          for (var d = 0, e2 = a.length; d < e2; ) {
            var m2 = 2 * (d + 1) - 1, n2 = a[m2], v2 = m2 + 1, r2 = a[v2];
            if (void 0 !== n2 && 0 > I2(n2, c))
              void 0 !== r2 && 0 > I2(r2, n2) ? (a[d] = r2, a[v2] = c, d = v2) : (a[d] = n2, a[m2] = c, d = m2);
            else if (void 0 !== r2 && 0 > I2(r2, c))
              a[d] = r2, a[v2] = c, d = v2;
            else
              break a;
          }
      }
      return b;
    }
    return null;
  }
  function I2(a, b) {
    var c = a.sortIndex - b.sortIndex;
    return 0 !== c ? c : a.id - b.id;
  }
  var L2 = [], M2 = [], N2 = 1, O2 = null, P2 = 3, Q2 = false, R2 = false, S2 = false;
  function T2(a) {
    for (var b = J2(M2); null !== b; ) {
      if (null === b.callback)
        K2(M2);
      else if (b.startTime <= a)
        K2(M2), b.sortIndex = b.expirationTime, H2(L2, b);
      else
        break;
      b = J2(M2);
    }
  }
  function U2(a) {
    S2 = false;
    T2(a);
    if (!R2)
      if (null !== J2(L2))
        R2 = true, f2(V2);
      else {
        var b = J2(M2);
        null !== b && g2(U2, b.startTime - a);
      }
  }
  function V2(a, b) {
    R2 = false;
    S2 && (S2 = false, h2());
    Q2 = true;
    var c = P2;
    try {
      T2(b);
      for (O2 = J2(L2); null !== O2 && (!(O2.expirationTime > b) || a && !exports2.unstable_shouldYield()); ) {
        var d = O2.callback;
        if ("function" === typeof d) {
          O2.callback = null;
          P2 = O2.priorityLevel;
          var e2 = d(O2.expirationTime <= b);
          b = exports2.unstable_now();
          "function" === typeof e2 ? O2.callback = e2 : O2 === J2(L2) && K2(L2);
          T2(b);
        } else
          K2(L2);
        O2 = J2(L2);
      }
      if (null !== O2)
        var m2 = true;
      else {
        var n2 = J2(M2);
        null !== n2 && g2(U2, n2.startTime - b);
        m2 = false;
      }
      return m2;
    } finally {
      O2 = null, P2 = c, Q2 = false;
    }
  }
  var W2 = k;
  exports2.unstable_IdlePriority = 5;
  exports2.unstable_ImmediatePriority = 1;
  exports2.unstable_LowPriority = 4;
  exports2.unstable_NormalPriority = 3;
  exports2.unstable_Profiling = null;
  exports2.unstable_UserBlockingPriority = 2;
  exports2.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports2.unstable_continueExecution = function() {
    R2 || Q2 || (R2 = true, f2(V2));
  };
  exports2.unstable_getCurrentPriorityLevel = function() {
    return P2;
  };
  exports2.unstable_getFirstCallbackNode = function() {
    return J2(L2);
  };
  exports2.unstable_next = function(a) {
    switch (P2) {
      case 1:
      case 2:
      case 3:
        var b = 3;
        break;
      default:
        b = P2;
    }
    var c = P2;
    P2 = b;
    try {
      return a();
    } finally {
      P2 = c;
    }
  };
  exports2.unstable_pauseExecution = function() {
  };
  exports2.unstable_requestPaint = W2;
  exports2.unstable_runWithPriority = function(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c = P2;
    P2 = a;
    try {
      return b();
    } finally {
      P2 = c;
    }
  };
  exports2.unstable_scheduleCallback = function(a, b, c) {
    var d = exports2.unstable_now();
    "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
    switch (a) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c + e2;
    a = { id: N2++, callback: b, priorityLevel: a, startTime: c, expirationTime: e2, sortIndex: -1 };
    c > d ? (a.sortIndex = c, H2(M2, a), null === J2(L2) && a === J2(M2) && (S2 ? h2() : S2 = true, g2(U2, c - d))) : (a.sortIndex = e2, H2(L2, a), R2 || Q2 || (R2 = true, f2(V2)));
    return a;
  };
  exports2.unstable_wrapCallback = function(a) {
    var b = P2;
    return function() {
      var c = P2;
      P2 = b;
      try {
        return a.apply(this, arguments);
      } finally {
        P2 = c;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = react$1.exports, m$1 = objectAssign, r$2 = scheduler.exports;
function y(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
if (!aa)
  throw Error(y(227));
var ba = /* @__PURE__ */ new Set(), ca = {};
function da(a, b) {
  ea(a, b);
  ea(a + "Capture", b);
}
function ea(a, b) {
  ca[a] = b;
  for (a = 0; a < b.length; a++)
    ba.add(b[a]);
}
var fa = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia = Object.prototype.hasOwnProperty, ja = {}, ka = {};
function la(a) {
  if (ia.call(ka, a))
    return true;
  if (ia.call(ja, a))
    return false;
  if (ha.test(a))
    return ka[a] = true;
  ja[a] = true;
  return false;
}
function ma(a, b, c, d) {
  if (null !== c && 0 === c.type)
    return false;
  switch (typeof b) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d)
        return false;
      if (null !== c)
        return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function na(a, b, c, d) {
  if (null === b || "undefined" === typeof b || ma(a, b, c, d))
    return true;
  if (d)
    return false;
  if (null !== c)
    switch (c.type) {
      case 3:
        return !b;
      case 4:
        return false === b;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
  return false;
}
function B(a, b, c, d, e2, f2, g2) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
  this.attributeName = d;
  this.attributeNamespace = e2;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var D = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  D[a] = new B(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b = a[0];
  D[b] = new B(b, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  D[a] = new B(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  D[a] = new B(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  D[a] = new B(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  D[a] = new B(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  D[a] = new B(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  D[a] = new B(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  D[a] = new B(a, 5, false, a.toLowerCase(), null, false, false);
});
var oa = /[\-:]([a-z])/g;
function pa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b = a.replace(oa, pa);
  D[b] = new B(b, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b = a.replace(oa, pa);
  D[b] = new B(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b = a.replace(oa, pa);
  D[b] = new B(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  D[a] = new B(a, 1, false, a.toLowerCase(), null, false, false);
});
D.xlinkHref = new B("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  D[a] = new B(a, 1, false, a.toLowerCase(), null, true, true);
});
function qa(a, b, c, d) {
  var e2 = D.hasOwnProperty(b) ? D[b] : null;
  var f2 = null !== e2 ? 0 === e2.type : d ? false : !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1] ? false : true;
  f2 || (na(b, c, e2, d) && (c = null), d || null === e2 ? la(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e2.mustUseProperty ? a[e2.propertyName] = null === c ? 3 === e2.type ? false : "" : c : (b = e2.attributeName, d = e2.attributeNamespace, null === c ? a.removeAttribute(b) : (e2 = e2.type, c = 3 === e2 || 4 === e2 && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
}
var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, sa = 60103, ta = 60106, ua = 60107, wa = 60108, xa = 60114, ya = 60109, za = 60110, Aa = 60112, Ba = 60113, Ca = 60120, Da = 60115, Ea = 60116, Fa = 60121, Ga = 60128, Ha = 60129, Ia = 60130, Ja = 60131;
if ("function" === typeof Symbol && Symbol.for) {
  var E = Symbol.for;
  sa = E("react.element");
  ta = E("react.portal");
  ua = E("react.fragment");
  wa = E("react.strict_mode");
  xa = E("react.profiler");
  ya = E("react.provider");
  za = E("react.context");
  Aa = E("react.forward_ref");
  Ba = E("react.suspense");
  Ca = E("react.suspense_list");
  Da = E("react.memo");
  Ea = E("react.lazy");
  Fa = E("react.block");
  E("react.scope");
  Ga = E("react.opaque.id");
  Ha = E("react.debug_trace_mode");
  Ia = E("react.offscreen");
  Ja = E("react.legacy_hidden");
}
var Ka = "function" === typeof Symbol && Symbol.iterator;
function La(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = Ka && a[Ka] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var Ma;
function Na(a) {
  if (void 0 === Ma)
    try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      Ma = b && b[1] || "";
    }
  return "\n" + Ma + a;
}
var Oa = false;
function Pa(a, b) {
  if (!a || Oa)
    return "";
  Oa = true;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b)
      if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (k) {
          var d = k;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (k) {
          d = k;
        }
        a.call(b.prototype);
      }
    else {
      try {
        throw Error();
      } catch (k) {
        d = k;
      }
      a();
    }
  } catch (k) {
    if (k && d && "string" === typeof k.stack) {
      for (var e2 = k.stack.split("\n"), f2 = d.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2])
                return "\n" + e2[g2].replace(" at new ", " at ");
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Oa = false, Error.prepareStackTrace = c;
  }
  return (a = a ? a.displayName || a.name : "") ? Na(a) : "";
}
function Qa(a) {
  switch (a.tag) {
    case 5:
      return Na(a.type);
    case 16:
      return Na("Lazy");
    case 13:
      return Na("Suspense");
    case 19:
      return Na("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Pa(a.type, false), a;
    case 11:
      return a = Pa(a.type.render, false), a;
    case 22:
      return a = Pa(a.type._render, false), a;
    case 1:
      return a = Pa(a.type, true), a;
    default:
      return "";
  }
}
function Ra(a) {
  if (null == a)
    return null;
  if ("function" === typeof a)
    return a.displayName || a.name || null;
  if ("string" === typeof a)
    return a;
  switch (a) {
    case ua:
      return "Fragment";
    case ta:
      return "Portal";
    case xa:
      return "Profiler";
    case wa:
      return "StrictMode";
    case Ba:
      return "Suspense";
    case Ca:
      return "SuspenseList";
  }
  if ("object" === typeof a)
    switch (a.$$typeof) {
      case za:
        return (a.displayName || "Context") + ".Consumer";
      case ya:
        return (a._context.displayName || "Context") + ".Provider";
      case Aa:
        var b = a.render;
        b = b.displayName || b.name || "";
        return a.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");
      case Da:
        return Ra(a.type);
      case Fa:
        return Ra(a._render);
      case Ea:
        b = a._payload;
        a = a._init;
        try {
          return Ra(a(b));
        } catch (c) {
        }
    }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "object":
    case "string":
    case "undefined":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function Ua(a) {
  var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
  if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
    var e2 = c.get, f2 = c.set;
    Object.defineProperty(a, b, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a2) {
      d = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b, { enumerable: c.enumerable });
    return { getValue: function() {
      return d;
    }, setValue: function(a2) {
      d = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a)
    return false;
  var b = a._valueTracker;
  if (!b)
    return true;
  var c = b.getValue();
  var d = "";
  a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b.setValue(a), true) : false;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a)
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}
function Ya(a, b) {
  var c = b.checked;
  return m$1({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
}
function Za(a, b) {
  var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
  c = Sa(null != b.value ? b.value : c);
  a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
}
function $a(a, b) {
  b = b.checked;
  null != b && qa(a, "checked", b, false);
}
function ab(a, b) {
  $a(a, b);
  var c = Sa(b.value), d = b.type;
  if (null != c)
    if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c)
        a.value = "" + c;
    } else
      a.value !== "" + c && (a.value = "" + c);
  else if ("submit" === d || "reset" === d) {
    a.removeAttribute("value");
    return;
  }
  b.hasOwnProperty("value") ? bb(a, b.type, c) : b.hasOwnProperty("defaultValue") && bb(a, b.type, Sa(b.defaultValue));
  null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function cb(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d = b.type;
    if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value))
      return;
    b = "" + a._wrapperState.initialValue;
    c || b === a.value || (a.value = b);
    a.defaultValue = b;
  }
  c = a.name;
  "" !== c && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c && (a.name = c);
}
function bb(a, b, c) {
  if ("number" !== b || Xa(a.ownerDocument) !== a)
    null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}
function db(a) {
  var b = "";
  aa.Children.forEach(a, function(a2) {
    null != a2 && (b += a2);
  });
  return b;
}
function eb(a, b) {
  a = m$1({ children: void 0 }, b);
  if (b = db(b.children))
    a.children = b;
  return a;
}
function fb(a, b, c, d) {
  a = a.options;
  if (b) {
    b = {};
    for (var e2 = 0; e2 < c.length; e2++)
      b["$" + c[e2]] = true;
    for (c = 0; c < a.length; c++)
      e2 = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e2 && (a[c].selected = e2), e2 && d && (a[c].defaultSelected = true);
  } else {
    c = "" + Sa(c);
    b = null;
    for (e2 = 0; e2 < a.length; e2++) {
      if (a[e2].value === c) {
        a[e2].selected = true;
        d && (a[e2].defaultSelected = true);
        return;
      }
      null !== b || a[e2].disabled || (b = a[e2]);
    }
    null !== b && (b.selected = true);
  }
}
function gb(a, b) {
  if (null != b.dangerouslySetInnerHTML)
    throw Error(y(91));
  return m$1({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b) {
  var c = b.value;
  if (null == c) {
    c = b.children;
    b = b.defaultValue;
    if (null != c) {
      if (null != b)
        throw Error(y(92));
      if (Array.isArray(c)) {
        if (!(1 >= c.length))
          throw Error(y(93));
        c = c[0];
      }
      b = c;
    }
    null == b && (b = "");
    c = b;
  }
  a._wrapperState = { initialValue: Sa(c) };
}
function ib(a, b) {
  var c = Sa(b.value), d = Sa(b.defaultValue);
  null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
  null != d && (a.defaultValue = "" + d);
}
function jb(a) {
  var b = a.textContent;
  b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
}
var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function lb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function mb(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? lb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var nb, ob = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b, c, d, e2);
    });
  } : a;
}(function(a, b) {
  if (a.namespaceURI !== kb.svg || "innerHTML" in a)
    a.innerHTML = b;
  else {
    nb = nb || document.createElement("div");
    nb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
    for (b = nb.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b.firstChild; )
      a.appendChild(b.firstChild);
  }
});
function pb(a, b) {
  if (b) {
    var c = a.firstChild;
    if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;
      return;
    }
  }
  a.textContent = b;
}
var qb = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, rb = ["Webkit", "ms", "Moz", "O"];
Object.keys(qb).forEach(function(a) {
  rb.forEach(function(b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    qb[b] = qb[a];
  });
});
function sb(a, b, c) {
  return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || qb.hasOwnProperty(a) && qb[a] ? ("" + b).trim() : b + "px";
}
function tb(a, b) {
  a = a.style;
  for (var c in b)
    if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--"), e2 = sb(c, b[c], d);
      "float" === c && (c = "cssFloat");
      d ? a.setProperty(c, e2) : a[c] = e2;
    }
}
var ub = m$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function vb(a, b) {
  if (b) {
    if (ub[a] && (null != b.children || null != b.dangerouslySetInnerHTML))
      throw Error(y(137, a));
    if (null != b.dangerouslySetInnerHTML) {
      if (null != b.children)
        throw Error(y(60));
      if (!("object" === typeof b.dangerouslySetInnerHTML && "__html" in b.dangerouslySetInnerHTML))
        throw Error(y(61));
    }
    if (null != b.style && "object" !== typeof b.style)
      throw Error(y(62));
  }
}
function wb(a, b) {
  if (-1 === a.indexOf("-"))
    return "string" === typeof b.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb)
      throw Error(y(280));
    var b = a.stateNode;
    b && (b = Db(b), yb(a.stateNode, a.type, b));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b = Ab;
    Ab = zb = null;
    Bb(a);
    if (b)
      for (a = 0; a < b.length; a++)
        Bb(b[a]);
  }
}
function Gb(a, b) {
  return a(b);
}
function Hb(a, b, c, d, e2) {
  return a(b, c, d, e2);
}
function Ib() {
}
var Jb = Gb, Kb = false, Lb = false;
function Mb() {
  if (null !== zb || null !== Ab)
    Ib(), Fb();
}
function Nb(a, b, c) {
  if (Lb)
    return a(b, c);
  Lb = true;
  try {
    return Jb(a, b, c);
  } finally {
    Lb = false, Mb();
  }
}
function Ob(a, b) {
  var c = a.stateNode;
  if (null === c)
    return null;
  var d = Db(c);
  if (null === d)
    return null;
  c = d[b];
  a:
    switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  if (c && "function" !== typeof c)
    throw Error(y(231, b, typeof c));
  return c;
}
var Pb = false;
if (fa)
  try {
    var Qb = {};
    Object.defineProperty(Qb, "passive", { get: function() {
      Pb = true;
    } });
    window.addEventListener("test", Qb, Qb);
    window.removeEventListener("test", Qb, Qb);
  } catch (a) {
    Pb = false;
  }
function Rb(a, b, c, d, e2, f2, g2, h2, k) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b.apply(c, l2);
  } catch (n2) {
    this.onError(n2);
  }
}
var Sb = false, Tb = null, Ub = false, Vb = null, Wb = { onError: function(a) {
  Sb = true;
  Tb = a;
} };
function Xb(a, b, c, d, e2, f2, g2, h2, k) {
  Sb = false;
  Tb = null;
  Rb.apply(Wb, arguments);
}
function Yb(a, b, c, d, e2, f2, g2, h2, k) {
  Xb.apply(this, arguments);
  if (Sb) {
    if (Sb) {
      var l2 = Tb;
      Sb = false;
      Tb = null;
    } else
      throw Error(y(198));
    Ub || (Ub = true, Vb = l2);
  }
}
function Zb(a) {
  var b = a, c = a;
  if (a.alternate)
    for (; b.return; )
      b = b.return;
  else {
    a = b;
    do
      b = a, 0 !== (b.flags & 1026) && (c = b.return), a = b.return;
    while (a);
  }
  return 3 === b.tag ? c : null;
}
function $b(a) {
  if (13 === a.tag) {
    var b = a.memoizedState;
    null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
    if (null !== b)
      return b.dehydrated;
  }
  return null;
}
function ac(a) {
  if (Zb(a) !== a)
    throw Error(y(188));
}
function bc(a) {
  var b = a.alternate;
  if (!b) {
    b = Zb(a);
    if (null === b)
      throw Error(y(188));
    return b !== a ? null : a;
  }
  for (var c = a, d = b; ; ) {
    var e2 = c.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d = e2.return;
      if (null !== d) {
        c = d;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c)
          return ac(e2), a;
        if (f2 === d)
          return ac(e2), b;
        f2 = f2.sibling;
      }
      throw Error(y(188));
    }
    if (c.return !== d.return)
      c = e2, d = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c) {
          g2 = true;
          c = e2;
          d = f2;
          break;
        }
        if (h2 === d) {
          g2 = true;
          d = e2;
          c = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c) {
            g2 = true;
            c = f2;
            d = e2;
            break;
          }
          if (h2 === d) {
            g2 = true;
            d = f2;
            c = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(y(189));
      }
    }
    if (c.alternate !== d)
      throw Error(y(190));
  }
  if (3 !== c.tag)
    throw Error(y(188));
  return c.stateNode.current === c ? a : b;
}
function cc(a) {
  a = bc(a);
  if (!a)
    return null;
  for (var b = a; ; ) {
    if (5 === b.tag || 6 === b.tag)
      return b;
    if (b.child)
      b.child.return = b, b = b.child;
    else {
      if (b === a)
        break;
      for (; !b.sibling; ) {
        if (!b.return || b.return === a)
          return null;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
  }
  return null;
}
function dc(a, b) {
  for (var c = a.alternate; null !== b; ) {
    if (b === a || b === c)
      return true;
    b = b.return;
  }
  return false;
}
var ec, fc, gc, hc, ic = false, jc = [], kc = null, lc = null, mc = null, nc = /* @__PURE__ */ new Map(), oc = /* @__PURE__ */ new Map(), pc = [], qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function rc(a, b, c, d, e2) {
  return { blockedOn: a, domEventName: b, eventSystemFlags: c | 16, nativeEvent: e2, targetContainers: [d] };
}
function sc(a, b) {
  switch (a) {
    case "focusin":
    case "focusout":
      kc = null;
      break;
    case "dragenter":
    case "dragleave":
      lc = null;
      break;
    case "mouseover":
    case "mouseout":
      mc = null;
      break;
    case "pointerover":
    case "pointerout":
      nc.delete(b.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      oc.delete(b.pointerId);
  }
}
function tc(a, b, c, d, e2, f2) {
  if (null === a || a.nativeEvent !== f2)
    return a = rc(b, c, d, e2, f2), null !== b && (b = Cb(b), null !== b && fc(b)), a;
  a.eventSystemFlags |= d;
  b = a.targetContainers;
  null !== e2 && -1 === b.indexOf(e2) && b.push(e2);
  return a;
}
function uc(a, b, c, d, e2) {
  switch (b) {
    case "focusin":
      return kc = tc(kc, a, b, c, d, e2), true;
    case "dragenter":
      return lc = tc(lc, a, b, c, d, e2), true;
    case "mouseover":
      return mc = tc(mc, a, b, c, d, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      nc.set(f2, tc(nc.get(f2) || null, a, b, c, d, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, oc.set(f2, tc(oc.get(f2) || null, a, b, c, d, e2)), true;
  }
  return false;
}
function vc(a) {
  var b = wc(a.target);
  if (null !== b) {
    var c = Zb(b);
    if (null !== c) {
      if (b = c.tag, 13 === b) {
        if (b = $b(c), null !== b) {
          a.blockedOn = b;
          hc(a.lanePriority, function() {
            r$2.unstable_runWithPriority(a.priority, function() {
              gc(c);
            });
          });
          return;
        }
      } else if (3 === b && c.stateNode.hydrate) {
        a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function xc(a) {
  if (null !== a.blockedOn)
    return false;
  for (var b = a.targetContainers; 0 < b.length; ) {
    var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
    if (null !== c)
      return b = Cb(c), null !== b && fc(b), a.blockedOn = c, false;
    b.shift();
  }
  return true;
}
function zc(a, b, c) {
  xc(a) && c.delete(b);
}
function Ac() {
  for (ic = false; 0 < jc.length; ) {
    var a = jc[0];
    if (null !== a.blockedOn) {
      a = Cb(a.blockedOn);
      null !== a && ec(a);
      break;
    }
    for (var b = a.targetContainers; 0 < b.length; ) {
      var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
      if (null !== c) {
        a.blockedOn = c;
        break;
      }
      b.shift();
    }
    null === a.blockedOn && jc.shift();
  }
  null !== kc && xc(kc) && (kc = null);
  null !== lc && xc(lc) && (lc = null);
  null !== mc && xc(mc) && (mc = null);
  nc.forEach(zc);
  oc.forEach(zc);
}
function Bc(a, b) {
  a.blockedOn === b && (a.blockedOn = null, ic || (ic = true, r$2.unstable_scheduleCallback(r$2.unstable_NormalPriority, Ac)));
}
function Cc(a) {
  function b(b2) {
    return Bc(b2, a);
  }
  if (0 < jc.length) {
    Bc(jc[0], a);
    for (var c = 1; c < jc.length; c++) {
      var d = jc[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }
  null !== kc && Bc(kc, a);
  null !== lc && Bc(lc, a);
  null !== mc && Bc(mc, a);
  nc.forEach(b);
  oc.forEach(b);
  for (c = 0; c < pc.length; c++)
    d = pc[c], d.blockedOn === a && (d.blockedOn = null);
  for (; 0 < pc.length && (c = pc[0], null === c.blockedOn); )
    vc(c), null === c.blockedOn && pc.shift();
}
function Dc(a, b) {
  var c = {};
  c[a.toLowerCase()] = b.toLowerCase();
  c["Webkit" + a] = "webkit" + b;
  c["Moz" + a] = "moz" + b;
  return c;
}
var Ec = { animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd") }, Fc = {}, Gc = {};
fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
function Hc(a) {
  if (Fc[a])
    return Fc[a];
  if (!Ec[a])
    return a;
  var b = Ec[a], c;
  for (c in b)
    if (b.hasOwnProperty(c) && c in Gc)
      return Fc[a] = b[c];
  return a;
}
var Ic = Hc("animationend"), Jc = Hc("animationiteration"), Kc = Hc("animationstart"), Lc = Hc("transitionend"), Mc = /* @__PURE__ */ new Map(), Nc = /* @__PURE__ */ new Map(), Oc = [
  "abort",
  "abort",
  Ic,
  "animationEnd",
  Jc,
  "animationIteration",
  Kc,
  "animationStart",
  "canplay",
  "canPlay",
  "canplaythrough",
  "canPlayThrough",
  "durationchange",
  "durationChange",
  "emptied",
  "emptied",
  "encrypted",
  "encrypted",
  "ended",
  "ended",
  "error",
  "error",
  "gotpointercapture",
  "gotPointerCapture",
  "load",
  "load",
  "loadeddata",
  "loadedData",
  "loadedmetadata",
  "loadedMetadata",
  "loadstart",
  "loadStart",
  "lostpointercapture",
  "lostPointerCapture",
  "playing",
  "playing",
  "progress",
  "progress",
  "seeking",
  "seeking",
  "stalled",
  "stalled",
  "suspend",
  "suspend",
  "timeupdate",
  "timeUpdate",
  Lc,
  "transitionEnd",
  "waiting",
  "waiting"
];
function Pc(a, b) {
  for (var c = 0; c < a.length; c += 2) {
    var d = a[c], e2 = a[c + 1];
    e2 = "on" + (e2[0].toUpperCase() + e2.slice(1));
    Nc.set(d, b);
    Mc.set(d, e2);
    da(e2, [d]);
  }
}
var Qc = r$2.unstable_now;
Qc();
var F = 8;
function Rc(a) {
  if (0 !== (1 & a))
    return F = 15, 1;
  if (0 !== (2 & a))
    return F = 14, 2;
  if (0 !== (4 & a))
    return F = 13, 4;
  var b = 24 & a;
  if (0 !== b)
    return F = 12, b;
  if (0 !== (a & 32))
    return F = 11, 32;
  b = 192 & a;
  if (0 !== b)
    return F = 10, b;
  if (0 !== (a & 256))
    return F = 9, 256;
  b = 3584 & a;
  if (0 !== b)
    return F = 8, b;
  if (0 !== (a & 4096))
    return F = 7, 4096;
  b = 4186112 & a;
  if (0 !== b)
    return F = 6, b;
  b = 62914560 & a;
  if (0 !== b)
    return F = 5, b;
  if (a & 67108864)
    return F = 4, 67108864;
  if (0 !== (a & 134217728))
    return F = 3, 134217728;
  b = 805306368 & a;
  if (0 !== b)
    return F = 2, b;
  if (0 !== (1073741824 & a))
    return F = 1, 1073741824;
  F = 8;
  return a;
}
function Sc(a) {
  switch (a) {
    case 99:
      return 15;
    case 98:
      return 10;
    case 97:
    case 96:
      return 8;
    case 95:
      return 2;
    default:
      return 0;
  }
}
function Tc(a) {
  switch (a) {
    case 15:
    case 14:
      return 99;
    case 13:
    case 12:
    case 11:
    case 10:
      return 98;
    case 9:
    case 8:
    case 7:
    case 6:
    case 4:
    case 5:
      return 97;
    case 3:
    case 2:
    case 1:
      return 95;
    case 0:
      return 90;
    default:
      throw Error(y(358, a));
  }
}
function Uc(a, b) {
  var c = a.pendingLanes;
  if (0 === c)
    return F = 0;
  var d = 0, e2 = 0, f2 = a.expiredLanes, g2 = a.suspendedLanes, h2 = a.pingedLanes;
  if (0 !== f2)
    d = f2, e2 = F = 15;
  else if (f2 = c & 134217727, 0 !== f2) {
    var k = f2 & ~g2;
    0 !== k ? (d = Rc(k), e2 = F) : (h2 &= f2, 0 !== h2 && (d = Rc(h2), e2 = F));
  } else
    f2 = c & ~g2, 0 !== f2 ? (d = Rc(f2), e2 = F) : 0 !== h2 && (d = Rc(h2), e2 = F);
  if (0 === d)
    return 0;
  d = 31 - Vc(d);
  d = c & ((0 > d ? 0 : 1 << d) << 1) - 1;
  if (0 !== b && b !== d && 0 === (b & g2)) {
    Rc(b);
    if (e2 <= F)
      return b;
    F = e2;
  }
  b = a.entangledLanes;
  if (0 !== b)
    for (a = a.entanglements, b &= d; 0 < b; )
      c = 31 - Vc(b), e2 = 1 << c, d |= a[c], b &= ~e2;
  return d;
}
function Wc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function Xc(a, b) {
  switch (a) {
    case 15:
      return 1;
    case 14:
      return 2;
    case 12:
      return a = Yc(24 & ~b), 0 === a ? Xc(10, b) : a;
    case 10:
      return a = Yc(192 & ~b), 0 === a ? Xc(8, b) : a;
    case 8:
      return a = Yc(3584 & ~b), 0 === a && (a = Yc(4186112 & ~b), 0 === a && (a = 512)), a;
    case 2:
      return b = Yc(805306368 & ~b), 0 === b && (b = 268435456), b;
  }
  throw Error(y(358, a));
}
function Yc(a) {
  return a & -a;
}
function Zc(a) {
  for (var b = [], c = 0; 31 > c; c++)
    b.push(a);
  return b;
}
function $c(a, b, c) {
  a.pendingLanes |= b;
  var d = b - 1;
  a.suspendedLanes &= d;
  a.pingedLanes &= d;
  a = a.eventTimes;
  b = 31 - Vc(b);
  a[b] = c;
}
var Vc = Math.clz32 ? Math.clz32 : ad, bd = Math.log, cd = Math.LN2;
function ad(a) {
  return 0 === a ? 32 : 31 - (bd(a) / cd | 0) | 0;
}
var dd = r$2.unstable_UserBlockingPriority, ed = r$2.unstable_runWithPriority, fd = true;
function gd(a, b, c, d) {
  Kb || Ib();
  var e2 = hd, f2 = Kb;
  Kb = true;
  try {
    Hb(e2, a, b, c, d);
  } finally {
    (Kb = f2) || Mb();
  }
}
function id(a, b, c, d) {
  ed(dd, hd.bind(null, a, b, c, d));
}
function hd(a, b, c, d) {
  if (fd) {
    var e2;
    if ((e2 = 0 === (b & 4)) && 0 < jc.length && -1 < qc.indexOf(a))
      a = rc(null, a, b, c, d), jc.push(a);
    else {
      var f2 = yc(a, b, c, d);
      if (null === f2)
        e2 && sc(a, d);
      else {
        if (e2) {
          if (-1 < qc.indexOf(a)) {
            a = rc(f2, a, b, c, d);
            jc.push(a);
            return;
          }
          if (uc(f2, a, b, c, d))
            return;
          sc(a, d);
        }
        jd(a, b, d, null, c);
      }
    }
  }
}
function yc(a, b, c, d) {
  var e2 = xb(d);
  e2 = wc(e2);
  if (null !== e2) {
    var f2 = Zb(e2);
    if (null === f2)
      e2 = null;
    else {
      var g2 = f2.tag;
      if (13 === g2) {
        e2 = $b(f2);
        if (null !== e2)
          return e2;
        e2 = null;
      } else if (3 === g2) {
        if (f2.stateNode.hydrate)
          return 3 === f2.tag ? f2.stateNode.containerInfo : null;
        e2 = null;
      } else
        f2 !== e2 && (e2 = null);
    }
  }
  jd(a, b, d, e2, c);
  return null;
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a, b = ld, c = b.length, d, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a = 0; a < c && b[a] === e2[a]; a++)
    ;
  var g2 = c - a;
  for (d = 1; d <= g2 && b[c - d] === e2[f2 - d]; d++)
    ;
  return md = e2.slice(a, 1 < d ? 1 - d : void 0);
}
function od(a) {
  var b = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b(b2, d, e2, f2, g2) {
    this._reactName = b2;
    this._targetInst = e2;
    this.type = d;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c in a)
      a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f2) : f2[c]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  m$1(b.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = m$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = m$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = m$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = m$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = m$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = m$1({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = m$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b = this.nativeEvent;
  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
}
function zd() {
  return Pd;
}
var Qd = m$1({}, ud, { key: function(a) {
  if (a.key) {
    var b = Md[a.key] || a.key;
    if ("Unidentified" !== b)
      return b;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = m$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = m$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = m$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = m$1({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = fa && "CompositionEvent" in window, be = null;
fa && "documentMode" in document && (be = document.documentMode);
var ce = fa && "TextEvent" in window && !be, de = fa && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b.keyCode);
    case "keydown":
      return 229 !== b.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b) {
  switch (a) {
    case "compositionend":
      return he(b);
    case "keypress":
      if (32 !== b.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b) {
  if (ie)
    return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length)
          return b.char;
        if (b.which)
          return String.fromCharCode(b.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b.locale ? null : b.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
}
function ne(a, b, c, d) {
  Eb(d);
  b = oe(b, "onChange");
  0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
}
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b = ue(a);
  if (Wa(b))
    return a;
}
function ve(a, b) {
  if ("change" === a)
    return b;
}
var we = false;
if (fa) {
  var xe;
  if (fa) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b = [];
    ne(b, qe, a, xb(a));
    a = re;
    if (Kb)
      a(b);
    else {
      Kb = true;
      try {
        Gb(a, b);
      } finally {
        Kb = false, Mb();
      }
    }
  }
}
function Ce(a, b, c) {
  "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a)
    return te(qe);
}
function Ee(a, b) {
  if ("click" === a)
    return te(b);
}
function Fe(a, b) {
  if ("input" === a || "change" === a)
    return te(b);
}
function Ge(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var He = "function" === typeof Object.is ? Object.is : Ge, Ie = Object.prototype.hasOwnProperty;
function Je(a, b) {
  if (He(a, b))
    return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b || null === b)
    return false;
  var c = Object.keys(a), d = Object.keys(b);
  if (c.length !== d.length)
    return false;
  for (d = 0; d < c.length; d++)
    if (!Ie.call(b, c[d]) || !He(a[c[d]], b[c[d]]))
      return false;
  return true;
}
function Ke(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
function Le(a, b) {
  var c = Ke(a);
  a = 0;
  for (var d; c; ) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;
      if (a <= b && d >= b)
        return { node: c, offset: b - a };
      a = d;
    }
    a: {
      for (; c; ) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = Ke(c);
  }
}
function Me(a, b) {
  return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Me(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
}
function Ne() {
  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
    try {
      var c = "string" === typeof b.contentWindow.location.href;
    } catch (d) {
      c = false;
    }
    if (c)
      a = b.contentWindow;
    else
      break;
    b = Xa(a.document);
  }
  return b;
}
function Oe(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
}
var Pe = fa && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b, c) {
  var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
  Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Oe(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Je(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
}
Pc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);
Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
Pc(Oc, 2);
for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
  Nc.set(Ve[We], 0);
ea("onMouseEnter", ["mouseout", "mouseover"]);
ea("onMouseLeave", ["mouseout", "mouseover"]);
ea("onPointerEnter", ["pointerout", "pointerover"]);
ea("onPointerLeave", ["pointerout", "pointerover"]);
da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
function Ze(a, b, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Yb(d, b, void 0, a);
  a.currentTarget = null;
}
function se(a, b) {
  b = 0 !== (b & 4);
  for (var c = 0; c < a.length; c++) {
    var d = a[c], e2 = d.event;
    d = d.listeners;
    a: {
      var f2 = void 0;
      if (b)
        for (var g2 = d.length - 1; 0 <= g2; g2--) {
          var h2 = d[g2], k = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k !== f2 && e2.isPropagationStopped())
            break a;
          Ze(e2, h2, l2);
          f2 = k;
        }
      else
        for (g2 = 0; g2 < d.length; g2++) {
          h2 = d[g2];
          k = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k !== f2 && e2.isPropagationStopped())
            break a;
          Ze(e2, h2, l2);
          f2 = k;
        }
    }
  }
  if (Ub)
    throw a = Vb, Ub = false, Vb = null, a;
}
function G(a, b) {
  var c = $e(b), d = a + "__bubble";
  c.has(d) || (af(b, a, 2, false), c.add(d));
}
var bf = "_reactListening" + Math.random().toString(36).slice(2);
function cf(a) {
  a[bf] || (a[bf] = true, ba.forEach(function(b) {
    Ye.has(b) || df(b, false, a, null);
    df(b, true, a, null);
  }));
}
function df(a, b, c, d) {
  var e2 = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, f2 = c;
  "selectionchange" === a && 9 !== c.nodeType && (f2 = c.ownerDocument);
  if (null !== d && !b && Ye.has(a)) {
    if ("scroll" !== a)
      return;
    e2 |= 2;
    f2 = d;
  }
  var g2 = $e(f2), h2 = a + "__" + (b ? "capture" : "bubble");
  g2.has(h2) || (b && (e2 |= 4), af(f2, a, e2, b), g2.add(h2));
}
function af(a, b, c, d) {
  var e2 = Nc.get(b);
  switch (void 0 === e2 ? 2 : e2) {
    case 0:
      e2 = gd;
      break;
    case 1:
      e2 = id;
      break;
    default:
      e2 = hd;
  }
  c = e2.bind(null, b, c, a);
  e2 = void 0;
  !Pb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e2 = true);
  d ? void 0 !== e2 ? a.addEventListener(b, c, { capture: true, passive: e2 }) : a.addEventListener(b, c, true) : void 0 !== e2 ? a.addEventListener(b, c, { passive: e2 }) : a.addEventListener(b, c, false);
}
function jd(a, b, c, d, e2) {
  var f2 = d;
  if (0 === (b & 1) && 0 === (b & 2) && null !== d)
    a:
      for (; ; ) {
        if (null === d)
          return;
        var g2 = d.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d.return; null !== g2; ) {
              var k = g2.tag;
              if (3 === k || 4 === k) {
                if (k = g2.stateNode.containerInfo, k === e2 || 8 === k.nodeType && k.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = wc(h2);
            if (null === g2)
              return;
            k = g2.tag;
            if (5 === k || 6 === k) {
              d = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d = d.return;
      }
  Nb(function() {
    var d2 = f2, e3 = xb(c), g3 = [];
    a: {
      var h3 = Mc.get(a);
      if (void 0 !== h3) {
        var k2 = td, x2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c))
              break a;
          case "keydown":
          case "keyup":
            k2 = Rd;
            break;
          case "focusin":
            x2 = "focus";
            k2 = Fd;
            break;
          case "focusout":
            x2 = "blur";
            k2 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k2 = Fd;
            break;
          case "click":
            if (2 === c.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k2 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k2 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k2 = Vd;
            break;
          case Ic:
          case Jc:
          case Kc:
            k2 = Hd;
            break;
          case Lc:
            k2 = Xd;
            break;
          case "scroll":
            k2 = vd;
            break;
          case "wheel":
            k2 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k2 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k2 = Td;
        }
        var w2 = 0 !== (b & 4), z2 = !w2 && "scroll" === a, u2 = w2 ? null !== h3 ? h3 + "Capture" : null : h3;
        w2 = [];
        for (var t2 = d2, q2; null !== t2; ) {
          q2 = t2;
          var v2 = q2.stateNode;
          5 === q2.tag && null !== v2 && (q2 = v2, null !== u2 && (v2 = Ob(t2, u2), null != v2 && w2.push(ef(t2, v2, q2))));
          if (z2)
            break;
          t2 = t2.return;
        }
        0 < w2.length && (h3 = new k2(h3, x2, null, c, e3), g3.push({ event: h3, listeners: w2 }));
      }
    }
    if (0 === (b & 7)) {
      a: {
        h3 = "mouseover" === a || "pointerover" === a;
        k2 = "mouseout" === a || "pointerout" === a;
        if (h3 && 0 === (b & 16) && (x2 = c.relatedTarget || c.fromElement) && (wc(x2) || x2[ff]))
          break a;
        if (k2 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k2) {
            if (x2 = c.relatedTarget || c.toElement, k2 = d2, x2 = x2 ? wc(x2) : null, null !== x2 && (z2 = Zb(x2), x2 !== z2 || 5 !== x2.tag && 6 !== x2.tag))
              x2 = null;
          } else
            k2 = null, x2 = d2;
          if (k2 !== x2) {
            w2 = Bd;
            v2 = "onMouseLeave";
            u2 = "onMouseEnter";
            t2 = "mouse";
            if ("pointerout" === a || "pointerover" === a)
              w2 = Td, v2 = "onPointerLeave", u2 = "onPointerEnter", t2 = "pointer";
            z2 = null == k2 ? h3 : ue(k2);
            q2 = null == x2 ? h3 : ue(x2);
            h3 = new w2(v2, t2 + "leave", k2, c, e3);
            h3.target = z2;
            h3.relatedTarget = q2;
            v2 = null;
            wc(e3) === d2 && (w2 = new w2(u2, t2 + "enter", x2, c, e3), w2.target = q2, w2.relatedTarget = z2, v2 = w2);
            z2 = v2;
            if (k2 && x2)
              b: {
                w2 = k2;
                u2 = x2;
                t2 = 0;
                for (q2 = w2; q2; q2 = gf(q2))
                  t2++;
                q2 = 0;
                for (v2 = u2; v2; v2 = gf(v2))
                  q2++;
                for (; 0 < t2 - q2; )
                  w2 = gf(w2), t2--;
                for (; 0 < q2 - t2; )
                  u2 = gf(u2), q2--;
                for (; t2--; ) {
                  if (w2 === u2 || null !== u2 && w2 === u2.alternate)
                    break b;
                  w2 = gf(w2);
                  u2 = gf(u2);
                }
                w2 = null;
              }
            else
              w2 = null;
            null !== k2 && hf(g3, h3, k2, w2, false);
            null !== x2 && null !== z2 && hf(g3, z2, x2, w2, true);
          }
        }
      }
      a: {
        h3 = d2 ? ue(d2) : window;
        k2 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k2 || "input" === k2 && "file" === h3.type)
          var J2 = ve;
        else if (me(h3))
          if (we)
            J2 = Fe;
          else {
            J2 = De;
            var K2 = Ce;
          }
        else
          (k2 = h3.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (J2 = Ee);
        if (J2 && (J2 = J2(a, d2))) {
          ne(g3, J2, c, e3);
          break a;
        }
        K2 && K2(a, h3, d2);
        "focusout" === a && (K2 = h3._wrapperState) && K2.controlled && "number" === h3.type && bb(h3, "number", h3.value);
      }
      K2 = d2 ? ue(d2) : window;
      switch (a) {
        case "focusin":
          if (me(K2) || "true" === K2.contentEditable)
            Qe = K2, Re = d2, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c, e3);
      }
      var Q2;
      if (ae)
        b: {
          switch (a) {
            case "compositionstart":
              var L2 = "onCompositionStart";
              break b;
            case "compositionend":
              L2 = "onCompositionEnd";
              break b;
            case "compositionupdate":
              L2 = "onCompositionUpdate";
              break b;
          }
          L2 = void 0;
        }
      else
        ie ? ge(a, c) && (L2 = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (L2 = "onCompositionStart");
      L2 && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== L2 ? "onCompositionEnd" === L2 && ie && (Q2 = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K2 = oe(d2, L2), 0 < K2.length && (L2 = new Ld(L2, a, null, c, e3), g3.push({ event: L2, listeners: K2 }), Q2 ? L2.data = Q2 : (Q2 = he(c), null !== Q2 && (L2.data = Q2))));
      if (Q2 = ce ? je(a, c) : ke(a, c))
        d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c, e3), g3.push({ event: e3, listeners: d2 }), e3.data = Q2);
    }
    se(g3, b);
  });
}
function ef(a, b, c) {
  return { instance: a, listener: b, currentTarget: c };
}
function oe(a, b) {
  for (var c = b + "Capture", d = []; null !== a; ) {
    var e2 = a, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Ob(a, c), null != f2 && d.unshift(ef(a, f2, e2)), f2 = Ob(a, b), null != f2 && d.push(ef(a, f2, e2)));
    a = a.return;
  }
  return d;
}
function gf(a) {
  if (null === a)
    return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function hf(a, b, c, d, e2) {
  for (var f2 = b._reactName, g2 = []; null !== c && c !== d; ) {
    var h2 = c, k = h2.alternate, l2 = h2.stateNode;
    if (null !== k && k === d)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k = Ob(c, f2), null != k && g2.unshift(ef(c, k, h2))) : e2 || (k = Ob(c, f2), null != k && g2.push(ef(c, k, h2))));
    c = c.return;
  }
  0 !== g2.length && a.push({ event: b, listeners: g2 });
}
function jf() {
}
var kf = null, lf = null;
function mf(a, b) {
  switch (a) {
    case "button":
    case "input":
    case "select":
    case "textarea":
      return !!b.autoFocus;
  }
  return false;
}
function nf(a, b) {
  return "textarea" === a || "option" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
}
var of$1 = "function" === typeof setTimeout ? setTimeout : void 0, pf = "function" === typeof clearTimeout ? clearTimeout : void 0;
function qf(a) {
  1 === a.nodeType ? a.textContent = "" : 9 === a.nodeType && (a = a.body, null != a && (a.textContent = ""));
}
function rf(a) {
  for (; null != a; a = a.nextSibling) {
    var b = a.nodeType;
    if (1 === b || 3 === b)
      break;
  }
  return a;
}
function sf(a) {
  a = a.previousSibling;
  for (var b = 0; a; ) {
    if (8 === a.nodeType) {
      var c = a.data;
      if ("$" === c || "$!" === c || "$?" === c) {
        if (0 === b)
          return a;
        b--;
      } else
        "/$" === c && b++;
    }
    a = a.previousSibling;
  }
  return null;
}
var tf = 0;
function uf(a) {
  return { $$typeof: Ga, toString: a, valueOf: a };
}
var vf = Math.random().toString(36).slice(2), wf = "__reactFiber$" + vf, xf = "__reactProps$" + vf, ff = "__reactContainer$" + vf, yf = "__reactEvents$" + vf;
function wc(a) {
  var b = a[wf];
  if (b)
    return b;
  for (var c = a.parentNode; c; ) {
    if (b = c[ff] || c[wf]) {
      c = b.alternate;
      if (null !== b.child || null !== c && null !== c.child)
        for (a = sf(a); null !== a; ) {
          if (c = a[wf])
            return c;
          a = sf(a);
        }
      return b;
    }
    a = c;
    c = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[wf] || a[ff];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag)
    return a.stateNode;
  throw Error(y(33));
}
function Db(a) {
  return a[xf] || null;
}
function $e(a) {
  var b = a[yf];
  void 0 === b && (b = a[yf] = /* @__PURE__ */ new Set());
  return b;
}
var zf = [], Af = -1;
function Bf(a) {
  return { current: a };
}
function H(a) {
  0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);
}
function I(a, b) {
  Af++;
  zf[Af] = a.current;
  a.current = b;
}
var Cf = {}, M = Bf(Cf), N = Bf(false), Df = Cf;
function Ef(a, b) {
  var c = a.type.contextTypes;
  if (!c)
    return Cf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
    return d.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c)
    e2[f2] = b[f2];
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Ff(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function Gf() {
  H(N);
  H(M);
}
function Hf(a, b, c) {
  if (M.current !== Cf)
    throw Error(y(168));
  I(M, b);
  I(N, c);
}
function If(a, b, c) {
  var d = a.stateNode;
  a = b.childContextTypes;
  if ("function" !== typeof d.getChildContext)
    return c;
  d = d.getChildContext();
  for (var e2 in d)
    if (!(e2 in a))
      throw Error(y(108, Ra(b) || "Unknown", e2));
  return m$1({}, c, d);
}
function Jf(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;
  Df = M.current;
  I(M, a);
  I(N, N.current);
  return true;
}
function Kf(a, b, c) {
  var d = a.stateNode;
  if (!d)
    throw Error(y(169));
  c ? (a = If(a, b, Df), d.__reactInternalMemoizedMergedChildContext = a, H(N), H(M), I(M, a)) : H(N);
  I(N, c);
}
var Lf = null, Mf = null, Nf = r$2.unstable_runWithPriority, Of = r$2.unstable_scheduleCallback, Pf = r$2.unstable_cancelCallback, Qf = r$2.unstable_shouldYield, Rf = r$2.unstable_requestPaint, Sf = r$2.unstable_now, Tf = r$2.unstable_getCurrentPriorityLevel, Uf = r$2.unstable_ImmediatePriority, Vf = r$2.unstable_UserBlockingPriority, Wf = r$2.unstable_NormalPriority, Xf = r$2.unstable_LowPriority, Yf = r$2.unstable_IdlePriority, Zf = {}, $f = void 0 !== Rf ? Rf : function() {
}, ag = null, bg = null, cg = false, dg = Sf(), O = 1e4 > dg ? Sf : function() {
  return Sf() - dg;
};
function eg() {
  switch (Tf()) {
    case Uf:
      return 99;
    case Vf:
      return 98;
    case Wf:
      return 97;
    case Xf:
      return 96;
    case Yf:
      return 95;
    default:
      throw Error(y(332));
  }
}
function fg(a) {
  switch (a) {
    case 99:
      return Uf;
    case 98:
      return Vf;
    case 97:
      return Wf;
    case 96:
      return Xf;
    case 95:
      return Yf;
    default:
      throw Error(y(332));
  }
}
function gg(a, b) {
  a = fg(a);
  return Nf(a, b);
}
function hg(a, b, c) {
  a = fg(a);
  return Of(a, b, c);
}
function ig() {
  if (null !== bg) {
    var a = bg;
    bg = null;
    Pf(a);
  }
  jg();
}
function jg() {
  if (!cg && null !== ag) {
    cg = true;
    var a = 0;
    try {
      var b = ag;
      gg(99, function() {
        for (; a < b.length; a++) {
          var c = b[a];
          do
            c = c(true);
          while (null !== c);
        }
      });
      ag = null;
    } catch (c) {
      throw null !== ag && (ag = ag.slice(a + 1)), Of(Uf, ig), c;
    } finally {
      cg = false;
    }
  }
}
var kg = ra.ReactCurrentBatchConfig;
function lg(a, b) {
  if (a && a.defaultProps) {
    b = m$1({}, b);
    a = a.defaultProps;
    for (var c in a)
      void 0 === b[c] && (b[c] = a[c]);
    return b;
  }
  return b;
}
var mg = Bf(null), ng = null, og = null, pg = null;
function qg() {
  pg = og = ng = null;
}
function rg(a) {
  var b = mg.current;
  H(mg);
  a.type._context._currentValue = b;
}
function sg(a, b) {
  for (; null !== a; ) {
    var c = a.alternate;
    if ((a.childLanes & b) === b)
      if (null === c || (c.childLanes & b) === b)
        break;
      else
        c.childLanes |= b;
    else
      a.childLanes |= b, null !== c && (c.childLanes |= b);
    a = a.return;
  }
}
function tg(a, b) {
  ng = a;
  pg = og = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (ug = true), a.firstContext = null);
}
function vg(a, b) {
  if (pg !== a && false !== b && 0 !== b) {
    if ("number" !== typeof b || 1073741823 === b)
      pg = a, b = 1073741823;
    b = { context: a, observedBits: b, next: null };
    if (null === og) {
      if (null === ng)
        throw Error(y(308));
      og = b;
      ng.dependencies = { lanes: 0, firstContext: b, responders: null };
    } else
      og = og.next = b;
  }
  return a._currentValue;
}
var wg = false;
function xg(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
}
function yg(a, b) {
  a = a.updateQueue;
  b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function zg(a, b) {
  return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
}
function Ag(a, b) {
  a = a.updateQueue;
  if (null !== a) {
    a = a.shared;
    var c = a.pending;
    null === c ? b.next = b : (b.next = c.next, c.next = b);
    a.pending = b;
  }
}
function Bg(a, b) {
  var c = a.updateQueue, d = a.alternate;
  if (null !== d && (d = d.updateQueue, c === d)) {
    var e2 = null, f2 = null;
    c = c.firstBaseUpdate;
    if (null !== c) {
      do {
        var g2 = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c = c.next;
      } while (null !== c);
      null === f2 ? e2 = f2 = b : f2 = f2.next = b;
    } else
      e2 = f2 = b;
    c = { baseState: d.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d.shared, effects: d.effects };
    a.updateQueue = c;
    return;
  }
  a = c.lastBaseUpdate;
  null === a ? c.firstBaseUpdate = b : a.next = b;
  c.lastBaseUpdate = b;
}
function Cg(a, b, c, d) {
  var e2 = a.updateQueue;
  wg = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k = h2, l2 = k.next;
    k.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k;
    var n2 = a.alternate;
    if (null !== n2) {
      n2 = n2.updateQueue;
      var A2 = n2.lastBaseUpdate;
      A2 !== g2 && (null === A2 ? n2.firstBaseUpdate = l2 : A2.next = l2, n2.lastBaseUpdate = k);
    }
  }
  if (null !== f2) {
    A2 = e2.baseState;
    g2 = 0;
    n2 = l2 = k = null;
    do {
      h2 = f2.lane;
      var p2 = f2.eventTime;
      if ((d & h2) === h2) {
        null !== n2 && (n2 = n2.next = {
          eventTime: p2,
          lane: 0,
          tag: f2.tag,
          payload: f2.payload,
          callback: f2.callback,
          next: null
        });
        a: {
          var C2 = a, x2 = f2;
          h2 = b;
          p2 = c;
          switch (x2.tag) {
            case 1:
              C2 = x2.payload;
              if ("function" === typeof C2) {
                A2 = C2.call(p2, A2, h2);
                break a;
              }
              A2 = C2;
              break a;
            case 3:
              C2.flags = C2.flags & -4097 | 64;
            case 0:
              C2 = x2.payload;
              h2 = "function" === typeof C2 ? C2.call(p2, A2, h2) : C2;
              if (null === h2 || void 0 === h2)
                break a;
              A2 = m$1({}, A2, h2);
              break a;
            case 2:
              wg = true;
          }
        }
        null !== f2.callback && (a.flags |= 32, h2 = e2.effects, null === h2 ? e2.effects = [f2] : h2.push(f2));
      } else
        p2 = { eventTime: p2, lane: h2, tag: f2.tag, payload: f2.payload, callback: f2.callback, next: null }, null === n2 ? (l2 = n2 = p2, k = A2) : n2 = n2.next = p2, g2 |= h2;
      f2 = f2.next;
      if (null === f2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          f2 = h2.next, h2.next = null, e2.lastBaseUpdate = h2, e2.shared.pending = null;
    } while (1);
    null === n2 && (k = A2);
    e2.baseState = k;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = n2;
    Dg |= g2;
    a.lanes = g2;
    a.memoizedState = A2;
  }
}
function Eg(a, b, c) {
  a = b.effects;
  b.effects = null;
  if (null !== a)
    for (b = 0; b < a.length; b++) {
      var d = a[b], e2 = d.callback;
      if (null !== e2) {
        d.callback = null;
        d = c;
        if ("function" !== typeof e2)
          throw Error(y(191, e2));
        e2.call(d);
      }
    }
}
var Fg = new aa.Component().refs;
function Gg(a, b, c, d) {
  b = a.memoizedState;
  c = c(d, b);
  c = null === c || void 0 === c ? b : m$1({}, b, c);
  a.memoizedState = c;
  0 === a.lanes && (a.updateQueue.baseState = c);
}
var Kg = { isMounted: function(a) {
  return (a = a._reactInternals) ? Zb(a) === a : false;
}, enqueueSetState: function(a, b, c) {
  a = a._reactInternals;
  var d = Hg(), e2 = Ig(a), f2 = zg(d, e2);
  f2.payload = b;
  void 0 !== c && null !== c && (f2.callback = c);
  Ag(a, f2);
  Jg(a, e2, d);
}, enqueueReplaceState: function(a, b, c) {
  a = a._reactInternals;
  var d = Hg(), e2 = Ig(a), f2 = zg(d, e2);
  f2.tag = 1;
  f2.payload = b;
  void 0 !== c && null !== c && (f2.callback = c);
  Ag(a, f2);
  Jg(a, e2, d);
}, enqueueForceUpdate: function(a, b) {
  a = a._reactInternals;
  var c = Hg(), d = Ig(a), e2 = zg(c, d);
  e2.tag = 2;
  void 0 !== b && null !== b && (e2.callback = b);
  Ag(a, e2);
  Jg(a, d, c);
} };
function Lg(a, b, c, d, e2, f2, g2) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f2, g2) : b.prototype && b.prototype.isPureReactComponent ? !Je(c, d) || !Je(e2, f2) : true;
}
function Mg(a, b, c) {
  var d = false, e2 = Cf;
  var f2 = b.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = vg(f2) : (e2 = Ff(b) ? Df : M.current, d = b.contextTypes, f2 = (d = null !== d && void 0 !== d) ? Ef(a, e2) : Cf);
  b = new b(c, f2);
  a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
  b.updater = Kg;
  a.stateNode = b;
  b._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b;
}
function Ng(a, b, c, d) {
  a = b.state;
  "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
  "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
  b.state !== a && Kg.enqueueReplaceState(b, b.state, null);
}
function Og(a, b, c, d) {
  var e2 = a.stateNode;
  e2.props = c;
  e2.state = a.memoizedState;
  e2.refs = Fg;
  xg(a);
  var f2 = b.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = vg(f2) : (f2 = Ff(b) ? Df : M.current, e2.context = Ef(a, f2));
  Cg(a, c, e2, d);
  e2.state = a.memoizedState;
  f2 = b.getDerivedStateFromProps;
  "function" === typeof f2 && (Gg(a, b, f2, c), e2.state = a.memoizedState);
  "function" === typeof b.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b !== e2.state && Kg.enqueueReplaceState(e2, e2.state, null), Cg(a, c, e2, d), e2.state = a.memoizedState);
  "function" === typeof e2.componentDidMount && (a.flags |= 4);
}
var Pg = Array.isArray;
function Qg(a, b, c) {
  a = c.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c._owner) {
      c = c._owner;
      if (c) {
        if (1 !== c.tag)
          throw Error(y(309));
        var d = c.stateNode;
      }
      if (!d)
        throw Error(y(147, a));
      var e2 = "" + a;
      if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e2)
        return b.ref;
      b = function(a2) {
        var b2 = d.refs;
        b2 === Fg && (b2 = d.refs = {});
        null === a2 ? delete b2[e2] : b2[e2] = a2;
      };
      b._stringRef = e2;
      return b;
    }
    if ("string" !== typeof a)
      throw Error(y(284));
    if (!c._owner)
      throw Error(y(290, a));
  }
  return a;
}
function Rg(a, b) {
  if ("textarea" !== a.type)
    throw Error(y(31, "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b));
}
function Sg(a) {
  function b(b2, c2) {
    if (a) {
      var d2 = b2.lastEffect;
      null !== d2 ? (d2.nextEffect = c2, b2.lastEffect = c2) : b2.firstEffect = b2.lastEffect = c2;
      c2.nextEffect = null;
      c2.flags = 8;
    }
  }
  function c(c2, d2) {
    if (!a)
      return null;
    for (; null !== d2; )
      b(c2, d2), d2 = d2.sibling;
    return null;
  }
  function d(a2, b2) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b2; )
      null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
    return a2;
  }
  function e2(a2, b2) {
    a2 = Tg(a2, b2);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b2, c2, d2) {
    b2.index = d2;
    if (!a)
      return c2;
    d2 = b2.alternate;
    if (null !== d2)
      return d2 = d2.index, d2 < c2 ? (b2.flags = 2, c2) : d2;
    b2.flags = 2;
    return c2;
  }
  function g2(b2) {
    a && null === b2.alternate && (b2.flags = 2);
    return b2;
  }
  function h2(a2, b2, c2, d2) {
    if (null === b2 || 6 !== b2.tag)
      return b2 = Ug(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e2(b2, c2);
    b2.return = a2;
    return b2;
  }
  function k(a2, b2, c2, d2) {
    if (null !== b2 && b2.elementType === c2.type)
      return d2 = e2(b2, c2.props), d2.ref = Qg(a2, b2, c2), d2.return = a2, d2;
    d2 = Vg(c2.type, c2.key, c2.props, null, a2.mode, d2);
    d2.ref = Qg(a2, b2, c2);
    d2.return = a2;
    return d2;
  }
  function l2(a2, b2, c2, d2) {
    if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation)
      return b2 = Wg(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e2(b2, c2.children || []);
    b2.return = a2;
    return b2;
  }
  function n2(a2, b2, c2, d2, f3) {
    if (null === b2 || 7 !== b2.tag)
      return b2 = Xg(c2, a2.mode, d2, f3), b2.return = a2, b2;
    b2 = e2(b2, c2);
    b2.return = a2;
    return b2;
  }
  function A2(a2, b2, c2) {
    if ("string" === typeof b2 || "number" === typeof b2)
      return b2 = Ug("" + b2, a2.mode, c2), b2.return = a2, b2;
    if ("object" === typeof b2 && null !== b2) {
      switch (b2.$$typeof) {
        case sa:
          return c2 = Vg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Qg(a2, null, b2), c2.return = a2, c2;
        case ta:
          return b2 = Wg(b2, a2.mode, c2), b2.return = a2, b2;
      }
      if (Pg(b2) || La(b2))
        return b2 = Xg(b2, a2.mode, c2, null), b2.return = a2, b2;
      Rg(a2, b2);
    }
    return null;
  }
  function p2(a2, b2, c2, d2) {
    var e3 = null !== b2 ? b2.key : null;
    if ("string" === typeof c2 || "number" === typeof c2)
      return null !== e3 ? null : h2(a2, b2, "" + c2, d2);
    if ("object" === typeof c2 && null !== c2) {
      switch (c2.$$typeof) {
        case sa:
          return c2.key === e3 ? c2.type === ua ? n2(a2, b2, c2.props.children, d2, e3) : k(a2, b2, c2, d2) : null;
        case ta:
          return c2.key === e3 ? l2(a2, b2, c2, d2) : null;
      }
      if (Pg(c2) || La(c2))
        return null !== e3 ? null : n2(a2, b2, c2, d2, null);
      Rg(a2, c2);
    }
    return null;
  }
  function C2(a2, b2, c2, d2, e3) {
    if ("string" === typeof d2 || "number" === typeof d2)
      return a2 = a2.get(c2) || null, h2(b2, a2, "" + d2, e3);
    if ("object" === typeof d2 && null !== d2) {
      switch (d2.$$typeof) {
        case sa:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, d2.type === ua ? n2(b2, a2, d2.props.children, e3, d2.key) : k(b2, a2, d2, e3);
        case ta:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l2(b2, a2, d2, e3);
      }
      if (Pg(d2) || La(d2))
        return a2 = a2.get(c2) || null, n2(b2, a2, d2, e3, null);
      Rg(b2, d2);
    }
    return null;
  }
  function x2(e3, g3, h3, k2) {
    for (var l3 = null, t2 = null, u2 = g3, z2 = g3 = 0, q2 = null; null !== u2 && z2 < h3.length; z2++) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var n3 = p2(e3, u2, h3[z2], k2);
      if (null === n3) {
        null === u2 && (u2 = q2);
        break;
      }
      a && u2 && null === n3.alternate && b(e3, u2);
      g3 = f2(n3, g3, z2);
      null === t2 ? l3 = n3 : t2.sibling = n3;
      t2 = n3;
      u2 = q2;
    }
    if (z2 === h3.length)
      return c(e3, u2), l3;
    if (null === u2) {
      for (; z2 < h3.length; z2++)
        u2 = A2(e3, h3[z2], k2), null !== u2 && (g3 = f2(u2, g3, z2), null === t2 ? l3 = u2 : t2.sibling = u2, t2 = u2);
      return l3;
    }
    for (u2 = d(e3, u2); z2 < h3.length; z2++)
      q2 = C2(u2, e3, z2, h3[z2], k2), null !== q2 && (a && null !== q2.alternate && u2.delete(null === q2.key ? z2 : q2.key), g3 = f2(q2, g3, z2), null === t2 ? l3 = q2 : t2.sibling = q2, t2 = q2);
    a && u2.forEach(function(a2) {
      return b(e3, a2);
    });
    return l3;
  }
  function w2(e3, g3, h3, k2) {
    var l3 = La(h3);
    if ("function" !== typeof l3)
      throw Error(y(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(y(151));
    for (var t2 = l3 = null, u2 = g3, z2 = g3 = 0, q2 = null, n3 = h3.next(); null !== u2 && !n3.done; z2++, n3 = h3.next()) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var w3 = p2(e3, u2, n3.value, k2);
      if (null === w3) {
        null === u2 && (u2 = q2);
        break;
      }
      a && u2 && null === w3.alternate && b(e3, u2);
      g3 = f2(w3, g3, z2);
      null === t2 ? l3 = w3 : t2.sibling = w3;
      t2 = w3;
      u2 = q2;
    }
    if (n3.done)
      return c(e3, u2), l3;
    if (null === u2) {
      for (; !n3.done; z2++, n3 = h3.next())
        n3 = A2(e3, n3.value, k2), null !== n3 && (g3 = f2(n3, g3, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
      return l3;
    }
    for (u2 = d(e3, u2); !n3.done; z2++, n3 = h3.next())
      n3 = C2(u2, e3, z2, n3.value, k2), null !== n3 && (a && null !== n3.alternate && u2.delete(null === n3.key ? z2 : n3.key), g3 = f2(n3, g3, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
    a && u2.forEach(function(a2) {
      return b(e3, a2);
    });
    return l3;
  }
  return function(a2, d2, f3, h3) {
    var k2 = "object" === typeof f3 && null !== f3 && f3.type === ua && null === f3.key;
    k2 && (f3 = f3.props.children);
    var l3 = "object" === typeof f3 && null !== f3;
    if (l3)
      switch (f3.$$typeof) {
        case sa:
          a: {
            l3 = f3.key;
            for (k2 = d2; null !== k2; ) {
              if (k2.key === l3) {
                switch (k2.tag) {
                  case 7:
                    if (f3.type === ua) {
                      c(a2, k2.sibling);
                      d2 = e2(k2, f3.props.children);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                    break;
                  default:
                    if (k2.elementType === f3.type) {
                      c(a2, k2.sibling);
                      d2 = e2(k2, f3.props);
                      d2.ref = Qg(a2, k2, f3);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                }
                c(a2, k2);
                break;
              } else
                b(a2, k2);
              k2 = k2.sibling;
            }
            f3.type === ua ? (d2 = Xg(f3.props.children, a2.mode, h3, f3.key), d2.return = a2, a2 = d2) : (h3 = Vg(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = Qg(a2, d2, f3), h3.return = a2, a2 = h3);
          }
          return g2(a2);
        case ta:
          a: {
            for (k2 = f3.key; null !== d2; ) {
              if (d2.key === k2)
                if (4 === d2.tag && d2.stateNode.containerInfo === f3.containerInfo && d2.stateNode.implementation === f3.implementation) {
                  c(a2, d2.sibling);
                  d2 = e2(d2, f3.children || []);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
              else
                b(a2, d2);
              d2 = d2.sibling;
            }
            d2 = Wg(f3, a2.mode, h3);
            d2.return = a2;
            a2 = d2;
          }
          return g2(a2);
      }
    if ("string" === typeof f3 || "number" === typeof f3)
      return f3 = "" + f3, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e2(d2, f3), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Ug(f3, a2.mode, h3), d2.return = a2, a2 = d2), g2(a2);
    if (Pg(f3))
      return x2(a2, d2, f3, h3);
    if (La(f3))
      return w2(a2, d2, f3, h3);
    l3 && Rg(a2, f3);
    if ("undefined" === typeof f3 && !k2)
      switch (a2.tag) {
        case 1:
        case 22:
        case 0:
        case 11:
        case 15:
          throw Error(y(152, Ra(a2.type) || "Component"));
      }
    return c(a2, d2);
  };
}
var Yg = Sg(true), Zg = Sg(false), $g = {}, ah = Bf($g), bh = Bf($g), ch = Bf($g);
function dh(a) {
  if (a === $g)
    throw Error(y(174));
  return a;
}
function eh(a, b) {
  I(ch, b);
  I(bh, a);
  I(ah, $g);
  a = b.nodeType;
  switch (a) {
    case 9:
    case 11:
      b = (b = b.documentElement) ? b.namespaceURI : mb(null, "");
      break;
    default:
      a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = mb(b, a);
  }
  H(ah);
  I(ah, b);
}
function fh() {
  H(ah);
  H(bh);
  H(ch);
}
function gh(a) {
  dh(ch.current);
  var b = dh(ah.current);
  var c = mb(b, a.type);
  b !== c && (I(bh, a), I(ah, c));
}
function hh(a) {
  bh.current === a && (H(ah), H(bh));
}
var P = Bf(0);
function ih(a) {
  for (var b = a; null !== b; ) {
    if (13 === b.tag) {
      var c = b.memoizedState;
      if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data))
        return b;
    } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
      if (0 !== (b.flags & 64))
        return b;
    } else if (null !== b.child) {
      b.child.return = b;
      b = b.child;
      continue;
    }
    if (b === a)
      break;
    for (; null === b.sibling; ) {
      if (null === b.return || b.return === a)
        return null;
      b = b.return;
    }
    b.sibling.return = b.return;
    b = b.sibling;
  }
  return null;
}
var jh = null, kh = null, lh = false;
function mh(a, b) {
  var c = nh(5, null, null, 0);
  c.elementType = "DELETED";
  c.type = "DELETED";
  c.stateNode = b;
  c.return = a;
  c.flags = 8;
  null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
}
function oh(a, b) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
      return null !== b ? (a.stateNode = b, true) : false;
    case 6:
      return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, true) : false;
    case 13:
      return false;
    default:
      return false;
  }
}
function ph(a) {
  if (lh) {
    var b = kh;
    if (b) {
      var c = b;
      if (!oh(a, b)) {
        b = rf(c.nextSibling);
        if (!b || !oh(a, b)) {
          a.flags = a.flags & -1025 | 2;
          lh = false;
          jh = a;
          return;
        }
        mh(jh, c);
      }
      jh = a;
      kh = rf(b.firstChild);
    } else
      a.flags = a.flags & -1025 | 2, lh = false, jh = a;
  }
}
function qh(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
    a = a.return;
  jh = a;
}
function rh(a) {
  if (a !== jh)
    return false;
  if (!lh)
    return qh(a), lh = true, false;
  var b = a.type;
  if (5 !== a.tag || "head" !== b && "body" !== b && !nf(b, a.memoizedProps))
    for (b = kh; b; )
      mh(a, b), b = rf(b.nextSibling);
  qh(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a)
      throw Error(y(317));
    a: {
      a = a.nextSibling;
      for (b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("/$" === c) {
            if (0 === b) {
              kh = rf(a.nextSibling);
              break a;
            }
            b--;
          } else
            "$" !== c && "$!" !== c && "$?" !== c || b++;
        }
        a = a.nextSibling;
      }
      kh = null;
    }
  } else
    kh = jh ? rf(a.stateNode.nextSibling) : null;
  return true;
}
function sh() {
  kh = jh = null;
  lh = false;
}
var th = [];
function uh() {
  for (var a = 0; a < th.length; a++)
    th[a]._workInProgressVersionPrimary = null;
  th.length = 0;
}
var vh = ra.ReactCurrentDispatcher, wh = ra.ReactCurrentBatchConfig, xh = 0, R$1 = null, S = null, T = null, yh = false, zh = false;
function Ah() {
  throw Error(y(321));
}
function Bh(a, b) {
  if (null === b)
    return false;
  for (var c = 0; c < b.length && c < a.length; c++)
    if (!He(a[c], b[c]))
      return false;
  return true;
}
function Ch(a, b, c, d, e2, f2) {
  xh = f2;
  R$1 = b;
  b.memoizedState = null;
  b.updateQueue = null;
  b.lanes = 0;
  vh.current = null === a || null === a.memoizedState ? Dh : Eh;
  a = c(d, e2);
  if (zh) {
    f2 = 0;
    do {
      zh = false;
      if (!(25 > f2))
        throw Error(y(301));
      f2 += 1;
      T = S = null;
      b.updateQueue = null;
      vh.current = Fh;
      a = c(d, e2);
    } while (zh);
  }
  vh.current = Gh;
  b = null !== S && null !== S.next;
  xh = 0;
  T = S = R$1 = null;
  yh = false;
  if (b)
    throw Error(y(300));
  return a;
}
function Hh() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === T ? R$1.memoizedState = T = a : T = T.next = a;
  return T;
}
function Ih() {
  if (null === S) {
    var a = R$1.alternate;
    a = null !== a ? a.memoizedState : null;
  } else
    a = S.next;
  var b = null === T ? R$1.memoizedState : T.next;
  if (null !== b)
    T = b, S = a;
  else {
    if (null === a)
      throw Error(y(310));
    S = a;
    a = { memoizedState: S.memoizedState, baseState: S.baseState, baseQueue: S.baseQueue, queue: S.queue, next: null };
    null === T ? R$1.memoizedState = T = a : T = T.next = a;
  }
  return T;
}
function Jh(a, b) {
  return "function" === typeof b ? b(a) : b;
}
function Kh(a) {
  var b = Ih(), c = b.queue;
  if (null === c)
    throw Error(y(311));
  c.lastRenderedReducer = a;
  var d = S, e2 = d.baseQueue, f2 = c.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d.baseQueue = e2 = f2;
    c.pending = null;
  }
  if (null !== e2) {
    e2 = e2.next;
    d = d.baseState;
    var h2 = g2 = f2 = null, k = e2;
    do {
      var l2 = k.lane;
      if ((xh & l2) === l2)
        null !== h2 && (h2 = h2.next = { lane: 0, action: k.action, eagerReducer: k.eagerReducer, eagerState: k.eagerState, next: null }), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);
      else {
        var n2 = {
          lane: l2,
          action: k.action,
          eagerReducer: k.eagerReducer,
          eagerState: k.eagerState,
          next: null
        };
        null === h2 ? (g2 = h2 = n2, f2 = d) : h2 = h2.next = n2;
        R$1.lanes |= l2;
        Dg |= l2;
      }
      k = k.next;
    } while (null !== k && k !== e2);
    null === h2 ? f2 = d : h2.next = g2;
    He(d, b.memoizedState) || (ug = true);
    b.memoizedState = d;
    b.baseState = f2;
    b.baseQueue = h2;
    c.lastRenderedState = d;
  }
  return [b.memoizedState, c.dispatch];
}
function Lh(a) {
  var b = Ih(), c = b.queue;
  if (null === c)
    throw Error(y(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch, e2 = c.pending, f2 = b.memoizedState;
  if (null !== e2) {
    c.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b.memoizedState) || (ug = true);
    b.memoizedState = f2;
    null === b.baseQueue && (b.baseState = f2);
    c.lastRenderedState = f2;
  }
  return [f2, d];
}
function Mh(a, b, c) {
  var d = b._getVersion;
  d = d(b._source);
  var e2 = b._workInProgressVersionPrimary;
  if (null !== e2)
    a = e2 === d;
  else if (a = a.mutableReadLanes, a = (xh & a) === a)
    b._workInProgressVersionPrimary = d, th.push(b);
  if (a)
    return c(b._source);
  th.push(b);
  throw Error(y(350));
}
function Nh(a, b, c, d) {
  var e2 = U;
  if (null === e2)
    throw Error(y(349));
  var f2 = b._getVersion, g2 = f2(b._source), h2 = vh.current, k = h2.useState(function() {
    return Mh(e2, b, c);
  }), l2 = k[1], n2 = k[0];
  k = T;
  var A2 = a.memoizedState, p2 = A2.refs, C2 = p2.getSnapshot, x2 = A2.source;
  A2 = A2.subscribe;
  var w2 = R$1;
  a.memoizedState = { refs: p2, source: b, subscribe: d };
  h2.useEffect(function() {
    p2.getSnapshot = c;
    p2.setSnapshot = l2;
    var a2 = f2(b._source);
    if (!He(g2, a2)) {
      a2 = c(b._source);
      He(n2, a2) || (l2(a2), a2 = Ig(w2), e2.mutableReadLanes |= a2 & e2.pendingLanes);
      a2 = e2.mutableReadLanes;
      e2.entangledLanes |= a2;
      for (var d2 = e2.entanglements, h3 = a2; 0 < h3; ) {
        var k2 = 31 - Vc(h3), v2 = 1 << k2;
        d2[k2] |= a2;
        h3 &= ~v2;
      }
    }
  }, [c, b, d]);
  h2.useEffect(function() {
    return d(b._source, function() {
      var a2 = p2.getSnapshot, c2 = p2.setSnapshot;
      try {
        c2(a2(b._source));
        var d2 = Ig(w2);
        e2.mutableReadLanes |= d2 & e2.pendingLanes;
      } catch (q2) {
        c2(function() {
          throw q2;
        });
      }
    });
  }, [b, d]);
  He(C2, c) && He(x2, b) && He(A2, d) || (a = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n2 }, a.dispatch = l2 = Oh.bind(null, R$1, a), k.queue = a, k.baseQueue = null, n2 = Mh(e2, b, c), k.memoizedState = k.baseState = n2);
  return n2;
}
function Ph(a, b, c) {
  var d = Ih();
  return Nh(d, a, b, c);
}
function Qh(a) {
  var b = Hh();
  "function" === typeof a && (a = a());
  b.memoizedState = b.baseState = a;
  a = b.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a };
  a = a.dispatch = Oh.bind(null, R$1, a);
  return [b.memoizedState, a];
}
function Rh(a, b, c, d) {
  a = { tag: a, create: b, destroy: c, deps: d, next: null };
  b = R$1.updateQueue;
  null === b ? (b = { lastEffect: null }, R$1.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
  return a;
}
function Sh(a) {
  var b = Hh();
  a = { current: a };
  return b.memoizedState = a;
}
function Th() {
  return Ih().memoizedState;
}
function Uh(a, b, c, d) {
  var e2 = Hh();
  R$1.flags |= a;
  e2.memoizedState = Rh(1 | b, c, void 0, void 0 === d ? null : d);
}
function Vh(a, b, c, d) {
  var e2 = Ih();
  d = void 0 === d ? null : d;
  var f2 = void 0;
  if (null !== S) {
    var g2 = S.memoizedState;
    f2 = g2.destroy;
    if (null !== d && Bh(d, g2.deps)) {
      Rh(b, c, f2, d);
      return;
    }
  }
  R$1.flags |= a;
  e2.memoizedState = Rh(1 | b, c, f2, d);
}
function Wh(a, b) {
  return Uh(516, 4, a, b);
}
function Xh(a, b) {
  return Vh(516, 4, a, b);
}
function Yh(a, b) {
  return Vh(4, 2, a, b);
}
function Zh(a, b) {
  if ("function" === typeof b)
    return a = a(), b(a), function() {
      b(null);
    };
  if (null !== b && void 0 !== b)
    return a = a(), b.current = a, function() {
      b.current = null;
    };
}
function $h(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return Vh(4, 2, Zh.bind(null, b, a), c);
}
function ai() {
}
function bi(a, b) {
  var c = Ih();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Bh(b, d[1]))
    return d[0];
  c.memoizedState = [a, b];
  return a;
}
function ci(a, b) {
  var c = Ih();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Bh(b, d[1]))
    return d[0];
  a = a();
  c.memoizedState = [a, b];
  return a;
}
function di(a, b) {
  var c = eg();
  gg(98 > c ? 98 : c, function() {
    a(true);
  });
  gg(97 < c ? 97 : c, function() {
    var c2 = wh.transition;
    wh.transition = 1;
    try {
      a(false), b();
    } finally {
      wh.transition = c2;
    }
  });
}
function Oh(a, b, c) {
  var d = Hg(), e2 = Ig(a), f2 = { lane: e2, action: c, eagerReducer: null, eagerState: null, next: null }, g2 = b.pending;
  null === g2 ? f2.next = f2 : (f2.next = g2.next, g2.next = f2);
  b.pending = f2;
  g2 = a.alternate;
  if (a === R$1 || null !== g2 && g2 === R$1)
    zh = yh = true;
  else {
    if (0 === a.lanes && (null === g2 || 0 === g2.lanes) && (g2 = b.lastRenderedReducer, null !== g2))
      try {
        var h2 = b.lastRenderedState, k = g2(h2, c);
        f2.eagerReducer = g2;
        f2.eagerState = k;
        if (He(k, h2))
          return;
      } catch (l2) {
      } finally {
      }
    Jg(a, e2, d);
  }
}
var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false }, Dh = { readContext: vg, useCallback: function(a, b) {
  Hh().memoizedState = [a, void 0 === b ? null : b];
  return a;
}, useContext: vg, useEffect: Wh, useImperativeHandle: function(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return Uh(4, 2, Zh.bind(null, b, a), c);
}, useLayoutEffect: function(a, b) {
  return Uh(4, 2, a, b);
}, useMemo: function(a, b) {
  var c = Hh();
  b = void 0 === b ? null : b;
  a = a();
  c.memoizedState = [a, b];
  return a;
}, useReducer: function(a, b, c) {
  var d = Hh();
  b = void 0 !== c ? c(b) : b;
  d.memoizedState = d.baseState = b;
  a = d.queue = { pending: null, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
  a = a.dispatch = Oh.bind(null, R$1, a);
  return [d.memoizedState, a];
}, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Qh(a), c = b[0], d = b[1];
  Wh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Qh(false), b = a[0];
  a = di.bind(null, a[1]);
  Sh(a);
  return [a, b];
}, useMutableSource: function(a, b, c) {
  var d = Hh();
  d.memoizedState = { refs: { getSnapshot: b, setSnapshot: null }, source: a, subscribe: c };
  return Nh(d, a, b, c);
}, useOpaqueIdentifier: function() {
  if (lh) {
    var a = false, b = uf(function() {
      a || (a = true, c("r:" + (tf++).toString(36)));
      throw Error(y(355));
    }), c = Qh(b)[1];
    0 === (R$1.mode & 2) && (R$1.flags |= 516, Rh(5, function() {
      c("r:" + (tf++).toString(36));
    }, void 0, null));
    return b;
  }
  b = "r:" + (tf++).toString(36);
  Qh(b);
  return b;
}, unstable_isNewReconciler: false }, Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
  return Kh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Kh(Jh), c = b[0], d = b[1];
  Xh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Kh(Jh)[0];
  return [
    Th().current,
    a
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Kh(Jh)[0];
}, unstable_isNewReconciler: false }, Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
  return Lh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Lh(Jh), c = b[0], d = b[1];
  Xh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Lh(Jh)[0];
  return [
    Th().current,
    a
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Lh(Jh)[0];
}, unstable_isNewReconciler: false }, ei = ra.ReactCurrentOwner, ug = false;
function fi(a, b, c, d) {
  b.child = null === a ? Zg(b, null, c, d) : Yg(b, a.child, c, d);
}
function gi(a, b, c, d, e2) {
  c = c.render;
  var f2 = b.ref;
  tg(b, e2);
  d = Ch(a, b, c, d, f2, e2);
  if (null !== a && !ug)
    return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e2, hi(a, b, e2);
  b.flags |= 1;
  fi(a, b, d, e2);
  return b.child;
}
function ii(a, b, c, d, e2, f2) {
  if (null === a) {
    var g2 = c.type;
    if ("function" === typeof g2 && !ji(g2) && void 0 === g2.defaultProps && null === c.compare && void 0 === c.defaultProps)
      return b.tag = 15, b.type = g2, ki(a, b, g2, d, e2, f2);
    a = Vg(c.type, null, d, b, b.mode, f2);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  g2 = a.child;
  if (0 === (e2 & f2) && (e2 = g2.memoizedProps, c = c.compare, c = null !== c ? c : Je, c(e2, d) && a.ref === b.ref))
    return hi(a, b, f2);
  b.flags |= 1;
  a = Tg(g2, d);
  a.ref = b.ref;
  a.return = b;
  return b.child = a;
}
function ki(a, b, c, d, e2, f2) {
  if (null !== a && Je(a.memoizedProps, d) && a.ref === b.ref)
    if (ug = false, 0 !== (f2 & e2))
      0 !== (a.flags & 16384) && (ug = true);
    else
      return b.lanes = a.lanes, hi(a, b, f2);
  return li(a, b, c, d, f2);
}
function mi(a, b, c) {
  var d = b.pendingProps, e2 = d.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d.mode || "unstable-defer-without-hiding" === d.mode)
    if (0 === (b.mode & 4))
      b.memoizedState = { baseLanes: 0 }, ni(b, c);
    else if (0 !== (c & 1073741824))
      b.memoizedState = { baseLanes: 0 }, ni(b, null !== f2 ? f2.baseLanes : c);
    else
      return a = null !== f2 ? f2.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a }, ni(b, a), null;
  else
    null !== f2 ? (d = f2.baseLanes | c, b.memoizedState = null) : d = c, ni(b, d);
  fi(a, b, e2, c);
  return b.child;
}
function oi(a, b) {
  var c = b.ref;
  if (null === a && null !== c || null !== a && a.ref !== c)
    b.flags |= 128;
}
function li(a, b, c, d, e2) {
  var f2 = Ff(c) ? Df : M.current;
  f2 = Ef(b, f2);
  tg(b, e2);
  c = Ch(a, b, c, d, f2, e2);
  if (null !== a && !ug)
    return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e2, hi(a, b, e2);
  b.flags |= 1;
  fi(a, b, c, e2);
  return b.child;
}
function pi(a, b, c, d, e2) {
  if (Ff(c)) {
    var f2 = true;
    Jf(b);
  } else
    f2 = false;
  tg(b, e2);
  if (null === b.stateNode)
    null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), Mg(b, c, d), Og(b, c, d, e2), d = true;
  else if (null === a) {
    var g2 = b.stateNode, h2 = b.memoizedProps;
    g2.props = h2;
    var k = g2.context, l2 = c.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = vg(l2) : (l2 = Ff(c) ? Df : M.current, l2 = Ef(b, l2));
    var n2 = c.getDerivedStateFromProps, A2 = "function" === typeof n2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    A2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d || k !== l2) && Ng(b, g2, d, l2);
    wg = false;
    var p2 = b.memoizedState;
    g2.state = p2;
    Cg(b, d, g2, e2);
    k = b.memoizedState;
    h2 !== d || p2 !== k || N.current || wg ? ("function" === typeof n2 && (Gg(b, c, n2, d), k = b.memoizedState), (h2 = wg || Lg(b, c, h2, d, p2, k, l2)) ? (A2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b.flags |= 4)) : ("function" === typeof g2.componentDidMount && (b.flags |= 4), b.memoizedProps = d, b.memoizedState = k), g2.props = d, g2.state = k, g2.context = l2, d = h2) : ("function" === typeof g2.componentDidMount && (b.flags |= 4), d = false);
  } else {
    g2 = b.stateNode;
    yg(a, b);
    h2 = b.memoizedProps;
    l2 = b.type === b.elementType ? h2 : lg(b.type, h2);
    g2.props = l2;
    A2 = b.pendingProps;
    p2 = g2.context;
    k = c.contextType;
    "object" === typeof k && null !== k ? k = vg(k) : (k = Ff(c) ? Df : M.current, k = Ef(b, k));
    var C2 = c.getDerivedStateFromProps;
    (n2 = "function" === typeof C2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== A2 || p2 !== k) && Ng(b, g2, d, k);
    wg = false;
    p2 = b.memoizedState;
    g2.state = p2;
    Cg(b, d, g2, e2);
    var x2 = b.memoizedState;
    h2 !== A2 || p2 !== x2 || N.current || wg ? ("function" === typeof C2 && (Gg(b, c, C2, d), x2 = b.memoizedState), (l2 = wg || Lg(b, c, l2, d, p2, x2, k)) ? (n2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d, x2, k), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d, x2, k)), "function" === typeof g2.componentDidUpdate && (b.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b.flags |= 256)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 256), b.memoizedProps = d, b.memoizedState = x2), g2.props = d, g2.state = x2, g2.context = k, d = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 256), d = false);
  }
  return qi(a, b, c, d, f2, e2);
}
function qi(a, b, c, d, e2, f2) {
  oi(a, b);
  var g2 = 0 !== (b.flags & 64);
  if (!d && !g2)
    return e2 && Kf(b, c, false), hi(a, b, f2);
  d = b.stateNode;
  ei.current = b;
  var h2 = g2 && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
  b.flags |= 1;
  null !== a && g2 ? (b.child = Yg(b, a.child, null, f2), b.child = Yg(b, null, h2, f2)) : fi(a, b, h2, f2);
  b.memoizedState = d.state;
  e2 && Kf(b, c, true);
  return b.child;
}
function ri(a) {
  var b = a.stateNode;
  b.pendingContext ? Hf(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Hf(a, b.context, false);
  eh(a, b.containerInfo);
}
var si = { dehydrated: null, retryLane: 0 };
function ti(a, b, c) {
  var d = b.pendingProps, e2 = P.current, f2 = false, g2;
  (g2 = 0 !== (b.flags & 64)) || (g2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
  g2 ? (f2 = true, b.flags &= -65) : null !== a && null === a.memoizedState || void 0 === d.fallback || true === d.unstable_avoidThisFallback || (e2 |= 1);
  I(P, e2 & 1);
  if (null === a) {
    void 0 !== d.fallback && ph(b);
    a = d.children;
    e2 = d.fallback;
    if (f2)
      return a = ui(b, a, e2, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, a;
    if ("number" === typeof d.unstable_expectedLoadTime)
      return a = ui(b, a, e2, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, b.lanes = 33554432, a;
    c = vi({ mode: "visible", children: a }, b.mode, c, null);
    c.return = b;
    return b.child = c;
  }
  if (null !== a.memoizedState) {
    if (f2)
      return d = wi(a, b, d.children, d.fallback, c), f2 = b.child, e2 = a.child.memoizedState, f2.memoizedState = null === e2 ? { baseLanes: c } : { baseLanes: e2.baseLanes | c }, f2.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
    c = xi(a, b, d.children, c);
    b.memoizedState = null;
    return c;
  }
  if (f2)
    return d = wi(a, b, d.children, d.fallback, c), f2 = b.child, e2 = a.child.memoizedState, f2.memoizedState = null === e2 ? { baseLanes: c } : { baseLanes: e2.baseLanes | c }, f2.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
  c = xi(a, b, d.children, c);
  b.memoizedState = null;
  return c;
}
function ui(a, b, c, d) {
  var e2 = a.mode, f2 = a.child;
  b = { mode: "hidden", children: b };
  0 === (e2 & 2) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = b) : f2 = vi(b, e2, 0, null);
  c = Xg(c, e2, d, null);
  f2.return = a;
  c.return = a;
  f2.sibling = c;
  a.child = f2;
  return c;
}
function xi(a, b, c, d) {
  var e2 = a.child;
  a = e2.sibling;
  c = Tg(e2, { mode: "visible", children: c });
  0 === (b.mode & 2) && (c.lanes = d);
  c.return = b;
  c.sibling = null;
  null !== a && (a.nextEffect = null, a.flags = 8, b.firstEffect = b.lastEffect = a);
  return b.child = c;
}
function wi(a, b, c, d, e2) {
  var f2 = b.mode, g2 = a.child;
  a = g2.sibling;
  var h2 = { mode: "hidden", children: c };
  0 === (f2 & 2) && b.child !== g2 ? (c = b.child, c.childLanes = 0, c.pendingProps = h2, g2 = c.lastEffect, null !== g2 ? (b.firstEffect = c.firstEffect, b.lastEffect = g2, g2.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Tg(g2, h2);
  null !== a ? d = Tg(a, d) : (d = Xg(d, f2, e2, null), d.flags |= 2);
  d.return = b;
  c.return = b;
  c.sibling = d;
  b.child = c;
  return d;
}
function yi(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  null !== c && (c.lanes |= b);
  sg(a.return, b);
}
function zi(a, b, c, d, e2, f2) {
  var g2 = a.memoizedState;
  null === g2 ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e2, lastEffect: f2 } : (g2.isBackwards = b, g2.rendering = null, g2.renderingStartTime = 0, g2.last = d, g2.tail = c, g2.tailMode = e2, g2.lastEffect = f2);
}
function Ai(a, b, c) {
  var d = b.pendingProps, e2 = d.revealOrder, f2 = d.tail;
  fi(a, b, d.children, c);
  d = P.current;
  if (0 !== (d & 2))
    d = d & 1 | 2, b.flags |= 64;
  else {
    if (null !== a && 0 !== (a.flags & 64))
      a:
        for (a = b.child; null !== a; ) {
          if (13 === a.tag)
            null !== a.memoizedState && yi(a, c);
          else if (19 === a.tag)
            yi(a, c);
          else if (null !== a.child) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b)
            break a;
          for (; null === a.sibling; ) {
            if (null === a.return || a.return === b)
              break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
    d &= 1;
  }
  I(P, d);
  if (0 === (b.mode & 2))
    b.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c = b.child;
        for (e2 = null; null !== c; )
          a = c.alternate, null !== a && null === ih(a) && (e2 = c), c = c.sibling;
        c = e2;
        null === c ? (e2 = b.child, b.child = null) : (e2 = c.sibling, c.sibling = null);
        zi(b, false, e2, c, f2, b.lastEffect);
        break;
      case "backwards":
        c = null;
        e2 = b.child;
        for (b.child = null; null !== e2; ) {
          a = e2.alternate;
          if (null !== a && null === ih(a)) {
            b.child = e2;
            break;
          }
          a = e2.sibling;
          e2.sibling = c;
          c = e2;
          e2 = a;
        }
        zi(b, true, c, null, f2, b.lastEffect);
        break;
      case "together":
        zi(b, false, null, null, void 0, b.lastEffect);
        break;
      default:
        b.memoizedState = null;
    }
  return b.child;
}
function hi(a, b, c) {
  null !== a && (b.dependencies = a.dependencies);
  Dg |= b.lanes;
  if (0 !== (c & b.childLanes)) {
    if (null !== a && b.child !== a.child)
      throw Error(y(153));
    if (null !== b.child) {
      a = b.child;
      c = Tg(a, a.pendingProps);
      b.child = c;
      for (c.return = b; null !== a.sibling; )
        a = a.sibling, c = c.sibling = Tg(a, a.pendingProps), c.return = b;
      c.sibling = null;
    }
    return b.child;
  }
  return null;
}
var Bi, Ci, Di, Ei;
Bi = function(a, b) {
  for (var c = b.child; null !== c; ) {
    if (5 === c.tag || 6 === c.tag)
      a.appendChild(c.stateNode);
    else if (4 !== c.tag && null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b)
      break;
    for (; null === c.sibling; ) {
      if (null === c.return || c.return === b)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
};
Ci = function() {
};
Di = function(a, b, c, d) {
  var e2 = a.memoizedProps;
  if (e2 !== d) {
    a = b.stateNode;
    dh(ah.current);
    var f2 = null;
    switch (c) {
      case "input":
        e2 = Ya(a, e2);
        d = Ya(a, d);
        f2 = [];
        break;
      case "option":
        e2 = eb(a, e2);
        d = eb(a, d);
        f2 = [];
        break;
      case "select":
        e2 = m$1({}, e2, { value: void 0 });
        d = m$1({}, d, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a, e2);
        d = gb(a, d);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d.onClick && (a.onclick = jf);
    }
    vb(c, d);
    var g2;
    c = null;
    for (l2 in e2)
      if (!d.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c || (c = {}), c[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ca.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d) {
      var k = d[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d.hasOwnProperty(l2) && k !== h2 && (null != k || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k && k.hasOwnProperty(g2) || (c || (c = {}), c[g2] = "");
            for (g2 in k)
              k.hasOwnProperty(g2) && h2[g2] !== k[g2] && (c || (c = {}), c[g2] = k[g2]);
          } else
            c || (f2 || (f2 = []), f2.push(l2, c)), c = k;
        else
          "dangerouslySetInnerHTML" === l2 ? (k = k ? k.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k && h2 !== k && (f2 = f2 || []).push(l2, k)) : "children" === l2 ? "string" !== typeof k && "number" !== typeof k || (f2 = f2 || []).push(l2, "" + k) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ca.hasOwnProperty(l2) ? (null != k && "onScroll" === l2 && G("scroll", a), f2 || h2 === k || (f2 = [])) : "object" === typeof k && null !== k && k.$$typeof === Ga ? k.toString() : (f2 = f2 || []).push(l2, k));
    }
    c && (f2 = f2 || []).push("style", c);
    var l2 = f2;
    if (b.updateQueue = l2)
      b.flags |= 4;
  }
};
Ei = function(a, b, c, d) {
  c !== d && (b.flags |= 4);
};
function Fi(a, b) {
  if (!lh)
    switch (a.tailMode) {
      case "hidden":
        b = a.tail;
        for (var c = null; null !== b; )
          null !== b.alternate && (c = b), b = b.sibling;
        null === c ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; null !== c; )
          null !== c.alternate && (d = c), c = c.sibling;
        null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
}
function Gi(a, b, c) {
  var d = b.pendingProps;
  switch (b.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return null;
    case 1:
      return Ff(b.type) && Gf(), null;
    case 3:
      fh();
      H(N);
      H(M);
      uh();
      d = b.stateNode;
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (null === a || null === a.child)
        rh(b) ? b.flags |= 4 : d.hydrate || (b.flags |= 256);
      Ci(b);
      return null;
    case 5:
      hh(b);
      var e2 = dh(ch.current);
      c = b.type;
      if (null !== a && null != b.stateNode)
        Di(a, b, c, d, e2), a.ref !== b.ref && (b.flags |= 128);
      else {
        if (!d) {
          if (null === b.stateNode)
            throw Error(y(166));
          return null;
        }
        a = dh(ah.current);
        if (rh(b)) {
          d = b.stateNode;
          c = b.type;
          var f2 = b.memoizedProps;
          d[wf] = b;
          d[xf] = f2;
          switch (c) {
            case "dialog":
              G("cancel", d);
              G("close", d);
              break;
            case "iframe":
            case "object":
            case "embed":
              G("load", d);
              break;
            case "video":
            case "audio":
              for (a = 0; a < Xe.length; a++)
                G(Xe[a], d);
              break;
            case "source":
              G("error", d);
              break;
            case "img":
            case "image":
            case "link":
              G("error", d);
              G("load", d);
              break;
            case "details":
              G("toggle", d);
              break;
            case "input":
              Za(d, f2);
              G("invalid", d);
              break;
            case "select":
              d._wrapperState = { wasMultiple: !!f2.multiple };
              G("invalid", d);
              break;
            case "textarea":
              hb(d, f2), G("invalid", d);
          }
          vb(c, f2);
          a = null;
          for (var g2 in f2)
            f2.hasOwnProperty(g2) && (e2 = f2[g2], "children" === g2 ? "string" === typeof e2 ? d.textContent !== e2 && (a = ["children", e2]) : "number" === typeof e2 && d.textContent !== "" + e2 && (a = ["children", "" + e2]) : ca.hasOwnProperty(g2) && null != e2 && "onScroll" === g2 && G("scroll", d));
          switch (c) {
            case "input":
              Va(d);
              cb(d, f2, true);
              break;
            case "textarea":
              Va(d);
              jb(d);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d.onclick = jf);
          }
          d = a;
          b.updateQueue = d;
          null !== d && (b.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          a === kb.html && (a = lb(c));
          a === kb.html ? "script" === c ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g2.createElement(c, { is: d.is }) : (a = g2.createElement(c), "select" === c && (g2 = a, d.multiple ? g2.multiple = true : d.size && (g2.size = d.size))) : a = g2.createElementNS(a, c);
          a[wf] = b;
          a[xf] = d;
          Bi(a, b, false, false);
          b.stateNode = a;
          g2 = wb(c, d);
          switch (c) {
            case "dialog":
              G("cancel", a);
              G("close", a);
              e2 = d;
              break;
            case "iframe":
            case "object":
            case "embed":
              G("load", a);
              e2 = d;
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < Xe.length; e2++)
                G(Xe[e2], a);
              e2 = d;
              break;
            case "source":
              G("error", a);
              e2 = d;
              break;
            case "img":
            case "image":
            case "link":
              G("error", a);
              G("load", a);
              e2 = d;
              break;
            case "details":
              G("toggle", a);
              e2 = d;
              break;
            case "input":
              Za(a, d);
              e2 = Ya(a, d);
              G("invalid", a);
              break;
            case "option":
              e2 = eb(a, d);
              break;
            case "select":
              a._wrapperState = { wasMultiple: !!d.multiple };
              e2 = m$1({}, d, { value: void 0 });
              G("invalid", a);
              break;
            case "textarea":
              hb(a, d);
              e2 = gb(a, d);
              G("invalid", a);
              break;
            default:
              e2 = d;
          }
          vb(c, e2);
          var h2 = e2;
          for (f2 in h2)
            if (h2.hasOwnProperty(f2)) {
              var k = h2[f2];
              "style" === f2 ? tb(a, k) : "dangerouslySetInnerHTML" === f2 ? (k = k ? k.__html : void 0, null != k && ob(a, k)) : "children" === f2 ? "string" === typeof k ? ("textarea" !== c || "" !== k) && pb(a, k) : "number" === typeof k && pb(a, "" + k) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ca.hasOwnProperty(f2) ? null != k && "onScroll" === f2 && G("scroll", a) : null != k && qa(a, f2, k, g2));
            }
          switch (c) {
            case "input":
              Va(a);
              cb(a, d, false);
              break;
            case "textarea":
              Va(a);
              jb(a);
              break;
            case "option":
              null != d.value && a.setAttribute("value", "" + Sa(d.value));
              break;
            case "select":
              a.multiple = !!d.multiple;
              f2 = d.value;
              null != f2 ? fb(a, !!d.multiple, f2, false) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, true);
              break;
            default:
              "function" === typeof e2.onClick && (a.onclick = jf);
          }
          mf(c, d) && (b.flags |= 4);
        }
        null !== b.ref && (b.flags |= 128);
      }
      return null;
    case 6:
      if (a && null != b.stateNode)
        Ei(a, b, a.memoizedProps, d);
      else {
        if ("string" !== typeof d && null === b.stateNode)
          throw Error(y(166));
        c = dh(ch.current);
        dh(ah.current);
        rh(b) ? (d = b.stateNode, c = b.memoizedProps, d[wf] = b, d.nodeValue !== c && (b.flags |= 4)) : (d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[wf] = b, b.stateNode = d);
      }
      return null;
    case 13:
      H(P);
      d = b.memoizedState;
      if (0 !== (b.flags & 64))
        return b.lanes = c, b;
      d = null !== d;
      c = false;
      null === a ? void 0 !== b.memoizedProps.fallback && rh(b) : c = null !== a.memoizedState;
      if (d && !c && 0 !== (b.mode & 2))
        if (null === a && true !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (P.current & 1))
          0 === V && (V = 3);
        else {
          if (0 === V || 3 === V)
            V = 4;
          null === U || 0 === (Dg & 134217727) && 0 === (Hi & 134217727) || Ii(U, W);
        }
      if (d || c)
        b.flags |= 4;
      return null;
    case 4:
      return fh(), Ci(b), null === a && cf(b.stateNode.containerInfo), null;
    case 10:
      return rg(b), null;
    case 17:
      return Ff(b.type) && Gf(), null;
    case 19:
      H(P);
      d = b.memoizedState;
      if (null === d)
        return null;
      f2 = 0 !== (b.flags & 64);
      g2 = d.rendering;
      if (null === g2)
        if (f2)
          Fi(d, false);
        else {
          if (0 !== V || null !== a && 0 !== (a.flags & 64))
            for (a = b.child; null !== a; ) {
              g2 = ih(a);
              if (null !== g2) {
                b.flags |= 64;
                Fi(d, false);
                f2 = g2.updateQueue;
                null !== f2 && (b.updateQueue = f2, b.flags |= 4);
                null === d.lastEffect && (b.firstEffect = null);
                b.lastEffect = d.lastEffect;
                d = c;
                for (c = b.child; null !== c; )
                  f2 = c, a = d, f2.flags &= 2, f2.nextEffect = null, f2.firstEffect = null, f2.lastEffect = null, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                I(P, P.current & 1 | 2);
                return b.child;
              }
              a = a.sibling;
            }
          null !== d.tail && O() > Ji && (b.flags |= 64, f2 = true, Fi(d, false), b.lanes = 33554432);
        }
      else {
        if (!f2)
          if (a = ih(g2), null !== a) {
            if (b.flags |= 64, f2 = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Fi(d, true), null === d.tail && "hidden" === d.tailMode && !g2.alternate && !lh)
              return b = b.lastEffect = d.lastEffect, null !== b && (b.nextEffect = null), null;
          } else
            2 * O() - d.renderingStartTime > Ji && 1073741824 !== c && (b.flags |= 64, f2 = true, Fi(d, false), b.lanes = 33554432);
        d.isBackwards ? (g2.sibling = b.child, b.child = g2) : (c = d.last, null !== c ? c.sibling = g2 : b.child = g2, d.last = g2);
      }
      return null !== d.tail ? (c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = O(), c.sibling = null, b = P.current, I(P, f2 ? b & 1 | 2 : b & 1), c) : null;
    case 23:
    case 24:
      return Ki(), null !== a && null !== a.memoizedState !== (null !== b.memoizedState) && "unstable-defer-without-hiding" !== d.mode && (b.flags |= 4), null;
  }
  throw Error(y(156, b.tag));
}
function Li(a) {
  switch (a.tag) {
    case 1:
      Ff(a.type) && Gf();
      var b = a.flags;
      return b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
    case 3:
      fh();
      H(N);
      H(M);
      uh();
      b = a.flags;
      if (0 !== (b & 64))
        throw Error(y(285));
      a.flags = b & -4097 | 64;
      return a;
    case 5:
      return hh(a), null;
    case 13:
      return H(P), b = a.flags, b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
    case 19:
      return H(P), null;
    case 4:
      return fh(), null;
    case 10:
      return rg(a), null;
    case 23:
    case 24:
      return Ki(), null;
    default:
      return null;
  }
}
function Mi(a, b) {
  try {
    var c = "", d = b;
    do
      c += Qa(d), d = d.return;
    while (d);
    var e2 = c;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b, stack: e2 };
}
function Ni(a, b) {
  try {
    console.error(b.value);
  } catch (c) {
    setTimeout(function() {
      throw c;
    });
  }
}
var Oi = "function" === typeof WeakMap ? WeakMap : Map;
function Pi(a, b, c) {
  c = zg(-1, c);
  c.tag = 3;
  c.payload = { element: null };
  var d = b.value;
  c.callback = function() {
    Qi || (Qi = true, Ri = d);
    Ni(a, b);
  };
  return c;
}
function Si(a, b, c) {
  c = zg(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;
  if ("function" === typeof d) {
    var e2 = b.value;
    c.payload = function() {
      Ni(a, b);
      return d(e2);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c.callback = function() {
    "function" !== typeof d && (null === Ti ? Ti = /* @__PURE__ */ new Set([this]) : Ti.add(this), Ni(a, b));
    var c2 = b.stack;
    this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
  });
  return c;
}
var Ui = "function" === typeof WeakSet ? WeakSet : Set;
function Vi(a) {
  var b = a.ref;
  if (null !== b)
    if ("function" === typeof b)
      try {
        b(null);
      } catch (c) {
        Wi(a, c);
      }
    else
      b.current = null;
}
function Xi(a, b) {
  switch (b.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      return;
    case 1:
      if (b.flags & 256 && null !== a) {
        var c = a.memoizedProps, d = a.memoizedState;
        a = b.stateNode;
        b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : lg(b.type, c), d);
        a.__reactInternalSnapshotBeforeUpdate = b;
      }
      return;
    case 3:
      b.flags & 256 && qf(b.stateNode.containerInfo);
      return;
    case 5:
    case 6:
    case 4:
    case 17:
      return;
  }
  throw Error(y(163));
}
function Yi(a, b, c) {
  switch (c.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      b = c.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        a = b = b.next;
        do {
          if (3 === (a.tag & 3)) {
            var d = a.create;
            a.destroy = d();
          }
          a = a.next;
        } while (a !== b);
      }
      b = c.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        a = b = b.next;
        do {
          var e2 = a;
          d = e2.next;
          e2 = e2.tag;
          0 !== (e2 & 4) && 0 !== (e2 & 1) && (Zi(c, a), $i(c, a));
          a = d;
        } while (a !== b);
      }
      return;
    case 1:
      a = c.stateNode;
      c.flags & 4 && (null === b ? a.componentDidMount() : (d = c.elementType === c.type ? b.memoizedProps : lg(c.type, b.memoizedProps), a.componentDidUpdate(d, b.memoizedState, a.__reactInternalSnapshotBeforeUpdate)));
      b = c.updateQueue;
      null !== b && Eg(c, b, a);
      return;
    case 3:
      b = c.updateQueue;
      if (null !== b) {
        a = null;
        if (null !== c.child)
          switch (c.child.tag) {
            case 5:
              a = c.child.stateNode;
              break;
            case 1:
              a = c.child.stateNode;
          }
        Eg(c, b, a);
      }
      return;
    case 5:
      a = c.stateNode;
      null === b && c.flags & 4 && mf(c.type, c.memoizedProps) && a.focus();
      return;
    case 6:
      return;
    case 4:
      return;
    case 12:
      return;
    case 13:
      null === c.memoizedState && (c = c.alternate, null !== c && (c = c.memoizedState, null !== c && (c = c.dehydrated, null !== c && Cc(c))));
      return;
    case 19:
    case 17:
    case 20:
    case 21:
    case 23:
    case 24:
      return;
  }
  throw Error(y(163));
}
function aj(a, b) {
  for (var c = a; ; ) {
    if (5 === c.tag) {
      var d = c.stateNode;
      if (b)
        d = d.style, "function" === typeof d.setProperty ? d.setProperty("display", "none", "important") : d.display = "none";
      else {
        d = c.stateNode;
        var e2 = c.memoizedProps.style;
        e2 = void 0 !== e2 && null !== e2 && e2.hasOwnProperty("display") ? e2.display : null;
        d.style.display = sb("display", e2);
      }
    } else if (6 === c.tag)
      c.stateNode.nodeValue = b ? "" : c.memoizedProps;
    else if ((23 !== c.tag && 24 !== c.tag || null === c.memoizedState || c === a) && null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === a)
      break;
    for (; null === c.sibling; ) {
      if (null === c.return || c.return === a)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
}
function bj(a, b) {
  if (Mf && "function" === typeof Mf.onCommitFiberUnmount)
    try {
      Mf.onCommitFiberUnmount(Lf, b);
    } catch (f2) {
    }
  switch (b.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      a = b.updateQueue;
      if (null !== a && (a = a.lastEffect, null !== a)) {
        var c = a = a.next;
        do {
          var d = c, e2 = d.destroy;
          d = d.tag;
          if (void 0 !== e2)
            if (0 !== (d & 4))
              Zi(b, c);
            else {
              d = b;
              try {
                e2();
              } catch (f2) {
                Wi(d, f2);
              }
            }
          c = c.next;
        } while (c !== a);
      }
      break;
    case 1:
      Vi(b);
      a = b.stateNode;
      if ("function" === typeof a.componentWillUnmount)
        try {
          a.props = b.memoizedProps, a.state = b.memoizedState, a.componentWillUnmount();
        } catch (f2) {
          Wi(b, f2);
        }
      break;
    case 5:
      Vi(b);
      break;
    case 4:
      cj(a, b);
  }
}
function dj(a) {
  a.alternate = null;
  a.child = null;
  a.dependencies = null;
  a.firstEffect = null;
  a.lastEffect = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.return = null;
  a.updateQueue = null;
}
function ej(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function fj(a) {
  a: {
    for (var b = a.return; null !== b; ) {
      if (ej(b))
        break a;
      b = b.return;
    }
    throw Error(y(160));
  }
  var c = b;
  b = c.stateNode;
  switch (c.tag) {
    case 5:
      var d = false;
      break;
    case 3:
      b = b.containerInfo;
      d = true;
      break;
    case 4:
      b = b.containerInfo;
      d = true;
      break;
    default:
      throw Error(y(161));
  }
  c.flags & 16 && (pb(b, ""), c.flags &= -17);
  a:
    b:
      for (c = a; ; ) {
        for (; null === c.sibling; ) {
          if (null === c.return || ej(c.return)) {
            c = null;
            break a;
          }
          c = c.return;
        }
        c.sibling.return = c.return;
        for (c = c.sibling; 5 !== c.tag && 6 !== c.tag && 18 !== c.tag; ) {
          if (c.flags & 2)
            continue b;
          if (null === c.child || 4 === c.tag)
            continue b;
          else
            c.child.return = c, c = c.child;
        }
        if (!(c.flags & 2)) {
          c = c.stateNode;
          break a;
        }
      }
  d ? gj(a, c, b) : hj(a, c, b);
}
function gj(a, b, c) {
  var d = a.tag, e2 = 5 === d || 6 === d;
  if (e2)
    a = e2 ? a.stateNode : a.stateNode.instance, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = jf));
  else if (4 !== d && (a = a.child, null !== a))
    for (gj(a, b, c), a = a.sibling; null !== a; )
      gj(a, b, c), a = a.sibling;
}
function hj(a, b, c) {
  var d = a.tag, e2 = 5 === d || 6 === d;
  if (e2)
    a = e2 ? a.stateNode : a.stateNode.instance, b ? c.insertBefore(a, b) : c.appendChild(a);
  else if (4 !== d && (a = a.child, null !== a))
    for (hj(a, b, c), a = a.sibling; null !== a; )
      hj(a, b, c), a = a.sibling;
}
function cj(a, b) {
  for (var c = b, d = false, e2, f2; ; ) {
    if (!d) {
      d = c.return;
      a:
        for (; ; ) {
          if (null === d)
            throw Error(y(160));
          e2 = d.stateNode;
          switch (d.tag) {
            case 5:
              f2 = false;
              break a;
            case 3:
              e2 = e2.containerInfo;
              f2 = true;
              break a;
            case 4:
              e2 = e2.containerInfo;
              f2 = true;
              break a;
          }
          d = d.return;
        }
      d = true;
    }
    if (5 === c.tag || 6 === c.tag) {
      a:
        for (var g2 = a, h2 = c, k = h2; ; )
          if (bj(g2, k), null !== k.child && 4 !== k.tag)
            k.child.return = k, k = k.child;
          else {
            if (k === h2)
              break a;
            for (; null === k.sibling; ) {
              if (null === k.return || k.return === h2)
                break a;
              k = k.return;
            }
            k.sibling.return = k.return;
            k = k.sibling;
          }
      f2 ? (g2 = e2, h2 = c.stateNode, 8 === g2.nodeType ? g2.parentNode.removeChild(h2) : g2.removeChild(h2)) : e2.removeChild(c.stateNode);
    } else if (4 === c.tag) {
      if (null !== c.child) {
        e2 = c.stateNode.containerInfo;
        f2 = true;
        c.child.return = c;
        c = c.child;
        continue;
      }
    } else if (bj(a, c), null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b)
      break;
    for (; null === c.sibling; ) {
      if (null === c.return || c.return === b)
        return;
      c = c.return;
      4 === c.tag && (d = false);
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
}
function ij(a, b) {
  switch (b.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      var c = b.updateQueue;
      c = null !== c ? c.lastEffect : null;
      if (null !== c) {
        var d = c = c.next;
        do
          3 === (d.tag & 3) && (a = d.destroy, d.destroy = void 0, void 0 !== a && a()), d = d.next;
        while (d !== c);
      }
      return;
    case 1:
      return;
    case 5:
      c = b.stateNode;
      if (null != c) {
        d = b.memoizedProps;
        var e2 = null !== a ? a.memoizedProps : d;
        a = b.type;
        var f2 = b.updateQueue;
        b.updateQueue = null;
        if (null !== f2) {
          c[xf] = d;
          "input" === a && "radio" === d.type && null != d.name && $a(c, d);
          wb(a, e2);
          b = wb(a, d);
          for (e2 = 0; e2 < f2.length; e2 += 2) {
            var g2 = f2[e2], h2 = f2[e2 + 1];
            "style" === g2 ? tb(c, h2) : "dangerouslySetInnerHTML" === g2 ? ob(c, h2) : "children" === g2 ? pb(c, h2) : qa(c, g2, h2, b);
          }
          switch (a) {
            case "input":
              ab(c, d);
              break;
            case "textarea":
              ib(c, d);
              break;
            case "select":
              a = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f2 = d.value, null != f2 ? fb(c, !!d.multiple, f2, false) : a !== !!d.multiple && (null != d.defaultValue ? fb(c, !!d.multiple, d.defaultValue, true) : fb(c, !!d.multiple, d.multiple ? [] : "", false));
          }
        }
      }
      return;
    case 6:
      if (null === b.stateNode)
        throw Error(y(162));
      b.stateNode.nodeValue = b.memoizedProps;
      return;
    case 3:
      c = b.stateNode;
      c.hydrate && (c.hydrate = false, Cc(c.containerInfo));
      return;
    case 12:
      return;
    case 13:
      null !== b.memoizedState && (jj = O(), aj(b.child, true));
      kj(b);
      return;
    case 19:
      kj(b);
      return;
    case 17:
      return;
    case 23:
    case 24:
      aj(b, null !== b.memoizedState);
      return;
  }
  throw Error(y(163));
}
function kj(a) {
  var b = a.updateQueue;
  if (null !== b) {
    a.updateQueue = null;
    var c = a.stateNode;
    null === c && (c = a.stateNode = new Ui());
    b.forEach(function(b2) {
      var d = lj.bind(null, a, b2);
      c.has(b2) || (c.add(b2), b2.then(d, d));
    });
  }
}
function mj(a, b) {
  return null !== a && (a = a.memoizedState, null === a || null !== a.dehydrated) ? (b = b.memoizedState, null !== b && null === b.dehydrated) : false;
}
var nj = Math.ceil, oj = ra.ReactCurrentDispatcher, pj = ra.ReactCurrentOwner, X = 0, U = null, Y = null, W = 0, qj = 0, rj = Bf(0), V = 0, sj = null, tj = 0, Dg = 0, Hi = 0, uj = 0, vj = null, jj = 0, Ji = Infinity;
function wj() {
  Ji = O() + 500;
}
var Z = null, Qi = false, Ri = null, Ti = null, xj = false, yj = null, zj = 90, Aj = [], Bj = [], Cj = null, Dj = 0, Ej = null, Fj = -1, Gj = 0, Hj = 0, Ij = null, Jj = false;
function Hg() {
  return 0 !== (X & 48) ? O() : -1 !== Fj ? Fj : Fj = O();
}
function Ig(a) {
  a = a.mode;
  if (0 === (a & 2))
    return 1;
  if (0 === (a & 4))
    return 99 === eg() ? 1 : 2;
  0 === Gj && (Gj = tj);
  if (0 !== kg.transition) {
    0 !== Hj && (Hj = null !== vj ? vj.pendingLanes : 0);
    a = Gj;
    var b = 4186112 & ~Hj;
    b &= -b;
    0 === b && (a = 4186112 & ~a, b = a & -a, 0 === b && (b = 8192));
    return b;
  }
  a = eg();
  0 !== (X & 4) && 98 === a ? a = Xc(12, Gj) : (a = Sc(a), a = Xc(a, Gj));
  return a;
}
function Jg(a, b, c) {
  if (50 < Dj)
    throw Dj = 0, Ej = null, Error(y(185));
  a = Kj(a, b);
  if (null === a)
    return null;
  $c(a, b, c);
  a === U && (Hi |= b, 4 === V && Ii(a, W));
  var d = eg();
  1 === b ? 0 !== (X & 8) && 0 === (X & 48) ? Lj(a) : (Mj(a, c), 0 === X && (wj(), ig())) : (0 === (X & 4) || 98 !== d && 99 !== d || (null === Cj ? Cj = /* @__PURE__ */ new Set([a]) : Cj.add(a)), Mj(a, c));
  vj = a;
}
function Kj(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  null !== c && (c.lanes |= b);
  c = a;
  for (a = a.return; null !== a; )
    a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
  return 3 === c.tag ? c.stateNode : null;
}
function Mj(a, b) {
  for (var c = a.callbackNode, d = a.suspendedLanes, e2 = a.pingedLanes, f2 = a.expirationTimes, g2 = a.pendingLanes; 0 < g2; ) {
    var h2 = 31 - Vc(g2), k = 1 << h2, l2 = f2[h2];
    if (-1 === l2) {
      if (0 === (k & d) || 0 !== (k & e2)) {
        l2 = b;
        Rc(k);
        var n2 = F;
        f2[h2] = 10 <= n2 ? l2 + 250 : 6 <= n2 ? l2 + 5e3 : -1;
      }
    } else
      l2 <= b && (a.expiredLanes |= k);
    g2 &= ~k;
  }
  d = Uc(a, a === U ? W : 0);
  b = F;
  if (0 === d)
    null !== c && (c !== Zf && Pf(c), a.callbackNode = null, a.callbackPriority = 0);
  else {
    if (null !== c) {
      if (a.callbackPriority === b)
        return;
      c !== Zf && Pf(c);
    }
    15 === b ? (c = Lj.bind(null, a), null === ag ? (ag = [c], bg = Of(Uf, jg)) : ag.push(c), c = Zf) : 14 === b ? c = hg(99, Lj.bind(null, a)) : (c = Tc(b), c = hg(c, Nj.bind(null, a)));
    a.callbackPriority = b;
    a.callbackNode = c;
  }
}
function Nj(a) {
  Fj = -1;
  Hj = Gj = 0;
  if (0 !== (X & 48))
    throw Error(y(327));
  var b = a.callbackNode;
  if (Oj() && a.callbackNode !== b)
    return null;
  var c = Uc(a, a === U ? W : 0);
  if (0 === c)
    return null;
  var d = c;
  var e2 = X;
  X |= 16;
  var f2 = Pj();
  if (U !== a || W !== d)
    wj(), Qj(a, d);
  do
    try {
      Rj();
      break;
    } catch (h2) {
      Sj(a, h2);
    }
  while (1);
  qg();
  oj.current = f2;
  X = e2;
  null !== Y ? d = 0 : (U = null, W = 0, d = V);
  if (0 !== (tj & Hi))
    Qj(a, 0);
  else if (0 !== d) {
    2 === d && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), c = Wc(a), 0 !== c && (d = Tj(a, c)));
    if (1 === d)
      throw b = sj, Qj(a, 0), Ii(a, c), Mj(a, O()), b;
    a.finishedWork = a.current.alternate;
    a.finishedLanes = c;
    switch (d) {
      case 0:
      case 1:
        throw Error(y(345));
      case 2:
        Uj(a);
        break;
      case 3:
        Ii(a, c);
        if ((c & 62914560) === c && (d = jj + 500 - O(), 10 < d)) {
          if (0 !== Uc(a, 0))
            break;
          e2 = a.suspendedLanes;
          if ((e2 & c) !== c) {
            Hg();
            a.pingedLanes |= a.suspendedLanes & e2;
            break;
          }
          a.timeoutHandle = of$1(Uj.bind(null, a), d);
          break;
        }
        Uj(a);
        break;
      case 4:
        Ii(a, c);
        if ((c & 4186112) === c)
          break;
        d = a.eventTimes;
        for (e2 = -1; 0 < c; ) {
          var g2 = 31 - Vc(c);
          f2 = 1 << g2;
          g2 = d[g2];
          g2 > e2 && (e2 = g2);
          c &= ~f2;
        }
        c = e2;
        c = O() - c;
        c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * nj(c / 1960)) - c;
        if (10 < c) {
          a.timeoutHandle = of$1(Uj.bind(null, a), c);
          break;
        }
        Uj(a);
        break;
      case 5:
        Uj(a);
        break;
      default:
        throw Error(y(329));
    }
  }
  Mj(a, O());
  return a.callbackNode === b ? Nj.bind(null, a) : null;
}
function Ii(a, b) {
  b &= ~uj;
  b &= ~Hi;
  a.suspendedLanes |= b;
  a.pingedLanes &= ~b;
  for (a = a.expirationTimes; 0 < b; ) {
    var c = 31 - Vc(b), d = 1 << c;
    a[c] = -1;
    b &= ~d;
  }
}
function Lj(a) {
  if (0 !== (X & 48))
    throw Error(y(327));
  Oj();
  if (a === U && 0 !== (a.expiredLanes & W)) {
    var b = W;
    var c = Tj(a, b);
    0 !== (tj & Hi) && (b = Uc(a, b), c = Tj(a, b));
  } else
    b = Uc(a, 0), c = Tj(a, b);
  0 !== a.tag && 2 === c && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), b = Wc(a), 0 !== b && (c = Tj(a, b)));
  if (1 === c)
    throw c = sj, Qj(a, 0), Ii(a, b), Mj(a, O()), c;
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b;
  Uj(a);
  Mj(a, O());
  return null;
}
function Vj() {
  if (null !== Cj) {
    var a = Cj;
    Cj = null;
    a.forEach(function(a2) {
      a2.expiredLanes |= 24 & a2.pendingLanes;
      Mj(a2, O());
    });
  }
  ig();
}
function Wj(a, b) {
  var c = X;
  X |= 1;
  try {
    return a(b);
  } finally {
    X = c, 0 === X && (wj(), ig());
  }
}
function Xj(a, b) {
  var c = X;
  X &= -2;
  X |= 8;
  try {
    return a(b);
  } finally {
    X = c, 0 === X && (wj(), ig());
  }
}
function ni(a, b) {
  I(rj, qj);
  qj |= b;
  tj |= b;
}
function Ki() {
  qj = rj.current;
  H(rj);
}
function Qj(a, b) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  -1 !== c && (a.timeoutHandle = -1, pf(c));
  if (null !== Y)
    for (c = Y.return; null !== c; ) {
      var d = c;
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          null !== d && void 0 !== d && Gf();
          break;
        case 3:
          fh();
          H(N);
          H(M);
          uh();
          break;
        case 5:
          hh(d);
          break;
        case 4:
          fh();
          break;
        case 13:
          H(P);
          break;
        case 19:
          H(P);
          break;
        case 10:
          rg(d);
          break;
        case 23:
        case 24:
          Ki();
      }
      c = c.return;
    }
  U = a;
  Y = Tg(a.current, null);
  W = qj = tj = b;
  V = 0;
  sj = null;
  uj = Hi = Dg = 0;
}
function Sj(a, b) {
  do {
    var c = Y;
    try {
      qg();
      vh.current = Gh;
      if (yh) {
        for (var d = R$1.memoizedState; null !== d; ) {
          var e2 = d.queue;
          null !== e2 && (e2.pending = null);
          d = d.next;
        }
        yh = false;
      }
      xh = 0;
      T = S = R$1 = null;
      zh = false;
      pj.current = null;
      if (null === c || null === c.return) {
        V = 1;
        sj = b;
        Y = null;
        break;
      }
      a: {
        var f2 = a, g2 = c.return, h2 = c, k = b;
        b = W;
        h2.flags |= 2048;
        h2.firstEffect = h2.lastEffect = null;
        if (null !== k && "object" === typeof k && "function" === typeof k.then) {
          var l2 = k;
          if (0 === (h2.mode & 2)) {
            var n2 = h2.alternate;
            n2 ? (h2.updateQueue = n2.updateQueue, h2.memoizedState = n2.memoizedState, h2.lanes = n2.lanes) : (h2.updateQueue = null, h2.memoizedState = null);
          }
          var A2 = 0 !== (P.current & 1), p2 = g2;
          do {
            var C2;
            if (C2 = 13 === p2.tag) {
              var x2 = p2.memoizedState;
              if (null !== x2)
                C2 = null !== x2.dehydrated ? true : false;
              else {
                var w2 = p2.memoizedProps;
                C2 = void 0 === w2.fallback ? false : true !== w2.unstable_avoidThisFallback ? true : A2 ? false : true;
              }
            }
            if (C2) {
              var z2 = p2.updateQueue;
              if (null === z2) {
                var u2 = /* @__PURE__ */ new Set();
                u2.add(l2);
                p2.updateQueue = u2;
              } else
                z2.add(l2);
              if (0 === (p2.mode & 2)) {
                p2.flags |= 64;
                h2.flags |= 16384;
                h2.flags &= -2981;
                if (1 === h2.tag)
                  if (null === h2.alternate)
                    h2.tag = 17;
                  else {
                    var t2 = zg(-1, 1);
                    t2.tag = 2;
                    Ag(h2, t2);
                  }
                h2.lanes |= 1;
                break a;
              }
              k = void 0;
              h2 = b;
              var q2 = f2.pingCache;
              null === q2 ? (q2 = f2.pingCache = new Oi(), k = /* @__PURE__ */ new Set(), q2.set(l2, k)) : (k = q2.get(l2), void 0 === k && (k = /* @__PURE__ */ new Set(), q2.set(l2, k)));
              if (!k.has(h2)) {
                k.add(h2);
                var v2 = Yj.bind(null, f2, l2, h2);
                l2.then(v2, v2);
              }
              p2.flags |= 4096;
              p2.lanes = b;
              break a;
            }
            p2 = p2.return;
          } while (null !== p2);
          k = Error((Ra(h2.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
        }
        5 !== V && (V = 2);
        k = Mi(k, h2);
        p2 = g2;
        do {
          switch (p2.tag) {
            case 3:
              f2 = k;
              p2.flags |= 4096;
              b &= -b;
              p2.lanes |= b;
              var J2 = Pi(p2, f2, b);
              Bg(p2, J2);
              break a;
            case 1:
              f2 = k;
              var K2 = p2.type, Q2 = p2.stateNode;
              if (0 === (p2.flags & 64) && ("function" === typeof K2.getDerivedStateFromError || null !== Q2 && "function" === typeof Q2.componentDidCatch && (null === Ti || !Ti.has(Q2)))) {
                p2.flags |= 4096;
                b &= -b;
                p2.lanes |= b;
                var L2 = Si(p2, f2, b);
                Bg(p2, L2);
                break a;
              }
          }
          p2 = p2.return;
        } while (null !== p2);
      }
      Zj(c);
    } catch (va) {
      b = va;
      Y === c && null !== c && (Y = c = c.return);
      continue;
    }
    break;
  } while (1);
}
function Pj() {
  var a = oj.current;
  oj.current = Gh;
  return null === a ? Gh : a;
}
function Tj(a, b) {
  var c = X;
  X |= 16;
  var d = Pj();
  U === a && W === b || Qj(a, b);
  do
    try {
      ak();
      break;
    } catch (e2) {
      Sj(a, e2);
    }
  while (1);
  qg();
  X = c;
  oj.current = d;
  if (null !== Y)
    throw Error(y(261));
  U = null;
  W = 0;
  return V;
}
function ak() {
  for (; null !== Y; )
    bk(Y);
}
function Rj() {
  for (; null !== Y && !Qf(); )
    bk(Y);
}
function bk(a) {
  var b = ck(a.alternate, a, qj);
  a.memoizedProps = a.pendingProps;
  null === b ? Zj(a) : Y = b;
  pj.current = null;
}
function Zj(a) {
  var b = a;
  do {
    var c = b.alternate;
    a = b.return;
    if (0 === (b.flags & 2048)) {
      c = Gi(c, b, qj);
      if (null !== c) {
        Y = c;
        return;
      }
      c = b;
      if (24 !== c.tag && 23 !== c.tag || null === c.memoizedState || 0 !== (qj & 1073741824) || 0 === (c.mode & 4)) {
        for (var d = 0, e2 = c.child; null !== e2; )
          d |= e2.lanes | e2.childLanes, e2 = e2.sibling;
        c.childLanes = d;
      }
      null !== a && 0 === (a.flags & 2048) && (null === a.firstEffect && (a.firstEffect = b.firstEffect), null !== b.lastEffect && (null !== a.lastEffect && (a.lastEffect.nextEffect = b.firstEffect), a.lastEffect = b.lastEffect), 1 < b.flags && (null !== a.lastEffect ? a.lastEffect.nextEffect = b : a.firstEffect = b, a.lastEffect = b));
    } else {
      c = Li(b);
      if (null !== c) {
        c.flags &= 2047;
        Y = c;
        return;
      }
      null !== a && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);
    }
    b = b.sibling;
    if (null !== b) {
      Y = b;
      return;
    }
    Y = b = a;
  } while (null !== b);
  0 === V && (V = 5);
}
function Uj(a) {
  var b = eg();
  gg(99, dk.bind(null, a, b));
  return null;
}
function dk(a, b) {
  do
    Oj();
  while (null !== yj);
  if (0 !== (X & 48))
    throw Error(y(327));
  var c = a.finishedWork;
  if (null === c)
    return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current)
    throw Error(y(177));
  a.callbackNode = null;
  var d = c.lanes | c.childLanes, e2 = d, f2 = a.pendingLanes & ~e2;
  a.pendingLanes = e2;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= e2;
  a.mutableReadLanes &= e2;
  a.entangledLanes &= e2;
  e2 = a.entanglements;
  for (var g2 = a.eventTimes, h2 = a.expirationTimes; 0 < f2; ) {
    var k = 31 - Vc(f2), l2 = 1 << k;
    e2[k] = 0;
    g2[k] = -1;
    h2[k] = -1;
    f2 &= ~l2;
  }
  null !== Cj && 0 === (d & 24) && Cj.has(a) && Cj.delete(a);
  a === U && (Y = U = null, W = 0);
  1 < c.flags ? null !== c.lastEffect ? (c.lastEffect.nextEffect = c, d = c.firstEffect) : d = c : d = c.firstEffect;
  if (null !== d) {
    e2 = X;
    X |= 32;
    pj.current = null;
    kf = fd;
    g2 = Ne();
    if (Oe(g2)) {
      if ("selectionStart" in g2)
        h2 = { start: g2.selectionStart, end: g2.selectionEnd };
      else
        a:
          if (h2 = (h2 = g2.ownerDocument) && h2.defaultView || window, (l2 = h2.getSelection && h2.getSelection()) && 0 !== l2.rangeCount) {
            h2 = l2.anchorNode;
            f2 = l2.anchorOffset;
            k = l2.focusNode;
            l2 = l2.focusOffset;
            try {
              h2.nodeType, k.nodeType;
            } catch (va) {
              h2 = null;
              break a;
            }
            var n2 = 0, A2 = -1, p2 = -1, C2 = 0, x2 = 0, w2 = g2, z2 = null;
            b:
              for (; ; ) {
                for (var u2; ; ) {
                  w2 !== h2 || 0 !== f2 && 3 !== w2.nodeType || (A2 = n2 + f2);
                  w2 !== k || 0 !== l2 && 3 !== w2.nodeType || (p2 = n2 + l2);
                  3 === w2.nodeType && (n2 += w2.nodeValue.length);
                  if (null === (u2 = w2.firstChild))
                    break;
                  z2 = w2;
                  w2 = u2;
                }
                for (; ; ) {
                  if (w2 === g2)
                    break b;
                  z2 === h2 && ++C2 === f2 && (A2 = n2);
                  z2 === k && ++x2 === l2 && (p2 = n2);
                  if (null !== (u2 = w2.nextSibling))
                    break;
                  w2 = z2;
                  z2 = w2.parentNode;
                }
                w2 = u2;
              }
            h2 = -1 === A2 || -1 === p2 ? null : { start: A2, end: p2 };
          } else
            h2 = null;
      h2 = h2 || { start: 0, end: 0 };
    } else
      h2 = null;
    lf = { focusedElem: g2, selectionRange: h2 };
    fd = false;
    Ij = null;
    Jj = false;
    Z = d;
    do
      try {
        ek();
      } catch (va) {
        if (null === Z)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (null !== Z);
    Ij = null;
    Z = d;
    do
      try {
        for (g2 = a; null !== Z; ) {
          var t2 = Z.flags;
          t2 & 16 && pb(Z.stateNode, "");
          if (t2 & 128) {
            var q2 = Z.alternate;
            if (null !== q2) {
              var v2 = q2.ref;
              null !== v2 && ("function" === typeof v2 ? v2(null) : v2.current = null);
            }
          }
          switch (t2 & 1038) {
            case 2:
              fj(Z);
              Z.flags &= -3;
              break;
            case 6:
              fj(Z);
              Z.flags &= -3;
              ij(Z.alternate, Z);
              break;
            case 1024:
              Z.flags &= -1025;
              break;
            case 1028:
              Z.flags &= -1025;
              ij(Z.alternate, Z);
              break;
            case 4:
              ij(Z.alternate, Z);
              break;
            case 8:
              h2 = Z;
              cj(g2, h2);
              var J2 = h2.alternate;
              dj(h2);
              null !== J2 && dj(J2);
          }
          Z = Z.nextEffect;
        }
      } catch (va) {
        if (null === Z)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (null !== Z);
    v2 = lf;
    q2 = Ne();
    t2 = v2.focusedElem;
    g2 = v2.selectionRange;
    if (q2 !== t2 && t2 && t2.ownerDocument && Me(t2.ownerDocument.documentElement, t2)) {
      null !== g2 && Oe(t2) && (q2 = g2.start, v2 = g2.end, void 0 === v2 && (v2 = q2), "selectionStart" in t2 ? (t2.selectionStart = q2, t2.selectionEnd = Math.min(v2, t2.value.length)) : (v2 = (q2 = t2.ownerDocument || document) && q2.defaultView || window, v2.getSelection && (v2 = v2.getSelection(), h2 = t2.textContent.length, J2 = Math.min(g2.start, h2), g2 = void 0 === g2.end ? J2 : Math.min(g2.end, h2), !v2.extend && J2 > g2 && (h2 = g2, g2 = J2, J2 = h2), h2 = Le(t2, J2), f2 = Le(t2, g2), h2 && f2 && (1 !== v2.rangeCount || v2.anchorNode !== h2.node || v2.anchorOffset !== h2.offset || v2.focusNode !== f2.node || v2.focusOffset !== f2.offset) && (q2 = q2.createRange(), q2.setStart(h2.node, h2.offset), v2.removeAllRanges(), J2 > g2 ? (v2.addRange(q2), v2.extend(f2.node, f2.offset)) : (q2.setEnd(f2.node, f2.offset), v2.addRange(q2))))));
      q2 = [];
      for (v2 = t2; v2 = v2.parentNode; )
        1 === v2.nodeType && q2.push({ element: v2, left: v2.scrollLeft, top: v2.scrollTop });
      "function" === typeof t2.focus && t2.focus();
      for (t2 = 0; t2 < q2.length; t2++)
        v2 = q2[t2], v2.element.scrollLeft = v2.left, v2.element.scrollTop = v2.top;
    }
    fd = !!kf;
    lf = kf = null;
    a.current = c;
    Z = d;
    do
      try {
        for (t2 = a; null !== Z; ) {
          var K2 = Z.flags;
          K2 & 36 && Yi(t2, Z.alternate, Z);
          if (K2 & 128) {
            q2 = void 0;
            var Q2 = Z.ref;
            if (null !== Q2) {
              var L2 = Z.stateNode;
              switch (Z.tag) {
                case 5:
                  q2 = L2;
                  break;
                default:
                  q2 = L2;
              }
              "function" === typeof Q2 ? Q2(q2) : Q2.current = q2;
            }
          }
          Z = Z.nextEffect;
        }
      } catch (va) {
        if (null === Z)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (null !== Z);
    Z = null;
    $f();
    X = e2;
  } else
    a.current = c;
  if (xj)
    xj = false, yj = a, zj = b;
  else
    for (Z = d; null !== Z; )
      b = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K2 = Z, K2.sibling = null, K2.stateNode = null), Z = b;
  d = a.pendingLanes;
  0 === d && (Ti = null);
  1 === d ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;
  c = c.stateNode;
  if (Mf && "function" === typeof Mf.onCommitFiberRoot)
    try {
      Mf.onCommitFiberRoot(Lf, c, void 0, 64 === (c.current.flags & 64));
    } catch (va) {
    }
  Mj(a, O());
  if (Qi)
    throw Qi = false, a = Ri, Ri = null, a;
  if (0 !== (X & 8))
    return null;
  ig();
  return null;
}
function ek() {
  for (; null !== Z; ) {
    var a = Z.alternate;
    Jj || null === Ij || (0 !== (Z.flags & 8) ? dc(Z, Ij) && (Jj = true) : 13 === Z.tag && mj(a, Z) && dc(Z, Ij) && (Jj = true));
    var b = Z.flags;
    0 !== (b & 256) && Xi(a, Z);
    0 === (b & 512) || xj || (xj = true, hg(97, function() {
      Oj();
      return null;
    }));
    Z = Z.nextEffect;
  }
}
function Oj() {
  if (90 !== zj) {
    var a = 97 < zj ? 97 : zj;
    zj = 90;
    return gg(a, fk);
  }
  return false;
}
function $i(a, b) {
  Aj.push(b, a);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function Zi(a, b) {
  Bj.push(b, a);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function fk() {
  if (null === yj)
    return false;
  var a = yj;
  yj = null;
  if (0 !== (X & 48))
    throw Error(y(331));
  var b = X;
  X |= 32;
  var c = Bj;
  Bj = [];
  for (var d = 0; d < c.length; d += 2) {
    var e2 = c[d], f2 = c[d + 1], g2 = e2.destroy;
    e2.destroy = void 0;
    if ("function" === typeof g2)
      try {
        g2();
      } catch (k) {
        if (null === f2)
          throw Error(y(330));
        Wi(f2, k);
      }
  }
  c = Aj;
  Aj = [];
  for (d = 0; d < c.length; d += 2) {
    e2 = c[d];
    f2 = c[d + 1];
    try {
      var h2 = e2.create;
      e2.destroy = h2();
    } catch (k) {
      if (null === f2)
        throw Error(y(330));
      Wi(f2, k);
    }
  }
  for (h2 = a.current.firstEffect; null !== h2; )
    a = h2.nextEffect, h2.nextEffect = null, h2.flags & 8 && (h2.sibling = null, h2.stateNode = null), h2 = a;
  X = b;
  ig();
  return true;
}
function gk(a, b, c) {
  b = Mi(c, b);
  b = Pi(a, b, 1);
  Ag(a, b);
  b = Hg();
  a = Kj(a, 1);
  null !== a && ($c(a, 1, b), Mj(a, b));
}
function Wi(a, b) {
  if (3 === a.tag)
    gk(a, a, b);
  else
    for (var c = a.return; null !== c; ) {
      if (3 === c.tag) {
        gk(c, a, b);
        break;
      } else if (1 === c.tag) {
        var d = c.stateNode;
        if ("function" === typeof c.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d))) {
          a = Mi(b, a);
          var e2 = Si(c, a, 1);
          Ag(c, e2);
          e2 = Hg();
          c = Kj(c, 1);
          if (null !== c)
            $c(c, 1, e2), Mj(c, e2);
          else if ("function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d)))
            try {
              d.componentDidCatch(b, a);
            } catch (f2) {
            }
          break;
        }
      }
      c = c.return;
    }
}
function Yj(a, b, c) {
  var d = a.pingCache;
  null !== d && d.delete(b);
  b = Hg();
  a.pingedLanes |= a.suspendedLanes & c;
  U === a && (W & c) === c && (4 === V || 3 === V && (W & 62914560) === W && 500 > O() - jj ? Qj(a, 0) : uj |= c);
  Mj(a, b);
}
function lj(a, b) {
  var c = a.stateNode;
  null !== c && c.delete(b);
  b = 0;
  0 === b && (b = a.mode, 0 === (b & 2) ? b = 1 : 0 === (b & 4) ? b = 99 === eg() ? 1 : 2 : (0 === Gj && (Gj = tj), b = Yc(62914560 & ~Gj), 0 === b && (b = 4194304)));
  c = Hg();
  a = Kj(a, b);
  null !== a && ($c(a, b, c), Mj(a, c));
}
var ck;
ck = function(a, b, c) {
  var d = b.lanes;
  if (null !== a)
    if (a.memoizedProps !== b.pendingProps || N.current)
      ug = true;
    else if (0 !== (c & d))
      ug = 0 !== (a.flags & 16384) ? true : false;
    else {
      ug = false;
      switch (b.tag) {
        case 3:
          ri(b);
          sh();
          break;
        case 5:
          gh(b);
          break;
        case 1:
          Ff(b.type) && Jf(b);
          break;
        case 4:
          eh(b, b.stateNode.containerInfo);
          break;
        case 10:
          d = b.memoizedProps.value;
          var e2 = b.type._context;
          I(mg, e2._currentValue);
          e2._currentValue = d;
          break;
        case 13:
          if (null !== b.memoizedState) {
            if (0 !== (c & b.child.childLanes))
              return ti(a, b, c);
            I(P, P.current & 1);
            b = hi(a, b, c);
            return null !== b ? b.sibling : null;
          }
          I(P, P.current & 1);
          break;
        case 19:
          d = 0 !== (c & b.childLanes);
          if (0 !== (a.flags & 64)) {
            if (d)
              return Ai(a, b, c);
            b.flags |= 64;
          }
          e2 = b.memoizedState;
          null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
          I(P, P.current);
          if (d)
            break;
          else
            return null;
        case 23:
        case 24:
          return b.lanes = 0, mi(a, b, c);
      }
      return hi(a, b, c);
    }
  else
    ug = false;
  b.lanes = 0;
  switch (b.tag) {
    case 2:
      d = b.type;
      null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
      a = b.pendingProps;
      e2 = Ef(b, M.current);
      tg(b, c);
      e2 = Ch(null, b, d, a, e2, c);
      b.flags |= 1;
      if ("object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof) {
        b.tag = 1;
        b.memoizedState = null;
        b.updateQueue = null;
        if (Ff(d)) {
          var f2 = true;
          Jf(b);
        } else
          f2 = false;
        b.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null;
        xg(b);
        var g2 = d.getDerivedStateFromProps;
        "function" === typeof g2 && Gg(b, d, g2, a);
        e2.updater = Kg;
        b.stateNode = e2;
        e2._reactInternals = b;
        Og(b, d, a, c);
        b = qi(null, b, d, true, f2, c);
      } else
        b.tag = 0, fi(null, b, e2, c), b = b.child;
      return b;
    case 16:
      e2 = b.elementType;
      a: {
        null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
        a = b.pendingProps;
        f2 = e2._init;
        e2 = f2(e2._payload);
        b.type = e2;
        f2 = b.tag = hk(e2);
        a = lg(e2, a);
        switch (f2) {
          case 0:
            b = li(null, b, e2, a, c);
            break a;
          case 1:
            b = pi(null, b, e2, a, c);
            break a;
          case 11:
            b = gi(null, b, e2, a, c);
            break a;
          case 14:
            b = ii(null, b, e2, lg(e2.type, a), d, c);
            break a;
        }
        throw Error(y(306, e2, ""));
      }
      return b;
    case 0:
      return d = b.type, e2 = b.pendingProps, e2 = b.elementType === d ? e2 : lg(d, e2), li(a, b, d, e2, c);
    case 1:
      return d = b.type, e2 = b.pendingProps, e2 = b.elementType === d ? e2 : lg(d, e2), pi(a, b, d, e2, c);
    case 3:
      ri(b);
      d = b.updateQueue;
      if (null === a || null === d)
        throw Error(y(282));
      d = b.pendingProps;
      e2 = b.memoizedState;
      e2 = null !== e2 ? e2.element : null;
      yg(a, b);
      Cg(b, d, null, c);
      d = b.memoizedState.element;
      if (d === e2)
        sh(), b = hi(a, b, c);
      else {
        e2 = b.stateNode;
        if (f2 = e2.hydrate)
          kh = rf(b.stateNode.containerInfo.firstChild), jh = b, f2 = lh = true;
        if (f2) {
          a = e2.mutableSourceEagerHydrationData;
          if (null != a)
            for (e2 = 0; e2 < a.length; e2 += 2)
              f2 = a[e2], f2._workInProgressVersionPrimary = a[e2 + 1], th.push(f2);
          c = Zg(b, null, d, c);
          for (b.child = c; c; )
            c.flags = c.flags & -3 | 1024, c = c.sibling;
        } else
          fi(a, b, d, c), sh();
        b = b.child;
      }
      return b;
    case 5:
      return gh(b), null === a && ph(b), d = b.type, e2 = b.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, nf(d, e2) ? g2 = null : null !== f2 && nf(d, f2) && (b.flags |= 16), oi(a, b), fi(a, b, g2, c), b.child;
    case 6:
      return null === a && ph(b), null;
    case 13:
      return ti(a, b, c);
    case 4:
      return eh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Yg(b, null, d, c) : fi(a, b, d, c), b.child;
    case 11:
      return d = b.type, e2 = b.pendingProps, e2 = b.elementType === d ? e2 : lg(d, e2), gi(a, b, d, e2, c);
    case 7:
      return fi(a, b, b.pendingProps, c), b.child;
    case 8:
      return fi(a, b, b.pendingProps.children, c), b.child;
    case 12:
      return fi(a, b, b.pendingProps.children, c), b.child;
    case 10:
      a: {
        d = b.type._context;
        e2 = b.pendingProps;
        g2 = b.memoizedProps;
        f2 = e2.value;
        var h2 = b.type._context;
        I(mg, h2._currentValue);
        h2._currentValue = f2;
        if (null !== g2)
          if (h2 = g2.value, f2 = He(h2, f2) ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(h2, f2) : 1073741823) | 0, 0 === f2) {
            if (g2.children === e2.children && !N.current) {
              b = hi(a, b, c);
              break a;
            }
          } else
            for (h2 = b.child, null !== h2 && (h2.return = b); null !== h2; ) {
              var k = h2.dependencies;
              if (null !== k) {
                g2 = h2.child;
                for (var l2 = k.firstContext; null !== l2; ) {
                  if (l2.context === d && 0 !== (l2.observedBits & f2)) {
                    1 === h2.tag && (l2 = zg(-1, c & -c), l2.tag = 2, Ag(h2, l2));
                    h2.lanes |= c;
                    l2 = h2.alternate;
                    null !== l2 && (l2.lanes |= c);
                    sg(h2.return, c);
                    k.lanes |= c;
                    break;
                  }
                  l2 = l2.next;
                }
              } else
                g2 = 10 === h2.tag ? h2.type === b.type ? null : h2.child : h2.child;
              if (null !== g2)
                g2.return = h2;
              else
                for (g2 = h2; null !== g2; ) {
                  if (g2 === b) {
                    g2 = null;
                    break;
                  }
                  h2 = g2.sibling;
                  if (null !== h2) {
                    h2.return = g2.return;
                    g2 = h2;
                    break;
                  }
                  g2 = g2.return;
                }
              h2 = g2;
            }
        fi(a, b, e2.children, c);
        b = b.child;
      }
      return b;
    case 9:
      return e2 = b.type, f2 = b.pendingProps, d = f2.children, tg(b, c), e2 = vg(e2, f2.unstable_observedBits), d = d(e2), b.flags |= 1, fi(a, b, d, c), b.child;
    case 14:
      return e2 = b.type, f2 = lg(e2, b.pendingProps), f2 = lg(e2.type, f2), ii(a, b, e2, f2, d, c);
    case 15:
      return ki(a, b, b.type, b.pendingProps, d, c);
    case 17:
      return d = b.type, e2 = b.pendingProps, e2 = b.elementType === d ? e2 : lg(d, e2), null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, Ff(d) ? (a = true, Jf(b)) : a = false, tg(b, c), Mg(b, d, e2), Og(b, d, e2, c), qi(null, b, d, true, a, c);
    case 19:
      return Ai(a, b, c);
    case 23:
      return mi(a, b, c);
    case 24:
      return mi(a, b, c);
  }
  throw Error(y(156, b.tag));
};
function ik(a, b, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.flags = 0;
  this.lastEffect = this.firstEffect = this.nextEffect = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function nh(a, b, c, d) {
  return new ik(a, b, c, d);
}
function ji(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function hk(a) {
  if ("function" === typeof a)
    return ji(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Aa)
      return 11;
    if (a === Da)
      return 14;
  }
  return 2;
}
function Tg(a, b) {
  var c = a.alternate;
  null === c ? (c = nh(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b = a.dependencies;
  c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}
function Vg(a, b, c, d, e2, f2) {
  var g2 = 2;
  d = a;
  if ("function" === typeof a)
    ji(a) && (g2 = 1);
  else if ("string" === typeof a)
    g2 = 5;
  else
    a:
      switch (a) {
        case ua:
          return Xg(c.children, e2, f2, b);
        case Ha:
          g2 = 8;
          e2 |= 16;
          break;
        case wa:
          g2 = 8;
          e2 |= 1;
          break;
        case xa:
          return a = nh(12, c, b, e2 | 8), a.elementType = xa, a.type = xa, a.lanes = f2, a;
        case Ba:
          return a = nh(13, c, b, e2), a.type = Ba, a.elementType = Ba, a.lanes = f2, a;
        case Ca:
          return a = nh(19, c, b, e2), a.elementType = Ca, a.lanes = f2, a;
        case Ia:
          return vi(c, e2, f2, b);
        case Ja:
          return a = nh(24, c, b, e2), a.elementType = Ja, a.lanes = f2, a;
        default:
          if ("object" === typeof a && null !== a)
            switch (a.$$typeof) {
              case ya:
                g2 = 10;
                break a;
              case za:
                g2 = 9;
                break a;
              case Aa:
                g2 = 11;
                break a;
              case Da:
                g2 = 14;
                break a;
              case Ea:
                g2 = 16;
                d = null;
                break a;
              case Fa:
                g2 = 22;
                break a;
            }
          throw Error(y(130, null == a ? a : typeof a, ""));
      }
  b = nh(g2, c, b, e2);
  b.elementType = a;
  b.type = d;
  b.lanes = f2;
  return b;
}
function Xg(a, b, c, d) {
  a = nh(7, a, d, b);
  a.lanes = c;
  return a;
}
function vi(a, b, c, d) {
  a = nh(23, a, d, b);
  a.elementType = Ia;
  a.lanes = c;
  return a;
}
function Ug(a, b, c) {
  a = nh(6, a, null, b);
  a.lanes = c;
  return a;
}
function Wg(a, b, c) {
  b = nh(4, null !== a.children ? a.children : [], a.key, b);
  b.lanes = c;
  b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b;
}
function jk(a, b, c) {
  this.tag = b;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.pendingContext = this.context = null;
  this.hydrate = c;
  this.callbackNode = null;
  this.callbackPriority = 0;
  this.eventTimes = Zc(0);
  this.expirationTimes = Zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = Zc(0);
  this.mutableSourceEagerHydrationData = null;
}
function kk(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: ta, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
}
function lk(a, b, c, d) {
  var e2 = b.current, f2 = Hg(), g2 = Ig(e2);
  a:
    if (c) {
      c = c._reactInternals;
      b: {
        if (Zb(c) !== c || 1 !== c.tag)
          throw Error(y(170));
        var h2 = c;
        do {
          switch (h2.tag) {
            case 3:
              h2 = h2.stateNode.context;
              break b;
            case 1:
              if (Ff(h2.type)) {
                h2 = h2.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }
          }
          h2 = h2.return;
        } while (null !== h2);
        throw Error(y(171));
      }
      if (1 === c.tag) {
        var k = c.type;
        if (Ff(k)) {
          c = If(c, k, h2);
          break a;
        }
      }
      c = h2;
    } else
      c = Cf;
  null === b.context ? b.context = c : b.pendingContext = c;
  b = zg(f2, g2);
  b.payload = { element: a };
  d = void 0 === d ? null : d;
  null !== d && (b.callback = d);
  Ag(e2, b);
  Jg(e2, g2, f2);
  return g2;
}
function mk(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function nk(a, b) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c = a.retryLane;
    a.retryLane = 0 !== c && c < b ? c : b;
  }
}
function ok(a, b) {
  nk(a, b);
  (a = a.alternate) && nk(a, b);
}
function pk() {
  return null;
}
function qk(a, b, c) {
  var d = null != c && null != c.hydrationOptions && c.hydrationOptions.mutableSources || null;
  c = new jk(a, b, null != c && true === c.hydrate);
  b = nh(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);
  c.current = b;
  b.stateNode = c;
  xg(b);
  a[ff] = c.current;
  cf(8 === a.nodeType ? a.parentNode : a);
  if (d)
    for (a = 0; a < d.length; a++) {
      b = d[a];
      var e2 = b._getVersion;
      e2 = e2(b._source);
      null == c.mutableSourceEagerHydrationData ? c.mutableSourceEagerHydrationData = [b, e2] : c.mutableSourceEagerHydrationData.push(b, e2);
    }
  this._internalRoot = c;
}
qk.prototype.render = function(a) {
  lk(a, this._internalRoot, null, null);
};
qk.prototype.unmount = function() {
  var a = this._internalRoot, b = a.containerInfo;
  lk(null, a, null, function() {
    b[ff] = null;
  });
};
function rk(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function sk(a, b) {
  b || (b = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null, b = !(!b || 1 !== b.nodeType || !b.hasAttribute("data-reactroot")));
  if (!b)
    for (var c; c = a.lastChild; )
      a.removeChild(c);
  return new qk(a, 0, b ? { hydrate: true } : void 0);
}
function tk(a, b, c, d, e2) {
  var f2 = c._reactRootContainer;
  if (f2) {
    var g2 = f2._internalRoot;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a2 = mk(g2);
        h2.call(a2);
      };
    }
    lk(b, g2, a, e2);
  } else {
    f2 = c._reactRootContainer = sk(c, d);
    g2 = f2._internalRoot;
    if ("function" === typeof e2) {
      var k = e2;
      e2 = function() {
        var a2 = mk(g2);
        k.call(a2);
      };
    }
    Xj(function() {
      lk(b, g2, a, e2);
    });
  }
  return mk(g2);
}
ec = function(a) {
  if (13 === a.tag) {
    var b = Hg();
    Jg(a, 4, b);
    ok(a, 4);
  }
};
fc = function(a) {
  if (13 === a.tag) {
    var b = Hg();
    Jg(a, 67108864, b);
    ok(a, 67108864);
  }
};
gc = function(a) {
  if (13 === a.tag) {
    var b = Hg(), c = Ig(a);
    Jg(a, c, b);
    ok(a, c);
  }
};
hc = function(a, b) {
  return b();
};
yb = function(a, b, c) {
  switch (b) {
    case "input":
      ab(a, c);
      b = c.name;
      if ("radio" === c.type && null != b) {
        for (c = a; c.parentNode; )
          c = c.parentNode;
        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
        for (b = 0; b < c.length; b++) {
          var d = c[b];
          if (d !== a && d.form === a.form) {
            var e2 = Db(d);
            if (!e2)
              throw Error(y(90));
            Wa(d);
            ab(d, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c);
      break;
    case "select":
      b = c.value, null != b && fb(a, !!c.multiple, b, false);
  }
};
Gb = Wj;
Hb = function(a, b, c, d, e2) {
  var f2 = X;
  X |= 4;
  try {
    return gg(98, a.bind(null, b, c, d, e2));
  } finally {
    X = f2, 0 === X && (wj(), ig());
  }
};
Ib = function() {
  0 === (X & 49) && (Vj(), Oj());
};
Jb = function(a, b) {
  var c = X;
  X |= 2;
  try {
    return a(b);
  } finally {
    X = c, 0 === X && (wj(), ig());
  }
};
function uk(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!rk(b))
    throw Error(y(200));
  return kk(a, b, null, c);
}
var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: false }] }, wk = { findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom" };
var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = cc(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!yk.isDisabled && yk.supportsFiber)
    try {
      Lf = yk.inject(xk), Mf = yk;
    } catch (a) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
reactDom_production_min.createPortal = uk;
reactDom_production_min.findDOMNode = function(a) {
  if (null == a)
    return null;
  if (1 === a.nodeType)
    return a;
  var b = a._reactInternals;
  if (void 0 === b) {
    if ("function" === typeof a.render)
      throw Error(y(188));
    throw Error(y(268, Object.keys(a)));
  }
  a = cc(b);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a, b) {
  var c = X;
  if (0 !== (c & 48))
    return a(b);
  X |= 1;
  try {
    if (a)
      return gg(99, a.bind(null, b));
  } finally {
    X = c, ig();
  }
};
reactDom_production_min.hydrate = function(a, b, c) {
  if (!rk(b))
    throw Error(y(200));
  return tk(null, a, b, true, c);
};
reactDom_production_min.render = function(a, b, c) {
  if (!rk(b))
    throw Error(y(200));
  return tk(null, a, b, false, c);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!rk(a))
    throw Error(y(40));
  return a._reactRootContainer ? (Xj(function() {
    tk(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[ff] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Wj;
reactDom_production_min.unstable_createPortal = function(a, b) {
  return uk(a, b, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
};
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
  if (!rk(c))
    throw Error(y(200));
  if (null == a || void 0 === a._reactInternals)
    throw Error(y(38));
  return tk(a, b, c, false, d);
};
reactDom_production_min.version = "17.0.2";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var ReactDOM = reactDom.exports;
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$1 = react$1.exports, g = 60103;
reactJsxRuntime_production_min.Fragment = 60107;
if ("function" === typeof Symbol && Symbol.for) {
  var h = Symbol.for;
  g = h("react.element");
  reactJsxRuntime_production_min.Fragment = h("react.fragment");
}
var m = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n$1 = Object.prototype.hasOwnProperty, p = { key: true, ref: true, __self: true, __source: true };
function q(c, a, k) {
  var b, d = {}, e2 = null, l2 = null;
  void 0 !== k && (e2 = "" + k);
  void 0 !== a.key && (e2 = "" + a.key);
  void 0 !== a.ref && (l2 = a.ref);
  for (b in a)
    n$1.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps)
    for (b in a = c.defaultProps, a)
      void 0 === d[b] && (d[b] = a[b]);
  return { $$typeof: g, type: c, key: e2, ref: l2, props: d, _owner: m.current };
}
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
const jsx = jsxRuntime.exports.jsx;
const jsxs = jsxRuntime.exports.jsxs;
const Fragment = jsxRuntime.exports.Fragment;
function _mergeNamespaces(n2, m2) {
  m2.forEach(function(e2) {
    e2 && typeof e2 !== "string" && !Array.isArray(e2) && Object.keys(e2).forEach(function(k) {
      if (k !== "default" && !(k in n2)) {
        var d = Object.getOwnPropertyDescriptor(e2, k);
        Object.defineProperty(n2, k, d.get ? d : { enumerable: true, get: function() {
          return e2[k];
        } });
      }
    });
  });
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
let currentSubId = 0;
const subscribers = /* @__PURE__ */ new Map();
const subscribersInternal = /* @__PURE__ */ new Map();
function createSubscribe(options2 = {}) {
  return function(cb2) {
    if (typeof cb2 !== "function")
      return;
    const watchers = options2.internal ? subscribersInternal : subscribers;
    const id2 = ++currentSubId;
    watchers.set(id2, cb2);
    return () => {
      watchers.delete(id2);
    };
  };
}
function createOn(options2 = {}) {
  return function(name2, cb2) {
    const _subscribe = options2.internal ? subscribeInternal : subscribe;
    return _subscribe((e2, payload) => {
      if (name2 === e2)
        return cb2(payload);
    });
  };
}
function createTrigger(options2 = {}) {
  const watchers = options2.internal ? subscribersInternal : subscribers;
  return async function(name2, ...args) {
    let action = { type: name2, payload: args[0] };
    const eventType = Boolean(options2.internal) ? "Internal" : "External";
    log$1.info(`${eventType} Event:`, action);
    await Promise.all(Array.from(watchers.values()).map((x2) => x2(action.type, action.payload)));
  };
}
const trigger$1 = createTrigger();
const subscribe = createSubscribe();
const on = createOn();
const triggerInternal$1 = createTrigger({ internal: true });
const subscribeInternal = createSubscribe({ internal: true });
const onInternal = createOn({ internal: true });
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a, k, d.get ? d : { enumerable: true, get: function() {
      return n2[k];
    } });
  });
  return a;
}
var loglevel = { exports: {} };
(function(module2) {
  (function(root2, definition) {
    if (module2.exports) {
      module2.exports = definition();
    } else {
      root2.log = definition();
    }
  })(commonjsGlobal, function() {
    var noop2 = function() {
    };
    var undefinedType = "undefined";
    var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
    var logMethods = ["trace", "debug", "info", "warn", "error"];
    function bindMethod(obj, methodName) {
      var method = obj[methodName];
      if (typeof method.bind === "function") {
        return method.bind(obj);
      } else {
        try {
          return Function.prototype.bind.call(method, obj);
        } catch (e2) {
          return function() {
            return Function.prototype.apply.apply(method, [obj, arguments]);
          };
        }
      }
    }
    function traceForIE() {
      if (console.log) {
        if (console.log.apply) {
          console.log.apply(console, arguments);
        } else {
          Function.prototype.apply.apply(console.log, [console, arguments]);
        }
      }
      if (console.trace)
        console.trace();
    }
    function realMethod(methodName) {
      if (methodName === "debug") {
        methodName = "log";
      }
      if (typeof console === undefinedType) {
        return false;
      } else if (methodName === "trace" && isIE) {
        return traceForIE;
      } else if (console[methodName] !== void 0) {
        return bindMethod(console, methodName);
      } else if (console.log !== void 0) {
        return bindMethod(console, "log");
      } else {
        return noop2;
      }
    }
    function replaceLoggingMethods(level, loggerName) {
      for (var i2 = 0; i2 < logMethods.length; i2++) {
        var methodName = logMethods[i2];
        this[methodName] = i2 < level ? noop2 : this.methodFactory(methodName, level, loggerName);
      }
      this.log = this.debug;
    }
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
      return function() {
        if (typeof console !== undefinedType) {
          replaceLoggingMethods.call(this, level, loggerName);
          this[methodName].apply(this, arguments);
        }
      };
    }
    function defaultMethodFactory(methodName, level, loggerName) {
      return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
    }
    function Logger(name2, defaultLevel, factory2) {
      var self2 = this;
      var currentLevel;
      defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;
      var storageKey = "loglevel";
      if (typeof name2 === "string") {
        storageKey += ":" + name2;
      } else if (typeof name2 === "symbol") {
        storageKey = void 0;
      }
      function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || "silent").toUpperCase();
        if (typeof window === undefinedType || !storageKey)
          return;
        try {
          window.localStorage[storageKey] = levelName;
          return;
        } catch (ignore) {
        }
        try {
          window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
        } catch (ignore) {
        }
      }
      function getPersistedLevel() {
        var storedLevel;
        if (typeof window === undefinedType || !storageKey)
          return;
        try {
          storedLevel = window.localStorage[storageKey];
        } catch (ignore) {
        }
        if (typeof storedLevel === undefinedType) {
          try {
            var cookie = window.document.cookie;
            var location2 = cookie.indexOf(encodeURIComponent(storageKey) + "=");
            if (location2 !== -1) {
              storedLevel = /^([^;]+)/.exec(cookie.slice(location2))[1];
            }
          } catch (ignore) {
          }
        }
        if (self2.levels[storedLevel] === void 0) {
          storedLevel = void 0;
        }
        return storedLevel;
      }
      function clearPersistedLevel() {
        if (typeof window === undefinedType || !storageKey)
          return;
        try {
          window.localStorage.removeItem(storageKey);
          return;
        } catch (ignore) {
        }
        try {
          window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
        } catch (ignore) {
        }
      }
      self2.name = name2;
      self2.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3, "ERROR": 4, "SILENT": 5 };
      self2.methodFactory = factory2 || defaultMethodFactory;
      self2.getLevel = function() {
        return currentLevel;
      };
      self2.setLevel = function(level, persist) {
        if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
          level = self2.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
          currentLevel = level;
          if (persist !== false) {
            persistLevelIfPossible(level);
          }
          replaceLoggingMethods.call(self2, level, name2);
          if (typeof console === undefinedType && level < self2.levels.SILENT) {
            return "No console available for logging";
          }
        } else {
          throw "log.setLevel() called with invalid level: " + level;
        }
      };
      self2.setDefaultLevel = function(level) {
        defaultLevel = level;
        if (!getPersistedLevel()) {
          self2.setLevel(level, false);
        }
      };
      self2.resetLevel = function() {
        self2.setLevel(defaultLevel, false);
        clearPersistedLevel();
      };
      self2.enableAll = function(persist) {
        self2.setLevel(self2.levels.TRACE, persist);
      };
      self2.disableAll = function(persist) {
        self2.setLevel(self2.levels.SILENT, persist);
      };
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
        initialLevel = defaultLevel;
      }
      self2.setLevel(initialLevel, false);
    }
    var defaultLogger = new Logger();
    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name2) {
      if (typeof name2 !== "symbol" && typeof name2 !== "string" || name2 === "") {
        throw new TypeError("You must supply a name when creating a logger.");
      }
      var logger2 = _loggersByName[name2];
      if (!logger2) {
        logger2 = _loggersByName[name2] = new Logger(name2, defaultLogger.getLevel(), defaultLogger.methodFactory);
      }
      return logger2;
    };
    var _log = typeof window !== undefinedType ? window.log : void 0;
    defaultLogger.noConflict = function() {
      if (typeof window !== undefinedType && window.log === defaultLogger) {
        window.log = _log;
      }
      return defaultLogger;
    };
    defaultLogger.getLoggers = function getLoggers() {
      return _loggersByName;
    };
    defaultLogger["default"] = defaultLogger;
    return defaultLogger;
  });
})(loglevel);
var log$1 = loglevel.exports;
const connectionId$1 = (Math.random() * 1e20).toString(36);
const version$4 = "1.1.42";
const CoreContext = { config: null, clients: null, Request: {}, Command: {}, on, subscribe, onInternal, subscribeInternal, trigger: trigger$1, triggerInternal: triggerInternal$1, state: {}, compositor: {}, connectionId: connectionId$1, version: version$4, log: log$1, logLevel: null };
const setAppState = (state2) => {
  Object.keys(state2).forEach((name2) => {
    CoreContext.state[name2] = state2[name2];
  });
};
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
var root$1 = root;
var Symbol$1 = root$1.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$f = Object.prototype;
var hasOwnProperty$d = objectProto$f.hasOwnProperty;
var nativeObjectToString$1 = objectProto$f.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$d.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$e = Object.prototype;
var nativeObjectToString = objectProto$e.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var symbolTag$3 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
}
function arrayMap(array, iteratee) {
  var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
  while (++index2 < length2) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var isArray$3 = Array.isArray;
var isArray$4 = isArray$3;
var INFINITY$1 = 1 / 0;
var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$4(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
function isObject$5(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$5(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$5(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
function identity$1(value) {
  return value;
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$5(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$d = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$c = objectProto$d.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$c).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject$5(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$3(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var WeakMap$2 = getNative(root$1, "WeakMap");
var WeakMap$3 = WeakMap$2;
var objectCreate$1 = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$5(proto)) {
      return {};
    }
    if (objectCreate$1) {
      return objectCreate$1(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate$1 = baseCreate;
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function copyArray(source2, array) {
  var index2 = -1, length2 = source2.length;
  array || (array = Array(length2));
  while (++index2 < length2) {
    array[index2] = source2[index2];
  }
  return array;
}
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
function constant(value) {
  return function() {
    return value;
  };
}
var defineProperty$1 = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var defineProperty$2 = defineProperty$1;
var baseSetToString = !defineProperty$2 ? identity$1 : function(func, string) {
  return defineProperty$2(func, "toString", { "configurable": true, "enumerable": false, "value": constant(string), "writable": true });
};
var baseSetToString$1 = baseSetToString;
var setToString = shortOut(baseSetToString$1);
var setToString$1 = setToString;
function arrayEach(array, iteratee) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length2 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
function baseIsNaN(value) {
  return value !== value;
}
function strictIndexOf(array, value, fromIndex) {
  var index2 = fromIndex - 1, length2 = array.length;
  while (++index2 < length2) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return -1;
}
function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length2) {
  var type = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length2;
}
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty$2) {
    defineProperty$2(object, key, { "configurable": true, "enumerable": true, "value": value, "writable": true });
  } else {
    object[key] = value;
  }
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var objectProto$c = Object.prototype;
var hasOwnProperty$b = objectProto$c.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$b.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function copyObject(source2, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length2 = props.length;
  while (++index2 < length2) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : void 0;
    if (newValue === void 0) {
      newValue = source2[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
var nativeMax$1 = Math.max;
function overRest(func, start2, transform) {
  start2 = nativeMax$1(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length2 = nativeMax$1(args.length - start2, 0), array = Array(length2);
    while (++index2 < length2) {
      array[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform(array);
    return apply(func, this, otherArgs);
  };
}
function baseRest(func, start2) {
  return setToString$1(overRest(func, start2, identity$1), func + "");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isArrayLike$1(value) {
  return value != null && isLength(value.length) && !isFunction$3(value);
}
function isIterateeCall(value, index2, object) {
  if (!isObject$5(object)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike$1(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
    return eq(object[index2], value);
  }
  return false;
}
var objectProto$b = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$b;
  return value === proto;
}
function baseTimes(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$3 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$3;
}
var objectProto$a = Object.prototype;
var hasOwnProperty$a = objectProto$a.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$a.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments$1 = isArguments;
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
var isBuffer$1 = nativeIsBuffer || stubFalse;
var isBuffer$2 = isBuffer$1;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types2) {
      return types2;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;
var objectProto$9 = Object.prototype;
var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$4(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$9.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;
var objectProto$8 = Object.prototype;
var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$8.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys$1(object) {
  return isArrayLike$1(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject$5(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$7.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike$1(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray$4(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$6 = Object.prototype;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
function hashGet(key) {
  var data2 = this.__data__;
  if (nativeCreate$1) {
    var result = data2[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$6.call(data2, key) ? data2[key] : void 0;
}
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function hashHas(key) {
  var data2 = this.__data__;
  return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$5.call(data2, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data2 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data2[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array, key) {
  var length2 = array.length;
  while (length2--) {
    if (eq(array[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var arrayProto$1 = Array.prototype;
var splice$1 = arrayProto$1.splice;
function listCacheDelete(key) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index2 == lastIndex) {
    data2.pop();
  } else {
    splice$1.call(data2, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key);
  return index2 < 0 ? void 0 : data2[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key);
  if (index2 < 0) {
    ++this.size;
    data2.push([key, value]);
  } else {
    data2[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root$1, "Map");
var Map$2 = Map$1;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = { "hash": new Hash(), "map": new (Map$2 || ListCache)(), "string": new Hash() };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map2, key) {
  var data2 = map2.__data__;
  return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data2 = getMapData(this, key), size = data2.size;
  data2.set(key, value);
  this.size += data2.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var stringToPath$1 = stringToPath;
function toString$1(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object) {
  if (isArray$4(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath$1(toString$1(value));
}
var INFINITY = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function baseGet(object, path) {
  path = castPath(path, object);
  var index2 = 0, length2 = path.length;
  while (object != null && index2 < length2) {
    object = object[toKey(path[index2++])];
  }
  return index2 && index2 == length2 ? object : void 0;
}
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
function arrayPush(array, values2) {
  var index2 = -1, length2 = values2.length, offset = array.length;
  while (++index2 < length2) {
    array[offset + index2] = values2[index2];
  }
  return array;
}
var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray$4(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index2 = -1, length2 = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length2) {
    var value = array[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
function flatten(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? baseFlatten(array, 1) : [];
}
function flatRest(func) {
  return setToString$1(overRest(func, void 0, flatten), func + "");
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
var objectTag$3 = "[object Object]";
var funcProto = Function.prototype, objectProto$4 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$1(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$4.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
function baseSlice(array, start2, end2) {
  var index2 = -1, length2 = array.length;
  if (start2 < 0) {
    start2 = -start2 > length2 ? 0 : length2 + start2;
  }
  end2 = end2 > length2 ? length2 : end2;
  if (end2 < 0) {
    end2 += length2;
  }
  length2 = start2 > end2 ? 0 : end2 - start2 >>> 0;
  start2 >>>= 0;
  var result = Array(length2);
  while (++index2 < length2) {
    result[index2] = array[index2 + start2];
  }
  return result;
}
function castSlice(array, start2, end2) {
  var length2 = array.length;
  end2 = end2 === void 0 ? length2 : end2;
  return !start2 && end2 >= length2 ? array : baseSlice(array, start2, end2);
}
var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f";
var rsZWJ$2 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
function asciiToArray(string) {
  return string.split("");
}
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d";
var reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
function stringToArray(string) {
  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
}
function createCaseFirst(methodName) {
  return function(string) {
    string = toString$1(string);
    var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var upperFirst = createCaseFirst("toUpperCase");
var upperFirst$1 = upperFirst;
function capitalize(string) {
  return upperFirst$1(toString$1(string).toLowerCase());
}
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  if (initAccum && length2) {
    accumulator = array[++index2];
  }
  while (++index2 < length2) {
    accumulator = iteratee(accumulator, array[index2], index2, array);
  }
  return accumulator;
}
function basePropertyOf(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var deburredLetters = { "\xC0": "A", "\xC1": "A", "\xC2": "A", "\xC3": "A", "\xC4": "A", "\xC5": "A", "\xE0": "a", "\xE1": "a", "\xE2": "a", "\xE3": "a", "\xE4": "a", "\xE5": "a", "\xC7": "C", "\xE7": "c", "\xD0": "D", "\xF0": "d", "\xC8": "E", "\xC9": "E", "\xCA": "E", "\xCB": "E", "\xE8": "e", "\xE9": "e", "\xEA": "e", "\xEB": "e", "\xCC": "I", "\xCD": "I", "\xCE": "I", "\xCF": "I", "\xEC": "i", "\xED": "i", "\xEE": "i", "\xEF": "i", "\xD1": "N", "\xF1": "n", "\xD2": "O", "\xD3": "O", "\xD4": "O", "\xD5": "O", "\xD6": "O", "\xD8": "O", "\xF2": "o", "\xF3": "o", "\xF4": "o", "\xF5": "o", "\xF6": "o", "\xF8": "o", "\xD9": "U", "\xDA": "U", "\xDB": "U", "\xDC": "U", "\xF9": "u", "\xFA": "u", "\xFB": "u", "\xFC": "u", "\xDD": "Y", "\xFD": "y", "\xFF": "y", "\xC6": "Ae", "\xE6": "ae", "\xDE": "Th", "\xFE": "th", "\xDF": "ss", "\u0100": "A", "\u0102": "A", "\u0104": "A", "\u0101": "a", "\u0103": "a", "\u0105": "a", "\u0106": "C", "\u0108": "C", "\u010A": "C", "\u010C": "C", "\u0107": "c", "\u0109": "c", "\u010B": "c", "\u010D": "c", "\u010E": "D", "\u0110": "D", "\u010F": "d", "\u0111": "d", "\u0112": "E", "\u0114": "E", "\u0116": "E", "\u0118": "E", "\u011A": "E", "\u0113": "e", "\u0115": "e", "\u0117": "e", "\u0119": "e", "\u011B": "e", "\u011C": "G", "\u011E": "G", "\u0120": "G", "\u0122": "G", "\u011D": "g", "\u011F": "g", "\u0121": "g", "\u0123": "g", "\u0124": "H", "\u0126": "H", "\u0125": "h", "\u0127": "h", "\u0128": "I", "\u012A": "I", "\u012C": "I", "\u012E": "I", "\u0130": "I", "\u0129": "i", "\u012B": "i", "\u012D": "i", "\u012F": "i", "\u0131": "i", "\u0134": "J", "\u0135": "j", "\u0136": "K", "\u0137": "k", "\u0138": "k", "\u0139": "L", "\u013B": "L", "\u013D": "L", "\u013F": "L", "\u0141": "L", "\u013A": "l", "\u013C": "l", "\u013E": "l", "\u0140": "l", "\u0142": "l", "\u0143": "N", "\u0145": "N", "\u0147": "N", "\u014A": "N", "\u0144": "n", "\u0146": "n", "\u0148": "n", "\u014B": "n", "\u014C": "O", "\u014E": "O", "\u0150": "O", "\u014D": "o", "\u014F": "o", "\u0151": "o", "\u0154": "R", "\u0156": "R", "\u0158": "R", "\u0155": "r", "\u0157": "r", "\u0159": "r", "\u015A": "S", "\u015C": "S", "\u015E": "S", "\u0160": "S", "\u015B": "s", "\u015D": "s", "\u015F": "s", "\u0161": "s", "\u0162": "T", "\u0164": "T", "\u0166": "T", "\u0163": "t", "\u0165": "t", "\u0167": "t", "\u0168": "U", "\u016A": "U", "\u016C": "U", "\u016E": "U", "\u0170": "U", "\u0172": "U", "\u0169": "u", "\u016B": "u", "\u016D": "u", "\u016F": "u", "\u0171": "u", "\u0173": "u", "\u0174": "W", "\u0175": "w", "\u0176": "Y", "\u0177": "y", "\u0178": "Y", "\u0179": "Z", "\u017B": "Z", "\u017D": "Z", "\u017A": "z", "\u017C": "z", "\u017E": "z", "\u0132": "IJ", "\u0133": "ij", "\u0152": "Oe", "\u0153": "oe", "\u0149": "'n", "\u017F": "s" };
var deburrLetter = basePropertyOf(deburredLetters);
var deburrLetter$1 = deburrLetter;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsCombo$1 = "[" + rsComboRange$1 + "]";
var reComboMark = RegExp(rsCombo$1, "g");
function deburr(string) {
  string = toString$1(string);
  return string && string.replace(reLatin, deburrLetter$1).replace(reComboMark, "");
}
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "['\u2019]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
var reUnicodeWord = RegExp([rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")", rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")", rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower, rsUpper + "+" + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join("|"), "g");
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}
function words(string, pattern, guard) {
  string = toString$1(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}
var rsApos = "['\u2019]";
var reApos = RegExp(rsApos, "g");
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
  };
}
var camelCase$2 = createCompounder(function(result, word, index2) {
  word = word.toLowerCase();
  return result + (index2 ? capitalize(word) : word);
});
var camelCase$3 = camelCase$2;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data2 = this.__data__, result = data2["delete"](key);
  this.size = data2.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data2 = this.__data__;
  if (data2 instanceof ListCache) {
    var pairs = data2.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data2.size;
      return this;
    }
    data2 = this.__data__ = new MapCache(pairs);
  }
  data2.set(key, value);
  this.size = data2.size;
  return this;
}
function Stack(entries) {
  var data2 = this.__data__ = new ListCache(entries);
  this.size = data2.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(object, source2) {
  return object && copyObject(source2, keys$1(source2), object);
}
function baseAssignIn(object, source2) {
  return object && copyObject(source2, keysIn(source2), object);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer$1 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
function cloneBuffer(buffer2, isDeep) {
  if (isDeep) {
    return buffer2.slice();
  }
  var length2 = buffer2.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer2.constructor(length2);
  buffer2.copy(result);
  return result;
}
function arrayFilter(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length2) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$3 = Object.prototype;
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var getSymbols$1 = getSymbols;
function copySymbols(source2, object) {
  return copyObject(source2, getSymbols$1(source2), object);
}
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols$1(object));
    object = getPrototype$1(object);
  }
  return result;
};
var getSymbolsIn$1 = getSymbolsIn;
function copySymbolsIn(source2, object) {
  return copyObject(source2, getSymbolsIn$1(source2), object);
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$4(object) ? result : arrayPush(result, symbolsFunc(object));
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys$1, getSymbols$1);
}
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
}
var DataView$1 = getNative(root$1, "DataView");
var DataView$2 = DataView$1;
var Promise$1 = getNative(root$1, "Promise");
var Promise$2 = Promise$1;
var Set$1 = getNative(root$1, "Set");
var Set$2 = Set$1;
var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$3 = "[object DataView]";
var dataViewCtorString = toSource(DataView$2), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$3);
var getTag = baseGetTag;
if (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$3 || Map$2 && getTag(new Map$2()) != mapTag$4 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$4 || WeakMap$3 && getTag(new WeakMap$3()) != weakMapTag$1) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$3;
        case mapCtorString:
          return mapTag$4;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$4;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var objectProto$2 = Object.prototype;
var hasOwnProperty$3 = objectProto$2.hasOwnProperty;
function initCloneArray(array) {
  var length2 = array.length, result = new array.constructor(length2);
  if (length2 && typeof array[0] == "string" && hasOwnProperty$3.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var Uint8Array$1 = root$1.Uint8Array;
var Uint8Array$2 = Uint8Array$1;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
}
var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object);
    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object);
    case dataViewTag$2:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$3:
      return new Ctor();
    case numberTag$2:
    case stringTag$2:
      return new Ctor(object);
    case regexpTag$2:
      return cloneRegExp(object);
    case setTag$3:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object);
  }
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
}
var mapTag$2 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$2;
}
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
var isMap$1 = isMap;
var setTag$2 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$2;
}
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet$2 = isSet$1;
var CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$5(value)) {
    return value;
  }
  var isArr = isArray$4(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$2(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet$2(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys$1;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var CLONE_DEEP_FLAG$1 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values2) {
  var index2 = -1, length2 = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache();
  while (++index2 < length2) {
    this.add(values2[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache2, key) {
  return cache2.has(key);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
function mapToArray(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
function setToArray(set) {
  var index2 = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag:
      var convert = mapToArray;
    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$4(object), othIsArr = isArray$4(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$2(object)) {
    if (!isBuffer$2(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object, source2, matchData, customizer) {
  var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length2;
  }
  object = Object(object);
  while (index2--) {
    var data2 = matchData[index2];
    if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
      return false;
    }
  }
  while (++index2 < length2) {
    data2 = matchData[index2];
    var key = data2[0], objValue = object[key], srcValue = data2[1];
    if (noCustomizer && data2[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source2, stack);
      }
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject$5(value);
}
function getMatchData(object) {
  var result = keys$1(object), length2 = result.length;
  while (length2--) {
    var key = result[length2], value = object[key];
    result[length2] = [key, value, isStrictComparable(value)];
  }
  return result;
}
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
function baseMatches(source2) {
  var matchData = getMatchData(source2);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source2 || baseIsMatch(object, source2, matchData);
  };
}
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index2 = -1, length2 = path.length, result = false;
  while (++index2 < length2) {
    var key = toKey(path[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length2) {
    return result;
  }
  length2 = object == null ? 0 : object.length;
  return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray$4(object) || isArguments$1(object));
}
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$1;
  }
  if (typeof value == "object") {
    return isArray$4(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
    while (length2--) {
      var key = props[fromRight ? length2 : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor = createBaseFor();
var baseFor$1 = baseFor;
function baseForOwn(object, iteratee) {
  return object && baseFor$1(object, iteratee, keys$1);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$1(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length2) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach = createBaseEach(baseForOwn);
var baseEach$1 = baseEach;
var now = function() {
  return root$1.Date.now();
};
var now$1 = now;
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce$1(func, wait, options2) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject$5(options2)) {
    leading = !!options2.leading;
    maxing = "maxWait" in options2;
    maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options2 ? !!options2.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$1());
  }
  function debounced() {
    var time = now$1(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function last$1(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? array[length2 - 1] : void 0;
}
function arrayEvery(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (!predicate(array[index2], index2, array)) {
      return false;
    }
  }
  return true;
}
function baseEvery(collection, predicate) {
  var result = true;
  baseEach$1(collection, function(value, index2, collection2) {
    result = !!predicate(value, index2, collection2);
    return result;
  });
  return result;
}
function every$1(collection, predicate, guard) {
  var func = isArray$4(collection) ? arrayEvery : baseEvery;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee(predicate));
}
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike$1(collection) ? Array(collection.length) : [];
  baseEach$1(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
function isMatch(object, source2) {
  return object === source2 || baseIsMatch(object, source2, getMatchData(source2));
}
var kebabCase = createCompounder(function(result, word, index2) {
  return result + (index2 ? "-" : "") + word.toLowerCase();
});
var kebabCase$1 = kebabCase;
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last$1(path))];
}
function customOmitClone(value) {
  return isPlainObject$1(value) ? void 0 : value;
}
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length2 = paths.length;
  while (length2--) {
    baseUnset(result, paths[length2]);
  }
  return result;
});
var omit$1 = omit;
function baseSet(object, path, value, customizer) {
  if (!isObject$5(object)) {
    return object;
  }
  path = castPath(path, object);
  var index2 = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
  while (nested != null && ++index2 < length2) {
    var key = toKey(path[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$5(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
function basePickBy(object, paths, predicate) {
  var index2 = -1, length2 = paths.length, result = {};
  while (++index2 < length2) {
    var path = paths[index2], value = baseGet(object, path);
    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}
function baseSortBy(array, comparer) {
  var length2 = array.length;
  array.sort(comparer);
  while (length2--) {
    array[length2] = array[length2].value;
  }
  return array;
}
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
function compareMultiple(object, other, orders) {
  var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
  while (++index2 < length2) {
    var result = compareAscending(objCriteria[index2], othCriteria[index2]);
    if (result) {
      if (index2 >= ordersLength) {
        return result;
      }
      var order = orders[index2];
      return result * (order == "desc" ? -1 : 1);
    }
  }
  return object.index - other.index;
}
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap(iteratees, function(iteratee) {
      if (isArray$4(iteratee)) {
        return function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        };
      }
      return iteratee;
    });
  } else {
    iteratees = [identity$1];
  }
  var index2 = -1;
  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
  var result = baseMap(collection, function(value, key, collection2) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { "criteria": criteria, "index": ++index2, "value": value };
  });
  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});
var pick$1 = pick;
function baseIndexOfWith(array, value, fromIndex, comparator) {
  var index2 = fromIndex - 1, length2 = array.length;
  while (++index2 < length2) {
    if (comparator(array[index2], value)) {
      return index2;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function basePullAll(array, values2, iteratee, comparator) {
  var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length2 = values2.length, seen = array;
  if (array === values2) {
    values2 = copyArray(values2);
  }
  if (iteratee) {
    seen = arrayMap(array, baseUnary(iteratee));
  }
  while (++index2 < length2) {
    var fromIndex = 0, value = values2[index2], computed = iteratee ? iteratee(value) : value;
    while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array) {
        splice.call(seen, fromIndex, 1);
      }
      splice.call(array, fromIndex, 1);
    }
  }
  return array;
}
function pullAll(array, values2) {
  return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
}
var pull$1 = baseRest(pullAll);
var pull$2 = pull$1;
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length2 = iteratees.length;
  if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});
var sortBy$1 = sortBy;
var fastDeepEqual = function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length2, i2, keys2;
    if (Array.isArray(a)) {
      length2 = a.length;
      if (length2 != b.length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (!equal(a[i2], b[i2]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys2 = Object.keys(a);
    length2 = keys2.length;
    if (length2 !== Object.keys(b).length)
      return false;
    for (i2 = length2; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys2[i2]))
        return false;
    for (i2 = length2; i2-- !== 0; ) {
      var key = keys2[i2];
      if (!equal(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
const generateId = () => (Math.random() * 1e20).toString(36);
const insertAt$1 = (index2 = 0, ins, arr, replace = false) => [...arr.slice(0, index2), ...[ins].flat(), ...arr.slice(replace ? index2 + 1 : index2)];
const replaceItem$1 = (match, newItem, arr) => {
  match = typeof match === "function" ? match : (x2) => x2 === match;
  const index2 = arr.findIndex(match);
  if (index2 < 0)
    return arr;
  return insertAt$1(index2, newItem, arr, true);
};
const swapIndex = (indexA, indexB, arr) => {
  if (!arr[indexA] || !arr[indexB])
    return arr;
  arr = [...arr];
  const prevA = arr[indexA];
  arr[indexA] = arr[indexB];
  arr[indexB] = prevA;
  return arr;
};
const swapItems = (itemA, itemB, arr) => {
  const indexA = arr.findIndex((x2) => x2 === itemA);
  const indexB = arr.findIndex((x2) => x2 === itemB);
  if (indexA < 0 || indexB < 0)
    return arr;
  return swapIndex(indexA, indexB, arr);
};
const toDataNode$1 = (node) => {
  if (!node)
    return null;
  return { id: node.id, props: node.props, childIds: (node.children || []).map((x2) => x2.id) };
};
const toSceneNode = (node) => {
  return { id: node.id, props: node.props, children: [] };
};
const toSceneTree = (nodes, rootId) => {
  const root2 = nodes.find((x2) => x2.id === rootId);
  if (!root2)
    return null;
  const childIds = root2.childIds;
  return { id: root2.id, props: root2.props, children: childIds.map((x2) => toSceneTree(nodes, x2)).filter(Boolean) };
};
const forEachDown$1 = (node, fn) => {
  fn(node);
  const children = node.children || [];
  children.forEach((x2) => forEachDown$1(x2, (next, parent2) => {
    fn(next, parent2 || node);
  }));
};
const mapDown = (node, fn) => {
  const result = fn(node);
  return { ...result, children: ((result == null ? void 0 : result.children) || (node == null ? void 0 : node.children) || []).map((x2) => mapDown(x2, fn)) };
};
const mapDownAsync = async (node, fn) => {
  var _a2;
  const children = (_a2 = node == null ? void 0 : node.children) != null ? _a2 : [];
  return { ...await fn(node), children: await Promise.all(children.map((x2) => mapDownAsync(x2, fn))) };
};
const getElementAttributes = (x2) => {
  return Object.values(x2.attributes).reduce((acc, x22) => {
    return { ...acc, [x22.name]: x22.value };
  }, {});
};
const asArray = (x2) => {
  return isArray$4(x2) ? x2 : [x2];
};
const sizeToNum = (x2, parentSize) => {
  if (typeof x2 === "number")
    return x2;
  if (typeof x2 === "string") {
    if (x2.indexOf("%") > -1) {
      return parseFloat(x2) / 100 * parentSize;
    }
    return parseFloat(x2);
  }
  return 0;
};
const asSize = (x2) => {
  if (typeof x2 === "number")
    return x2 + "px";
  if (typeof x2 === "string") {
    if (x2.indexOf("%") > -1) {
      return parseFloat(x2) + "%";
    }
    return x2;
  }
  return "0px";
};
const asDuration = (x2) => {
  if (typeof x2 === "string") {
    return x2;
  }
  if (typeof x2 === "number")
    return x2 + "ms";
  return "0ms";
};
const values = (map2) => Array.from(map2.values());
var Logic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, deepEqual: fastDeepEqual, generateId, insertAt: insertAt$1, replaceItem: replaceItem$1, swapIndex, swapItems, toDataNode: toDataNode$1, toSceneNode, toSceneTree, forEachDown: forEachDown$1, mapDown, mapDownAsync, getElementAttributes, asArray, sizeToNum, asSize, asDuration, values, pick: pick$1, pull: pull$2, omit: omit$1, isEqual, cloneDeep, sortBy: sortBy$1, debounce: debounce$1, camelCase: camelCase$3, kebabCase: kebabCase$1, isArray: isArray$4, every: every$1 }, Symbol.toStringTag, { value: "Module" }));
var lib$2 = {};
function e(e2) {
  this.message = e2;
}
e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
var r$1 = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r2) {
  var t2 = String(r2).replace(/=+$/, "");
  if (t2.length % 4 == 1)
    throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var n2, o2, a = 0, i2 = 0, c = ""; o2 = t2.charAt(i2++); ~o2 && (n2 = a % 4 ? 64 * n2 + o2 : o2, a++ % 4) ? c += String.fromCharCode(255 & n2 >> (-2 * a & 6)) : 0)
    o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
  return c;
};
function t(e2) {
  var t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
  switch (t2.length % 4) {
    case 0:
      break;
    case 2:
      t2 += "==";
      break;
    case 3:
      t2 += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(e3) {
      return decodeURIComponent(r$1(e3).replace(/(.)/g, function(e4, r2) {
        var t3 = r2.charCodeAt(0).toString(16).toUpperCase();
        return t3.length < 2 && (t3 = "0" + t3), "%" + t3;
      }));
    }(t2);
  } catch (e3) {
    return r$1(t2);
  }
}
function n(e2) {
  this.message = e2;
}
function o(e2, r2) {
  if ("string" != typeof e2)
    throw new n("Invalid token specified");
  var o2 = true === (r2 = r2 || {}).header ? 0 : 1;
  try {
    return JSON.parse(t(e2.split(".")[o2]));
  } catch (e3) {
    throw new n("Invalid token specified: " + e3.message);
  }
}
n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
var jwtDecode_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, "default": o, InvalidTokenError: n }, Symbol.toStringTag, { value: "Module" }));
var require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(jwtDecode_esm);
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate$1(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate$1(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var _nodeId;
var _clockseq;
var _lastMSecs = 0;
var _lastNSecs = 0;
function v1(options2, buf, offset) {
  var i2 = buf && offset || 0;
  var b = buf || new Array(16);
  options2 = options2 || {};
  var node = options2.node || _nodeId;
  var clockseq = options2.clockseq !== void 0 ? options2.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options2.random || (options2.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options2.msecs !== void 0 ? options2.msecs : Date.now();
  var nsecs = options2.nsecs !== void 0 ? options2.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options2.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options2.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i2++] = tl >>> 24 & 255;
  b[i2++] = tl >>> 16 & 255;
  b[i2++] = tl >>> 8 & 255;
  b[i2++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i2++] = tmh >>> 8 & 255;
  b[i2++] = tmh & 255;
  b[i2++] = tmh >>> 24 & 15 | 16;
  b[i2++] = tmh >>> 16 & 255;
  b[i2++] = clockseq >>> 8 | 128;
  b[i2++] = clockseq & 255;
  for (var n2 = 0; n2 < 6; ++n2) {
    b[i2 + n2] = node[n2];
  }
  return buf || stringify(b);
}
function parse$1(uuid) {
  if (!validate$1(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v2;
  var arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    bytes.push(str.charCodeAt(i2));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name2, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse$1(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = bytes[i2];
      }
      return buf;
    }
    return stringify(bytes);
  }
  try {
    generateUUID.name = name2;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL$1;
  return generateUUID;
}
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i2 = 0; i2 < msg.length; ++i2) {
      bytes[i2] = msg.charCodeAt(i2);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i2 = 0; i2 < length32; i2 += 8) {
    var x2 = input[i2 >> 5] >>> i2 % 32 & 255;
    var hex = parseInt(hexTab.charAt(x2 >>> 4 & 15) + hexTab.charAt(x2 & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x2, len) {
  x2[len >> 5] |= 128 << len % 32;
  x2[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i2 = 0; i2 < x2.length; i2 += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x2[i2], 7, -680876936);
    d = md5ff(d, a, b, c, x2[i2 + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x2[i2 + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x2[i2 + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x2[i2 + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x2[i2 + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x2[i2 + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x2[i2 + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x2[i2 + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x2[i2 + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x2[i2 + 10], 17, -42063);
    b = md5ff(b, c, d, a, x2[i2 + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x2[i2 + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x2[i2 + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x2[i2 + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x2[i2 + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x2[i2 + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x2[i2 + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x2[i2 + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x2[i2], 20, -373897302);
    a = md5gg(a, b, c, d, x2[i2 + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x2[i2 + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x2[i2 + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x2[i2 + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x2[i2 + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x2[i2 + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x2[i2 + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x2[i2 + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x2[i2 + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x2[i2 + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x2[i2 + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x2[i2 + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x2[i2 + 5], 4, -378558);
    d = md5hh(d, a, b, c, x2[i2 + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x2[i2 + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x2[i2 + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x2[i2 + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x2[i2 + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x2[i2 + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x2[i2 + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x2[i2 + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x2[i2], 11, -358537222);
    c = md5hh(c, d, a, b, x2[i2 + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x2[i2 + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x2[i2 + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x2[i2 + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x2[i2 + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x2[i2 + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x2[i2], 6, -198630844);
    d = md5ii(d, a, b, c, x2[i2 + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x2[i2 + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x2[i2 + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x2[i2 + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x2[i2 + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x2[i2 + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x2[i2 + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x2[i2 + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x2[i2 + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x2[i2 + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x2[i2 + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x2[i2 + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x2[i2 + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x2[i2 + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x2[i2 + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i2 = 0; i2 < length8; i2 += 8) {
    output[i2 >> 5] |= (input[i2 / 8] & 255) << i2 % 32;
  }
  return output;
}
function safeAdd(x2, y2) {
  var lsw = (x2 & 65535) + (y2 & 65535);
  var msw = (x2 >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q2, a, b, x2, s, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q2), safeAdd(x2, t2)), s), b);
}
function md5ff(a, b, c, d, x2, s, t2) {
  return md5cmn(b & c | ~b & d, a, b, x2, s, t2);
}
function md5gg(a, b, c, d, x2, s, t2) {
  return md5cmn(b & d | c & ~d, a, b, x2, s, t2);
}
function md5hh(a, b, c, d, x2, s, t2) {
  return md5cmn(b ^ c ^ d, a, b, x2, s, t2);
}
function md5ii(a, b, c, d, x2, s, t2) {
  return md5cmn(c ^ (b | ~d), a, b, x2, s, t2);
}
var v3 = v35("v3", 48, md5);
var v3$1 = v3;
function v4(options2, buf, offset) {
  options2 = options2 || {};
  var rnds = options2.random || (options2.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return stringify(rnds);
}
function f(s, x2, y2, z2) {
  switch (s) {
    case 0:
      return x2 & y2 ^ ~x2 & z2;
    case 1:
      return x2 ^ y2 ^ z2;
    case 2:
      return x2 & y2 ^ x2 & z2 ^ y2 & z2;
    case 3:
      return x2 ^ y2 ^ z2;
  }
}
function ROTL(x2, n2) {
  return x2 << n2 | x2 >>> 32 - n2;
}
function sha1(bytes) {
  var K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  var H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i2 = 0; i2 < msg.length; ++i2) {
      bytes.push(msg.charCodeAt(i2));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l2 = bytes.length / 4 + 2;
  var N2 = Math.ceil(l2 / 16);
  var M2 = new Array(N2);
  for (var _i = 0; _i < N2; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M2[_i] = arr;
  }
  M2[N2 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M2[N2 - 1][14] = Math.floor(M2[N2 - 1][14]);
  M2[N2 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N2; ++_i2) {
    var W2 = new Uint32Array(80);
    for (var t2 = 0; t2 < 16; ++t2) {
      W2[t2] = M2[_i2][t2];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W2[_t] = ROTL(W2[_t - 3] ^ W2[_t - 8] ^ W2[_t - 14] ^ W2[_t - 16], 1);
    }
    var a = H2[0];
    var b = H2[1];
    var c = H2[2];
    var d = H2[3];
    var e2 = H2[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T2 = ROTL(a, 5) + f(s, b, c, d) + e2 + K2[s] + W2[_t2] >>> 0;
      e2 = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T2;
    }
    H2[0] = H2[0] + a >>> 0;
    H2[1] = H2[1] + b >>> 0;
    H2[2] = H2[2] + c >>> 0;
    H2[3] = H2[3] + d >>> 0;
    H2[4] = H2[4] + e2 >>> 0;
  }
  return [H2[0] >> 24 & 255, H2[0] >> 16 & 255, H2[0] >> 8 & 255, H2[0] & 255, H2[1] >> 24 & 255, H2[1] >> 16 & 255, H2[1] >> 8 & 255, H2[1] & 255, H2[2] >> 24 & 255, H2[2] >> 16 & 255, H2[2] >> 8 & 255, H2[2] & 255, H2[3] >> 24 & 255, H2[3] >> 16 & 255, H2[3] >> 8 & 255, H2[3] & 255, H2[4] >> 24 & 255, H2[4] >> 16 & 255, H2[4] >> 8 & 255, H2[4] & 255];
}
var v5 = v35("v5", 80, sha1);
var v5$1 = v5;
var nil = "00000000-0000-0000-0000-000000000000";
function version$3(uuid) {
  if (!validate$1(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, v1, v3: v3$1, v4, v5: v5$1, NIL: nil, version: version$3, validate: validate$1, stringify, parse: parse$1 }, Symbol.toStringTag, { value: "Module" }));
var require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser);
class EnhancedMap$1 extends Map {
  computeIfAbsent(key, computer) {
    if (this.has(key)) {
      return this.get(key);
    }
    const newValue = computer(key);
    this.set(key, newValue);
    return newValue;
  }
  computeIfPresent(key, computer) {
    const currentValue = this.get(key);
    if (currentValue === void 0) {
      return void 0;
    }
    const newValue = computer(key, currentValue);
    if (newValue !== void 0) {
      this.set(key, newValue);
    } else {
      this.delete(key);
    }
    return newValue;
  }
  compute(key, computer) {
    const currentValue = this.get(key);
    const newValue = computer(key, currentValue);
    if (newValue) {
      this.set(key, newValue);
    } else {
      this.delete(key);
    }
    return newValue;
  }
}
var InternalLogLevel$1;
(function(InternalLogLevel2) {
  InternalLogLevel2[InternalLogLevel2["Trace"] = 0] = "Trace";
  InternalLogLevel2[InternalLogLevel2["Debug"] = 1] = "Debug";
  InternalLogLevel2[InternalLogLevel2["Info"] = 2] = "Info";
  InternalLogLevel2[InternalLogLevel2["Warn"] = 3] = "Warn";
  InternalLogLevel2[InternalLogLevel2["Error"] = 4] = "Error";
})(InternalLogLevel$1 || (InternalLogLevel$1 = {}));
function getInternalLogger$1(name2) {
  return provider$1.getLogger(name2);
}
const INTERNAL_LOGGING_SETTINGS$1 = { setInternalLogLevel: (level) => provider$1.changeLogLevel(level), setOutput: (fnOutput) => provider$1.changeOutput(fnOutput), reset: () => provider$1.reset() };
class InternalLoggerImpl$1 {
  constructor(name2, level, fnOutput) {
    this._name = name2;
    this._level = level;
    this._fnOutput = fnOutput;
  }
  trace(msg) {
    this.log(InternalLogLevel$1.Trace, msg);
  }
  debug(msg) {
    this.log(InternalLogLevel$1.Debug, msg);
  }
  error(msg, error) {
    this.log(InternalLogLevel$1.Error, msg, error);
  }
  info(msg) {
    this.log(InternalLogLevel$1.Info, msg);
  }
  warn(msg, error) {
    this.log(InternalLogLevel$1.Warn, msg, error);
  }
  setLevel(level) {
    this._level = level;
  }
  setOutput(fnOutput) {
    this._fnOutput = fnOutput;
  }
  log(level, msg, error) {
    if (this._level > level) {
      return;
    }
    this._fnOutput(`${InternalLogLevel$1[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${msg()}${error ? "\n" + error.stack : ""}`);
  }
}
class InternalProviderImpl$1 {
  constructor() {
    this._loggers = new EnhancedMap$1();
    this._logLevel = InternalLogLevel$1.Error;
    this._fnOutput = InternalProviderImpl$1.logConsole;
  }
  getLogger(name2) {
    return this._loggers.computeIfAbsent(name2, (key) => new InternalLoggerImpl$1(key, this._logLevel, this._fnOutput));
  }
  changeLogLevel(level) {
    this._logLevel = level;
    this._loggers.forEach((logger2) => logger2.setLevel(level));
  }
  changeOutput(_fnOutput) {
    this._fnOutput = _fnOutput;
    this._loggers.forEach((logger2) => logger2.setOutput(this._fnOutput));
  }
  reset() {
    this.changeLogLevel(InternalLogLevel$1.Error);
    this._fnOutput = InternalProviderImpl$1.logConsole;
    this._loggers.forEach((logger2) => logger2.setOutput(this._fnOutput));
  }
  static logConsole(msg) {
    if (console && console.log) {
      console.log(msg);
    }
  }
}
const provider$1 = new InternalProviderImpl$1();
var InternalLogger$1 = /* @__PURE__ */ Object.freeze({ __proto__: null, get InternalLogLevel() {
  return InternalLogLevel$1;
}, getInternalLogger: getInternalLogger$1, INTERNAL_LOGGING_SETTINGS: INTERNAL_LOGGING_SETTINGS$1 });
var LogLevel$1;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Trace"] = 0] = "Trace";
  LogLevel2[LogLevel2["Debug"] = 1] = "Debug";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Warn"] = 3] = "Warn";
  LogLevel2[LogLevel2["Error"] = 4] = "Error";
  LogLevel2[LogLevel2["Fatal"] = 5] = "Fatal";
})(LogLevel$1 || (LogLevel$1 = {}));
(function(LogLevel2) {
  function toLogLevel(val) {
    switch (val.toLowerCase()) {
      case "trace":
        return LogLevel2.Trace;
      case "debug":
        return LogLevel2.Debug;
      case "info":
        return LogLevel2.Info;
      case "warn":
        return LogLevel2.Warn;
      case "error":
        return LogLevel2.Error;
      case "fatal":
        return LogLevel2.Fatal;
      default:
        return void 0;
    }
  }
  LogLevel2.toLogLevel = toLogLevel;
})(LogLevel$1 || (LogLevel$1 = {}));
class CoreLoggerImpl$1 {
  constructor(runtime) {
    this._runtime = runtime;
  }
  get id() {
    return this._runtime.id;
  }
  get logLevel() {
    return this._runtime.level;
  }
  get runtimeSettings() {
    return Object.assign({}, this._runtime);
  }
  set runtimeSettings(runtime) {
    this._runtime = runtime;
  }
  trace(message, ...args) {
    this.logMessage(LogLevel$1.Trace, message, args);
  }
  debug(message, ...args) {
    this.logMessage(LogLevel$1.Debug, message, args);
  }
  info(message, ...args) {
    this.logMessage(LogLevel$1.Info, message, args);
  }
  warn(message, ...args) {
    this.logMessage(LogLevel$1.Warn, message, args);
  }
  error(message, ...args) {
    this.logMessage(LogLevel$1.Error, message, args);
  }
  fatal(message, ...args) {
    this.logMessage(LogLevel$1.Fatal, message, args);
  }
  logMessage(level, logMessageType, args) {
    if (this._runtime.level > level) {
      return;
    }
    const nowMillis = Date.now();
    const message = typeof logMessageType === "string" ? logMessageType : logMessageType();
    const errorAndArgs = CoreLoggerImpl$1.getErrorAndArgs(args);
    switch (this._runtime.channel.type) {
      case "RawLogChannel":
        this._runtime.channel.write({ message, exception: errorAndArgs.error, args: errorAndArgs.args, timeInMillis: nowMillis, level, logNames: this._runtime.name }, this._runtime.argumentFormatter);
        return;
      case "LogChannel":
        this._runtime.channel.write(this.createLogMessage(message, level, errorAndArgs, nowMillis));
        break;
    }
  }
  formatArgValue(value) {
    try {
      return this._runtime.argumentFormatter(value);
    } catch (e2) {
      return `>>ARG CONVERT FAILED: '${value !== void 0 ? value.toString() : "undefined"}'<<`;
    }
  }
  createLogMessage(message, level, errorAndArgs, nowMillis) {
    let errorResult;
    const error = errorAndArgs.error;
    const args = errorAndArgs.args;
    if (error) {
      errorResult = `${error.name}: ${error.message}`;
      if (error.stack) {
        errorResult += `@
${error.stack}`;
      }
    }
    const dateFormatted = this._runtime.dateFormatter(nowMillis);
    let levelAsStr = LogLevel$1[level].toUpperCase();
    if (levelAsStr.length < 5) {
      levelAsStr += " ";
    }
    const names = typeof this._runtime.name === "string" ? this._runtime.name : this._runtime.name.join(", ");
    const argsFormatted = typeof args !== "undefined" && args.length > 0 ? " [" + args.map((arg) => this.formatArgValue(arg)).join(", ") + "]" : "";
    const completedMessage = dateFormatted + " " + levelAsStr + " [" + names + "] " + message + argsFormatted;
    return { message: completedMessage, error: errorResult };
  }
  static getErrorAndArgs(args) {
    if (args.length === 0) {
      return {};
    }
    let error;
    let actualArgs;
    const value0 = args[0];
    if (value0 instanceof Error) {
      error = value0;
      actualArgs = args.length > 1 ? args.slice(1) : void 0;
      return { error, args: actualArgs };
    }
    if (typeof value0 === "function") {
      const errorOrArgs = value0();
      if (errorOrArgs instanceof Error) {
        error = errorOrArgs;
        actualArgs = args.length > 1 ? args.slice(1) : void 0;
        return { error, args: actualArgs };
      }
      if (args.length === 1) {
        if (Array.isArray(errorOrArgs)) {
          return { args: errorOrArgs.length > 0 ? errorOrArgs : void 0 };
        } else {
          return { args: errorOrArgs };
        }
      } else {
        if (Array.isArray(errorOrArgs)) {
          return { args: [...errorOrArgs, ...args.slice(1)] };
        }
        return { args: [errorOrArgs, ...args.slice(1)] };
      }
    }
    return { args };
  }
}
function padStart$1(value, length2, fillChar = " ") {
  return padInternal$1(value, length2, "start", fillChar);
}
function padEnd$1(value, length2, fillChar = " ") {
  return padInternal$1(value, length2, "end", fillChar);
}
function maxLengthStringValueInArray$1(arr) {
  return arr.map((v2) => v2.length).reduce((previous, current) => {
    if (current > previous) {
      return current;
    }
    return previous;
  }, 0);
}
function padInternal$1(value, length2, padType, fillChar = " ") {
  if (length2 <= value.length) {
    return value;
  }
  if (fillChar.length > 1) {
    throw new Error(`Fill char must be one char exactly, it is: ${fillChar.length}`);
  }
  const charsNeeded = length2 - value.length;
  let padding = "";
  for (let i2 = 0; i2 < charsNeeded; i2++) {
    padding += fillChar;
  }
  if (padType === "start") {
    return padding + value;
  }
  return value + padding;
}
function formatArgument$1(arg) {
  if (arg === void 0) {
    return "undefined";
  }
  return JSON.stringify(arg);
}
function formatDate$1(millisSinceEpoch) {
  const date = new Date(millisSinceEpoch);
  const year = date.getFullYear();
  const month = padStart$1((date.getMonth() + 1).toString(), 2, "0");
  const day = padStart$1(date.getDate().toString(), 2, "0");
  const hours = padStart$1(date.getHours().toString(), 2, "0");
  const minutes = padStart$1(date.getMinutes().toString(), 2, "0");
  const seconds = padStart$1(date.getSeconds().toString(), 2, "0");
  const millis = padStart$1(date.getMilliseconds().toString(), 2, "0");
  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds},${millis}`;
}
class ConsoleLogChannel$1 {
  constructor() {
    this.type = "LogChannel";
  }
  write(msg) {
    if (console && console.log) {
      console.log(msg.message + (msg.error ? `
${msg.error}` : ""));
    }
  }
}
var DefaultChannels$1;
(function(DefaultChannels2) {
  function createConsoleChannel() {
    return new ConsoleLogChannel$1();
  }
  DefaultChannels2.createConsoleChannel = createConsoleChannel;
})(DefaultChannels$1 || (DefaultChannels$1 = {}));
class LogProviderImpl$1 {
  constructor(name2, settings) {
    this._log = getInternalLogger$1("core.impl.LogProviderImpl");
    this._name = name2;
    this._settings = settings;
    this._loggers = new EnhancedMap$1();
    this._idToKeyMap = new EnhancedMap$1();
    this._globalRuntimeSettings = { level: settings.level, channel: settings.channel };
    this._nextLoggerId = 1;
    this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);
  }
  get runtimeSettings() {
    return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });
  }
  getLogger(name2) {
    return this.getOrCreateLogger(name2);
  }
  updateLoggerRuntime(log2, settings) {
    this._log.debug(() => `Updating logger ${log2.id} runtime settings using: '${JSON.stringify(settings)}'`);
    const key = this._idToKeyMap.get(log2.id);
    if (key === void 0) {
      this._log.warn(() => `Cannot update logger with id: ${log2.id}, it was not found.`);
      return false;
    }
    this._loggers.computeIfPresent(key, (currentKey, currentValue) => {
      currentValue.runtimeSettings = LogProviderImpl$1.mergeRuntimeSettingsIntoLogRuntime(currentValue.runtimeSettings, settings);
      return currentValue;
    });
    return true;
  }
  updateRuntimeSettings(settings) {
    this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(settings)}'`);
    this._globalRuntimeSettings = { level: settings.level !== void 0 ? settings.level : this._globalRuntimeSettings.level, channel: settings.channel !== void 0 ? settings.channel : this._globalRuntimeSettings.channel };
    this._loggers.forEach((logger2) => logger2.runtimeSettings = LogProviderImpl$1.mergeRuntimeSettingsIntoLogRuntime(logger2.runtimeSettings, settings));
  }
  clear() {
    this._loggers.clear();
    this._idToKeyMap.clear();
    this._globalRuntimeSettings = Object.assign({}, this._settings);
    this._nextLoggerId = 1;
  }
  getOrCreateLogger(name2) {
    const key = LogProviderImpl$1.createKey(name2);
    const logger2 = this._loggers.computeIfAbsent(key, () => {
      const runtime = { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel, id: this.nextLoggerId(), name: name2, argumentFormatter: this._settings.argumentFormatter, dateFormatter: this._settings.dateFormatter };
      return new CoreLoggerImpl$1(runtime);
    });
    this._idToKeyMap.computeIfAbsent(logger2.id, () => key);
    return logger2;
  }
  nextLoggerId() {
    const result = this._name + "_" + this._nextLoggerId;
    this._nextLoggerId++;
    return result;
  }
  static mergeRuntimeSettingsIntoLogRuntime(currentSettings, settings) {
    return Object.assign(Object.assign({}, currentSettings), { level: settings.level !== void 0 ? settings.level : currentSettings.level, channel: settings.channel !== void 0 ? settings.channel : currentSettings.channel });
  }
  static createKey(name2) {
    if (typeof name2 === "string") {
      return name2;
    }
    return name2.join(",");
  }
}
function createLogProvider$1(name2, settings) {
  return new LogProviderImpl$1(name2, settings);
}
var index$4 = /* @__PURE__ */ Object.freeze({ __proto__: null, EnhancedMap: EnhancedMap$1, padStart: padStart$1, padEnd: padEnd$1, maxLengthStringValueInArray: maxLengthStringValueInArray$1 });
class ArrayLogChannel {
  constructor() {
    this._buffer = [];
    this.type = "LogChannel";
  }
  write(msg) {
    this._buffer.push(msg);
  }
  get logMessages() {
    return this._buffer;
  }
  get messages() {
    return this._buffer.map((msg) => msg.message);
  }
}
class ArrayRawLogChannel {
  constructor() {
    this._buffer = [];
    this.type = "RawLogChannel";
  }
  write(msg, _) {
    this._buffer.push(msg);
  }
  get messages() {
    return this._buffer.map((m2) => m2.message);
  }
  get errors() {
    return this._buffer.map((m2) => m2.exception);
  }
  get size() {
    return this._buffer.length;
  }
  get rawMessages() {
    return this._buffer;
  }
  clear() {
    this._buffer = [];
  }
}
class TestControlMessage {
  constructor() {
    this._messages = [];
    this.write = this.write.bind(this);
  }
  get messages() {
    return this._messages;
  }
  write(msg) {
    this._messages.push(msg);
  }
  clear() {
    this._messages = [];
  }
}
var TestClasses = /* @__PURE__ */ Object.freeze({ __proto__: null, ArrayLogChannel, ArrayRawLogChannel, TestControlMessage });
var typescriptLogging_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, $internal: InternalLogger$1, $test: TestClasses, get DefaultChannels() {
  return DefaultChannels$1;
}, get LogLevel() {
  return LogLevel$1;
}, createLogProvider: createLogProvider$1, formatArgument: formatArgument$1, formatDate: formatDate$1, util: index$4 }, Symbol.toStringTag, { value: "Module" }));
var require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(typescriptLogging_esm);
var layoutapi = {};
var lib$1 = {};
var lib = {};
var Metadata = {};
Object.defineProperty(Metadata, "__esModule", { value: true });
Metadata.Metadata = void 0;
Metadata.Metadata = function Metadata2(init2) {
  const data2 = /* @__PURE__ */ new Map();
  const metadata = { set(key, value) {
    key = normalizeKey(key);
    if (Array.isArray(value)) {
      if (value.length === 0) {
        data2.delete(key);
      } else {
        for (const item of value) {
          validate(key, item);
        }
        data2.set(key, key.endsWith("-bin") ? value : [value.join(", ")]);
      }
    } else {
      validate(key, value);
      data2.set(key, [value]);
    }
    return metadata;
  }, append(key, value) {
    key = normalizeKey(key);
    validate(key, value);
    let values2 = data2.get(key);
    if (values2 == null) {
      values2 = [];
      data2.set(key, values2);
    }
    values2.push(value);
    if (!key.endsWith("-bin")) {
      data2.set(key, [values2.join(", ")]);
    }
    return metadata;
  }, delete(key) {
    key = normalizeKey(key);
    data2.delete(key);
  }, get(key) {
    var _a2;
    key = normalizeKey(key);
    return (_a2 = data2.get(key)) === null || _a2 === void 0 ? void 0 : _a2[0];
  }, getAll(key) {
    var _a2;
    key = normalizeKey(key);
    return (_a2 = data2.get(key)) !== null && _a2 !== void 0 ? _a2 : [];
  }, has(key) {
    key = normalizeKey(key);
    return data2.has(key);
  }, [Symbol.iterator]() {
    return data2[Symbol.iterator]();
  } };
  if (init2 != null) {
    const entries = isIterable$1(init2) ? init2 : Object.entries(init2);
    for (const [key, value] of entries) {
      metadata.set(key, value);
    }
  }
  return metadata;
};
function normalizeKey(key) {
  return key.toLowerCase();
}
function validate(key, value) {
  if (!/^[0-9a-z_.-]+$/.test(key)) {
    throw new Error(`Metadata key '${key}' contains illegal characters`);
  }
  if (key.endsWith("-bin")) {
    if (!(value instanceof Uint8Array)) {
      throw new Error(`Metadata key '${key}' ends with '-bin', thus it must have binary value`);
    }
  } else {
    if (typeof value !== "string") {
      throw new Error(`Metadata key '${key}' doesn't end with '-bin', thus it must have string value`);
    }
    if (!/^[ -~]*$/.test(value)) {
      throw new Error(`Metadata value '${value}' of key '${key}' contains illegal characters`);
    }
  }
}
function isIterable$1(value) {
  return Symbol.iterator in value;
}
var Status = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Status = void 0;
  (function(Status2) {
    Status2[Status2["OK"] = 0] = "OK";
    Status2[Status2["CANCELLED"] = 1] = "CANCELLED";
    Status2[Status2["UNKNOWN"] = 2] = "UNKNOWN";
    Status2[Status2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    Status2[Status2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    Status2[Status2["NOT_FOUND"] = 5] = "NOT_FOUND";
    Status2[Status2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    Status2[Status2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    Status2[Status2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    Status2[Status2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    Status2[Status2["ABORTED"] = 10] = "ABORTED";
    Status2[Status2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    Status2[Status2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    Status2[Status2["INTERNAL"] = 13] = "INTERNAL";
    Status2[Status2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    Status2[Status2["DATA_LOSS"] = 15] = "DATA_LOSS";
    Status2[Status2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
  })(exports2.Status || (exports2.Status = {}));
})(Status);
var MethodDescriptor = {};
Object.defineProperty(MethodDescriptor, "__esModule", { value: true });
var CallOptions = {};
Object.defineProperty(CallOptions, "__esModule", { value: true });
var ClientMiddleware = {};
Object.defineProperty(ClientMiddleware, "__esModule", { value: true });
var composeClientMiddleware$1 = {};
Object.defineProperty(composeClientMiddleware$1, "__esModule", { value: true });
composeClientMiddleware$1.composeClientMiddleware = void 0;
function composeClientMiddleware(middleware1, middleware2) {
  return (call, options2) => {
    return middleware2({ ...call, next: (request3, options22) => {
      return middleware1({ ...call, request: request3 }, options22);
    } }, options2);
  };
}
composeClientMiddleware$1.composeClientMiddleware = composeClientMiddleware;
var ClientError$1 = {};
var cjs = {};
var helpers = {};
helpers.__esModule = void 0;
helpers.__esModule = true;
var objectSetPrototypeOfIsDefined = typeof Object.setPrototypeOf === "function";
var objectGetPrototypeOfIsDefined = typeof Object.getPrototypeOf === "function";
var objectDefinePropertyIsDefined = typeof Object.defineProperty === "function";
var objectCreateIsDefined = typeof Object.create === "function";
var objectHasOwnPropertyIsDefined = typeof Object.prototype.hasOwnProperty === "function";
var setPrototypeOf = function setPrototypeOf2(target, prototype) {
  if (objectSetPrototypeOfIsDefined) {
    Object.setPrototypeOf(target, prototype);
  } else {
    target.__proto__ = prototype;
  }
};
helpers.setPrototypeOf = setPrototypeOf;
var getPrototypeOf = function getPrototypeOf2(target) {
  if (objectGetPrototypeOfIsDefined) {
    return Object.getPrototypeOf(target);
  } else {
    return target.__proto__ || target.prototype;
  }
};
helpers.getPrototypeOf = getPrototypeOf;
var ie8ObjectDefinePropertyBug = false;
var defineProperty = function defineProperty2(target, name2, propertyDescriptor) {
  if (objectDefinePropertyIsDefined && !ie8ObjectDefinePropertyBug) {
    try {
      Object.defineProperty(target, name2, propertyDescriptor);
    } catch (e2) {
      ie8ObjectDefinePropertyBug = true;
      defineProperty2(target, name2, propertyDescriptor);
    }
  } else {
    target[name2] = propertyDescriptor.value;
  }
};
helpers.defineProperty = defineProperty;
var hasOwnProperty = function hasOwnProperty2(target, name2) {
  if (objectHasOwnPropertyIsDefined) {
    return target.hasOwnProperty(target, name2);
  } else {
    return target[name2] === void 0;
  }
};
helpers.hasOwnProperty = hasOwnProperty;
var objectCreate = function objectCreate2(prototype, propertyDescriptors) {
  if (objectCreateIsDefined) {
    return Object.create(prototype, propertyDescriptors);
  } else {
    var F2 = function F22() {
    };
    F2.prototype = prototype;
    var result = new F2();
    if (typeof propertyDescriptors === "undefined") {
      return result;
    }
    if (typeof propertyDescriptors === "null") {
      throw new Error("PropertyDescriptors must not be null.");
    }
    if (typeof propertyDescriptors === "object") {
      for (var key in propertyDescriptors) {
        if (hasOwnProperty(propertyDescriptors, key)) {
          result[key] = propertyDescriptors[key].value;
        }
      }
    }
    return result;
  }
};
helpers.objectCreate = objectCreate;
(function(exports2) {
  exports2.__esModule = void 0;
  exports2.__esModule = true;
  var helpers$1 = helpers;
  var setPrototypeOf3 = helpers$1.setPrototypeOf;
  var getPrototypeOf3 = helpers$1.getPrototypeOf;
  var defineProperty3 = helpers$1.defineProperty;
  var objectCreate3 = helpers$1.objectCreate;
  var uglyErrorPrinting = new Error().toString() === "[object Error]";
  var extendableErrorName = "";
  function ExtendableError(message) {
    var originalConstructor = this.constructor;
    var constructorName = originalConstructor.name || function() {
      var constructorNameMatch = originalConstructor.toString().match(/^function\s*([^\s(]+)/);
      return constructorNameMatch === null ? extendableErrorName ? extendableErrorName : "Error" : constructorNameMatch[1];
    }();
    var constructorNameIsError = constructorName === "Error";
    var name2 = constructorNameIsError ? extendableErrorName : constructorName;
    var instance = Error.apply(this, arguments);
    setPrototypeOf3(instance, getPrototypeOf3(this));
    if (!(instance instanceof originalConstructor) || !(instance instanceof ExtendableError)) {
      var instance = this;
      Error.apply(this, arguments);
      defineProperty3(instance, "message", { configurable: true, enumerable: false, value: message, writable: true });
    }
    defineProperty3(instance, "name", { configurable: true, enumerable: false, value: name2, writable: true });
    if (Error.captureStackTrace) {
      Error.captureStackTrace(instance, constructorNameIsError ? ExtendableError : originalConstructor);
    }
    if (instance.stack === void 0) {
      var err = new Error(message);
      err.name = instance.name;
      instance.stack = err.stack;
    }
    if (uglyErrorPrinting) {
      defineProperty3(instance, "toString", { configurable: true, enumerable: false, value: function toString3() {
        return (this.name || "Error") + (typeof this.message === "undefined" ? "" : ": " + this.message);
      }, writable: true });
    }
    return instance;
  }
  extendableErrorName = ExtendableError.name || "ExtendableError";
  ExtendableError.prototype = objectCreate3(Error.prototype, { constructor: { value: Error, enumerable: false, writable: true, configurable: true } });
  exports2.ExtendableError = ExtendableError;
  exports2["default"] = exports2.ExtendableError;
})(cjs);
Object.defineProperty(ClientError$1, "__esModule", { value: true });
ClientError$1.ClientError = void 0;
const ts_error_1$1 = cjs;
const Status_1$1 = Status;
class ClientError extends ts_error_1$1.ExtendableError {
  constructor(path, code, details) {
    super(`${path} ${Status_1$1.Status[code]}: ${details}`);
    this.path = path;
    this.code = code;
    this.details = details;
    this.name = "ClientError";
    Object.defineProperty(this, "@@nice-grpc", { value: true });
    Object.defineProperty(this, "@@nice-grpc:ClientError", { value: true });
  }
  static [Symbol.hasInstance](instance) {
    if (this !== ClientError) {
      return this.prototype.isPrototypeOf(instance);
    }
    return typeof instance === "object" && instance !== null && (instance.constructor === ClientError || instance["@@nice-grpc:ClientError"] === true || instance.name === "ClientError" && instance["@@nice-grpc"] === true);
  }
}
ClientError$1.ClientError = ClientError;
var CallContext = {};
Object.defineProperty(CallContext, "__esModule", { value: true });
var ServerMiddleware = {};
Object.defineProperty(ServerMiddleware, "__esModule", { value: true });
var composeServerMiddleware$1 = {};
Object.defineProperty(composeServerMiddleware$1, "__esModule", { value: true });
composeServerMiddleware$1.composeServerMiddleware = void 0;
function composeServerMiddleware(middleware1, middleware2) {
  return (call, context2) => {
    return middleware1({ ...call, next: (request3, context1) => {
      return middleware2({ ...call, request: request3 }, context1);
    } }, context2);
  };
}
composeServerMiddleware$1.composeServerMiddleware = composeServerMiddleware;
var ServerError$1 = {};
Object.defineProperty(ServerError$1, "__esModule", { value: true });
ServerError$1.ServerError = void 0;
const ts_error_1 = cjs;
const Status_1 = Status;
class ServerError extends ts_error_1.ExtendableError {
  constructor(code, details) {
    super(`${Status_1.Status[code]}: ${details}`);
    this.code = code;
    this.details = details;
    this.name = "ServerError";
    Object.defineProperty(this, "@@nice-grpc", { value: true });
    Object.defineProperty(this, "@@nice-grpc:ServerError", { value: true });
  }
  static [Symbol.hasInstance](instance) {
    if (this !== ServerError) {
      return this.prototype.isPrototypeOf(instance);
    }
    return typeof instance === "object" && instance !== null && (instance.constructor === ServerError || instance["@@nice-grpc:ServerError"] === true || instance.name === "ServerError" && instance["@@nice-grpc"] === true);
  }
}
ServerError$1.ServerError = ServerError;
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(Metadata, exports2);
  __exportStar(Status, exports2);
  __exportStar(MethodDescriptor, exports2);
  __exportStar(CallOptions, exports2);
  __exportStar(ClientMiddleware, exports2);
  __exportStar(composeClientMiddleware$1, exports2);
  __exportStar(ClientError$1, exports2);
  __exportStar(CallContext, exports2);
  __exportStar(ServerMiddleware, exports2);
  __exportStar(composeServerMiddleware$1, exports2);
  __exportStar(ServerError$1, exports2);
})(lib);
var serviceDefinitions = {};
var grpcWeb = {};
Object.defineProperty(grpcWeb, "__esModule", { value: true });
grpcWeb.isGrpcWebServiceDefinition = grpcWeb.fromGrpcWebServiceDefinition = void 0;
function fromGrpcWebServiceDefinition(definition) {
  const result = {};
  for (const [key, value] of Object.entries(definition)) {
    if (key === "serviceName") {
      continue;
    }
    const method = value;
    result[uncapitalize(key)] = { path: `/${definition.serviceName}/${key}`, requestStream: method.requestStream, responseStream: method.responseStream, requestDeserialize: method.requestType.deserializeBinary, requestSerialize: (value2) => value2.serializeBinary(), responseDeserialize: method.responseType.deserializeBinary, responseSerialize: (value2) => value2.serializeBinary(), options: {} };
  }
  return result;
}
grpcWeb.fromGrpcWebServiceDefinition = fromGrpcWebServiceDefinition;
function isGrpcWebServiceDefinition(definition) {
  return "prototype" in definition;
}
grpcWeb.isGrpcWebServiceDefinition = isGrpcWebServiceDefinition;
function uncapitalize(value) {
  if (value.length === 0) {
    return value;
  }
  return value[0].toLowerCase() + value.slice(1);
}
var tsProto = {};
Object.defineProperty(tsProto, "__esModule", { value: true });
tsProto.isTsProtoServiceDefinition = tsProto.fromTsProtoServiceDefinition = void 0;
function fromTsProtoServiceDefinition(definition) {
  const result = {};
  for (const [key, method] of Object.entries(definition.methods)) {
    const requestEncode = method.requestType.encode;
    const requestFromPartial = method.requestType.fromPartial;
    const responseEncode = method.responseType.encode;
    const responseFromPartial = method.responseType.fromPartial;
    result[key] = { path: `/${definition.fullName}/${method.name}`, requestStream: method.requestStream, responseStream: method.responseStream, requestDeserialize: method.requestType.decode, requestSerialize: requestFromPartial != null ? (value) => requestEncode(requestFromPartial(value)).finish() : (value) => requestEncode(value).finish(), responseDeserialize: method.responseType.decode, responseSerialize: responseFromPartial != null ? (value) => responseEncode(responseFromPartial(value)).finish() : (value) => responseEncode(value).finish(), options: method.options };
  }
  return result;
}
tsProto.fromTsProtoServiceDefinition = fromTsProtoServiceDefinition;
function isTsProtoServiceDefinition(definition) {
  return "name" in definition && "fullName" in definition && "methods" in definition;
}
tsProto.isTsProtoServiceDefinition = isTsProtoServiceDefinition;
Object.defineProperty(serviceDefinitions, "__esModule", { value: true });
serviceDefinitions.toGrpcWebMethodDefinition = serviceDefinitions.normalizeServiceDefinition = void 0;
const grpc_web_1$5 = grpcWeb;
const ts_proto_1 = tsProto;
function normalizeServiceDefinition(definition) {
  if ((0, grpc_web_1$5.isGrpcWebServiceDefinition)(definition)) {
    return (0, grpc_web_1$5.fromGrpcWebServiceDefinition)(definition);
  } else if ((0, ts_proto_1.isTsProtoServiceDefinition)(definition)) {
    return (0, ts_proto_1.fromTsProtoServiceDefinition)(definition);
  } else {
    return definition;
  }
}
serviceDefinitions.normalizeServiceDefinition = normalizeServiceDefinition;
function toGrpcWebMethodDefinition(definition) {
  const [, serviceName, methodName] = definition.path.split("/");
  return { service: { serviceName }, methodName, requestStream: definition.requestStream, responseStream: definition.responseStream, requestType: class {
    constructor() {
      throw new Error("Unexpected instantiation");
    }
    static deserializeBinary(bytes) {
      return definition.requestDeserialize(bytes);
    }
  }, responseType: class {
    constructor() {
      throw new Error("Unexpected instantiation");
    }
    static deserializeBinary(bytes) {
      return definition.responseDeserialize(bytes);
    }
  } };
}
serviceDefinitions.toGrpcWebMethodDefinition = toGrpcWebMethodDefinition;
var channel = {};
Object.defineProperty(channel, "__esModule", { value: true });
channel.createChannel = void 0;
function createChannel(address, transport) {
  return { address, transport };
}
channel.createChannel = createChannel;
var ClientFactory = {};
var createBidiStreamingMethod$1 = {};
var grpcWebClient_umd = { exports: {} };
(function(module2, exports2) {
  !function(e2, t2) {
    module2.exports = t2();
  }(commonjsGlobal, function() {
    return e2 = { 418: function(e3, t3) {
      !function(e4, t4) {
        for (var r2 in t4)
          e4[r2] = t4[r2];
      }(t3, function(e4) {
        var t4 = {};
        function r2(n2) {
          if (t4[n2])
            return t4[n2].exports;
          var o2 = t4[n2] = { i: n2, l: false, exports: {} };
          return e4[n2].call(o2.exports, o2, o2.exports, r2), o2.l = true, o2.exports;
        }
        return r2.m = e4, r2.c = t4, r2.i = function(e5) {
          return e5;
        }, r2.d = function(e5, t5, n2) {
          r2.o(e5, t5) || Object.defineProperty(e5, t5, { configurable: false, enumerable: true, get: n2 });
        }, r2.n = function(e5) {
          var t5 = e5 && e5.__esModule ? function() {
            return e5.default;
          } : function() {
            return e5;
          };
          return r2.d(t5, "a", t5), t5;
        }, r2.o = function(e5, t5) {
          return Object.prototype.hasOwnProperty.call(e5, t5);
        }, r2.p = "", r2(r2.s = 1);
      }([function(e4, t4, r2) {
        Object.defineProperty(t4, "__esModule", { value: true });
        var n2 = r2(3), o2 = function() {
          function e5(e6, t5) {
            void 0 === e6 && (e6 = {}), void 0 === t5 && (t5 = { splitValues: false });
            var r3, o3 = this;
            this.headersMap = {}, e6 && ("undefined" != typeof Headers && e6 instanceof Headers ? n2.getHeaderKeys(e6).forEach(function(r4) {
              n2.getHeaderValues(e6, r4).forEach(function(e7) {
                t5.splitValues ? o3.append(r4, n2.splitHeaderValue(e7)) : o3.append(r4, e7);
              });
            }) : "object" == typeof (r3 = e6) && "object" == typeof r3.headersMap && "function" == typeof r3.forEach ? e6.forEach(function(e7, t6) {
              o3.append(e7, t6);
            }) : "undefined" != typeof Map && e6 instanceof Map ? e6.forEach(function(e7, t6) {
              o3.append(t6, e7);
            }) : "string" == typeof e6 ? this.appendFromString(e6) : "object" == typeof e6 && Object.getOwnPropertyNames(e6).forEach(function(t6) {
              var r4 = e6[t6];
              Array.isArray(r4) ? r4.forEach(function(e7) {
                o3.append(t6, e7);
              }) : o3.append(t6, r4);
            }));
          }
          return e5.prototype.appendFromString = function(e6) {
            for (var t5 = e6.split("\r\n"), r3 = 0; r3 < t5.length; r3++) {
              var n3 = t5[r3], o3 = n3.indexOf(":");
              if (o3 > 0) {
                var s = n3.substring(0, o3).trim(), i2 = n3.substring(o3 + 1).trim();
                this.append(s, i2);
              }
            }
          }, e5.prototype.delete = function(e6, t5) {
            var r3 = n2.normalizeName(e6);
            if (void 0 === t5)
              delete this.headersMap[r3];
            else {
              var o3 = this.headersMap[r3];
              if (o3) {
                var s = o3.indexOf(t5);
                s >= 0 && o3.splice(s, 1), 0 === o3.length && delete this.headersMap[r3];
              }
            }
          }, e5.prototype.append = function(e6, t5) {
            var r3 = this, o3 = n2.normalizeName(e6);
            Array.isArray(this.headersMap[o3]) || (this.headersMap[o3] = []), Array.isArray(t5) ? t5.forEach(function(e7) {
              r3.headersMap[o3].push(n2.normalizeValue(e7));
            }) : this.headersMap[o3].push(n2.normalizeValue(t5));
          }, e5.prototype.set = function(e6, t5) {
            var r3 = n2.normalizeName(e6);
            if (Array.isArray(t5)) {
              var o3 = [];
              t5.forEach(function(e7) {
                o3.push(n2.normalizeValue(e7));
              }), this.headersMap[r3] = o3;
            } else
              this.headersMap[r3] = [n2.normalizeValue(t5)];
          }, e5.prototype.has = function(e6, t5) {
            var r3 = this.headersMap[n2.normalizeName(e6)];
            if (!Array.isArray(r3))
              return false;
            if (void 0 !== t5) {
              var o3 = n2.normalizeValue(t5);
              return r3.indexOf(o3) >= 0;
            }
            return true;
          }, e5.prototype.get = function(e6) {
            var t5 = this.headersMap[n2.normalizeName(e6)];
            return void 0 !== t5 ? t5.concat() : [];
          }, e5.prototype.forEach = function(e6) {
            var t5 = this;
            Object.getOwnPropertyNames(this.headersMap).forEach(function(r3) {
              e6(r3, t5.headersMap[r3]);
            }, this);
          }, e5.prototype.toHeaders = function() {
            if ("undefined" != typeof Headers) {
              var e6 = new Headers();
              return this.forEach(function(t5, r3) {
                r3.forEach(function(r4) {
                  e6.append(t5, r4);
                });
              }), e6;
            }
            throw new Error("Headers class is not defined");
          }, e5;
        }();
        t4.BrowserHeaders = o2;
      }, function(e4, t4, r2) {
        Object.defineProperty(t4, "__esModule", { value: true });
        var n2 = r2(0);
        t4.BrowserHeaders = n2.BrowserHeaders;
      }, function(e4, t4, r2) {
        Object.defineProperty(t4, "__esModule", { value: true }), t4.iterateHeaders = function(e5, t5) {
          for (var r3 = e5[Symbol.iterator](), n2 = r3.next(); !n2.done; )
            t5(n2.value[0]), n2 = r3.next();
        }, t4.iterateHeadersKeys = function(e5, t5) {
          for (var r3 = e5.keys(), n2 = r3.next(); !n2.done; )
            t5(n2.value), n2 = r3.next();
        };
      }, function(e4, t4, r2) {
        Object.defineProperty(t4, "__esModule", { value: true });
        var n2 = r2(2);
        t4.normalizeName = function(e5) {
          if ("string" != typeof e5 && (e5 = String(e5)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(e5))
            throw new TypeError("Invalid character in header field name");
          return e5.toLowerCase();
        }, t4.normalizeValue = function(e5) {
          return "string" != typeof e5 && (e5 = String(e5)), e5;
        }, t4.getHeaderValues = function(e5, t5) {
          var r3 = e5;
          if (r3 instanceof Headers && r3.getAll)
            return r3.getAll(t5);
          var n3 = r3.get(t5);
          return n3 && "string" == typeof n3 ? [n3] : n3;
        }, t4.getHeaderKeys = function(e5) {
          var t5 = e5, r3 = {}, o2 = [];
          return t5.keys ? n2.iterateHeadersKeys(t5, function(e6) {
            r3[e6] || (r3[e6] = true, o2.push(e6));
          }) : t5.forEach ? t5.forEach(function(e6, t6) {
            r3[t6] || (r3[t6] = true, o2.push(t6));
          }) : n2.iterateHeaders(t5, function(e6) {
            var t6 = e6[0];
            r3[t6] || (r3[t6] = true, o2.push(t6));
          }), o2;
        }, t4.splitHeaderValue = function(e5) {
          var t5 = [];
          return e5.split(", ").forEach(function(e6) {
            e6.split(",").forEach(function(e7) {
              t5.push(e7);
            });
          }), t5;
        };
      }]));
    }, 617: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.ChunkParser = t3.ChunkType = t3.encodeASCII = t3.decodeASCII = void 0;
      var n2, o2 = r2(65);
      function s(e4) {
        return 9 === (t4 = e4) || 10 === t4 || 13 === t4 || e4 >= 32 && e4 <= 126;
        var t4;
      }
      function i2(e4) {
        for (var t4 = 0; t4 !== e4.length; ++t4)
          if (!s(e4[t4]))
            throw new Error("Metadata is not valid (printable) ASCII");
        return String.fromCharCode.apply(String, Array.prototype.slice.call(e4));
      }
      function a(e4) {
        return 128 == (128 & e4.getUint8(0));
      }
      function u2(e4) {
        return e4.getUint32(1, false);
      }
      function d(e4, t4, r3) {
        return e4.byteLength - t4 >= r3;
      }
      function c(e4, t4, r3) {
        if (e4.slice)
          return e4.slice(t4, r3);
        var n3 = e4.length;
        void 0 !== r3 && (n3 = r3);
        for (var o3 = new Uint8Array(n3 - t4), s2 = 0, i3 = t4; i3 < n3; i3++)
          o3[s2++] = e4[i3];
        return o3;
      }
      t3.decodeASCII = i2, t3.encodeASCII = function(e4) {
        for (var t4 = new Uint8Array(e4.length), r3 = 0; r3 !== e4.length; ++r3) {
          var n3 = e4.charCodeAt(r3);
          if (!s(n3))
            throw new Error("Metadata contains invalid ASCII");
          t4[r3] = n3;
        }
        return t4;
      }, function(e4) {
        e4[e4.MESSAGE = 1] = "MESSAGE", e4[e4.TRAILERS = 2] = "TRAILERS";
      }(n2 = t3.ChunkType || (t3.ChunkType = {}));
      var p2 = function() {
        function e4() {
          this.buffer = null, this.position = 0;
        }
        return e4.prototype.parse = function(e5, t4) {
          if (0 === e5.length && t4)
            return [];
          var r3, s2 = [];
          if (null == this.buffer)
            this.buffer = e5, this.position = 0;
          else if (this.position === this.buffer.byteLength)
            this.buffer = e5, this.position = 0;
          else {
            var p22 = this.buffer.byteLength - this.position, h2 = new Uint8Array(p22 + e5.byteLength), f2 = c(this.buffer, this.position);
            h2.set(f2, 0);
            var l2 = new Uint8Array(e5);
            h2.set(l2, p22), this.buffer = h2, this.position = 0;
          }
          for (; ; ) {
            if (!d(this.buffer, this.position, 5))
              return s2;
            var g2 = c(this.buffer, this.position, this.position + 5), b = new DataView(g2.buffer, g2.byteOffset, g2.byteLength), y2 = u2(b);
            if (!d(this.buffer, this.position, 5 + y2))
              return s2;
            var v2 = c(this.buffer, this.position + 5, this.position + 5 + y2);
            if (this.position += 5 + y2, a(b))
              return s2.push({ chunkType: n2.TRAILERS, trailers: (r3 = v2, new o2.Metadata(i2(r3))) }), s2;
            s2.push({ chunkType: n2.MESSAGE, data: v2 });
          }
        }, e4;
      }();
      t3.ChunkParser = p2;
    }, 8: function(e3, t3) {
      var r2;
      Object.defineProperty(t3, "__esModule", { value: true }), t3.httpStatusToCode = t3.Code = void 0, function(e4) {
        e4[e4.OK = 0] = "OK", e4[e4.Canceled = 1] = "Canceled", e4[e4.Unknown = 2] = "Unknown", e4[e4.InvalidArgument = 3] = "InvalidArgument", e4[e4.DeadlineExceeded = 4] = "DeadlineExceeded", e4[e4.NotFound = 5] = "NotFound", e4[e4.AlreadyExists = 6] = "AlreadyExists", e4[e4.PermissionDenied = 7] = "PermissionDenied", e4[e4.ResourceExhausted = 8] = "ResourceExhausted", e4[e4.FailedPrecondition = 9] = "FailedPrecondition", e4[e4.Aborted = 10] = "Aborted", e4[e4.OutOfRange = 11] = "OutOfRange", e4[e4.Unimplemented = 12] = "Unimplemented", e4[e4.Internal = 13] = "Internal", e4[e4.Unavailable = 14] = "Unavailable", e4[e4.DataLoss = 15] = "DataLoss", e4[e4.Unauthenticated = 16] = "Unauthenticated";
      }(r2 = t3.Code || (t3.Code = {})), t3.httpStatusToCode = function(e4) {
        switch (e4) {
          case 0:
            return r2.Internal;
          case 200:
            return r2.OK;
          case 400:
            return r2.InvalidArgument;
          case 401:
            return r2.Unauthenticated;
          case 403:
            return r2.PermissionDenied;
          case 404:
            return r2.NotFound;
          case 409:
            return r2.Aborted;
          case 412:
            return r2.FailedPrecondition;
          case 429:
            return r2.ResourceExhausted;
          case 499:
            return r2.Canceled;
          case 500:
            return r2.Unknown;
          case 501:
            return r2.Unimplemented;
          case 503:
            return r2.Unavailable;
          case 504:
            return r2.DeadlineExceeded;
          default:
            return r2.Unknown;
        }
      };
    }, 934: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.client = void 0;
      var n2 = r2(65), o2 = r2(617), s = r2(8), i2 = r2(346), a = r2(57), u2 = r2(882);
      t3.client = function(e4, t4) {
        return new d(e4, t4);
      };
      var d = function() {
        function e4(e5, t4) {
          this.started = false, this.sentFirstMessage = false, this.completed = false, this.closed = false, this.finishedSending = false, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new o2.ChunkParser(), this.methodDefinition = e5, this.props = t4, this.createTransport();
        }
        return e4.prototype.createTransport = function() {
          var e5 = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName, t4 = { methodDefinition: this.methodDefinition, debug: this.props.debug || false, url: e5, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };
          this.props.transport ? this.transport = this.props.transport(t4) : this.transport = a.makeDefaultTransport(t4);
        }, e4.prototype.onTransportHeaders = function(e5, t4) {
          if (this.props.debug && i2.debug("onHeaders", e5, t4), this.closed)
            this.props.debug && i2.debug("grpc.onHeaders received after request was closed - ignoring");
          else if (0 === t4)
            ;
          else {
            this.responseHeaders = e5, this.props.debug && i2.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
            var r3 = c(e5);
            this.props.debug && i2.debug("onHeaders.gRPCStatus", r3);
            var n3 = r3 && r3 >= 0 ? r3 : s.httpStatusToCode(t4);
            this.props.debug && i2.debug("onHeaders.code", n3);
            var o3 = e5.get("grpc-message") || [];
            if (this.props.debug && i2.debug("onHeaders.gRPCMessage", o3), this.rawOnHeaders(e5), n3 !== s.Code.OK) {
              var a2 = this.decodeGRPCStatus(o3[0]);
              this.rawOnError(n3, a2, e5);
            }
          }
        }, e4.prototype.onTransportChunk = function(e5) {
          var t4 = this;
          if (this.closed)
            this.props.debug && i2.debug("grpc.onChunk received after request was closed - ignoring");
          else {
            var r3 = [];
            try {
              r3 = this.parser.parse(e5);
            } catch (e6) {
              return this.props.debug && i2.debug("onChunk.parsing error", e6, e6.message), void this.rawOnError(s.Code.Internal, "parsing error: " + e6.message);
            }
            r3.forEach(function(e6) {
              if (e6.chunkType === o2.ChunkType.MESSAGE) {
                var r4 = t4.methodDefinition.responseType.deserializeBinary(e6.data);
                t4.rawOnMessage(r4);
              } else
                e6.chunkType === o2.ChunkType.TRAILERS && (t4.responseHeaders ? (t4.responseTrailers = new n2.Metadata(e6.trailers), t4.props.debug && i2.debug("onChunk.trailers", t4.responseTrailers)) : (t4.responseHeaders = new n2.Metadata(e6.trailers), t4.rawOnHeaders(t4.responseHeaders)));
            });
          }
        }, e4.prototype.onTransportEnd = function() {
          if (this.props.debug && i2.debug("grpc.onEnd"), this.closed)
            this.props.debug && i2.debug("grpc.onEnd received after request was closed - ignoring");
          else if (void 0 !== this.responseTrailers) {
            var e5 = c(this.responseTrailers);
            if (null !== e5) {
              var t4 = this.responseTrailers.get("grpc-message"), r3 = this.decodeGRPCStatus(t4[0]);
              this.rawOnEnd(e5, r3, this.responseTrailers);
            } else
              this.rawOnError(s.Code.Internal, "Response closed without grpc-status (Trailers provided)");
          } else {
            if (void 0 === this.responseHeaders)
              return void this.rawOnError(s.Code.Unknown, "Response closed without headers");
            var n3 = c(this.responseHeaders), o3 = this.responseHeaders.get("grpc-message");
            if (this.props.debug && i2.debug("grpc.headers only response ", n3, o3), null === n3)
              return void this.rawOnEnd(s.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
            var a2 = this.decodeGRPCStatus(o3[0]);
            this.rawOnEnd(n3, a2, this.responseHeaders);
          }
        }, e4.prototype.decodeGRPCStatus = function(e5) {
          if (!e5)
            return "";
          try {
            return decodeURIComponent(e5);
          } catch (t4) {
            return e5;
          }
        }, e4.prototype.rawOnEnd = function(e5, t4, r3) {
          var n3 = this;
          this.props.debug && i2.debug("rawOnEnd", e5, t4, r3), this.completed || (this.completed = true, this.onEndCallbacks.forEach(function(o3) {
            if (!n3.closed)
              try {
                o3(e5, t4, r3);
              } catch (e6) {
                setTimeout(function() {
                  throw e6;
                }, 0);
              }
          }));
        }, e4.prototype.rawOnHeaders = function(e5) {
          this.props.debug && i2.debug("rawOnHeaders", e5), this.completed || this.onHeadersCallbacks.forEach(function(t4) {
            try {
              t4(e5);
            } catch (e6) {
              setTimeout(function() {
                throw e6;
              }, 0);
            }
          });
        }, e4.prototype.rawOnError = function(e5, t4, r3) {
          var o3 = this;
          void 0 === r3 && (r3 = new n2.Metadata()), this.props.debug && i2.debug("rawOnError", e5, t4), this.completed || (this.completed = true, this.onEndCallbacks.forEach(function(n3) {
            if (!o3.closed)
              try {
                n3(e5, t4, r3);
              } catch (e6) {
                setTimeout(function() {
                  throw e6;
                }, 0);
              }
          }));
        }, e4.prototype.rawOnMessage = function(e5) {
          var t4 = this;
          this.props.debug && i2.debug("rawOnMessage", e5.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach(function(r3) {
            if (!t4.closed)
              try {
                r3(e5);
              } catch (e6) {
                setTimeout(function() {
                  throw e6;
                }, 0);
              }
          });
        }, e4.prototype.onHeaders = function(e5) {
          this.onHeadersCallbacks.push(e5);
        }, e4.prototype.onMessage = function(e5) {
          this.onMessageCallbacks.push(e5);
        }, e4.prototype.onEnd = function(e5) {
          this.onEndCallbacks.push(e5);
        }, e4.prototype.start = function(e5) {
          if (this.started)
            throw new Error("Client already started - cannot .start()");
          this.started = true;
          var t4 = new n2.Metadata(e5 || {});
          t4.set("content-type", "application/grpc-web+proto"), t4.set("x-grpc-web", "1"), this.transport.start(t4);
        }, e4.prototype.send = function(e5) {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .send()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .send()");
          if (!this.methodDefinition.requestStream && this.sentFirstMessage)
            throw new Error("Message already sent for non-client-streaming method - cannot .send()");
          this.sentFirstMessage = true;
          var t4 = u2.frameRequest(e5);
          this.transport.sendMessage(t4);
        }, e4.prototype.finishSend = function() {
          if (!this.started)
            throw new Error("Client not started - .finishSend() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .finishSend()");
          this.finishedSending = true, this.transport.finishSend();
        }, e4.prototype.close = function() {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .close()");
          this.closed = true, this.props.debug && i2.debug("request.abort aborting request"), this.transport.cancel();
        }, e4;
      }();
      function c(e4) {
        var t4 = e4.get("grpc-status") || [];
        if (t4.length > 0)
          try {
            var r3 = t4[0];
            return parseInt(r3, 10);
          } catch (e5) {
            return null;
          }
        return null;
      }
    }, 346: function(e3, t3) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.debug = void 0, t3.debug = function() {
        for (var e4 = [], t4 = 0; t4 < arguments.length; t4++)
          e4[t4] = arguments[t4];
        console.debug ? console.debug.apply(null, e4) : console.log.apply(null, e4);
      };
    }, 607: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.grpc = void 0;
      var n2, o2 = r2(418), s = r2(57), i2 = r2(229), a = r2(540), u2 = r2(210), d = r2(859), c = r2(8), p2 = r2(938), h2 = r2(35), f2 = r2(934);
      (n2 = t3.grpc || (t3.grpc = {})).setDefaultTransport = s.setDefaultTransportFactory, n2.CrossBrowserHttpTransport = d.CrossBrowserHttpTransport, n2.FetchReadableStreamTransport = i2.FetchReadableStreamTransport, n2.XhrTransport = u2.XhrTransport, n2.WebsocketTransport = a.WebsocketTransport, n2.Code = c.Code, n2.Metadata = o2.BrowserHeaders, n2.client = function(e4, t4) {
        return f2.client(e4, t4);
      }, n2.invoke = p2.invoke, n2.unary = h2.unary;
    }, 938: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.invoke = void 0;
      var n2 = r2(934);
      t3.invoke = function(e4, t4) {
        if (e4.requestStream)
          throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
        var r3 = n2.client(e4, { host: t4.host, transport: t4.transport, debug: t4.debug });
        return t4.onHeaders && r3.onHeaders(t4.onHeaders), t4.onMessage && r3.onMessage(t4.onMessage), t4.onEnd && r3.onEnd(t4.onEnd), r3.start(t4.metadata), r3.send(t4.request), r3.finishSend(), { close: function() {
          r3.close();
        } };
      };
    }, 65: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.Metadata = void 0;
      var n2 = r2(418);
      Object.defineProperty(t3, "Metadata", { enumerable: true, get: function() {
        return n2.BrowserHeaders;
      } });
    }, 57: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.makeDefaultTransport = t3.setDefaultTransportFactory = void 0;
      var n2 = r2(859), o2 = function(e4) {
        return n2.CrossBrowserHttpTransport({ withCredentials: false })(e4);
      };
      t3.setDefaultTransportFactory = function(e4) {
        o2 = e4;
      }, t3.makeDefaultTransport = function(e4) {
        return o2(e4);
      };
    }, 229: function(e3, t3, r2) {
      var n2 = this && this.__assign || function() {
        return (n2 = Object.assign || function(e4) {
          for (var t4, r3 = 1, n3 = arguments.length; r3 < n3; r3++)
            for (var o3 in t4 = arguments[r3])
              Object.prototype.hasOwnProperty.call(t4, o3) && (e4[o3] = t4[o3]);
          return e4;
        }).apply(this, arguments);
      };
      Object.defineProperty(t3, "__esModule", { value: true }), t3.detectFetchSupport = t3.FetchReadableStreamTransport = void 0;
      var o2 = r2(65), s = r2(346);
      t3.FetchReadableStreamTransport = function(e4) {
        return function(t4) {
          return function(e5, t5) {
            return e5.debug && s.debug("fetchRequest", e5), new i2(e5, t5);
          }(t4, e4);
        };
      };
      var i2 = function() {
        function e4(e5, t4) {
          this.cancelled = false, this.controller = self.AbortController && new AbortController(), this.options = e5, this.init = t4;
        }
        return e4.prototype.pump = function(e5, t4) {
          var r3 = this;
          if (this.reader = e5, this.cancelled)
            return this.options.debug && s.debug("Fetch.pump.cancel at first pump"), void this.reader.cancel().catch(function(e6) {
              r3.options.debug && s.debug("Fetch.pump.reader.cancel exception", e6);
            });
          this.reader.read().then(function(e6) {
            if (e6.done)
              return r3.options.onEnd(), t4;
            r3.options.onChunk(e6.value), r3.pump(r3.reader, t4);
          }).catch(function(e6) {
            r3.cancelled ? r3.options.debug && s.debug("Fetch.catch - request cancelled") : (r3.cancelled = true, r3.options.debug && s.debug("Fetch.catch", e6.message), r3.options.onEnd(e6));
          });
        }, e4.prototype.send = function(e5) {
          var t4 = this;
          fetch(this.options.url, n2(n2({}, this.init), { headers: this.metadata.toHeaders(), method: "POST", body: e5, signal: this.controller && this.controller.signal })).then(function(e6) {
            if (t4.options.debug && s.debug("Fetch.response", e6), t4.options.onHeaders(new o2.Metadata(e6.headers), e6.status), !e6.body)
              return e6;
            t4.pump(e6.body.getReader(), e6);
          }).catch(function(e6) {
            t4.cancelled ? t4.options.debug && s.debug("Fetch.catch - request cancelled") : (t4.cancelled = true, t4.options.debug && s.debug("Fetch.catch", e6.message), t4.options.onEnd(e6));
          });
        }, e4.prototype.sendMessage = function(e5) {
          this.send(e5);
        }, e4.prototype.finishSend = function() {
        }, e4.prototype.start = function(e5) {
          this.metadata = e5;
        }, e4.prototype.cancel = function() {
          var e5 = this;
          this.cancelled ? this.options.debug && s.debug("Fetch.cancel already cancelled") : (this.cancelled = true, this.controller ? (this.options.debug && s.debug("Fetch.cancel.controller.abort"), this.controller.abort()) : this.options.debug && s.debug("Fetch.cancel.missing abort controller"), this.reader ? (this.options.debug && s.debug("Fetch.cancel.reader.cancel"), this.reader.cancel().catch(function(t4) {
            e5.options.debug && s.debug("Fetch.cancel.reader.cancel exception", t4);
          })) : this.options.debug && s.debug("Fetch.cancel before reader"));
        }, e4;
      }();
      t3.detectFetchSupport = function() {
        return "undefined" != typeof Response && Response.prototype.hasOwnProperty("body") && "function" == typeof Headers;
      };
    }, 859: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.CrossBrowserHttpTransport = void 0;
      var n2 = r2(229), o2 = r2(210);
      t3.CrossBrowserHttpTransport = function(e4) {
        if (n2.detectFetchSupport()) {
          var t4 = { credentials: e4.withCredentials ? "include" : "same-origin" };
          return n2.FetchReadableStreamTransport(t4);
        }
        return o2.XhrTransport({ withCredentials: e4.withCredentials });
      };
    }, 210: function(e3, t3, r2) {
      var n2, o2 = this && this.__extends || (n2 = function(e4, t4) {
        return (n2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e5, t5) {
          e5.__proto__ = t5;
        } || function(e5, t5) {
          for (var r3 in t5)
            Object.prototype.hasOwnProperty.call(t5, r3) && (e5[r3] = t5[r3]);
        })(e4, t4);
      }, function(e4, t4) {
        function r3() {
          this.constructor = e4;
        }
        n2(e4, t4), e4.prototype = null === t4 ? Object.create(t4) : (r3.prototype = t4.prototype, new r3());
      });
      Object.defineProperty(t3, "__esModule", { value: true }), t3.stringToArrayBuffer = t3.MozChunkedArrayBufferXHR = t3.XHR = t3.XhrTransport = void 0;
      var s = r2(65), i2 = r2(346), a = r2(849);
      t3.XhrTransport = function(e4) {
        return function(t4) {
          if (a.detectMozXHRSupport())
            return new d(t4, e4);
          if (a.detectXHROverrideMimeTypeSupport())
            return new u2(t4, e4);
          throw new Error("This environment's XHR implementation cannot support binary transfer.");
        };
      };
      var u2 = function() {
        function e4(e5, t4) {
          this.options = e5, this.init = t4;
        }
        return e4.prototype.onProgressEvent = function() {
          this.options.debug && i2.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
          var e5 = this.xhr.response.substr(this.index);
          this.index = this.xhr.response.length;
          var t4 = p2(e5);
          this.options.onChunk(t4);
        }, e4.prototype.onLoadEvent = function() {
          this.options.debug && i2.debug("XHR.onLoadEvent"), this.options.onEnd();
        }, e4.prototype.onStateChange = function() {
          this.options.debug && i2.debug("XHR.onStateChange", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new s.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);
        }, e4.prototype.sendMessage = function(e5) {
          this.xhr.send(e5);
        }, e4.prototype.finishSend = function() {
        }, e4.prototype.start = function(e5) {
          var t4 = this;
          this.metadata = e5;
          var r3 = new XMLHttpRequest();
          this.xhr = r3, r3.open("POST", this.options.url), this.configureXhr(), this.metadata.forEach(function(e6, t5) {
            r3.setRequestHeader(e6, t5.join(", "));
          }), r3.withCredentials = Boolean(this.init.withCredentials), r3.addEventListener("readystatechange", this.onStateChange.bind(this)), r3.addEventListener("progress", this.onProgressEvent.bind(this)), r3.addEventListener("loadend", this.onLoadEvent.bind(this)), r3.addEventListener("error", function(e6) {
            t4.options.debug && i2.debug("XHR.error", e6), t4.options.onEnd(e6.error);
          });
        }, e4.prototype.configureXhr = function() {
          this.xhr.responseType = "text", this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }, e4.prototype.cancel = function() {
          this.options.debug && i2.debug("XHR.abort"), this.xhr.abort();
        }, e4;
      }();
      t3.XHR = u2;
      var d = function(e4) {
        function t4() {
          return null !== e4 && e4.apply(this, arguments) || this;
        }
        return o2(t4, e4), t4.prototype.configureXhr = function() {
          this.options.debug && i2.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"), this.xhr.responseType = "moz-chunked-arraybuffer";
        }, t4.prototype.onProgressEvent = function() {
          var e5 = this.xhr.response;
          this.options.debug && i2.debug("MozXHR.onProgressEvent: ", new Uint8Array(e5)), this.options.onChunk(new Uint8Array(e5));
        }, t4;
      }(u2);
      function c(e4, t4) {
        var r3 = e4.charCodeAt(t4);
        if (r3 >= 55296 && r3 <= 56319) {
          var n3 = e4.charCodeAt(t4 + 1);
          n3 >= 56320 && n3 <= 57343 && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320));
        }
        return r3;
      }
      function p2(e4) {
        for (var t4 = new Uint8Array(e4.length), r3 = 0, n3 = 0; n3 < e4.length; n3++) {
          var o3 = String.prototype.codePointAt ? e4.codePointAt(n3) : c(e4, n3);
          t4[r3++] = 255 & o3;
        }
        return t4;
      }
      t3.MozChunkedArrayBufferXHR = d, t3.stringToArrayBuffer = p2;
    }, 849: function(e3, t3) {
      var r2;
      function n2() {
        if (void 0 !== r2)
          return r2;
        if (XMLHttpRequest) {
          r2 = new XMLHttpRequest();
          try {
            r2.open("GET", "https://localhost");
          } catch (e4) {
          }
        }
        return r2;
      }
      function o2(e4) {
        var t4 = n2();
        if (!t4)
          return false;
        try {
          return t4.responseType = e4, t4.responseType === e4;
        } catch (e5) {
        }
        return false;
      }
      Object.defineProperty(t3, "__esModule", { value: true }), t3.detectXHROverrideMimeTypeSupport = t3.detectMozXHRSupport = t3.xhrSupportsResponseType = void 0, t3.xhrSupportsResponseType = o2, t3.detectMozXHRSupport = function() {
        return "undefined" != typeof XMLHttpRequest && o2("moz-chunked-arraybuffer");
      }, t3.detectXHROverrideMimeTypeSupport = function() {
        return "undefined" != typeof XMLHttpRequest && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
      };
    }, 540: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.WebsocketTransport = void 0;
      var n2, o2 = r2(346), s = r2(617);
      !function(e4) {
        e4[e4.FINISH_SEND = 1] = "FINISH_SEND";
      }(n2 || (n2 = {}));
      var i2 = new Uint8Array([1]);
      t3.WebsocketTransport = function() {
        return function(e4) {
          return function(e5) {
            e5.debug && o2.debug("websocketRequest", e5);
            var t4, r3 = function(e6) {
              if ("https://" === e6.substr(0, 8))
                return "wss://" + e6.substr(8);
              if ("http://" === e6.substr(0, 7))
                return "ws://" + e6.substr(7);
              throw new Error("Websocket transport constructed with non-https:// or http:// host.");
            }(e5.url), a = [];
            function u2(e6) {
              if (e6 === n2.FINISH_SEND)
                t4.send(i2);
              else {
                var r4 = e6, o3 = new Int8Array(r4.byteLength + 1);
                o3.set(new Uint8Array([0])), o3.set(r4, 1), t4.send(o3);
              }
            }
            return { sendMessage: function(e6) {
              t4 && t4.readyState !== t4.CONNECTING ? u2(e6) : a.push(e6);
            }, finishSend: function() {
              t4 && t4.readyState !== t4.CONNECTING ? u2(n2.FINISH_SEND) : a.push(n2.FINISH_SEND);
            }, start: function(n3) {
              (t4 = new WebSocket(r3, ["grpc-websockets"])).binaryType = "arraybuffer", t4.onopen = function() {
                var r4;
                e5.debug && o2.debug("websocketRequest.onopen"), t4.send((r4 = "", n3.forEach(function(e6, t5) {
                  r4 += e6 + ": " + t5.join(", ") + "\r\n";
                }), s.encodeASCII(r4))), a.forEach(function(e6) {
                  u2(e6);
                });
              }, t4.onclose = function(t5) {
                e5.debug && o2.debug("websocketRequest.onclose", t5), e5.onEnd();
              }, t4.onerror = function(t5) {
                e5.debug && o2.debug("websocketRequest.onerror", t5);
              }, t4.onmessage = function(t5) {
                e5.onChunk(new Uint8Array(t5.data));
              };
            }, cancel: function() {
              e5.debug && o2.debug("websocket.abort"), t4.close();
            } };
          }(e4);
        };
      };
    }, 35: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.unary = void 0;
      var n2 = r2(65), o2 = r2(934);
      t3.unary = function(e4, t4) {
        if (e4.responseStream)
          throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
        if (e4.requestStream)
          throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
        var r3 = null, s = null, i2 = o2.client(e4, { host: t4.host, transport: t4.transport, debug: t4.debug });
        return i2.onHeaders(function(e5) {
          r3 = e5;
        }), i2.onMessage(function(e5) {
          s = e5;
        }), i2.onEnd(function(e5, o3, i3) {
          t4.onEnd({ status: e5, statusMessage: o3, headers: r3 || new n2.Metadata(), message: s, trailers: i3 });
        }), i2.start(t4.metadata), i2.send(t4.request), i2.finishSend(), { close: function() {
          i2.close();
        } };
      };
    }, 882: function(e3, t3) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.frameRequest = void 0, t3.frameRequest = function(e4) {
        var t4 = e4.serializeBinary(), r2 = new ArrayBuffer(t4.byteLength + 5);
        return new DataView(r2, 1, 4).setUint32(0, t4.length, false), new Uint8Array(r2, 5).set(t4), new Uint8Array(r2);
      };
    } }, t2 = {}, function r2(n2) {
      if (t2[n2])
        return t2[n2].exports;
      var o2 = t2[n2] = { exports: {} };
      return e2[n2].call(o2.exports, o2, o2.exports, r2), o2.exports;
    }(607);
    var e2, t2;
  });
})(grpcWebClient_umd);
class AbortError extends Error {
  constructor() {
    super("The operation has been aborted");
    this.message = "The operation has been aborted";
    this.name = "AbortError";
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}
function isAbortError(error) {
  return typeof error === "object" && error !== null && error.name === "AbortError";
}
function throwIfAborted(signal) {
  if (signal.aborted) {
    throw new AbortError();
  }
}
function rethrowAbortError(error) {
  if (isAbortError(error)) {
    throw error;
  }
  return;
}
function catchAbortError(error) {
  if (isAbortError(error)) {
    return;
  }
  throw error;
}
function execute(signal, executor) {
  return new Promise((resolve, reject) => {
    if (signal.aborted) {
      reject(new AbortError());
      return;
    }
    let removeAbortListener;
    let finished = false;
    function finish2() {
      if (!finished) {
        finished = true;
        if (removeAbortListener != null) {
          removeAbortListener();
        }
      }
    }
    const callback = executor((value) => {
      resolve(value);
      finish2();
    }, (reason) => {
      reject(reason);
      finish2();
    });
    if (!finished) {
      const listener = () => {
        const callbackResult = callback();
        if (callbackResult == null) {
          reject(new AbortError());
        } else {
          callbackResult.then(() => {
            reject(new AbortError());
          }, (reason) => {
            reject(reason);
          });
        }
        finish2();
      };
      signal.addEventListener("abort", listener);
      removeAbortListener = () => {
        signal.removeEventListener("abort", listener);
      };
    }
  });
}
function abortable(signal, promise) {
  if (signal.aborted) {
    const noop2 = () => {
    };
    promise.then(noop2, noop2);
  }
  return execute(signal, (resolve, reject) => {
    promise.then(resolve, reject);
    return () => {
    };
  });
}
function delay$1(signal, dueTime) {
  return execute(signal, (resolve) => {
    const ms = typeof dueTime === "number" ? dueTime : dueTime.getTime() - Date.now();
    const timer2 = setTimeout(resolve, ms);
    return () => {
      clearTimeout(timer2);
    };
  });
}
function forever(signal) {
  return execute(signal, () => () => {
  });
}
function waitForEvent(signal, target, eventName, options2) {
  return execute(signal, (resolve) => {
    let unlisten;
    let finished = false;
    const handler = (...args) => {
      resolve(args.length > 1 ? args : args[0]);
      finished = true;
      if (unlisten != null) {
        unlisten();
      }
    };
    unlisten = listen(target, eventName, handler, options2);
    if (finished) {
      unlisten();
    }
    return () => {
      finished = true;
      if (unlisten != null) {
        unlisten();
      }
    };
  });
}
function listen(target, eventName, handler, options2) {
  if (isEventTarget(target)) {
    target.addEventListener(eventName, handler, options2);
    return () => target.removeEventListener(eventName, handler, options2);
  }
  if (isJQueryStyleEventEmitter(target)) {
    target.on(eventName, handler);
    return () => target.off(eventName, handler);
  }
  if (isNodeStyleEventEmitter(target)) {
    target.addListener(eventName, handler);
    return () => target.removeListener(eventName, handler);
  }
  throw new Error("Invalid event target");
}
function isNodeStyleEventEmitter(sourceObj) {
  return isFunction$2(sourceObj.addListener) && isFunction$2(sourceObj.removeListener);
}
function isJQueryStyleEventEmitter(sourceObj) {
  return isFunction$2(sourceObj.on) && isFunction$2(sourceObj.off);
}
function isEventTarget(sourceObj) {
  return isFunction$2(sourceObj.addEventListener) && isFunction$2(sourceObj.removeEventListener);
}
const isFunction$2 = (obj) => typeof obj === "function";
var browser$3 = { exports: {} };
const _global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : void 0;
if (!_global) {
  throw new Error(`Unable to find global scope. Are you sure this is running in the browser?`);
}
if (!_global.AbortController) {
  throw new Error(`Could not find "AbortController" in the global scope. You need to polyfill it first`);
}
browser$3.exports = _global.AbortController;
browser$3.exports.default = _global.AbortController;
var AbortController$1 = browser$3.exports;
function all(signal, executor) {
  return new Promise((resolve, reject) => {
    if (signal.aborted) {
      reject(new AbortError());
      return;
    }
    const innerAbortController = new AbortController$1();
    const promises = executor(innerAbortController.signal);
    if (promises.length === 0) {
      resolve([]);
      return;
    }
    const abortListener = () => {
      innerAbortController.abort();
    };
    signal.addEventListener("abort", abortListener);
    let rejection;
    const results = new Array(promises.length);
    let settledCount = 0;
    function settled() {
      settledCount += 1;
      if (settledCount === promises.length) {
        signal.removeEventListener("abort", abortListener);
        if (rejection != null) {
          reject(rejection.reason);
        } else {
          resolve(results);
        }
      }
    }
    for (const [i2, promise] of promises.entries()) {
      promise.then((value) => {
        results[i2] = value;
        settled();
      }, (reason) => {
        innerAbortController.abort();
        if (rejection == null || !isAbortError(reason) && isAbortError(rejection.reason)) {
          rejection = { reason };
        }
        settled();
      });
    }
  });
}
function race$2(signal, executor) {
  return new Promise((resolve, reject) => {
    if (signal.aborted) {
      reject(new AbortError());
      return;
    }
    const innerAbortController = new AbortController$1();
    const promises = executor(innerAbortController.signal);
    const abortListener = () => {
      innerAbortController.abort();
    };
    signal.addEventListener("abort", abortListener);
    let settledCount = 0;
    function settled(result2) {
      innerAbortController.abort();
      settledCount += 1;
      if (settledCount === promises.length) {
        signal.removeEventListener("abort", abortListener);
        if (result2.status === "fulfilled") {
          resolve(result2.value);
        } else {
          reject(result2.reason);
        }
      }
    }
    let result;
    for (const promise of promises) {
      promise.then((value) => {
        if (result == null) {
          result = { status: "fulfilled", value };
        }
        settled(result);
      }, (reason) => {
        if (result == null || !isAbortError(reason) && (result.status === "fulfilled" || isAbortError(result.reason))) {
          result = { status: "rejected", reason };
        }
        settled(result);
      });
    }
  });
}
async function retry$1(signal, fn, options2 = {}) {
  const { baseMs = 1e3, maxDelayMs = 15e3, onError, maxAttempts = Infinity } = options2;
  let attempt = 0;
  const reset2 = () => {
    attempt = -1;
  };
  while (true) {
    try {
      return await fn(signal, attempt, reset2);
    } catch (error) {
      rethrowAbortError(error);
      if (attempt >= maxAttempts) {
        throw error;
      }
      let delayMs;
      if (attempt === -1) {
        delayMs = 0;
      } else {
        const backoff = Math.min(maxDelayMs, Math.pow(2, attempt) * baseMs);
        delayMs = Math.round(backoff * (1 + Math.random()) / 2);
      }
      if (onError) {
        onError(error, attempt, delayMs);
      }
      if (delayMs !== 0) {
        await delay$1(signal, delayMs);
      }
      attempt += 1;
    }
  }
}
function spawn(signal, fn) {
  if (signal.aborted) {
    return Promise.reject(new AbortError());
  }
  const deferredFunctions = [];
  const spawnAbortController = new AbortController$1();
  const spawnSignal = spawnAbortController.signal;
  const abortSpawn = () => {
    spawnAbortController.abort();
  };
  signal.addEventListener("abort", abortSpawn);
  const removeAbortListener = () => {
    signal.removeEventListener("abort", abortSpawn);
  };
  const tasks = /* @__PURE__ */ new Set();
  const abortTasks = () => {
    for (const task of tasks) {
      task.abort();
    }
  };
  spawnSignal.addEventListener("abort", abortTasks);
  const removeSpawnAbortListener = () => {
    spawnSignal.removeEventListener("abort", abortTasks);
  };
  let promise = new Promise((resolve, reject) => {
    let result;
    let failure;
    fork2((signal2) => fn(signal2, { defer(fn2) {
      deferredFunctions.push(fn2);
    }, fork: fork2 })).join().then((value) => {
      spawnAbortController.abort();
      result = { value };
    }, (error) => {
      spawnAbortController.abort();
      if (!isAbortError(error) || failure == null) {
        failure = { error };
      }
    });
    function fork2(forkFn) {
      if (spawnSignal.aborted) {
        return { abort() {
        }, async join() {
          throw new AbortError();
        } };
      }
      const taskAbortController = new AbortController$1();
      const taskSignal = taskAbortController.signal;
      const taskPromise = forkFn(taskSignal);
      const task = { abort() {
        taskAbortController.abort();
      }, join: () => taskPromise };
      tasks.add(task);
      taskPromise.catch(catchAbortError).catch((error) => {
        failure = { error };
        spawnAbortController.abort();
      }).finally(() => {
        tasks.delete(task);
        if (tasks.size === 0) {
          if (failure != null) {
            reject(failure.error);
          } else {
            resolve(result.value);
          }
        }
      });
      return task;
    }
  });
  promise = promise.finally(() => {
    removeAbortListener();
    removeSpawnAbortListener();
    let deferPromise = Promise.resolve();
    for (let i2 = deferredFunctions.length - 1; i2 >= 0; i2--) {
      deferPromise = deferPromise.finally(deferredFunctions[i2]);
    }
    return deferPromise;
  });
  return promise;
}
function run(fn) {
  const abortController = new AbortController$1();
  const promise = fn(abortController.signal).catch(catchAbortError);
  return () => {
    abortController.abort();
    return promise;
  };
}
var es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, abortable, AbortError, isAbortError, throwIfAborted, rethrowAbortError, catchAbortError, delay: delay$1, execute, forever, waitForEvent, all, race: race$2, retry: retry$1, spawn, run }, Symbol.toStringTag, { value: "Module" }));
var require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(es);
var AsyncSink$1 = {};
Object.defineProperty(AsyncSink$1, "__esModule", { value: true });
AsyncSink$1.AsyncSink = void 0;
const ARRAY_VALUE = "value";
const ARRAY_ERROR = "error";
class AsyncSink {
  constructor() {
    this._ended = false;
    this._values = [];
    this._resolvers = [];
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  write(value) {
    this._push({ type: ARRAY_VALUE, value });
  }
  error(error) {
    this._push({ type: ARRAY_ERROR, error });
  }
  _push(item) {
    if (this._ended) {
      throw new Error("AsyncSink already ended");
    }
    if (this._resolvers.length > 0) {
      const { resolve, reject } = this._resolvers.shift();
      if (item.type === ARRAY_ERROR) {
        reject(item.error);
      } else {
        resolve({ done: false, value: item.value });
      }
    } else {
      this._values.push(item);
    }
  }
  next() {
    if (this._values.length > 0) {
      const { type, value, error } = this._values.shift();
      if (type === ARRAY_ERROR) {
        return Promise.reject(error);
      } else {
        return Promise.resolve({ done: false, value });
      }
    }
    if (this._ended) {
      return Promise.resolve({ done: true });
    }
    return new Promise((resolve, reject) => {
      this._resolvers.push({ resolve, reject });
    });
  }
  end() {
    while (this._resolvers.length > 0) {
      this._resolvers.shift().resolve({ done: true });
    }
    this._ended = true;
  }
}
AsyncSink$1.AsyncSink = AsyncSink;
var isAsyncIterable$1 = {};
Object.defineProperty(isAsyncIterable$1, "__esModule", { value: true });
isAsyncIterable$1.isAsyncIterable = void 0;
function isAsyncIterable(value) {
  return value != null && Symbol.asyncIterator in value;
}
isAsyncIterable$1.isAsyncIterable = isAsyncIterable;
var convertMetadata = {};
var base64$2 = { exports: {} };
(function(module2, exports2) {
  (function(global2, factory2) {
    module2.exports = factory2();
  })(typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : commonjsGlobal, function() {
    var version2 = "3.7.2";
    var VERSION = version2;
    var _hasatob = typeof atob === "function";
    var _hasbtoa = typeof btoa === "function";
    var _hasBuffer = typeof Buffer === "function";
    var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
    var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
    var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var b64chs = Array.prototype.slice.call(b64ch);
    var b64tab = function(a) {
      var tab = {};
      a.forEach(function(c, i2) {
        return tab[c] = i2;
      });
      return tab;
    }(b64chs);
    var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
    var _fromCC = String.fromCharCode.bind(String);
    var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : function(it, fn) {
      if (fn === void 0) {
        fn = function(x2) {
          return x2;
        };
      }
      return new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
    };
    var _mkUriSafe = function(src) {
      return src.replace(/=/g, "").replace(/[+\/]/g, function(m0) {
        return m0 == "+" ? "-" : "_";
      });
    };
    var _tidyB64 = function(s) {
      return s.replace(/[^A-Za-z0-9\+\/]/g, "");
    };
    var btoaPolyfill = function(bin) {
      var u32, c0, c1, c2, asc = "";
      var pad = bin.length % 3;
      for (var i2 = 0; i2 < bin.length; ) {
        if ((c0 = bin.charCodeAt(i2++)) > 255 || (c1 = bin.charCodeAt(i2++)) > 255 || (c2 = bin.charCodeAt(i2++)) > 255)
          throw new TypeError("invalid character found");
        u32 = c0 << 16 | c1 << 8 | c2;
        asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
      }
      return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
    };
    var _btoa = _hasbtoa ? function(bin) {
      return btoa(bin);
    } : _hasBuffer ? function(bin) {
      return Buffer.from(bin, "binary").toString("base64");
    } : btoaPolyfill;
    var _fromUint8Array = _hasBuffer ? function(u8a) {
      return Buffer.from(u8a).toString("base64");
    } : function(u8a) {
      var maxargs = 4096;
      var strs = [];
      for (var i2 = 0, l2 = u8a.length; i2 < l2; i2 += maxargs) {
        strs.push(_fromCC.apply(null, u8a.subarray(i2, i2 + maxargs)));
      }
      return _btoa(strs.join(""));
    };
    var fromUint8Array = function(u8a, urlsafe) {
      if (urlsafe === void 0) {
        urlsafe = false;
      }
      return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
    };
    var cb_utob = function(c) {
      if (c.length < 2) {
        var cc2 = c.charCodeAt(0);
        return cc2 < 128 ? c : cc2 < 2048 ? _fromCC(192 | cc2 >>> 6) + _fromCC(128 | cc2 & 63) : _fromCC(224 | cc2 >>> 12 & 15) + _fromCC(128 | cc2 >>> 6 & 63) + _fromCC(128 | cc2 & 63);
      } else {
        var cc2 = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
        return _fromCC(240 | cc2 >>> 18 & 7) + _fromCC(128 | cc2 >>> 12 & 63) + _fromCC(128 | cc2 >>> 6 & 63) + _fromCC(128 | cc2 & 63);
      }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u2) {
      return u2.replace(re_utob, cb_utob);
    };
    var _encode = _hasBuffer ? function(s) {
      return Buffer.from(s, "utf8").toString("base64");
    } : _TE ? function(s) {
      return _fromUint8Array(_TE.encode(s));
    } : function(s) {
      return _btoa(utob(s));
    };
    var encode2 = function(src, urlsafe) {
      if (urlsafe === void 0) {
        urlsafe = false;
      }
      return urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
    };
    var encodeURI = function(src) {
      return encode2(src, true);
    };
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function(cccc) {
      switch (cccc.length) {
        case 4:
          var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
          return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
        case 3:
          return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
        default:
          return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
      }
    };
    var btou = function(b) {
      return b.replace(re_btou, cb_btou);
    };
    var atobPolyfill = function(asc) {
      asc = asc.replace(/\s+/g, "");
      if (!b64re.test(asc))
        throw new TypeError("malformed base64.");
      asc += "==".slice(2 - (asc.length & 3));
      var u24, bin = "", r1, r2;
      for (var i2 = 0; i2 < asc.length; ) {
        u24 = b64tab[asc.charAt(i2++)] << 18 | b64tab[asc.charAt(i2++)] << 12 | (r1 = b64tab[asc.charAt(i2++)]) << 6 | (r2 = b64tab[asc.charAt(i2++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
      }
      return bin;
    };
    var _atob = _hasatob ? function(asc) {
      return atob(_tidyB64(asc));
    } : _hasBuffer ? function(asc) {
      return Buffer.from(asc, "base64").toString("binary");
    } : atobPolyfill;
    var _toUint8Array = _hasBuffer ? function(a) {
      return _U8Afrom(Buffer.from(a, "base64"));
    } : function(a) {
      return _U8Afrom(_atob(a), function(c) {
        return c.charCodeAt(0);
      });
    };
    var toUint8Array = function(a) {
      return _toUint8Array(_unURI(a));
    };
    var _decode = _hasBuffer ? function(a) {
      return Buffer.from(a, "base64").toString("utf8");
    } : _TD ? function(a) {
      return _TD.decode(_toUint8Array(a));
    } : function(a) {
      return btou(_atob(a));
    };
    var _unURI = function(a) {
      return _tidyB64(a.replace(/[-_]/g, function(m0) {
        return m0 == "-" ? "+" : "/";
      }));
    };
    var decode = function(src) {
      return _decode(_unURI(src));
    };
    var isValid = function(src) {
      if (typeof src !== "string")
        return false;
      var s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
      return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
    };
    var _noEnum = function(v2) {
      return { value: v2, enumerable: false, writable: true, configurable: true };
    };
    var extendString = function() {
      var _add = function(name2, body) {
        return Object.defineProperty(String.prototype, name2, _noEnum(body));
      };
      _add("fromBase64", function() {
        return decode(this);
      });
      _add("toBase64", function(urlsafe) {
        return encode2(this, urlsafe);
      });
      _add("toBase64URI", function() {
        return encode2(this, true);
      });
      _add("toBase64URL", function() {
        return encode2(this, true);
      });
      _add("toUint8Array", function() {
        return toUint8Array(this);
      });
    };
    var extendUint8Array = function() {
      var _add = function(name2, body) {
        return Object.defineProperty(Uint8Array.prototype, name2, _noEnum(body));
      };
      _add("toBase64", function(urlsafe) {
        return fromUint8Array(this, urlsafe);
      });
      _add("toBase64URI", function() {
        return fromUint8Array(this, true);
      });
      _add("toBase64URL", function() {
        return fromUint8Array(this, true);
      });
    };
    var extendBuiltins = function() {
      extendString();
      extendUint8Array();
    };
    var gBase64 = { version: version2, VERSION, atob: _atob, atobPolyfill, btoa: _btoa, btoaPolyfill, fromBase64: decode, toBase64: encode2, encode: encode2, encodeURI, encodeURL: encodeURI, utob, btou, decode, isValid, fromUint8Array, toUint8Array, extendString, extendUint8Array, extendBuiltins };
    gBase64.Base64 = {};
    Object.keys(gBase64).forEach(function(k) {
      return gBase64.Base64[k] = gBase64[k];
    });
    return gBase64;
  });
})(base64$2);
Object.defineProperty(convertMetadata, "__esModule", { value: true });
convertMetadata.convertMetadataFromGrpcWeb = convertMetadata.convertMetadataToGrpcWeb = void 0;
const grpc_web_1$4 = grpcWebClient_umd.exports;
const nice_grpc_common_1$5 = lib;
const js_base64_1 = base64$2.exports;
function convertMetadataToGrpcWeb(metadata) {
  const grpcMetadata = new grpc_web_1$4.grpc.Metadata();
  for (const [key, values2] of metadata) {
    for (const value of values2) {
      grpcMetadata.append(key, typeof value === "string" ? value : js_base64_1.Base64.fromUint8Array(value));
    }
  }
  return grpcMetadata;
}
convertMetadata.convertMetadataToGrpcWeb = convertMetadataToGrpcWeb;
function convertMetadataFromGrpcWeb(grpcMetadata) {
  const metadata = (0, nice_grpc_common_1$5.Metadata)();
  for (const [key, values2] of Object.entries(grpcMetadata.headersMap)) {
    metadata.set(key, key.endsWith("-bin") ? values2.map((value) => js_base64_1.Base64.toUint8Array(value)) : values2);
  }
  return metadata;
}
convertMetadata.convertMetadataFromGrpcWeb = convertMetadataFromGrpcWeb;
var __importDefault$l = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(createBidiStreamingMethod$1, "__esModule", { value: true });
createBidiStreamingMethod$1.createBidiStreamingMethod = void 0;
const nice_grpc_common_1$4 = lib;
const grpc_web_1$3 = grpcWebClient_umd.exports;
const abort_controller_x_1$4 = require$$1$1;
const node_abort_controller_1$3 = __importDefault$l(browser$3.exports);
const AsyncSink_1$1 = AsyncSink$1;
const service_definitions_1$4 = serviceDefinitions;
const isAsyncIterable_1$3 = isAsyncIterable$1;
const convertMetadata_1$3 = convertMetadata;
function createBidiStreamingMethod(definition, channel2, middleware, defaultOptions) {
  const grpcMethodDefinition = (0, service_definitions_1$4.toGrpcWebMethodDefinition)(definition);
  const methodDescriptor = { path: definition.path, requestStream: definition.requestStream, responseStream: definition.responseStream, options: definition.options };
  async function* bidiStreamingMethod(request3, options2) {
    if (!(0, isAsyncIterable_1$3.isAsyncIterable)(request3)) {
      throw new Error("A middleware passed invalid request to next(): expected a single message for bidirectional streaming method");
    }
    const { metadata = (0, nice_grpc_common_1$4.Metadata)(), signal = new node_abort_controller_1$3.default().signal, onHeader, onTrailer } = options2;
    const pipeAbortController = new node_abort_controller_1$3.default();
    const sink = new AsyncSink_1$1.AsyncSink();
    const client = grpc_web_1$3.grpc.client(grpcMethodDefinition, { host: channel2.address, transport: channel2.transport });
    client.onHeaders((headers) => {
      onHeader === null || onHeader === void 0 ? void 0 : onHeader((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(headers));
    });
    client.onMessage((message) => {
      sink.write(message);
    });
    client.onEnd((code, message, trailers) => {
      onTrailer === null || onTrailer === void 0 ? void 0 : onTrailer((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(trailers));
      if (code === grpc_web_1$3.grpc.Code.OK) {
        sink.end();
      } else {
        sink.error(new nice_grpc_common_1$4.ClientError(definition.path, +code, message));
      }
    });
    client.start((0, convertMetadata_1$3.convertMetadataToGrpcWeb)(metadata));
    let pipeError;
    pipeRequest$1(pipeAbortController.signal, request3, client, definition).then(() => {
      client.finishSend();
    }, (err) => {
      if (!(0, abort_controller_x_1$4.isAbortError)(err)) {
        pipeError = err;
        client.close();
        sink.end();
      }
    });
    const abortListener = () => {
      sink.error(new abort_controller_x_1$4.AbortError());
      pipeAbortController.abort();
      client.close();
    };
    signal.addEventListener("abort", abortListener);
    try {
      yield* sink;
    } finally {
      pipeAbortController.abort();
      signal.removeEventListener("abort", abortListener);
      (0, abort_controller_x_1$4.throwIfAborted)(signal);
      if (pipeError) {
        throw pipeError;
      }
    }
  }
  const method = middleware == null ? bidiStreamingMethod : (request3, options2) => middleware({ method: methodDescriptor, requestStream: true, request: request3, responseStream: true, next: bidiStreamingMethod }, options2);
  return (request3, options2) => {
    const iterable = method(request3, { ...defaultOptions, ...options2 });
    const iterator2 = iterable[Symbol.asyncIterator]();
    return { [Symbol.asyncIterator]() {
      return { async next() {
        const result = await iterator2.next();
        if (result.done && result.value != null) {
          return await iterator2.throw(new Error("A middleware returned a message, but expected to return void for bidirectional streaming method"));
        }
        return result;
      }, return() {
        return iterator2.return();
      }, throw(err) {
        return iterator2.throw(err);
      } };
    } };
  };
}
createBidiStreamingMethod$1.createBidiStreamingMethod = createBidiStreamingMethod;
async function pipeRequest$1(signal, request3, client, definition) {
  for await (const item of request3) {
    (0, abort_controller_x_1$4.throwIfAborted)(signal);
    client.send({ serializeBinary: () => definition.requestSerialize(item) });
  }
}
var createClientStreamingMethod$1 = {};
var __importDefault$k = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(createClientStreamingMethod$1, "__esModule", { value: true });
createClientStreamingMethod$1.createClientStreamingMethod = void 0;
const nice_grpc_common_1$3 = lib;
const grpc_web_1$2 = grpcWebClient_umd.exports;
const abort_controller_x_1$3 = require$$1$1;
const node_abort_controller_1$2 = __importDefault$k(browser$3.exports);
const service_definitions_1$3 = serviceDefinitions;
const isAsyncIterable_1$2 = isAsyncIterable$1;
const convertMetadata_1$2 = convertMetadata;
function createClientStreamingMethod(definition, channel2, middleware, defaultOptions) {
  const grpcMethodDefinition = (0, service_definitions_1$3.toGrpcWebMethodDefinition)(definition);
  const methodDescriptor = { path: definition.path, requestStream: definition.requestStream, responseStream: definition.responseStream, options: definition.options };
  async function* clientStreamingMethod(request3, options2) {
    if (!(0, isAsyncIterable_1$2.isAsyncIterable)(request3)) {
      throw new Error("A middleware passed invalid request to next(): expected a single message for client streaming method");
    }
    const { metadata = (0, nice_grpc_common_1$3.Metadata)(), signal = new node_abort_controller_1$2.default().signal, onHeader, onTrailer } = options2;
    return await (0, abort_controller_x_1$3.execute)(signal, (resolve, reject) => {
      const pipeAbortController = new node_abort_controller_1$2.default();
      let response;
      const client = grpc_web_1$2.grpc.client(grpcMethodDefinition, { host: channel2.address, transport: channel2.transport });
      client.onHeaders((headers) => {
        onHeader === null || onHeader === void 0 ? void 0 : onHeader((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(headers));
      });
      client.onMessage((message) => {
        response = message;
      });
      client.onEnd((code, message, trailers) => {
        onTrailer === null || onTrailer === void 0 ? void 0 : onTrailer((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(trailers));
        pipeAbortController.abort();
        if (code === grpc_web_1$2.grpc.Code.OK) {
          resolve(response);
        } else {
          reject(new nice_grpc_common_1$3.ClientError(definition.path, +code, message));
        }
      });
      client.start((0, convertMetadata_1$2.convertMetadataToGrpcWeb)(metadata));
      pipeRequest(pipeAbortController.signal, request3, client, definition).then(() => {
        client.finishSend();
      }, (err) => {
        if (!(0, abort_controller_x_1$3.isAbortError)(err)) {
          reject(err);
          client.close();
        }
      });
      return () => {
        pipeAbortController.abort();
        client.close();
      };
    });
  }
  const method = middleware == null ? clientStreamingMethod : (request3, options2) => middleware({ method: methodDescriptor, requestStream: true, request: request3, responseStream: false, next: clientStreamingMethod }, options2);
  return async (request3, options2) => {
    const iterable = method(request3, { ...defaultOptions, ...options2 });
    const iterator2 = iterable[Symbol.asyncIterator]();
    let result = await iterator2.next();
    while (true) {
      if (!result.done) {
        result = await iterator2.throw(new Error("A middleware yielded a message, but expected to only return a message for client streaming method"));
        continue;
      }
      if (result.value == null) {
        result = await iterator2.throw(new Error("A middleware returned void, but expected to return a message for client streaming method"));
        continue;
      }
      return result.value;
    }
  };
}
createClientStreamingMethod$1.createClientStreamingMethod = createClientStreamingMethod;
async function pipeRequest(signal, request3, client, definition) {
  for await (const item of request3) {
    (0, abort_controller_x_1$3.throwIfAborted)(signal);
    client.send({ serializeBinary: () => definition.requestSerialize(item) });
  }
}
var createServerStreamingMethod$1 = {};
var __importDefault$j = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(createServerStreamingMethod$1, "__esModule", { value: true });
createServerStreamingMethod$1.createServerStreamingMethod = void 0;
const grpc_web_1$1 = grpcWebClient_umd.exports;
const abort_controller_x_1$2 = require$$1$1;
const AsyncSink_1 = AsyncSink$1;
const nice_grpc_common_1$2 = lib;
const node_abort_controller_1$1 = __importDefault$j(browser$3.exports);
const service_definitions_1$2 = serviceDefinitions;
const convertMetadata_1$1 = convertMetadata;
const isAsyncIterable_1$1 = isAsyncIterable$1;
function createServerStreamingMethod(definition, channel2, middleware, defaultOptions) {
  const grpcMethodDefinition = (0, service_definitions_1$2.toGrpcWebMethodDefinition)(definition);
  const methodDescriptor = { path: definition.path, requestStream: definition.requestStream, responseStream: definition.responseStream, options: definition.options };
  async function* serverStreamingMethod(request3, options2) {
    if ((0, isAsyncIterable_1$1.isAsyncIterable)(request3)) {
      throw new Error("A middleware passed invalid request to next(): expected a single message for server streaming method");
    }
    const { metadata = (0, nice_grpc_common_1$2.Metadata)(), signal = new node_abort_controller_1$1.default().signal, onHeader, onTrailer } = options2;
    const sink = new AsyncSink_1.AsyncSink();
    const client = grpc_web_1$1.grpc.client(grpcMethodDefinition, { host: channel2.address, transport: channel2.transport });
    client.onHeaders((headers) => {
      onHeader === null || onHeader === void 0 ? void 0 : onHeader((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(headers));
    });
    client.onMessage((message) => {
      sink.write(message);
    });
    client.onEnd((code, message, trailers) => {
      onTrailer === null || onTrailer === void 0 ? void 0 : onTrailer((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(trailers));
      if (code === grpc_web_1$1.grpc.Code.OK) {
        sink.end();
      } else {
        sink.error(new nice_grpc_common_1$2.ClientError(definition.path, +code, message));
      }
    });
    client.start((0, convertMetadata_1$1.convertMetadataToGrpcWeb)(metadata));
    client.send({ serializeBinary: () => definition.requestSerialize(request3) });
    client.finishSend();
    const abortListener = () => {
      sink.error(new abort_controller_x_1$2.AbortError());
      client.close();
    };
    signal.addEventListener("abort", abortListener);
    try {
      yield* sink;
    } finally {
      signal.removeEventListener("abort", abortListener);
      (0, abort_controller_x_1$2.throwIfAborted)(signal);
    }
  }
  const method = middleware == null ? serverStreamingMethod : (request3, options2) => middleware({ method: methodDescriptor, requestStream: false, request: request3, responseStream: true, next: serverStreamingMethod }, options2);
  return (request3, options2) => {
    const iterable = method(request3, { ...defaultOptions, ...options2 });
    const iterator2 = iterable[Symbol.asyncIterator]();
    return { [Symbol.asyncIterator]() {
      return { async next() {
        const result = await iterator2.next();
        if (result.done && result.value != null) {
          return await iterator2.throw(new Error("A middleware returned a message, but expected to return void for server streaming method"));
        }
        return result;
      }, return() {
        return iterator2.return();
      }, throw(err) {
        return iterator2.throw(err);
      } };
    } };
  };
}
createServerStreamingMethod$1.createServerStreamingMethod = createServerStreamingMethod;
var createUnaryMethod$1 = {};
var __importDefault$i = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(createUnaryMethod$1, "__esModule", { value: true });
createUnaryMethod$1.createUnaryMethod = void 0;
const nice_grpc_common_1$1 = lib;
const grpc_web_1 = grpcWebClient_umd.exports;
const abort_controller_x_1$1 = require$$1$1;
const node_abort_controller_1 = __importDefault$i(browser$3.exports);
const service_definitions_1$1 = serviceDefinitions;
const isAsyncIterable_1 = isAsyncIterable$1;
const convertMetadata_1 = convertMetadata;
function createUnaryMethod(definition, channel2, middleware, defaultOptions) {
  const grpcMethodDefinition = (0, service_definitions_1$1.toGrpcWebMethodDefinition)(definition);
  const methodDescriptor = { path: definition.path, requestStream: definition.requestStream, responseStream: definition.responseStream, options: definition.options };
  async function* unaryMethod(request3, options2) {
    if ((0, isAsyncIterable_1.isAsyncIterable)(request3)) {
      throw new Error("A middleware passed invalid request to next(): expected a single message for unary method");
    }
    const { metadata = (0, nice_grpc_common_1$1.Metadata)(), signal = new node_abort_controller_1.default().signal, onHeader, onTrailer } = options2;
    return await (0, abort_controller_x_1$1.execute)(signal, (resolve, reject) => {
      let response;
      const client = grpc_web_1.grpc.client(grpcMethodDefinition, { host: channel2.address, transport: channel2.transport });
      client.onHeaders((headers) => {
        onHeader === null || onHeader === void 0 ? void 0 : onHeader((0, convertMetadata_1.convertMetadataFromGrpcWeb)(headers));
      });
      client.onMessage((message) => {
        response = message;
      });
      client.onEnd((code, message, trailers) => {
        onTrailer === null || onTrailer === void 0 ? void 0 : onTrailer((0, convertMetadata_1.convertMetadataFromGrpcWeb)(trailers));
        if (code === grpc_web_1.grpc.Code.OK) {
          resolve(response);
        } else {
          reject(new nice_grpc_common_1$1.ClientError(definition.path, +code, message));
        }
      });
      client.start((0, convertMetadata_1.convertMetadataToGrpcWeb)(metadata));
      client.send({ serializeBinary: () => definition.requestSerialize(request3) });
      client.finishSend();
      return () => {
        client.close();
      };
    });
  }
  const method = middleware == null ? unaryMethod : (request3, options2) => middleware({ method: methodDescriptor, requestStream: false, request: request3, responseStream: false, next: unaryMethod }, options2);
  return async (request3, options2) => {
    const iterable = method(request3, { ...defaultOptions, ...options2 });
    const iterator2 = iterable[Symbol.asyncIterator]();
    let result = await iterator2.next();
    while (true) {
      if (!result.done) {
        result = await iterator2.throw(new Error("A middleware yielded a message, but expected to only return a message for unary method"));
        continue;
      }
      if (result.value == null) {
        result = await iterator2.throw(new Error("A middleware returned void, but expected to return a message for unary method"));
        continue;
      }
      return result.value;
    }
  };
}
createUnaryMethod$1.createUnaryMethod = createUnaryMethod;
Object.defineProperty(ClientFactory, "__esModule", { value: true });
ClientFactory.createClient = ClientFactory.createClientFactory = void 0;
const nice_grpc_common_1 = lib;
const service_definitions_1 = serviceDefinitions;
const createBidiStreamingMethod_1 = createBidiStreamingMethod$1;
const createClientStreamingMethod_1 = createClientStreamingMethod$1;
const createServerStreamingMethod_1 = createServerStreamingMethod$1;
const createUnaryMethod_1 = createUnaryMethod$1;
function createClientFactory() {
  return createClientFactoryWithMiddleware();
}
ClientFactory.createClientFactory = createClientFactory;
function createClient(definition, channel2, defaultCallOptions) {
  return createClientFactory().create(definition, channel2, defaultCallOptions);
}
ClientFactory.createClient = createClient;
function createClientFactoryWithMiddleware(middleware) {
  return { use(newMiddleware) {
    return createClientFactoryWithMiddleware(middleware == null ? newMiddleware : (0, nice_grpc_common_1.composeClientMiddleware)(middleware, newMiddleware));
  }, create(definition, channel2, defaultCallOptions = {}) {
    const client = {};
    const methodEntries = Object.entries((0, service_definitions_1.normalizeServiceDefinition)(definition));
    for (const [methodName, methodDefinition] of methodEntries) {
      const defaultOptions = { ...defaultCallOptions["*"], ...defaultCallOptions[methodName] };
      if (!methodDefinition.requestStream) {
        if (!methodDefinition.responseStream) {
          client[methodName] = (0, createUnaryMethod_1.createUnaryMethod)(methodDefinition, channel2, middleware, defaultOptions);
        } else {
          client[methodName] = (0, createServerStreamingMethod_1.createServerStreamingMethod)(methodDefinition, channel2, middleware, defaultOptions);
        }
      } else {
        if (!methodDefinition.responseStream) {
          client[methodName] = (0, createClientStreamingMethod_1.createClientStreamingMethod)(methodDefinition, channel2, middleware, defaultOptions);
        } else {
          client[methodName] = (0, createBidiStreamingMethod_1.createBidiStreamingMethod)(methodDefinition, channel2, middleware, defaultOptions);
        }
      }
    }
    return client;
  } };
}
var Client = {};
Object.defineProperty(Client, "__esModule", { value: true });
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Status = exports2.Metadata = exports2.composeClientMiddleware = exports2.ClientError = void 0;
  var nice_grpc_common_12 = lib;
  Object.defineProperty(exports2, "ClientError", { enumerable: true, get: function() {
    return nice_grpc_common_12.ClientError;
  } });
  Object.defineProperty(exports2, "composeClientMiddleware", { enumerable: true, get: function() {
    return nice_grpc_common_12.composeClientMiddleware;
  } });
  Object.defineProperty(exports2, "Metadata", { enumerable: true, get: function() {
    return nice_grpc_common_12.Metadata;
  } });
  Object.defineProperty(exports2, "Status", { enumerable: true, get: function() {
    return nice_grpc_common_12.Status;
  } });
  __exportStar(serviceDefinitions, exports2);
  __exportStar(channel, exports2);
  __exportStar(ClientFactory, exports2);
  __exportStar(Client, exports2);
})(lib$1);
var dist$3 = {};
var api$3 = {};
var umd = { exports: {} };
(function(module2, exports2) {
  var Long = function(exports3) {
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.default = void 0;
    /**
    * @license
    * Copyright 2009 The Closure Library Authors
    * Copyright 2020 Daniel Wirtz / The long.js Authors.
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    *
    * SPDX-License-Identifier: Apache-2.0
    */
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
    } catch (e2) {
    }
    function Long2(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long2.prototype.__isLong__;
    Object.defineProperty(Long2.prototype, "__isLong__", { value: true });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    function ctz32(value) {
      var c = Math.clz32(value & -value);
      return value ? 31 - c : c;
    }
    Long2.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache2;
      if (unsigned) {
        value >>>= 0;
        if (cache2 = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, 0, true);
        if (cache2)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache2 = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache2)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long2.fromInt = fromInt;
    function fromNumber2(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber2(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long2.fromNumber = fromNumber2;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long2(lowBits, highBits, unsigned);
    }
    Long2.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (typeof unsigned === "number") {
        radix = unsigned;
        unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return unsigned ? UZERO : ZERO;
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p2;
      if ((p2 = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p2 === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber2(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i2 = 0; i2 < str.length; i2 += 8) {
        var size = Math.min(8, str.length - i2), value = parseInt(str.substring(i2, i2 + size), radix);
        if (size < 8) {
          var power = fromNumber2(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber2(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber2(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long2.fromString = fromString;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber2(val, unsigned);
      if (typeof val === "string")
        return fromString(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long2.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long2.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long2.UZERO = UZERO;
    var ONE = fromInt(1);
    Long2.ONE = ONE;
    var UONE = fromInt(1, true);
    Long2.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long2.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long2.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long2.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long2.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber3() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString3(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber2(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber2(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(other);
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(other) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(other) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(other) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(other) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return this;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      if (multiplier.isZero())
        return this.unsigned ? UZERO : ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber2(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber2(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber2(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not2() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.countLeadingZeros = function countLeadingZeros() {
      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
    };
    LongPrototype.clz = LongPrototype.countLeadingZeros;
    LongPrototype.countTrailingZeros = function countTrailingZeros() {
      return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
    };
    LongPrototype.ctz = LongPrototype.countTrailingZeros;
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
      if (numBits === 32)
        return fromBits(this.high, 0, this.unsigned);
      return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.rotateLeft = function rotateLeft(numBits) {
      var b;
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits === 32)
        return fromBits(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
    };
    LongPrototype.rotl = LongPrototype.rotateLeft;
    LongPrototype.rotateRight = function rotateRight(numBits) {
      var b;
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits === 32)
        return fromBits(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
    };
    LongPrototype.rotr = LongPrototype.rotateRight;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le2) {
      return le2 ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi2 = this.high, lo = this.low;
      return [lo & 255, lo >>> 8 & 255, lo >>> 16 & 255, lo >>> 24, hi2 & 255, hi2 >>> 8 & 255, hi2 >>> 16 & 255, hi2 >>> 24];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi2 = this.high, lo = this.low;
      return [hi2 >>> 24, hi2 >>> 16 & 255, hi2 >>> 8 & 255, hi2 & 255, lo >>> 24, lo >>> 16 & 255, lo >>> 8 & 255, lo & 255];
    };
    Long2.fromBytes = function fromBytes(bytes, unsigned, le2) {
      return le2 ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
    };
    Long2.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long2(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
    };
    Long2.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long2(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
    };
    var _default = Long2;
    exports3.default = _default;
    return "default" in exports3 ? exports3.default : exports3;
  }({});
  module2.exports = Long;
})(umd);
var indexMinimal = {};
var minimal$1 = {};
var aspromise = asPromise;
function asPromise(fn, ctx) {
  var params = new Array(arguments.length - 1), offset = 0, index2 = 2, pending = true;
  while (index2 < arguments.length)
    params[offset++] = arguments[index2++];
  return new Promise(function executor(resolve, reject) {
    params[offset] = function callback(err) {
      if (pending) {
        pending = false;
        if (err)
          reject(err);
        else {
          var params2 = new Array(arguments.length - 1), offset2 = 0;
          while (offset2 < params2.length)
            params2[offset2++] = arguments[offset2];
          resolve.apply(null, params2);
        }
      }
    };
    try {
      fn.apply(ctx || null, params);
    } catch (err) {
      if (pending) {
        pending = false;
        reject(err);
      }
    }
  });
}
var base64$1 = {};
(function(exports2) {
  var base642 = exports2;
  base642.length = function length2(string) {
    var p2 = string.length;
    if (!p2)
      return 0;
    var n2 = 0;
    while (--p2 % 4 > 1 && string.charAt(p2) === "=")
      ++n2;
    return Math.ceil(string.length * 3) / 4 - n2;
  };
  var b64 = new Array(64);
  var s64 = new Array(123);
  for (var i2 = 0; i2 < 64; )
    s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
  base642.encode = function encode2(buffer2, start2, end2) {
    var parts = null, chunk = [];
    var i3 = 0, j = 0, t2;
    while (start2 < end2) {
      var b = buffer2[start2++];
      switch (j) {
        case 0:
          chunk[i3++] = b64[b >> 2];
          t2 = (b & 3) << 4;
          j = 1;
          break;
        case 1:
          chunk[i3++] = b64[t2 | b >> 4];
          t2 = (b & 15) << 2;
          j = 2;
          break;
        case 2:
          chunk[i3++] = b64[t2 | b >> 6];
          chunk[i3++] = b64[b & 63];
          j = 0;
          break;
      }
      if (i3 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i3 = 0;
      }
    }
    if (j) {
      chunk[i3++] = b64[t2];
      chunk[i3++] = 61;
      if (j === 1)
        chunk[i3++] = 61;
    }
    if (parts) {
      if (i3)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i3));
  };
  var invalidEncoding = "invalid encoding";
  base642.decode = function decode(string, buffer2, offset) {
    var start2 = offset;
    var j = 0, t2;
    for (var i3 = 0; i3 < string.length; ) {
      var c = string.charCodeAt(i3++);
      if (c === 61 && j > 1)
        break;
      if ((c = s64[c]) === void 0)
        throw Error(invalidEncoding);
      switch (j) {
        case 0:
          t2 = c;
          j = 1;
          break;
        case 1:
          buffer2[offset++] = t2 << 2 | (c & 48) >> 4;
          t2 = c;
          j = 2;
          break;
        case 2:
          buffer2[offset++] = (t2 & 15) << 4 | (c & 60) >> 2;
          t2 = c;
          j = 3;
          break;
        case 3:
          buffer2[offset++] = (t2 & 3) << 6 | c;
          j = 0;
          break;
      }
    }
    if (j === 1)
      throw Error(invalidEncoding);
    return offset - start2;
  };
  base642.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
  };
})(base64$1);
var eventemitter = EventEmitter$1;
function EventEmitter$1() {
  this._listeners = {};
}
EventEmitter$1.prototype.on = function on2(evt, fn, ctx) {
  (this._listeners[evt] || (this._listeners[evt] = [])).push({ fn, ctx: ctx || this });
  return this;
};
EventEmitter$1.prototype.off = function off(evt, fn) {
  if (evt === void 0)
    this._listeners = {};
  else {
    if (fn === void 0)
      this._listeners[evt] = [];
    else {
      var listeners2 = this._listeners[evt];
      for (var i2 = 0; i2 < listeners2.length; )
        if (listeners2[i2].fn === fn)
          listeners2.splice(i2, 1);
        else
          ++i2;
    }
  }
  return this;
};
EventEmitter$1.prototype.emit = function emit(evt) {
  var listeners2 = this._listeners[evt];
  if (listeners2) {
    var args = [], i2 = 1;
    for (; i2 < arguments.length; )
      args.push(arguments[i2++]);
    for (i2 = 0; i2 < listeners2.length; )
      listeners2[i2].fn.apply(listeners2[i2++].ctx, args);
  }
  return this;
};
var float = factory(factory);
function factory(exports2) {
  if (typeof Float32Array !== "undefined")
    (function() {
      var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le2 = f8b[3] === 128;
      function writeFloat_f32_cpy(val, buf, pos) {
        f32[0] = val;
        buf[pos] = f8b[0];
        buf[pos + 1] = f8b[1];
        buf[pos + 2] = f8b[2];
        buf[pos + 3] = f8b[3];
      }
      function writeFloat_f32_rev(val, buf, pos) {
        f32[0] = val;
        buf[pos] = f8b[3];
        buf[pos + 1] = f8b[2];
        buf[pos + 2] = f8b[1];
        buf[pos + 3] = f8b[0];
      }
      exports2.writeFloatLE = le2 ? writeFloat_f32_cpy : writeFloat_f32_rev;
      exports2.writeFloatBE = le2 ? writeFloat_f32_rev : writeFloat_f32_cpy;
      function readFloat_f32_cpy(buf, pos) {
        f8b[0] = buf[pos];
        f8b[1] = buf[pos + 1];
        f8b[2] = buf[pos + 2];
        f8b[3] = buf[pos + 3];
        return f32[0];
      }
      function readFloat_f32_rev(buf, pos) {
        f8b[3] = buf[pos];
        f8b[2] = buf[pos + 1];
        f8b[1] = buf[pos + 2];
        f8b[0] = buf[pos + 3];
        return f32[0];
      }
      exports2.readFloatLE = le2 ? readFloat_f32_cpy : readFloat_f32_rev;
      exports2.readFloatBE = le2 ? readFloat_f32_rev : readFloat_f32_cpy;
    })();
  else
    (function() {
      function writeFloat_ieee754(writeUint, val, buf, pos) {
        var sign = val < 0 ? 1 : 0;
        if (sign)
          val = -val;
        if (val === 0)
          writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
        else if (isNaN(val))
          writeUint(2143289344, buf, pos);
        else if (val > 34028234663852886e22)
          writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
        else if (val < 11754943508222875e-54)
          writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
        else {
          var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
          writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
        }
      }
      exports2.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
      exports2.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
      function readFloat_ieee754(readUint, buf, pos) {
        var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
        return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
      }
      exports2.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
      exports2.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
    })();
  if (typeof Float64Array !== "undefined")
    (function() {
      var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le2 = f8b[7] === 128;
      function writeDouble_f64_cpy(val, buf, pos) {
        f64[0] = val;
        buf[pos] = f8b[0];
        buf[pos + 1] = f8b[1];
        buf[pos + 2] = f8b[2];
        buf[pos + 3] = f8b[3];
        buf[pos + 4] = f8b[4];
        buf[pos + 5] = f8b[5];
        buf[pos + 6] = f8b[6];
        buf[pos + 7] = f8b[7];
      }
      function writeDouble_f64_rev(val, buf, pos) {
        f64[0] = val;
        buf[pos] = f8b[7];
        buf[pos + 1] = f8b[6];
        buf[pos + 2] = f8b[5];
        buf[pos + 3] = f8b[4];
        buf[pos + 4] = f8b[3];
        buf[pos + 5] = f8b[2];
        buf[pos + 6] = f8b[1];
        buf[pos + 7] = f8b[0];
      }
      exports2.writeDoubleLE = le2 ? writeDouble_f64_cpy : writeDouble_f64_rev;
      exports2.writeDoubleBE = le2 ? writeDouble_f64_rev : writeDouble_f64_cpy;
      function readDouble_f64_cpy(buf, pos) {
        f8b[0] = buf[pos];
        f8b[1] = buf[pos + 1];
        f8b[2] = buf[pos + 2];
        f8b[3] = buf[pos + 3];
        f8b[4] = buf[pos + 4];
        f8b[5] = buf[pos + 5];
        f8b[6] = buf[pos + 6];
        f8b[7] = buf[pos + 7];
        return f64[0];
      }
      function readDouble_f64_rev(buf, pos) {
        f8b[7] = buf[pos];
        f8b[6] = buf[pos + 1];
        f8b[5] = buf[pos + 2];
        f8b[4] = buf[pos + 3];
        f8b[3] = buf[pos + 4];
        f8b[2] = buf[pos + 5];
        f8b[1] = buf[pos + 6];
        f8b[0] = buf[pos + 7];
        return f64[0];
      }
      exports2.readDoubleLE = le2 ? readDouble_f64_cpy : readDouble_f64_rev;
      exports2.readDoubleBE = le2 ? readDouble_f64_rev : readDouble_f64_cpy;
    })();
  else
    (function() {
      function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
        var sign = val < 0 ? 1 : 0;
        if (sign)
          val = -val;
        if (val === 0) {
          writeUint(0, buf, pos + off0);
          writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
        } else if (isNaN(val)) {
          writeUint(0, buf, pos + off0);
          writeUint(2146959360, buf, pos + off1);
        } else if (val > 17976931348623157e292) {
          writeUint(0, buf, pos + off0);
          writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
        } else {
          var mantissa;
          if (val < 22250738585072014e-324) {
            mantissa = val / 5e-324;
            writeUint(mantissa >>> 0, buf, pos + off0);
            writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
          } else {
            var exponent = Math.floor(Math.log(val) / Math.LN2);
            if (exponent === 1024)
              exponent = 1023;
            mantissa = val * Math.pow(2, -exponent);
            writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
            writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
          }
        }
      }
      exports2.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
      exports2.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
      function readDouble_ieee754(readUint, off0, off1, buf, pos) {
        var lo = readUint(buf, pos + off0), hi2 = readUint(buf, pos + off1);
        var sign = (hi2 >> 31) * 2 + 1, exponent = hi2 >>> 20 & 2047, mantissa = 4294967296 * (hi2 & 1048575) + lo;
        return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
      }
      exports2.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
      exports2.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
    })();
  return exports2;
}
function writeUintLE(val, buf, pos) {
  buf[pos] = val & 255;
  buf[pos + 1] = val >>> 8 & 255;
  buf[pos + 2] = val >>> 16 & 255;
  buf[pos + 3] = val >>> 24;
}
function writeUintBE(val, buf, pos) {
  buf[pos] = val >>> 24;
  buf[pos + 1] = val >>> 16 & 255;
  buf[pos + 2] = val >>> 8 & 255;
  buf[pos + 3] = val & 255;
}
function readUintLE(buf, pos) {
  return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
}
function readUintBE(buf, pos) {
  return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (e2) {
  }
  return null;
}
var utf8$2 = {};
(function(exports2) {
  var utf82 = exports2;
  utf82.length = function utf8_length(string) {
    var len = 0, c = 0;
    for (var i2 = 0; i2 < string.length; ++i2) {
      c = string.charCodeAt(i2);
      if (c < 128)
        len += 1;
      else if (c < 2048)
        len += 2;
      else if ((c & 64512) === 55296 && (string.charCodeAt(i2 + 1) & 64512) === 56320) {
        ++i2;
        len += 4;
      } else
        len += 3;
    }
    return len;
  };
  utf82.read = function utf8_read(buffer2, start2, end2) {
    var len = end2 - start2;
    if (len < 1)
      return "";
    var parts = null, chunk = [], i2 = 0, t2;
    while (start2 < end2) {
      t2 = buffer2[start2++];
      if (t2 < 128)
        chunk[i2++] = t2;
      else if (t2 > 191 && t2 < 224)
        chunk[i2++] = (t2 & 31) << 6 | buffer2[start2++] & 63;
      else if (t2 > 239 && t2 < 365) {
        t2 = ((t2 & 7) << 18 | (buffer2[start2++] & 63) << 12 | (buffer2[start2++] & 63) << 6 | buffer2[start2++] & 63) - 65536;
        chunk[i2++] = 55296 + (t2 >> 10);
        chunk[i2++] = 56320 + (t2 & 1023);
      } else
        chunk[i2++] = (t2 & 15) << 12 | (buffer2[start2++] & 63) << 6 | buffer2[start2++] & 63;
      if (i2 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i2 = 0;
      }
    }
    if (parts) {
      if (i2)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i2));
  };
  utf82.write = function utf8_write(string, buffer2, offset) {
    var start2 = offset, c1, c2;
    for (var i2 = 0; i2 < string.length; ++i2) {
      c1 = string.charCodeAt(i2);
      if (c1 < 128) {
        buffer2[offset++] = c1;
      } else if (c1 < 2048) {
        buffer2[offset++] = c1 >> 6 | 192;
        buffer2[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i2 + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
        ++i2;
        buffer2[offset++] = c1 >> 18 | 240;
        buffer2[offset++] = c1 >> 12 & 63 | 128;
        buffer2[offset++] = c1 >> 6 & 63 | 128;
        buffer2[offset++] = c1 & 63 | 128;
      } else {
        buffer2[offset++] = c1 >> 12 | 224;
        buffer2[offset++] = c1 >> 6 & 63 | 128;
        buffer2[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start2;
  };
})(utf8$2);
var pool_1 = pool;
function pool(alloc2, slice2, size) {
  var SIZE = size || 8192;
  var MAX = SIZE >>> 1;
  var slab = null;
  var offset = SIZE;
  return function pool_alloc(size2) {
    if (size2 < 1 || size2 > MAX)
      return alloc2(size2);
    if (offset + size2 > SIZE) {
      slab = alloc2(SIZE);
      offset = 0;
    }
    var buf = slice2.call(slab, offset, offset += size2);
    if (offset & 7)
      offset = (offset | 7) + 1;
    return buf;
  };
}
var longbits = LongBits$2;
var util$5 = minimal$1;
function LongBits$2(lo, hi2) {
  this.lo = lo >>> 0;
  this.hi = hi2 >>> 0;
}
var zero = LongBits$2.zero = new LongBits$2(0, 0);
zero.toNumber = function() {
  return 0;
};
zero.zzEncode = zero.zzDecode = function() {
  return this;
};
zero.length = function() {
  return 1;
};
var zeroHash = LongBits$2.zeroHash = "\0\0\0\0\0\0\0\0";
LongBits$2.fromNumber = function fromNumber(value) {
  if (value === 0)
    return zero;
  var sign = value < 0;
  if (sign)
    value = -value;
  var lo = value >>> 0, hi2 = (value - lo) / 4294967296 >>> 0;
  if (sign) {
    hi2 = ~hi2 >>> 0;
    lo = ~lo >>> 0;
    if (++lo > 4294967295) {
      lo = 0;
      if (++hi2 > 4294967295)
        hi2 = 0;
    }
  }
  return new LongBits$2(lo, hi2);
};
LongBits$2.from = function from2(value) {
  if (typeof value === "number")
    return LongBits$2.fromNumber(value);
  if (util$5.isString(value)) {
    if (util$5.Long)
      value = util$5.Long.fromString(value);
    else
      return LongBits$2.fromNumber(parseInt(value, 10));
  }
  return value.low || value.high ? new LongBits$2(value.low >>> 0, value.high >>> 0) : zero;
};
LongBits$2.prototype.toNumber = function toNumber2(unsigned) {
  if (!unsigned && this.hi >>> 31) {
    var lo = ~this.lo + 1 >>> 0, hi2 = ~this.hi >>> 0;
    if (!lo)
      hi2 = hi2 + 1 >>> 0;
    return -(lo + hi2 * 4294967296);
  }
  return this.lo + this.hi * 4294967296;
};
LongBits$2.prototype.toLong = function toLong(unsigned) {
  return util$5.Long ? new util$5.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};
var charCodeAt = String.prototype.charCodeAt;
LongBits$2.fromHash = function fromHash(hash) {
  if (hash === zeroHash)
    return zero;
  return new LongBits$2((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
};
LongBits$2.prototype.toHash = function toHash() {
  return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
};
LongBits$2.prototype.zzEncode = function zzEncode() {
  var mask = this.hi >> 31;
  this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
  this.lo = (this.lo << 1 ^ mask) >>> 0;
  return this;
};
LongBits$2.prototype.zzDecode = function zzDecode() {
  var mask = -(this.lo & 1);
  this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
  this.hi = (this.hi >>> 1 ^ mask) >>> 0;
  return this;
};
LongBits$2.prototype.length = function length() {
  var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
  return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
};
(function(exports2) {
  var util2 = exports2;
  util2.asPromise = aspromise;
  util2.base64 = base64$1;
  util2.EventEmitter = eventemitter;
  util2.float = float;
  util2.inquire = inquire_1;
  util2.utf8 = utf8$2;
  util2.pool = pool_1;
  util2.LongBits = longbits;
  util2.isNode = Boolean(typeof commonjsGlobal !== "undefined" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node);
  util2.global = util2.isNode && commonjsGlobal || typeof window !== "undefined" && window || typeof self !== "undefined" && self || commonjsGlobal;
  util2.emptyArray = Object.freeze ? Object.freeze([]) : [];
  util2.emptyObject = Object.freeze ? Object.freeze({}) : {};
  util2.isInteger = Number.isInteger || function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
  util2.isString = function isString2(value) {
    return typeof value === "string" || value instanceof String;
  };
  util2.isObject = function isObject2(value) {
    return value && typeof value === "object";
  };
  util2.isset = util2.isSet = function isSet2(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop))
      return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
  };
  util2.Buffer = function() {
    try {
      var Buffer2 = util2.inquire("buffer").Buffer;
      return Buffer2.prototype.utf8Write ? Buffer2 : null;
    } catch (e2) {
      return null;
    }
  }();
  util2._Buffer_from = null;
  util2._Buffer_allocUnsafe = null;
  util2.newBuffer = function newBuffer(sizeOrArray) {
    return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
  };
  util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  util2.Long = util2.global.dcodeIO && util2.global.dcodeIO.Long || util2.global.Long || util2.inquire("long");
  util2.key2Re = /^true|false|0|1$/;
  util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
  util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
  util2.longToHash = function longToHash(value) {
    return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
  };
  util2.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util2.LongBits.fromHash(hash);
    if (util2.Long)
      return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
  };
  function merge2(dst, src, ifNotSet) {
    for (var keys2 = Object.keys(src), i2 = 0; i2 < keys2.length; ++i2)
      if (dst[keys2[i2]] === void 0 || !ifNotSet)
        dst[keys2[i2]] = src[keys2[i2]];
    return dst;
  }
  util2.merge = merge2;
  util2.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
  };
  function newError(name2) {
    function CustomError(message, properties) {
      if (!(this instanceof CustomError))
        return new CustomError(message, properties);
      Object.defineProperty(this, "message", { get: function() {
        return message;
      } });
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, CustomError);
      else
        Object.defineProperty(this, "stack", { value: new Error().stack || "" });
      if (properties)
        merge2(this, properties);
    }
    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
    Object.defineProperty(CustomError.prototype, "name", { get: function() {
      return name2;
    } });
    CustomError.prototype.toString = function toString3() {
      return this.name + ": " + this.message;
    };
    return CustomError;
  }
  util2.newError = newError;
  util2.ProtocolError = newError("ProtocolError");
  util2.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i2 = 0; i2 < fieldNames.length; ++i2)
      fieldMap[fieldNames[i2]] = 1;
    return function() {
      for (var keys2 = Object.keys(this), i3 = keys2.length - 1; i3 > -1; --i3)
        if (fieldMap[keys2[i3]] === 1 && this[keys2[i3]] !== void 0 && this[keys2[i3]] !== null)
          return keys2[i3];
    };
  };
  util2.oneOfSetter = function setOneOf(fieldNames) {
    return function(name2) {
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        if (fieldNames[i2] !== name2)
          delete this[fieldNames[i2]];
    };
  };
  util2.toJSONOptions = { longs: String, enums: String, bytes: String, json: true };
  util2._configure = function() {
    var Buffer2 = util2.Buffer;
    if (!Buffer2) {
      util2._Buffer_from = util2._Buffer_allocUnsafe = null;
      return;
    }
    util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
      return new Buffer2(value, encoding);
    };
    util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
      return new Buffer2(size);
    };
  };
})(minimal$1);
var writer = Writer$1;
var util$4 = minimal$1;
var BufferWriter$1;
var LongBits$1 = util$4.LongBits, base64 = util$4.base64, utf8$1 = util$4.utf8;
function Op(fn, len, val) {
  this.fn = fn;
  this.len = len;
  this.next = void 0;
  this.val = val;
}
function noop$2() {
}
function State(writer2) {
  this.head = writer2.head;
  this.tail = writer2.tail;
  this.len = writer2.len;
  this.next = writer2.states;
}
function Writer$1() {
  this.len = 0;
  this.head = new Op(noop$2, 0, 0);
  this.tail = this.head;
  this.states = null;
}
var create$4 = function create2() {
  return util$4.Buffer ? function create_buffer_setup() {
    return (Writer$1.create = function create_buffer() {
      return new BufferWriter$1();
    })();
  } : function create_array3() {
    return new Writer$1();
  };
};
Writer$1.create = create$4();
Writer$1.alloc = function alloc(size) {
  return new util$4.Array(size);
};
if (util$4.Array !== Array)
  Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray);
Writer$1.prototype._push = function push(fn, len, val) {
  this.tail = this.tail.next = new Op(fn, len, val);
  this.len += len;
  return this;
};
function writeByte(val, buf, pos) {
  buf[pos] = val & 255;
}
function writeVarint32(val, buf, pos) {
  while (val > 127) {
    buf[pos++] = val & 127 | 128;
    val >>>= 7;
  }
  buf[pos] = val;
}
function VarintOp(len, val) {
  this.len = len;
  this.next = void 0;
  this.val = val;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function write_uint32(value) {
  this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
  return this;
};
Writer$1.prototype.int32 = function write_int32(value) {
  return value < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(value)) : this.uint32(value);
};
Writer$1.prototype.sint32 = function write_sint32(value) {
  return this.uint32((value << 1 ^ value >> 31) >>> 0);
};
function writeVarint64(val, buf, pos) {
  while (val.hi) {
    buf[pos++] = val.lo & 127 | 128;
    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
    val.hi >>>= 7;
  }
  while (val.lo > 127) {
    buf[pos++] = val.lo & 127 | 128;
    val.lo = val.lo >>> 7;
  }
  buf[pos++] = val.lo;
}
Writer$1.prototype.uint64 = function write_uint64(value) {
  var bits = LongBits$1.from(value);
  return this._push(writeVarint64, bits.length(), bits);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function write_sint64(value) {
  var bits = LongBits$1.from(value).zzEncode();
  return this._push(writeVarint64, bits.length(), bits);
};
Writer$1.prototype.bool = function write_bool(value) {
  return this._push(writeByte, 1, value ? 1 : 0);
};
function writeFixed32(val, buf, pos) {
  buf[pos] = val & 255;
  buf[pos + 1] = val >>> 8 & 255;
  buf[pos + 2] = val >>> 16 & 255;
  buf[pos + 3] = val >>> 24;
}
Writer$1.prototype.fixed32 = function write_fixed32(value) {
  return this._push(writeFixed32, 4, value >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function write_fixed64(value) {
  var bits = LongBits$1.from(value);
  return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function write_float(value) {
  return this._push(util$4.float.writeFloatLE, 4, value);
};
Writer$1.prototype.double = function write_double(value) {
  return this._push(util$4.float.writeDoubleLE, 8, value);
};
var writeBytes = util$4.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
  buf.set(val, pos);
} : function writeBytes_for(val, buf, pos) {
  for (var i2 = 0; i2 < val.length; ++i2)
    buf[pos + i2] = val[i2];
};
Writer$1.prototype.bytes = function write_bytes(value) {
  var len = value.length >>> 0;
  if (!len)
    return this._push(writeByte, 1, 0);
  if (util$4.isString(value)) {
    var buf = Writer$1.alloc(len = base64.length(value));
    base64.decode(value, buf, 0);
    value = buf;
  }
  return this.uint32(len)._push(writeBytes, len, value);
};
Writer$1.prototype.string = function write_string(value) {
  var len = utf8$1.length(value);
  return len ? this.uint32(len)._push(utf8$1.write, len, value) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function fork() {
  this.states = new State(this);
  this.head = this.tail = new Op(noop$2, 0, 0);
  this.len = 0;
  return this;
};
Writer$1.prototype.reset = function reset() {
  if (this.states) {
    this.head = this.states.head;
    this.tail = this.states.tail;
    this.len = this.states.len;
    this.states = this.states.next;
  } else {
    this.head = this.tail = new Op(noop$2, 0, 0);
    this.len = 0;
  }
  return this;
};
Writer$1.prototype.ldelim = function ldelim() {
  var head = this.head, tail = this.tail, len = this.len;
  this.reset().uint32(len);
  if (len) {
    this.tail.next = head.next;
    this.tail = tail;
    this.len += len;
  }
  return this;
};
Writer$1.prototype.finish = function finish() {
  var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
  while (head) {
    head.fn(head.val, buf, pos);
    pos += head.len;
    head = head.next;
  }
  return buf;
};
Writer$1._configure = function(BufferWriter_) {
  BufferWriter$1 = BufferWriter_;
  Writer$1.create = create$4();
  BufferWriter$1._configure();
};
var writer_buffer = BufferWriter;
var Writer = writer;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$3 = minimal$1;
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$3._Buffer_allocUnsafe;
  BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && util$3.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytesBuffer_copy(val, buf, pos) {
    if (val.copy)
      val.copy(buf, pos, 0, val.length);
    else
      for (var i2 = 0; i2 < val.length; )
        buf[pos++] = val[i2++];
  };
};
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
  if (util$3.isString(value))
    value = util$3._Buffer_from(value, "base64");
  var len = value.length >>> 0;
  this.uint32(len);
  if (len)
    this._push(BufferWriter.writeBytesBuffer, len, value);
  return this;
};
function writeStringBuffer(val, buf, pos) {
  if (val.length < 40)
    util$3.utf8.write(val, buf, pos);
  else if (buf.utf8Write)
    buf.utf8Write(val, pos);
  else
    buf.write(val, pos);
}
BufferWriter.prototype.string = function write_string_buffer(value) {
  var len = util$3.Buffer.byteLength(value);
  this.uint32(len);
  if (len)
    this._push(writeStringBuffer, len, value);
  return this;
};
BufferWriter._configure();
var reader = Reader$1;
var util$2 = minimal$1;
var BufferReader$1;
var LongBits = util$2.LongBits, utf8 = util$2.utf8;
function indexOutOfRange(reader2, writeLength) {
  return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
}
function Reader$1(buffer2) {
  this.buf = buffer2;
  this.pos = 0;
  this.len = buffer2.length;
}
var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
  if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
    return new Reader$1(buffer2);
  throw Error("illegal buffer");
} : function create_array2(buffer2) {
  if (Array.isArray(buffer2))
    return new Reader$1(buffer2);
  throw Error("illegal buffer");
};
var create$3 = function create3() {
  return util$2.Buffer ? function create_buffer_setup(buffer2) {
    return (Reader$1.create = function create_buffer(buffer3) {
      return util$2.Buffer.isBuffer(buffer3) ? new BufferReader$1(buffer3) : create_array(buffer3);
    })(buffer2);
  } : create_array;
};
Reader$1.create = create$3();
Reader$1.prototype._slice = util$2.Array.prototype.subarray || util$2.Array.prototype.slice;
Reader$1.prototype.uint32 = function read_uint32_setup() {
  var value = 4294967295;
  return function read_uint32() {
    value = (this.buf[this.pos] & 127) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    if ((this.pos += 5) > this.len) {
      this.pos = this.len;
      throw indexOutOfRange(this, 10);
    }
    return value;
  };
}();
Reader$1.prototype.int32 = function read_int32() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function read_sint32() {
  var value = this.uint32();
  return value >>> 1 ^ -(value & 1) | 0;
};
function readLongVarint() {
  var bits = new LongBits(0, 0);
  var i2 = 0;
  if (this.len - this.pos > 4) {
    for (; i2 < 4; ++i2) {
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
    bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
    bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
    if (this.buf[this.pos++] < 128)
      return bits;
    i2 = 0;
  } else {
    for (; i2 < 3; ++i2) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
    bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
    return bits;
  }
  if (this.len - this.pos > 4) {
    for (; i2 < 5; ++i2) {
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
  } else {
    for (; i2 < 5; ++i2) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
  }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function read_bool() {
  return this.uint32() !== 0;
};
function readFixed32_end(buf, end2) {
  return (buf[end2 - 4] | buf[end2 - 3] << 8 | buf[end2 - 2] << 16 | buf[end2 - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function read_fixed32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function read_sfixed32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function read_float() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var value = util$2.float.readFloatLE(this.buf, this.pos);
  this.pos += 4;
  return value;
};
Reader$1.prototype.double = function read_double() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var value = util$2.float.readDoubleLE(this.buf, this.pos);
  this.pos += 8;
  return value;
};
Reader$1.prototype.bytes = function read_bytes() {
  var length2 = this.uint32(), start2 = this.pos, end2 = this.pos + length2;
  if (end2 > this.len)
    throw indexOutOfRange(this, length2);
  this.pos += length2;
  if (Array.isArray(this.buf))
    return this.buf.slice(start2, end2);
  return start2 === end2 ? new this.buf.constructor(0) : this._slice.call(this.buf, start2, end2);
};
Reader$1.prototype.string = function read_string() {
  var bytes = this.bytes();
  return utf8.read(bytes, 0, bytes.length);
};
Reader$1.prototype.skip = function skip2(length2) {
  if (typeof length2 === "number") {
    if (this.pos + length2 > this.len)
      throw indexOutOfRange(this, length2);
    this.pos += length2;
  } else {
    do {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    } while (this.buf[this.pos++] & 128);
  }
  return this;
};
Reader$1.prototype.skipType = function(wireType) {
  switch (wireType) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      while ((wireType = this.uint32() & 7) !== 4) {
        this.skipType(wireType);
      }
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + wireType + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(BufferReader_) {
  BufferReader$1 = BufferReader_;
  Reader$1.create = create$3();
  BufferReader$1._configure();
  var fn = util$2.Long ? "toLong" : "toNumber";
  util$2.merge(Reader$1.prototype, { int64: function read_int64() {
    return readLongVarint.call(this)[fn](false);
  }, uint64: function read_uint64() {
    return readLongVarint.call(this)[fn](true);
  }, sint64: function read_sint64() {
    return readLongVarint.call(this).zzDecode()[fn](false);
  }, fixed64: function read_fixed64() {
    return readFixed64.call(this)[fn](true);
  }, sfixed64: function read_sfixed64() {
    return readFixed64.call(this)[fn](false);
  } });
};
var reader_buffer = BufferReader;
var Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$1 = minimal$1;
function BufferReader(buffer2) {
  Reader.call(this, buffer2);
}
BufferReader._configure = function() {
  if (util$1.Buffer)
    BufferReader.prototype._slice = util$1.Buffer.prototype.slice;
};
BufferReader.prototype.string = function read_string_buffer() {
  var len = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};
BufferReader._configure();
var rpc = {};
var service = Service;
var util = minimal$1;
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
function Service(rpcImpl, requestDelimited, responseDelimited) {
  if (typeof rpcImpl !== "function")
    throw TypeError("rpcImpl must be a function");
  util.EventEmitter.call(this);
  this.rpcImpl = rpcImpl;
  this.requestDelimited = Boolean(requestDelimited);
  this.responseDelimited = Boolean(responseDelimited);
}
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request3, callback) {
  if (!request3)
    throw TypeError("request must be specified");
  var self2 = this;
  if (!callback)
    return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request3);
  if (!self2.rpcImpl) {
    setTimeout(function() {
      callback(Error("already ended"));
    }, 0);
    return void 0;
  }
  try {
    return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request3).finish(), function rpcCallback(err, response) {
      if (err) {
        self2.emit("error", err, method);
        return callback(err);
      }
      if (response === null) {
        self2.end(true);
        return void 0;
      }
      if (!(response instanceof responseCtor)) {
        try {
          response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
        } catch (err2) {
          self2.emit("error", err2, method);
          return callback(err2);
        }
      }
      self2.emit("data", response, method);
      return callback(null, response);
    });
  } catch (err) {
    self2.emit("error", err, method);
    setTimeout(function() {
      callback(err);
    }, 0);
    return void 0;
  }
};
Service.prototype.end = function end(endedByRPC) {
  if (this.rpcImpl) {
    if (!endedByRPC)
      this.rpcImpl(null, null, null);
    this.rpcImpl = null;
    this.emit("end").off();
  }
  return this;
};
(function(exports2) {
  var rpc2 = exports2;
  rpc2.Service = service;
})(rpc);
var roots = {};
(function(exports2) {
  var protobuf = exports2;
  protobuf.build = "minimal";
  protobuf.Writer = writer;
  protobuf.BufferWriter = writer_buffer;
  protobuf.Reader = reader;
  protobuf.BufferReader = reader_buffer;
  protobuf.util = minimal$1;
  protobuf.rpc = rpc;
  protobuf.roots = roots;
  protobuf.configure = configure;
  function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
  }
  configure();
})(indexMinimal);
var minimal = indexMinimal;
var struct$2 = {};
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m2[k];
    } });
  } : function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ListValue = exports2.Value = exports2.Struct_FieldsEntry = exports2.Struct = exports2.nullValueToNumber = exports2.nullValueToJSON = exports2.nullValueFromJSON = exports2.NullValue = exports2.protobufPackage = void 0;
  const long_12 = __importDefault2(umd.exports);
  const _m02 = __importStar2(minimal);
  exports2.protobufPackage = "google.protobuf";
  var NullValue;
  (function(NullValue2) {
    NullValue2["NULL_VALUE"] = "NULL_VALUE";
  })(NullValue = exports2.NullValue || (exports2.NullValue = {}));
  function nullValueFromJSON(object) {
    switch (object) {
      case 0:
      case "NULL_VALUE":
        return NullValue.NULL_VALUE;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum NullValue");
    }
  }
  exports2.nullValueFromJSON = nullValueFromJSON;
  function nullValueToJSON(object) {
    switch (object) {
      case NullValue.NULL_VALUE:
        return "NULL_VALUE";
      default:
        return "UNKNOWN";
    }
  }
  exports2.nullValueToJSON = nullValueToJSON;
  function nullValueToNumber(object) {
    switch (object) {
      case NullValue.NULL_VALUE:
        return 0;
      default:
        return 0;
    }
  }
  exports2.nullValueToNumber = nullValueToNumber;
  function createBaseStruct() {
    return { fields: {} };
  }
  exports2.Struct = { encode(message, writer2 = _m02.Writer.create()) {
    Object.entries(message.fields).forEach(([key, value]) => {
      if (value !== void 0) {
        exports2.Struct_FieldsEntry.encode({ key, value }, writer2.uint32(10).fork()).ldelim();
      }
    });
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStruct();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = exports2.Struct_FieldsEntry.decode(reader2, reader2.uint32());
          if (entry1.value !== void 0) {
            message.fields[entry1.key] = entry1.value;
          }
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { fields: isObject2(object.fields) ? Object.entries(object.fields).reduce((acc, [key, value]) => {
      acc[key] = value;
      return acc;
    }, {}) : {} };
  }, toJSON(message) {
    const obj = {};
    obj.fields = {};
    if (message.fields) {
      Object.entries(message.fields).forEach(([k, v2]) => {
        obj.fields[k] = v2;
      });
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseStruct();
    message.fields = Object.entries((_a2 = object.fields) !== null && _a2 !== void 0 ? _a2 : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = value;
      }
      return acc;
    }, {});
    return message;
  }, wrap(object) {
    const struct2 = createBaseStruct();
    if (object !== void 0) {
      Object.keys(object).forEach((key) => {
        struct2.fields[key] = object[key];
      });
    }
    return struct2;
  }, unwrap(message) {
    const object = {};
    Object.keys(message.fields).forEach((key) => {
      object[key] = message.fields[key];
    });
    return object;
  } };
  function createBaseStruct_FieldsEntry() {
    return { key: "", value: void 0 };
  }
  exports2.Struct_FieldsEntry = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.key !== "") {
      writer2.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      exports2.Value.encode(exports2.Value.wrap(message.value), writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStruct_FieldsEntry();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader2.string();
          break;
        case 2:
          message.value = exports2.Value.unwrap(exports2.Value.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { key: isSet2(object.key) ? String(object.key) : "", value: isSet2(object === null || object === void 0 ? void 0 : object.value) ? object.value : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseStruct_FieldsEntry();
    message.key = (_a2 = object.key) !== null && _a2 !== void 0 ? _a2 : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : void 0;
    return message;
  } };
  function createBaseValue() {
    return { nullValue: void 0, numberValue: void 0, stringValue: void 0, boolValue: void 0, structValue: void 0, listValue: void 0 };
  }
  exports2.Value = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.nullValue !== void 0) {
      writer2.uint32(8).int32(nullValueToNumber(message.nullValue));
    }
    if (message.numberValue !== void 0) {
      writer2.uint32(17).double(message.numberValue);
    }
    if (message.stringValue !== void 0) {
      writer2.uint32(26).string(message.stringValue);
    }
    if (message.boolValue !== void 0) {
      writer2.uint32(32).bool(message.boolValue);
    }
    if (message.structValue !== void 0) {
      exports2.Struct.encode(exports2.Struct.wrap(message.structValue), writer2.uint32(42).fork()).ldelim();
    }
    if (message.listValue !== void 0) {
      exports2.ListValue.encode(exports2.ListValue.wrap(message.listValue), writer2.uint32(50).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseValue();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.nullValue = nullValueFromJSON(reader2.int32());
          break;
        case 2:
          message.numberValue = reader2.double();
          break;
        case 3:
          message.stringValue = reader2.string();
          break;
        case 4:
          message.boolValue = reader2.bool();
          break;
        case 5:
          message.structValue = exports2.Struct.unwrap(exports2.Struct.decode(reader2, reader2.uint32()));
          break;
        case 6:
          message.listValue = exports2.ListValue.unwrap(exports2.ListValue.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { nullValue: isSet2(object.nullValue) ? nullValueFromJSON(object.nullValue) : void 0, numberValue: isSet2(object.numberValue) ? Number(object.numberValue) : void 0, stringValue: isSet2(object.stringValue) ? String(object.stringValue) : void 0, boolValue: isSet2(object.boolValue) ? Boolean(object.boolValue) : void 0, structValue: isObject2(object.structValue) ? object.structValue : void 0, listValue: Array.isArray(object.listValue) ? [...object.listValue] : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.nullValue !== void 0 && (obj.nullValue = message.nullValue !== void 0 ? nullValueToJSON(message.nullValue) : void 0);
    message.numberValue !== void 0 && (obj.numberValue = message.numberValue);
    message.stringValue !== void 0 && (obj.stringValue = message.stringValue);
    message.boolValue !== void 0 && (obj.boolValue = message.boolValue);
    message.structValue !== void 0 && (obj.structValue = message.structValue);
    message.listValue !== void 0 && (obj.listValue = message.listValue);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f;
    const message = createBaseValue();
    message.nullValue = (_a2 = object.nullValue) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.numberValue = (_b = object.numberValue) !== null && _b !== void 0 ? _b : void 0;
    message.stringValue = (_c = object.stringValue) !== null && _c !== void 0 ? _c : void 0;
    message.boolValue = (_d = object.boolValue) !== null && _d !== void 0 ? _d : void 0;
    message.structValue = (_e = object.structValue) !== null && _e !== void 0 ? _e : void 0;
    message.listValue = (_f = object.listValue) !== null && _f !== void 0 ? _f : void 0;
    return message;
  }, wrap(value) {
    const result = createBaseValue();
    if (value === null) {
      result.nullValue = NullValue.NULL_VALUE;
    } else if (typeof value === "boolean") {
      result.boolValue = value;
    } else if (typeof value === "number") {
      result.numberValue = value;
    } else if (typeof value === "string") {
      result.stringValue = value;
    } else if (Array.isArray(value)) {
      result.listValue = value;
    } else if (typeof value === "object") {
      result.structValue = value;
    } else if (typeof value !== "undefined") {
      throw new Error("Unsupported any value type: " + typeof value);
    }
    return result;
  }, unwrap(message) {
    if ((message === null || message === void 0 ? void 0 : message.stringValue) !== void 0) {
      return message.stringValue;
    } else if ((message === null || message === void 0 ? void 0 : message.numberValue) !== void 0) {
      return message.numberValue;
    } else if ((message === null || message === void 0 ? void 0 : message.boolValue) !== void 0) {
      return message.boolValue;
    } else if ((message === null || message === void 0 ? void 0 : message.structValue) !== void 0) {
      return message.structValue;
    } else if ((message === null || message === void 0 ? void 0 : message.listValue) !== void 0) {
      return message.listValue;
    } else if ((message === null || message === void 0 ? void 0 : message.nullValue) !== void 0) {
      return null;
    }
    return void 0;
  } };
  function createBaseListValue() {
    return { values: [] };
  }
  exports2.ListValue = { encode(message, writer2 = _m02.Writer.create()) {
    for (const v2 of message.values) {
      exports2.Value.encode(exports2.Value.wrap(v2), writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseListValue();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.values.push(exports2.Value.unwrap(exports2.Value.decode(reader2, reader2.uint32())));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { values: Array.isArray(object === null || object === void 0 ? void 0 : object.values) ? [...object.values] : [] };
  }, toJSON(message) {
    const obj = {};
    if (message.values) {
      obj.values = message.values.map((e2) => e2);
    } else {
      obj.values = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseListValue();
    message.values = ((_a2 = object.values) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
    return message;
  }, wrap(value) {
    const result = createBaseListValue();
    result.values = value !== null && value !== void 0 ? value : [];
    return result;
  }, unwrap(message) {
    return message.values;
  } };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal !== "undefined")
      return commonjsGlobal;
    throw "Unable to locate global object";
  })();
  if (_m02.util.Long !== long_12.default) {
    _m02.util.Long = long_12.default;
    _m02.configure();
  }
  function isObject2(value) {
    return typeof value === "object" && value !== null;
  }
  function isSet2(value) {
    return value !== null && value !== void 0;
  }
})(struct$2);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m2[k];
    } });
  } : function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.LayoutServiceDefinition = exports2.LayoutServiceClientImpl = exports2.LayerServiceDefinition = exports2.LayerServiceClientImpl = exports2.Event = exports2.LayerEvent = exports2.LayoutEvent = exports2.BatchLayerRequest_BatchItem = exports2.BatchLayerRequest = exports2.BatchDeleteLayerRequest = exports2.DeleteLayerPayload = exports2.UpdateLayerRequest = exports2.GetLayerRequest = exports2.CreateLayerRequest = exports2.ListLayersResponse = exports2.ListLayersRequest = exports2.PartialLayerWithID = exports2.PartialLayer = exports2.LayerAnimation = exports2.DeleteLayoutResponse = exports2.DeleteLayoutRequest = exports2.DeleteLayoutPayload = exports2.UpdateLayoutRequest = exports2.GetLayoutRequest = exports2.CreateLayoutRequest = exports2.ListLayoutsResponse = exports2.ListLayoutsRequest = exports2.PartialLayout = exports2.BatchLayerResponse_BatchLayerItem = exports2.BatchLayerResponse = exports2.DeleteLayerResponse = exports2.DeleteLayerRequest = exports2.Layer = exports2.Layout = exports2.Transition_TransitionStinger = exports2.Transition_TransitionStingerCut = exports2.Transition_TransitionSwipe = exports2.Transition_TransitionCrossfade = exports2.Transition_TransitionFadeToColor = exports2.Transition_TransitionCut = exports2.Transition_TransitionMediaType = exports2.Transition = exports2.transition_TransitionSwipeTypeToNumber = exports2.transition_TransitionSwipeTypeToJSON = exports2.transition_TransitionSwipeTypeFromJSON = exports2.Transition_TransitionSwipeType = exports2.transition_TransitionDirectionToNumber = exports2.transition_TransitionDirectionToJSON = exports2.transition_TransitionDirectionFromJSON = exports2.Transition_TransitionDirection = exports2.eventTypeToNumber = exports2.eventTypeToJSON = exports2.eventTypeFromJSON = exports2.EventType = exports2.eventSubTypeToNumber = exports2.eventSubTypeToJSON = exports2.eventSubTypeFromJSON = exports2.EventSubType = exports2.requestAnimationModeToNumber = exports2.requestAnimationModeToJSON = exports2.requestAnimationModeFromJSON = exports2.RequestAnimationMode = exports2.layoutTypeToNumber = exports2.layoutTypeToJSON = exports2.layoutTypeFromJSON = exports2.LayoutType = exports2.protobufPackage = void 0;
  const long_12 = __importDefault2(umd.exports);
  const _m02 = __importStar2(minimal);
  const struct_1 = struct$2;
  exports2.protobufPackage = "apis.layout.v2";
  var LayoutType;
  (function(LayoutType2) {
    LayoutType2["LAYOUT_TYPE_UNSPECIFIED"] = "LAYOUT_TYPE_UNSPECIFIED";
    LayoutType2["LAYOUT_TYPE_SCENELESS"] = "LAYOUT_TYPE_SCENELESS";
    LayoutType2["LAYOUT_TYPE_SCENE"] = "LAYOUT_TYPE_SCENE";
  })(LayoutType = exports2.LayoutType || (exports2.LayoutType = {}));
  function layoutTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "LAYOUT_TYPE_UNSPECIFIED":
        return LayoutType.LAYOUT_TYPE_UNSPECIFIED;
      case 1:
      case "LAYOUT_TYPE_SCENELESS":
        return LayoutType.LAYOUT_TYPE_SCENELESS;
      case 2:
      case "LAYOUT_TYPE_SCENE":
        return LayoutType.LAYOUT_TYPE_SCENE;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum LayoutType");
    }
  }
  exports2.layoutTypeFromJSON = layoutTypeFromJSON;
  function layoutTypeToJSON(object) {
    switch (object) {
      case LayoutType.LAYOUT_TYPE_UNSPECIFIED:
        return "LAYOUT_TYPE_UNSPECIFIED";
      case LayoutType.LAYOUT_TYPE_SCENELESS:
        return "LAYOUT_TYPE_SCENELESS";
      case LayoutType.LAYOUT_TYPE_SCENE:
        return "LAYOUT_TYPE_SCENE";
      default:
        return "UNKNOWN";
    }
  }
  exports2.layoutTypeToJSON = layoutTypeToJSON;
  function layoutTypeToNumber(object) {
    switch (object) {
      case LayoutType.LAYOUT_TYPE_UNSPECIFIED:
        return 0;
      case LayoutType.LAYOUT_TYPE_SCENELESS:
        return 1;
      case LayoutType.LAYOUT_TYPE_SCENE:
        return 2;
      default:
        return 0;
    }
  }
  exports2.layoutTypeToNumber = layoutTypeToNumber;
  var RequestAnimationMode;
  (function(RequestAnimationMode2) {
    RequestAnimationMode2["REQUEST_ANIMATION_MODE_UNSPECIFIED"] = "REQUEST_ANIMATION_MODE_UNSPECIFIED";
    RequestAnimationMode2["REQUEST_ANIMATION_MODE_PARALLEL"] = "REQUEST_ANIMATION_MODE_PARALLEL";
    RequestAnimationMode2["REQUEST_ANIMATION_MODE_SERIES"] = "REQUEST_ANIMATION_MODE_SERIES";
  })(RequestAnimationMode = exports2.RequestAnimationMode || (exports2.RequestAnimationMode = {}));
  function requestAnimationModeFromJSON(object) {
    switch (object) {
      case 0:
      case "REQUEST_ANIMATION_MODE_UNSPECIFIED":
        return RequestAnimationMode.REQUEST_ANIMATION_MODE_UNSPECIFIED;
      case 1:
      case "REQUEST_ANIMATION_MODE_PARALLEL":
        return RequestAnimationMode.REQUEST_ANIMATION_MODE_PARALLEL;
      case 2:
      case "REQUEST_ANIMATION_MODE_SERIES":
        return RequestAnimationMode.REQUEST_ANIMATION_MODE_SERIES;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum RequestAnimationMode");
    }
  }
  exports2.requestAnimationModeFromJSON = requestAnimationModeFromJSON;
  function requestAnimationModeToJSON(object) {
    switch (object) {
      case RequestAnimationMode.REQUEST_ANIMATION_MODE_UNSPECIFIED:
        return "REQUEST_ANIMATION_MODE_UNSPECIFIED";
      case RequestAnimationMode.REQUEST_ANIMATION_MODE_PARALLEL:
        return "REQUEST_ANIMATION_MODE_PARALLEL";
      case RequestAnimationMode.REQUEST_ANIMATION_MODE_SERIES:
        return "REQUEST_ANIMATION_MODE_SERIES";
      default:
        return "UNKNOWN";
    }
  }
  exports2.requestAnimationModeToJSON = requestAnimationModeToJSON;
  function requestAnimationModeToNumber(object) {
    switch (object) {
      case RequestAnimationMode.REQUEST_ANIMATION_MODE_UNSPECIFIED:
        return 0;
      case RequestAnimationMode.REQUEST_ANIMATION_MODE_PARALLEL:
        return 1;
      case RequestAnimationMode.REQUEST_ANIMATION_MODE_SERIES:
        return 2;
      default:
        return 0;
    }
  }
  exports2.requestAnimationModeToNumber = requestAnimationModeToNumber;
  var EventSubType2;
  (function(EventSubType3) {
    EventSubType3["EVENT_SUB_TYPE_UNSPECIFIED"] = "EVENT_SUB_TYPE_UNSPECIFIED";
    EventSubType3["EVENT_SUB_TYPE_CREATE"] = "EVENT_SUB_TYPE_CREATE";
    EventSubType3["EVENT_SUB_TYPE_UPDATE"] = "EVENT_SUB_TYPE_UPDATE";
    EventSubType3["EVENT_SUB_TYPE_DELETE"] = "EVENT_SUB_TYPE_DELETE";
    EventSubType3["EVENT_SUB_TYPE_BATCH"] = "EVENT_SUB_TYPE_BATCH";
  })(EventSubType2 = exports2.EventSubType || (exports2.EventSubType = {}));
  function eventSubTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "EVENT_SUB_TYPE_UNSPECIFIED":
        return EventSubType2.EVENT_SUB_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_SUB_TYPE_CREATE":
        return EventSubType2.EVENT_SUB_TYPE_CREATE;
      case 2:
      case "EVENT_SUB_TYPE_UPDATE":
        return EventSubType2.EVENT_SUB_TYPE_UPDATE;
      case 3:
      case "EVENT_SUB_TYPE_DELETE":
        return EventSubType2.EVENT_SUB_TYPE_DELETE;
      case 4:
      case "EVENT_SUB_TYPE_BATCH":
        return EventSubType2.EVENT_SUB_TYPE_BATCH;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum EventSubType");
    }
  }
  exports2.eventSubTypeFromJSON = eventSubTypeFromJSON;
  function eventSubTypeToJSON(object) {
    switch (object) {
      case EventSubType2.EVENT_SUB_TYPE_UNSPECIFIED:
        return "EVENT_SUB_TYPE_UNSPECIFIED";
      case EventSubType2.EVENT_SUB_TYPE_CREATE:
        return "EVENT_SUB_TYPE_CREATE";
      case EventSubType2.EVENT_SUB_TYPE_UPDATE:
        return "EVENT_SUB_TYPE_UPDATE";
      case EventSubType2.EVENT_SUB_TYPE_DELETE:
        return "EVENT_SUB_TYPE_DELETE";
      case EventSubType2.EVENT_SUB_TYPE_BATCH:
        return "EVENT_SUB_TYPE_BATCH";
      default:
        return "UNKNOWN";
    }
  }
  exports2.eventSubTypeToJSON = eventSubTypeToJSON;
  function eventSubTypeToNumber(object) {
    switch (object) {
      case EventSubType2.EVENT_SUB_TYPE_UNSPECIFIED:
        return 0;
      case EventSubType2.EVENT_SUB_TYPE_CREATE:
        return 1;
      case EventSubType2.EVENT_SUB_TYPE_UPDATE:
        return 2;
      case EventSubType2.EVENT_SUB_TYPE_DELETE:
        return 3;
      case EventSubType2.EVENT_SUB_TYPE_BATCH:
        return 4;
      default:
        return 0;
    }
  }
  exports2.eventSubTypeToNumber = eventSubTypeToNumber;
  var EventType2;
  (function(EventType3) {
    EventType3["EVENT_TYPE_UNSPECIFIED"] = "EVENT_TYPE_UNSPECIFIED";
    EventType3["EVENT_TYPE_LAYOUT"] = "EVENT_TYPE_LAYOUT";
    EventType3["EVENT_TYPE_LAYER"] = "EVENT_TYPE_LAYER";
  })(EventType2 = exports2.EventType || (exports2.EventType = {}));
  function eventTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "EVENT_TYPE_UNSPECIFIED":
        return EventType2.EVENT_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_TYPE_LAYOUT":
        return EventType2.EVENT_TYPE_LAYOUT;
      case 2:
      case "EVENT_TYPE_LAYER":
        return EventType2.EVENT_TYPE_LAYER;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum EventType");
    }
  }
  exports2.eventTypeFromJSON = eventTypeFromJSON;
  function eventTypeToJSON(object) {
    switch (object) {
      case EventType2.EVENT_TYPE_UNSPECIFIED:
        return "EVENT_TYPE_UNSPECIFIED";
      case EventType2.EVENT_TYPE_LAYOUT:
        return "EVENT_TYPE_LAYOUT";
      case EventType2.EVENT_TYPE_LAYER:
        return "EVENT_TYPE_LAYER";
      default:
        return "UNKNOWN";
    }
  }
  exports2.eventTypeToJSON = eventTypeToJSON;
  function eventTypeToNumber(object) {
    switch (object) {
      case EventType2.EVENT_TYPE_UNSPECIFIED:
        return 0;
      case EventType2.EVENT_TYPE_LAYOUT:
        return 1;
      case EventType2.EVENT_TYPE_LAYER:
        return 2;
      default:
        return 0;
    }
  }
  exports2.eventTypeToNumber = eventTypeToNumber;
  var Transition_TransitionDirection;
  (function(Transition_TransitionDirection2) {
    Transition_TransitionDirection2["TRANSITION_DIRECTION_UNSPECIFIED"] = "TRANSITION_DIRECTION_UNSPECIFIED";
    Transition_TransitionDirection2["TRANSITION_DIRECTION_LEFT"] = "TRANSITION_DIRECTION_LEFT";
    Transition_TransitionDirection2["TRANSITION_DIRECTION_RIGHT"] = "TRANSITION_DIRECTION_RIGHT";
    Transition_TransitionDirection2["TRANSITION_DIRECTION_UP"] = "TRANSITION_DIRECTION_UP";
    Transition_TransitionDirection2["TRANSITION_DIRECTION_DOWN"] = "TRANSITION_DIRECTION_DOWN";
  })(Transition_TransitionDirection = exports2.Transition_TransitionDirection || (exports2.Transition_TransitionDirection = {}));
  function transition_TransitionDirectionFromJSON(object) {
    switch (object) {
      case 0:
      case "TRANSITION_DIRECTION_UNSPECIFIED":
        return Transition_TransitionDirection.TRANSITION_DIRECTION_UNSPECIFIED;
      case 1:
      case "TRANSITION_DIRECTION_LEFT":
        return Transition_TransitionDirection.TRANSITION_DIRECTION_LEFT;
      case 2:
      case "TRANSITION_DIRECTION_RIGHT":
        return Transition_TransitionDirection.TRANSITION_DIRECTION_RIGHT;
      case 3:
      case "TRANSITION_DIRECTION_UP":
        return Transition_TransitionDirection.TRANSITION_DIRECTION_UP;
      case 4:
      case "TRANSITION_DIRECTION_DOWN":
        return Transition_TransitionDirection.TRANSITION_DIRECTION_DOWN;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum Transition_TransitionDirection");
    }
  }
  exports2.transition_TransitionDirectionFromJSON = transition_TransitionDirectionFromJSON;
  function transition_TransitionDirectionToJSON(object) {
    switch (object) {
      case Transition_TransitionDirection.TRANSITION_DIRECTION_UNSPECIFIED:
        return "TRANSITION_DIRECTION_UNSPECIFIED";
      case Transition_TransitionDirection.TRANSITION_DIRECTION_LEFT:
        return "TRANSITION_DIRECTION_LEFT";
      case Transition_TransitionDirection.TRANSITION_DIRECTION_RIGHT:
        return "TRANSITION_DIRECTION_RIGHT";
      case Transition_TransitionDirection.TRANSITION_DIRECTION_UP:
        return "TRANSITION_DIRECTION_UP";
      case Transition_TransitionDirection.TRANSITION_DIRECTION_DOWN:
        return "TRANSITION_DIRECTION_DOWN";
      default:
        return "UNKNOWN";
    }
  }
  exports2.transition_TransitionDirectionToJSON = transition_TransitionDirectionToJSON;
  function transition_TransitionDirectionToNumber(object) {
    switch (object) {
      case Transition_TransitionDirection.TRANSITION_DIRECTION_UNSPECIFIED:
        return 0;
      case Transition_TransitionDirection.TRANSITION_DIRECTION_LEFT:
        return 1;
      case Transition_TransitionDirection.TRANSITION_DIRECTION_RIGHT:
        return 2;
      case Transition_TransitionDirection.TRANSITION_DIRECTION_UP:
        return 3;
      case Transition_TransitionDirection.TRANSITION_DIRECTION_DOWN:
        return 4;
      default:
        return 0;
    }
  }
  exports2.transition_TransitionDirectionToNumber = transition_TransitionDirectionToNumber;
  var Transition_TransitionSwipeType;
  (function(Transition_TransitionSwipeType2) {
    Transition_TransitionSwipeType2["TRANSITION_SWIPE_TYPE_UNSPECIFIED"] = "TRANSITION_SWIPE_TYPE_UNSPECIFIED";
    Transition_TransitionSwipeType2["TRANSITION_SWIPE_TYPE_COMBINED"] = "TRANSITION_SWIPE_TYPE_COMBINED";
    Transition_TransitionSwipeType2["TRANSITION_SWIPE_TYPE_SOURCE"] = "TRANSITION_SWIPE_TYPE_SOURCE";
    Transition_TransitionSwipeType2["TRANSITION_SWIPE_TYPE_DESTINATION"] = "TRANSITION_SWIPE_TYPE_DESTINATION";
  })(Transition_TransitionSwipeType = exports2.Transition_TransitionSwipeType || (exports2.Transition_TransitionSwipeType = {}));
  function transition_TransitionSwipeTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "TRANSITION_SWIPE_TYPE_UNSPECIFIED":
        return Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_UNSPECIFIED;
      case 1:
      case "TRANSITION_SWIPE_TYPE_COMBINED":
        return Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_COMBINED;
      case 2:
      case "TRANSITION_SWIPE_TYPE_SOURCE":
        return Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_SOURCE;
      case 3:
      case "TRANSITION_SWIPE_TYPE_DESTINATION":
        return Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_DESTINATION;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum Transition_TransitionSwipeType");
    }
  }
  exports2.transition_TransitionSwipeTypeFromJSON = transition_TransitionSwipeTypeFromJSON;
  function transition_TransitionSwipeTypeToJSON(object) {
    switch (object) {
      case Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_UNSPECIFIED:
        return "TRANSITION_SWIPE_TYPE_UNSPECIFIED";
      case Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_COMBINED:
        return "TRANSITION_SWIPE_TYPE_COMBINED";
      case Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_SOURCE:
        return "TRANSITION_SWIPE_TYPE_SOURCE";
      case Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_DESTINATION:
        return "TRANSITION_SWIPE_TYPE_DESTINATION";
      default:
        return "UNKNOWN";
    }
  }
  exports2.transition_TransitionSwipeTypeToJSON = transition_TransitionSwipeTypeToJSON;
  function transition_TransitionSwipeTypeToNumber(object) {
    switch (object) {
      case Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_UNSPECIFIED:
        return 0;
      case Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_COMBINED:
        return 1;
      case Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_SOURCE:
        return 2;
      case Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_DESTINATION:
        return 3;
      default:
        return 0;
    }
  }
  exports2.transition_TransitionSwipeTypeToNumber = transition_TransitionSwipeTypeToNumber;
  function createBaseTransition() {
    return { fromLayoutIds: [], cut: void 0, crossfade: void 0, fadeToColor: void 0, swipe: void 0, stinger: void 0 };
  }
  exports2.Transition = { encode(message, writer2 = _m02.Writer.create()) {
    for (const v2 of message.fromLayoutIds) {
      writer2.uint32(10).string(v2);
    }
    if (message.cut !== void 0) {
      exports2.Transition_TransitionCut.encode(message.cut, writer2.uint32(82).fork()).ldelim();
    }
    if (message.crossfade !== void 0) {
      exports2.Transition_TransitionCrossfade.encode(message.crossfade, writer2.uint32(90).fork()).ldelim();
    }
    if (message.fadeToColor !== void 0) {
      exports2.Transition_TransitionFadeToColor.encode(message.fadeToColor, writer2.uint32(98).fork()).ldelim();
    }
    if (message.swipe !== void 0) {
      exports2.Transition_TransitionSwipe.encode(message.swipe, writer2.uint32(106).fork()).ldelim();
    }
    if (message.stinger !== void 0) {
      exports2.Transition_TransitionStinger.encode(message.stinger, writer2.uint32(114).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTransition();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fromLayoutIds.push(reader2.string());
          break;
        case 10:
          message.cut = exports2.Transition_TransitionCut.decode(reader2, reader2.uint32());
          break;
        case 11:
          message.crossfade = exports2.Transition_TransitionCrossfade.decode(reader2, reader2.uint32());
          break;
        case 12:
          message.fadeToColor = exports2.Transition_TransitionFadeToColor.decode(reader2, reader2.uint32());
          break;
        case 13:
          message.swipe = exports2.Transition_TransitionSwipe.decode(reader2, reader2.uint32());
          break;
        case 14:
          message.stinger = exports2.Transition_TransitionStinger.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { fromLayoutIds: Array.isArray(object === null || object === void 0 ? void 0 : object.fromLayoutIds) ? object.fromLayoutIds.map((e2) => String(e2)) : [], cut: isSet2(object.cut) ? exports2.Transition_TransitionCut.fromJSON(object.cut) : void 0, crossfade: isSet2(object.crossfade) ? exports2.Transition_TransitionCrossfade.fromJSON(object.crossfade) : void 0, fadeToColor: isSet2(object.fadeToColor) ? exports2.Transition_TransitionFadeToColor.fromJSON(object.fadeToColor) : void 0, swipe: isSet2(object.swipe) ? exports2.Transition_TransitionSwipe.fromJSON(object.swipe) : void 0, stinger: isSet2(object.stinger) ? exports2.Transition_TransitionStinger.fromJSON(object.stinger) : void 0 };
  }, toJSON(message) {
    const obj = {};
    if (message.fromLayoutIds) {
      obj.fromLayoutIds = message.fromLayoutIds.map((e2) => e2);
    } else {
      obj.fromLayoutIds = [];
    }
    message.cut !== void 0 && (obj.cut = message.cut ? exports2.Transition_TransitionCut.toJSON(message.cut) : void 0);
    message.crossfade !== void 0 && (obj.crossfade = message.crossfade ? exports2.Transition_TransitionCrossfade.toJSON(message.crossfade) : void 0);
    message.fadeToColor !== void 0 && (obj.fadeToColor = message.fadeToColor ? exports2.Transition_TransitionFadeToColor.toJSON(message.fadeToColor) : void 0);
    message.swipe !== void 0 && (obj.swipe = message.swipe ? exports2.Transition_TransitionSwipe.toJSON(message.swipe) : void 0);
    message.stinger !== void 0 && (obj.stinger = message.stinger ? exports2.Transition_TransitionStinger.toJSON(message.stinger) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseTransition();
    message.fromLayoutIds = ((_a2 = object.fromLayoutIds) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
    message.cut = object.cut !== void 0 && object.cut !== null ? exports2.Transition_TransitionCut.fromPartial(object.cut) : void 0;
    message.crossfade = object.crossfade !== void 0 && object.crossfade !== null ? exports2.Transition_TransitionCrossfade.fromPartial(object.crossfade) : void 0;
    message.fadeToColor = object.fadeToColor !== void 0 && object.fadeToColor !== null ? exports2.Transition_TransitionFadeToColor.fromPartial(object.fadeToColor) : void 0;
    message.swipe = object.swipe !== void 0 && object.swipe !== null ? exports2.Transition_TransitionSwipe.fromPartial(object.swipe) : void 0;
    message.stinger = object.stinger !== void 0 && object.stinger !== null ? exports2.Transition_TransitionStinger.fromPartial(object.stinger) : void 0;
    return message;
  } };
  function createBaseTransition_TransitionMediaType() {
    return { url: "", volume: 0 };
  }
  exports2.Transition_TransitionMediaType = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.url !== "") {
      writer2.uint32(10).string(message.url);
    }
    if (message.volume !== 0) {
      writer2.uint32(17).double(message.volume);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTransition_TransitionMediaType();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.url = reader2.string();
          break;
        case 2:
          message.volume = reader2.double();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { url: isSet2(object.url) ? String(object.url) : "", volume: isSet2(object.volume) ? Number(object.volume) : 0 };
  }, toJSON(message) {
    const obj = {};
    message.url !== void 0 && (obj.url = message.url);
    message.volume !== void 0 && (obj.volume = message.volume);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseTransition_TransitionMediaType();
    message.url = (_a2 = object.url) !== null && _a2 !== void 0 ? _a2 : "";
    message.volume = (_b = object.volume) !== null && _b !== void 0 ? _b : 0;
    return message;
  } };
  function createBaseTransition_TransitionCut() {
    return {};
  }
  exports2.Transition_TransitionCut = { encode(_, writer2 = _m02.Writer.create()) {
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTransition_TransitionCut();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(_) {
    return {};
  }, toJSON(_) {
    const obj = {};
    return obj;
  }, fromPartial(_) {
    const message = createBaseTransition_TransitionCut();
    return message;
  } };
  function createBaseTransition_TransitionFadeToColor() {
    return { durationMs: 0, backgroundColor: "" };
  }
  exports2.Transition_TransitionFadeToColor = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.durationMs !== 0) {
      writer2.uint32(8).int32(message.durationMs);
    }
    if (message.backgroundColor !== "") {
      writer2.uint32(18).string(message.backgroundColor);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTransition_TransitionFadeToColor();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.durationMs = reader2.int32();
          break;
        case 2:
          message.backgroundColor = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { durationMs: isSet2(object.durationMs) ? Number(object.durationMs) : 0, backgroundColor: isSet2(object.backgroundColor) ? String(object.backgroundColor) : "" };
  }, toJSON(message) {
    const obj = {};
    message.durationMs !== void 0 && (obj.durationMs = Math.round(message.durationMs));
    message.backgroundColor !== void 0 && (obj.backgroundColor = message.backgroundColor);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseTransition_TransitionFadeToColor();
    message.durationMs = (_a2 = object.durationMs) !== null && _a2 !== void 0 ? _a2 : 0;
    message.backgroundColor = (_b = object.backgroundColor) !== null && _b !== void 0 ? _b : "";
    return message;
  } };
  function createBaseTransition_TransitionCrossfade() {
    return { durationMs: 0 };
  }
  exports2.Transition_TransitionCrossfade = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.durationMs !== 0) {
      writer2.uint32(8).int32(message.durationMs);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTransition_TransitionCrossfade();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.durationMs = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { durationMs: isSet2(object.durationMs) ? Number(object.durationMs) : 0 };
  }, toJSON(message) {
    const obj = {};
    message.durationMs !== void 0 && (obj.durationMs = Math.round(message.durationMs));
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseTransition_TransitionCrossfade();
    message.durationMs = (_a2 = object.durationMs) !== null && _a2 !== void 0 ? _a2 : 0;
    return message;
  } };
  function createBaseTransition_TransitionSwipe() {
    return { durationMs: 0, direction: Transition_TransitionDirection.TRANSITION_DIRECTION_UNSPECIFIED, combinedAnimation: Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_UNSPECIFIED };
  }
  exports2.Transition_TransitionSwipe = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.durationMs !== 0) {
      writer2.uint32(8).int32(message.durationMs);
    }
    if (message.direction !== Transition_TransitionDirection.TRANSITION_DIRECTION_UNSPECIFIED) {
      writer2.uint32(16).int32(transition_TransitionDirectionToNumber(message.direction));
    }
    if (message.combinedAnimation !== Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_UNSPECIFIED) {
      writer2.uint32(24).int32(transition_TransitionSwipeTypeToNumber(message.combinedAnimation));
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTransition_TransitionSwipe();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.durationMs = reader2.int32();
          break;
        case 2:
          message.direction = transition_TransitionDirectionFromJSON(reader2.int32());
          break;
        case 3:
          message.combinedAnimation = transition_TransitionSwipeTypeFromJSON(reader2.int32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { durationMs: isSet2(object.durationMs) ? Number(object.durationMs) : 0, direction: isSet2(object.direction) ? transition_TransitionDirectionFromJSON(object.direction) : Transition_TransitionDirection.TRANSITION_DIRECTION_UNSPECIFIED, combinedAnimation: isSet2(object.combinedAnimation) ? transition_TransitionSwipeTypeFromJSON(object.combinedAnimation) : Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_UNSPECIFIED };
  }, toJSON(message) {
    const obj = {};
    message.durationMs !== void 0 && (obj.durationMs = Math.round(message.durationMs));
    message.direction !== void 0 && (obj.direction = transition_TransitionDirectionToJSON(message.direction));
    message.combinedAnimation !== void 0 && (obj.combinedAnimation = transition_TransitionSwipeTypeToJSON(message.combinedAnimation));
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseTransition_TransitionSwipe();
    message.durationMs = (_a2 = object.durationMs) !== null && _a2 !== void 0 ? _a2 : 0;
    message.direction = (_b = object.direction) !== null && _b !== void 0 ? _b : Transition_TransitionDirection.TRANSITION_DIRECTION_UNSPECIFIED;
    message.combinedAnimation = (_c = object.combinedAnimation) !== null && _c !== void 0 ? _c : Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_UNSPECIFIED;
    return message;
  } };
  function createBaseTransition_TransitionStingerCut() {
    return { cutPointMs: 0, media: void 0 };
  }
  exports2.Transition_TransitionStingerCut = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.cutPointMs !== 0) {
      writer2.uint32(8).int32(message.cutPointMs);
    }
    if (message.media !== void 0) {
      exports2.Transition_TransitionMediaType.encode(message.media, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTransition_TransitionStingerCut();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.cutPointMs = reader2.int32();
          break;
        case 2:
          message.media = exports2.Transition_TransitionMediaType.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { cutPointMs: isSet2(object.cutPointMs) ? Number(object.cutPointMs) : 0, media: isSet2(object.media) ? exports2.Transition_TransitionMediaType.fromJSON(object.media) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.cutPointMs !== void 0 && (obj.cutPointMs = Math.round(message.cutPointMs));
    message.media !== void 0 && (obj.media = message.media ? exports2.Transition_TransitionMediaType.toJSON(message.media) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseTransition_TransitionStingerCut();
    message.cutPointMs = (_a2 = object.cutPointMs) !== null && _a2 !== void 0 ? _a2 : 0;
    message.media = object.media !== void 0 && object.media !== null ? exports2.Transition_TransitionMediaType.fromPartial(object.media) : void 0;
    return message;
  } };
  function createBaseTransition_TransitionStinger() {
    return { cut: void 0 };
  }
  exports2.Transition_TransitionStinger = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.cut !== void 0) {
      exports2.Transition_TransitionStingerCut.encode(message.cut, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTransition_TransitionStinger();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.cut = exports2.Transition_TransitionStingerCut.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { cut: isSet2(object.cut) ? exports2.Transition_TransitionStingerCut.fromJSON(object.cut) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.cut !== void 0 && (obj.cut = message.cut ? exports2.Transition_TransitionStingerCut.toJSON(message.cut) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseTransition_TransitionStinger();
    message.cut = object.cut !== void 0 && object.cut !== null ? exports2.Transition_TransitionStingerCut.fromPartial(object.cut) : void 0;
    return message;
  } };
  function createBaseLayout() {
    return { id: "", width: 0, height: 0, metadata: void 0, projectId: void 0, collectionId: void 0, type: void 0, transitions: [], requestMetadata: void 0 };
  }
  exports2.Layout = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.id !== "") {
      writer2.uint32(10).string(message.id);
    }
    if (message.width !== 0) {
      writer2.uint32(16).int32(message.width);
    }
    if (message.height !== 0) {
      writer2.uint32(24).int32(message.height);
    }
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(50).fork()).ldelim();
    }
    if (message.projectId !== void 0) {
      writer2.uint32(58).string(message.projectId);
    }
    if (message.collectionId !== void 0) {
      writer2.uint32(66).string(message.collectionId);
    }
    if (message.type !== void 0) {
      writer2.uint32(72).int32(layoutTypeToNumber(message.type));
    }
    for (const v2 of message.transitions) {
      exports2.Transition.encode(v2, writer2.uint32(82).fork()).ldelim();
    }
    if (message.requestMetadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(810).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseLayout();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader2.string();
          break;
        case 2:
          message.width = reader2.int32();
          break;
        case 3:
          message.height = reader2.int32();
          break;
        case 6:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 7:
          message.projectId = reader2.string();
          break;
        case 8:
          message.collectionId = reader2.string();
          break;
        case 9:
          message.type = layoutTypeFromJSON(reader2.int32());
          break;
        case 10:
          message.transitions.push(exports2.Transition.decode(reader2, reader2.uint32()));
          break;
        case 101:
          message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { id: isSet2(object.id) ? String(object.id) : "", width: isSet2(object.width) ? Number(object.width) : 0, height: isSet2(object.height) ? Number(object.height) : 0, metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0, projectId: isSet2(object.projectId) ? String(object.projectId) : void 0, collectionId: isSet2(object.collectionId) ? String(object.collectionId) : void 0, type: isSet2(object.type) ? layoutTypeFromJSON(object.type) : void 0, transitions: Array.isArray(object === null || object === void 0 ? void 0 : object.transitions) ? object.transitions.map((e2) => exports2.Transition.fromJSON(e2)) : [], requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.width !== void 0 && (obj.width = Math.round(message.width));
    message.height !== void 0 && (obj.height = Math.round(message.height));
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.type !== void 0 && (obj.type = message.type !== void 0 ? layoutTypeToJSON(message.type) : void 0);
    if (message.transitions) {
      obj.transitions = message.transitions.map((e2) => e2 ? exports2.Transition.toJSON(e2) : void 0);
    } else {
      obj.transitions = [];
    }
    message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
    const message = createBaseLayout();
    message.id = (_a2 = object.id) !== null && _a2 !== void 0 ? _a2 : "";
    message.width = (_b = object.width) !== null && _b !== void 0 ? _b : 0;
    message.height = (_c = object.height) !== null && _c !== void 0 ? _c : 0;
    message.metadata = (_d = object.metadata) !== null && _d !== void 0 ? _d : void 0;
    message.projectId = (_e = object.projectId) !== null && _e !== void 0 ? _e : void 0;
    message.collectionId = (_f = object.collectionId) !== null && _f !== void 0 ? _f : void 0;
    message.type = (_g = object.type) !== null && _g !== void 0 ? _g : void 0;
    message.transitions = ((_h = object.transitions) === null || _h === void 0 ? void 0 : _h.map((e2) => exports2.Transition.fromPartial(e2))) || [];
    message.requestMetadata = (_j = object.requestMetadata) !== null && _j !== void 0 ? _j : void 0;
    return message;
  } };
  function createBaseLayer() {
    return { type: "", data: void 0, x: void 0, y: void 0, width: void 0, height: void 0, rotation: 0, opacity: 0, scale: 0, hidden: false, children: void 0, metadata: void 0, id: "", layoutId: "", requestMetadata: void 0, requestAnimation: [] };
  }
  exports2.Layer = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.type !== "") {
      writer2.uint32(10).string(message.type);
    }
    if (message.data !== void 0) {
      struct_1.Struct.encode(struct_1.Struct.wrap(message.data), writer2.uint32(18).fork()).ldelim();
    }
    if (message.x !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.x), writer2.uint32(26).fork()).ldelim();
    }
    if (message.y !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.y), writer2.uint32(34).fork()).ldelim();
    }
    if (message.width !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.width), writer2.uint32(42).fork()).ldelim();
    }
    if (message.height !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.height), writer2.uint32(50).fork()).ldelim();
    }
    if (message.rotation !== 0) {
      writer2.uint32(57).double(message.rotation);
    }
    if (message.opacity !== 0) {
      writer2.uint32(65).double(message.opacity);
    }
    if (message.scale !== 0) {
      writer2.uint32(73).double(message.scale);
    }
    if (message.hidden === true) {
      writer2.uint32(80).bool(message.hidden);
    }
    if (message.children !== void 0) {
      struct_1.ListValue.encode(struct_1.ListValue.wrap(message.children), writer2.uint32(98).fork()).ldelim();
    }
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(114).fork()).ldelim();
    }
    if (message.id !== "") {
      writer2.uint32(802).string(message.id);
    }
    if (message.layoutId !== "") {
      writer2.uint32(818).string(message.layoutId);
    }
    if (message.requestMetadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(810).fork()).ldelim();
    }
    for (const v2 of message.requestAnimation) {
      exports2.LayerAnimation.encode(v2, writer2.uint32(826).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseLayer();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader2.string();
          break;
        case 2:
          message.data = struct_1.Struct.unwrap(struct_1.Struct.decode(reader2, reader2.uint32()));
          break;
        case 3:
          message.x = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 4:
          message.y = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 5:
          message.width = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 6:
          message.height = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 7:
          message.rotation = reader2.double();
          break;
        case 8:
          message.opacity = reader2.double();
          break;
        case 9:
          message.scale = reader2.double();
          break;
        case 10:
          message.hidden = reader2.bool();
          break;
        case 12:
          message.children = struct_1.ListValue.unwrap(struct_1.ListValue.decode(reader2, reader2.uint32()));
          break;
        case 14:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 100:
          message.id = reader2.string();
          break;
        case 102:
          message.layoutId = reader2.string();
          break;
        case 101:
          message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 103:
          message.requestAnimation.push(exports2.LayerAnimation.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { type: isSet2(object.type) ? String(object.type) : "", data: isObject2(object.data) ? object.data : void 0, x: isSet2(object === null || object === void 0 ? void 0 : object.x) ? object.x : void 0, y: isSet2(object === null || object === void 0 ? void 0 : object.y) ? object.y : void 0, width: isSet2(object === null || object === void 0 ? void 0 : object.width) ? object.width : void 0, height: isSet2(object === null || object === void 0 ? void 0 : object.height) ? object.height : void 0, rotation: isSet2(object.rotation) ? Number(object.rotation) : 0, opacity: isSet2(object.opacity) ? Number(object.opacity) : 0, scale: isSet2(object.scale) ? Number(object.scale) : 0, hidden: isSet2(object.hidden) ? Boolean(object.hidden) : false, children: Array.isArray(object.children) ? [...object.children] : void 0, metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0, id: isSet2(object.id) ? String(object.id) : "", layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "", requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0, requestAnimation: Array.isArray(object === null || object === void 0 ? void 0 : object.requestAnimation) ? object.requestAnimation.map((e2) => exports2.LayerAnimation.fromJSON(e2)) : [] };
  }, toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = message.type);
    message.data !== void 0 && (obj.data = message.data);
    message.x !== void 0 && (obj.x = message.x);
    message.y !== void 0 && (obj.y = message.y);
    message.width !== void 0 && (obj.width = message.width);
    message.height !== void 0 && (obj.height = message.height);
    message.rotation !== void 0 && (obj.rotation = message.rotation);
    message.opacity !== void 0 && (obj.opacity = message.opacity);
    message.scale !== void 0 && (obj.scale = message.scale);
    message.hidden !== void 0 && (obj.hidden = message.hidden);
    message.children !== void 0 && (obj.children = message.children);
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.id !== void 0 && (obj.id = message.id);
    message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
    message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
    if (message.requestAnimation) {
      obj.requestAnimation = message.requestAnimation.map((e2) => e2 ? exports2.LayerAnimation.toJSON(e2) : void 0);
    } else {
      obj.requestAnimation = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    const message = createBaseLayer();
    message.type = (_a2 = object.type) !== null && _a2 !== void 0 ? _a2 : "";
    message.data = (_b = object.data) !== null && _b !== void 0 ? _b : void 0;
    message.x = (_c = object.x) !== null && _c !== void 0 ? _c : void 0;
    message.y = (_d = object.y) !== null && _d !== void 0 ? _d : void 0;
    message.width = (_e = object.width) !== null && _e !== void 0 ? _e : void 0;
    message.height = (_f = object.height) !== null && _f !== void 0 ? _f : void 0;
    message.rotation = (_g = object.rotation) !== null && _g !== void 0 ? _g : 0;
    message.opacity = (_h = object.opacity) !== null && _h !== void 0 ? _h : 0;
    message.scale = (_j = object.scale) !== null && _j !== void 0 ? _j : 0;
    message.hidden = (_k = object.hidden) !== null && _k !== void 0 ? _k : false;
    message.children = (_l = object.children) !== null && _l !== void 0 ? _l : void 0;
    message.metadata = (_m = object.metadata) !== null && _m !== void 0 ? _m : void 0;
    message.id = (_o = object.id) !== null && _o !== void 0 ? _o : "";
    message.layoutId = (_p = object.layoutId) !== null && _p !== void 0 ? _p : "";
    message.requestMetadata = (_q = object.requestMetadata) !== null && _q !== void 0 ? _q : void 0;
    message.requestAnimation = ((_r = object.requestAnimation) === null || _r === void 0 ? void 0 : _r.map((e2) => exports2.LayerAnimation.fromPartial(e2))) || [];
    return message;
  } };
  function createBaseDeleteLayerRequest() {
    return { layoutId: "", layerId: "", payload: void 0 };
  }
  exports2.DeleteLayerRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.layoutId !== "") {
      writer2.uint32(10).string(message.layoutId);
    }
    if (message.layerId !== "") {
      writer2.uint32(18).string(message.layerId);
    }
    if (message.payload !== void 0) {
      exports2.DeleteLayerPayload.encode(message.payload, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDeleteLayerRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.layoutId = reader2.string();
          break;
        case 2:
          message.layerId = reader2.string();
          break;
        case 3:
          message.payload = exports2.DeleteLayerPayload.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "", layerId: isSet2(object.layerId) ? String(object.layerId) : "", payload: isSet2(object.payload) ? exports2.DeleteLayerPayload.fromJSON(object.payload) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
    message.layerId !== void 0 && (obj.layerId = message.layerId);
    message.payload !== void 0 && (obj.payload = message.payload ? exports2.DeleteLayerPayload.toJSON(message.payload) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseDeleteLayerRequest();
    message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
    message.layerId = (_b = object.layerId) !== null && _b !== void 0 ? _b : "";
    message.payload = object.payload !== void 0 && object.payload !== null ? exports2.DeleteLayerPayload.fromPartial(object.payload) : void 0;
    return message;
  } };
  function createBaseDeleteLayerResponse() {
    return { id: "", layoutId: "", requestMetadata: void 0 };
  }
  exports2.DeleteLayerResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.id !== "") {
      writer2.uint32(10).string(message.id);
    }
    if (message.layoutId !== "") {
      writer2.uint32(18).string(message.layoutId);
    }
    if (message.requestMetadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDeleteLayerResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader2.string();
          break;
        case 2:
          message.layoutId = reader2.string();
          break;
        case 100:
          message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { id: isSet2(object.id) ? String(object.id) : "", layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "", requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
    message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseDeleteLayerResponse();
    message.id = (_a2 = object.id) !== null && _a2 !== void 0 ? _a2 : "";
    message.layoutId = (_b = object.layoutId) !== null && _b !== void 0 ? _b : "";
    message.requestMetadata = (_c = object.requestMetadata) !== null && _c !== void 0 ? _c : void 0;
    return message;
  } };
  function createBaseBatchLayerResponse() {
    return { layers: [], layoutId: "", requestMetadata: void 0, requestAnimationMode: RequestAnimationMode.REQUEST_ANIMATION_MODE_UNSPECIFIED };
  }
  exports2.BatchLayerResponse = { encode(message, writer2 = _m02.Writer.create()) {
    for (const v2 of message.layers) {
      exports2.BatchLayerResponse_BatchLayerItem.encode(v2, writer2.uint32(18).fork()).ldelim();
    }
    if (message.layoutId !== "") {
      writer2.uint32(26).string(message.layoutId);
    }
    if (message.requestMetadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
    }
    if (message.requestAnimationMode !== RequestAnimationMode.REQUEST_ANIMATION_MODE_UNSPECIFIED) {
      writer2.uint32(808).int32(requestAnimationModeToNumber(message.requestAnimationMode));
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseBatchLayerResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 2:
          message.layers.push(exports2.BatchLayerResponse_BatchLayerItem.decode(reader2, reader2.uint32()));
          break;
        case 3:
          message.layoutId = reader2.string();
          break;
        case 100:
          message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 101:
          message.requestAnimationMode = requestAnimationModeFromJSON(reader2.int32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e2) => exports2.BatchLayerResponse_BatchLayerItem.fromJSON(e2)) : [], layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "", requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0, requestAnimationMode: isSet2(object.requestAnimationMode) ? requestAnimationModeFromJSON(object.requestAnimationMode) : RequestAnimationMode.REQUEST_ANIMATION_MODE_UNSPECIFIED };
  }, toJSON(message) {
    const obj = {};
    if (message.layers) {
      obj.layers = message.layers.map((e2) => e2 ? exports2.BatchLayerResponse_BatchLayerItem.toJSON(e2) : void 0);
    } else {
      obj.layers = [];
    }
    message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
    message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
    message.requestAnimationMode !== void 0 && (obj.requestAnimationMode = requestAnimationModeToJSON(message.requestAnimationMode));
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseBatchLayerResponse();
    message.layers = ((_a2 = object.layers) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports2.BatchLayerResponse_BatchLayerItem.fromPartial(e2))) || [];
    message.layoutId = (_b = object.layoutId) !== null && _b !== void 0 ? _b : "";
    message.requestMetadata = (_c = object.requestMetadata) !== null && _c !== void 0 ? _c : void 0;
    message.requestAnimationMode = (_d = object.requestAnimationMode) !== null && _d !== void 0 ? _d : RequestAnimationMode.REQUEST_ANIMATION_MODE_UNSPECIFIED;
    return message;
  } };
  function createBaseBatchLayerResponse_BatchLayerItem() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  exports2.BatchLayerResponse_BatchLayerItem = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.create !== void 0) {
      exports2.Layer.encode(message.create, writer2.uint32(10).fork()).ldelim();
    }
    if (message.update !== void 0) {
      exports2.Layer.encode(message.update, writer2.uint32(18).fork()).ldelim();
    }
    if (message.delete !== void 0) {
      exports2.DeleteLayerResponse.encode(message.delete, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseBatchLayerResponse_BatchLayerItem();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.create = exports2.Layer.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.update = exports2.Layer.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.delete = exports2.DeleteLayerResponse.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { create: isSet2(object.create) ? exports2.Layer.fromJSON(object.create) : void 0, update: isSet2(object.update) ? exports2.Layer.fromJSON(object.update) : void 0, delete: isSet2(object.delete) ? exports2.DeleteLayerResponse.fromJSON(object.delete) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.create !== void 0 && (obj.create = message.create ? exports2.Layer.toJSON(message.create) : void 0);
    message.update !== void 0 && (obj.update = message.update ? exports2.Layer.toJSON(message.update) : void 0);
    message.delete !== void 0 && (obj.delete = message.delete ? exports2.DeleteLayerResponse.toJSON(message.delete) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseBatchLayerResponse_BatchLayerItem();
    message.create = object.create !== void 0 && object.create !== null ? exports2.Layer.fromPartial(object.create) : void 0;
    message.update = object.update !== void 0 && object.update !== null ? exports2.Layer.fromPartial(object.update) : void 0;
    message.delete = object.delete !== void 0 && object.delete !== null ? exports2.DeleteLayerResponse.fromPartial(object.delete) : void 0;
    return message;
  } };
  function createBasePartialLayout() {
    return { width: void 0, height: void 0, metadata: void 0, projectId: void 0, collectionId: void 0, type: void 0, transitions: [], requestMetadata: void 0 };
  }
  exports2.PartialLayout = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.width !== void 0) {
      writer2.uint32(16).int32(message.width);
    }
    if (message.height !== void 0) {
      writer2.uint32(24).int32(message.height);
    }
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(50).fork()).ldelim();
    }
    if (message.projectId !== void 0) {
      writer2.uint32(58).string(message.projectId);
    }
    if (message.collectionId !== void 0) {
      writer2.uint32(66).string(message.collectionId);
    }
    if (message.type !== void 0) {
      writer2.uint32(72).int32(layoutTypeToNumber(message.type));
    }
    for (const v2 of message.transitions) {
      exports2.Transition.encode(v2, writer2.uint32(82).fork()).ldelim();
    }
    if (message.requestMetadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(810).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBasePartialLayout();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 2:
          message.width = reader2.int32();
          break;
        case 3:
          message.height = reader2.int32();
          break;
        case 6:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 7:
          message.projectId = reader2.string();
          break;
        case 8:
          message.collectionId = reader2.string();
          break;
        case 9:
          message.type = layoutTypeFromJSON(reader2.int32());
          break;
        case 10:
          message.transitions.push(exports2.Transition.decode(reader2, reader2.uint32()));
          break;
        case 101:
          message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { width: isSet2(object.width) ? Number(object.width) : void 0, height: isSet2(object.height) ? Number(object.height) : void 0, metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0, projectId: isSet2(object.projectId) ? String(object.projectId) : void 0, collectionId: isSet2(object.collectionId) ? String(object.collectionId) : void 0, type: isSet2(object.type) ? layoutTypeFromJSON(object.type) : void 0, transitions: Array.isArray(object === null || object === void 0 ? void 0 : object.transitions) ? object.transitions.map((e2) => exports2.Transition.fromJSON(e2)) : [], requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.width !== void 0 && (obj.width = Math.round(message.width));
    message.height !== void 0 && (obj.height = Math.round(message.height));
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.type !== void 0 && (obj.type = message.type !== void 0 ? layoutTypeToJSON(message.type) : void 0);
    if (message.transitions) {
      obj.transitions = message.transitions.map((e2) => e2 ? exports2.Transition.toJSON(e2) : void 0);
    } else {
      obj.transitions = [];
    }
    message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    const message = createBasePartialLayout();
    message.width = (_a2 = object.width) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.height = (_b = object.height) !== null && _b !== void 0 ? _b : void 0;
    message.metadata = (_c = object.metadata) !== null && _c !== void 0 ? _c : void 0;
    message.projectId = (_d = object.projectId) !== null && _d !== void 0 ? _d : void 0;
    message.collectionId = (_e = object.collectionId) !== null && _e !== void 0 ? _e : void 0;
    message.type = (_f = object.type) !== null && _f !== void 0 ? _f : void 0;
    message.transitions = ((_g = object.transitions) === null || _g === void 0 ? void 0 : _g.map((e2) => exports2.Transition.fromPartial(e2))) || [];
    message.requestMetadata = (_h = object.requestMetadata) !== null && _h !== void 0 ? _h : void 0;
    return message;
  } };
  function createBaseListLayoutsRequest() {
    return { projectId: void 0, collectionId: void 0, type: void 0 };
  }
  exports2.ListLayoutsRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.projectId !== void 0) {
      writer2.uint32(10).string(message.projectId);
    }
    if (message.collectionId !== void 0) {
      writer2.uint32(18).string(message.collectionId);
    }
    if (message.type !== void 0) {
      writer2.uint32(24).int32(layoutTypeToNumber(message.type));
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseListLayoutsRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.projectId = reader2.string();
          break;
        case 2:
          message.collectionId = reader2.string();
          break;
        case 3:
          message.type = layoutTypeFromJSON(reader2.int32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { projectId: isSet2(object.projectId) ? String(object.projectId) : void 0, collectionId: isSet2(object.collectionId) ? String(object.collectionId) : void 0, type: isSet2(object.type) ? layoutTypeFromJSON(object.type) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.type !== void 0 && (obj.type = message.type !== void 0 ? layoutTypeToJSON(message.type) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseListLayoutsRequest();
    message.projectId = (_a2 = object.projectId) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.collectionId = (_b = object.collectionId) !== null && _b !== void 0 ? _b : void 0;
    message.type = (_c = object.type) !== null && _c !== void 0 ? _c : void 0;
    return message;
  } };
  function createBaseListLayoutsResponse() {
    return { layouts: [] };
  }
  exports2.ListLayoutsResponse = { encode(message, writer2 = _m02.Writer.create()) {
    for (const v2 of message.layouts) {
      exports2.Layout.encode(v2, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseListLayoutsResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.layouts.push(exports2.Layout.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { layouts: Array.isArray(object === null || object === void 0 ? void 0 : object.layouts) ? object.layouts.map((e2) => exports2.Layout.fromJSON(e2)) : [] };
  }, toJSON(message) {
    const obj = {};
    if (message.layouts) {
      obj.layouts = message.layouts.map((e2) => e2 ? exports2.Layout.toJSON(e2) : void 0);
    } else {
      obj.layouts = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseListLayoutsResponse();
    message.layouts = ((_a2 = object.layouts) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports2.Layout.fromPartial(e2))) || [];
    return message;
  } };
  function createBaseCreateLayoutRequest() {
    return { layout: void 0 };
  }
  exports2.CreateLayoutRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.layout !== void 0) {
      exports2.PartialLayout.encode(message.layout, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCreateLayoutRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 2:
          message.layout = exports2.PartialLayout.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { layout: isSet2(object.layout) ? exports2.PartialLayout.fromJSON(object.layout) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.layout !== void 0 && (obj.layout = message.layout ? exports2.PartialLayout.toJSON(message.layout) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseCreateLayoutRequest();
    message.layout = object.layout !== void 0 && object.layout !== null ? exports2.PartialLayout.fromPartial(object.layout) : void 0;
    return message;
  } };
  function createBaseGetLayoutRequest() {
    return { layoutId: "" };
  }
  exports2.GetLayoutRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.layoutId !== "") {
      writer2.uint32(10).string(message.layoutId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetLayoutRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.layoutId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "" };
  }, toJSON(message) {
    const obj = {};
    message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseGetLayoutRequest();
    message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
    return message;
  } };
  function createBaseUpdateLayoutRequest() {
    return { layoutId: "", layout: void 0 };
  }
  exports2.UpdateLayoutRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.layoutId !== "") {
      writer2.uint32(10).string(message.layoutId);
    }
    if (message.layout !== void 0) {
      exports2.PartialLayout.encode(message.layout, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUpdateLayoutRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.layoutId = reader2.string();
          break;
        case 3:
          message.layout = exports2.PartialLayout.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "", layout: isSet2(object.layout) ? exports2.PartialLayout.fromJSON(object.layout) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
    message.layout !== void 0 && (obj.layout = message.layout ? exports2.PartialLayout.toJSON(message.layout) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseUpdateLayoutRequest();
    message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
    message.layout = object.layout !== void 0 && object.layout !== null ? exports2.PartialLayout.fromPartial(object.layout) : void 0;
    return message;
  } };
  function createBaseDeleteLayoutPayload() {
    return { requestMetadata: void 0 };
  }
  exports2.DeleteLayoutPayload = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.requestMetadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDeleteLayoutPayload();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 100:
          message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseDeleteLayoutPayload();
    message.requestMetadata = (_a2 = object.requestMetadata) !== null && _a2 !== void 0 ? _a2 : void 0;
    return message;
  } };
  function createBaseDeleteLayoutRequest() {
    return { layoutId: "", payload: void 0 };
  }
  exports2.DeleteLayoutRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.layoutId !== "") {
      writer2.uint32(10).string(message.layoutId);
    }
    if (message.payload !== void 0) {
      exports2.DeleteLayoutPayload.encode(message.payload, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDeleteLayoutRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.layoutId = reader2.string();
          break;
        case 2:
          message.payload = exports2.DeleteLayoutPayload.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "", payload: isSet2(object.payload) ? exports2.DeleteLayoutPayload.fromJSON(object.payload) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
    message.payload !== void 0 && (obj.payload = message.payload ? exports2.DeleteLayoutPayload.toJSON(message.payload) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseDeleteLayoutRequest();
    message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
    message.payload = object.payload !== void 0 && object.payload !== null ? exports2.DeleteLayoutPayload.fromPartial(object.payload) : void 0;
    return message;
  } };
  function createBaseDeleteLayoutResponse() {
    return { id: "", requestMetadata: void 0 };
  }
  exports2.DeleteLayoutResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.id !== "") {
      writer2.uint32(18).string(message.id);
    }
    if (message.requestMetadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDeleteLayoutResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 2:
          message.id = reader2.string();
          break;
        case 100:
          message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { id: isSet2(object.id) ? String(object.id) : "", requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseDeleteLayoutResponse();
    message.id = (_a2 = object.id) !== null && _a2 !== void 0 ? _a2 : "";
    message.requestMetadata = (_b = object.requestMetadata) !== null && _b !== void 0 ? _b : void 0;
    return message;
  } };
  function createBaseLayerAnimation() {
    return { properties: [], durationMs: 0, delayMs: void 0, easingMode: void 0 };
  }
  exports2.LayerAnimation = { encode(message, writer2 = _m02.Writer.create()) {
    for (const v2 of message.properties) {
      writer2.uint32(10).string(v2);
    }
    if (message.durationMs !== 0) {
      writer2.uint32(16).int32(message.durationMs);
    }
    if (message.delayMs !== void 0) {
      writer2.uint32(32).int32(message.delayMs);
    }
    if (message.easingMode !== void 0) {
      writer2.uint32(42).string(message.easingMode);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseLayerAnimation();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.properties.push(reader2.string());
          break;
        case 2:
          message.durationMs = reader2.int32();
          break;
        case 4:
          message.delayMs = reader2.int32();
          break;
        case 5:
          message.easingMode = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { properties: Array.isArray(object === null || object === void 0 ? void 0 : object.properties) ? object.properties.map((e2) => String(e2)) : [], durationMs: isSet2(object.durationMs) ? Number(object.durationMs) : 0, delayMs: isSet2(object.delayMs) ? Number(object.delayMs) : void 0, easingMode: isSet2(object.easingMode) ? String(object.easingMode) : void 0 };
  }, toJSON(message) {
    const obj = {};
    if (message.properties) {
      obj.properties = message.properties.map((e2) => e2);
    } else {
      obj.properties = [];
    }
    message.durationMs !== void 0 && (obj.durationMs = Math.round(message.durationMs));
    message.delayMs !== void 0 && (obj.delayMs = Math.round(message.delayMs));
    message.easingMode !== void 0 && (obj.easingMode = message.easingMode);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseLayerAnimation();
    message.properties = ((_a2 = object.properties) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
    message.durationMs = (_b = object.durationMs) !== null && _b !== void 0 ? _b : 0;
    message.delayMs = (_c = object.delayMs) !== null && _c !== void 0 ? _c : void 0;
    message.easingMode = (_d = object.easingMode) !== null && _d !== void 0 ? _d : void 0;
    return message;
  } };
  function createBasePartialLayer() {
    return { type: void 0, data: void 0, x: void 0, y: void 0, width: void 0, height: void 0, rotation: void 0, opacity: void 0, scale: void 0, hidden: void 0, children: void 0, parentId: void 0, metadata: void 0, requestMetadata: void 0, requestAnimation: [] };
  }
  exports2.PartialLayer = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.type !== void 0) {
      writer2.uint32(10).string(message.type);
    }
    if (message.data !== void 0) {
      struct_1.Struct.encode(struct_1.Struct.wrap(message.data), writer2.uint32(18).fork()).ldelim();
    }
    if (message.x !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.x), writer2.uint32(26).fork()).ldelim();
    }
    if (message.y !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.y), writer2.uint32(34).fork()).ldelim();
    }
    if (message.width !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.width), writer2.uint32(42).fork()).ldelim();
    }
    if (message.height !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.height), writer2.uint32(50).fork()).ldelim();
    }
    if (message.rotation !== void 0) {
      writer2.uint32(57).double(message.rotation);
    }
    if (message.opacity !== void 0) {
      writer2.uint32(65).double(message.opacity);
    }
    if (message.scale !== void 0) {
      writer2.uint32(73).double(message.scale);
    }
    if (message.hidden !== void 0) {
      writer2.uint32(80).bool(message.hidden);
    }
    if (message.children !== void 0) {
      struct_1.ListValue.encode(struct_1.ListValue.wrap(message.children), writer2.uint32(98).fork()).ldelim();
    }
    if (message.parentId !== void 0) {
      writer2.uint32(106).string(message.parentId);
    }
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(114).fork()).ldelim();
    }
    if (message.requestMetadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
    }
    for (const v2 of message.requestAnimation) {
      exports2.LayerAnimation.encode(v2, writer2.uint32(826).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBasePartialLayer();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader2.string();
          break;
        case 2:
          message.data = struct_1.Struct.unwrap(struct_1.Struct.decode(reader2, reader2.uint32()));
          break;
        case 3:
          message.x = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 4:
          message.y = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 5:
          message.width = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 6:
          message.height = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 7:
          message.rotation = reader2.double();
          break;
        case 8:
          message.opacity = reader2.double();
          break;
        case 9:
          message.scale = reader2.double();
          break;
        case 10:
          message.hidden = reader2.bool();
          break;
        case 12:
          message.children = struct_1.ListValue.unwrap(struct_1.ListValue.decode(reader2, reader2.uint32()));
          break;
        case 13:
          message.parentId = reader2.string();
          break;
        case 14:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 100:
          message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 103:
          message.requestAnimation.push(exports2.LayerAnimation.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { type: isSet2(object.type) ? String(object.type) : void 0, data: isObject2(object.data) ? object.data : void 0, x: isSet2(object === null || object === void 0 ? void 0 : object.x) ? object.x : void 0, y: isSet2(object === null || object === void 0 ? void 0 : object.y) ? object.y : void 0, width: isSet2(object === null || object === void 0 ? void 0 : object.width) ? object.width : void 0, height: isSet2(object === null || object === void 0 ? void 0 : object.height) ? object.height : void 0, rotation: isSet2(object.rotation) ? Number(object.rotation) : void 0, opacity: isSet2(object.opacity) ? Number(object.opacity) : void 0, scale: isSet2(object.scale) ? Number(object.scale) : void 0, hidden: isSet2(object.hidden) ? Boolean(object.hidden) : void 0, children: Array.isArray(object.children) ? [...object.children] : void 0, parentId: isSet2(object.parentId) ? String(object.parentId) : void 0, metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0, requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0, requestAnimation: Array.isArray(object === null || object === void 0 ? void 0 : object.requestAnimation) ? object.requestAnimation.map((e2) => exports2.LayerAnimation.fromJSON(e2)) : [] };
  }, toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = message.type);
    message.data !== void 0 && (obj.data = message.data);
    message.x !== void 0 && (obj.x = message.x);
    message.y !== void 0 && (obj.y = message.y);
    message.width !== void 0 && (obj.width = message.width);
    message.height !== void 0 && (obj.height = message.height);
    message.rotation !== void 0 && (obj.rotation = message.rotation);
    message.opacity !== void 0 && (obj.opacity = message.opacity);
    message.scale !== void 0 && (obj.scale = message.scale);
    message.hidden !== void 0 && (obj.hidden = message.hidden);
    message.children !== void 0 && (obj.children = message.children);
    message.parentId !== void 0 && (obj.parentId = message.parentId);
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
    if (message.requestAnimation) {
      obj.requestAnimation = message.requestAnimation.map((e2) => e2 ? exports2.LayerAnimation.toJSON(e2) : void 0);
    } else {
      obj.requestAnimation = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    const message = createBasePartialLayer();
    message.type = (_a2 = object.type) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.data = (_b = object.data) !== null && _b !== void 0 ? _b : void 0;
    message.x = (_c = object.x) !== null && _c !== void 0 ? _c : void 0;
    message.y = (_d = object.y) !== null && _d !== void 0 ? _d : void 0;
    message.width = (_e = object.width) !== null && _e !== void 0 ? _e : void 0;
    message.height = (_f = object.height) !== null && _f !== void 0 ? _f : void 0;
    message.rotation = (_g = object.rotation) !== null && _g !== void 0 ? _g : void 0;
    message.opacity = (_h = object.opacity) !== null && _h !== void 0 ? _h : void 0;
    message.scale = (_j = object.scale) !== null && _j !== void 0 ? _j : void 0;
    message.hidden = (_k = object.hidden) !== null && _k !== void 0 ? _k : void 0;
    message.children = (_l = object.children) !== null && _l !== void 0 ? _l : void 0;
    message.parentId = (_m = object.parentId) !== null && _m !== void 0 ? _m : void 0;
    message.metadata = (_o = object.metadata) !== null && _o !== void 0 ? _o : void 0;
    message.requestMetadata = (_p = object.requestMetadata) !== null && _p !== void 0 ? _p : void 0;
    message.requestAnimation = ((_q = object.requestAnimation) === null || _q === void 0 ? void 0 : _q.map((e2) => exports2.LayerAnimation.fromPartial(e2))) || [];
    return message;
  } };
  function createBasePartialLayerWithID() {
    return { id: "", type: void 0, data: void 0, x: void 0, y: void 0, width: void 0, height: void 0, rotation: void 0, opacity: void 0, scale: void 0, hidden: void 0, children: void 0, parentId: void 0, metadata: void 0, requestMetadata: void 0, requestAnimation: [] };
  }
  exports2.PartialLayerWithID = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.id !== "") {
      writer2.uint32(8002).string(message.id);
    }
    if (message.type !== void 0) {
      writer2.uint32(10).string(message.type);
    }
    if (message.data !== void 0) {
      struct_1.Struct.encode(struct_1.Struct.wrap(message.data), writer2.uint32(18).fork()).ldelim();
    }
    if (message.x !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.x), writer2.uint32(26).fork()).ldelim();
    }
    if (message.y !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.y), writer2.uint32(34).fork()).ldelim();
    }
    if (message.width !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.width), writer2.uint32(42).fork()).ldelim();
    }
    if (message.height !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.height), writer2.uint32(50).fork()).ldelim();
    }
    if (message.rotation !== void 0) {
      writer2.uint32(57).double(message.rotation);
    }
    if (message.opacity !== void 0) {
      writer2.uint32(65).double(message.opacity);
    }
    if (message.scale !== void 0) {
      writer2.uint32(73).double(message.scale);
    }
    if (message.hidden !== void 0) {
      writer2.uint32(80).bool(message.hidden);
    }
    if (message.children !== void 0) {
      struct_1.ListValue.encode(struct_1.ListValue.wrap(message.children), writer2.uint32(98).fork()).ldelim();
    }
    if (message.parentId !== void 0) {
      writer2.uint32(106).string(message.parentId);
    }
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(114).fork()).ldelim();
    }
    if (message.requestMetadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
    }
    for (const v2 of message.requestAnimation) {
      exports2.LayerAnimation.encode(v2, writer2.uint32(826).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBasePartialLayerWithID();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1e3:
          message.id = reader2.string();
          break;
        case 1:
          message.type = reader2.string();
          break;
        case 2:
          message.data = struct_1.Struct.unwrap(struct_1.Struct.decode(reader2, reader2.uint32()));
          break;
        case 3:
          message.x = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 4:
          message.y = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 5:
          message.width = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 6:
          message.height = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 7:
          message.rotation = reader2.double();
          break;
        case 8:
          message.opacity = reader2.double();
          break;
        case 9:
          message.scale = reader2.double();
          break;
        case 10:
          message.hidden = reader2.bool();
          break;
        case 12:
          message.children = struct_1.ListValue.unwrap(struct_1.ListValue.decode(reader2, reader2.uint32()));
          break;
        case 13:
          message.parentId = reader2.string();
          break;
        case 14:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 100:
          message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 103:
          message.requestAnimation.push(exports2.LayerAnimation.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { id: isSet2(object.id) ? String(object.id) : "", type: isSet2(object.type) ? String(object.type) : void 0, data: isObject2(object.data) ? object.data : void 0, x: isSet2(object === null || object === void 0 ? void 0 : object.x) ? object.x : void 0, y: isSet2(object === null || object === void 0 ? void 0 : object.y) ? object.y : void 0, width: isSet2(object === null || object === void 0 ? void 0 : object.width) ? object.width : void 0, height: isSet2(object === null || object === void 0 ? void 0 : object.height) ? object.height : void 0, rotation: isSet2(object.rotation) ? Number(object.rotation) : void 0, opacity: isSet2(object.opacity) ? Number(object.opacity) : void 0, scale: isSet2(object.scale) ? Number(object.scale) : void 0, hidden: isSet2(object.hidden) ? Boolean(object.hidden) : void 0, children: Array.isArray(object.children) ? [...object.children] : void 0, parentId: isSet2(object.parentId) ? String(object.parentId) : void 0, metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0, requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0, requestAnimation: Array.isArray(object === null || object === void 0 ? void 0 : object.requestAnimation) ? object.requestAnimation.map((e2) => exports2.LayerAnimation.fromJSON(e2)) : [] };
  }, toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.type !== void 0 && (obj.type = message.type);
    message.data !== void 0 && (obj.data = message.data);
    message.x !== void 0 && (obj.x = message.x);
    message.y !== void 0 && (obj.y = message.y);
    message.width !== void 0 && (obj.width = message.width);
    message.height !== void 0 && (obj.height = message.height);
    message.rotation !== void 0 && (obj.rotation = message.rotation);
    message.opacity !== void 0 && (obj.opacity = message.opacity);
    message.scale !== void 0 && (obj.scale = message.scale);
    message.hidden !== void 0 && (obj.hidden = message.hidden);
    message.children !== void 0 && (obj.children = message.children);
    message.parentId !== void 0 && (obj.parentId = message.parentId);
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
    if (message.requestAnimation) {
      obj.requestAnimation = message.requestAnimation.map((e2) => e2 ? exports2.LayerAnimation.toJSON(e2) : void 0);
    } else {
      obj.requestAnimation = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    const message = createBasePartialLayerWithID();
    message.id = (_a2 = object.id) !== null && _a2 !== void 0 ? _a2 : "";
    message.type = (_b = object.type) !== null && _b !== void 0 ? _b : void 0;
    message.data = (_c = object.data) !== null && _c !== void 0 ? _c : void 0;
    message.x = (_d = object.x) !== null && _d !== void 0 ? _d : void 0;
    message.y = (_e = object.y) !== null && _e !== void 0 ? _e : void 0;
    message.width = (_f = object.width) !== null && _f !== void 0 ? _f : void 0;
    message.height = (_g = object.height) !== null && _g !== void 0 ? _g : void 0;
    message.rotation = (_h = object.rotation) !== null && _h !== void 0 ? _h : void 0;
    message.opacity = (_j = object.opacity) !== null && _j !== void 0 ? _j : void 0;
    message.scale = (_k = object.scale) !== null && _k !== void 0 ? _k : void 0;
    message.hidden = (_l = object.hidden) !== null && _l !== void 0 ? _l : void 0;
    message.children = (_m = object.children) !== null && _m !== void 0 ? _m : void 0;
    message.parentId = (_o = object.parentId) !== null && _o !== void 0 ? _o : void 0;
    message.metadata = (_p = object.metadata) !== null && _p !== void 0 ? _p : void 0;
    message.requestMetadata = (_q = object.requestMetadata) !== null && _q !== void 0 ? _q : void 0;
    message.requestAnimation = ((_r = object.requestAnimation) === null || _r === void 0 ? void 0 : _r.map((e2) => exports2.LayerAnimation.fromPartial(e2))) || [];
    return message;
  } };
  function createBaseListLayersRequest() {
    return { layoutId: "" };
  }
  exports2.ListLayersRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.layoutId !== "") {
      writer2.uint32(10).string(message.layoutId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseListLayersRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.layoutId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "" };
  }, toJSON(message) {
    const obj = {};
    message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseListLayersRequest();
    message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
    return message;
  } };
  function createBaseListLayersResponse() {
    return { layers: [] };
  }
  exports2.ListLayersResponse = { encode(message, writer2 = _m02.Writer.create()) {
    for (const v2 of message.layers) {
      exports2.Layer.encode(v2, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseListLayersResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.layers.push(exports2.Layer.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e2) => exports2.Layer.fromJSON(e2)) : [] };
  }, toJSON(message) {
    const obj = {};
    if (message.layers) {
      obj.layers = message.layers.map((e2) => e2 ? exports2.Layer.toJSON(e2) : void 0);
    } else {
      obj.layers = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseListLayersResponse();
    message.layers = ((_a2 = object.layers) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports2.Layer.fromPartial(e2))) || [];
    return message;
  } };
  function createBaseCreateLayerRequest() {
    return { layoutId: "", layer: void 0 };
  }
  exports2.CreateLayerRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.layoutId !== "") {
      writer2.uint32(10).string(message.layoutId);
    }
    if (message.layer !== void 0) {
      exports2.PartialLayer.encode(message.layer, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCreateLayerRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.layoutId = reader2.string();
          break;
        case 2:
          message.layer = exports2.PartialLayer.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "", layer: isSet2(object.layer) ? exports2.PartialLayer.fromJSON(object.layer) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
    message.layer !== void 0 && (obj.layer = message.layer ? exports2.PartialLayer.toJSON(message.layer) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseCreateLayerRequest();
    message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
    message.layer = object.layer !== void 0 && object.layer !== null ? exports2.PartialLayer.fromPartial(object.layer) : void 0;
    return message;
  } };
  function createBaseGetLayerRequest() {
    return { layoutId: "", layerId: "" };
  }
  exports2.GetLayerRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.layoutId !== "") {
      writer2.uint32(10).string(message.layoutId);
    }
    if (message.layerId !== "") {
      writer2.uint32(18).string(message.layerId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetLayerRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.layoutId = reader2.string();
          break;
        case 2:
          message.layerId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "", layerId: isSet2(object.layerId) ? String(object.layerId) : "" };
  }, toJSON(message) {
    const obj = {};
    message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
    message.layerId !== void 0 && (obj.layerId = message.layerId);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseGetLayerRequest();
    message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
    message.layerId = (_b = object.layerId) !== null && _b !== void 0 ? _b : "";
    return message;
  } };
  function createBaseUpdateLayerRequest() {
    return { layoutId: "", layerId: "", layer: void 0 };
  }
  exports2.UpdateLayerRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.layoutId !== "") {
      writer2.uint32(10).string(message.layoutId);
    }
    if (message.layerId !== "") {
      writer2.uint32(18).string(message.layerId);
    }
    if (message.layer !== void 0) {
      exports2.PartialLayer.encode(message.layer, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUpdateLayerRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.layoutId = reader2.string();
          break;
        case 2:
          message.layerId = reader2.string();
          break;
        case 3:
          message.layer = exports2.PartialLayer.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "", layerId: isSet2(object.layerId) ? String(object.layerId) : "", layer: isSet2(object.layer) ? exports2.PartialLayer.fromJSON(object.layer) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
    message.layerId !== void 0 && (obj.layerId = message.layerId);
    message.layer !== void 0 && (obj.layer = message.layer ? exports2.PartialLayer.toJSON(message.layer) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseUpdateLayerRequest();
    message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
    message.layerId = (_b = object.layerId) !== null && _b !== void 0 ? _b : "";
    message.layer = object.layer !== void 0 && object.layer !== null ? exports2.PartialLayer.fromPartial(object.layer) : void 0;
    return message;
  } };
  function createBaseDeleteLayerPayload() {
    return { requestMetadata: void 0 };
  }
  exports2.DeleteLayerPayload = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.requestMetadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDeleteLayerPayload();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 100:
          message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseDeleteLayerPayload();
    message.requestMetadata = (_a2 = object.requestMetadata) !== null && _a2 !== void 0 ? _a2 : void 0;
    return message;
  } };
  function createBaseBatchDeleteLayerRequest() {
    return { id: "", requestMetadata: void 0 };
  }
  exports2.BatchDeleteLayerRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.id !== "") {
      writer2.uint32(10).string(message.id);
    }
    if (message.requestMetadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseBatchDeleteLayerRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader2.string();
          break;
        case 100:
          message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { id: isSet2(object.id) ? String(object.id) : "", requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = message.id);
    message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseBatchDeleteLayerRequest();
    message.id = (_a2 = object.id) !== null && _a2 !== void 0 ? _a2 : "";
    message.requestMetadata = (_b = object.requestMetadata) !== null && _b !== void 0 ? _b : void 0;
    return message;
  } };
  function createBaseBatchLayerRequest() {
    return { layoutId: "", layers: [], requestMetadata: void 0, requestAnimationMode: void 0 };
  }
  exports2.BatchLayerRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.layoutId !== "") {
      writer2.uint32(10).string(message.layoutId);
    }
    for (const v2 of message.layers) {
      exports2.BatchLayerRequest_BatchItem.encode(v2, writer2.uint32(18).fork()).ldelim();
    }
    if (message.requestMetadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
    }
    if (message.requestAnimationMode !== void 0) {
      writer2.uint32(808).int32(requestAnimationModeToNumber(message.requestAnimationMode));
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseBatchLayerRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.layoutId = reader2.string();
          break;
        case 2:
          message.layers.push(exports2.BatchLayerRequest_BatchItem.decode(reader2, reader2.uint32()));
          break;
        case 100:
          message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 101:
          message.requestAnimationMode = requestAnimationModeFromJSON(reader2.int32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "", layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e2) => exports2.BatchLayerRequest_BatchItem.fromJSON(e2)) : [], requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0, requestAnimationMode: isSet2(object.requestAnimationMode) ? requestAnimationModeFromJSON(object.requestAnimationMode) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
    if (message.layers) {
      obj.layers = message.layers.map((e2) => e2 ? exports2.BatchLayerRequest_BatchItem.toJSON(e2) : void 0);
    } else {
      obj.layers = [];
    }
    message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
    message.requestAnimationMode !== void 0 && (obj.requestAnimationMode = message.requestAnimationMode !== void 0 ? requestAnimationModeToJSON(message.requestAnimationMode) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseBatchLayerRequest();
    message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
    message.layers = ((_b = object.layers) === null || _b === void 0 ? void 0 : _b.map((e2) => exports2.BatchLayerRequest_BatchItem.fromPartial(e2))) || [];
    message.requestMetadata = (_c = object.requestMetadata) !== null && _c !== void 0 ? _c : void 0;
    message.requestAnimationMode = (_d = object.requestAnimationMode) !== null && _d !== void 0 ? _d : void 0;
    return message;
  } };
  function createBaseBatchLayerRequest_BatchItem() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  exports2.BatchLayerRequest_BatchItem = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.create !== void 0) {
      exports2.PartialLayer.encode(message.create, writer2.uint32(10).fork()).ldelim();
    }
    if (message.update !== void 0) {
      exports2.PartialLayerWithID.encode(message.update, writer2.uint32(18).fork()).ldelim();
    }
    if (message.delete !== void 0) {
      exports2.BatchDeleteLayerRequest.encode(message.delete, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseBatchLayerRequest_BatchItem();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.create = exports2.PartialLayer.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.update = exports2.PartialLayerWithID.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.delete = exports2.BatchDeleteLayerRequest.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { create: isSet2(object.create) ? exports2.PartialLayer.fromJSON(object.create) : void 0, update: isSet2(object.update) ? exports2.PartialLayerWithID.fromJSON(object.update) : void 0, delete: isSet2(object.delete) ? exports2.BatchDeleteLayerRequest.fromJSON(object.delete) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.create !== void 0 && (obj.create = message.create ? exports2.PartialLayer.toJSON(message.create) : void 0);
    message.update !== void 0 && (obj.update = message.update ? exports2.PartialLayerWithID.toJSON(message.update) : void 0);
    message.delete !== void 0 && (obj.delete = message.delete ? exports2.BatchDeleteLayerRequest.toJSON(message.delete) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseBatchLayerRequest_BatchItem();
    message.create = object.create !== void 0 && object.create !== null ? exports2.PartialLayer.fromPartial(object.create) : void 0;
    message.update = object.update !== void 0 && object.update !== null ? exports2.PartialLayerWithID.fromPartial(object.update) : void 0;
    message.delete = object.delete !== void 0 && object.delete !== null ? exports2.BatchDeleteLayerRequest.fromPartial(object.delete) : void 0;
    return message;
  } };
  function createBaseLayoutEvent() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  exports2.LayoutEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.create !== void 0) {
      exports2.Layout.encode(message.create, writer2.uint32(10).fork()).ldelim();
    }
    if (message.update !== void 0) {
      exports2.Layout.encode(message.update, writer2.uint32(18).fork()).ldelim();
    }
    if (message.delete !== void 0) {
      exports2.DeleteLayoutResponse.encode(message.delete, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseLayoutEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.create = exports2.Layout.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.update = exports2.Layout.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.delete = exports2.DeleteLayoutResponse.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { create: isSet2(object.create) ? exports2.Layout.fromJSON(object.create) : void 0, update: isSet2(object.update) ? exports2.Layout.fromJSON(object.update) : void 0, delete: isSet2(object.delete) ? exports2.DeleteLayoutResponse.fromJSON(object.delete) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.create !== void 0 && (obj.create = message.create ? exports2.Layout.toJSON(message.create) : void 0);
    message.update !== void 0 && (obj.update = message.update ? exports2.Layout.toJSON(message.update) : void 0);
    message.delete !== void 0 && (obj.delete = message.delete ? exports2.DeleteLayoutResponse.toJSON(message.delete) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseLayoutEvent();
    message.create = object.create !== void 0 && object.create !== null ? exports2.Layout.fromPartial(object.create) : void 0;
    message.update = object.update !== void 0 && object.update !== null ? exports2.Layout.fromPartial(object.update) : void 0;
    message.delete = object.delete !== void 0 && object.delete !== null ? exports2.DeleteLayoutResponse.fromPartial(object.delete) : void 0;
    return message;
  } };
  function createBaseLayerEvent() {
    return { create: void 0, update: void 0, delete: void 0, batch: void 0 };
  }
  exports2.LayerEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.create !== void 0) {
      exports2.Layer.encode(message.create, writer2.uint32(10).fork()).ldelim();
    }
    if (message.update !== void 0) {
      exports2.Layer.encode(message.update, writer2.uint32(18).fork()).ldelim();
    }
    if (message.delete !== void 0) {
      exports2.DeleteLayerResponse.encode(message.delete, writer2.uint32(26).fork()).ldelim();
    }
    if (message.batch !== void 0) {
      exports2.BatchLayerResponse.encode(message.batch, writer2.uint32(34).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseLayerEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.create = exports2.Layer.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.update = exports2.Layer.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.delete = exports2.DeleteLayerResponse.decode(reader2, reader2.uint32());
          break;
        case 4:
          message.batch = exports2.BatchLayerResponse.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { create: isSet2(object.create) ? exports2.Layer.fromJSON(object.create) : void 0, update: isSet2(object.update) ? exports2.Layer.fromJSON(object.update) : void 0, delete: isSet2(object.delete) ? exports2.DeleteLayerResponse.fromJSON(object.delete) : void 0, batch: isSet2(object.batch) ? exports2.BatchLayerResponse.fromJSON(object.batch) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.create !== void 0 && (obj.create = message.create ? exports2.Layer.toJSON(message.create) : void 0);
    message.update !== void 0 && (obj.update = message.update ? exports2.Layer.toJSON(message.update) : void 0);
    message.delete !== void 0 && (obj.delete = message.delete ? exports2.DeleteLayerResponse.toJSON(message.delete) : void 0);
    message.batch !== void 0 && (obj.batch = message.batch ? exports2.BatchLayerResponse.toJSON(message.batch) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseLayerEvent();
    message.create = object.create !== void 0 && object.create !== null ? exports2.Layer.fromPartial(object.create) : void 0;
    message.update = object.update !== void 0 && object.update !== null ? exports2.Layer.fromPartial(object.update) : void 0;
    message.delete = object.delete !== void 0 && object.delete !== null ? exports2.DeleteLayerResponse.fromPartial(object.delete) : void 0;
    message.batch = object.batch !== void 0 && object.batch !== null ? exports2.BatchLayerResponse.fromPartial(object.batch) : void 0;
    return message;
  } };
  function createBaseEvent() {
    return { layout: void 0, layer: void 0 };
  }
  exports2.Event = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.layout !== void 0) {
      exports2.LayoutEvent.encode(message.layout, writer2.uint32(10).fork()).ldelim();
    }
    if (message.layer !== void 0) {
      exports2.LayerEvent.encode(message.layer, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.layout = exports2.LayoutEvent.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.layer = exports2.LayerEvent.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { layout: isSet2(object.layout) ? exports2.LayoutEvent.fromJSON(object.layout) : void 0, layer: isSet2(object.layer) ? exports2.LayerEvent.fromJSON(object.layer) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.layout !== void 0 && (obj.layout = message.layout ? exports2.LayoutEvent.toJSON(message.layout) : void 0);
    message.layer !== void 0 && (obj.layer = message.layer ? exports2.LayerEvent.toJSON(message.layer) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseEvent();
    message.layout = object.layout !== void 0 && object.layout !== null ? exports2.LayoutEvent.fromPartial(object.layout) : void 0;
    message.layer = object.layer !== void 0 && object.layer !== null ? exports2.LayerEvent.fromPartial(object.layer) : void 0;
    return message;
  } };
  class LayerServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.ListLayers = this.ListLayers.bind(this);
      this.CreateLayer = this.CreateLayer.bind(this);
      this.GetLayer = this.GetLayer.bind(this);
      this.UpdateLayer = this.UpdateLayer.bind(this);
      this.DeleteLayer = this.DeleteLayer.bind(this);
      this.Batch = this.Batch.bind(this);
    }
    ListLayers(request3) {
      const data2 = exports2.ListLayersRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayerService", "ListLayers", data2);
      return promise.then((data3) => exports2.ListLayersResponse.decode(new _m02.Reader(data3)));
    }
    CreateLayer(request3) {
      const data2 = exports2.CreateLayerRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayerService", "CreateLayer", data2);
      return promise.then((data3) => exports2.Layer.decode(new _m02.Reader(data3)));
    }
    GetLayer(request3) {
      const data2 = exports2.GetLayerRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayerService", "GetLayer", data2);
      return promise.then((data3) => exports2.Layer.decode(new _m02.Reader(data3)));
    }
    UpdateLayer(request3) {
      const data2 = exports2.UpdateLayerRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayerService", "UpdateLayer", data2);
      return promise.then((data3) => exports2.Layer.decode(new _m02.Reader(data3)));
    }
    DeleteLayer(request3) {
      const data2 = exports2.DeleteLayerRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayerService", "DeleteLayer", data2);
      return promise.then((data3) => exports2.DeleteLayerResponse.decode(new _m02.Reader(data3)));
    }
    Batch(request3) {
      const data2 = exports2.BatchLayerRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayerService", "Batch", data2);
      return promise.then((data3) => exports2.BatchLayerResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.LayerServiceClientImpl = LayerServiceClientImpl;
  exports2.LayerServiceDefinition = { name: "LayerService", fullName: "apis.layout.v2.LayerService", methods: { listLayers: { name: "ListLayers", requestType: exports2.ListLayersRequest, requestStream: false, responseType: exports2.ListLayersResponse, responseStream: false, options: {} }, createLayer: { name: "CreateLayer", requestType: exports2.CreateLayerRequest, requestStream: false, responseType: exports2.Layer, responseStream: false, options: {} }, getLayer: { name: "GetLayer", requestType: exports2.GetLayerRequest, requestStream: false, responseType: exports2.Layer, responseStream: false, options: {} }, updateLayer: { name: "UpdateLayer", requestType: exports2.UpdateLayerRequest, requestStream: false, responseType: exports2.Layer, responseStream: false, options: {} }, deleteLayer: { name: "DeleteLayer", requestType: exports2.DeleteLayerRequest, requestStream: false, responseType: exports2.DeleteLayerResponse, responseStream: false, options: {} }, batch: { name: "Batch", requestType: exports2.BatchLayerRequest, requestStream: false, responseType: exports2.BatchLayerResponse, responseStream: false, options: {} } } };
  class LayoutServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.ListLayouts = this.ListLayouts.bind(this);
      this.CreateLayout = this.CreateLayout.bind(this);
      this.GetLayout = this.GetLayout.bind(this);
      this.UpdateLayout = this.UpdateLayout.bind(this);
      this.DeleteLayout = this.DeleteLayout.bind(this);
    }
    ListLayouts(request3) {
      const data2 = exports2.ListLayoutsRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayoutService", "ListLayouts", data2);
      return promise.then((data3) => exports2.ListLayoutsResponse.decode(new _m02.Reader(data3)));
    }
    CreateLayout(request3) {
      const data2 = exports2.CreateLayoutRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayoutService", "CreateLayout", data2);
      return promise.then((data3) => exports2.Layout.decode(new _m02.Reader(data3)));
    }
    GetLayout(request3) {
      const data2 = exports2.GetLayoutRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayoutService", "GetLayout", data2);
      return promise.then((data3) => exports2.Layout.decode(new _m02.Reader(data3)));
    }
    UpdateLayout(request3) {
      const data2 = exports2.UpdateLayoutRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayoutService", "UpdateLayout", data2);
      return promise.then((data3) => exports2.Layout.decode(new _m02.Reader(data3)));
    }
    DeleteLayout(request3) {
      const data2 = exports2.DeleteLayoutRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayoutService", "DeleteLayout", data2);
      return promise.then((data3) => exports2.DeleteLayoutResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.LayoutServiceClientImpl = LayoutServiceClientImpl;
  exports2.LayoutServiceDefinition = { name: "LayoutService", fullName: "apis.layout.v2.LayoutService", methods: { listLayouts: { name: "ListLayouts", requestType: exports2.ListLayoutsRequest, requestStream: false, responseType: exports2.ListLayoutsResponse, responseStream: false, options: {} }, createLayout: { name: "CreateLayout", requestType: exports2.CreateLayoutRequest, requestStream: false, responseType: exports2.Layout, responseStream: false, options: {} }, getLayout: { name: "GetLayout", requestType: exports2.GetLayoutRequest, requestStream: false, responseType: exports2.Layout, responseStream: false, options: {} }, updateLayout: { name: "UpdateLayout", requestType: exports2.UpdateLayoutRequest, requestStream: false, responseType: exports2.Layout, responseStream: false, options: {} }, deleteLayout: { name: "DeleteLayout", requestType: exports2.DeleteLayoutRequest, requestStream: false, responseType: exports2.DeleteLayoutResponse, responseStream: false, options: {} } } };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal !== "undefined")
      return commonjsGlobal;
    throw "Unable to locate global object";
  })();
  if (_m02.util.Long !== long_12.default) {
    _m02.util.Long = long_12.default;
    _m02.configure();
  }
  function isObject2(value) {
    return typeof value === "object" && value !== null;
  }
  function isSet2(value) {
    return value !== null && value !== void 0;
  }
})(api$3);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m2[k];
    } });
  } : function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !exports3.hasOwnProperty(p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.layoutApiEventMap = void 0;
  const api_12 = api$3;
  __exportStar(api$3, exports2);
  exports2.layoutApiEventMap = { [api_12.EventType.EVENT_TYPE_LAYOUT]: "layout", [api_12.EventType.EVENT_TYPE_LAYER]: "layer", [api_12.EventType.EVENT_TYPE_UNSPECIFIED]: "unspecified" };
})(dist$3);
var api$2 = {};
var browser$2 = false;
var __viteBrowserExternal = {};
var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, "default": __viteBrowserExternal }, Symbol.toStringTag, { value: "Module" }));
var require$$3 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var logger$1 = {};
class EnhancedMap extends Map {
  computeIfAbsent(key, computer) {
    if (this.has(key)) {
      return this.get(key);
    }
    const newValue = computer(key);
    this.set(key, newValue);
    return newValue;
  }
  computeIfPresent(key, computer) {
    const currentValue = this.get(key);
    if (currentValue === void 0) {
      return void 0;
    }
    const newValue = computer(key, currentValue);
    if (newValue !== void 0) {
      this.set(key, newValue);
    } else {
      this.delete(key);
    }
    return newValue;
  }
  compute(key, computer) {
    const currentValue = this.get(key);
    const newValue = computer(key, currentValue);
    if (newValue) {
      this.set(key, newValue);
    } else {
      this.delete(key);
    }
    return newValue;
  }
}
var InternalLogLevel;
(function(InternalLogLevel2) {
  InternalLogLevel2[InternalLogLevel2["Trace"] = 0] = "Trace";
  InternalLogLevel2[InternalLogLevel2["Debug"] = 1] = "Debug";
  InternalLogLevel2[InternalLogLevel2["Info"] = 2] = "Info";
  InternalLogLevel2[InternalLogLevel2["Warn"] = 3] = "Warn";
  InternalLogLevel2[InternalLogLevel2["Error"] = 4] = "Error";
})(InternalLogLevel || (InternalLogLevel = {}));
function getInternalLogger(name2) {
  return provider.getLogger(name2);
}
const INTERNAL_LOGGING_SETTINGS = { setInternalLogLevel: (level) => provider.changeLogLevel(level), setOutput: (fnOutput) => provider.changeOutput(fnOutput), reset: () => provider.reset() };
class InternalLoggerImpl {
  constructor(name2, level, fnOutput) {
    this._name = name2;
    this._level = level;
    this._fnOutput = fnOutput;
  }
  trace(msg) {
    this.log(InternalLogLevel.Trace, msg);
  }
  debug(msg) {
    this.log(InternalLogLevel.Debug, msg);
  }
  error(msg, error) {
    this.log(InternalLogLevel.Error, msg, error);
  }
  info(msg) {
    this.log(InternalLogLevel.Info, msg);
  }
  warn(msg, error) {
    this.log(InternalLogLevel.Warn, msg, error);
  }
  setLevel(level) {
    this._level = level;
  }
  setOutput(fnOutput) {
    this._fnOutput = fnOutput;
  }
  log(level, msg, error) {
    if (this._level > level) {
      return;
    }
    this._fnOutput(`${InternalLogLevel[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${msg()}${error ? "\n" + error.stack : ""}`);
  }
}
class InternalProviderImpl {
  constructor() {
    this._loggers = new EnhancedMap();
    this._logLevel = InternalLogLevel.Error;
    this._fnOutput = InternalProviderImpl.logConsole;
  }
  getLogger(name2) {
    return this._loggers.computeIfAbsent(name2, (key) => new InternalLoggerImpl(key, this._logLevel, this._fnOutput));
  }
  changeLogLevel(level) {
    this._logLevel = level;
    this._loggers.forEach((logger2) => logger2.setLevel(level));
  }
  changeOutput(_fnOutput) {
    this._fnOutput = _fnOutput;
    this._loggers.forEach((logger2) => logger2.setOutput(this._fnOutput));
  }
  reset() {
    this.changeLogLevel(InternalLogLevel.Error);
    this._fnOutput = InternalProviderImpl.logConsole;
    this._loggers.forEach((logger2) => logger2.setOutput(this._fnOutput));
  }
  static logConsole(msg) {
    if (console && console.log) {
      console.log(msg);
    }
  }
}
const provider = new InternalProviderImpl();
var InternalLogger = /* @__PURE__ */ Object.freeze({ __proto__: null, get InternalLogLevel() {
  return InternalLogLevel;
}, getInternalLogger, INTERNAL_LOGGING_SETTINGS });
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Trace"] = 0] = "Trace";
  LogLevel2[LogLevel2["Debug"] = 1] = "Debug";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Warn"] = 3] = "Warn";
  LogLevel2[LogLevel2["Error"] = 4] = "Error";
  LogLevel2[LogLevel2["Fatal"] = 5] = "Fatal";
})(LogLevel || (LogLevel = {}));
(function(LogLevel2) {
  function toLogLevel(val) {
    switch (val.toLowerCase()) {
      case "trace":
        return LogLevel2.Trace;
      case "debug":
        return LogLevel2.Debug;
      case "info":
        return LogLevel2.Info;
      case "warn":
        return LogLevel2.Warn;
      case "error":
        return LogLevel2.Error;
      case "fatal":
        return LogLevel2.Fatal;
      default:
        return void 0;
    }
  }
  LogLevel2.toLogLevel = toLogLevel;
})(LogLevel || (LogLevel = {}));
class CoreLoggerImpl {
  constructor(runtime) {
    this._runtime = runtime;
  }
  get id() {
    return this._runtime.id;
  }
  get logLevel() {
    return this._runtime.level;
  }
  get runtimeSettings() {
    return Object.assign({}, this._runtime);
  }
  set runtimeSettings(runtime) {
    this._runtime = runtime;
  }
  trace(message, ...args) {
    this.logMessage(LogLevel.Trace, message, args);
  }
  debug(message, ...args) {
    this.logMessage(LogLevel.Debug, message, args);
  }
  info(message, ...args) {
    this.logMessage(LogLevel.Info, message, args);
  }
  warn(message, ...args) {
    this.logMessage(LogLevel.Warn, message, args);
  }
  error(message, ...args) {
    this.logMessage(LogLevel.Error, message, args);
  }
  fatal(message, ...args) {
    this.logMessage(LogLevel.Fatal, message, args);
  }
  logMessage(level, logMessageType, args) {
    if (this._runtime.level > level) {
      return;
    }
    const nowMillis = Date.now();
    const message = typeof logMessageType === "string" ? logMessageType : logMessageType();
    const errorAndArgs = CoreLoggerImpl.getErrorAndArgs(args);
    switch (this._runtime.channel.type) {
      case "RawLogChannel":
        this._runtime.channel.write({ message, exception: errorAndArgs.error, args: errorAndArgs.args, timeInMillis: nowMillis, level, logNames: this._runtime.name }, this._runtime.argumentFormatter);
        return;
      case "LogChannel":
        this._runtime.channel.write(this.createLogMessage(message, level, errorAndArgs, nowMillis));
        break;
    }
  }
  formatArgValue(value) {
    try {
      return this._runtime.argumentFormatter(value);
    } catch (e2) {
      return `>>ARG CONVERT FAILED: '${value !== void 0 ? value.toString() : "undefined"}'<<`;
    }
  }
  createLogMessage(message, level, errorAndArgs, nowMillis) {
    let errorResult;
    const error = errorAndArgs.error;
    const args = errorAndArgs.args;
    if (error) {
      errorResult = `${error.name}: ${error.message}`;
      if (error.stack) {
        errorResult += `@
${error.stack}`;
      }
    }
    const dateFormatted = this._runtime.dateFormatter(nowMillis);
    let levelAsStr = LogLevel[level].toUpperCase();
    if (levelAsStr.length < 5) {
      levelAsStr += " ";
    }
    const names = typeof this._runtime.name === "string" ? this._runtime.name : this._runtime.name.join(", ");
    const argsFormatted = typeof args !== "undefined" && args.length > 0 ? " [" + args.map((arg) => this.formatArgValue(arg)).join(", ") + "]" : "";
    const completedMessage = dateFormatted + " " + levelAsStr + " [" + names + "] " + message + argsFormatted;
    return { message: completedMessage, error: errorResult };
  }
  static getErrorAndArgs(args) {
    if (args.length === 0) {
      return {};
    }
    let error;
    let actualArgs;
    const value0 = args[0];
    if (value0 instanceof Error) {
      error = value0;
      actualArgs = args.length > 1 ? args.slice(1) : void 0;
      return { error, args: actualArgs };
    }
    if (typeof value0 === "function") {
      const errorOrArgs = value0();
      if (errorOrArgs instanceof Error) {
        error = errorOrArgs;
        actualArgs = args.length > 1 ? args.slice(1) : void 0;
        return { error, args: actualArgs };
      }
      if (args.length === 1) {
        if (Array.isArray(errorOrArgs)) {
          return { args: errorOrArgs.length > 0 ? errorOrArgs : void 0 };
        } else {
          return { args: errorOrArgs };
        }
      } else {
        if (Array.isArray(errorOrArgs)) {
          return { args: [...errorOrArgs, ...args.slice(1)] };
        }
        return { args: [errorOrArgs, ...args.slice(1)] };
      }
    }
    return { args };
  }
}
function padStart(value, length2, fillChar = " ") {
  return padInternal(value, length2, "start", fillChar);
}
function padEnd(value, length2, fillChar = " ") {
  return padInternal(value, length2, "end", fillChar);
}
function maxLengthStringValueInArray(arr) {
  return arr.map((v2) => v2.length).reduce((previous, current) => {
    if (current > previous) {
      return current;
    }
    return previous;
  }, 0);
}
function padInternal(value, length2, padType, fillChar = " ") {
  if (length2 <= value.length) {
    return value;
  }
  if (fillChar.length > 1) {
    throw new Error(`Fill char must be one char exactly, it is: ${fillChar.length}`);
  }
  const charsNeeded = length2 - value.length;
  let padding = "";
  for (let i2 = 0; i2 < charsNeeded; i2++) {
    padding += fillChar;
  }
  if (padType === "start") {
    return padding + value;
  }
  return value + padding;
}
function formatArgument(arg) {
  if (arg === void 0) {
    return "undefined";
  }
  return JSON.stringify(arg);
}
function formatDate(millisSinceEpoch) {
  const date = new Date(millisSinceEpoch);
  const year = date.getFullYear();
  const month = padStart((date.getMonth() + 1).toString(), 2, "0");
  const day = padStart(date.getDate().toString(), 2, "0");
  const hours = padStart(date.getHours().toString(), 2, "0");
  const minutes = padStart(date.getMinutes().toString(), 2, "0");
  const seconds = padStart(date.getSeconds().toString(), 2, "0");
  const millis = padStart(date.getMilliseconds().toString(), 2, "0");
  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds},${millis}`;
}
class ConsoleLogChannel {
  constructor() {
    this.type = "LogChannel";
  }
  write(msg) {
    if (console && console.log) {
      console.log(msg.message + (msg.error ? `
${msg.error}` : ""));
    }
  }
}
var DefaultChannels;
(function(DefaultChannels2) {
  function createConsoleChannel() {
    return new ConsoleLogChannel();
  }
  DefaultChannels2.createConsoleChannel = createConsoleChannel;
})(DefaultChannels || (DefaultChannels = {}));
class LogProviderImpl {
  constructor(name2, settings) {
    this._log = getInternalLogger("core.impl.LogProviderImpl");
    this._name = name2;
    this._settings = settings;
    this._loggers = new EnhancedMap();
    this._idToKeyMap = new EnhancedMap();
    this._globalRuntimeSettings = { level: settings.level, channel: settings.channel };
    this._nextLoggerId = 1;
    this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);
  }
  get runtimeSettings() {
    return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });
  }
  getLogger(name2) {
    return this.getOrCreateLogger(name2);
  }
  updateLoggerRuntime(log2, settings) {
    this._log.debug(() => `Updating logger ${log2.id} runtime settings using: '${JSON.stringify(settings)}'`);
    const key = this._idToKeyMap.get(log2.id);
    if (key === void 0) {
      this._log.warn(() => `Cannot update logger with id: ${log2.id}, it was not found.`);
      return false;
    }
    this._loggers.computeIfPresent(key, (currentKey, currentValue) => {
      currentValue.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(currentValue.runtimeSettings, settings);
      return currentValue;
    });
    return true;
  }
  updateRuntimeSettings(settings) {
    this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(settings)}'`);
    this._globalRuntimeSettings = { level: settings.level !== void 0 ? settings.level : this._globalRuntimeSettings.level, channel: settings.channel !== void 0 ? settings.channel : this._globalRuntimeSettings.channel };
    this._loggers.forEach((logger2) => logger2.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(logger2.runtimeSettings, settings));
  }
  clear() {
    this._loggers.clear();
    this._idToKeyMap.clear();
    this._globalRuntimeSettings = Object.assign({}, this._settings);
    this._nextLoggerId = 1;
  }
  getOrCreateLogger(name2) {
    const key = LogProviderImpl.createKey(name2);
    const logger2 = this._loggers.computeIfAbsent(key, () => {
      const runtime = { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel, id: this.nextLoggerId(), name: name2, argumentFormatter: this._settings.argumentFormatter, dateFormatter: this._settings.dateFormatter };
      return new CoreLoggerImpl(runtime);
    });
    this._idToKeyMap.computeIfAbsent(logger2.id, () => key);
    return logger2;
  }
  nextLoggerId() {
    const result = this._name + "_" + this._nextLoggerId;
    this._nextLoggerId++;
    return result;
  }
  static mergeRuntimeSettingsIntoLogRuntime(currentSettings, settings) {
    return Object.assign(Object.assign({}, currentSettings), { level: settings.level !== void 0 ? settings.level : currentSettings.level, channel: settings.channel !== void 0 ? settings.channel : currentSettings.channel });
  }
  static createKey(name2) {
    if (typeof name2 === "string") {
      return name2;
    }
    return name2.join(",");
  }
}
function createLogProvider(name2, settings) {
  return new LogProviderImpl(name2, settings);
}
var index$3 = /* @__PURE__ */ Object.freeze({ __proto__: null, EnhancedMap, padStart, padEnd, maxLengthStringValueInArray });
class CategoryImpl {
  constructor(logger2, name2, parent2, fnGetOrCreateChildCategory) {
    this._children = [];
    this._logger = logger2;
    this._name = name2;
    this._parent = parent2;
    this._fnGetOrCreateChildCategory = fnGetOrCreateChildCategory;
  }
  get name() {
    return this._name;
  }
  get parent() {
    return this._parent;
  }
  get path() {
    const result = [];
    let tmpCat = this;
    while (tmpCat !== void 0) {
      result.push(tmpCat.name);
      tmpCat = tmpCat.parent;
    }
    return result.reverse();
  }
  get children() {
    return [...this._children];
  }
  addChild(childCategory) {
    if (childCategory.parent !== this) {
      throw new Error(`Cannot add child '${childCategory.name}', expected parent '${this._name} but got ${childCategory.parent ? childCategory.parent.name : "undefined"}'`);
    }
    this._children.push(childCategory);
  }
  getChildCategory(name2) {
    const existing = this._children.find((c) => c.name === name2);
    if (existing !== void 0) {
      return existing;
    }
    return this._fnGetOrCreateChildCategory(name2, this);
  }
  get id() {
    return this._logger.id;
  }
  get logLevel() {
    return this._logger.logLevel;
  }
  get runtimeSettings() {
    return this._logger.runtimeSettings;
  }
  get logger() {
    return this._logger;
  }
  trace(message, ...args) {
    this._logger.trace(message, ...args);
  }
  debug(message, ...args) {
    this._logger.debug(message, ...args);
  }
  info(message, ...args) {
    this._logger.info(message, ...args);
  }
  warn(message, ...args) {
    this._logger.warn(message, ...args);
  }
  error(message, ...args) {
    this._logger.error(message, ...args);
  }
  fatal(message, ...args) {
    this._logger.fatal(message, ...args);
  }
}
const CATEGORY_PATH_SEPARATOR = "#";
class CategoryProviderImpl {
  constructor(name2, config2) {
    this._name = name2;
    this._initialConfig = config2;
    this._categoryStorage = new CategoryStorage(name2, config2);
  }
  get name() {
    return this._name;
  }
  get config() {
    return this._initialConfig;
  }
  get runtimeConfig() {
    return this._categoryStorage.getCurrentRuntimeConfig();
  }
  getCategory(name2, parent2) {
    return this._categoryStorage.getOrCreateCategory(name2, parent2);
  }
  updateRuntimeSettingsCategory(category, settings) {
    this._categoryStorage.updateRuntimeSettingsCategory(category, settings);
  }
  updateRuntimeSettings(settings) {
    this._categoryStorage.updateRuntimeSettings(settings);
  }
  getRegisteredCategories() {
    return this._categoryStorage.getRegisteredCategories();
  }
  getCategoryByPath(path) {
    return this._categoryStorage.getCategoryByPath(path);
  }
}
class CategoryStorage {
  constructor(categoryProviderName, config2) {
    this._categoriesById = /* @__PURE__ */ new Map();
    this._categoriesByPath = /* @__PURE__ */ new Map();
    this._categoryProviderName = categoryProviderName;
    this._allowSameCategoryName = config2.allowSameCategoryName;
    this._logProvider = createLogProvider(categoryProviderName, Object.assign({}, config2));
    this.getOrCreateCategory = this.getOrCreateCategory.bind(this);
  }
  getOrCreateCategory(name2, parent2) {
    if (name2.indexOf(CATEGORY_PATH_SEPARATOR) !== -1) {
      throw new Error(`Cannot create category '${name2}', name cannot contain a '${CATEGORY_PATH_SEPARATOR}'.`);
    }
    const parentCategory = parent2 !== void 0 ? this.getParentCategory(parent2) : void 0;
    if (parentCategory === void 0) {
      return this.getOrCreateRootCategory(name2);
    }
    return this.getOrCreateChildCategory(name2, parentCategory);
  }
  updateRuntimeSettingsCategory(category, settings) {
    if (!category.id.startsWith(this._categoryProviderName)) {
      throw new Error(`Category '${category.name}' with LogId '${category.id}' is from a different CategoryProvider, cannot mix categories between providers.`);
    }
    const categoryImpl = this._categoriesById.get(category.id);
    if (categoryImpl === void 0) {
      return;
    }
    this._logProvider.updateLoggerRuntime(categoryImpl.logger, { level: settings.level });
    if (settings.disableRecursion !== void 0 && settings.disableRecursion) {
      return;
    }
    categoryImpl.children.forEach((childCategory) => this.updateRuntimeSettingsCategory(childCategory, settings));
  }
  updateRuntimeSettings(settings) {
    this._logProvider.updateRuntimeSettings(settings);
  }
  getCurrentRuntimeConfig() {
    return Object.assign(Object.assign({}, this._logProvider.runtimeSettings), { allowSameCategoryName: this._allowSameCategoryName });
  }
  getRegisteredCategories() {
    return [...this._categoriesById.values()];
  }
  getCategoryByPath(path) {
    return this._categoriesByPath.get(path);
  }
  getParentCategory(parent2) {
    let parentCategory;
    if (CategoryStorage.isLogId(parent2)) {
      parentCategory = this._categoriesById.get(parent2);
      if (parentCategory === void 0) {
        throw new Error(`Parent category was not found by LogId '${parent2}'. Are you sure you passed in the correct argument?`);
      }
    } else {
      parentCategory = this._categoriesById.get(parent2.id);
      if (parentCategory === void 0) {
        throw new Error(`Parent category '${parent2.name}' was not found by it's LogId '${parent2.id}'. Are you sure you passed in the correct parent category?`);
      }
    }
    return parentCategory;
  }
  getOrCreateRootCategory(name2) {
    const existingCategory = this._categoriesByPath.get(name2);
    if (existingCategory) {
      if (!this._allowSameCategoryName) {
        throw new Error(`Category '${name2} already exists, config flag allowSameCategoryName=false - therefore matching version 1 behavior (hence this Error)`);
      }
      return existingCategory;
    }
    const logger2 = this._logProvider.getLogger(name2);
    const category = new CategoryImpl(logger2, name2, void 0, this.getOrCreateCategory);
    this._categoriesById.set(category.id, category);
    this._categoriesByPath.set(name2, category);
    return category;
  }
  getOrCreateChildCategory(name2, parentCategory) {
    if (!parentCategory.id.startsWith(this._categoryProviderName)) {
      throw new Error(`Parent category '${parentCategory.name}' with LogId '${parentCategory.id}' is from a different CategoryProvider, cannot mix categories between providers.`);
    }
    const path = [...parentCategory.path, name2].join(CATEGORY_PATH_SEPARATOR);
    const existingChildCategory = this._categoriesByPath.get(path);
    if (existingChildCategory) {
      if (!this._allowSameCategoryName) {
        throw new Error(`Child category '${name2} already exists for parent category ${parentCategory.name}, config flag allowSameCategoryName=false - therefore matching version 1 behavior (hence this Error)`);
      }
      return existingChildCategory;
    }
    const logger2 = this._logProvider.getLogger(path);
    this._logProvider.updateLoggerRuntime(logger2, { level: parentCategory.logger.runtimeSettings.level, channel: parentCategory.logger.runtimeSettings.channel });
    const childCategory = new CategoryImpl(logger2, name2, parentCategory, this.getOrCreateCategory);
    this._categoriesById.set(childCategory.id, childCategory);
    this._categoriesByPath.set(childCategory.path.join(CATEGORY_PATH_SEPARATOR), childCategory);
    parentCategory.addChild(childCategory);
    return childCategory;
  }
  static isLogId(parent2) {
    return typeof parent2 === "string";
  }
}
class CategoryControlProviderImpl {
  constructor(provider2, messageChannel) {
    this._provider = provider2;
    this._messageChannel = messageChannel;
    this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(provider2);
  }
  get name() {
    return this._provider.name;
  }
  showSettings() {
    let result = `Available categories (CategoryProvider '${this._provider.name}'):
`;
    const categories = this.createCategoryInfoHierarchy();
    const maxWidthIndex = categories.size.toString().length;
    const maxWidthIdentifier = index$3.maxLengthStringValueInArray([...categories.values()].map((value) => value.category.name + " ".repeat(value.depth)));
    const providerLines = [...categories.values()].map((category, idx) => CategoryControlProviderImpl.createSettingLineCategory(category, idx, maxWidthIndex, maxWidthIdentifier));
    result += providerLines.join("\n") + (providerLines.length > 0 ? "\n" : "");
    this._messageChannel(result);
  }
  help() {
    const msg = `You can use the following commands (CategoryProvider ${this._provider.name}):
  showSettings()
    Shows the current configuration settings.
  update(level: CategoryControlProviderLogLevel, categoryId?: number | string, noRecurse?: boolean)
    Change the log level for a category (by default recursively).
      @param level      The log level to set - must be one of 'trace', 'debug', 'info', 'warn', 'error' or 'fatal'
      @param categoryId The category id or path of a category (e.g. root#child1) to update. Use showSettings() for id and/or name.
                        When omitted, it applies the level to all categories recursively.
  reset()
    Resets the log levels of the config groups back to when this control provider was created.
  save()
    Saves the current log levels for all categories of this provider. Use restore() to load last saved state.
  restore()
    Restore stored saved state, if any. Log levels will be set according to the saved state.
  help()
    Shows this help.
`;
    this._messageChannel(msg);
  }
  reset() {
    const currentCategories = new Map(this._provider.getRegisteredCategories().map((cat) => [cat.id, cat]));
    this._originalLogLevels.forEach((value, key) => {
      const category = currentCategories.get(key);
      if (category !== void 0) {
        this._provider.updateRuntimeSettingsCategory(category, { level: value, disableRecursion: true });
      }
      currentCategories.delete(key);
    });
    currentCategories.forEach((category) => {
      if (category.parent !== void 0) {
        this._provider.updateRuntimeSettingsCategory(category, { level: category.parent.logLevel, disableRecursion: true });
      }
    });
    this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(this._provider);
    this._messageChannel("Successfully reset log levels back to original state (from when this CategoryControlProvider was created).");
  }
  save() {
    if (!localStorage) {
      this._messageChannel("Cannot save state, localStorage is not available.");
      return;
    }
    const saveDataForAllRootCategories = this._provider.getRegisteredCategories().filter((cat) => cat.parent === void 0).map((rootCategory) => CategoryControlProviderImpl.createCategorySaveData(rootCategory));
    const saveData = { name: this._provider.name, rootCategories: saveDataForAllRootCategories };
    localStorage.setItem(this.createKey(), JSON.stringify(saveData));
    this._messageChannel(`Successfully saved state for CategoryControlProvider '${this._provider.name}'.`);
  }
  restore(logRestoreFailures) {
    const finalLogRestoreFailures = logRestoreFailures !== void 0 ? logRestoreFailures : true;
    if (!localStorage) {
      if (finalLogRestoreFailures) {
        this._messageChannel(`Will not attempt to restore state for CategoryControlProvider '${this._provider.name}', localStorage is not available.`);
      }
      return;
    }
    const key = this.createKey();
    const value = localStorage.getItem(key);
    if (value === null) {
      if (finalLogRestoreFailures) {
        this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', no data available.`);
      }
      return;
    }
    try {
      const savedData = JSON.parse(value);
      if (this._provider.name !== savedData.name) {
        if (finalLogRestoreFailures) {
          this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', data is not for provider - found name '${savedData.name}'.`);
        }
        return;
      }
      this.restoreBySaveData(savedData, finalLogRestoreFailures);
      this._messageChannel(`Successfully restored state for CategoryControlProvider '${this._provider.name}'`);
      this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(this._provider);
    } catch (e2) {
      localStorage.removeItem(key);
      this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', data is not valid. Invalid data removed from localStorage.`);
    }
  }
  update(level, categoryId, noRecurse) {
    if (typeof categoryId === "undefined") {
      this.updateAll(level);
    } else if (typeof categoryId === "number") {
      this.updateByIndex(level, categoryId, noRecurse !== void 0 ? noRecurse : false);
    } else {
      this.updateByPath(level, categoryId, noRecurse !== void 0 ? noRecurse : false);
    }
  }
  updateAll(level) {
    const logLevel = LogLevel.toLogLevel(level);
    this._provider.getRegisteredCategories().filter((cat) => cat.parent === void 0).forEach((cat) => this._provider.updateRuntimeSettingsCategory(cat, { level: logLevel }));
    this._messageChannel(`Updated all categories to use log level '${level.toLowerCase()}'`);
  }
  updateByPath(level, path, noRecurse) {
    const category = this._provider.getCategoryByPath(path);
    if (category === void 0) {
      this._messageChannel(`Failed to find a provider by path '${path}', please make sure to separate the parts by a ${CATEGORY_PATH_SEPARATOR}.`);
      return;
    }
    this._provider.updateRuntimeSettingsCategory(category, { level: LogLevel.toLogLevel(level), disableRecursion: noRecurse });
    this._messageChannel(`Successfully updated category '${category.name}' with path '${path}' to log level '${level.toLowerCase()}'${noRecurse ? "" : " and recursively applied to children (if any)"}.`);
  }
  updateByIndex(level, index2, noRecurse) {
    if (index2 < 0) {
      this._messageChannel(`Cannot update category by index '${index2}', it is negative.`);
      return;
    }
    const categories = this.createCategoryInfoHierarchy();
    if (index2 >= categories.size) {
      this._messageChannel(`Cannot update category by index '${index2}', it is outside of the range of available categories, use showSettings() to see the indices.`);
      return;
    }
    const category = [...categories.values()][index2].category;
    this._provider.updateRuntimeSettingsCategory(category, { level: LogLevel.toLogLevel(level), disableRecursion: noRecurse });
    this._messageChannel(`Successfully updated category '${category.name}' by index '${index2}' to log level '${level.toLowerCase()}'${noRecurse ? "" : " and recursively applied to children (if any)"}.`);
  }
  restoreBySaveData(saveData, logCannotRestore) {
    const restoreCategory = (categorySaveData, currentPath) => {
      const newPath = currentPath.length > 0 ? currentPath + CATEGORY_PATH_SEPARATOR + categorySaveData.name : categorySaveData.name;
      const category = this._provider.getCategoryByPath(newPath);
      if (category !== void 0) {
        const newLevel = LogLevel.toLogLevel(categorySaveData.level);
        if (newLevel !== void 0) {
          this._provider.updateRuntimeSettingsCategory(category, { level: newLevel, disableRecursion: true });
        } else if (logCannotRestore) {
          this._messageChannel(`CategoryControlProvider '${this._provider.name}' - cannot restore log level for category path '${newPath}', log level is invalid.`);
        }
        for (const childSaveData of categorySaveData.children) {
          restoreCategory(childSaveData, newPath);
        }
      } else if (logCannotRestore) {
        this._messageChannel(`CategoryControlProvider '${this._provider.name}' - failed to find a Category by path '${newPath}', will not restore category (and children)`);
      }
    };
    for (const rootSaveData of saveData.rootCategories) {
      restoreCategory(rootSaveData, "");
    }
  }
  createKey() {
    return `CategoryProvider-${this._provider.name}`;
  }
  createCategoryInfoHierarchy() {
    const result = /* @__PURE__ */ new Map();
    const rootCategories = this._provider.getRegisteredCategories().filter((cat) => cat.parent === void 0);
    rootCategories.forEach((category) => CategoryControlProviderImpl.addCategoryInfoHierarchy(category, 0, result));
    return result;
  }
  static createCategorySaveData(category) {
    return { name: category.name, level: LogLevel[category.logLevel], children: category.children.map((child) => this.createCategorySaveData(child)) };
  }
  static loadCurrentGroupLogLevels(provider2) {
    return new Map(provider2.getRegisteredCategories().map((category) => [category.id, category.logLevel]));
  }
  static createSettingLineCategory(categoryInfo, index$12, maxWidthIndex, maxWidthIdentifier) {
    const prefix = " ".repeat(categoryInfo.depth);
    const catName = prefix + categoryInfo.category.name;
    return `  [${index$3.padStart(index$12.toString(), maxWidthIndex)}, ${index$3.padEnd(catName, maxWidthIdentifier)} (level=${index$3.padEnd(categoryInfo.logLevel, 5)})]`;
  }
  static addCategoryInfoHierarchy(category, currentDepth, result) {
    result.set(category.id, { category, logLevel: LogLevel[category.logLevel], depth: currentDepth });
    category.children.forEach((child) => this.addCategoryInfoHierarchy(child, currentDepth + 1, result));
  }
}
function categoryConfigDebug(config2) {
  return `CategoryConfig=level: ${LogLevel[config2.level].toString()}, allowSameCategoryName=${config2.allowSameCategoryName}`;
}
class CategoryProviderService {
  constructor() {
    this._log = InternalLogger.getInternalLogger("category.impl.CategoryProviderService");
    this._providers = new index$3.EnhancedMap();
  }
  createLogProvider(name2, config2) {
    const result = this._providers.compute(name2, (key, currentValue) => {
      if (currentValue) {
        throw new Error(`CategoryProvider with name '${name2}' already exists, cannot create another.`);
      }
      const finalConfig = mergeWithDefaults(config2);
      this._log.debug(() => `Creating new CategoryProvider with name '${name2}', using config settings '${categoryConfigDebug(finalConfig)}'.`);
      return new CategoryProviderImpl(name2, finalConfig);
    });
    if (result) {
      return result;
    }
    throw new Error("No CategoryProvider? This is a bug.");
  }
  getCategoryControl(fnValue) {
    const fnMessageChannel = fnValue ? fnValue : (value) => {
      if (console && console.log) {
        console.log(value);
      } else {
        throw new Error("Cannot use console (it is not present), please specify a custom function to write to.");
      }
    };
    return { help: () => fnMessageChannel(CategoryProviderService.help()), showSettings: () => fnMessageChannel(this.showSettings()), getProvider: (id2) => this.getCategoryControlProviderByIdOrName(id2, fnMessageChannel) };
  }
  clear() {
    this._providers.clear();
  }
  showSettings() {
    let result = "Available CategoryProviders:\n";
    const maxWidthIndex = this._providers.size.toString().length;
    const maxWidthName = index$3.maxLengthStringValueInArray([...this._providers.keys()]);
    const lines = [...this._providers.entries()].map((entry, index$12) => {
      const name2 = entry[0];
      return `  [${index$3.padStart(index$12.toString(), maxWidthIndex)}, ${index$3.padEnd(name2, maxWidthName)}]`;
    });
    result += lines.join("\n") + (lines.length > 0 ? "\n" : "");
    return result;
  }
  getCategoryControlProviderByIdOrName(id2, messageChannel) {
    if (typeof id2 === "string") {
      const provider2 = this._providers.get(id2);
      if (provider2 === void 0) {
        throw new Error(`Provider with name '${id2}' does not exist.`);
      }
      return new CategoryControlProviderImpl(provider2, messageChannel);
    }
    const providers = [...this._providers.values()];
    if (id2 < 0 || id2 >= providers.length) {
      throw new Error(`Provider with index '${id2}' does not exist (outside of range).`);
    }
    return new CategoryControlProviderImpl(providers[id2], messageChannel);
  }
  static help() {
    return "You can use the following commands:\n  showSettings()\n    Shows the current configuration settings.\n  getProvider: (id: number | string): CategoryControlProvider\n    Get access to a CategoryControlProvider to change log levels.\n      @param id The id (use showSettings to see) or name of the provider\n  help()\n    Shows this help.\n";
  }
}
const CATEGORY_PROVIDER_SERVICE = new CategoryProviderService();
const CATEGORY_LOG_CONTROL = (fnValue) => CATEGORY_PROVIDER_SERVICE.getCategoryControl(fnValue);
function mergeWithDefaults(config2) {
  const defaultConfig = { channel: DefaultChannels.createConsoleChannel(), allowSameCategoryName: true, level: LogLevel.Error, dateFormatter: formatDate, argumentFormatter: formatArgument };
  if (!config2) {
    return defaultConfig;
  }
  return { channel: config2.channel ? config2.channel : defaultConfig.channel, allowSameCategoryName: config2.allowSameCategoryName !== void 0 ? config2.allowSameCategoryName : defaultConfig.allowSameCategoryName, level: config2.level ? config2.level : defaultConfig.level, dateFormatter: config2.dateFormatter ? config2.dateFormatter : defaultConfig.dateFormatter, argumentFormatter: config2.argumentFormatter ? config2.argumentFormatter : defaultConfig.argumentFormatter };
}
var CategoryProvider;
(function(CategoryProvider2) {
  function createProvider(name2, config2) {
    return CATEGORY_PROVIDER_SERVICE.createLogProvider(name2, config2);
  }
  CategoryProvider2.createProvider = createProvider;
  function clear() {
    CATEGORY_PROVIDER_SERVICE.clear();
  }
  CategoryProvider2.clear = clear;
})(CategoryProvider || (CategoryProvider = {}));
var typescriptLoggingCategory_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, CATEGORY_LOG_CONTROL, get CategoryProvider() {
  return CategoryProvider;
} }, Symbol.toStringTag, { value: "Module" }));
var require$$1 = /* @__PURE__ */ getAugmentedNamespace(typescriptLoggingCategory_esm);
Object.defineProperty(logger$1, "__esModule", { value: true });
logger$1.logger = void 0;
const typescript_logging_1 = require$$2$1;
const typescript_logging_category_style_1 = require$$1;
logger$1.logger = typescript_logging_category_style_1.CategoryProvider.createProvider("ApiStream", { allowSameCategoryName: true, level: typescript_logging_1.LogLevel.Warn });
var version$2 = "1.0.19";
var __createBinding$5 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o2, k2, desc);
} : function(o2, m2, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o2[k2] = m2[k];
});
var __setModuleDefault$5 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$5 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k in mod2)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
        __createBinding$5(result, mod2, k);
  }
  __setModuleDefault$5(result, mod2);
  return result;
};
var __importDefault$h = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(api$2, "__esModule", { value: true });
api$2.ApiClient = void 0;
const NiceGrpc$1 = __importStar$5(lib$1);
const abort_controller_x_1 = require$$1$1;
const detect_node_1 = __importDefault$h(browser$2);
const NodeTransport = __importStar$5(require$$3);
const logger_1$8 = logger$1;
const clientVersion$1 = version$2;
class ApiClient {
  constructor(sessionId, server, sdkVersion, logCategory, apiLogCallback, eventLogCallback) {
    this.sessionId = sessionId;
    this.sdkVersion = sdkVersion;
    this.version = clientVersion$1;
    this.apiLogCallback = apiLogCallback;
    this.eventLogCallback = eventLogCallback;
    this.log = logger_1$8.logger.getCategory(logCategory);
    this.channel = NiceGrpc$1.createChannel(server, detect_node_1.default ? NodeTransport.NodeHttpTransport() : void 0);
    this.clientFactory = NiceGrpc$1.createClientFactory().use(this.logMiddleware.bind(this));
  }
  async *logMiddleware(call, options2) {
    const { path } = call.method;
    try {
      const result = yield* call.next(call.request, options2);
      this.log.debug(`-> ${path}: ok`);
      this.log.trace(`${JSON.stringify(call.request)} -> ${path}: ${JSON.stringify(result)}`);
      if (this.apiLogCallback) {
        let parts = path.split("/");
        let serviceParts = parts[1].split(".");
        let service2 = serviceParts[serviceParts.length - 1];
        let version2 = serviceParts[serviceParts.length - 2];
        let api2 = serviceParts[serviceParts.length - 3];
        let func = parts[2];
        this.apiLogCallback(api2, service2, func, call.request, result);
      }
      return result;
    } catch (error) {
      this.log.trace(`${JSON.stringify(call.request)} -> ${path}`);
      if (error instanceof NiceGrpc$1.ClientError) {
        this.log.warn(`-> ${path}: error: ${NiceGrpc$1.Status[error.code]}: ${error.details}`);
      } else if ((0, abort_controller_x_1.isAbortError)(error)) {
        this.log.warn(`-> ${path}: cancel`);
      } else {
        this.log.warn(`-> ${path}: error: ${error === null || error === void 0 ? void 0 : error.stack}`);
      }
      throw error;
    }
  }
  setAccessToken(accessToken) {
    if (this.accessToken == void 0 || this.accessToken != accessToken) {
      this.log.debug("access token refreshed");
      this.accessToken = accessToken;
      this.setup();
    }
  }
  makeGrpcMetadata() {
    let metadata = NiceGrpc$1.Metadata({ Authorization: `Bearer ${this.accessToken}`, Version: this.version, SessionId: this.sessionId });
    if (this.sdkVersion != void 0) {
      metadata.set("SdkVersion", this.sdkVersion);
    }
    return metadata;
  }
  setup() {
    let options2 = { metadata: this.makeGrpcMetadata() };
    this._setup(options2);
  }
  _setup(options2) {
  }
}
api$2.ApiClient = ApiClient;
var decorator = {};
Object.defineProperty(decorator, "__esModule", { value: true });
decorator.RequiresSdkAuthentication = void 0;
function RequiresSdkAuthentication() {
  return function(target, propertyKey) {
    let value;
    Object.defineProperty(target, propertyKey, { get: () => {
      if (!value) {
        throw new Error("Please authenticate ApiStream by calling apiStream.load( accessToken )");
      }
      return value;
    }, set: (val) => {
      value = val;
    } });
  };
}
decorator.RequiresSdkAuthentication = RequiresSdkAuthentication;
var __createBinding$4 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o2, k2, desc);
} : function(o2, m2, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o2[k2] = m2[k];
});
var __setModuleDefault$4 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __decorate = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d = decorators[i2])
        r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __importStar$4 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k in mod2)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
        __createBinding$4(result, mod2, k);
  }
  __setModuleDefault$4(result, mod2);
  return result;
};
var __metadata = commonjsGlobal && commonjsGlobal.__metadata || function(k, v2) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v2);
};
Object.defineProperty(layoutapi, "__esModule", { value: true });
layoutapi.LayoutApi = void 0;
__importStar$4(lib$1);
const LayoutApiModel = __importStar$4(dist$3);
const api_1$1 = api$2;
const decorator_1 = decorator;
const LOG_CATEGORY$1 = "LayoutApi";
class LayoutApi extends api_1$1.ApiClient {
  constructor(sessionId, eventApi, server, sdkVersion, apiLogCallback) {
    super(sessionId, server, sdkVersion, LOG_CATEGORY$1, apiLogCallback);
    this.handlers = {};
    this.eventApi = eventApi;
    this.eventApi.on("event", { name: `${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:*`, ignoreSessionEvents: true }, (evt) => {
      var _a2;
      const [, eventName] = evt.name.split(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:`);
      const [type, subtype] = eventName.split(":");
      const payload = evt.payload;
      for (const handler of (_a2 = this.handlers[type]) !== null && _a2 !== void 0 ? _a2 : []) {
        handler(Object.values(payload).find((i2) => !!i2), subtype);
      }
    });
  }
  _setup(options2) {
    this.layer = this.clientFactory.create(LayoutApiModel.LayerServiceDefinition, this.channel, { "*": options2 });
    this.layout = this.clientFactory.create(LayoutApiModel.LayoutServiceDefinition, this.channel, { "*": options2 });
  }
  async subscribeToLayout(layoutId) {
    await Promise.all([this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { layoutId } }), this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { layoutId } })]);
  }
  async unsubscribeFromLayout(layoutId) {
    await Promise.all([this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { layoutId } }), this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { layoutId } })]);
  }
  async subscribeToLayoutsInProject(collectionId, projectId) {
    await Promise.all([this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { collectionId, projectId } }), this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { collectionId, projectId } })]);
  }
  async unsubscribeFromLayoutsInProject(collectionId, projectId) {
    await Promise.all([this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { collectionId, projectId } }), this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { collectionId, projectId } })]);
  }
  on(type, handler) {
    var _a2;
    this.handlers[type] = (_a2 = this.handlers[type]) !== null && _a2 !== void 0 ? _a2 : [];
    this.handlers[type].push(handler);
  }
  off(type, handler) {
    this.handlers[type] = this.handlers[type].filter((i2) => i2 !== handler);
  }
}
LayoutApi.LAYOUTAPI_EVENT_PREFIX = "apistream:layout";
__decorate([(0, decorator_1.RequiresSdkAuthentication)(), __metadata("design:type", Object)], LayoutApi.prototype, "layout", void 0);
__decorate([(0, decorator_1.RequiresSdkAuthentication)(), __metadata("design:type", Object)], LayoutApi.prototype, "layer", void 0);
layoutapi.LayoutApi = LayoutApi;
var liveapi = {};
var api$1 = {};
var timestamp$1 = {};
var __createBinding$3 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o2, k2, desc);
} : function(o2, m2, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o2[k2] = m2[k];
});
var __setModuleDefault$3 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k in mod2)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
        __createBinding$3(result, mod2, k);
  }
  __setModuleDefault$3(result, mod2);
  return result;
};
var __importDefault$g = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(timestamp$1, "__esModule", { value: true });
timestamp$1.Timestamp = timestamp$1.protobufPackage = void 0;
const long_1$1 = __importDefault$g(umd.exports);
const _m0$1 = __importStar$3(minimal);
timestamp$1.protobufPackage = "google.protobuf";
function createBaseTimestamp() {
  return { seconds: 0, nanos: 0 };
}
timestamp$1.Timestamp = { encode(message, writer2 = _m0$1.Writer.create()) {
  if (message.seconds !== 0) {
    writer2.uint32(8).int64(message.seconds);
  }
  if (message.nanos !== 0) {
    writer2.uint32(16).int32(message.nanos);
  }
  return writer2;
}, decode(input, length2) {
  const reader2 = input instanceof _m0$1.Reader ? input : new _m0$1.Reader(input);
  let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
  const message = createBaseTimestamp();
  while (reader2.pos < end2) {
    const tag = reader2.uint32();
    switch (tag >>> 3) {
      case 1:
        message.seconds = longToNumber(reader2.int64());
        break;
      case 2:
        message.nanos = reader2.int32();
        break;
      default:
        reader2.skipType(tag & 7);
        break;
    }
  }
  return message;
}, fromJSON(object) {
  return { seconds: isSet(object.seconds) ? Number(object.seconds) : 0, nanos: isSet(object.nanos) ? Number(object.nanos) : 0 };
}, toJSON(message) {
  const obj = {};
  message.seconds !== void 0 && (obj.seconds = Math.round(message.seconds));
  message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
  return obj;
}, fromPartial(object) {
  var _a2, _b;
  const message = createBaseTimestamp();
  message.seconds = (_a2 = object.seconds) !== null && _a2 !== void 0 ? _a2 : 0;
  message.nanos = (_b = object.nanos) !== null && _b !== void 0 ? _b : 0;
  return message;
} };
var globalThis$1 = (() => {
  if (typeof globalThis$1 !== "undefined")
    return globalThis$1;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof commonjsGlobal !== "undefined")
    return commonjsGlobal;
  throw "Unable to locate global object";
})();
function longToNumber(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis$1.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (_m0$1.util.Long !== long_1$1.default) {
  _m0$1.util.Long = long_1$1.default;
  _m0$1.configure();
}
function isSet(value) {
  return value !== null && value !== void 0;
}
var struct$1 = {};
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ListValue = exports2.Value = exports2.Struct_FieldsEntry = exports2.Struct = exports2.nullValueToNumber = exports2.nullValueToJSON = exports2.nullValueFromJSON = exports2.NullValue = exports2.protobufPackage = void 0;
  const long_12 = __importDefault2(umd.exports);
  const _m02 = __importStar2(minimal);
  exports2.protobufPackage = "google.protobuf";
  var NullValue;
  (function(NullValue2) {
    NullValue2["NULL_VALUE"] = "NULL_VALUE";
  })(NullValue = exports2.NullValue || (exports2.NullValue = {}));
  function nullValueFromJSON(object) {
    switch (object) {
      case 0:
      case "NULL_VALUE":
        return NullValue.NULL_VALUE;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum NullValue");
    }
  }
  exports2.nullValueFromJSON = nullValueFromJSON;
  function nullValueToJSON(object) {
    switch (object) {
      case NullValue.NULL_VALUE:
        return "NULL_VALUE";
      default:
        return "UNKNOWN";
    }
  }
  exports2.nullValueToJSON = nullValueToJSON;
  function nullValueToNumber(object) {
    switch (object) {
      case NullValue.NULL_VALUE:
        return 0;
      default:
        return 0;
    }
  }
  exports2.nullValueToNumber = nullValueToNumber;
  function createBaseStruct() {
    return { fields: {} };
  }
  exports2.Struct = { encode(message, writer2 = _m02.Writer.create()) {
    Object.entries(message.fields).forEach(([key, value]) => {
      if (value !== void 0) {
        exports2.Struct_FieldsEntry.encode({ key, value }, writer2.uint32(10).fork()).ldelim();
      }
    });
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStruct();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = exports2.Struct_FieldsEntry.decode(reader2, reader2.uint32());
          if (entry1.value !== void 0) {
            message.fields[entry1.key] = entry1.value;
          }
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { fields: isObject2(object.fields) ? Object.entries(object.fields).reduce((acc, [key, value]) => {
      acc[key] = value;
      return acc;
    }, {}) : {} };
  }, toJSON(message) {
    const obj = {};
    obj.fields = {};
    if (message.fields) {
      Object.entries(message.fields).forEach(([k, v2]) => {
        obj.fields[k] = v2;
      });
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseStruct();
    message.fields = Object.entries((_a2 = object.fields) !== null && _a2 !== void 0 ? _a2 : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = value;
      }
      return acc;
    }, {});
    return message;
  }, wrap(object) {
    const struct2 = createBaseStruct();
    if (object !== void 0) {
      Object.keys(object).forEach((key) => {
        struct2.fields[key] = object[key];
      });
    }
    return struct2;
  }, unwrap(message) {
    const object = {};
    Object.keys(message.fields).forEach((key) => {
      object[key] = message.fields[key];
    });
    return object;
  } };
  function createBaseStruct_FieldsEntry() {
    return { key: "", value: void 0 };
  }
  exports2.Struct_FieldsEntry = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.key !== "") {
      writer2.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      exports2.Value.encode(exports2.Value.wrap(message.value), writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStruct_FieldsEntry();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader2.string();
          break;
        case 2:
          message.value = exports2.Value.unwrap(exports2.Value.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { key: isSet2(object.key) ? String(object.key) : "", value: isSet2(object === null || object === void 0 ? void 0 : object.value) ? object.value : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseStruct_FieldsEntry();
    message.key = (_a2 = object.key) !== null && _a2 !== void 0 ? _a2 : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : void 0;
    return message;
  } };
  function createBaseValue() {
    return { nullValue: void 0, numberValue: void 0, stringValue: void 0, boolValue: void 0, structValue: void 0, listValue: void 0 };
  }
  exports2.Value = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.nullValue !== void 0) {
      writer2.uint32(8).int32(nullValueToNumber(message.nullValue));
    }
    if (message.numberValue !== void 0) {
      writer2.uint32(17).double(message.numberValue);
    }
    if (message.stringValue !== void 0) {
      writer2.uint32(26).string(message.stringValue);
    }
    if (message.boolValue !== void 0) {
      writer2.uint32(32).bool(message.boolValue);
    }
    if (message.structValue !== void 0) {
      exports2.Struct.encode(exports2.Struct.wrap(message.structValue), writer2.uint32(42).fork()).ldelim();
    }
    if (message.listValue !== void 0) {
      exports2.ListValue.encode(exports2.ListValue.wrap(message.listValue), writer2.uint32(50).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseValue();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.nullValue = nullValueFromJSON(reader2.int32());
          break;
        case 2:
          message.numberValue = reader2.double();
          break;
        case 3:
          message.stringValue = reader2.string();
          break;
        case 4:
          message.boolValue = reader2.bool();
          break;
        case 5:
          message.structValue = exports2.Struct.unwrap(exports2.Struct.decode(reader2, reader2.uint32()));
          break;
        case 6:
          message.listValue = exports2.ListValue.unwrap(exports2.ListValue.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { nullValue: isSet2(object.nullValue) ? nullValueFromJSON(object.nullValue) : void 0, numberValue: isSet2(object.numberValue) ? Number(object.numberValue) : void 0, stringValue: isSet2(object.stringValue) ? String(object.stringValue) : void 0, boolValue: isSet2(object.boolValue) ? Boolean(object.boolValue) : void 0, structValue: isObject2(object.structValue) ? object.structValue : void 0, listValue: Array.isArray(object.listValue) ? [...object.listValue] : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.nullValue !== void 0 && (obj.nullValue = message.nullValue !== void 0 ? nullValueToJSON(message.nullValue) : void 0);
    message.numberValue !== void 0 && (obj.numberValue = message.numberValue);
    message.stringValue !== void 0 && (obj.stringValue = message.stringValue);
    message.boolValue !== void 0 && (obj.boolValue = message.boolValue);
    message.structValue !== void 0 && (obj.structValue = message.structValue);
    message.listValue !== void 0 && (obj.listValue = message.listValue);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f;
    const message = createBaseValue();
    message.nullValue = (_a2 = object.nullValue) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.numberValue = (_b = object.numberValue) !== null && _b !== void 0 ? _b : void 0;
    message.stringValue = (_c = object.stringValue) !== null && _c !== void 0 ? _c : void 0;
    message.boolValue = (_d = object.boolValue) !== null && _d !== void 0 ? _d : void 0;
    message.structValue = (_e = object.structValue) !== null && _e !== void 0 ? _e : void 0;
    message.listValue = (_f = object.listValue) !== null && _f !== void 0 ? _f : void 0;
    return message;
  }, wrap(value) {
    const result = createBaseValue();
    if (value === null) {
      result.nullValue = NullValue.NULL_VALUE;
    } else if (typeof value === "boolean") {
      result.boolValue = value;
    } else if (typeof value === "number") {
      result.numberValue = value;
    } else if (typeof value === "string") {
      result.stringValue = value;
    } else if (Array.isArray(value)) {
      result.listValue = value;
    } else if (typeof value === "object") {
      result.structValue = value;
    } else if (typeof value !== "undefined") {
      throw new Error("Unsupported any value type: " + typeof value);
    }
    return result;
  }, unwrap(message) {
    if ((message === null || message === void 0 ? void 0 : message.stringValue) !== void 0) {
      return message.stringValue;
    } else if ((message === null || message === void 0 ? void 0 : message.numberValue) !== void 0) {
      return message.numberValue;
    } else if ((message === null || message === void 0 ? void 0 : message.boolValue) !== void 0) {
      return message.boolValue;
    } else if ((message === null || message === void 0 ? void 0 : message.structValue) !== void 0) {
      return message.structValue;
    } else if ((message === null || message === void 0 ? void 0 : message.listValue) !== void 0) {
      return message.listValue;
    } else if ((message === null || message === void 0 ? void 0 : message.nullValue) !== void 0) {
      return null;
    }
    return void 0;
  } };
  function createBaseListValue() {
    return { values: [] };
  }
  exports2.ListValue = { encode(message, writer2 = _m02.Writer.create()) {
    for (const v2 of message.values) {
      exports2.Value.encode(exports2.Value.wrap(v2), writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseListValue();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.values.push(exports2.Value.unwrap(exports2.Value.decode(reader2, reader2.uint32())));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { values: Array.isArray(object === null || object === void 0 ? void 0 : object.values) ? [...object.values] : [] };
  }, toJSON(message) {
    const obj = {};
    if (message.values) {
      obj.values = message.values.map((e2) => e2);
    } else {
      obj.values = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseListValue();
    message.values = ((_a2 = object.values) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
    return message;
  }, wrap(value) {
    const result = createBaseListValue();
    result.values = value !== null && value !== void 0 ? value : [];
    return result;
  }, unwrap(message) {
    return message.values;
  } };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal !== "undefined")
      return commonjsGlobal;
    throw "Unable to locate global object";
  })();
  if (_m02.util.Long !== long_12.default) {
    _m02.util.Long = long_12.default;
    _m02.configure();
  }
  function isObject2(value) {
    return typeof value === "object" && value !== null;
  }
  function isSet2(value) {
    return value !== null && value !== void 0;
  }
})(struct$1);
var field_mask = {};
var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o2, k2, desc);
} : function(o2, m2, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o2[k2] = m2[k];
});
var __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k in mod2)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
        __createBinding$2(result, mod2, k);
  }
  __setModuleDefault$2(result, mod2);
  return result;
};
var __importDefault$f = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(field_mask, "__esModule", { value: true });
field_mask.FieldMask = field_mask.protobufPackage = void 0;
const long_1 = __importDefault$f(umd.exports);
const _m0 = __importStar$2(minimal);
field_mask.protobufPackage = "google.protobuf";
function createBaseFieldMask() {
  return { paths: [] };
}
field_mask.FieldMask = { encode(message, writer2 = _m0.Writer.create()) {
  for (const v2 of message.paths) {
    writer2.uint32(10).string(v2);
  }
  return writer2;
}, decode(input, length2) {
  const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
  let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
  const message = createBaseFieldMask();
  while (reader2.pos < end2) {
    const tag = reader2.uint32();
    switch (tag >>> 3) {
      case 1:
        message.paths.push(reader2.string());
        break;
      default:
        reader2.skipType(tag & 7);
        break;
    }
  }
  return message;
}, fromJSON(object) {
  return { paths: typeof object === "string" ? object.split(",").filter(Boolean) : Array.isArray(object === null || object === void 0 ? void 0 : object.paths) ? object.paths.map(String) : [] };
}, toJSON(message) {
  return message.paths.join(",");
}, fromPartial(object) {
  var _a2;
  const message = createBaseFieldMask();
  message.paths = ((_a2 = object.paths) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
  return message;
}, wrap(paths) {
  return { paths };
}, unwrap(message) {
  return message.paths;
} };
if (_m0.util.Long !== long_1.default) {
  _m0.util.Long = long_1.default;
  _m0.configure();
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Role = exports2.regionToNumber = exports2.regionToJSON = exports2.regionFromJSON = exports2.Region = exports2.sourceTriggerActionToNumber = exports2.sourceTriggerActionToJSON = exports2.sourceTriggerActionFromJSON = exports2.SourceTriggerAction = exports2.s3ACLToNumber = exports2.s3ACLToJSON = exports2.s3ACLFromJSON = exports2.S3ACL = exports2.projectBroadcastPhaseToNumber = exports2.projectBroadcastPhaseToJSON = exports2.projectBroadcastPhaseFromJSON = exports2.ProjectBroadcastPhase = exports2.videoCodecRateControlModeToNumber = exports2.videoCodecRateControlModeToJSON = exports2.videoCodecRateControlModeFromJSON = exports2.VideoCodecRateControlMode = exports2.audioCodecToNumber = exports2.audioCodecToJSON = exports2.audioCodecFromJSON = exports2.AudioCodec = exports2.videoCodecProfileToNumber = exports2.videoCodecProfileToJSON = exports2.videoCodecProfileFromJSON = exports2.VideoCodecProfile = exports2.videoCodecToNumber = exports2.videoCodecToJSON = exports2.videoCodecFromJSON = exports2.VideoCodec = exports2.renderingQualityToNumber = exports2.renderingQualityToJSON = exports2.renderingQualityFromJSON = exports2.RenderingQuality = exports2.audioChannelLayoutToNumber = exports2.audioChannelLayoutToJSON = exports2.audioChannelLayoutFromJSON = exports2.AudioChannelLayout = exports2.videoColorSpaceToNumber = exports2.videoColorSpaceToJSON = exports2.videoColorSpaceFromJSON = exports2.VideoColorSpace = exports2.imageFormatToNumber = exports2.imageFormatToJSON = exports2.imageFormatFromJSON = exports2.ImageFormat = exports2.protobufPackage = void 0;
  exports2.HostedWebRtc = exports2.Composition = exports2.ExternalComposition = exports2.SceneComposition = exports2.StudioSdkComposition = exports2.PreviewAddress = exports2.PreviewWebRtcAddress = exports2.PreviewHlsPullAddress = exports2.ProjectTrigger = exports2.WebRtcTrigger = exports2.SourceTrigger = exports2.DestinationAddress = exports2.S3StorageAddress = exports2.ObjectStoragePackaging = exports2.HlsPackaging = exports2.HlsLifecycle = exports2.HlsLifecycleVod = exports2.HlsLifecycleLive = exports2.DestinationAgoraPushAddress = exports2.DestinationRtmpPushAddress = exports2.SourceAddress = exports2.RtmpPullAddress = exports2.SrtPushAddress = exports2.SourceRtmpPushAddress = exports2.Encoding = exports2.AudioEncoding = exports2.VideoEncoding = exports2.VideoCodecRateControl = exports2.Rendering = exports2.AudioRendering = exports2.VideoRendering = exports2.eventTypeToNumber = exports2.eventTypeToJSON = exports2.eventTypeFromJSON = exports2.EventType = exports2.eventSubTypeToNumber = exports2.eventSubTypeToJSON = exports2.eventSubTypeFromJSON = exports2.EventSubType = exports2.connectStateToNumber = exports2.connectStateToJSON = exports2.connectStateFromJSON = exports2.ConnectState = exports2.projectBroadcastErrorToNumber = exports2.projectBroadcastErrorToJSON = exports2.projectBroadcastErrorFromJSON = exports2.ProjectBroadcastError = exports2.roleToNumber = exports2.roleToJSON = exports2.roleFromJSON = void 0;
  exports2.DeleteSourceResponse = exports2.DeleteSourceRequest = exports2.CreateSourceResponse = exports2.CreateSourceRequest = exports2.UpdateDestinationResponse = exports2.UpdateDestinationRequest = exports2.DeleteDestinationResponse = exports2.DeleteDestinationRequest = exports2.GetDestinationResponse = exports2.GetDestinationRequest = exports2.CreateDestinationResponse = exports2.CreateDestinationRequest = exports2.StopProjectWebRtcResponse = exports2.StopProjectWebRtcRequest = exports2.StartProjectWebRtcResponse = exports2.StartProjectWebRtcRequest = exports2.GetProjectBroadcastStatusResponse = exports2.GetProjectBroadcastStatusRequest = exports2.GetProjectBroadcastSnapshotResponse = exports2.GetProjectBroadcastSnapshotRequest = exports2.GetProjectResponse = exports2.GetProjectRequest = exports2.StopProjectBroadcastResponse = exports2.StopProjectBroadcastRequest = exports2.StartProjectBroadcastResponse = exports2.StartProjectBroadcastRequest = exports2.DeleteProjectResponse = exports2.DeleteProjectRequest = exports2.UpdateProjectResponse = exports2.UpdateProjectRequest = exports2.CreateProjectResponse = exports2.CreateProjectRequest = exports2.GetCollectionsResponse = exports2.GetCollectionsRequest = exports2.DeleteCollectionResponse = exports2.DeleteCollectionRequest = exports2.UpdateCollectionResponse = exports2.UpdateCollectionRequest = exports2.GetCollectionResponse = exports2.GetCollectionRequest = exports2.CreateCollectionResponse = exports2.CreateCollectionRequest = exports2.Collection = exports2.Project = exports2.Destination = exports2.Source = exports2.ProjectBroadcastStatus = exports2.LatLong = exports2.WebRtcAccess = exports2.WebRtc = void 0;
  exports2.DestinationEvent = exports2.CollectionEvent = exports2.SourceStateEvent = exports2.SourceRemoveEvent = exports2.SourceAddEvent = exports2.SourceUpdateEvent = exports2.SourceDeleteEvent = exports2.SourceCreateEvent = exports2.CollectionUpdateEvent = exports2.CollectionDeleteEvent = exports2.CollectionCreateEvent = exports2.ProjectBroadcastStateEvent = exports2.ProjectUpdateEvent = exports2.ProjectDeleteEvent = exports2.ProjectCreateEvent = exports2.DestinationStateEvent = exports2.DestinationUpdateEvent = exports2.DestinationDeleteEvent = exports2.DestinationCreateEvent = exports2.GetTestTokenResponse = exports2.GetTestTokenRequest = exports2.GetJsonWebKeySetResponse = exports2.GetJsonWebKeySetRequest = exports2.JsonWebKey = exports2.GuestCodeRedirectResponse = exports2.GuestCodeRedirectRequest = exports2.GuestCode = exports2.RefreshAccessTokenResponse = exports2.RefreshAccessTokenRequest = exports2.CreateWebRtcAccessTokenResponse = exports2.CreateWebRtcAccessTokenRequest = exports2.CreateGuestAccessTokenResponse = exports2.CreateGuestAccessTokenRequest = exports2.GuestAccessToken = exports2.GuestAccessTokenExchange = exports2.GuestAccessTokenDirect = exports2.CreateAccessTokenResponse = exports2.CreateAccessTokenRequest = exports2.RemoveSourceFromProjectResponse = exports2.RemoveSourceFromProjectRequest = exports2.UpdateSourceResponse = exports2.UpdateSourceRequest = exports2.GetSourcesResponse = exports2.GetSourcesRequest = exports2.GetSourceResponse = exports2.GetSourceRequest = exports2.UpdateSourceInProjectResponse = exports2.UpdateSourceInProjectRequest = exports2.AddSourceToProjectResponse = exports2.AddSourceToProjectRequest = void 0;
  exports2.PublicAuthenticationServiceDefinition = exports2.PublicAuthenticationServiceClientImpl = exports2.AuthenticationServiceDefinition = exports2.AuthenticationServiceClientImpl = exports2.BackendAuthenticationServiceDefinition = exports2.BackendAuthenticationServiceClientImpl = exports2.SourceServiceDefinition = exports2.SourceServiceClientImpl = exports2.DestinationServiceDefinition = exports2.DestinationServiceClientImpl = exports2.ProjectServiceDefinition = exports2.ProjectServiceClientImpl = exports2.CollectionServiceDefinition = exports2.CollectionServiceClientImpl = exports2.LiveEvent = exports2.SourceEvent = exports2.ProjectEvent = void 0;
  const long_12 = __importDefault2(umd.exports);
  const _m02 = __importStar2(minimal);
  const timestamp_1 = timestamp$1;
  const struct_1 = struct$1;
  const field_mask_1 = field_mask;
  exports2.protobufPackage = "live.v21";
  var ImageFormat;
  (function(ImageFormat2) {
    ImageFormat2["IMAGE_FORMAT_UNSPECIFIED"] = "IMAGE_FORMAT_UNSPECIFIED";
    ImageFormat2["IMAGE_FORMAT_JPEG"] = "IMAGE_FORMAT_JPEG";
  })(ImageFormat = exports2.ImageFormat || (exports2.ImageFormat = {}));
  function imageFormatFromJSON(object) {
    switch (object) {
      case 0:
      case "IMAGE_FORMAT_UNSPECIFIED":
        return ImageFormat.IMAGE_FORMAT_UNSPECIFIED;
      case 1:
      case "IMAGE_FORMAT_JPEG":
        return ImageFormat.IMAGE_FORMAT_JPEG;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum ImageFormat");
    }
  }
  exports2.imageFormatFromJSON = imageFormatFromJSON;
  function imageFormatToJSON(object) {
    switch (object) {
      case ImageFormat.IMAGE_FORMAT_UNSPECIFIED:
        return "IMAGE_FORMAT_UNSPECIFIED";
      case ImageFormat.IMAGE_FORMAT_JPEG:
        return "IMAGE_FORMAT_JPEG";
      default:
        return "UNKNOWN";
    }
  }
  exports2.imageFormatToJSON = imageFormatToJSON;
  function imageFormatToNumber(object) {
    switch (object) {
      case ImageFormat.IMAGE_FORMAT_UNSPECIFIED:
        return 0;
      case ImageFormat.IMAGE_FORMAT_JPEG:
        return 1;
      default:
        return 0;
    }
  }
  exports2.imageFormatToNumber = imageFormatToNumber;
  var VideoColorSpace;
  (function(VideoColorSpace2) {
    VideoColorSpace2["VIDEO_COLOR_SPACE_UNSPECIFIED"] = "VIDEO_COLOR_SPACE_UNSPECIFIED";
    VideoColorSpace2["VIDEO_COLOR_SPACE_YUV420"] = "VIDEO_COLOR_SPACE_YUV420";
  })(VideoColorSpace = exports2.VideoColorSpace || (exports2.VideoColorSpace = {}));
  function videoColorSpaceFromJSON(object) {
    switch (object) {
      case 0:
      case "VIDEO_COLOR_SPACE_UNSPECIFIED":
        return VideoColorSpace.VIDEO_COLOR_SPACE_UNSPECIFIED;
      case 1:
      case "VIDEO_COLOR_SPACE_YUV420":
        return VideoColorSpace.VIDEO_COLOR_SPACE_YUV420;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum VideoColorSpace");
    }
  }
  exports2.videoColorSpaceFromJSON = videoColorSpaceFromJSON;
  function videoColorSpaceToJSON(object) {
    switch (object) {
      case VideoColorSpace.VIDEO_COLOR_SPACE_UNSPECIFIED:
        return "VIDEO_COLOR_SPACE_UNSPECIFIED";
      case VideoColorSpace.VIDEO_COLOR_SPACE_YUV420:
        return "VIDEO_COLOR_SPACE_YUV420";
      default:
        return "UNKNOWN";
    }
  }
  exports2.videoColorSpaceToJSON = videoColorSpaceToJSON;
  function videoColorSpaceToNumber(object) {
    switch (object) {
      case VideoColorSpace.VIDEO_COLOR_SPACE_UNSPECIFIED:
        return 0;
      case VideoColorSpace.VIDEO_COLOR_SPACE_YUV420:
        return 1;
      default:
        return 0;
    }
  }
  exports2.videoColorSpaceToNumber = videoColorSpaceToNumber;
  var AudioChannelLayout;
  (function(AudioChannelLayout2) {
    AudioChannelLayout2["AUDIO_CHANNEL_LAYOUT_UNSPECIFIED"] = "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED";
    AudioChannelLayout2["AUDIO_CHANNEL_LAYOUT_STEREO"] = "AUDIO_CHANNEL_LAYOUT_STEREO";
  })(AudioChannelLayout = exports2.AudioChannelLayout || (exports2.AudioChannelLayout = {}));
  function audioChannelLayoutFromJSON(object) {
    switch (object) {
      case 0:
      case "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED":
        return AudioChannelLayout.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED;
      case 1:
      case "AUDIO_CHANNEL_LAYOUT_STEREO":
        return AudioChannelLayout.AUDIO_CHANNEL_LAYOUT_STEREO;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum AudioChannelLayout");
    }
  }
  exports2.audioChannelLayoutFromJSON = audioChannelLayoutFromJSON;
  function audioChannelLayoutToJSON(object) {
    switch (object) {
      case AudioChannelLayout.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED:
        return "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED";
      case AudioChannelLayout.AUDIO_CHANNEL_LAYOUT_STEREO:
        return "AUDIO_CHANNEL_LAYOUT_STEREO";
      default:
        return "UNKNOWN";
    }
  }
  exports2.audioChannelLayoutToJSON = audioChannelLayoutToJSON;
  function audioChannelLayoutToNumber(object) {
    switch (object) {
      case AudioChannelLayout.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED:
        return 0;
      case AudioChannelLayout.AUDIO_CHANNEL_LAYOUT_STEREO:
        return 1;
      default:
        return 0;
    }
  }
  exports2.audioChannelLayoutToNumber = audioChannelLayoutToNumber;
  var RenderingQuality2;
  (function(RenderingQuality3) {
    RenderingQuality3["RENDERING_QUALITY_UNSPECIFIED"] = "RENDERING_QUALITY_UNSPECIFIED";
    RenderingQuality3["RENDERING_QUALITY_STANDARD"] = "RENDERING_QUALITY_STANDARD";
    RenderingQuality3["RENDERING_QUALITY_HIGH"] = "RENDERING_QUALITY_HIGH";
  })(RenderingQuality2 = exports2.RenderingQuality || (exports2.RenderingQuality = {}));
  function renderingQualityFromJSON(object) {
    switch (object) {
      case 0:
      case "RENDERING_QUALITY_UNSPECIFIED":
        return RenderingQuality2.RENDERING_QUALITY_UNSPECIFIED;
      case 1:
      case "RENDERING_QUALITY_STANDARD":
        return RenderingQuality2.RENDERING_QUALITY_STANDARD;
      case 2:
      case "RENDERING_QUALITY_HIGH":
        return RenderingQuality2.RENDERING_QUALITY_HIGH;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum RenderingQuality");
    }
  }
  exports2.renderingQualityFromJSON = renderingQualityFromJSON;
  function renderingQualityToJSON(object) {
    switch (object) {
      case RenderingQuality2.RENDERING_QUALITY_UNSPECIFIED:
        return "RENDERING_QUALITY_UNSPECIFIED";
      case RenderingQuality2.RENDERING_QUALITY_STANDARD:
        return "RENDERING_QUALITY_STANDARD";
      case RenderingQuality2.RENDERING_QUALITY_HIGH:
        return "RENDERING_QUALITY_HIGH";
      default:
        return "UNKNOWN";
    }
  }
  exports2.renderingQualityToJSON = renderingQualityToJSON;
  function renderingQualityToNumber(object) {
    switch (object) {
      case RenderingQuality2.RENDERING_QUALITY_UNSPECIFIED:
        return 0;
      case RenderingQuality2.RENDERING_QUALITY_STANDARD:
        return 1;
      case RenderingQuality2.RENDERING_QUALITY_HIGH:
        return 2;
      default:
        return 0;
    }
  }
  exports2.renderingQualityToNumber = renderingQualityToNumber;
  var VideoCodec2;
  (function(VideoCodec3) {
    VideoCodec3["VIDEO_CODEC_UNSPECIFIED"] = "VIDEO_CODEC_UNSPECIFIED";
    VideoCodec3["VIDEO_CODEC_H264"] = "VIDEO_CODEC_H264";
  })(VideoCodec2 = exports2.VideoCodec || (exports2.VideoCodec = {}));
  function videoCodecFromJSON(object) {
    switch (object) {
      case 0:
      case "VIDEO_CODEC_UNSPECIFIED":
        return VideoCodec2.VIDEO_CODEC_UNSPECIFIED;
      case 1:
      case "VIDEO_CODEC_H264":
        return VideoCodec2.VIDEO_CODEC_H264;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum VideoCodec");
    }
  }
  exports2.videoCodecFromJSON = videoCodecFromJSON;
  function videoCodecToJSON(object) {
    switch (object) {
      case VideoCodec2.VIDEO_CODEC_UNSPECIFIED:
        return "VIDEO_CODEC_UNSPECIFIED";
      case VideoCodec2.VIDEO_CODEC_H264:
        return "VIDEO_CODEC_H264";
      default:
        return "UNKNOWN";
    }
  }
  exports2.videoCodecToJSON = videoCodecToJSON;
  function videoCodecToNumber(object) {
    switch (object) {
      case VideoCodec2.VIDEO_CODEC_UNSPECIFIED:
        return 0;
      case VideoCodec2.VIDEO_CODEC_H264:
        return 1;
      default:
        return 0;
    }
  }
  exports2.videoCodecToNumber = videoCodecToNumber;
  var VideoCodecProfile2;
  (function(VideoCodecProfile3) {
    VideoCodecProfile3["VIDEO_CODEC_PROFILE_UNSPECIFIED"] = "VIDEO_CODEC_PROFILE_UNSPECIFIED";
    VideoCodecProfile3["VIDEO_CODEC_PROFILE_BASELINE"] = "VIDEO_CODEC_PROFILE_BASELINE";
    VideoCodecProfile3["VIDEO_CODEC_PROFILE_MAIN"] = "VIDEO_CODEC_PROFILE_MAIN";
    VideoCodecProfile3["VIDEO_CODEC_PROFILE_HIGH"] = "VIDEO_CODEC_PROFILE_HIGH";
  })(VideoCodecProfile2 = exports2.VideoCodecProfile || (exports2.VideoCodecProfile = {}));
  function videoCodecProfileFromJSON(object) {
    switch (object) {
      case 0:
      case "VIDEO_CODEC_PROFILE_UNSPECIFIED":
        return VideoCodecProfile2.VIDEO_CODEC_PROFILE_UNSPECIFIED;
      case 2:
      case "VIDEO_CODEC_PROFILE_BASELINE":
        return VideoCodecProfile2.VIDEO_CODEC_PROFILE_BASELINE;
      case 3:
      case "VIDEO_CODEC_PROFILE_MAIN":
        return VideoCodecProfile2.VIDEO_CODEC_PROFILE_MAIN;
      case 4:
      case "VIDEO_CODEC_PROFILE_HIGH":
        return VideoCodecProfile2.VIDEO_CODEC_PROFILE_HIGH;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum VideoCodecProfile");
    }
  }
  exports2.videoCodecProfileFromJSON = videoCodecProfileFromJSON;
  function videoCodecProfileToJSON(object) {
    switch (object) {
      case VideoCodecProfile2.VIDEO_CODEC_PROFILE_UNSPECIFIED:
        return "VIDEO_CODEC_PROFILE_UNSPECIFIED";
      case VideoCodecProfile2.VIDEO_CODEC_PROFILE_BASELINE:
        return "VIDEO_CODEC_PROFILE_BASELINE";
      case VideoCodecProfile2.VIDEO_CODEC_PROFILE_MAIN:
        return "VIDEO_CODEC_PROFILE_MAIN";
      case VideoCodecProfile2.VIDEO_CODEC_PROFILE_HIGH:
        return "VIDEO_CODEC_PROFILE_HIGH";
      default:
        return "UNKNOWN";
    }
  }
  exports2.videoCodecProfileToJSON = videoCodecProfileToJSON;
  function videoCodecProfileToNumber(object) {
    switch (object) {
      case VideoCodecProfile2.VIDEO_CODEC_PROFILE_UNSPECIFIED:
        return 0;
      case VideoCodecProfile2.VIDEO_CODEC_PROFILE_BASELINE:
        return 2;
      case VideoCodecProfile2.VIDEO_CODEC_PROFILE_MAIN:
        return 3;
      case VideoCodecProfile2.VIDEO_CODEC_PROFILE_HIGH:
        return 4;
      default:
        return 0;
    }
  }
  exports2.videoCodecProfileToNumber = videoCodecProfileToNumber;
  var AudioCodec2;
  (function(AudioCodec3) {
    AudioCodec3["AUDIO_CODEC_UNSPECIFIED"] = "AUDIO_CODEC_UNSPECIFIED";
    AudioCodec3["AUDIO_CODEC_AAC"] = "AUDIO_CODEC_AAC";
  })(AudioCodec2 = exports2.AudioCodec || (exports2.AudioCodec = {}));
  function audioCodecFromJSON(object) {
    switch (object) {
      case 0:
      case "AUDIO_CODEC_UNSPECIFIED":
        return AudioCodec2.AUDIO_CODEC_UNSPECIFIED;
      case 1:
      case "AUDIO_CODEC_AAC":
        return AudioCodec2.AUDIO_CODEC_AAC;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum AudioCodec");
    }
  }
  exports2.audioCodecFromJSON = audioCodecFromJSON;
  function audioCodecToJSON(object) {
    switch (object) {
      case AudioCodec2.AUDIO_CODEC_UNSPECIFIED:
        return "AUDIO_CODEC_UNSPECIFIED";
      case AudioCodec2.AUDIO_CODEC_AAC:
        return "AUDIO_CODEC_AAC";
      default:
        return "UNKNOWN";
    }
  }
  exports2.audioCodecToJSON = audioCodecToJSON;
  function audioCodecToNumber(object) {
    switch (object) {
      case AudioCodec2.AUDIO_CODEC_UNSPECIFIED:
        return 0;
      case AudioCodec2.AUDIO_CODEC_AAC:
        return 1;
      default:
        return 0;
    }
  }
  exports2.audioCodecToNumber = audioCodecToNumber;
  var VideoCodecRateControlMode;
  (function(VideoCodecRateControlMode2) {
    VideoCodecRateControlMode2["VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED"] = "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED";
    VideoCodecRateControlMode2["VIDEO_CODEC_RATE_CONTROL_MODE_CBR"] = "VIDEO_CODEC_RATE_CONTROL_MODE_CBR";
  })(VideoCodecRateControlMode = exports2.VideoCodecRateControlMode || (exports2.VideoCodecRateControlMode = {}));
  function videoCodecRateControlModeFromJSON(object) {
    switch (object) {
      case 0:
      case "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED":
        return VideoCodecRateControlMode.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED;
      case 1:
      case "VIDEO_CODEC_RATE_CONTROL_MODE_CBR":
        return VideoCodecRateControlMode.VIDEO_CODEC_RATE_CONTROL_MODE_CBR;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum VideoCodecRateControlMode");
    }
  }
  exports2.videoCodecRateControlModeFromJSON = videoCodecRateControlModeFromJSON;
  function videoCodecRateControlModeToJSON(object) {
    switch (object) {
      case VideoCodecRateControlMode.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED:
        return "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED";
      case VideoCodecRateControlMode.VIDEO_CODEC_RATE_CONTROL_MODE_CBR:
        return "VIDEO_CODEC_RATE_CONTROL_MODE_CBR";
      default:
        return "UNKNOWN";
    }
  }
  exports2.videoCodecRateControlModeToJSON = videoCodecRateControlModeToJSON;
  function videoCodecRateControlModeToNumber(object) {
    switch (object) {
      case VideoCodecRateControlMode.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED:
        return 0;
      case VideoCodecRateControlMode.VIDEO_CODEC_RATE_CONTROL_MODE_CBR:
        return 1;
      default:
        return 0;
    }
  }
  exports2.videoCodecRateControlModeToNumber = videoCodecRateControlModeToNumber;
  var ProjectBroadcastPhase2;
  (function(ProjectBroadcastPhase3) {
    ProjectBroadcastPhase3["PROJECT_BROADCAST_PHASE_UNSPECIFIED"] = "PROJECT_BROADCAST_PHASE_UNSPECIFIED";
    ProjectBroadcastPhase3["PROJECT_BROADCAST_PHASE_NOT_RUNNING"] = "PROJECT_BROADCAST_PHASE_NOT_RUNNING";
    ProjectBroadcastPhase3["PROJECT_BROADCAST_PHASE_WAITING"] = "PROJECT_BROADCAST_PHASE_WAITING";
    ProjectBroadcastPhase3["PROJECT_BROADCAST_PHASE_STARTING"] = "PROJECT_BROADCAST_PHASE_STARTING";
    ProjectBroadcastPhase3["PROJECT_BROADCAST_PHASE_RUNNING"] = "PROJECT_BROADCAST_PHASE_RUNNING";
    ProjectBroadcastPhase3["PROJECT_BROADCAST_PHASE_STOPPING"] = "PROJECT_BROADCAST_PHASE_STOPPING";
    ProjectBroadcastPhase3["PROJECT_BROADCAST_PHASE_STOPPED"] = "PROJECT_BROADCAST_PHASE_STOPPED";
    ProjectBroadcastPhase3["PROJECT_BROADCAST_PHASE_ARCHIVED"] = "PROJECT_BROADCAST_PHASE_ARCHIVED";
  })(ProjectBroadcastPhase2 = exports2.ProjectBroadcastPhase || (exports2.ProjectBroadcastPhase = {}));
  function projectBroadcastPhaseFromJSON(object) {
    switch (object) {
      case 0:
      case "PROJECT_BROADCAST_PHASE_UNSPECIFIED":
        return ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_UNSPECIFIED;
      case 1:
      case "PROJECT_BROADCAST_PHASE_NOT_RUNNING":
        return ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_NOT_RUNNING;
      case 2:
      case "PROJECT_BROADCAST_PHASE_WAITING":
        return ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_WAITING;
      case 3:
      case "PROJECT_BROADCAST_PHASE_STARTING":
        return ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STARTING;
      case 4:
      case "PROJECT_BROADCAST_PHASE_RUNNING":
        return ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_RUNNING;
      case 5:
      case "PROJECT_BROADCAST_PHASE_STOPPING":
        return ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STOPPING;
      case 6:
      case "PROJECT_BROADCAST_PHASE_STOPPED":
        return ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STOPPED;
      case 7:
      case "PROJECT_BROADCAST_PHASE_ARCHIVED":
        return ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_ARCHIVED;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum ProjectBroadcastPhase");
    }
  }
  exports2.projectBroadcastPhaseFromJSON = projectBroadcastPhaseFromJSON;
  function projectBroadcastPhaseToJSON(object) {
    switch (object) {
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_UNSPECIFIED:
        return "PROJECT_BROADCAST_PHASE_UNSPECIFIED";
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_NOT_RUNNING:
        return "PROJECT_BROADCAST_PHASE_NOT_RUNNING";
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_WAITING:
        return "PROJECT_BROADCAST_PHASE_WAITING";
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STARTING:
        return "PROJECT_BROADCAST_PHASE_STARTING";
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_RUNNING:
        return "PROJECT_BROADCAST_PHASE_RUNNING";
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STOPPING:
        return "PROJECT_BROADCAST_PHASE_STOPPING";
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STOPPED:
        return "PROJECT_BROADCAST_PHASE_STOPPED";
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_ARCHIVED:
        return "PROJECT_BROADCAST_PHASE_ARCHIVED";
      default:
        return "UNKNOWN";
    }
  }
  exports2.projectBroadcastPhaseToJSON = projectBroadcastPhaseToJSON;
  function projectBroadcastPhaseToNumber(object) {
    switch (object) {
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_UNSPECIFIED:
        return 0;
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_NOT_RUNNING:
        return 1;
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_WAITING:
        return 2;
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STARTING:
        return 3;
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_RUNNING:
        return 4;
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STOPPING:
        return 5;
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STOPPED:
        return 6;
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_ARCHIVED:
        return 7;
      default:
        return 0;
    }
  }
  exports2.projectBroadcastPhaseToNumber = projectBroadcastPhaseToNumber;
  var S3ACL;
  (function(S3ACL2) {
    S3ACL2["S3ACL_UNSPECIFIED"] = "S3ACL_UNSPECIFIED";
    S3ACL2["S3ACL_PRIVATE"] = "S3ACL_PRIVATE";
    S3ACL2["S3ACL_PUBLIC_READ"] = "S3ACL_PUBLIC_READ";
    S3ACL2["S3ACL_PUBLIC_READ_WRITE"] = "S3ACL_PUBLIC_READ_WRITE";
    S3ACL2["S3ACL_AUTHENTICATED_READ"] = "S3ACL_AUTHENTICATED_READ";
    S3ACL2["S3ACL_BUCKET_OWNER_READ"] = "S3ACL_BUCKET_OWNER_READ";
    S3ACL2["S3ACL_BUCKET_OWNER_FULL_CONTROL"] = "S3ACL_BUCKET_OWNER_FULL_CONTROL";
  })(S3ACL = exports2.S3ACL || (exports2.S3ACL = {}));
  function s3ACLFromJSON(object) {
    switch (object) {
      case 0:
      case "S3ACL_UNSPECIFIED":
        return S3ACL.S3ACL_UNSPECIFIED;
      case 1:
      case "S3ACL_PRIVATE":
        return S3ACL.S3ACL_PRIVATE;
      case 2:
      case "S3ACL_PUBLIC_READ":
        return S3ACL.S3ACL_PUBLIC_READ;
      case 3:
      case "S3ACL_PUBLIC_READ_WRITE":
        return S3ACL.S3ACL_PUBLIC_READ_WRITE;
      case 4:
      case "S3ACL_AUTHENTICATED_READ":
        return S3ACL.S3ACL_AUTHENTICATED_READ;
      case 5:
      case "S3ACL_BUCKET_OWNER_READ":
        return S3ACL.S3ACL_BUCKET_OWNER_READ;
      case 6:
      case "S3ACL_BUCKET_OWNER_FULL_CONTROL":
        return S3ACL.S3ACL_BUCKET_OWNER_FULL_CONTROL;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum S3ACL");
    }
  }
  exports2.s3ACLFromJSON = s3ACLFromJSON;
  function s3ACLToJSON(object) {
    switch (object) {
      case S3ACL.S3ACL_UNSPECIFIED:
        return "S3ACL_UNSPECIFIED";
      case S3ACL.S3ACL_PRIVATE:
        return "S3ACL_PRIVATE";
      case S3ACL.S3ACL_PUBLIC_READ:
        return "S3ACL_PUBLIC_READ";
      case S3ACL.S3ACL_PUBLIC_READ_WRITE:
        return "S3ACL_PUBLIC_READ_WRITE";
      case S3ACL.S3ACL_AUTHENTICATED_READ:
        return "S3ACL_AUTHENTICATED_READ";
      case S3ACL.S3ACL_BUCKET_OWNER_READ:
        return "S3ACL_BUCKET_OWNER_READ";
      case S3ACL.S3ACL_BUCKET_OWNER_FULL_CONTROL:
        return "S3ACL_BUCKET_OWNER_FULL_CONTROL";
      default:
        return "UNKNOWN";
    }
  }
  exports2.s3ACLToJSON = s3ACLToJSON;
  function s3ACLToNumber(object) {
    switch (object) {
      case S3ACL.S3ACL_UNSPECIFIED:
        return 0;
      case S3ACL.S3ACL_PRIVATE:
        return 1;
      case S3ACL.S3ACL_PUBLIC_READ:
        return 2;
      case S3ACL.S3ACL_PUBLIC_READ_WRITE:
        return 3;
      case S3ACL.S3ACL_AUTHENTICATED_READ:
        return 4;
      case S3ACL.S3ACL_BUCKET_OWNER_READ:
        return 5;
      case S3ACL.S3ACL_BUCKET_OWNER_FULL_CONTROL:
        return 6;
      default:
        return 0;
    }
  }
  exports2.s3ACLToNumber = s3ACLToNumber;
  var SourceTriggerAction;
  (function(SourceTriggerAction2) {
    SourceTriggerAction2["SOURCE_TRIGGER_ACTION_UNSPECIFIED"] = "SOURCE_TRIGGER_ACTION_UNSPECIFIED";
    SourceTriggerAction2["SOURCE_TRIGGER_ACTION_IGNORE"] = "SOURCE_TRIGGER_ACTION_IGNORE";
    SourceTriggerAction2["SOURCE_TRIGGER_ACTION_OR"] = "SOURCE_TRIGGER_ACTION_OR";
  })(SourceTriggerAction = exports2.SourceTriggerAction || (exports2.SourceTriggerAction = {}));
  function sourceTriggerActionFromJSON(object) {
    switch (object) {
      case 0:
      case "SOURCE_TRIGGER_ACTION_UNSPECIFIED":
        return SourceTriggerAction.SOURCE_TRIGGER_ACTION_UNSPECIFIED;
      case 1:
      case "SOURCE_TRIGGER_ACTION_IGNORE":
        return SourceTriggerAction.SOURCE_TRIGGER_ACTION_IGNORE;
      case 3:
      case "SOURCE_TRIGGER_ACTION_OR":
        return SourceTriggerAction.SOURCE_TRIGGER_ACTION_OR;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum SourceTriggerAction");
    }
  }
  exports2.sourceTriggerActionFromJSON = sourceTriggerActionFromJSON;
  function sourceTriggerActionToJSON(object) {
    switch (object) {
      case SourceTriggerAction.SOURCE_TRIGGER_ACTION_UNSPECIFIED:
        return "SOURCE_TRIGGER_ACTION_UNSPECIFIED";
      case SourceTriggerAction.SOURCE_TRIGGER_ACTION_IGNORE:
        return "SOURCE_TRIGGER_ACTION_IGNORE";
      case SourceTriggerAction.SOURCE_TRIGGER_ACTION_OR:
        return "SOURCE_TRIGGER_ACTION_OR";
      default:
        return "UNKNOWN";
    }
  }
  exports2.sourceTriggerActionToJSON = sourceTriggerActionToJSON;
  function sourceTriggerActionToNumber(object) {
    switch (object) {
      case SourceTriggerAction.SOURCE_TRIGGER_ACTION_UNSPECIFIED:
        return 0;
      case SourceTriggerAction.SOURCE_TRIGGER_ACTION_IGNORE:
        return 1;
      case SourceTriggerAction.SOURCE_TRIGGER_ACTION_OR:
        return 3;
      default:
        return 0;
    }
  }
  exports2.sourceTriggerActionToNumber = sourceTriggerActionToNumber;
  var Region;
  (function(Region2) {
    Region2["REGION_UNSPECIFIED"] = "REGION_UNSPECIFIED";
    Region2["REGION_US_EAST_1"] = "REGION_US_EAST_1";
    Region2["REGION_US_EAST_2"] = "REGION_US_EAST_2";
    Region2["REGION_US_WEST_1"] = "REGION_US_WEST_1";
    Region2["REGION_US_WEST_2"] = "REGION_US_WEST_2";
    Region2["REGION_US_CENTRAL_1"] = "REGION_US_CENTRAL_1";
    Region2["REGION_AP_SOUTHEAST_1"] = "REGION_AP_SOUTHEAST_1";
    Region2["REGION_CA_EAST_1"] = "REGION_CA_EAST_1";
    Region2["REGION_EU_CENTRAL_1"] = "REGION_EU_CENTRAL_1";
    Region2["REGION_EU_WEST_1"] = "REGION_EU_WEST_1";
  })(Region = exports2.Region || (exports2.Region = {}));
  function regionFromJSON(object) {
    switch (object) {
      case 0:
      case "REGION_UNSPECIFIED":
        return Region.REGION_UNSPECIFIED;
      case 1:
      case "REGION_US_EAST_1":
        return Region.REGION_US_EAST_1;
      case 2:
      case "REGION_US_EAST_2":
        return Region.REGION_US_EAST_2;
      case 3:
      case "REGION_US_WEST_1":
        return Region.REGION_US_WEST_1;
      case 4:
      case "REGION_US_WEST_2":
        return Region.REGION_US_WEST_2;
      case 5:
      case "REGION_US_CENTRAL_1":
        return Region.REGION_US_CENTRAL_1;
      case 10:
      case "REGION_AP_SOUTHEAST_1":
        return Region.REGION_AP_SOUTHEAST_1;
      case 20:
      case "REGION_CA_EAST_1":
        return Region.REGION_CA_EAST_1;
      case 30:
      case "REGION_EU_CENTRAL_1":
        return Region.REGION_EU_CENTRAL_1;
      case 31:
      case "REGION_EU_WEST_1":
        return Region.REGION_EU_WEST_1;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum Region");
    }
  }
  exports2.regionFromJSON = regionFromJSON;
  function regionToJSON(object) {
    switch (object) {
      case Region.REGION_UNSPECIFIED:
        return "REGION_UNSPECIFIED";
      case Region.REGION_US_EAST_1:
        return "REGION_US_EAST_1";
      case Region.REGION_US_EAST_2:
        return "REGION_US_EAST_2";
      case Region.REGION_US_WEST_1:
        return "REGION_US_WEST_1";
      case Region.REGION_US_WEST_2:
        return "REGION_US_WEST_2";
      case Region.REGION_US_CENTRAL_1:
        return "REGION_US_CENTRAL_1";
      case Region.REGION_AP_SOUTHEAST_1:
        return "REGION_AP_SOUTHEAST_1";
      case Region.REGION_CA_EAST_1:
        return "REGION_CA_EAST_1";
      case Region.REGION_EU_CENTRAL_1:
        return "REGION_EU_CENTRAL_1";
      case Region.REGION_EU_WEST_1:
        return "REGION_EU_WEST_1";
      default:
        return "UNKNOWN";
    }
  }
  exports2.regionToJSON = regionToJSON;
  function regionToNumber(object) {
    switch (object) {
      case Region.REGION_UNSPECIFIED:
        return 0;
      case Region.REGION_US_EAST_1:
        return 1;
      case Region.REGION_US_EAST_2:
        return 2;
      case Region.REGION_US_WEST_1:
        return 3;
      case Region.REGION_US_WEST_2:
        return 4;
      case Region.REGION_US_CENTRAL_1:
        return 5;
      case Region.REGION_AP_SOUTHEAST_1:
        return 10;
      case Region.REGION_CA_EAST_1:
        return 20;
      case Region.REGION_EU_CENTRAL_1:
        return 30;
      case Region.REGION_EU_WEST_1:
        return 31;
      default:
        return 0;
    }
  }
  exports2.regionToNumber = regionToNumber;
  var Role2;
  (function(Role3) {
    Role3["ROLE_UNSPECIFIED"] = "ROLE_UNSPECIFIED";
    Role3["ROLE_HOST"] = "ROLE_HOST";
    Role3["ROLE_COHOST"] = "ROLE_COHOST";
    Role3["ROLE_CONTRIBUTOR"] = "ROLE_CONTRIBUTOR";
    Role3["ROLE_GUEST"] = "ROLE_GUEST";
    Role3["ROLE_VIEWER"] = "ROLE_VIEWER";
    Role3["ROLE_RENDERER"] = "ROLE_RENDERER";
    Role3["ROLE_PLATFORM"] = "ROLE_PLATFORM";
    Role3["ROLE_IMPERSONATE"] = "ROLE_IMPERSONATE";
  })(Role2 = exports2.Role || (exports2.Role = {}));
  function roleFromJSON(object) {
    switch (object) {
      case 0:
      case "ROLE_UNSPECIFIED":
        return Role2.ROLE_UNSPECIFIED;
      case 1:
      case "ROLE_HOST":
        return Role2.ROLE_HOST;
      case 2:
      case "ROLE_COHOST":
        return Role2.ROLE_COHOST;
      case 3:
      case "ROLE_CONTRIBUTOR":
        return Role2.ROLE_CONTRIBUTOR;
      case 4:
      case "ROLE_GUEST":
        return Role2.ROLE_GUEST;
      case 5:
      case "ROLE_VIEWER":
        return Role2.ROLE_VIEWER;
      case 6:
      case "ROLE_RENDERER":
        return Role2.ROLE_RENDERER;
      case 7:
      case "ROLE_PLATFORM":
        return Role2.ROLE_PLATFORM;
      case 8:
      case "ROLE_IMPERSONATE":
        return Role2.ROLE_IMPERSONATE;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum Role");
    }
  }
  exports2.roleFromJSON = roleFromJSON;
  function roleToJSON(object) {
    switch (object) {
      case Role2.ROLE_UNSPECIFIED:
        return "ROLE_UNSPECIFIED";
      case Role2.ROLE_HOST:
        return "ROLE_HOST";
      case Role2.ROLE_COHOST:
        return "ROLE_COHOST";
      case Role2.ROLE_CONTRIBUTOR:
        return "ROLE_CONTRIBUTOR";
      case Role2.ROLE_GUEST:
        return "ROLE_GUEST";
      case Role2.ROLE_VIEWER:
        return "ROLE_VIEWER";
      case Role2.ROLE_RENDERER:
        return "ROLE_RENDERER";
      case Role2.ROLE_PLATFORM:
        return "ROLE_PLATFORM";
      case Role2.ROLE_IMPERSONATE:
        return "ROLE_IMPERSONATE";
      default:
        return "UNKNOWN";
    }
  }
  exports2.roleToJSON = roleToJSON;
  function roleToNumber(object) {
    switch (object) {
      case Role2.ROLE_UNSPECIFIED:
        return 0;
      case Role2.ROLE_HOST:
        return 1;
      case Role2.ROLE_COHOST:
        return 2;
      case Role2.ROLE_CONTRIBUTOR:
        return 3;
      case Role2.ROLE_GUEST:
        return 4;
      case Role2.ROLE_VIEWER:
        return 5;
      case Role2.ROLE_RENDERER:
        return 6;
      case Role2.ROLE_PLATFORM:
        return 7;
      case Role2.ROLE_IMPERSONATE:
        return 8;
      default:
        return 0;
    }
  }
  exports2.roleToNumber = roleToNumber;
  var ProjectBroadcastError;
  (function(ProjectBroadcastError2) {
    ProjectBroadcastError2["PROJECT_BROADCAST_ERROR_UNSPECIFIED"] = "PROJECT_BROADCAST_ERROR_UNSPECIFIED";
    ProjectBroadcastError2["PROJECT_BROADCAST_ERROR_INTERNAL"] = "PROJECT_BROADCAST_ERROR_INTERNAL";
    ProjectBroadcastError2["PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED"] = "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED";
  })(ProjectBroadcastError = exports2.ProjectBroadcastError || (exports2.ProjectBroadcastError = {}));
  function projectBroadcastErrorFromJSON(object) {
    switch (object) {
      case 0:
      case "PROJECT_BROADCAST_ERROR_UNSPECIFIED":
        return ProjectBroadcastError.PROJECT_BROADCAST_ERROR_UNSPECIFIED;
      case 1:
      case "PROJECT_BROADCAST_ERROR_INTERNAL":
        return ProjectBroadcastError.PROJECT_BROADCAST_ERROR_INTERNAL;
      case 2:
      case "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED":
        return ProjectBroadcastError.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum ProjectBroadcastError");
    }
  }
  exports2.projectBroadcastErrorFromJSON = projectBroadcastErrorFromJSON;
  function projectBroadcastErrorToJSON(object) {
    switch (object) {
      case ProjectBroadcastError.PROJECT_BROADCAST_ERROR_UNSPECIFIED:
        return "PROJECT_BROADCAST_ERROR_UNSPECIFIED";
      case ProjectBroadcastError.PROJECT_BROADCAST_ERROR_INTERNAL:
        return "PROJECT_BROADCAST_ERROR_INTERNAL";
      case ProjectBroadcastError.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED:
        return "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED";
      default:
        return "UNKNOWN";
    }
  }
  exports2.projectBroadcastErrorToJSON = projectBroadcastErrorToJSON;
  function projectBroadcastErrorToNumber(object) {
    switch (object) {
      case ProjectBroadcastError.PROJECT_BROADCAST_ERROR_UNSPECIFIED:
        return 0;
      case ProjectBroadcastError.PROJECT_BROADCAST_ERROR_INTERNAL:
        return 1;
      case ProjectBroadcastError.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED:
        return 2;
      default:
        return 0;
    }
  }
  exports2.projectBroadcastErrorToNumber = projectBroadcastErrorToNumber;
  var ConnectState;
  (function(ConnectState2) {
    ConnectState2["CONNECT_STATE_UNSPECIFIED"] = "CONNECT_STATE_UNSPECIFIED";
    ConnectState2["CONNECT_STATE_CONNECTED"] = "CONNECT_STATE_CONNECTED";
    ConnectState2["CONNECT_STATE_DISCONNECTED"] = "CONNECT_STATE_DISCONNECTED";
  })(ConnectState = exports2.ConnectState || (exports2.ConnectState = {}));
  function connectStateFromJSON(object) {
    switch (object) {
      case 0:
      case "CONNECT_STATE_UNSPECIFIED":
        return ConnectState.CONNECT_STATE_UNSPECIFIED;
      case 1:
      case "CONNECT_STATE_CONNECTED":
        return ConnectState.CONNECT_STATE_CONNECTED;
      case 2:
      case "CONNECT_STATE_DISCONNECTED":
        return ConnectState.CONNECT_STATE_DISCONNECTED;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum ConnectState");
    }
  }
  exports2.connectStateFromJSON = connectStateFromJSON;
  function connectStateToJSON(object) {
    switch (object) {
      case ConnectState.CONNECT_STATE_UNSPECIFIED:
        return "CONNECT_STATE_UNSPECIFIED";
      case ConnectState.CONNECT_STATE_CONNECTED:
        return "CONNECT_STATE_CONNECTED";
      case ConnectState.CONNECT_STATE_DISCONNECTED:
        return "CONNECT_STATE_DISCONNECTED";
      default:
        return "UNKNOWN";
    }
  }
  exports2.connectStateToJSON = connectStateToJSON;
  function connectStateToNumber(object) {
    switch (object) {
      case ConnectState.CONNECT_STATE_UNSPECIFIED:
        return 0;
      case ConnectState.CONNECT_STATE_CONNECTED:
        return 1;
      case ConnectState.CONNECT_STATE_DISCONNECTED:
        return 2;
      default:
        return 0;
    }
  }
  exports2.connectStateToNumber = connectStateToNumber;
  var EventSubType2;
  (function(EventSubType3) {
    EventSubType3["EVENT_SUB_TYPE_UNSPECIFIED"] = "EVENT_SUB_TYPE_UNSPECIFIED";
    EventSubType3["EVENT_SUB_TYPE_CREATE"] = "EVENT_SUB_TYPE_CREATE";
    EventSubType3["EVENT_SUB_TYPE_UPDATE"] = "EVENT_SUB_TYPE_UPDATE";
    EventSubType3["EVENT_SUB_TYPE_DELETE"] = "EVENT_SUB_TYPE_DELETE";
    EventSubType3["EVENT_SUB_TYPE_ADD"] = "EVENT_SUB_TYPE_ADD";
    EventSubType3["EVENT_SUB_TYPE_REMOVE"] = "EVENT_SUB_TYPE_REMOVE";
    EventSubType3["EVENT_SUB_TYPE_STATE"] = "EVENT_SUB_TYPE_STATE";
  })(EventSubType2 = exports2.EventSubType || (exports2.EventSubType = {}));
  function eventSubTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "EVENT_SUB_TYPE_UNSPECIFIED":
        return EventSubType2.EVENT_SUB_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_SUB_TYPE_CREATE":
        return EventSubType2.EVENT_SUB_TYPE_CREATE;
      case 2:
      case "EVENT_SUB_TYPE_UPDATE":
        return EventSubType2.EVENT_SUB_TYPE_UPDATE;
      case 3:
      case "EVENT_SUB_TYPE_DELETE":
        return EventSubType2.EVENT_SUB_TYPE_DELETE;
      case 4:
      case "EVENT_SUB_TYPE_ADD":
        return EventSubType2.EVENT_SUB_TYPE_ADD;
      case 5:
      case "EVENT_SUB_TYPE_REMOVE":
        return EventSubType2.EVENT_SUB_TYPE_REMOVE;
      case 6:
      case "EVENT_SUB_TYPE_STATE":
        return EventSubType2.EVENT_SUB_TYPE_STATE;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum EventSubType");
    }
  }
  exports2.eventSubTypeFromJSON = eventSubTypeFromJSON;
  function eventSubTypeToJSON(object) {
    switch (object) {
      case EventSubType2.EVENT_SUB_TYPE_UNSPECIFIED:
        return "EVENT_SUB_TYPE_UNSPECIFIED";
      case EventSubType2.EVENT_SUB_TYPE_CREATE:
        return "EVENT_SUB_TYPE_CREATE";
      case EventSubType2.EVENT_SUB_TYPE_UPDATE:
        return "EVENT_SUB_TYPE_UPDATE";
      case EventSubType2.EVENT_SUB_TYPE_DELETE:
        return "EVENT_SUB_TYPE_DELETE";
      case EventSubType2.EVENT_SUB_TYPE_ADD:
        return "EVENT_SUB_TYPE_ADD";
      case EventSubType2.EVENT_SUB_TYPE_REMOVE:
        return "EVENT_SUB_TYPE_REMOVE";
      case EventSubType2.EVENT_SUB_TYPE_STATE:
        return "EVENT_SUB_TYPE_STATE";
      default:
        return "UNKNOWN";
    }
  }
  exports2.eventSubTypeToJSON = eventSubTypeToJSON;
  function eventSubTypeToNumber(object) {
    switch (object) {
      case EventSubType2.EVENT_SUB_TYPE_UNSPECIFIED:
        return 0;
      case EventSubType2.EVENT_SUB_TYPE_CREATE:
        return 1;
      case EventSubType2.EVENT_SUB_TYPE_UPDATE:
        return 2;
      case EventSubType2.EVENT_SUB_TYPE_DELETE:
        return 3;
      case EventSubType2.EVENT_SUB_TYPE_ADD:
        return 4;
      case EventSubType2.EVENT_SUB_TYPE_REMOVE:
        return 5;
      case EventSubType2.EVENT_SUB_TYPE_STATE:
        return 6;
      default:
        return 0;
    }
  }
  exports2.eventSubTypeToNumber = eventSubTypeToNumber;
  var EventType2;
  (function(EventType3) {
    EventType3["EVENT_TYPE_UNSPECIFIED"] = "EVENT_TYPE_UNSPECIFIED";
    EventType3["EVENT_TYPE_COLLECTION"] = "EVENT_TYPE_COLLECTION";
    EventType3["EVENT_TYPE_PROJECT"] = "EVENT_TYPE_PROJECT";
    EventType3["EVENT_TYPE_SOURCE"] = "EVENT_TYPE_SOURCE";
    EventType3["EVENT_TYPE_DESTINATION"] = "EVENT_TYPE_DESTINATION";
  })(EventType2 = exports2.EventType || (exports2.EventType = {}));
  function eventTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "EVENT_TYPE_UNSPECIFIED":
        return EventType2.EVENT_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_TYPE_COLLECTION":
        return EventType2.EVENT_TYPE_COLLECTION;
      case 2:
      case "EVENT_TYPE_PROJECT":
        return EventType2.EVENT_TYPE_PROJECT;
      case 4:
      case "EVENT_TYPE_SOURCE":
        return EventType2.EVENT_TYPE_SOURCE;
      case 5:
      case "EVENT_TYPE_DESTINATION":
        return EventType2.EVENT_TYPE_DESTINATION;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum EventType");
    }
  }
  exports2.eventTypeFromJSON = eventTypeFromJSON;
  function eventTypeToJSON(object) {
    switch (object) {
      case EventType2.EVENT_TYPE_UNSPECIFIED:
        return "EVENT_TYPE_UNSPECIFIED";
      case EventType2.EVENT_TYPE_COLLECTION:
        return "EVENT_TYPE_COLLECTION";
      case EventType2.EVENT_TYPE_PROJECT:
        return "EVENT_TYPE_PROJECT";
      case EventType2.EVENT_TYPE_SOURCE:
        return "EVENT_TYPE_SOURCE";
      case EventType2.EVENT_TYPE_DESTINATION:
        return "EVENT_TYPE_DESTINATION";
      default:
        return "UNKNOWN";
    }
  }
  exports2.eventTypeToJSON = eventTypeToJSON;
  function eventTypeToNumber(object) {
    switch (object) {
      case EventType2.EVENT_TYPE_UNSPECIFIED:
        return 0;
      case EventType2.EVENT_TYPE_COLLECTION:
        return 1;
      case EventType2.EVENT_TYPE_PROJECT:
        return 2;
      case EventType2.EVENT_TYPE_SOURCE:
        return 4;
      case EventType2.EVENT_TYPE_DESTINATION:
        return 5;
      default:
        return 0;
    }
  }
  exports2.eventTypeToNumber = eventTypeToNumber;
  function createBaseVideoRendering() {
    return { height: void 0, width: void 0, framerate: void 0, colorSpace: void 0 };
  }
  exports2.VideoRendering = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.height !== void 0) {
      writer2.uint32(8).uint32(message.height);
    }
    if (message.width !== void 0) {
      writer2.uint32(16).uint32(message.width);
    }
    if (message.framerate !== void 0) {
      writer2.uint32(29).float(message.framerate);
    }
    if (message.colorSpace !== void 0) {
      writer2.uint32(32).int32(videoColorSpaceToNumber(message.colorSpace));
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseVideoRendering();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.height = reader2.uint32();
          break;
        case 2:
          message.width = reader2.uint32();
          break;
        case 3:
          message.framerate = reader2.float();
          break;
        case 4:
          message.colorSpace = videoColorSpaceFromJSON(reader2.int32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { height: isSet2(object.height) ? Number(object.height) : void 0, width: isSet2(object.width) ? Number(object.width) : void 0, framerate: isSet2(object.framerate) ? Number(object.framerate) : void 0, colorSpace: isSet2(object.colorSpace) ? videoColorSpaceFromJSON(object.colorSpace) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.height !== void 0 && (obj.height = Math.round(message.height));
    message.width !== void 0 && (obj.width = Math.round(message.width));
    message.framerate !== void 0 && (obj.framerate = message.framerate);
    message.colorSpace !== void 0 && (obj.colorSpace = message.colorSpace !== void 0 ? videoColorSpaceToJSON(message.colorSpace) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseVideoRendering();
    message.height = (_a2 = object.height) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.width = (_b = object.width) !== null && _b !== void 0 ? _b : void 0;
    message.framerate = (_c = object.framerate) !== null && _c !== void 0 ? _c : void 0;
    message.colorSpace = (_d = object.colorSpace) !== null && _d !== void 0 ? _d : void 0;
    return message;
  } };
  function createBaseAudioRendering() {
    return { channelLayout: void 0 };
  }
  exports2.AudioRendering = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.channelLayout !== void 0) {
      writer2.uint32(8).int32(audioChannelLayoutToNumber(message.channelLayout));
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseAudioRendering();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.channelLayout = audioChannelLayoutFromJSON(reader2.int32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { channelLayout: isSet2(object.channelLayout) ? audioChannelLayoutFromJSON(object.channelLayout) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.channelLayout !== void 0 && (obj.channelLayout = message.channelLayout !== void 0 ? audioChannelLayoutToJSON(message.channelLayout) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseAudioRendering();
    message.channelLayout = (_a2 = object.channelLayout) !== null && _a2 !== void 0 ? _a2 : void 0;
    return message;
  } };
  function createBaseRendering() {
    return { video: void 0, audio: void 0, quality: void 0, targetLatency: void 0, complexity: void 0 };
  }
  exports2.Rendering = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.video !== void 0) {
      exports2.VideoRendering.encode(message.video, writer2.uint32(10).fork()).ldelim();
    }
    if (message.audio !== void 0) {
      exports2.AudioRendering.encode(message.audio, writer2.uint32(18).fork()).ldelim();
    }
    if (message.quality !== void 0) {
      writer2.uint32(24).int32(renderingQualityToNumber(message.quality));
    }
    if (message.targetLatency !== void 0) {
      writer2.uint32(32).uint32(message.targetLatency);
    }
    if (message.complexity !== void 0) {
      writer2.uint32(40).int32(message.complexity);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseRendering();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.video = exports2.VideoRendering.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.audio = exports2.AudioRendering.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.quality = renderingQualityFromJSON(reader2.int32());
          break;
        case 4:
          message.targetLatency = reader2.uint32();
          break;
        case 5:
          message.complexity = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { video: isSet2(object.video) ? exports2.VideoRendering.fromJSON(object.video) : void 0, audio: isSet2(object.audio) ? exports2.AudioRendering.fromJSON(object.audio) : void 0, quality: isSet2(object.quality) ? renderingQualityFromJSON(object.quality) : void 0, targetLatency: isSet2(object.targetLatency) ? Number(object.targetLatency) : void 0, complexity: isSet2(object.complexity) ? Number(object.complexity) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.video !== void 0 && (obj.video = message.video ? exports2.VideoRendering.toJSON(message.video) : void 0);
    message.audio !== void 0 && (obj.audio = message.audio ? exports2.AudioRendering.toJSON(message.audio) : void 0);
    message.quality !== void 0 && (obj.quality = message.quality !== void 0 ? renderingQualityToJSON(message.quality) : void 0);
    message.targetLatency !== void 0 && (obj.targetLatency = Math.round(message.targetLatency));
    message.complexity !== void 0 && (obj.complexity = Math.round(message.complexity));
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseRendering();
    message.video = object.video !== void 0 && object.video !== null ? exports2.VideoRendering.fromPartial(object.video) : void 0;
    message.audio = object.audio !== void 0 && object.audio !== null ? exports2.AudioRendering.fromPartial(object.audio) : void 0;
    message.quality = (_a2 = object.quality) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.targetLatency = (_b = object.targetLatency) !== null && _b !== void 0 ? _b : void 0;
    message.complexity = (_c = object.complexity) !== null && _c !== void 0 ? _c : void 0;
    return message;
  } };
  function createBaseVideoCodecRateControl() {
    return { mode: void 0, targetBitrate: void 0, maxKeyFrameInterval: void 0 };
  }
  exports2.VideoCodecRateControl = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.mode !== void 0) {
      writer2.uint32(8).int32(videoCodecRateControlModeToNumber(message.mode));
    }
    if (message.targetBitrate !== void 0) {
      writer2.uint32(16).uint32(message.targetBitrate);
    }
    if (message.maxKeyFrameInterval !== void 0) {
      writer2.uint32(24).uint32(message.maxKeyFrameInterval);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseVideoCodecRateControl();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mode = videoCodecRateControlModeFromJSON(reader2.int32());
          break;
        case 2:
          message.targetBitrate = reader2.uint32();
          break;
        case 3:
          message.maxKeyFrameInterval = reader2.uint32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { mode: isSet2(object.mode) ? videoCodecRateControlModeFromJSON(object.mode) : void 0, targetBitrate: isSet2(object.targetBitrate) ? Number(object.targetBitrate) : void 0, maxKeyFrameInterval: isSet2(object.maxKeyFrameInterval) ? Number(object.maxKeyFrameInterval) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.mode !== void 0 && (obj.mode = message.mode !== void 0 ? videoCodecRateControlModeToJSON(message.mode) : void 0);
    message.targetBitrate !== void 0 && (obj.targetBitrate = Math.round(message.targetBitrate));
    message.maxKeyFrameInterval !== void 0 && (obj.maxKeyFrameInterval = Math.round(message.maxKeyFrameInterval));
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseVideoCodecRateControl();
    message.mode = (_a2 = object.mode) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.targetBitrate = (_b = object.targetBitrate) !== null && _b !== void 0 ? _b : void 0;
    message.maxKeyFrameInterval = (_c = object.maxKeyFrameInterval) !== null && _c !== void 0 ? _c : void 0;
    return message;
  } };
  function createBaseVideoEncoding() {
    return { codec: void 0, rateControl: void 0, profile: void 0 };
  }
  exports2.VideoEncoding = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.codec !== void 0) {
      writer2.uint32(8).int32(videoCodecToNumber(message.codec));
    }
    if (message.rateControl !== void 0) {
      exports2.VideoCodecRateControl.encode(message.rateControl, writer2.uint32(18).fork()).ldelim();
    }
    if (message.profile !== void 0) {
      writer2.uint32(32).int32(videoCodecProfileToNumber(message.profile));
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseVideoEncoding();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.codec = videoCodecFromJSON(reader2.int32());
          break;
        case 2:
          message.rateControl = exports2.VideoCodecRateControl.decode(reader2, reader2.uint32());
          break;
        case 4:
          message.profile = videoCodecProfileFromJSON(reader2.int32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { codec: isSet2(object.codec) ? videoCodecFromJSON(object.codec) : void 0, rateControl: isSet2(object.rateControl) ? exports2.VideoCodecRateControl.fromJSON(object.rateControl) : void 0, profile: isSet2(object.profile) ? videoCodecProfileFromJSON(object.profile) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.codec !== void 0 && (obj.codec = message.codec !== void 0 ? videoCodecToJSON(message.codec) : void 0);
    message.rateControl !== void 0 && (obj.rateControl = message.rateControl ? exports2.VideoCodecRateControl.toJSON(message.rateControl) : void 0);
    message.profile !== void 0 && (obj.profile = message.profile !== void 0 ? videoCodecProfileToJSON(message.profile) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseVideoEncoding();
    message.codec = (_a2 = object.codec) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.rateControl = object.rateControl !== void 0 && object.rateControl !== null ? exports2.VideoCodecRateControl.fromPartial(object.rateControl) : void 0;
    message.profile = (_b = object.profile) !== null && _b !== void 0 ? _b : void 0;
    return message;
  } };
  function createBaseAudioEncoding() {
    return { codec: void 0 };
  }
  exports2.AudioEncoding = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.codec !== void 0) {
      writer2.uint32(8).int32(audioCodecToNumber(message.codec));
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseAudioEncoding();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.codec = audioCodecFromJSON(reader2.int32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { codec: isSet2(object.codec) ? audioCodecFromJSON(object.codec) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.codec !== void 0 && (obj.codec = message.codec !== void 0 ? audioCodecToJSON(message.codec) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseAudioEncoding();
    message.codec = (_a2 = object.codec) !== null && _a2 !== void 0 ? _a2 : void 0;
    return message;
  } };
  function createBaseEncoding() {
    return { video: void 0, audio: void 0 };
  }
  exports2.Encoding = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.video !== void 0) {
      exports2.VideoEncoding.encode(message.video, writer2.uint32(10).fork()).ldelim();
    }
    if (message.audio !== void 0) {
      exports2.AudioEncoding.encode(message.audio, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseEncoding();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.video = exports2.VideoEncoding.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.audio = exports2.AudioEncoding.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { video: isSet2(object.video) ? exports2.VideoEncoding.fromJSON(object.video) : void 0, audio: isSet2(object.audio) ? exports2.AudioEncoding.fromJSON(object.audio) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.video !== void 0 && (obj.video = message.video ? exports2.VideoEncoding.toJSON(message.video) : void 0);
    message.audio !== void 0 && (obj.audio = message.audio ? exports2.AudioEncoding.toJSON(message.audio) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseEncoding();
    message.video = object.video !== void 0 && object.video !== null ? exports2.VideoEncoding.fromPartial(object.video) : void 0;
    message.audio = object.audio !== void 0 && object.audio !== null ? exports2.AudioEncoding.fromPartial(object.audio) : void 0;
    return message;
  } };
  function createBaseSourceRtmpPushAddress() {
    return { enabled: void 0, key: void 0, url: void 0, baseUrl: void 0 };
  }
  exports2.SourceRtmpPushAddress = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.enabled !== void 0) {
      writer2.uint32(8).bool(message.enabled);
    }
    if (message.key !== void 0) {
      writer2.uint32(18).string(message.key);
    }
    if (message.url !== void 0) {
      writer2.uint32(26).string(message.url);
    }
    if (message.baseUrl !== void 0) {
      writer2.uint32(34).string(message.baseUrl);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSourceRtmpPushAddress();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.enabled = reader2.bool();
          break;
        case 2:
          message.key = reader2.string();
          break;
        case 3:
          message.url = reader2.string();
          break;
        case 4:
          message.baseUrl = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { enabled: isSet2(object.enabled) ? Boolean(object.enabled) : void 0, key: isSet2(object.key) ? String(object.key) : void 0, url: isSet2(object.url) ? String(object.url) : void 0, baseUrl: isSet2(object.baseUrl) ? String(object.baseUrl) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.enabled !== void 0 && (obj.enabled = message.enabled);
    message.key !== void 0 && (obj.key = message.key);
    message.url !== void 0 && (obj.url = message.url);
    message.baseUrl !== void 0 && (obj.baseUrl = message.baseUrl);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseSourceRtmpPushAddress();
    message.enabled = (_a2 = object.enabled) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.key = (_b = object.key) !== null && _b !== void 0 ? _b : void 0;
    message.url = (_c = object.url) !== null && _c !== void 0 ? _c : void 0;
    message.baseUrl = (_d = object.baseUrl) !== null && _d !== void 0 ? _d : void 0;
    return message;
  } };
  function createBaseSrtPushAddress() {
    return { enabled: void 0, streamId: void 0, url: void 0, baseUrl: void 0 };
  }
  exports2.SrtPushAddress = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.enabled !== void 0) {
      writer2.uint32(8).bool(message.enabled);
    }
    if (message.streamId !== void 0) {
      writer2.uint32(18).string(message.streamId);
    }
    if (message.url !== void 0) {
      writer2.uint32(26).string(message.url);
    }
    if (message.baseUrl !== void 0) {
      writer2.uint32(34).string(message.baseUrl);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSrtPushAddress();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.enabled = reader2.bool();
          break;
        case 2:
          message.streamId = reader2.string();
          break;
        case 3:
          message.url = reader2.string();
          break;
        case 4:
          message.baseUrl = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { enabled: isSet2(object.enabled) ? Boolean(object.enabled) : void 0, streamId: isSet2(object.streamId) ? String(object.streamId) : void 0, url: isSet2(object.url) ? String(object.url) : void 0, baseUrl: isSet2(object.baseUrl) ? String(object.baseUrl) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.enabled !== void 0 && (obj.enabled = message.enabled);
    message.streamId !== void 0 && (obj.streamId = message.streamId);
    message.url !== void 0 && (obj.url = message.url);
    message.baseUrl !== void 0 && (obj.baseUrl = message.baseUrl);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseSrtPushAddress();
    message.enabled = (_a2 = object.enabled) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.streamId = (_b = object.streamId) !== null && _b !== void 0 ? _b : void 0;
    message.url = (_c = object.url) !== null && _c !== void 0 ? _c : void 0;
    message.baseUrl = (_d = object.baseUrl) !== null && _d !== void 0 ? _d : void 0;
    return message;
  } };
  function createBaseRtmpPullAddress() {
    return { url: "" };
  }
  exports2.RtmpPullAddress = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.url !== "") {
      writer2.uint32(10).string(message.url);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseRtmpPullAddress();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.url = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { url: isSet2(object.url) ? String(object.url) : "" };
  }, toJSON(message) {
    const obj = {};
    message.url !== void 0 && (obj.url = message.url);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseRtmpPullAddress();
    message.url = (_a2 = object.url) !== null && _a2 !== void 0 ? _a2 : "";
    return message;
  } };
  function createBaseSourceAddress() {
    return { rtmpPush: void 0, srtPush: void 0, rtmpPull: void 0 };
  }
  exports2.SourceAddress = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.rtmpPush !== void 0) {
      exports2.SourceRtmpPushAddress.encode(message.rtmpPush, writer2.uint32(10).fork()).ldelim();
    }
    if (message.srtPush !== void 0) {
      exports2.SrtPushAddress.encode(message.srtPush, writer2.uint32(18).fork()).ldelim();
    }
    if (message.rtmpPull !== void 0) {
      exports2.RtmpPullAddress.encode(message.rtmpPull, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSourceAddress();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rtmpPush = exports2.SourceRtmpPushAddress.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.srtPush = exports2.SrtPushAddress.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.rtmpPull = exports2.RtmpPullAddress.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { rtmpPush: isSet2(object.rtmpPush) ? exports2.SourceRtmpPushAddress.fromJSON(object.rtmpPush) : void 0, srtPush: isSet2(object.srtPush) ? exports2.SrtPushAddress.fromJSON(object.srtPush) : void 0, rtmpPull: isSet2(object.rtmpPull) ? exports2.RtmpPullAddress.fromJSON(object.rtmpPull) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.rtmpPush !== void 0 && (obj.rtmpPush = message.rtmpPush ? exports2.SourceRtmpPushAddress.toJSON(message.rtmpPush) : void 0);
    message.srtPush !== void 0 && (obj.srtPush = message.srtPush ? exports2.SrtPushAddress.toJSON(message.srtPush) : void 0);
    message.rtmpPull !== void 0 && (obj.rtmpPull = message.rtmpPull ? exports2.RtmpPullAddress.toJSON(message.rtmpPull) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseSourceAddress();
    message.rtmpPush = object.rtmpPush !== void 0 && object.rtmpPush !== null ? exports2.SourceRtmpPushAddress.fromPartial(object.rtmpPush) : void 0;
    message.srtPush = object.srtPush !== void 0 && object.srtPush !== null ? exports2.SrtPushAddress.fromPartial(object.srtPush) : void 0;
    message.rtmpPull = object.rtmpPull !== void 0 && object.rtmpPull !== null ? exports2.RtmpPullAddress.fromPartial(object.rtmpPull) : void 0;
    return message;
  } };
  function createBaseDestinationRtmpPushAddress() {
    return { key: void 0, url: "" };
  }
  exports2.DestinationRtmpPushAddress = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.key !== void 0) {
      writer2.uint32(10).string(message.key);
    }
    if (message.url !== "") {
      writer2.uint32(18).string(message.url);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDestinationRtmpPushAddress();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader2.string();
          break;
        case 2:
          message.url = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { key: isSet2(object.key) ? String(object.key) : void 0, url: isSet2(object.url) ? String(object.url) : "" };
  }, toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.url !== void 0 && (obj.url = message.url);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseDestinationRtmpPushAddress();
    message.key = (_a2 = object.key) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.url = (_b = object.url) !== null && _b !== void 0 ? _b : "";
    return message;
  } };
  function createBaseDestinationAgoraPushAddress() {
    return { appId: "", channelId: "", userId: "" };
  }
  exports2.DestinationAgoraPushAddress = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.appId !== "") {
      writer2.uint32(10).string(message.appId);
    }
    if (message.channelId !== "") {
      writer2.uint32(18).string(message.channelId);
    }
    if (message.userId !== "") {
      writer2.uint32(26).string(message.userId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDestinationAgoraPushAddress();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.appId = reader2.string();
          break;
        case 2:
          message.channelId = reader2.string();
          break;
        case 3:
          message.userId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { appId: isSet2(object.appId) ? String(object.appId) : "", channelId: isSet2(object.channelId) ? String(object.channelId) : "", userId: isSet2(object.userId) ? String(object.userId) : "" };
  }, toJSON(message) {
    const obj = {};
    message.appId !== void 0 && (obj.appId = message.appId);
    message.channelId !== void 0 && (obj.channelId = message.channelId);
    message.userId !== void 0 && (obj.userId = message.userId);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseDestinationAgoraPushAddress();
    message.appId = (_a2 = object.appId) !== null && _a2 !== void 0 ? _a2 : "";
    message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
    message.userId = (_c = object.userId) !== null && _c !== void 0 ? _c : "";
    return message;
  } };
  function createBaseHlsLifecycleLive() {
    return { playlistCount: void 0, fileCount: void 0 };
  }
  exports2.HlsLifecycleLive = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.playlistCount !== void 0) {
      writer2.uint32(8).int32(message.playlistCount);
    }
    if (message.fileCount !== void 0) {
      writer2.uint32(16).int32(message.fileCount);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseHlsLifecycleLive();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.playlistCount = reader2.int32();
          break;
        case 2:
          message.fileCount = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { playlistCount: isSet2(object.playlistCount) ? Number(object.playlistCount) : void 0, fileCount: isSet2(object.fileCount) ? Number(object.fileCount) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.playlistCount !== void 0 && (obj.playlistCount = Math.round(message.playlistCount));
    message.fileCount !== void 0 && (obj.fileCount = Math.round(message.fileCount));
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseHlsLifecycleLive();
    message.playlistCount = (_a2 = object.playlistCount) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.fileCount = (_b = object.fileCount) !== null && _b !== void 0 ? _b : void 0;
    return message;
  } };
  function createBaseHlsLifecycleVod() {
    return { maxDuration: void 0 };
  }
  exports2.HlsLifecycleVod = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.maxDuration !== void 0) {
      writer2.uint32(8).int32(message.maxDuration);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseHlsLifecycleVod();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maxDuration = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { maxDuration: isSet2(object.maxDuration) ? Number(object.maxDuration) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.maxDuration !== void 0 && (obj.maxDuration = Math.round(message.maxDuration));
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseHlsLifecycleVod();
    message.maxDuration = (_a2 = object.maxDuration) !== null && _a2 !== void 0 ? _a2 : void 0;
    return message;
  } };
  function createBaseHlsLifecycle() {
    return { vod: void 0, live: void 0 };
  }
  exports2.HlsLifecycle = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.vod !== void 0) {
      exports2.HlsLifecycleVod.encode(message.vod, writer2.uint32(10).fork()).ldelim();
    }
    if (message.live !== void 0) {
      exports2.HlsLifecycleLive.encode(message.live, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseHlsLifecycle();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.vod = exports2.HlsLifecycleVod.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.live = exports2.HlsLifecycleLive.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { vod: isSet2(object.vod) ? exports2.HlsLifecycleVod.fromJSON(object.vod) : void 0, live: isSet2(object.live) ? exports2.HlsLifecycleLive.fromJSON(object.live) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.vod !== void 0 && (obj.vod = message.vod ? exports2.HlsLifecycleVod.toJSON(message.vod) : void 0);
    message.live !== void 0 && (obj.live = message.live ? exports2.HlsLifecycleLive.toJSON(message.live) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseHlsLifecycle();
    message.vod = object.vod !== void 0 && object.vod !== null ? exports2.HlsLifecycleVod.fromPartial(object.vod) : void 0;
    message.live = object.live !== void 0 && object.live !== null ? exports2.HlsLifecycleLive.fromPartial(object.live) : void 0;
    return message;
  } };
  function createBaseHlsPackaging() {
    return { lifecycle: void 0, segmentDuration: void 0 };
  }
  exports2.HlsPackaging = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.lifecycle !== void 0) {
      exports2.HlsLifecycle.encode(message.lifecycle, writer2.uint32(10).fork()).ldelim();
    }
    if (message.segmentDuration !== void 0) {
      writer2.uint32(16).int32(message.segmentDuration);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseHlsPackaging();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.lifecycle = exports2.HlsLifecycle.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.segmentDuration = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { lifecycle: isSet2(object.lifecycle) ? exports2.HlsLifecycle.fromJSON(object.lifecycle) : void 0, segmentDuration: isSet2(object.segmentDuration) ? Number(object.segmentDuration) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.lifecycle !== void 0 && (obj.lifecycle = message.lifecycle ? exports2.HlsLifecycle.toJSON(message.lifecycle) : void 0);
    message.segmentDuration !== void 0 && (obj.segmentDuration = Math.round(message.segmentDuration));
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseHlsPackaging();
    message.lifecycle = object.lifecycle !== void 0 && object.lifecycle !== null ? exports2.HlsLifecycle.fromPartial(object.lifecycle) : void 0;
    message.segmentDuration = (_a2 = object.segmentDuration) !== null && _a2 !== void 0 ? _a2 : void 0;
    return message;
  } };
  function createBaseObjectStoragePackaging() {
    return { hls: void 0 };
  }
  exports2.ObjectStoragePackaging = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.hls !== void 0) {
      exports2.HlsPackaging.encode(message.hls, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseObjectStoragePackaging();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hls = exports2.HlsPackaging.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { hls: isSet2(object.hls) ? exports2.HlsPackaging.fromJSON(object.hls) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.hls !== void 0 && (obj.hls = message.hls ? exports2.HlsPackaging.toJSON(message.hls) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseObjectStoragePackaging();
    message.hls = object.hls !== void 0 && object.hls !== null ? exports2.HlsPackaging.fromPartial(object.hls) : void 0;
    return message;
  } };
  function createBaseS3StorageAddress() {
    return { region: "", bucket: "", prefix: void 0, accessKey: "", secretKey: "", token: void 0, tokenDuration: void 0, acl: void 0, endpoint: void 0, packaging: void 0 };
  }
  exports2.S3StorageAddress = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.region !== "") {
      writer2.uint32(10).string(message.region);
    }
    if (message.bucket !== "") {
      writer2.uint32(18).string(message.bucket);
    }
    if (message.prefix !== void 0) {
      writer2.uint32(26).string(message.prefix);
    }
    if (message.accessKey !== "") {
      writer2.uint32(34).string(message.accessKey);
    }
    if (message.secretKey !== "") {
      writer2.uint32(42).string(message.secretKey);
    }
    if (message.token !== void 0) {
      writer2.uint32(50).string(message.token);
    }
    if (message.tokenDuration !== void 0) {
      writer2.uint32(56).int32(message.tokenDuration);
    }
    if (message.acl !== void 0) {
      writer2.uint32(64).int32(s3ACLToNumber(message.acl));
    }
    if (message.endpoint !== void 0) {
      writer2.uint32(74).string(message.endpoint);
    }
    if (message.packaging !== void 0) {
      exports2.ObjectStoragePackaging.encode(message.packaging, writer2.uint32(82).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseS3StorageAddress();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.region = reader2.string();
          break;
        case 2:
          message.bucket = reader2.string();
          break;
        case 3:
          message.prefix = reader2.string();
          break;
        case 4:
          message.accessKey = reader2.string();
          break;
        case 5:
          message.secretKey = reader2.string();
          break;
        case 6:
          message.token = reader2.string();
          break;
        case 7:
          message.tokenDuration = reader2.int32();
          break;
        case 8:
          message.acl = s3ACLFromJSON(reader2.int32());
          break;
        case 9:
          message.endpoint = reader2.string();
          break;
        case 10:
          message.packaging = exports2.ObjectStoragePackaging.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { region: isSet2(object.region) ? String(object.region) : "", bucket: isSet2(object.bucket) ? String(object.bucket) : "", prefix: isSet2(object.prefix) ? String(object.prefix) : void 0, accessKey: isSet2(object.accessKey) ? String(object.accessKey) : "", secretKey: isSet2(object.secretKey) ? String(object.secretKey) : "", token: isSet2(object.token) ? String(object.token) : void 0, tokenDuration: isSet2(object.tokenDuration) ? Number(object.tokenDuration) : void 0, acl: isSet2(object.acl) ? s3ACLFromJSON(object.acl) : void 0, endpoint: isSet2(object.endpoint) ? String(object.endpoint) : void 0, packaging: isSet2(object.packaging) ? exports2.ObjectStoragePackaging.fromJSON(object.packaging) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.region !== void 0 && (obj.region = message.region);
    message.bucket !== void 0 && (obj.bucket = message.bucket);
    message.prefix !== void 0 && (obj.prefix = message.prefix);
    message.accessKey !== void 0 && (obj.accessKey = message.accessKey);
    message.secretKey !== void 0 && (obj.secretKey = message.secretKey);
    message.token !== void 0 && (obj.token = message.token);
    message.tokenDuration !== void 0 && (obj.tokenDuration = Math.round(message.tokenDuration));
    message.acl !== void 0 && (obj.acl = message.acl !== void 0 ? s3ACLToJSON(message.acl) : void 0);
    message.endpoint !== void 0 && (obj.endpoint = message.endpoint);
    message.packaging !== void 0 && (obj.packaging = message.packaging ? exports2.ObjectStoragePackaging.toJSON(message.packaging) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
    const message = createBaseS3StorageAddress();
    message.region = (_a2 = object.region) !== null && _a2 !== void 0 ? _a2 : "";
    message.bucket = (_b = object.bucket) !== null && _b !== void 0 ? _b : "";
    message.prefix = (_c = object.prefix) !== null && _c !== void 0 ? _c : void 0;
    message.accessKey = (_d = object.accessKey) !== null && _d !== void 0 ? _d : "";
    message.secretKey = (_e = object.secretKey) !== null && _e !== void 0 ? _e : "";
    message.token = (_f = object.token) !== null && _f !== void 0 ? _f : void 0;
    message.tokenDuration = (_g = object.tokenDuration) !== null && _g !== void 0 ? _g : void 0;
    message.acl = (_h = object.acl) !== null && _h !== void 0 ? _h : void 0;
    message.endpoint = (_j = object.endpoint) !== null && _j !== void 0 ? _j : void 0;
    message.packaging = object.packaging !== void 0 && object.packaging !== null ? exports2.ObjectStoragePackaging.fromPartial(object.packaging) : void 0;
    return message;
  } };
  function createBaseDestinationAddress() {
    return { rtmpPush: void 0, agora: void 0, s3Storage: void 0 };
  }
  exports2.DestinationAddress = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.rtmpPush !== void 0) {
      exports2.DestinationRtmpPushAddress.encode(message.rtmpPush, writer2.uint32(10).fork()).ldelim();
    }
    if (message.agora !== void 0) {
      exports2.DestinationAgoraPushAddress.encode(message.agora, writer2.uint32(18).fork()).ldelim();
    }
    if (message.s3Storage !== void 0) {
      exports2.S3StorageAddress.encode(message.s3Storage, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDestinationAddress();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rtmpPush = exports2.DestinationRtmpPushAddress.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.agora = exports2.DestinationAgoraPushAddress.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.s3Storage = exports2.S3StorageAddress.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { rtmpPush: isSet2(object.rtmpPush) ? exports2.DestinationRtmpPushAddress.fromJSON(object.rtmpPush) : void 0, agora: isSet2(object.agora) ? exports2.DestinationAgoraPushAddress.fromJSON(object.agora) : void 0, s3Storage: isSet2(object.s3Storage) ? exports2.S3StorageAddress.fromJSON(object.s3Storage) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.rtmpPush !== void 0 && (obj.rtmpPush = message.rtmpPush ? exports2.DestinationRtmpPushAddress.toJSON(message.rtmpPush) : void 0);
    message.agora !== void 0 && (obj.agora = message.agora ? exports2.DestinationAgoraPushAddress.toJSON(message.agora) : void 0);
    message.s3Storage !== void 0 && (obj.s3Storage = message.s3Storage ? exports2.S3StorageAddress.toJSON(message.s3Storage) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseDestinationAddress();
    message.rtmpPush = object.rtmpPush !== void 0 && object.rtmpPush !== null ? exports2.DestinationRtmpPushAddress.fromPartial(object.rtmpPush) : void 0;
    message.agora = object.agora !== void 0 && object.agora !== null ? exports2.DestinationAgoraPushAddress.fromPartial(object.agora) : void 0;
    message.s3Storage = object.s3Storage !== void 0 && object.s3Storage !== null ? exports2.S3StorageAddress.fromPartial(object.s3Storage) : void 0;
    return message;
  } };
  function createBaseSourceTrigger() {
    return { sourceId: "", start: void 0, stop: void 0 };
  }
  exports2.SourceTrigger = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.sourceId !== "") {
      writer2.uint32(10).string(message.sourceId);
    }
    if (message.start !== void 0) {
      writer2.uint32(16).int32(sourceTriggerActionToNumber(message.start));
    }
    if (message.stop !== void 0) {
      writer2.uint32(24).int32(sourceTriggerActionToNumber(message.stop));
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSourceTrigger();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sourceId = reader2.string();
          break;
        case 2:
          message.start = sourceTriggerActionFromJSON(reader2.int32());
          break;
        case 3:
          message.stop = sourceTriggerActionFromJSON(reader2.int32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "", start: isSet2(object.start) ? sourceTriggerActionFromJSON(object.start) : void 0, stop: isSet2(object.stop) ? sourceTriggerActionFromJSON(object.stop) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
    message.start !== void 0 && (obj.start = message.start !== void 0 ? sourceTriggerActionToJSON(message.start) : void 0);
    message.stop !== void 0 && (obj.stop = message.stop !== void 0 ? sourceTriggerActionToJSON(message.stop) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseSourceTrigger();
    message.sourceId = (_a2 = object.sourceId) !== null && _a2 !== void 0 ? _a2 : "";
    message.start = (_b = object.start) !== null && _b !== void 0 ? _b : void 0;
    message.stop = (_c = object.stop) !== null && _c !== void 0 ? _c : void 0;
    return message;
  } };
  function createBaseWebRtcTrigger() {
    return { stop: void 0 };
  }
  exports2.WebRtcTrigger = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.stop !== void 0) {
      writer2.uint32(24).int32(sourceTriggerActionToNumber(message.stop));
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseWebRtcTrigger();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 3:
          message.stop = sourceTriggerActionFromJSON(reader2.int32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { stop: isSet2(object.stop) ? sourceTriggerActionFromJSON(object.stop) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.stop !== void 0 && (obj.stop = message.stop !== void 0 ? sourceTriggerActionToJSON(message.stop) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseWebRtcTrigger();
    message.stop = (_a2 = object.stop) !== null && _a2 !== void 0 ? _a2 : void 0;
    return message;
  } };
  function createBaseProjectTrigger() {
    return { source: void 0 };
  }
  exports2.ProjectTrigger = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.source !== void 0) {
      exports2.SourceTrigger.encode(message.source, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseProjectTrigger();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.source = exports2.SourceTrigger.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { source: isSet2(object.source) ? exports2.SourceTrigger.fromJSON(object.source) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.source !== void 0 && (obj.source = message.source ? exports2.SourceTrigger.toJSON(message.source) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseProjectTrigger();
    message.source = object.source !== void 0 && object.source !== null ? exports2.SourceTrigger.fromPartial(object.source) : void 0;
    return message;
  } };
  function createBasePreviewHlsPullAddress() {
    return { enabled: void 0, url: void 0 };
  }
  exports2.PreviewHlsPullAddress = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.enabled !== void 0) {
      writer2.uint32(8).bool(message.enabled);
    }
    if (message.url !== void 0) {
      writer2.uint32(18).string(message.url);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBasePreviewHlsPullAddress();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.enabled = reader2.bool();
          break;
        case 2:
          message.url = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { enabled: isSet2(object.enabled) ? Boolean(object.enabled) : void 0, url: isSet2(object.url) ? String(object.url) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.enabled !== void 0 && (obj.enabled = message.enabled);
    message.url !== void 0 && (obj.url = message.url);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBasePreviewHlsPullAddress();
    message.enabled = (_a2 = object.enabled) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.url = (_b = object.url) !== null && _b !== void 0 ? _b : void 0;
    return message;
  } };
  function createBasePreviewWebRtcAddress() {
    return { enabled: void 0, displayName: void 0, participantId: void 0 };
  }
  exports2.PreviewWebRtcAddress = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.enabled !== void 0) {
      writer2.uint32(8).bool(message.enabled);
    }
    if (message.displayName !== void 0) {
      writer2.uint32(18).string(message.displayName);
    }
    if (message.participantId !== void 0) {
      writer2.uint32(26).string(message.participantId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBasePreviewWebRtcAddress();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.enabled = reader2.bool();
          break;
        case 2:
          message.displayName = reader2.string();
          break;
        case 3:
          message.participantId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { enabled: isSet2(object.enabled) ? Boolean(object.enabled) : void 0, displayName: isSet2(object.displayName) ? String(object.displayName) : void 0, participantId: isSet2(object.participantId) ? String(object.participantId) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.enabled !== void 0 && (obj.enabled = message.enabled);
    message.displayName !== void 0 && (obj.displayName = message.displayName);
    message.participantId !== void 0 && (obj.participantId = message.participantId);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBasePreviewWebRtcAddress();
    message.enabled = (_a2 = object.enabled) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.displayName = (_b = object.displayName) !== null && _b !== void 0 ? _b : void 0;
    message.participantId = (_c = object.participantId) !== null && _c !== void 0 ? _c : void 0;
    return message;
  } };
  function createBasePreviewAddress() {
    return { webrtc: void 0 };
  }
  exports2.PreviewAddress = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.webrtc !== void 0) {
      exports2.PreviewWebRtcAddress.encode(message.webrtc, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBasePreviewAddress();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 2:
          message.webrtc = exports2.PreviewWebRtcAddress.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { webrtc: isSet2(object.webrtc) ? exports2.PreviewWebRtcAddress.fromJSON(object.webrtc) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.webrtc !== void 0 && (obj.webrtc = message.webrtc ? exports2.PreviewWebRtcAddress.toJSON(message.webrtc) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBasePreviewAddress();
    message.webrtc = object.webrtc !== void 0 && object.webrtc !== null ? exports2.PreviewWebRtcAddress.fromPartial(object.webrtc) : void 0;
    return message;
  } };
  function createBaseStudioSdkComposition() {
    return { rendererUrl: void 0, version: void 0 };
  }
  exports2.StudioSdkComposition = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.rendererUrl !== void 0) {
      writer2.uint32(10).string(message.rendererUrl);
    }
    if (message.version !== void 0) {
      writer2.uint32(18).string(message.version);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStudioSdkComposition();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rendererUrl = reader2.string();
          break;
        case 2:
          message.version = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { rendererUrl: isSet2(object.rendererUrl) ? String(object.rendererUrl) : void 0, version: isSet2(object.version) ? String(object.version) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.rendererUrl !== void 0 && (obj.rendererUrl = message.rendererUrl);
    message.version !== void 0 && (obj.version = message.version);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseStudioSdkComposition();
    message.rendererUrl = (_a2 = object.rendererUrl) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.version = (_b = object.version) !== null && _b !== void 0 ? _b : void 0;
    return message;
  } };
  function createBaseSceneComposition() {
    return { rendererUrl: void 0, selectedLayoutId: void 0, debug: void 0 };
  }
  exports2.SceneComposition = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.rendererUrl !== void 0) {
      writer2.uint32(10).string(message.rendererUrl);
    }
    if (message.selectedLayoutId !== void 0) {
      writer2.uint32(18).string(message.selectedLayoutId);
    }
    if (message.debug !== void 0) {
      writer2.uint32(24).bool(message.debug);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSceneComposition();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rendererUrl = reader2.string();
          break;
        case 2:
          message.selectedLayoutId = reader2.string();
          break;
        case 3:
          message.debug = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { rendererUrl: isSet2(object.rendererUrl) ? String(object.rendererUrl) : void 0, selectedLayoutId: isSet2(object.selectedLayoutId) ? String(object.selectedLayoutId) : void 0, debug: isSet2(object.debug) ? Boolean(object.debug) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.rendererUrl !== void 0 && (obj.rendererUrl = message.rendererUrl);
    message.selectedLayoutId !== void 0 && (obj.selectedLayoutId = message.selectedLayoutId);
    message.debug !== void 0 && (obj.debug = message.debug);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseSceneComposition();
    message.rendererUrl = (_a2 = object.rendererUrl) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.selectedLayoutId = (_b = object.selectedLayoutId) !== null && _b !== void 0 ? _b : void 0;
    message.debug = (_c = object.debug) !== null && _c !== void 0 ? _c : void 0;
    return message;
  } };
  function createBaseExternalComposition() {
    return { url: "" };
  }
  exports2.ExternalComposition = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.url !== "") {
      writer2.uint32(10).string(message.url);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseExternalComposition();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.url = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { url: isSet2(object.url) ? String(object.url) : "" };
  }, toJSON(message) {
    const obj = {};
    message.url !== void 0 && (obj.url = message.url);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseExternalComposition();
    message.url = (_a2 = object.url) !== null && _a2 !== void 0 ? _a2 : "";
    return message;
  } };
  function createBaseComposition() {
    return { external: void 0, studioSdk: void 0, scene: void 0 };
  }
  exports2.Composition = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.external !== void 0) {
      exports2.ExternalComposition.encode(message.external, writer2.uint32(10).fork()).ldelim();
    }
    if (message.studioSdk !== void 0) {
      exports2.StudioSdkComposition.encode(message.studioSdk, writer2.uint32(18).fork()).ldelim();
    }
    if (message.scene !== void 0) {
      exports2.SceneComposition.encode(message.scene, writer2.uint32(34).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseComposition();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.external = exports2.ExternalComposition.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.studioSdk = exports2.StudioSdkComposition.decode(reader2, reader2.uint32());
          break;
        case 4:
          message.scene = exports2.SceneComposition.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { external: isSet2(object.external) ? exports2.ExternalComposition.fromJSON(object.external) : void 0, studioSdk: isSet2(object.studioSdk) ? exports2.StudioSdkComposition.fromJSON(object.studioSdk) : void 0, scene: isSet2(object.scene) ? exports2.SceneComposition.fromJSON(object.scene) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.external !== void 0 && (obj.external = message.external ? exports2.ExternalComposition.toJSON(message.external) : void 0);
    message.studioSdk !== void 0 && (obj.studioSdk = message.studioSdk ? exports2.StudioSdkComposition.toJSON(message.studioSdk) : void 0);
    message.scene !== void 0 && (obj.scene = message.scene ? exports2.SceneComposition.toJSON(message.scene) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseComposition();
    message.external = object.external !== void 0 && object.external !== null ? exports2.ExternalComposition.fromPartial(object.external) : void 0;
    message.studioSdk = object.studioSdk !== void 0 && object.studioSdk !== null ? exports2.StudioSdkComposition.fromPartial(object.studioSdk) : void 0;
    message.scene = object.scene !== void 0 && object.scene !== null ? exports2.SceneComposition.fromPartial(object.scene) : void 0;
    return message;
  } };
  function createBaseHostedWebRtc() {
    return { enabled: void 0 };
  }
  exports2.HostedWebRtc = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.enabled !== void 0) {
      writer2.uint32(8).bool(message.enabled);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseHostedWebRtc();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.enabled = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { enabled: isSet2(object.enabled) ? Boolean(object.enabled) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.enabled !== void 0 && (obj.enabled = message.enabled);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseHostedWebRtc();
    message.enabled = (_a2 = object.enabled) !== null && _a2 !== void 0 ? _a2 : void 0;
    return message;
  } };
  function createBaseWebRtc() {
    return { hosted: void 0 };
  }
  exports2.WebRtc = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.hosted !== void 0) {
      exports2.HostedWebRtc.encode(message.hosted, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseWebRtc();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hosted = exports2.HostedWebRtc.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { hosted: isSet2(object.hosted) ? exports2.HostedWebRtc.fromJSON(object.hosted) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.hosted !== void 0 && (obj.hosted = message.hosted ? exports2.HostedWebRtc.toJSON(message.hosted) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseWebRtc();
    message.hosted = object.hosted !== void 0 && object.hosted !== null ? exports2.HostedWebRtc.fromPartial(object.hosted) : void 0;
    return message;
  } };
  function createBaseWebRtcAccess() {
    return { accessToken: "", participantId: void 0 };
  }
  exports2.WebRtcAccess = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.accessToken !== "") {
      writer2.uint32(10).string(message.accessToken);
    }
    if (message.participantId !== void 0) {
      writer2.uint32(26).string(message.participantId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseWebRtcAccess();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accessToken = reader2.string();
          break;
        case 3:
          message.participantId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { accessToken: isSet2(object.accessToken) ? String(object.accessToken) : "", participantId: isSet2(object.participantId) ? String(object.participantId) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.accessToken !== void 0 && (obj.accessToken = message.accessToken);
    message.participantId !== void 0 && (obj.participantId = message.participantId);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseWebRtcAccess();
    message.accessToken = (_a2 = object.accessToken) !== null && _a2 !== void 0 ? _a2 : "";
    message.participantId = (_b = object.participantId) !== null && _b !== void 0 ? _b : void 0;
    return message;
  } };
  function createBaseLatLong() {
    return { latitude: 0, longitude: 0 };
  }
  exports2.LatLong = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.latitude !== 0) {
      writer2.uint32(9).double(message.latitude);
    }
    if (message.longitude !== 0) {
      writer2.uint32(17).double(message.longitude);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseLatLong();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.latitude = reader2.double();
          break;
        case 2:
          message.longitude = reader2.double();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { latitude: isSet2(object.latitude) ? Number(object.latitude) : 0, longitude: isSet2(object.longitude) ? Number(object.longitude) : 0 };
  }, toJSON(message) {
    const obj = {};
    message.latitude !== void 0 && (obj.latitude = message.latitude);
    message.longitude !== void 0 && (obj.longitude = message.longitude);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseLatLong();
    message.latitude = (_a2 = object.latitude) !== null && _a2 !== void 0 ? _a2 : 0;
    message.longitude = (_b = object.longitude) !== null && _b !== void 0 ? _b : 0;
    return message;
  } };
  function createBaseProjectBroadcastStatus() {
    return { collectionId: "", projectId: "", broadcastId: void 0, duration: void 0, start: void 0, stop: void 0, phase: ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_UNSPECIFIED, region: void 0, datacenter: void 0 };
  }
  exports2.ProjectBroadcastStatus = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.broadcastId !== void 0) {
      writer2.uint32(26).string(message.broadcastId);
    }
    if (message.duration !== void 0) {
      writer2.uint32(32).uint32(message.duration);
    }
    if (message.start !== void 0) {
      timestamp_1.Timestamp.encode(toTimestamp(message.start), writer2.uint32(42).fork()).ldelim();
    }
    if (message.stop !== void 0) {
      timestamp_1.Timestamp.encode(toTimestamp(message.stop), writer2.uint32(50).fork()).ldelim();
    }
    if (message.phase !== ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_UNSPECIFIED) {
      writer2.uint32(56).int32(projectBroadcastPhaseToNumber(message.phase));
    }
    if (message.region !== void 0) {
      writer2.uint32(64).int32(regionToNumber(message.region));
    }
    if (message.datacenter !== void 0) {
      writer2.uint32(74).string(message.datacenter);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseProjectBroadcastStatus();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.broadcastId = reader2.string();
          break;
        case 4:
          message.duration = reader2.uint32();
          break;
        case 5:
          message.start = fromTimestamp(timestamp_1.Timestamp.decode(reader2, reader2.uint32()));
          break;
        case 6:
          message.stop = fromTimestamp(timestamp_1.Timestamp.decode(reader2, reader2.uint32()));
          break;
        case 7:
          message.phase = projectBroadcastPhaseFromJSON(reader2.int32());
          break;
        case 8:
          message.region = regionFromJSON(reader2.int32());
          break;
        case 9:
          message.datacenter = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", broadcastId: isSet2(object.broadcastId) ? String(object.broadcastId) : void 0, duration: isSet2(object.duration) ? Number(object.duration) : void 0, start: isSet2(object.start) ? String(object.start) : void 0, stop: isSet2(object.stop) ? String(object.stop) : void 0, phase: isSet2(object.phase) ? projectBroadcastPhaseFromJSON(object.phase) : ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_UNSPECIFIED, region: isSet2(object.region) ? regionFromJSON(object.region) : void 0, datacenter: isSet2(object.datacenter) ? String(object.datacenter) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.broadcastId !== void 0 && (obj.broadcastId = message.broadcastId);
    message.duration !== void 0 && (obj.duration = Math.round(message.duration));
    message.start !== void 0 && (obj.start = message.start);
    message.stop !== void 0 && (obj.stop = message.stop);
    message.phase !== void 0 && (obj.phase = projectBroadcastPhaseToJSON(message.phase));
    message.region !== void 0 && (obj.region = message.region !== void 0 ? regionToJSON(message.region) : void 0);
    message.datacenter !== void 0 && (obj.datacenter = message.datacenter);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
    const message = createBaseProjectBroadcastStatus();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.broadcastId = (_c = object.broadcastId) !== null && _c !== void 0 ? _c : void 0;
    message.duration = (_d = object.duration) !== null && _d !== void 0 ? _d : void 0;
    message.start = (_e = object.start) !== null && _e !== void 0 ? _e : void 0;
    message.stop = (_f = object.stop) !== null && _f !== void 0 ? _f : void 0;
    message.phase = (_g = object.phase) !== null && _g !== void 0 ? _g : ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_UNSPECIFIED;
    message.region = (_h = object.region) !== null && _h !== void 0 ? _h : void 0;
    message.datacenter = (_j = object.datacenter) !== null && _j !== void 0 ? _j : void 0;
    return message;
  } };
  function createBaseSource() {
    return { collectionId: "", sourceId: "", metadata: void 0, preview: void 0, address: void 0 };
  }
  exports2.Source = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.sourceId !== "") {
      writer2.uint32(18).string(message.sourceId);
    }
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(26).fork()).ldelim();
    }
    if (message.preview !== void 0) {
      exports2.PreviewAddress.encode(message.preview, writer2.uint32(34).fork()).ldelim();
    }
    if (message.address !== void 0) {
      exports2.SourceAddress.encode(message.address, writer2.uint32(50).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSource();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.sourceId = reader2.string();
          break;
        case 3:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 4:
          message.preview = exports2.PreviewAddress.decode(reader2, reader2.uint32());
          break;
        case 6:
          message.address = exports2.SourceAddress.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "", metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0, preview: isSet2(object.preview) ? exports2.PreviewAddress.fromJSON(object.preview) : void 0, address: isSet2(object.address) ? exports2.SourceAddress.fromJSON(object.address) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.preview !== void 0 && (obj.preview = message.preview ? exports2.PreviewAddress.toJSON(message.preview) : void 0);
    message.address !== void 0 && (obj.address = message.address ? exports2.SourceAddress.toJSON(message.address) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseSource();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
    message.metadata = (_c = object.metadata) !== null && _c !== void 0 ? _c : void 0;
    message.preview = object.preview !== void 0 && object.preview !== null ? exports2.PreviewAddress.fromPartial(object.preview) : void 0;
    message.address = object.address !== void 0 && object.address !== null ? exports2.SourceAddress.fromPartial(object.address) : void 0;
    return message;
  } };
  function createBaseDestination() {
    return { collectionId: "", projectId: "", destinationId: "", metadata: void 0, enabled: void 0, address: void 0, timeout: void 0 };
  }
  exports2.Destination = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.destinationId !== "") {
      writer2.uint32(26).string(message.destinationId);
    }
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(34).fork()).ldelim();
    }
    if (message.enabled !== void 0) {
      writer2.uint32(40).bool(message.enabled);
    }
    if (message.address !== void 0) {
      exports2.DestinationAddress.encode(message.address, writer2.uint32(50).fork()).ldelim();
    }
    if (message.timeout !== void 0) {
      writer2.uint32(56).uint32(message.timeout);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDestination();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.destinationId = reader2.string();
          break;
        case 4:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 5:
          message.enabled = reader2.bool();
          break;
        case 6:
          message.address = exports2.DestinationAddress.decode(reader2, reader2.uint32());
          break;
        case 7:
          message.timeout = reader2.uint32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", destinationId: isSet2(object.destinationId) ? String(object.destinationId) : "", metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0, enabled: isSet2(object.enabled) ? Boolean(object.enabled) : void 0, address: isSet2(object.address) ? exports2.DestinationAddress.fromJSON(object.address) : void 0, timeout: isSet2(object.timeout) ? Number(object.timeout) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.destinationId !== void 0 && (obj.destinationId = message.destinationId);
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.enabled !== void 0 && (obj.enabled = message.enabled);
    message.address !== void 0 && (obj.address = message.address ? exports2.DestinationAddress.toJSON(message.address) : void 0);
    message.timeout !== void 0 && (obj.timeout = Math.round(message.timeout));
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f;
    const message = createBaseDestination();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.destinationId = (_c = object.destinationId) !== null && _c !== void 0 ? _c : "";
    message.metadata = (_d = object.metadata) !== null && _d !== void 0 ? _d : void 0;
    message.enabled = (_e = object.enabled) !== null && _e !== void 0 ? _e : void 0;
    message.address = object.address !== void 0 && object.address !== null ? exports2.DestinationAddress.fromPartial(object.address) : void 0;
    message.timeout = (_f = object.timeout) !== null && _f !== void 0 ? _f : void 0;
    return message;
  } };
  function createBaseProject() {
    return { collectionId: "", projectId: "", metadata: void 0, rendering: void 0, encoding: void 0, sources: [], destinations: [], composition: void 0, maxDuration: void 0, webrtc: void 0, triggers: [], location: void 0, guestCodes: [] };
  }
  exports2.Project = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(26).fork()).ldelim();
    }
    if (message.rendering !== void 0) {
      exports2.Rendering.encode(message.rendering, writer2.uint32(34).fork()).ldelim();
    }
    if (message.encoding !== void 0) {
      exports2.Encoding.encode(message.encoding, writer2.uint32(42).fork()).ldelim();
    }
    for (const v2 of message.sources) {
      exports2.Source.encode(v2, writer2.uint32(50).fork()).ldelim();
    }
    for (const v2 of message.destinations) {
      exports2.Destination.encode(v2, writer2.uint32(58).fork()).ldelim();
    }
    if (message.composition !== void 0) {
      exports2.Composition.encode(message.composition, writer2.uint32(66).fork()).ldelim();
    }
    if (message.maxDuration !== void 0) {
      writer2.uint32(72).uint32(message.maxDuration);
    }
    if (message.webrtc !== void 0) {
      exports2.WebRtc.encode(message.webrtc, writer2.uint32(82).fork()).ldelim();
    }
    for (const v2 of message.triggers) {
      exports2.ProjectTrigger.encode(v2, writer2.uint32(90).fork()).ldelim();
    }
    if (message.location !== void 0) {
      exports2.LatLong.encode(message.location, writer2.uint32(98).fork()).ldelim();
    }
    for (const v2 of message.guestCodes) {
      exports2.GuestCode.encode(v2, writer2.uint32(106).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseProject();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 4:
          message.rendering = exports2.Rendering.decode(reader2, reader2.uint32());
          break;
        case 5:
          message.encoding = exports2.Encoding.decode(reader2, reader2.uint32());
          break;
        case 6:
          message.sources.push(exports2.Source.decode(reader2, reader2.uint32()));
          break;
        case 7:
          message.destinations.push(exports2.Destination.decode(reader2, reader2.uint32()));
          break;
        case 8:
          message.composition = exports2.Composition.decode(reader2, reader2.uint32());
          break;
        case 9:
          message.maxDuration = reader2.uint32();
          break;
        case 10:
          message.webrtc = exports2.WebRtc.decode(reader2, reader2.uint32());
          break;
        case 11:
          message.triggers.push(exports2.ProjectTrigger.decode(reader2, reader2.uint32()));
          break;
        case 12:
          message.location = exports2.LatLong.decode(reader2, reader2.uint32());
          break;
        case 13:
          message.guestCodes.push(exports2.GuestCode.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0, rendering: isSet2(object.rendering) ? exports2.Rendering.fromJSON(object.rendering) : void 0, encoding: isSet2(object.encoding) ? exports2.Encoding.fromJSON(object.encoding) : void 0, sources: Array.isArray(object === null || object === void 0 ? void 0 : object.sources) ? object.sources.map((e2) => exports2.Source.fromJSON(e2)) : [], destinations: Array.isArray(object === null || object === void 0 ? void 0 : object.destinations) ? object.destinations.map((e2) => exports2.Destination.fromJSON(e2)) : [], composition: isSet2(object.composition) ? exports2.Composition.fromJSON(object.composition) : void 0, maxDuration: isSet2(object.maxDuration) ? Number(object.maxDuration) : void 0, webrtc: isSet2(object.webrtc) ? exports2.WebRtc.fromJSON(object.webrtc) : void 0, triggers: Array.isArray(object === null || object === void 0 ? void 0 : object.triggers) ? object.triggers.map((e2) => exports2.ProjectTrigger.fromJSON(e2)) : [], location: isSet2(object.location) ? exports2.LatLong.fromJSON(object.location) : void 0, guestCodes: Array.isArray(object === null || object === void 0 ? void 0 : object.guestCodes) ? object.guestCodes.map((e2) => exports2.GuestCode.fromJSON(e2)) : [] };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.rendering !== void 0 && (obj.rendering = message.rendering ? exports2.Rendering.toJSON(message.rendering) : void 0);
    message.encoding !== void 0 && (obj.encoding = message.encoding ? exports2.Encoding.toJSON(message.encoding) : void 0);
    if (message.sources) {
      obj.sources = message.sources.map((e2) => e2 ? exports2.Source.toJSON(e2) : void 0);
    } else {
      obj.sources = [];
    }
    if (message.destinations) {
      obj.destinations = message.destinations.map((e2) => e2 ? exports2.Destination.toJSON(e2) : void 0);
    } else {
      obj.destinations = [];
    }
    message.composition !== void 0 && (obj.composition = message.composition ? exports2.Composition.toJSON(message.composition) : void 0);
    message.maxDuration !== void 0 && (obj.maxDuration = Math.round(message.maxDuration));
    message.webrtc !== void 0 && (obj.webrtc = message.webrtc ? exports2.WebRtc.toJSON(message.webrtc) : void 0);
    if (message.triggers) {
      obj.triggers = message.triggers.map((e2) => e2 ? exports2.ProjectTrigger.toJSON(e2) : void 0);
    } else {
      obj.triggers = [];
    }
    message.location !== void 0 && (obj.location = message.location ? exports2.LatLong.toJSON(message.location) : void 0);
    if (message.guestCodes) {
      obj.guestCodes = message.guestCodes.map((e2) => e2 ? exports2.GuestCode.toJSON(e2) : void 0);
    } else {
      obj.guestCodes = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    const message = createBaseProject();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.metadata = (_c = object.metadata) !== null && _c !== void 0 ? _c : void 0;
    message.rendering = object.rendering !== void 0 && object.rendering !== null ? exports2.Rendering.fromPartial(object.rendering) : void 0;
    message.encoding = object.encoding !== void 0 && object.encoding !== null ? exports2.Encoding.fromPartial(object.encoding) : void 0;
    message.sources = ((_d = object.sources) === null || _d === void 0 ? void 0 : _d.map((e2) => exports2.Source.fromPartial(e2))) || [];
    message.destinations = ((_e = object.destinations) === null || _e === void 0 ? void 0 : _e.map((e2) => exports2.Destination.fromPartial(e2))) || [];
    message.composition = object.composition !== void 0 && object.composition !== null ? exports2.Composition.fromPartial(object.composition) : void 0;
    message.maxDuration = (_f = object.maxDuration) !== null && _f !== void 0 ? _f : void 0;
    message.webrtc = object.webrtc !== void 0 && object.webrtc !== null ? exports2.WebRtc.fromPartial(object.webrtc) : void 0;
    message.triggers = ((_g = object.triggers) === null || _g === void 0 ? void 0 : _g.map((e2) => exports2.ProjectTrigger.fromPartial(e2))) || [];
    message.location = object.location !== void 0 && object.location !== null ? exports2.LatLong.fromPartial(object.location) : void 0;
    message.guestCodes = ((_h = object.guestCodes) === null || _h === void 0 ? void 0 : _h.map((e2) => exports2.GuestCode.fromPartial(e2))) || [];
    return message;
  } };
  function createBaseCollection() {
    return { collectionId: "", metadata: void 0, projects: [], sources: [] };
  }
  exports2.Collection = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(18).fork()).ldelim();
    }
    for (const v2 of message.projects) {
      exports2.Project.encode(v2, writer2.uint32(26).fork()).ldelim();
    }
    for (const v2 of message.sources) {
      exports2.Source.encode(v2, writer2.uint32(34).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCollection();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 3:
          message.projects.push(exports2.Project.decode(reader2, reader2.uint32()));
          break;
        case 4:
          message.sources.push(exports2.Source.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0, projects: Array.isArray(object === null || object === void 0 ? void 0 : object.projects) ? object.projects.map((e2) => exports2.Project.fromJSON(e2)) : [], sources: Array.isArray(object === null || object === void 0 ? void 0 : object.sources) ? object.sources.map((e2) => exports2.Source.fromJSON(e2)) : [] };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    if (message.projects) {
      obj.projects = message.projects.map((e2) => e2 ? exports2.Project.toJSON(e2) : void 0);
    } else {
      obj.projects = [];
    }
    if (message.sources) {
      obj.sources = message.sources.map((e2) => e2 ? exports2.Source.toJSON(e2) : void 0);
    } else {
      obj.sources = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseCollection();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.metadata = (_b = object.metadata) !== null && _b !== void 0 ? _b : void 0;
    message.projects = ((_c = object.projects) === null || _c === void 0 ? void 0 : _c.map((e2) => exports2.Project.fromPartial(e2))) || [];
    message.sources = ((_d = object.sources) === null || _d === void 0 ? void 0 : _d.map((e2) => exports2.Source.fromPartial(e2))) || [];
    return message;
  } };
  function createBaseCreateCollectionRequest() {
    return { metadata: void 0 };
  }
  exports2.CreateCollectionRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCreateCollectionRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseCreateCollectionRequest();
    message.metadata = (_a2 = object.metadata) !== null && _a2 !== void 0 ? _a2 : void 0;
    return message;
  } };
  function createBaseCreateCollectionResponse() {
    return { collection: void 0 };
  }
  exports2.CreateCollectionResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collection !== void 0) {
      exports2.Collection.encode(message.collection, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCreateCollectionResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collection = exports2.Collection.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collection: isSet2(object.collection) ? exports2.Collection.fromJSON(object.collection) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collection !== void 0 && (obj.collection = message.collection ? exports2.Collection.toJSON(message.collection) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseCreateCollectionResponse();
    message.collection = object.collection !== void 0 && object.collection !== null ? exports2.Collection.fromPartial(object.collection) : void 0;
    return message;
  } };
  function createBaseGetCollectionRequest() {
    return { collectionId: "", populateProjects: void 0, populateSources: void 0 };
  }
  exports2.GetCollectionRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.populateProjects !== void 0) {
      writer2.uint32(16).bool(message.populateProjects);
    }
    if (message.populateSources !== void 0) {
      writer2.uint32(24).bool(message.populateSources);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetCollectionRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.populateProjects = reader2.bool();
          break;
        case 3:
          message.populateSources = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", populateProjects: isSet2(object.populateProjects) ? Boolean(object.populateProjects) : void 0, populateSources: isSet2(object.populateSources) ? Boolean(object.populateSources) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.populateProjects !== void 0 && (obj.populateProjects = message.populateProjects);
    message.populateSources !== void 0 && (obj.populateSources = message.populateSources);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseGetCollectionRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.populateProjects = (_b = object.populateProjects) !== null && _b !== void 0 ? _b : void 0;
    message.populateSources = (_c = object.populateSources) !== null && _c !== void 0 ? _c : void 0;
    return message;
  } };
  function createBaseGetCollectionResponse() {
    return { collection: void 0 };
  }
  exports2.GetCollectionResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collection !== void 0) {
      exports2.Collection.encode(message.collection, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetCollectionResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collection = exports2.Collection.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collection: isSet2(object.collection) ? exports2.Collection.fromJSON(object.collection) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collection !== void 0 && (obj.collection = message.collection ? exports2.Collection.toJSON(message.collection) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseGetCollectionResponse();
    message.collection = object.collection !== void 0 && object.collection !== null ? exports2.Collection.fromPartial(object.collection) : void 0;
    return message;
  } };
  function createBaseUpdateCollectionRequest() {
    return { collectionId: "", updateMask: void 0, metadata: void 0 };
  }
  exports2.UpdateCollectionRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.updateMask !== void 0) {
      field_mask_1.FieldMask.encode(field_mask_1.FieldMask.wrap(message.updateMask), writer2.uint32(18).fork()).ldelim();
    }
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUpdateCollectionRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.updateMask = field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.decode(reader2, reader2.uint32()));
          break;
        case 3:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", updateMask: isSet2(object.updateMask) ? field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.fromJSON(object.updateMask)) : void 0, metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.updateMask !== void 0 && (obj.updateMask = field_mask_1.FieldMask.toJSON(field_mask_1.FieldMask.wrap(message.updateMask)));
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseUpdateCollectionRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.updateMask = (_b = object.updateMask) !== null && _b !== void 0 ? _b : void 0;
    message.metadata = (_c = object.metadata) !== null && _c !== void 0 ? _c : void 0;
    return message;
  } };
  function createBaseUpdateCollectionResponse() {
    return { collection: void 0 };
  }
  exports2.UpdateCollectionResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collection !== void 0) {
      exports2.Collection.encode(message.collection, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUpdateCollectionResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collection = exports2.Collection.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collection: isSet2(object.collection) ? exports2.Collection.fromJSON(object.collection) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collection !== void 0 && (obj.collection = message.collection ? exports2.Collection.toJSON(message.collection) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseUpdateCollectionResponse();
    message.collection = object.collection !== void 0 && object.collection !== null ? exports2.Collection.fromPartial(object.collection) : void 0;
    return message;
  } };
  function createBaseDeleteCollectionRequest() {
    return { collectionId: "", force: void 0 };
  }
  exports2.DeleteCollectionRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.force !== void 0) {
      writer2.uint32(16).bool(message.force);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDeleteCollectionRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.force = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", force: isSet2(object.force) ? Boolean(object.force) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.force !== void 0 && (obj.force = message.force);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseDeleteCollectionRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.force = (_b = object.force) !== null && _b !== void 0 ? _b : void 0;
    return message;
  } };
  function createBaseDeleteCollectionResponse() {
    return { sourcesDeleted: 0, projectsDeleted: 0, projectIdsStopped: [] };
  }
  exports2.DeleteCollectionResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.sourcesDeleted !== 0) {
      writer2.uint32(8).uint32(message.sourcesDeleted);
    }
    if (message.projectsDeleted !== 0) {
      writer2.uint32(16).uint32(message.projectsDeleted);
    }
    for (const v2 of message.projectIdsStopped) {
      writer2.uint32(26).string(v2);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDeleteCollectionResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sourcesDeleted = reader2.uint32();
          break;
        case 2:
          message.projectsDeleted = reader2.uint32();
          break;
        case 3:
          message.projectIdsStopped.push(reader2.string());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { sourcesDeleted: isSet2(object.sourcesDeleted) ? Number(object.sourcesDeleted) : 0, projectsDeleted: isSet2(object.projectsDeleted) ? Number(object.projectsDeleted) : 0, projectIdsStopped: Array.isArray(object === null || object === void 0 ? void 0 : object.projectIdsStopped) ? object.projectIdsStopped.map((e2) => String(e2)) : [] };
  }, toJSON(message) {
    const obj = {};
    message.sourcesDeleted !== void 0 && (obj.sourcesDeleted = Math.round(message.sourcesDeleted));
    message.projectsDeleted !== void 0 && (obj.projectsDeleted = Math.round(message.projectsDeleted));
    if (message.projectIdsStopped) {
      obj.projectIdsStopped = message.projectIdsStopped.map((e2) => e2);
    } else {
      obj.projectIdsStopped = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseDeleteCollectionResponse();
    message.sourcesDeleted = (_a2 = object.sourcesDeleted) !== null && _a2 !== void 0 ? _a2 : 0;
    message.projectsDeleted = (_b = object.projectsDeleted) !== null && _b !== void 0 ? _b : 0;
    message.projectIdsStopped = ((_c = object.projectIdsStopped) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
    return message;
  } };
  function createBaseGetCollectionsRequest() {
    return {};
  }
  exports2.GetCollectionsRequest = { encode(_, writer2 = _m02.Writer.create()) {
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetCollectionsRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(_) {
    return {};
  }, toJSON(_) {
    const obj = {};
    return obj;
  }, fromPartial(_) {
    const message = createBaseGetCollectionsRequest();
    return message;
  } };
  function createBaseGetCollectionsResponse() {
    return { collections: [] };
  }
  exports2.GetCollectionsResponse = { encode(message, writer2 = _m02.Writer.create()) {
    for (const v2 of message.collections) {
      exports2.Collection.encode(v2, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetCollectionsResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collections.push(exports2.Collection.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collections: Array.isArray(object === null || object === void 0 ? void 0 : object.collections) ? object.collections.map((e2) => exports2.Collection.fromJSON(e2)) : [] };
  }, toJSON(message) {
    const obj = {};
    if (message.collections) {
      obj.collections = message.collections.map((e2) => e2 ? exports2.Collection.toJSON(e2) : void 0);
    } else {
      obj.collections = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseGetCollectionsResponse();
    message.collections = ((_a2 = object.collections) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports2.Collection.fromPartial(e2))) || [];
    return message;
  } };
  function createBaseCreateProjectRequest() {
    return { collectionId: "", metadata: void 0, rendering: void 0, encoding: void 0, composition: void 0, maxDuration: void 0, webrtc: void 0, location: void 0 };
  }
  exports2.CreateProjectRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(18).fork()).ldelim();
    }
    if (message.rendering !== void 0) {
      exports2.Rendering.encode(message.rendering, writer2.uint32(26).fork()).ldelim();
    }
    if (message.encoding !== void 0) {
      exports2.Encoding.encode(message.encoding, writer2.uint32(34).fork()).ldelim();
    }
    if (message.composition !== void 0) {
      exports2.Composition.encode(message.composition, writer2.uint32(42).fork()).ldelim();
    }
    if (message.maxDuration !== void 0) {
      writer2.uint32(48).uint32(message.maxDuration);
    }
    if (message.webrtc !== void 0) {
      exports2.WebRtc.encode(message.webrtc, writer2.uint32(58).fork()).ldelim();
    }
    if (message.location !== void 0) {
      exports2.LatLong.encode(message.location, writer2.uint32(74).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCreateProjectRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 3:
          message.rendering = exports2.Rendering.decode(reader2, reader2.uint32());
          break;
        case 4:
          message.encoding = exports2.Encoding.decode(reader2, reader2.uint32());
          break;
        case 5:
          message.composition = exports2.Composition.decode(reader2, reader2.uint32());
          break;
        case 6:
          message.maxDuration = reader2.uint32();
          break;
        case 7:
          message.webrtc = exports2.WebRtc.decode(reader2, reader2.uint32());
          break;
        case 9:
          message.location = exports2.LatLong.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0, rendering: isSet2(object.rendering) ? exports2.Rendering.fromJSON(object.rendering) : void 0, encoding: isSet2(object.encoding) ? exports2.Encoding.fromJSON(object.encoding) : void 0, composition: isSet2(object.composition) ? exports2.Composition.fromJSON(object.composition) : void 0, maxDuration: isSet2(object.maxDuration) ? Number(object.maxDuration) : void 0, webrtc: isSet2(object.webrtc) ? exports2.WebRtc.fromJSON(object.webrtc) : void 0, location: isSet2(object.location) ? exports2.LatLong.fromJSON(object.location) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.rendering !== void 0 && (obj.rendering = message.rendering ? exports2.Rendering.toJSON(message.rendering) : void 0);
    message.encoding !== void 0 && (obj.encoding = message.encoding ? exports2.Encoding.toJSON(message.encoding) : void 0);
    message.composition !== void 0 && (obj.composition = message.composition ? exports2.Composition.toJSON(message.composition) : void 0);
    message.maxDuration !== void 0 && (obj.maxDuration = Math.round(message.maxDuration));
    message.webrtc !== void 0 && (obj.webrtc = message.webrtc ? exports2.WebRtc.toJSON(message.webrtc) : void 0);
    message.location !== void 0 && (obj.location = message.location ? exports2.LatLong.toJSON(message.location) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseCreateProjectRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.metadata = (_b = object.metadata) !== null && _b !== void 0 ? _b : void 0;
    message.rendering = object.rendering !== void 0 && object.rendering !== null ? exports2.Rendering.fromPartial(object.rendering) : void 0;
    message.encoding = object.encoding !== void 0 && object.encoding !== null ? exports2.Encoding.fromPartial(object.encoding) : void 0;
    message.composition = object.composition !== void 0 && object.composition !== null ? exports2.Composition.fromPartial(object.composition) : void 0;
    message.maxDuration = (_c = object.maxDuration) !== null && _c !== void 0 ? _c : void 0;
    message.webrtc = object.webrtc !== void 0 && object.webrtc !== null ? exports2.WebRtc.fromPartial(object.webrtc) : void 0;
    message.location = object.location !== void 0 && object.location !== null ? exports2.LatLong.fromPartial(object.location) : void 0;
    return message;
  } };
  function createBaseCreateProjectResponse() {
    return { project: void 0 };
  }
  exports2.CreateProjectResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.project !== void 0) {
      exports2.Project.encode(message.project, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCreateProjectResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = exports2.Project.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { project: isSet2(object.project) ? exports2.Project.fromJSON(object.project) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.project !== void 0 && (obj.project = message.project ? exports2.Project.toJSON(message.project) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseCreateProjectResponse();
    message.project = object.project !== void 0 && object.project !== null ? exports2.Project.fromPartial(object.project) : void 0;
    return message;
  } };
  function createBaseUpdateProjectRequest() {
    return { collectionId: "", projectId: "", updateMask: void 0, metadata: void 0, rendering: void 0, encoding: void 0, composition: void 0, maxDuration: void 0, webrtc: void 0, location: void 0 };
  }
  exports2.UpdateProjectRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.updateMask !== void 0) {
      field_mask_1.FieldMask.encode(field_mask_1.FieldMask.wrap(message.updateMask), writer2.uint32(26).fork()).ldelim();
    }
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(34).fork()).ldelim();
    }
    if (message.rendering !== void 0) {
      exports2.Rendering.encode(message.rendering, writer2.uint32(42).fork()).ldelim();
    }
    if (message.encoding !== void 0) {
      exports2.Encoding.encode(message.encoding, writer2.uint32(50).fork()).ldelim();
    }
    if (message.composition !== void 0) {
      exports2.Composition.encode(message.composition, writer2.uint32(58).fork()).ldelim();
    }
    if (message.maxDuration !== void 0) {
      writer2.uint32(64).uint32(message.maxDuration);
    }
    if (message.webrtc !== void 0) {
      exports2.WebRtc.encode(message.webrtc, writer2.uint32(74).fork()).ldelim();
    }
    if (message.location !== void 0) {
      exports2.LatLong.encode(message.location, writer2.uint32(82).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUpdateProjectRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.updateMask = field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.decode(reader2, reader2.uint32()));
          break;
        case 4:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 5:
          message.rendering = exports2.Rendering.decode(reader2, reader2.uint32());
          break;
        case 6:
          message.encoding = exports2.Encoding.decode(reader2, reader2.uint32());
          break;
        case 7:
          message.composition = exports2.Composition.decode(reader2, reader2.uint32());
          break;
        case 8:
          message.maxDuration = reader2.uint32();
          break;
        case 9:
          message.webrtc = exports2.WebRtc.decode(reader2, reader2.uint32());
          break;
        case 10:
          message.location = exports2.LatLong.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", updateMask: isSet2(object.updateMask) ? field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.fromJSON(object.updateMask)) : void 0, metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0, rendering: isSet2(object.rendering) ? exports2.Rendering.fromJSON(object.rendering) : void 0, encoding: isSet2(object.encoding) ? exports2.Encoding.fromJSON(object.encoding) : void 0, composition: isSet2(object.composition) ? exports2.Composition.fromJSON(object.composition) : void 0, maxDuration: isSet2(object.maxDuration) ? Number(object.maxDuration) : void 0, webrtc: isSet2(object.webrtc) ? exports2.WebRtc.fromJSON(object.webrtc) : void 0, location: isSet2(object.location) ? exports2.LatLong.fromJSON(object.location) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.updateMask !== void 0 && (obj.updateMask = field_mask_1.FieldMask.toJSON(field_mask_1.FieldMask.wrap(message.updateMask)));
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.rendering !== void 0 && (obj.rendering = message.rendering ? exports2.Rendering.toJSON(message.rendering) : void 0);
    message.encoding !== void 0 && (obj.encoding = message.encoding ? exports2.Encoding.toJSON(message.encoding) : void 0);
    message.composition !== void 0 && (obj.composition = message.composition ? exports2.Composition.toJSON(message.composition) : void 0);
    message.maxDuration !== void 0 && (obj.maxDuration = Math.round(message.maxDuration));
    message.webrtc !== void 0 && (obj.webrtc = message.webrtc ? exports2.WebRtc.toJSON(message.webrtc) : void 0);
    message.location !== void 0 && (obj.location = message.location ? exports2.LatLong.toJSON(message.location) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e;
    const message = createBaseUpdateProjectRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.updateMask = (_c = object.updateMask) !== null && _c !== void 0 ? _c : void 0;
    message.metadata = (_d = object.metadata) !== null && _d !== void 0 ? _d : void 0;
    message.rendering = object.rendering !== void 0 && object.rendering !== null ? exports2.Rendering.fromPartial(object.rendering) : void 0;
    message.encoding = object.encoding !== void 0 && object.encoding !== null ? exports2.Encoding.fromPartial(object.encoding) : void 0;
    message.composition = object.composition !== void 0 && object.composition !== null ? exports2.Composition.fromPartial(object.composition) : void 0;
    message.maxDuration = (_e = object.maxDuration) !== null && _e !== void 0 ? _e : void 0;
    message.webrtc = object.webrtc !== void 0 && object.webrtc !== null ? exports2.WebRtc.fromPartial(object.webrtc) : void 0;
    message.location = object.location !== void 0 && object.location !== null ? exports2.LatLong.fromPartial(object.location) : void 0;
    return message;
  } };
  function createBaseUpdateProjectResponse() {
    return { project: void 0, broadcastUpdated: false };
  }
  exports2.UpdateProjectResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.project !== void 0) {
      exports2.Project.encode(message.project, writer2.uint32(10).fork()).ldelim();
    }
    if (message.broadcastUpdated === true) {
      writer2.uint32(16).bool(message.broadcastUpdated);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUpdateProjectResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = exports2.Project.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.broadcastUpdated = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { project: isSet2(object.project) ? exports2.Project.fromJSON(object.project) : void 0, broadcastUpdated: isSet2(object.broadcastUpdated) ? Boolean(object.broadcastUpdated) : false };
  }, toJSON(message) {
    const obj = {};
    message.project !== void 0 && (obj.project = message.project ? exports2.Project.toJSON(message.project) : void 0);
    message.broadcastUpdated !== void 0 && (obj.broadcastUpdated = message.broadcastUpdated);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseUpdateProjectResponse();
    message.project = object.project !== void 0 && object.project !== null ? exports2.Project.fromPartial(object.project) : void 0;
    message.broadcastUpdated = (_a2 = object.broadcastUpdated) !== null && _a2 !== void 0 ? _a2 : false;
    return message;
  } };
  function createBaseDeleteProjectRequest() {
    return { collectionId: "", projectId: "", force: void 0 };
  }
  exports2.DeleteProjectRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.force !== void 0) {
      writer2.uint32(24).bool(message.force);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDeleteProjectRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.force = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", force: isSet2(object.force) ? Boolean(object.force) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.force !== void 0 && (obj.force = message.force);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseDeleteProjectRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.force = (_c = object.force) !== null && _c !== void 0 ? _c : void 0;
    return message;
  } };
  function createBaseDeleteProjectResponse() {
    return { broadcastStopped: false, layoutsDeleted: 0 };
  }
  exports2.DeleteProjectResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.broadcastStopped === true) {
      writer2.uint32(8).bool(message.broadcastStopped);
    }
    if (message.layoutsDeleted !== 0) {
      writer2.uint32(16).uint32(message.layoutsDeleted);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDeleteProjectResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.broadcastStopped = reader2.bool();
          break;
        case 2:
          message.layoutsDeleted = reader2.uint32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { broadcastStopped: isSet2(object.broadcastStopped) ? Boolean(object.broadcastStopped) : false, layoutsDeleted: isSet2(object.layoutsDeleted) ? Number(object.layoutsDeleted) : 0 };
  }, toJSON(message) {
    const obj = {};
    message.broadcastStopped !== void 0 && (obj.broadcastStopped = message.broadcastStopped);
    message.layoutsDeleted !== void 0 && (obj.layoutsDeleted = Math.round(message.layoutsDeleted));
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseDeleteProjectResponse();
    message.broadcastStopped = (_a2 = object.broadcastStopped) !== null && _a2 !== void 0 ? _a2 : false;
    message.layoutsDeleted = (_b = object.layoutsDeleted) !== null && _b !== void 0 ? _b : 0;
    return message;
  } };
  function createBaseStartProjectBroadcastRequest() {
    return { collectionId: "", projectId: "", webrtcStart: void 0 };
  }
  exports2.StartProjectBroadcastRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.webrtcStart !== void 0) {
      writer2.uint32(24).bool(message.webrtcStart);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStartProjectBroadcastRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.webrtcStart = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", webrtcStart: isSet2(object.webrtcStart) ? Boolean(object.webrtcStart) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.webrtcStart !== void 0 && (obj.webrtcStart = message.webrtcStart);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseStartProjectBroadcastRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.webrtcStart = (_c = object.webrtcStart) !== null && _c !== void 0 ? _c : void 0;
    return message;
  } };
  function createBaseStartProjectBroadcastResponse() {
    return { broadcastId: "" };
  }
  exports2.StartProjectBroadcastResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.broadcastId !== "") {
      writer2.uint32(10).string(message.broadcastId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStartProjectBroadcastResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.broadcastId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { broadcastId: isSet2(object.broadcastId) ? String(object.broadcastId) : "" };
  }, toJSON(message) {
    const obj = {};
    message.broadcastId !== void 0 && (obj.broadcastId = message.broadcastId);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseStartProjectBroadcastResponse();
    message.broadcastId = (_a2 = object.broadcastId) !== null && _a2 !== void 0 ? _a2 : "";
    return message;
  } };
  function createBaseStopProjectBroadcastRequest() {
    return { collectionId: "", projectId: "", webrtcStop: void 0 };
  }
  exports2.StopProjectBroadcastRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.webrtcStop !== void 0) {
      writer2.uint32(24).bool(message.webrtcStop);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStopProjectBroadcastRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.webrtcStop = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", webrtcStop: isSet2(object.webrtcStop) ? Boolean(object.webrtcStop) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.webrtcStop !== void 0 && (obj.webrtcStop = message.webrtcStop);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseStopProjectBroadcastRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.webrtcStop = (_c = object.webrtcStop) !== null && _c !== void 0 ? _c : void 0;
    return message;
  } };
  function createBaseStopProjectBroadcastResponse() {
    return {};
  }
  exports2.StopProjectBroadcastResponse = { encode(_, writer2 = _m02.Writer.create()) {
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStopProjectBroadcastResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(_) {
    return {};
  }, toJSON(_) {
    const obj = {};
    return obj;
  }, fromPartial(_) {
    const message = createBaseStopProjectBroadcastResponse();
    return message;
  } };
  function createBaseGetProjectRequest() {
    return { collectionId: "", projectId: "", status: void 0 };
  }
  exports2.GetProjectRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.status !== void 0) {
      writer2.uint32(24).bool(message.status);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetProjectRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.status = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", status: isSet2(object.status) ? Boolean(object.status) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.status !== void 0 && (obj.status = message.status);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseGetProjectRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.status = (_c = object.status) !== null && _c !== void 0 ? _c : void 0;
    return message;
  } };
  function createBaseGetProjectResponse() {
    return { project: void 0, status: void 0 };
  }
  exports2.GetProjectResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.project !== void 0) {
      exports2.Project.encode(message.project, writer2.uint32(10).fork()).ldelim();
    }
    if (message.status !== void 0) {
      exports2.ProjectBroadcastStatus.encode(message.status, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetProjectResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = exports2.Project.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.status = exports2.ProjectBroadcastStatus.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { project: isSet2(object.project) ? exports2.Project.fromJSON(object.project) : void 0, status: isSet2(object.status) ? exports2.ProjectBroadcastStatus.fromJSON(object.status) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.project !== void 0 && (obj.project = message.project ? exports2.Project.toJSON(message.project) : void 0);
    message.status !== void 0 && (obj.status = message.status ? exports2.ProjectBroadcastStatus.toJSON(message.status) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseGetProjectResponse();
    message.project = object.project !== void 0 && object.project !== null ? exports2.Project.fromPartial(object.project) : void 0;
    message.status = object.status !== void 0 && object.status !== null ? exports2.ProjectBroadcastStatus.fromPartial(object.status) : void 0;
    return message;
  } };
  function createBaseGetProjectBroadcastSnapshotRequest() {
    return { collectionId: "", projectId: "", format: void 0 };
  }
  exports2.GetProjectBroadcastSnapshotRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.format !== void 0) {
      writer2.uint32(24).int32(imageFormatToNumber(message.format));
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetProjectBroadcastSnapshotRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.format = imageFormatFromJSON(reader2.int32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", format: isSet2(object.format) ? imageFormatFromJSON(object.format) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.format !== void 0 && (obj.format = message.format !== void 0 ? imageFormatToJSON(message.format) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseGetProjectBroadcastSnapshotRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.format = (_c = object.format) !== null && _c !== void 0 ? _c : void 0;
    return message;
  } };
  function createBaseGetProjectBroadcastSnapshotResponse() {
    return { format: ImageFormat.IMAGE_FORMAT_UNSPECIFIED, image: new Uint8Array() };
  }
  exports2.GetProjectBroadcastSnapshotResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.format !== ImageFormat.IMAGE_FORMAT_UNSPECIFIED) {
      writer2.uint32(8).int32(imageFormatToNumber(message.format));
    }
    if (message.image.length !== 0) {
      writer2.uint32(18).bytes(message.image);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetProjectBroadcastSnapshotResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.format = imageFormatFromJSON(reader2.int32());
          break;
        case 2:
          message.image = reader2.bytes();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { format: isSet2(object.format) ? imageFormatFromJSON(object.format) : ImageFormat.IMAGE_FORMAT_UNSPECIFIED, image: isSet2(object.image) ? bytesFromBase64(object.image) : new Uint8Array() };
  }, toJSON(message) {
    const obj = {};
    message.format !== void 0 && (obj.format = imageFormatToJSON(message.format));
    message.image !== void 0 && (obj.image = base64FromBytes(message.image !== void 0 ? message.image : new Uint8Array()));
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseGetProjectBroadcastSnapshotResponse();
    message.format = (_a2 = object.format) !== null && _a2 !== void 0 ? _a2 : ImageFormat.IMAGE_FORMAT_UNSPECIFIED;
    message.image = (_b = object.image) !== null && _b !== void 0 ? _b : new Uint8Array();
    return message;
  } };
  function createBaseGetProjectBroadcastStatusRequest() {
    return { collectionId: "", projectId: "" };
  }
  exports2.GetProjectBroadcastStatusRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetProjectBroadcastStatusRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "" };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseGetProjectBroadcastStatusRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    return message;
  } };
  function createBaseGetProjectBroadcastStatusResponse() {
    return { status: void 0 };
  }
  exports2.GetProjectBroadcastStatusResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.status !== void 0) {
      exports2.ProjectBroadcastStatus.encode(message.status, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetProjectBroadcastStatusResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.status = exports2.ProjectBroadcastStatus.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { status: isSet2(object.status) ? exports2.ProjectBroadcastStatus.fromJSON(object.status) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.status !== void 0 && (obj.status = message.status ? exports2.ProjectBroadcastStatus.toJSON(message.status) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseGetProjectBroadcastStatusResponse();
    message.status = object.status !== void 0 && object.status !== null ? exports2.ProjectBroadcastStatus.fromPartial(object.status) : void 0;
    return message;
  } };
  function createBaseStartProjectWebRtcRequest() {
    return { collectionId: "", projectId: "" };
  }
  exports2.StartProjectWebRtcRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStartProjectWebRtcRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "" };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseStartProjectWebRtcRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    return message;
  } };
  function createBaseStartProjectWebRtcResponse() {
    return {};
  }
  exports2.StartProjectWebRtcResponse = { encode(_, writer2 = _m02.Writer.create()) {
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStartProjectWebRtcResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(_) {
    return {};
  }, toJSON(_) {
    const obj = {};
    return obj;
  }, fromPartial(_) {
    const message = createBaseStartProjectWebRtcResponse();
    return message;
  } };
  function createBaseStopProjectWebRtcRequest() {
    return { collectionId: "", projectId: "" };
  }
  exports2.StopProjectWebRtcRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStopProjectWebRtcRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "" };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseStopProjectWebRtcRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    return message;
  } };
  function createBaseStopProjectWebRtcResponse() {
    return {};
  }
  exports2.StopProjectWebRtcResponse = { encode(_, writer2 = _m02.Writer.create()) {
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStopProjectWebRtcResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(_) {
    return {};
  }, toJSON(_) {
    const obj = {};
    return obj;
  }, fromPartial(_) {
    const message = createBaseStopProjectWebRtcResponse();
    return message;
  } };
  function createBaseCreateDestinationRequest() {
    return { collectionId: "", projectId: "", metadata: void 0, address: void 0, enabled: void 0, timeout: void 0 };
  }
  exports2.CreateDestinationRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(26).fork()).ldelim();
    }
    if (message.address !== void 0) {
      exports2.DestinationAddress.encode(message.address, writer2.uint32(42).fork()).ldelim();
    }
    if (message.enabled !== void 0) {
      writer2.uint32(48).bool(message.enabled);
    }
    if (message.timeout !== void 0) {
      writer2.uint32(56).uint32(message.timeout);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCreateDestinationRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 5:
          message.address = exports2.DestinationAddress.decode(reader2, reader2.uint32());
          break;
        case 6:
          message.enabled = reader2.bool();
          break;
        case 7:
          message.timeout = reader2.uint32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0, address: isSet2(object.address) ? exports2.DestinationAddress.fromJSON(object.address) : void 0, enabled: isSet2(object.enabled) ? Boolean(object.enabled) : void 0, timeout: isSet2(object.timeout) ? Number(object.timeout) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.address !== void 0 && (obj.address = message.address ? exports2.DestinationAddress.toJSON(message.address) : void 0);
    message.enabled !== void 0 && (obj.enabled = message.enabled);
    message.timeout !== void 0 && (obj.timeout = Math.round(message.timeout));
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e;
    const message = createBaseCreateDestinationRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.metadata = (_c = object.metadata) !== null && _c !== void 0 ? _c : void 0;
    message.address = object.address !== void 0 && object.address !== null ? exports2.DestinationAddress.fromPartial(object.address) : void 0;
    message.enabled = (_d = object.enabled) !== null && _d !== void 0 ? _d : void 0;
    message.timeout = (_e = object.timeout) !== null && _e !== void 0 ? _e : void 0;
    return message;
  } };
  function createBaseCreateDestinationResponse() {
    return { destination: void 0 };
  }
  exports2.CreateDestinationResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.destination !== void 0) {
      exports2.Destination.encode(message.destination, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCreateDestinationResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.destination = exports2.Destination.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { destination: isSet2(object.destination) ? exports2.Destination.fromJSON(object.destination) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.destination !== void 0 && (obj.destination = message.destination ? exports2.Destination.toJSON(message.destination) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseCreateDestinationResponse();
    message.destination = object.destination !== void 0 && object.destination !== null ? exports2.Destination.fromPartial(object.destination) : void 0;
    return message;
  } };
  function createBaseGetDestinationRequest() {
    return { collectionId: "", projectId: "", destinationId: "" };
  }
  exports2.GetDestinationRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.destinationId !== "") {
      writer2.uint32(26).string(message.destinationId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetDestinationRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.destinationId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", destinationId: isSet2(object.destinationId) ? String(object.destinationId) : "" };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.destinationId !== void 0 && (obj.destinationId = message.destinationId);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseGetDestinationRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.destinationId = (_c = object.destinationId) !== null && _c !== void 0 ? _c : "";
    return message;
  } };
  function createBaseGetDestinationResponse() {
    return { destination: void 0 };
  }
  exports2.GetDestinationResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.destination !== void 0) {
      exports2.Destination.encode(message.destination, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetDestinationResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.destination = exports2.Destination.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { destination: isSet2(object.destination) ? exports2.Destination.fromJSON(object.destination) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.destination !== void 0 && (obj.destination = message.destination ? exports2.Destination.toJSON(message.destination) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseGetDestinationResponse();
    message.destination = object.destination !== void 0 && object.destination !== null ? exports2.Destination.fromPartial(object.destination) : void 0;
    return message;
  } };
  function createBaseDeleteDestinationRequest() {
    return { collectionId: "", projectId: "", destinationId: "", force: void 0 };
  }
  exports2.DeleteDestinationRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.destinationId !== "") {
      writer2.uint32(26).string(message.destinationId);
    }
    if (message.force !== void 0) {
      writer2.uint32(32).bool(message.force);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDeleteDestinationRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.destinationId = reader2.string();
          break;
        case 4:
          message.force = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", destinationId: isSet2(object.destinationId) ? String(object.destinationId) : "", force: isSet2(object.force) ? Boolean(object.force) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.destinationId !== void 0 && (obj.destinationId = message.destinationId);
    message.force !== void 0 && (obj.force = message.force);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseDeleteDestinationRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.destinationId = (_c = object.destinationId) !== null && _c !== void 0 ? _c : "";
    message.force = (_d = object.force) !== null && _d !== void 0 ? _d : void 0;
    return message;
  } };
  function createBaseDeleteDestinationResponse() {
    return { broadcastUpdated: false };
  }
  exports2.DeleteDestinationResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.broadcastUpdated === true) {
      writer2.uint32(8).bool(message.broadcastUpdated);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDeleteDestinationResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.broadcastUpdated = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { broadcastUpdated: isSet2(object.broadcastUpdated) ? Boolean(object.broadcastUpdated) : false };
  }, toJSON(message) {
    const obj = {};
    message.broadcastUpdated !== void 0 && (obj.broadcastUpdated = message.broadcastUpdated);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseDeleteDestinationResponse();
    message.broadcastUpdated = (_a2 = object.broadcastUpdated) !== null && _a2 !== void 0 ? _a2 : false;
    return message;
  } };
  function createBaseUpdateDestinationRequest() {
    return { collectionId: "", projectId: "", destinationId: "", updateMask: void 0, metadata: void 0, address: void 0, enabled: void 0, timeout: void 0 };
  }
  exports2.UpdateDestinationRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.destinationId !== "") {
      writer2.uint32(26).string(message.destinationId);
    }
    if (message.updateMask !== void 0) {
      field_mask_1.FieldMask.encode(field_mask_1.FieldMask.wrap(message.updateMask), writer2.uint32(34).fork()).ldelim();
    }
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(42).fork()).ldelim();
    }
    if (message.address !== void 0) {
      exports2.DestinationAddress.encode(message.address, writer2.uint32(50).fork()).ldelim();
    }
    if (message.enabled !== void 0) {
      writer2.uint32(56).bool(message.enabled);
    }
    if (message.timeout !== void 0) {
      writer2.uint32(64).uint32(message.timeout);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUpdateDestinationRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.destinationId = reader2.string();
          break;
        case 4:
          message.updateMask = field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.decode(reader2, reader2.uint32()));
          break;
        case 5:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 6:
          message.address = exports2.DestinationAddress.decode(reader2, reader2.uint32());
          break;
        case 7:
          message.enabled = reader2.bool();
          break;
        case 8:
          message.timeout = reader2.uint32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", destinationId: isSet2(object.destinationId) ? String(object.destinationId) : "", updateMask: isSet2(object.updateMask) ? field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.fromJSON(object.updateMask)) : void 0, metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0, address: isSet2(object.address) ? exports2.DestinationAddress.fromJSON(object.address) : void 0, enabled: isSet2(object.enabled) ? Boolean(object.enabled) : void 0, timeout: isSet2(object.timeout) ? Number(object.timeout) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.destinationId !== void 0 && (obj.destinationId = message.destinationId);
    message.updateMask !== void 0 && (obj.updateMask = field_mask_1.FieldMask.toJSON(field_mask_1.FieldMask.wrap(message.updateMask)));
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.address !== void 0 && (obj.address = message.address ? exports2.DestinationAddress.toJSON(message.address) : void 0);
    message.enabled !== void 0 && (obj.enabled = message.enabled);
    message.timeout !== void 0 && (obj.timeout = Math.round(message.timeout));
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g;
    const message = createBaseUpdateDestinationRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.destinationId = (_c = object.destinationId) !== null && _c !== void 0 ? _c : "";
    message.updateMask = (_d = object.updateMask) !== null && _d !== void 0 ? _d : void 0;
    message.metadata = (_e = object.metadata) !== null && _e !== void 0 ? _e : void 0;
    message.address = object.address !== void 0 && object.address !== null ? exports2.DestinationAddress.fromPartial(object.address) : void 0;
    message.enabled = (_f = object.enabled) !== null && _f !== void 0 ? _f : void 0;
    message.timeout = (_g = object.timeout) !== null && _g !== void 0 ? _g : void 0;
    return message;
  } };
  function createBaseUpdateDestinationResponse() {
    return { destination: void 0, broadcastUpdated: false };
  }
  exports2.UpdateDestinationResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.destination !== void 0) {
      exports2.Destination.encode(message.destination, writer2.uint32(10).fork()).ldelim();
    }
    if (message.broadcastUpdated === true) {
      writer2.uint32(16).bool(message.broadcastUpdated);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUpdateDestinationResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.destination = exports2.Destination.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.broadcastUpdated = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { destination: isSet2(object.destination) ? exports2.Destination.fromJSON(object.destination) : void 0, broadcastUpdated: isSet2(object.broadcastUpdated) ? Boolean(object.broadcastUpdated) : false };
  }, toJSON(message) {
    const obj = {};
    message.destination !== void 0 && (obj.destination = message.destination ? exports2.Destination.toJSON(message.destination) : void 0);
    message.broadcastUpdated !== void 0 && (obj.broadcastUpdated = message.broadcastUpdated);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseUpdateDestinationResponse();
    message.destination = object.destination !== void 0 && object.destination !== null ? exports2.Destination.fromPartial(object.destination) : void 0;
    message.broadcastUpdated = (_a2 = object.broadcastUpdated) !== null && _a2 !== void 0 ? _a2 : false;
    return message;
  } };
  function createBaseCreateSourceRequest() {
    return { collectionId: "", metadata: void 0, address: void 0, preview: void 0 };
  }
  exports2.CreateSourceRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(18).fork()).ldelim();
    }
    if (message.address !== void 0) {
      exports2.SourceAddress.encode(message.address, writer2.uint32(26).fork()).ldelim();
    }
    if (message.preview !== void 0) {
      exports2.PreviewAddress.encode(message.preview, writer2.uint32(34).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCreateSourceRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 3:
          message.address = exports2.SourceAddress.decode(reader2, reader2.uint32());
          break;
        case 4:
          message.preview = exports2.PreviewAddress.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0, address: isSet2(object.address) ? exports2.SourceAddress.fromJSON(object.address) : void 0, preview: isSet2(object.preview) ? exports2.PreviewAddress.fromJSON(object.preview) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.address !== void 0 && (obj.address = message.address ? exports2.SourceAddress.toJSON(message.address) : void 0);
    message.preview !== void 0 && (obj.preview = message.preview ? exports2.PreviewAddress.toJSON(message.preview) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseCreateSourceRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.metadata = (_b = object.metadata) !== null && _b !== void 0 ? _b : void 0;
    message.address = object.address !== void 0 && object.address !== null ? exports2.SourceAddress.fromPartial(object.address) : void 0;
    message.preview = object.preview !== void 0 && object.preview !== null ? exports2.PreviewAddress.fromPartial(object.preview) : void 0;
    return message;
  } };
  function createBaseCreateSourceResponse() {
    return { source: void 0 };
  }
  exports2.CreateSourceResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.source !== void 0) {
      exports2.Source.encode(message.source, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCreateSourceResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.source = exports2.Source.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { source: isSet2(object.source) ? exports2.Source.fromJSON(object.source) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.source !== void 0 && (obj.source = message.source ? exports2.Source.toJSON(message.source) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseCreateSourceResponse();
    message.source = object.source !== void 0 && object.source !== null ? exports2.Source.fromPartial(object.source) : void 0;
    return message;
  } };
  function createBaseDeleteSourceRequest() {
    return { collectionId: "", sourceId: "", force: void 0 };
  }
  exports2.DeleteSourceRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.sourceId !== "") {
      writer2.uint32(18).string(message.sourceId);
    }
    if (message.force !== void 0) {
      writer2.uint32(24).bool(message.force);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDeleteSourceRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.sourceId = reader2.string();
          break;
        case 3:
          message.force = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "", force: isSet2(object.force) ? Boolean(object.force) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
    message.force !== void 0 && (obj.force = message.force);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseDeleteSourceRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
    message.force = (_c = object.force) !== null && _c !== void 0 ? _c : void 0;
    return message;
  } };
  function createBaseDeleteSourceResponse() {
    return { projectIdsUpdated: [] };
  }
  exports2.DeleteSourceResponse = { encode(message, writer2 = _m02.Writer.create()) {
    for (const v2 of message.projectIdsUpdated) {
      writer2.uint32(26).string(v2);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDeleteSourceResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 3:
          message.projectIdsUpdated.push(reader2.string());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { projectIdsUpdated: Array.isArray(object === null || object === void 0 ? void 0 : object.projectIdsUpdated) ? object.projectIdsUpdated.map((e2) => String(e2)) : [] };
  }, toJSON(message) {
    const obj = {};
    if (message.projectIdsUpdated) {
      obj.projectIdsUpdated = message.projectIdsUpdated.map((e2) => e2);
    } else {
      obj.projectIdsUpdated = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseDeleteSourceResponse();
    message.projectIdsUpdated = ((_a2 = object.projectIdsUpdated) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
    return message;
  } };
  function createBaseAddSourceToProjectRequest() {
    return { collectionId: "", projectId: "", sourceId: "", trigger: void 0 };
  }
  exports2.AddSourceToProjectRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.sourceId !== "") {
      writer2.uint32(26).string(message.sourceId);
    }
    if (message.trigger !== void 0) {
      exports2.SourceTrigger.encode(message.trigger, writer2.uint32(34).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseAddSourceToProjectRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.sourceId = reader2.string();
          break;
        case 4:
          message.trigger = exports2.SourceTrigger.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "", trigger: isSet2(object.trigger) ? exports2.SourceTrigger.fromJSON(object.trigger) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
    message.trigger !== void 0 && (obj.trigger = message.trigger ? exports2.SourceTrigger.toJSON(message.trigger) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseAddSourceToProjectRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.sourceId = (_c = object.sourceId) !== null && _c !== void 0 ? _c : "";
    message.trigger = object.trigger !== void 0 && object.trigger !== null ? exports2.SourceTrigger.fromPartial(object.trigger) : void 0;
    return message;
  } };
  function createBaseAddSourceToProjectResponse() {
    return { project: void 0, broadcastUpdated: false };
  }
  exports2.AddSourceToProjectResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.project !== void 0) {
      exports2.Project.encode(message.project, writer2.uint32(10).fork()).ldelim();
    }
    if (message.broadcastUpdated === true) {
      writer2.uint32(16).bool(message.broadcastUpdated);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseAddSourceToProjectResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = exports2.Project.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.broadcastUpdated = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { project: isSet2(object.project) ? exports2.Project.fromJSON(object.project) : void 0, broadcastUpdated: isSet2(object.broadcastUpdated) ? Boolean(object.broadcastUpdated) : false };
  }, toJSON(message) {
    const obj = {};
    message.project !== void 0 && (obj.project = message.project ? exports2.Project.toJSON(message.project) : void 0);
    message.broadcastUpdated !== void 0 && (obj.broadcastUpdated = message.broadcastUpdated);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseAddSourceToProjectResponse();
    message.project = object.project !== void 0 && object.project !== null ? exports2.Project.fromPartial(object.project) : void 0;
    message.broadcastUpdated = (_a2 = object.broadcastUpdated) !== null && _a2 !== void 0 ? _a2 : false;
    return message;
  } };
  function createBaseUpdateSourceInProjectRequest() {
    return { collectionId: "", projectId: "", sourceId: "", updateMask: void 0, trigger: void 0 };
  }
  exports2.UpdateSourceInProjectRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.sourceId !== "") {
      writer2.uint32(26).string(message.sourceId);
    }
    if (message.updateMask !== void 0) {
      field_mask_1.FieldMask.encode(field_mask_1.FieldMask.wrap(message.updateMask), writer2.uint32(34).fork()).ldelim();
    }
    if (message.trigger !== void 0) {
      exports2.SourceTrigger.encode(message.trigger, writer2.uint32(42).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUpdateSourceInProjectRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.sourceId = reader2.string();
          break;
        case 4:
          message.updateMask = field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.decode(reader2, reader2.uint32()));
          break;
        case 5:
          message.trigger = exports2.SourceTrigger.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "", updateMask: isSet2(object.updateMask) ? field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.fromJSON(object.updateMask)) : void 0, trigger: isSet2(object.trigger) ? exports2.SourceTrigger.fromJSON(object.trigger) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
    message.updateMask !== void 0 && (obj.updateMask = field_mask_1.FieldMask.toJSON(field_mask_1.FieldMask.wrap(message.updateMask)));
    message.trigger !== void 0 && (obj.trigger = message.trigger ? exports2.SourceTrigger.toJSON(message.trigger) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseUpdateSourceInProjectRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.sourceId = (_c = object.sourceId) !== null && _c !== void 0 ? _c : "";
    message.updateMask = (_d = object.updateMask) !== null && _d !== void 0 ? _d : void 0;
    message.trigger = object.trigger !== void 0 && object.trigger !== null ? exports2.SourceTrigger.fromPartial(object.trigger) : void 0;
    return message;
  } };
  function createBaseUpdateSourceInProjectResponse() {
    return { project: void 0 };
  }
  exports2.UpdateSourceInProjectResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.project !== void 0) {
      exports2.Project.encode(message.project, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUpdateSourceInProjectResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = exports2.Project.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { project: isSet2(object.project) ? exports2.Project.fromJSON(object.project) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.project !== void 0 && (obj.project = message.project ? exports2.Project.toJSON(message.project) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseUpdateSourceInProjectResponse();
    message.project = object.project !== void 0 && object.project !== null ? exports2.Project.fromPartial(object.project) : void 0;
    return message;
  } };
  function createBaseGetSourceRequest() {
    return { collectionId: "", sourceId: "" };
  }
  exports2.GetSourceRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.sourceId !== "") {
      writer2.uint32(26).string(message.sourceId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetSourceRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 3:
          message.sourceId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "" };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseGetSourceRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
    return message;
  } };
  function createBaseGetSourceResponse() {
    return { source: void 0 };
  }
  exports2.GetSourceResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.source !== void 0) {
      exports2.Source.encode(message.source, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetSourceResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.source = exports2.Source.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { source: isSet2(object.source) ? exports2.Source.fromJSON(object.source) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.source !== void 0 && (obj.source = message.source ? exports2.Source.toJSON(message.source) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseGetSourceResponse();
    message.source = object.source !== void 0 && object.source !== null ? exports2.Source.fromPartial(object.source) : void 0;
    return message;
  } };
  function createBaseGetSourcesRequest() {
    return { collectionId: "" };
  }
  exports2.GetSourcesRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetSourcesRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "" };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseGetSourcesRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    return message;
  } };
  function createBaseGetSourcesResponse() {
    return { sources: [] };
  }
  exports2.GetSourcesResponse = { encode(message, writer2 = _m02.Writer.create()) {
    for (const v2 of message.sources) {
      exports2.Source.encode(v2, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetSourcesResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sources.push(exports2.Source.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { sources: Array.isArray(object === null || object === void 0 ? void 0 : object.sources) ? object.sources.map((e2) => exports2.Source.fromJSON(e2)) : [] };
  }, toJSON(message) {
    const obj = {};
    if (message.sources) {
      obj.sources = message.sources.map((e2) => e2 ? exports2.Source.toJSON(e2) : void 0);
    } else {
      obj.sources = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseGetSourcesResponse();
    message.sources = ((_a2 = object.sources) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports2.Source.fromPartial(e2))) || [];
    return message;
  } };
  function createBaseUpdateSourceRequest() {
    return { collectionId: "", sourceId: "", updateMask: void 0, metadata: void 0, address: void 0, preview: void 0 };
  }
  exports2.UpdateSourceRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.sourceId !== "") {
      writer2.uint32(26).string(message.sourceId);
    }
    if (message.updateMask !== void 0) {
      field_mask_1.FieldMask.encode(field_mask_1.FieldMask.wrap(message.updateMask), writer2.uint32(34).fork()).ldelim();
    }
    if (message.metadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(42).fork()).ldelim();
    }
    if (message.address !== void 0) {
      exports2.SourceAddress.encode(message.address, writer2.uint32(50).fork()).ldelim();
    }
    if (message.preview !== void 0) {
      exports2.PreviewAddress.encode(message.preview, writer2.uint32(58).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUpdateSourceRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 3:
          message.sourceId = reader2.string();
          break;
        case 4:
          message.updateMask = field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.decode(reader2, reader2.uint32()));
          break;
        case 5:
          message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 6:
          message.address = exports2.SourceAddress.decode(reader2, reader2.uint32());
          break;
        case 7:
          message.preview = exports2.PreviewAddress.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "", updateMask: isSet2(object.updateMask) ? field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.fromJSON(object.updateMask)) : void 0, metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0, address: isSet2(object.address) ? exports2.SourceAddress.fromJSON(object.address) : void 0, preview: isSet2(object.preview) ? exports2.PreviewAddress.fromJSON(object.preview) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
    message.updateMask !== void 0 && (obj.updateMask = field_mask_1.FieldMask.toJSON(field_mask_1.FieldMask.wrap(message.updateMask)));
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.address !== void 0 && (obj.address = message.address ? exports2.SourceAddress.toJSON(message.address) : void 0);
    message.preview !== void 0 && (obj.preview = message.preview ? exports2.PreviewAddress.toJSON(message.preview) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseUpdateSourceRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
    message.updateMask = (_c = object.updateMask) !== null && _c !== void 0 ? _c : void 0;
    message.metadata = (_d = object.metadata) !== null && _d !== void 0 ? _d : void 0;
    message.address = object.address !== void 0 && object.address !== null ? exports2.SourceAddress.fromPartial(object.address) : void 0;
    message.preview = object.preview !== void 0 && object.preview !== null ? exports2.PreviewAddress.fromPartial(object.preview) : void 0;
    return message;
  } };
  function createBaseUpdateSourceResponse() {
    return { source: void 0, broadcastUpdated: false };
  }
  exports2.UpdateSourceResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.source !== void 0) {
      exports2.Source.encode(message.source, writer2.uint32(10).fork()).ldelim();
    }
    if (message.broadcastUpdated === true) {
      writer2.uint32(16).bool(message.broadcastUpdated);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUpdateSourceResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.source = exports2.Source.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.broadcastUpdated = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { source: isSet2(object.source) ? exports2.Source.fromJSON(object.source) : void 0, broadcastUpdated: isSet2(object.broadcastUpdated) ? Boolean(object.broadcastUpdated) : false };
  }, toJSON(message) {
    const obj = {};
    message.source !== void 0 && (obj.source = message.source ? exports2.Source.toJSON(message.source) : void 0);
    message.broadcastUpdated !== void 0 && (obj.broadcastUpdated = message.broadcastUpdated);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseUpdateSourceResponse();
    message.source = object.source !== void 0 && object.source !== null ? exports2.Source.fromPartial(object.source) : void 0;
    message.broadcastUpdated = (_a2 = object.broadcastUpdated) !== null && _a2 !== void 0 ? _a2 : false;
    return message;
  } };
  function createBaseRemoveSourceFromProjectRequest() {
    return { collectionId: "", projectId: "", sourceId: "", force: void 0 };
  }
  exports2.RemoveSourceFromProjectRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.sourceId !== "") {
      writer2.uint32(26).string(message.sourceId);
    }
    if (message.force !== void 0) {
      writer2.uint32(32).bool(message.force);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseRemoveSourceFromProjectRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.sourceId = reader2.string();
          break;
        case 4:
          message.force = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "", force: isSet2(object.force) ? Boolean(object.force) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
    message.force !== void 0 && (obj.force = message.force);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseRemoveSourceFromProjectRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.sourceId = (_c = object.sourceId) !== null && _c !== void 0 ? _c : "";
    message.force = (_d = object.force) !== null && _d !== void 0 ? _d : void 0;
    return message;
  } };
  function createBaseRemoveSourceFromProjectResponse() {
    return { project: void 0, broadcastUpdated: false };
  }
  exports2.RemoveSourceFromProjectResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.project !== void 0) {
      exports2.Project.encode(message.project, writer2.uint32(10).fork()).ldelim();
    }
    if (message.broadcastUpdated === true) {
      writer2.uint32(16).bool(message.broadcastUpdated);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseRemoveSourceFromProjectResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = exports2.Project.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.broadcastUpdated = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { project: isSet2(object.project) ? exports2.Project.fromJSON(object.project) : void 0, broadcastUpdated: isSet2(object.broadcastUpdated) ? Boolean(object.broadcastUpdated) : false };
  }, toJSON(message) {
    const obj = {};
    message.project !== void 0 && (obj.project = message.project ? exports2.Project.toJSON(message.project) : void 0);
    message.broadcastUpdated !== void 0 && (obj.broadcastUpdated = message.broadcastUpdated);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseRemoveSourceFromProjectResponse();
    message.project = object.project !== void 0 && object.project !== null ? exports2.Project.fromPartial(object.project) : void 0;
    message.broadcastUpdated = (_a2 = object.broadcastUpdated) !== null && _a2 !== void 0 ? _a2 : false;
    return message;
  } };
  function createBaseCreateAccessTokenRequest() {
    return { serviceUserId: "", displayName: void 0, role: void 0, maxDuration: void 0 };
  }
  exports2.CreateAccessTokenRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.serviceUserId !== "") {
      writer2.uint32(10).string(message.serviceUserId);
    }
    if (message.displayName !== void 0) {
      writer2.uint32(34).string(message.displayName);
    }
    if (message.role !== void 0) {
      writer2.uint32(16).int32(roleToNumber(message.role));
    }
    if (message.maxDuration !== void 0) {
      writer2.uint32(24).uint32(message.maxDuration);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCreateAccessTokenRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.serviceUserId = reader2.string();
          break;
        case 4:
          message.displayName = reader2.string();
          break;
        case 2:
          message.role = roleFromJSON(reader2.int32());
          break;
        case 3:
          message.maxDuration = reader2.uint32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { serviceUserId: isSet2(object.serviceUserId) ? String(object.serviceUserId) : "", displayName: isSet2(object.displayName) ? String(object.displayName) : void 0, role: isSet2(object.role) ? roleFromJSON(object.role) : void 0, maxDuration: isSet2(object.maxDuration) ? Number(object.maxDuration) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.serviceUserId !== void 0 && (obj.serviceUserId = message.serviceUserId);
    message.displayName !== void 0 && (obj.displayName = message.displayName);
    message.role !== void 0 && (obj.role = message.role !== void 0 ? roleToJSON(message.role) : void 0);
    message.maxDuration !== void 0 && (obj.maxDuration = Math.round(message.maxDuration));
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseCreateAccessTokenRequest();
    message.serviceUserId = (_a2 = object.serviceUserId) !== null && _a2 !== void 0 ? _a2 : "";
    message.displayName = (_b = object.displayName) !== null && _b !== void 0 ? _b : void 0;
    message.role = (_c = object.role) !== null && _c !== void 0 ? _c : void 0;
    message.maxDuration = (_d = object.maxDuration) !== null && _d !== void 0 ? _d : void 0;
    return message;
  } };
  function createBaseCreateAccessTokenResponse() {
    return { accessToken: "" };
  }
  exports2.CreateAccessTokenResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.accessToken !== "") {
      writer2.uint32(10).string(message.accessToken);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCreateAccessTokenResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accessToken = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { accessToken: isSet2(object.accessToken) ? String(object.accessToken) : "" };
  }, toJSON(message) {
    const obj = {};
    message.accessToken !== void 0 && (obj.accessToken = message.accessToken);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseCreateAccessTokenResponse();
    message.accessToken = (_a2 = object.accessToken) !== null && _a2 !== void 0 ? _a2 : "";
    return message;
  } };
  function createBaseGuestAccessTokenDirect() {
    return { displayName: "", serviceUserId: void 0 };
  }
  exports2.GuestAccessTokenDirect = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.displayName !== "") {
      writer2.uint32(10).string(message.displayName);
    }
    if (message.serviceUserId !== void 0) {
      writer2.uint32(18).string(message.serviceUserId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGuestAccessTokenDirect();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.displayName = reader2.string();
          break;
        case 2:
          message.serviceUserId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { displayName: isSet2(object.displayName) ? String(object.displayName) : "", serviceUserId: isSet2(object.serviceUserId) ? String(object.serviceUserId) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.displayName !== void 0 && (obj.displayName = message.displayName);
    message.serviceUserId !== void 0 && (obj.serviceUserId = message.serviceUserId);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseGuestAccessTokenDirect();
    message.displayName = (_a2 = object.displayName) !== null && _a2 !== void 0 ? _a2 : "";
    message.serviceUserId = (_b = object.serviceUserId) !== null && _b !== void 0 ? _b : void 0;
    return message;
  } };
  function createBaseGuestAccessTokenExchange() {
    return { maxDuration: void 0 };
  }
  exports2.GuestAccessTokenExchange = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.maxDuration !== void 0) {
      writer2.uint32(8).uint32(message.maxDuration);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGuestAccessTokenExchange();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maxDuration = reader2.uint32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { maxDuration: isSet2(object.maxDuration) ? Number(object.maxDuration) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.maxDuration !== void 0 && (obj.maxDuration = Math.round(message.maxDuration));
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseGuestAccessTokenExchange();
    message.maxDuration = (_a2 = object.maxDuration) !== null && _a2 !== void 0 ? _a2 : void 0;
    return message;
  } };
  function createBaseGuestAccessToken() {
    return { direct: void 0, exchange: void 0 };
  }
  exports2.GuestAccessToken = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.direct !== void 0) {
      exports2.GuestAccessTokenDirect.encode(message.direct, writer2.uint32(10).fork()).ldelim();
    }
    if (message.exchange !== void 0) {
      exports2.GuestAccessTokenExchange.encode(message.exchange, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGuestAccessToken();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.direct = exports2.GuestAccessTokenDirect.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.exchange = exports2.GuestAccessTokenExchange.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { direct: isSet2(object.direct) ? exports2.GuestAccessTokenDirect.fromJSON(object.direct) : void 0, exchange: isSet2(object.exchange) ? exports2.GuestAccessTokenExchange.fromJSON(object.exchange) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.direct !== void 0 && (obj.direct = message.direct ? exports2.GuestAccessTokenDirect.toJSON(message.direct) : void 0);
    message.exchange !== void 0 && (obj.exchange = message.exchange ? exports2.GuestAccessTokenExchange.toJSON(message.exchange) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseGuestAccessToken();
    message.direct = object.direct !== void 0 && object.direct !== null ? exports2.GuestAccessTokenDirect.fromPartial(object.direct) : void 0;
    message.exchange = object.exchange !== void 0 && object.exchange !== null ? exports2.GuestAccessTokenExchange.fromPartial(object.exchange) : void 0;
    return message;
  } };
  function createBaseCreateGuestAccessTokenRequest() {
    return { collectionId: "", projectId: "", maxDuration: void 0, role: Role2.ROLE_UNSPECIFIED, token: void 0, url: void 0 };
  }
  exports2.CreateGuestAccessTokenRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.maxDuration !== void 0) {
      writer2.uint32(24).uint32(message.maxDuration);
    }
    if (message.role !== Role2.ROLE_UNSPECIFIED) {
      writer2.uint32(32).int32(roleToNumber(message.role));
    }
    if (message.token !== void 0) {
      exports2.GuestAccessToken.encode(message.token, writer2.uint32(42).fork()).ldelim();
    }
    if (message.url !== void 0) {
      writer2.uint32(50).string(message.url);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCreateGuestAccessTokenRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.maxDuration = reader2.uint32();
          break;
        case 4:
          message.role = roleFromJSON(reader2.int32());
          break;
        case 5:
          message.token = exports2.GuestAccessToken.decode(reader2, reader2.uint32());
          break;
        case 6:
          message.url = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", maxDuration: isSet2(object.maxDuration) ? Number(object.maxDuration) : void 0, role: isSet2(object.role) ? roleFromJSON(object.role) : Role2.ROLE_UNSPECIFIED, token: isSet2(object.token) ? exports2.GuestAccessToken.fromJSON(object.token) : void 0, url: isSet2(object.url) ? String(object.url) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.maxDuration !== void 0 && (obj.maxDuration = Math.round(message.maxDuration));
    message.role !== void 0 && (obj.role = roleToJSON(message.role));
    message.token !== void 0 && (obj.token = message.token ? exports2.GuestAccessToken.toJSON(message.token) : void 0);
    message.url !== void 0 && (obj.url = message.url);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e;
    const message = createBaseCreateGuestAccessTokenRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.maxDuration = (_c = object.maxDuration) !== null && _c !== void 0 ? _c : void 0;
    message.role = (_d = object.role) !== null && _d !== void 0 ? _d : Role2.ROLE_UNSPECIFIED;
    message.token = object.token !== void 0 && object.token !== null ? exports2.GuestAccessToken.fromPartial(object.token) : void 0;
    message.url = (_e = object.url) !== null && _e !== void 0 ? _e : void 0;
    return message;
  } };
  function createBaseCreateGuestAccessTokenResponse() {
    return { accessToken: "", url: void 0 };
  }
  exports2.CreateGuestAccessTokenResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.accessToken !== "") {
      writer2.uint32(10).string(message.accessToken);
    }
    if (message.url !== void 0) {
      writer2.uint32(18).string(message.url);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCreateGuestAccessTokenResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accessToken = reader2.string();
          break;
        case 2:
          message.url = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { accessToken: isSet2(object.accessToken) ? String(object.accessToken) : "", url: isSet2(object.url) ? String(object.url) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.accessToken !== void 0 && (obj.accessToken = message.accessToken);
    message.url !== void 0 && (obj.url = message.url);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseCreateGuestAccessTokenResponse();
    message.accessToken = (_a2 = object.accessToken) !== null && _a2 !== void 0 ? _a2 : "";
    message.url = (_b = object.url) !== null && _b !== void 0 ? _b : void 0;
    return message;
  } };
  function createBaseCreateWebRtcAccessTokenRequest() {
    return { collectionId: "", projectId: "", displayName: "" };
  }
  exports2.CreateWebRtcAccessTokenRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.displayName !== "") {
      writer2.uint32(26).string(message.displayName);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCreateWebRtcAccessTokenRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.displayName = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", displayName: isSet2(object.displayName) ? String(object.displayName) : "" };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.displayName !== void 0 && (obj.displayName = message.displayName);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseCreateWebRtcAccessTokenRequest();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.displayName = (_c = object.displayName) !== null && _c !== void 0 ? _c : "";
    return message;
  } };
  function createBaseCreateWebRtcAccessTokenResponse() {
    return { webrtcAccess: void 0 };
  }
  exports2.CreateWebRtcAccessTokenResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.webrtcAccess !== void 0) {
      exports2.WebRtcAccess.encode(message.webrtcAccess, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCreateWebRtcAccessTokenResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 2:
          message.webrtcAccess = exports2.WebRtcAccess.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { webrtcAccess: isSet2(object.webrtcAccess) ? exports2.WebRtcAccess.fromJSON(object.webrtcAccess) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.webrtcAccess !== void 0 && (obj.webrtcAccess = message.webrtcAccess ? exports2.WebRtcAccess.toJSON(message.webrtcAccess) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseCreateWebRtcAccessTokenResponse();
    message.webrtcAccess = object.webrtcAccess !== void 0 && object.webrtcAccess !== null ? exports2.WebRtcAccess.fromPartial(object.webrtcAccess) : void 0;
    return message;
  } };
  function createBaseRefreshAccessTokenRequest() {
    return {};
  }
  exports2.RefreshAccessTokenRequest = { encode(_, writer2 = _m02.Writer.create()) {
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseRefreshAccessTokenRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(_) {
    return {};
  }, toJSON(_) {
    const obj = {};
    return obj;
  }, fromPartial(_) {
    const message = createBaseRefreshAccessTokenRequest();
    return message;
  } };
  function createBaseRefreshAccessTokenResponse() {
    return {};
  }
  exports2.RefreshAccessTokenResponse = { encode(_, writer2 = _m02.Writer.create()) {
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseRefreshAccessTokenResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(_) {
    return {};
  }, toJSON(_) {
    const obj = {};
    return obj;
  }, fromPartial(_) {
    const message = createBaseRefreshAccessTokenResponse();
    return message;
  } };
  function createBaseGuestCode() {
    return { collectionId: "", projectId: "", code: "", url: "", autoDelete: void 0 };
  }
  exports2.GuestCode = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.code !== "") {
      writer2.uint32(26).string(message.code);
    }
    if (message.url !== "") {
      writer2.uint32(34).string(message.url);
    }
    if (message.autoDelete !== void 0) {
      timestamp_1.Timestamp.encode(toTimestamp(message.autoDelete), writer2.uint32(42).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGuestCode();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.code = reader2.string();
          break;
        case 4:
          message.url = reader2.string();
          break;
        case 5:
          message.autoDelete = fromTimestamp(timestamp_1.Timestamp.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", code: isSet2(object.code) ? String(object.code) : "", url: isSet2(object.url) ? String(object.url) : "", autoDelete: isSet2(object.autoDelete) ? String(object.autoDelete) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.code !== void 0 && (obj.code = message.code);
    message.url !== void 0 && (obj.url = message.url);
    message.autoDelete !== void 0 && (obj.autoDelete = message.autoDelete);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e;
    const message = createBaseGuestCode();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.code = (_c = object.code) !== null && _c !== void 0 ? _c : "";
    message.url = (_d = object.url) !== null && _d !== void 0 ? _d : "";
    message.autoDelete = (_e = object.autoDelete) !== null && _e !== void 0 ? _e : void 0;
    return message;
  } };
  function createBaseGuestCodeRedirectRequest() {
    return { serviceId: "", code: "" };
  }
  exports2.GuestCodeRedirectRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.serviceId !== "") {
      writer2.uint32(10).string(message.serviceId);
    }
    if (message.code !== "") {
      writer2.uint32(18).string(message.code);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGuestCodeRedirectRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.serviceId = reader2.string();
          break;
        case 2:
          message.code = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { serviceId: isSet2(object.serviceId) ? String(object.serviceId) : "", code: isSet2(object.code) ? String(object.code) : "" };
  }, toJSON(message) {
    const obj = {};
    message.serviceId !== void 0 && (obj.serviceId = message.serviceId);
    message.code !== void 0 && (obj.code = message.code);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseGuestCodeRedirectRequest();
    message.serviceId = (_a2 = object.serviceId) !== null && _a2 !== void 0 ? _a2 : "";
    message.code = (_b = object.code) !== null && _b !== void 0 ? _b : "";
    return message;
  } };
  function createBaseGuestCodeRedirectResponse() {
    return {};
  }
  exports2.GuestCodeRedirectResponse = { encode(_, writer2 = _m02.Writer.create()) {
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGuestCodeRedirectResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(_) {
    return {};
  }, toJSON(_) {
    const obj = {};
    return obj;
  }, fromPartial(_) {
    const message = createBaseGuestCodeRedirectResponse();
    return message;
  } };
  function createBaseJsonWebKey() {
    return { alg: "", kty: "", use: "", kid: "", e: "", n: "" };
  }
  exports2.JsonWebKey = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.alg !== "") {
      writer2.uint32(10).string(message.alg);
    }
    if (message.kty !== "") {
      writer2.uint32(18).string(message.kty);
    }
    if (message.use !== "") {
      writer2.uint32(26).string(message.use);
    }
    if (message.kid !== "") {
      writer2.uint32(34).string(message.kid);
    }
    if (message.e !== "") {
      writer2.uint32(42).string(message.e);
    }
    if (message.n !== "") {
      writer2.uint32(50).string(message.n);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseJsonWebKey();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.alg = reader2.string();
          break;
        case 2:
          message.kty = reader2.string();
          break;
        case 3:
          message.use = reader2.string();
          break;
        case 4:
          message.kid = reader2.string();
          break;
        case 5:
          message.e = reader2.string();
          break;
        case 6:
          message.n = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { alg: isSet2(object.alg) ? String(object.alg) : "", kty: isSet2(object.kty) ? String(object.kty) : "", use: isSet2(object.use) ? String(object.use) : "", kid: isSet2(object.kid) ? String(object.kid) : "", e: isSet2(object.e) ? String(object.e) : "", n: isSet2(object.n) ? String(object.n) : "" };
  }, toJSON(message) {
    const obj = {};
    message.alg !== void 0 && (obj.alg = message.alg);
    message.kty !== void 0 && (obj.kty = message.kty);
    message.use !== void 0 && (obj.use = message.use);
    message.kid !== void 0 && (obj.kid = message.kid);
    message.e !== void 0 && (obj.e = message.e);
    message.n !== void 0 && (obj.n = message.n);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f;
    const message = createBaseJsonWebKey();
    message.alg = (_a2 = object.alg) !== null && _a2 !== void 0 ? _a2 : "";
    message.kty = (_b = object.kty) !== null && _b !== void 0 ? _b : "";
    message.use = (_c = object.use) !== null && _c !== void 0 ? _c : "";
    message.kid = (_d = object.kid) !== null && _d !== void 0 ? _d : "";
    message.e = (_e = object.e) !== null && _e !== void 0 ? _e : "";
    message.n = (_f = object.n) !== null && _f !== void 0 ? _f : "";
    return message;
  } };
  function createBaseGetJsonWebKeySetRequest() {
    return {};
  }
  exports2.GetJsonWebKeySetRequest = { encode(_, writer2 = _m02.Writer.create()) {
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetJsonWebKeySetRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(_) {
    return {};
  }, toJSON(_) {
    const obj = {};
    return obj;
  }, fromPartial(_) {
    const message = createBaseGetJsonWebKeySetRequest();
    return message;
  } };
  function createBaseGetJsonWebKeySetResponse() {
    return { keys: [] };
  }
  exports2.GetJsonWebKeySetResponse = { encode(message, writer2 = _m02.Writer.create()) {
    for (const v2 of message.keys) {
      exports2.JsonWebKey.encode(v2, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetJsonWebKeySetResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.keys.push(exports2.JsonWebKey.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { keys: Array.isArray(object === null || object === void 0 ? void 0 : object.keys) ? object.keys.map((e2) => exports2.JsonWebKey.fromJSON(e2)) : [] };
  }, toJSON(message) {
    const obj = {};
    if (message.keys) {
      obj.keys = message.keys.map((e2) => e2 ? exports2.JsonWebKey.toJSON(e2) : void 0);
    } else {
      obj.keys = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseGetJsonWebKeySetResponse();
    message.keys = ((_a2 = object.keys) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports2.JsonWebKey.fromPartial(e2))) || [];
    return message;
  } };
  function createBaseGetTestTokenRequest() {
    return {};
  }
  exports2.GetTestTokenRequest = { encode(_, writer2 = _m02.Writer.create()) {
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetTestTokenRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(_) {
    return {};
  }, toJSON(_) {
    const obj = {};
    return obj;
  }, fromPartial(_) {
    const message = createBaseGetTestTokenRequest();
    return message;
  } };
  function createBaseGetTestTokenResponse() {
    return { accessToken: "" };
  }
  exports2.GetTestTokenResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.accessToken !== "") {
      writer2.uint32(10).string(message.accessToken);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetTestTokenResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accessToken = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { accessToken: isSet2(object.accessToken) ? String(object.accessToken) : "" };
  }, toJSON(message) {
    const obj = {};
    message.accessToken !== void 0 && (obj.accessToken = message.accessToken);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseGetTestTokenResponse();
    message.accessToken = (_a2 = object.accessToken) !== null && _a2 !== void 0 ? _a2 : "";
    return message;
  } };
  function createBaseDestinationCreateEvent() {
    return { collectionId: "", projectId: "", destinationId: "", destination: void 0 };
  }
  exports2.DestinationCreateEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.destinationId !== "") {
      writer2.uint32(26).string(message.destinationId);
    }
    if (message.destination !== void 0) {
      exports2.Destination.encode(message.destination, writer2.uint32(34).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDestinationCreateEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.destinationId = reader2.string();
          break;
        case 4:
          message.destination = exports2.Destination.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", destinationId: isSet2(object.destinationId) ? String(object.destinationId) : "", destination: isSet2(object.destination) ? exports2.Destination.fromJSON(object.destination) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.destinationId !== void 0 && (obj.destinationId = message.destinationId);
    message.destination !== void 0 && (obj.destination = message.destination ? exports2.Destination.toJSON(message.destination) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseDestinationCreateEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.destinationId = (_c = object.destinationId) !== null && _c !== void 0 ? _c : "";
    message.destination = object.destination !== void 0 && object.destination !== null ? exports2.Destination.fromPartial(object.destination) : void 0;
    return message;
  } };
  function createBaseDestinationDeleteEvent() {
    return { collectionId: "", projectId: "", destinationId: "" };
  }
  exports2.DestinationDeleteEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.destinationId !== "") {
      writer2.uint32(26).string(message.destinationId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDestinationDeleteEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.destinationId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", destinationId: isSet2(object.destinationId) ? String(object.destinationId) : "" };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.destinationId !== void 0 && (obj.destinationId = message.destinationId);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseDestinationDeleteEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.destinationId = (_c = object.destinationId) !== null && _c !== void 0 ? _c : "";
    return message;
  } };
  function createBaseDestinationUpdateEvent() {
    return { collectionId: "", projectId: "", destinationId: "", updateMask: [], destination: void 0 };
  }
  exports2.DestinationUpdateEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.destinationId !== "") {
      writer2.uint32(26).string(message.destinationId);
    }
    for (const v2 of message.updateMask) {
      writer2.uint32(34).string(v2);
    }
    if (message.destination !== void 0) {
      exports2.Destination.encode(message.destination, writer2.uint32(42).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDestinationUpdateEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.destinationId = reader2.string();
          break;
        case 4:
          message.updateMask.push(reader2.string());
          break;
        case 5:
          message.destination = exports2.Destination.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", destinationId: isSet2(object.destinationId) ? String(object.destinationId) : "", updateMask: Array.isArray(object === null || object === void 0 ? void 0 : object.updateMask) ? object.updateMask.map((e2) => String(e2)) : [], destination: isSet2(object.destination) ? exports2.Destination.fromJSON(object.destination) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.destinationId !== void 0 && (obj.destinationId = message.destinationId);
    if (message.updateMask) {
      obj.updateMask = message.updateMask.map((e2) => e2);
    } else {
      obj.updateMask = [];
    }
    message.destination !== void 0 && (obj.destination = message.destination ? exports2.Destination.toJSON(message.destination) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseDestinationUpdateEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.destinationId = (_c = object.destinationId) !== null && _c !== void 0 ? _c : "";
    message.updateMask = ((_d = object.updateMask) === null || _d === void 0 ? void 0 : _d.map((e2) => e2)) || [];
    message.destination = object.destination !== void 0 && object.destination !== null ? exports2.Destination.fromPartial(object.destination) : void 0;
    return message;
  } };
  function createBaseDestinationStateEvent() {
    return { collectionId: "", projectId: "", destinationId: "", connect: void 0 };
  }
  exports2.DestinationStateEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.destinationId !== "") {
      writer2.uint32(26).string(message.destinationId);
    }
    if (message.connect !== void 0) {
      writer2.uint32(32).int32(connectStateToNumber(message.connect));
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDestinationStateEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.destinationId = reader2.string();
          break;
        case 4:
          message.connect = connectStateFromJSON(reader2.int32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", destinationId: isSet2(object.destinationId) ? String(object.destinationId) : "", connect: isSet2(object.connect) ? connectStateFromJSON(object.connect) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.destinationId !== void 0 && (obj.destinationId = message.destinationId);
    message.connect !== void 0 && (obj.connect = message.connect !== void 0 ? connectStateToJSON(message.connect) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseDestinationStateEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.destinationId = (_c = object.destinationId) !== null && _c !== void 0 ? _c : "";
    message.connect = (_d = object.connect) !== null && _d !== void 0 ? _d : void 0;
    return message;
  } };
  function createBaseProjectCreateEvent() {
    return { collectionId: "", projectId: "", project: void 0 };
  }
  exports2.ProjectCreateEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.project !== void 0) {
      exports2.Project.encode(message.project, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseProjectCreateEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.project = exports2.Project.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", project: isSet2(object.project) ? exports2.Project.fromJSON(object.project) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.project !== void 0 && (obj.project = message.project ? exports2.Project.toJSON(message.project) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseProjectCreateEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.project = object.project !== void 0 && object.project !== null ? exports2.Project.fromPartial(object.project) : void 0;
    return message;
  } };
  function createBaseProjectDeleteEvent() {
    return { collectionId: "", projectId: "" };
  }
  exports2.ProjectDeleteEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseProjectDeleteEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "" };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseProjectDeleteEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    return message;
  } };
  function createBaseProjectUpdateEvent() {
    return { collectionId: "", projectId: "", updateMask: [], project: void 0 };
  }
  exports2.ProjectUpdateEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    for (const v2 of message.updateMask) {
      writer2.uint32(26).string(v2);
    }
    if (message.project !== void 0) {
      exports2.Project.encode(message.project, writer2.uint32(34).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseProjectUpdateEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.updateMask.push(reader2.string());
          break;
        case 4:
          message.project = exports2.Project.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", updateMask: Array.isArray(object === null || object === void 0 ? void 0 : object.updateMask) ? object.updateMask.map((e2) => String(e2)) : [], project: isSet2(object.project) ? exports2.Project.fromJSON(object.project) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    if (message.updateMask) {
      obj.updateMask = message.updateMask.map((e2) => e2);
    } else {
      obj.updateMask = [];
    }
    message.project !== void 0 && (obj.project = message.project ? exports2.Project.toJSON(message.project) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseProjectUpdateEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.updateMask = ((_c = object.updateMask) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
    message.project = object.project !== void 0 && object.project !== null ? exports2.Project.fromPartial(object.project) : void 0;
    return message;
  } };
  function createBaseProjectBroadcastStateEvent() {
    return { collectionId: "", projectId: "", broadcastId: "", phase: void 0, error: void 0 };
  }
  exports2.ProjectBroadcastStateEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.broadcastId !== "") {
      writer2.uint32(26).string(message.broadcastId);
    }
    if (message.phase !== void 0) {
      writer2.uint32(32).int32(projectBroadcastPhaseToNumber(message.phase));
    }
    if (message.error !== void 0) {
      writer2.uint32(40).int32(projectBroadcastErrorToNumber(message.error));
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseProjectBroadcastStateEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.broadcastId = reader2.string();
          break;
        case 4:
          message.phase = projectBroadcastPhaseFromJSON(reader2.int32());
          break;
        case 5:
          message.error = projectBroadcastErrorFromJSON(reader2.int32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", broadcastId: isSet2(object.broadcastId) ? String(object.broadcastId) : "", phase: isSet2(object.phase) ? projectBroadcastPhaseFromJSON(object.phase) : void 0, error: isSet2(object.error) ? projectBroadcastErrorFromJSON(object.error) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.broadcastId !== void 0 && (obj.broadcastId = message.broadcastId);
    message.phase !== void 0 && (obj.phase = message.phase !== void 0 ? projectBroadcastPhaseToJSON(message.phase) : void 0);
    message.error !== void 0 && (obj.error = message.error !== void 0 ? projectBroadcastErrorToJSON(message.error) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e;
    const message = createBaseProjectBroadcastStateEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.broadcastId = (_c = object.broadcastId) !== null && _c !== void 0 ? _c : "";
    message.phase = (_d = object.phase) !== null && _d !== void 0 ? _d : void 0;
    message.error = (_e = object.error) !== null && _e !== void 0 ? _e : void 0;
    return message;
  } };
  function createBaseCollectionCreateEvent() {
    return { collectionId: "", collection: void 0 };
  }
  exports2.CollectionCreateEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.collection !== void 0) {
      exports2.Collection.encode(message.collection, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCollectionCreateEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.collection = exports2.Collection.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", collection: isSet2(object.collection) ? exports2.Collection.fromJSON(object.collection) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.collection !== void 0 && (obj.collection = message.collection ? exports2.Collection.toJSON(message.collection) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseCollectionCreateEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.collection = object.collection !== void 0 && object.collection !== null ? exports2.Collection.fromPartial(object.collection) : void 0;
    return message;
  } };
  function createBaseCollectionDeleteEvent() {
    return { collectionId: "" };
  }
  exports2.CollectionDeleteEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCollectionDeleteEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "" };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseCollectionDeleteEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    return message;
  } };
  function createBaseCollectionUpdateEvent() {
    return { collectionId: "", updateMask: [], collection: void 0 };
  }
  exports2.CollectionUpdateEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    for (const v2 of message.updateMask) {
      writer2.uint32(18).string(v2);
    }
    if (message.collection !== void 0) {
      exports2.Collection.encode(message.collection, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCollectionUpdateEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.updateMask.push(reader2.string());
          break;
        case 3:
          message.collection = exports2.Collection.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", updateMask: Array.isArray(object === null || object === void 0 ? void 0 : object.updateMask) ? object.updateMask.map((e2) => String(e2)) : [], collection: isSet2(object.collection) ? exports2.Collection.fromJSON(object.collection) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    if (message.updateMask) {
      obj.updateMask = message.updateMask.map((e2) => e2);
    } else {
      obj.updateMask = [];
    }
    message.collection !== void 0 && (obj.collection = message.collection ? exports2.Collection.toJSON(message.collection) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseCollectionUpdateEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.updateMask = ((_b = object.updateMask) === null || _b === void 0 ? void 0 : _b.map((e2) => e2)) || [];
    message.collection = object.collection !== void 0 && object.collection !== null ? exports2.Collection.fromPartial(object.collection) : void 0;
    return message;
  } };
  function createBaseSourceCreateEvent() {
    return { collectionId: "", sourceId: "", source: void 0 };
  }
  exports2.SourceCreateEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.sourceId !== "") {
      writer2.uint32(18).string(message.sourceId);
    }
    if (message.source !== void 0) {
      exports2.Source.encode(message.source, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSourceCreateEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.sourceId = reader2.string();
          break;
        case 3:
          message.source = exports2.Source.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "", source: isSet2(object.source) ? exports2.Source.fromJSON(object.source) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
    message.source !== void 0 && (obj.source = message.source ? exports2.Source.toJSON(message.source) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseSourceCreateEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
    message.source = object.source !== void 0 && object.source !== null ? exports2.Source.fromPartial(object.source) : void 0;
    return message;
  } };
  function createBaseSourceDeleteEvent() {
    return { collectionId: "", sourceId: "" };
  }
  exports2.SourceDeleteEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.sourceId !== "") {
      writer2.uint32(18).string(message.sourceId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSourceDeleteEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.sourceId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "" };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseSourceDeleteEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
    return message;
  } };
  function createBaseSourceUpdateEvent() {
    return { collectionId: "", sourceId: "", updateMask: [], source: void 0 };
  }
  exports2.SourceUpdateEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.sourceId !== "") {
      writer2.uint32(18).string(message.sourceId);
    }
    for (const v2 of message.updateMask) {
      writer2.uint32(26).string(v2);
    }
    if (message.source !== void 0) {
      exports2.Source.encode(message.source, writer2.uint32(34).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSourceUpdateEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.sourceId = reader2.string();
          break;
        case 3:
          message.updateMask.push(reader2.string());
          break;
        case 4:
          message.source = exports2.Source.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "", updateMask: Array.isArray(object === null || object === void 0 ? void 0 : object.updateMask) ? object.updateMask.map((e2) => String(e2)) : [], source: isSet2(object.source) ? exports2.Source.fromJSON(object.source) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
    if (message.updateMask) {
      obj.updateMask = message.updateMask.map((e2) => e2);
    } else {
      obj.updateMask = [];
    }
    message.source !== void 0 && (obj.source = message.source ? exports2.Source.toJSON(message.source) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseSourceUpdateEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
    message.updateMask = ((_c = object.updateMask) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
    message.source = object.source !== void 0 && object.source !== null ? exports2.Source.fromPartial(object.source) : void 0;
    return message;
  } };
  function createBaseSourceAddEvent() {
    return { collectionId: "", sourceId: "", projectId: "", source: void 0 };
  }
  exports2.SourceAddEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.sourceId !== "") {
      writer2.uint32(18).string(message.sourceId);
    }
    if (message.projectId !== "") {
      writer2.uint32(26).string(message.projectId);
    }
    if (message.source !== void 0) {
      exports2.Source.encode(message.source, writer2.uint32(34).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSourceAddEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.sourceId = reader2.string();
          break;
        case 3:
          message.projectId = reader2.string();
          break;
        case 4:
          message.source = exports2.Source.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", source: isSet2(object.source) ? exports2.Source.fromJSON(object.source) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.source !== void 0 && (obj.source = message.source ? exports2.Source.toJSON(message.source) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseSourceAddEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
    message.projectId = (_c = object.projectId) !== null && _c !== void 0 ? _c : "";
    message.source = object.source !== void 0 && object.source !== null ? exports2.Source.fromPartial(object.source) : void 0;
    return message;
  } };
  function createBaseSourceRemoveEvent() {
    return { collectionId: "", sourceId: "", projectId: "" };
  }
  exports2.SourceRemoveEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.sourceId !== "") {
      writer2.uint32(18).string(message.sourceId);
    }
    if (message.projectId !== "") {
      writer2.uint32(26).string(message.projectId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSourceRemoveEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.sourceId = reader2.string();
          break;
        case 3:
          message.projectId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "" };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseSourceRemoveEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
    message.projectId = (_c = object.projectId) !== null && _c !== void 0 ? _c : "";
    return message;
  } };
  function createBaseSourceStateEvent() {
    return { collectionId: "", projectId: "", sourceId: "", connect: void 0 };
  }
  exports2.SourceStateEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== "") {
      writer2.uint32(10).string(message.collectionId);
    }
    if (message.projectId !== "") {
      writer2.uint32(18).string(message.projectId);
    }
    if (message.sourceId !== "") {
      writer2.uint32(26).string(message.sourceId);
    }
    if (message.connect !== void 0) {
      writer2.uint32(32).int32(connectStateToNumber(message.connect));
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSourceStateEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collectionId = reader2.string();
          break;
        case 2:
          message.projectId = reader2.string();
          break;
        case 3:
          message.sourceId = reader2.string();
          break;
        case 4:
          message.connect = connectStateFromJSON(reader2.int32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "", projectId: isSet2(object.projectId) ? String(object.projectId) : "", sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "", connect: isSet2(object.connect) ? connectStateFromJSON(object.connect) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
    message.connect !== void 0 && (obj.connect = message.connect !== void 0 ? connectStateToJSON(message.connect) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseSourceStateEvent();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
    message.sourceId = (_c = object.sourceId) !== null && _c !== void 0 ? _c : "";
    message.connect = (_d = object.connect) !== null && _d !== void 0 ? _d : void 0;
    return message;
  } };
  function createBaseCollectionEvent() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  exports2.CollectionEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.create !== void 0) {
      exports2.CollectionCreateEvent.encode(message.create, writer2.uint32(10).fork()).ldelim();
    }
    if (message.update !== void 0) {
      exports2.CollectionUpdateEvent.encode(message.update, writer2.uint32(18).fork()).ldelim();
    }
    if (message.delete !== void 0) {
      exports2.CollectionDeleteEvent.encode(message.delete, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCollectionEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.create = exports2.CollectionCreateEvent.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.update = exports2.CollectionUpdateEvent.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.delete = exports2.CollectionDeleteEvent.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { create: isSet2(object.create) ? exports2.CollectionCreateEvent.fromJSON(object.create) : void 0, update: isSet2(object.update) ? exports2.CollectionUpdateEvent.fromJSON(object.update) : void 0, delete: isSet2(object.delete) ? exports2.CollectionDeleteEvent.fromJSON(object.delete) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.create !== void 0 && (obj.create = message.create ? exports2.CollectionCreateEvent.toJSON(message.create) : void 0);
    message.update !== void 0 && (obj.update = message.update ? exports2.CollectionUpdateEvent.toJSON(message.update) : void 0);
    message.delete !== void 0 && (obj.delete = message.delete ? exports2.CollectionDeleteEvent.toJSON(message.delete) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseCollectionEvent();
    message.create = object.create !== void 0 && object.create !== null ? exports2.CollectionCreateEvent.fromPartial(object.create) : void 0;
    message.update = object.update !== void 0 && object.update !== null ? exports2.CollectionUpdateEvent.fromPartial(object.update) : void 0;
    message.delete = object.delete !== void 0 && object.delete !== null ? exports2.CollectionDeleteEvent.fromPartial(object.delete) : void 0;
    return message;
  } };
  function createBaseDestinationEvent() {
    return { create: void 0, update: void 0, delete: void 0, state: void 0 };
  }
  exports2.DestinationEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.create !== void 0) {
      exports2.DestinationCreateEvent.encode(message.create, writer2.uint32(10).fork()).ldelim();
    }
    if (message.update !== void 0) {
      exports2.DestinationUpdateEvent.encode(message.update, writer2.uint32(18).fork()).ldelim();
    }
    if (message.delete !== void 0) {
      exports2.DestinationDeleteEvent.encode(message.delete, writer2.uint32(26).fork()).ldelim();
    }
    if (message.state !== void 0) {
      exports2.DestinationStateEvent.encode(message.state, writer2.uint32(34).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDestinationEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.create = exports2.DestinationCreateEvent.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.update = exports2.DestinationUpdateEvent.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.delete = exports2.DestinationDeleteEvent.decode(reader2, reader2.uint32());
          break;
        case 4:
          message.state = exports2.DestinationStateEvent.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { create: isSet2(object.create) ? exports2.DestinationCreateEvent.fromJSON(object.create) : void 0, update: isSet2(object.update) ? exports2.DestinationUpdateEvent.fromJSON(object.update) : void 0, delete: isSet2(object.delete) ? exports2.DestinationDeleteEvent.fromJSON(object.delete) : void 0, state: isSet2(object.state) ? exports2.DestinationStateEvent.fromJSON(object.state) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.create !== void 0 && (obj.create = message.create ? exports2.DestinationCreateEvent.toJSON(message.create) : void 0);
    message.update !== void 0 && (obj.update = message.update ? exports2.DestinationUpdateEvent.toJSON(message.update) : void 0);
    message.delete !== void 0 && (obj.delete = message.delete ? exports2.DestinationDeleteEvent.toJSON(message.delete) : void 0);
    message.state !== void 0 && (obj.state = message.state ? exports2.DestinationStateEvent.toJSON(message.state) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseDestinationEvent();
    message.create = object.create !== void 0 && object.create !== null ? exports2.DestinationCreateEvent.fromPartial(object.create) : void 0;
    message.update = object.update !== void 0 && object.update !== null ? exports2.DestinationUpdateEvent.fromPartial(object.update) : void 0;
    message.delete = object.delete !== void 0 && object.delete !== null ? exports2.DestinationDeleteEvent.fromPartial(object.delete) : void 0;
    message.state = object.state !== void 0 && object.state !== null ? exports2.DestinationStateEvent.fromPartial(object.state) : void 0;
    return message;
  } };
  function createBaseProjectEvent() {
    return { create: void 0, update: void 0, delete: void 0, state: void 0 };
  }
  exports2.ProjectEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.create !== void 0) {
      exports2.ProjectCreateEvent.encode(message.create, writer2.uint32(10).fork()).ldelim();
    }
    if (message.update !== void 0) {
      exports2.ProjectUpdateEvent.encode(message.update, writer2.uint32(18).fork()).ldelim();
    }
    if (message.delete !== void 0) {
      exports2.ProjectDeleteEvent.encode(message.delete, writer2.uint32(26).fork()).ldelim();
    }
    if (message.state !== void 0) {
      exports2.ProjectBroadcastStateEvent.encode(message.state, writer2.uint32(34).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseProjectEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.create = exports2.ProjectCreateEvent.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.update = exports2.ProjectUpdateEvent.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.delete = exports2.ProjectDeleteEvent.decode(reader2, reader2.uint32());
          break;
        case 4:
          message.state = exports2.ProjectBroadcastStateEvent.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { create: isSet2(object.create) ? exports2.ProjectCreateEvent.fromJSON(object.create) : void 0, update: isSet2(object.update) ? exports2.ProjectUpdateEvent.fromJSON(object.update) : void 0, delete: isSet2(object.delete) ? exports2.ProjectDeleteEvent.fromJSON(object.delete) : void 0, state: isSet2(object.state) ? exports2.ProjectBroadcastStateEvent.fromJSON(object.state) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.create !== void 0 && (obj.create = message.create ? exports2.ProjectCreateEvent.toJSON(message.create) : void 0);
    message.update !== void 0 && (obj.update = message.update ? exports2.ProjectUpdateEvent.toJSON(message.update) : void 0);
    message.delete !== void 0 && (obj.delete = message.delete ? exports2.ProjectDeleteEvent.toJSON(message.delete) : void 0);
    message.state !== void 0 && (obj.state = message.state ? exports2.ProjectBroadcastStateEvent.toJSON(message.state) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseProjectEvent();
    message.create = object.create !== void 0 && object.create !== null ? exports2.ProjectCreateEvent.fromPartial(object.create) : void 0;
    message.update = object.update !== void 0 && object.update !== null ? exports2.ProjectUpdateEvent.fromPartial(object.update) : void 0;
    message.delete = object.delete !== void 0 && object.delete !== null ? exports2.ProjectDeleteEvent.fromPartial(object.delete) : void 0;
    message.state = object.state !== void 0 && object.state !== null ? exports2.ProjectBroadcastStateEvent.fromPartial(object.state) : void 0;
    return message;
  } };
  function createBaseSourceEvent() {
    return { create: void 0, update: void 0, delete: void 0, add: void 0, remove: void 0, state: void 0 };
  }
  exports2.SourceEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.create !== void 0) {
      exports2.SourceCreateEvent.encode(message.create, writer2.uint32(10).fork()).ldelim();
    }
    if (message.update !== void 0) {
      exports2.SourceUpdateEvent.encode(message.update, writer2.uint32(18).fork()).ldelim();
    }
    if (message.delete !== void 0) {
      exports2.SourceDeleteEvent.encode(message.delete, writer2.uint32(26).fork()).ldelim();
    }
    if (message.add !== void 0) {
      exports2.SourceAddEvent.encode(message.add, writer2.uint32(34).fork()).ldelim();
    }
    if (message.remove !== void 0) {
      exports2.SourceDeleteEvent.encode(message.remove, writer2.uint32(42).fork()).ldelim();
    }
    if (message.state !== void 0) {
      exports2.SourceStateEvent.encode(message.state, writer2.uint32(50).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSourceEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.create = exports2.SourceCreateEvent.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.update = exports2.SourceUpdateEvent.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.delete = exports2.SourceDeleteEvent.decode(reader2, reader2.uint32());
          break;
        case 4:
          message.add = exports2.SourceAddEvent.decode(reader2, reader2.uint32());
          break;
        case 5:
          message.remove = exports2.SourceDeleteEvent.decode(reader2, reader2.uint32());
          break;
        case 6:
          message.state = exports2.SourceStateEvent.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { create: isSet2(object.create) ? exports2.SourceCreateEvent.fromJSON(object.create) : void 0, update: isSet2(object.update) ? exports2.SourceUpdateEvent.fromJSON(object.update) : void 0, delete: isSet2(object.delete) ? exports2.SourceDeleteEvent.fromJSON(object.delete) : void 0, add: isSet2(object.add) ? exports2.SourceAddEvent.fromJSON(object.add) : void 0, remove: isSet2(object.remove) ? exports2.SourceDeleteEvent.fromJSON(object.remove) : void 0, state: isSet2(object.state) ? exports2.SourceStateEvent.fromJSON(object.state) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.create !== void 0 && (obj.create = message.create ? exports2.SourceCreateEvent.toJSON(message.create) : void 0);
    message.update !== void 0 && (obj.update = message.update ? exports2.SourceUpdateEvent.toJSON(message.update) : void 0);
    message.delete !== void 0 && (obj.delete = message.delete ? exports2.SourceDeleteEvent.toJSON(message.delete) : void 0);
    message.add !== void 0 && (obj.add = message.add ? exports2.SourceAddEvent.toJSON(message.add) : void 0);
    message.remove !== void 0 && (obj.remove = message.remove ? exports2.SourceDeleteEvent.toJSON(message.remove) : void 0);
    message.state !== void 0 && (obj.state = message.state ? exports2.SourceStateEvent.toJSON(message.state) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = createBaseSourceEvent();
    message.create = object.create !== void 0 && object.create !== null ? exports2.SourceCreateEvent.fromPartial(object.create) : void 0;
    message.update = object.update !== void 0 && object.update !== null ? exports2.SourceUpdateEvent.fromPartial(object.update) : void 0;
    message.delete = object.delete !== void 0 && object.delete !== null ? exports2.SourceDeleteEvent.fromPartial(object.delete) : void 0;
    message.add = object.add !== void 0 && object.add !== null ? exports2.SourceAddEvent.fromPartial(object.add) : void 0;
    message.remove = object.remove !== void 0 && object.remove !== null ? exports2.SourceDeleteEvent.fromPartial(object.remove) : void 0;
    message.state = object.state !== void 0 && object.state !== null ? exports2.SourceStateEvent.fromPartial(object.state) : void 0;
    return message;
  } };
  function createBaseLiveEvent() {
    return { collection: void 0, destination: void 0, project: void 0, source: void 0, unspecified: void 0 };
  }
  exports2.LiveEvent = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collection !== void 0) {
      exports2.CollectionEvent.encode(message.collection, writer2.uint32(10).fork()).ldelim();
    }
    if (message.destination !== void 0) {
      exports2.DestinationEvent.encode(message.destination, writer2.uint32(18).fork()).ldelim();
    }
    if (message.project !== void 0) {
      exports2.ProjectEvent.encode(message.project, writer2.uint32(26).fork()).ldelim();
    }
    if (message.source !== void 0) {
      exports2.SourceEvent.encode(message.source, writer2.uint32(34).fork()).ldelim();
    }
    if (message.unspecified !== void 0) {
      writer2.uint32(40).int32((0, struct_1.nullValueToNumber)(message.unspecified));
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseLiveEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collection = exports2.CollectionEvent.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.destination = exports2.DestinationEvent.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.project = exports2.ProjectEvent.decode(reader2, reader2.uint32());
          break;
        case 4:
          message.source = exports2.SourceEvent.decode(reader2, reader2.uint32());
          break;
        case 5:
          message.unspecified = (0, struct_1.nullValueFromJSON)(reader2.int32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collection: isSet2(object.collection) ? exports2.CollectionEvent.fromJSON(object.collection) : void 0, destination: isSet2(object.destination) ? exports2.DestinationEvent.fromJSON(object.destination) : void 0, project: isSet2(object.project) ? exports2.ProjectEvent.fromJSON(object.project) : void 0, source: isSet2(object.source) ? exports2.SourceEvent.fromJSON(object.source) : void 0, unspecified: isSet2(object.unspecified) ? (0, struct_1.nullValueFromJSON)(object.unspecified) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collection !== void 0 && (obj.collection = message.collection ? exports2.CollectionEvent.toJSON(message.collection) : void 0);
    message.destination !== void 0 && (obj.destination = message.destination ? exports2.DestinationEvent.toJSON(message.destination) : void 0);
    message.project !== void 0 && (obj.project = message.project ? exports2.ProjectEvent.toJSON(message.project) : void 0);
    message.source !== void 0 && (obj.source = message.source ? exports2.SourceEvent.toJSON(message.source) : void 0);
    message.unspecified !== void 0 && (obj.unspecified = message.unspecified !== void 0 ? (0, struct_1.nullValueToJSON)(message.unspecified) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseLiveEvent();
    message.collection = object.collection !== void 0 && object.collection !== null ? exports2.CollectionEvent.fromPartial(object.collection) : void 0;
    message.destination = object.destination !== void 0 && object.destination !== null ? exports2.DestinationEvent.fromPartial(object.destination) : void 0;
    message.project = object.project !== void 0 && object.project !== null ? exports2.ProjectEvent.fromPartial(object.project) : void 0;
    message.source = object.source !== void 0 && object.source !== null ? exports2.SourceEvent.fromPartial(object.source) : void 0;
    message.unspecified = (_a2 = object.unspecified) !== null && _a2 !== void 0 ? _a2 : void 0;
    return message;
  } };
  class CollectionServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.CreateCollection = this.CreateCollection.bind(this);
      this.GetCollection = this.GetCollection.bind(this);
      this.GetCollections = this.GetCollections.bind(this);
      this.UpdateCollection = this.UpdateCollection.bind(this);
      this.DeleteCollection = this.DeleteCollection.bind(this);
    }
    CreateCollection(request3) {
      const data2 = exports2.CreateCollectionRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.CollectionService", "CreateCollection", data2);
      return promise.then((data3) => exports2.CreateCollectionResponse.decode(new _m02.Reader(data3)));
    }
    GetCollection(request3) {
      const data2 = exports2.GetCollectionRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.CollectionService", "GetCollection", data2);
      return promise.then((data3) => exports2.GetCollectionResponse.decode(new _m02.Reader(data3)));
    }
    GetCollections(request3) {
      const data2 = exports2.GetCollectionsRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.CollectionService", "GetCollections", data2);
      return promise.then((data3) => exports2.GetCollectionsResponse.decode(new _m02.Reader(data3)));
    }
    UpdateCollection(request3) {
      const data2 = exports2.UpdateCollectionRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.CollectionService", "UpdateCollection", data2);
      return promise.then((data3) => exports2.UpdateCollectionResponse.decode(new _m02.Reader(data3)));
    }
    DeleteCollection(request3) {
      const data2 = exports2.DeleteCollectionRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.CollectionService", "DeleteCollection", data2);
      return promise.then((data3) => exports2.DeleteCollectionResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.CollectionServiceClientImpl = CollectionServiceClientImpl;
  exports2.CollectionServiceDefinition = { name: "CollectionService", fullName: "live.v21.CollectionService", methods: { createCollection: { name: "CreateCollection", requestType: exports2.CreateCollectionRequest, requestStream: false, responseType: exports2.CreateCollectionResponse, responseStream: false, options: {} }, getCollection: { name: "GetCollection", requestType: exports2.GetCollectionRequest, requestStream: false, responseType: exports2.GetCollectionResponse, responseStream: false, options: {} }, getCollections: { name: "GetCollections", requestType: exports2.GetCollectionsRequest, requestStream: false, responseType: exports2.GetCollectionsResponse, responseStream: false, options: {} }, updateCollection: { name: "UpdateCollection", requestType: exports2.UpdateCollectionRequest, requestStream: false, responseType: exports2.UpdateCollectionResponse, responseStream: false, options: {} }, deleteCollection: { name: "DeleteCollection", requestType: exports2.DeleteCollectionRequest, requestStream: false, responseType: exports2.DeleteCollectionResponse, responseStream: false, options: {} } } };
  class ProjectServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.CreateProject = this.CreateProject.bind(this);
      this.GetProject = this.GetProject.bind(this);
      this.DeleteProject = this.DeleteProject.bind(this);
      this.UpdateProject = this.UpdateProject.bind(this);
      this.StartProjectBroadcast = this.StartProjectBroadcast.bind(this);
      this.StopProjectBroadcast = this.StopProjectBroadcast.bind(this);
      this.StartProjectWebRtc = this.StartProjectWebRtc.bind(this);
      this.StopProjectWebRtc = this.StopProjectWebRtc.bind(this);
      this.GetProjectBroadcastSnapshot = this.GetProjectBroadcastSnapshot.bind(this);
      this.GetProjectBroadcastStatus = this.GetProjectBroadcastStatus.bind(this);
    }
    CreateProject(request3) {
      const data2 = exports2.CreateProjectRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "CreateProject", data2);
      return promise.then((data3) => exports2.CreateProjectResponse.decode(new _m02.Reader(data3)));
    }
    GetProject(request3) {
      const data2 = exports2.GetProjectRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "GetProject", data2);
      return promise.then((data3) => exports2.GetProjectResponse.decode(new _m02.Reader(data3)));
    }
    DeleteProject(request3) {
      const data2 = exports2.DeleteProjectRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "DeleteProject", data2);
      return promise.then((data3) => exports2.DeleteProjectResponse.decode(new _m02.Reader(data3)));
    }
    UpdateProject(request3) {
      const data2 = exports2.UpdateProjectRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "UpdateProject", data2);
      return promise.then((data3) => exports2.UpdateProjectResponse.decode(new _m02.Reader(data3)));
    }
    StartProjectBroadcast(request3) {
      const data2 = exports2.StartProjectBroadcastRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "StartProjectBroadcast", data2);
      return promise.then((data3) => exports2.StartProjectBroadcastResponse.decode(new _m02.Reader(data3)));
    }
    StopProjectBroadcast(request3) {
      const data2 = exports2.StopProjectBroadcastRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "StopProjectBroadcast", data2);
      return promise.then((data3) => exports2.StopProjectBroadcastResponse.decode(new _m02.Reader(data3)));
    }
    StartProjectWebRtc(request3) {
      const data2 = exports2.StartProjectWebRtcRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "StartProjectWebRtc", data2);
      return promise.then((data3) => exports2.StartProjectWebRtcResponse.decode(new _m02.Reader(data3)));
    }
    StopProjectWebRtc(request3) {
      const data2 = exports2.StopProjectWebRtcRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "StopProjectWebRtc", data2);
      return promise.then((data3) => exports2.StopProjectWebRtcResponse.decode(new _m02.Reader(data3)));
    }
    GetProjectBroadcastSnapshot(request3) {
      const data2 = exports2.GetProjectBroadcastSnapshotRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "GetProjectBroadcastSnapshot", data2);
      return promise.then((data3) => exports2.GetProjectBroadcastSnapshotResponse.decode(new _m02.Reader(data3)));
    }
    GetProjectBroadcastStatus(request3) {
      const data2 = exports2.GetProjectBroadcastStatusRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "GetProjectBroadcastStatus", data2);
      return promise.then((data3) => exports2.GetProjectBroadcastStatusResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.ProjectServiceClientImpl = ProjectServiceClientImpl;
  exports2.ProjectServiceDefinition = { name: "ProjectService", fullName: "live.v21.ProjectService", methods: { createProject: { name: "CreateProject", requestType: exports2.CreateProjectRequest, requestStream: false, responseType: exports2.CreateProjectResponse, responseStream: false, options: {} }, getProject: { name: "GetProject", requestType: exports2.GetProjectRequest, requestStream: false, responseType: exports2.GetProjectResponse, responseStream: false, options: {} }, deleteProject: { name: "DeleteProject", requestType: exports2.DeleteProjectRequest, requestStream: false, responseType: exports2.DeleteProjectResponse, responseStream: false, options: {} }, updateProject: { name: "UpdateProject", requestType: exports2.UpdateProjectRequest, requestStream: false, responseType: exports2.UpdateProjectResponse, responseStream: false, options: {} }, startProjectBroadcast: { name: "StartProjectBroadcast", requestType: exports2.StartProjectBroadcastRequest, requestStream: false, responseType: exports2.StartProjectBroadcastResponse, responseStream: false, options: {} }, stopProjectBroadcast: { name: "StopProjectBroadcast", requestType: exports2.StopProjectBroadcastRequest, requestStream: false, responseType: exports2.StopProjectBroadcastResponse, responseStream: false, options: {} }, startProjectWebRtc: { name: "StartProjectWebRtc", requestType: exports2.StartProjectWebRtcRequest, requestStream: false, responseType: exports2.StartProjectWebRtcResponse, responseStream: false, options: {} }, stopProjectWebRtc: { name: "StopProjectWebRtc", requestType: exports2.StopProjectWebRtcRequest, requestStream: false, responseType: exports2.StopProjectWebRtcResponse, responseStream: false, options: {} }, getProjectBroadcastSnapshot: { name: "GetProjectBroadcastSnapshot", requestType: exports2.GetProjectBroadcastSnapshotRequest, requestStream: false, responseType: exports2.GetProjectBroadcastSnapshotResponse, responseStream: false, options: {} }, getProjectBroadcastStatus: { name: "GetProjectBroadcastStatus", requestType: exports2.GetProjectBroadcastStatusRequest, requestStream: false, responseType: exports2.GetProjectBroadcastStatusResponse, responseStream: false, options: {} } } };
  class DestinationServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.CreateDestination = this.CreateDestination.bind(this);
      this.GetDestination = this.GetDestination.bind(this);
      this.UpdateDestination = this.UpdateDestination.bind(this);
      this.DeleteDestination = this.DeleteDestination.bind(this);
    }
    CreateDestination(request3) {
      const data2 = exports2.CreateDestinationRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.DestinationService", "CreateDestination", data2);
      return promise.then((data3) => exports2.CreateDestinationResponse.decode(new _m02.Reader(data3)));
    }
    GetDestination(request3) {
      const data2 = exports2.GetDestinationRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.DestinationService", "GetDestination", data2);
      return promise.then((data3) => exports2.GetDestinationResponse.decode(new _m02.Reader(data3)));
    }
    UpdateDestination(request3) {
      const data2 = exports2.UpdateDestinationRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.DestinationService", "UpdateDestination", data2);
      return promise.then((data3) => exports2.UpdateDestinationResponse.decode(new _m02.Reader(data3)));
    }
    DeleteDestination(request3) {
      const data2 = exports2.DeleteDestinationRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.DestinationService", "DeleteDestination", data2);
      return promise.then((data3) => exports2.DeleteDestinationResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.DestinationServiceClientImpl = DestinationServiceClientImpl;
  exports2.DestinationServiceDefinition = { name: "DestinationService", fullName: "live.v21.DestinationService", methods: { createDestination: { name: "CreateDestination", requestType: exports2.CreateDestinationRequest, requestStream: false, responseType: exports2.CreateDestinationResponse, responseStream: false, options: {} }, getDestination: { name: "GetDestination", requestType: exports2.GetDestinationRequest, requestStream: false, responseType: exports2.GetDestinationResponse, responseStream: false, options: {} }, updateDestination: { name: "UpdateDestination", requestType: exports2.UpdateDestinationRequest, requestStream: false, responseType: exports2.UpdateDestinationResponse, responseStream: false, options: {} }, deleteDestination: { name: "DeleteDestination", requestType: exports2.DeleteDestinationRequest, requestStream: false, responseType: exports2.DeleteDestinationResponse, responseStream: false, options: {} } } };
  class SourceServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.CreateSource = this.CreateSource.bind(this);
      this.DeleteSource = this.DeleteSource.bind(this);
      this.UpdateSource = this.UpdateSource.bind(this);
      this.UpdateSourceInProject = this.UpdateSourceInProject.bind(this);
      this.GetSource = this.GetSource.bind(this);
      this.GetSources = this.GetSources.bind(this);
      this.AddSourceToProject = this.AddSourceToProject.bind(this);
      this.RemoveSourceFromProject = this.RemoveSourceFromProject.bind(this);
    }
    CreateSource(request3) {
      const data2 = exports2.CreateSourceRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.SourceService", "CreateSource", data2);
      return promise.then((data3) => exports2.CreateSourceResponse.decode(new _m02.Reader(data3)));
    }
    DeleteSource(request3) {
      const data2 = exports2.DeleteSourceRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.SourceService", "DeleteSource", data2);
      return promise.then((data3) => exports2.DeleteSourceResponse.decode(new _m02.Reader(data3)));
    }
    UpdateSource(request3) {
      const data2 = exports2.UpdateSourceRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.SourceService", "UpdateSource", data2);
      return promise.then((data3) => exports2.UpdateSourceResponse.decode(new _m02.Reader(data3)));
    }
    UpdateSourceInProject(request3) {
      const data2 = exports2.UpdateSourceInProjectRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.SourceService", "UpdateSourceInProject", data2);
      return promise.then((data3) => exports2.UpdateSourceInProjectResponse.decode(new _m02.Reader(data3)));
    }
    GetSource(request3) {
      const data2 = exports2.GetSourceRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.SourceService", "GetSource", data2);
      return promise.then((data3) => exports2.GetSourceResponse.decode(new _m02.Reader(data3)));
    }
    GetSources(request3) {
      const data2 = exports2.GetSourcesRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.SourceService", "GetSources", data2);
      return promise.then((data3) => exports2.GetSourcesResponse.decode(new _m02.Reader(data3)));
    }
    AddSourceToProject(request3) {
      const data2 = exports2.AddSourceToProjectRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.SourceService", "AddSourceToProject", data2);
      return promise.then((data3) => exports2.AddSourceToProjectResponse.decode(new _m02.Reader(data3)));
    }
    RemoveSourceFromProject(request3) {
      const data2 = exports2.RemoveSourceFromProjectRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.SourceService", "RemoveSourceFromProject", data2);
      return promise.then((data3) => exports2.RemoveSourceFromProjectResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.SourceServiceClientImpl = SourceServiceClientImpl;
  exports2.SourceServiceDefinition = { name: "SourceService", fullName: "live.v21.SourceService", methods: { createSource: { name: "CreateSource", requestType: exports2.CreateSourceRequest, requestStream: false, responseType: exports2.CreateSourceResponse, responseStream: false, options: {} }, deleteSource: { name: "DeleteSource", requestType: exports2.DeleteSourceRequest, requestStream: false, responseType: exports2.DeleteSourceResponse, responseStream: false, options: {} }, updateSource: { name: "UpdateSource", requestType: exports2.UpdateSourceRequest, requestStream: false, responseType: exports2.UpdateSourceResponse, responseStream: false, options: {} }, updateSourceInProject: { name: "UpdateSourceInProject", requestType: exports2.UpdateSourceInProjectRequest, requestStream: false, responseType: exports2.UpdateSourceInProjectResponse, responseStream: false, options: {} }, getSource: { name: "GetSource", requestType: exports2.GetSourceRequest, requestStream: false, responseType: exports2.GetSourceResponse, responseStream: false, options: {} }, getSources: { name: "GetSources", requestType: exports2.GetSourcesRequest, requestStream: false, responseType: exports2.GetSourcesResponse, responseStream: false, options: {} }, addSourceToProject: { name: "AddSourceToProject", requestType: exports2.AddSourceToProjectRequest, requestStream: false, responseType: exports2.AddSourceToProjectResponse, responseStream: false, options: {} }, removeSourceFromProject: { name: "RemoveSourceFromProject", requestType: exports2.RemoveSourceFromProjectRequest, requestStream: false, responseType: exports2.RemoveSourceFromProjectResponse, responseStream: false, options: {} } } };
  class BackendAuthenticationServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.CreateAccessToken = this.CreateAccessToken.bind(this);
    }
    CreateAccessToken(request3) {
      const data2 = exports2.CreateAccessTokenRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.BackendAuthenticationService", "CreateAccessToken", data2);
      return promise.then((data3) => exports2.CreateAccessTokenResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.BackendAuthenticationServiceClientImpl = BackendAuthenticationServiceClientImpl;
  exports2.BackendAuthenticationServiceDefinition = { name: "BackendAuthenticationService", fullName: "live.v21.BackendAuthenticationService", methods: { createAccessToken: { name: "CreateAccessToken", requestType: exports2.CreateAccessTokenRequest, requestStream: false, responseType: exports2.CreateAccessTokenResponse, responseStream: false, options: {} } } };
  class AuthenticationServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.CreateGuestAccessToken = this.CreateGuestAccessToken.bind(this);
      this.RefreshAccessToken = this.RefreshAccessToken.bind(this);
      this.CreateWebRtcAccessToken = this.CreateWebRtcAccessToken.bind(this);
    }
    CreateGuestAccessToken(request3) {
      const data2 = exports2.CreateGuestAccessTokenRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.AuthenticationService", "CreateGuestAccessToken", data2);
      return promise.then((data3) => exports2.CreateGuestAccessTokenResponse.decode(new _m02.Reader(data3)));
    }
    RefreshAccessToken(request3) {
      const data2 = exports2.RefreshAccessTokenRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.AuthenticationService", "RefreshAccessToken", data2);
      return promise.then((data3) => exports2.RefreshAccessTokenResponse.decode(new _m02.Reader(data3)));
    }
    CreateWebRtcAccessToken(request3) {
      const data2 = exports2.CreateWebRtcAccessTokenRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.AuthenticationService", "CreateWebRtcAccessToken", data2);
      return promise.then((data3) => exports2.CreateWebRtcAccessTokenResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.AuthenticationServiceClientImpl = AuthenticationServiceClientImpl;
  exports2.AuthenticationServiceDefinition = { name: "AuthenticationService", fullName: "live.v21.AuthenticationService", methods: { createGuestAccessToken: { name: "CreateGuestAccessToken", requestType: exports2.CreateGuestAccessTokenRequest, requestStream: false, responseType: exports2.CreateGuestAccessTokenResponse, responseStream: false, options: {} }, refreshAccessToken: { name: "RefreshAccessToken", requestType: exports2.RefreshAccessTokenRequest, requestStream: false, responseType: exports2.RefreshAccessTokenResponse, responseStream: false, options: {} }, createWebRtcAccessToken: { name: "CreateWebRtcAccessToken", requestType: exports2.CreateWebRtcAccessTokenRequest, requestStream: false, responseType: exports2.CreateWebRtcAccessTokenResponse, responseStream: false, options: {} } } };
  class PublicAuthenticationServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.GetJsonWebKeySet = this.GetJsonWebKeySet.bind(this);
      this.GuestCodeRedirect = this.GuestCodeRedirect.bind(this);
    }
    GetJsonWebKeySet(request3) {
      const data2 = exports2.GetJsonWebKeySetRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.PublicAuthenticationService", "GetJsonWebKeySet", data2);
      return promise.then((data3) => exports2.GetJsonWebKeySetResponse.decode(new _m02.Reader(data3)));
    }
    GuestCodeRedirect(request3) {
      const data2 = exports2.GuestCodeRedirectRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.PublicAuthenticationService", "GuestCodeRedirect", data2);
      return promise.then((data3) => exports2.GuestCodeRedirectResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.PublicAuthenticationServiceClientImpl = PublicAuthenticationServiceClientImpl;
  exports2.PublicAuthenticationServiceDefinition = { name: "PublicAuthenticationService", fullName: "live.v21.PublicAuthenticationService", methods: { getJsonWebKeySet: { name: "GetJsonWebKeySet", requestType: exports2.GetJsonWebKeySetRequest, requestStream: false, responseType: exports2.GetJsonWebKeySetResponse, responseStream: false, options: {} }, guestCodeRedirect: { name: "GuestCodeRedirect", requestType: exports2.GuestCodeRedirectRequest, requestStream: false, responseType: exports2.GuestCodeRedirectResponse, responseStream: false, options: {} } } };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal !== "undefined")
      return commonjsGlobal;
    throw "Unable to locate global object";
  })();
  const atob2 = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
  function bytesFromBase64(b64) {
    const bin = atob2(b64);
    const arr = new Uint8Array(bin.length);
    for (let i2 = 0; i2 < bin.length; ++i2) {
      arr[i2] = bin.charCodeAt(i2);
    }
    return arr;
  }
  const btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
  function base64FromBytes(arr) {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return btoa2(bin.join(""));
  }
  function toTimestamp(dateStr) {
    const date = new Date(dateStr);
    const seconds = date.getTime() / 1e3;
    const nanos = date.getTime() % 1e3 * 1e6;
    return { seconds, nanos };
  }
  function fromTimestamp(t2) {
    let millis = t2.seconds * 1e3;
    millis += t2.nanos / 1e6;
    return new Date(millis).toISOString();
  }
  if (_m02.util.Long !== long_12.default) {
    _m02.util.Long = long_12.default;
    _m02.configure();
  }
  function isSet2(value) {
    return value !== null && value !== void 0;
  }
})(api$1);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __decorate2 = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d = decorators[i2])
          r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
    return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __metadata2 = commonjsGlobal && commonjsGlobal.__metadata || function(k, v2) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(k, v2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.LiveApi = void 0;
  const NiceGrpc2 = __importStar2(lib$1);
  const api_12 = api$2;
  const LiveApiModel = __importStar2(api$1);
  const decorator_12 = decorator;
  const LOG_CATEGORY2 = "LiveApi";
  class LiveApi extends api_12.ApiClient {
    constructor(sessionId, eventApi, server, onAccessTokenRefresh, apiKey, sdkVersion, apiLogCallback) {
      super(sessionId, server, sdkVersion, LOG_CATEGORY2, apiLogCallback);
      this.handlers = {};
      this.eventApi = eventApi;
      this.accessTokenRefreshCallback = onAccessTokenRefresh;
      this.publicAuthentication = this.clientFactory.create(LiveApiModel.PublicAuthenticationServiceDefinition, this.channel);
      if (apiKey != void 0) {
        this.backendAuthentication = this.clientFactory.create(LiveApiModel.BackendAuthenticationServiceDefinition, this.channel, { "*": { metadata: NiceGrpc2.Metadata({ "X-Api-Key": apiKey }) } });
      }
      this.eventApi.on("event", { name: `${LiveApi.LIVEAPI_EVENT_PREFIX}:*`, ignoreSessionEvents: true, allowedSessionEvents: [`${LiveApi.LIVEAPI_EVENT_PREFIX}:EVENT_TYPE_PROJECT:EVENT_SUB_TYPE_STATE`] }, this.eventCallback.bind(this));
    }
    on(type, handler) {
      var _a2;
      this.handlers[type] = (_a2 = this.handlers[type]) !== null && _a2 !== void 0 ? _a2 : [];
      this.handlers[type].push(handler);
    }
    off(type, handler) {
      this.handlers[type] = this.handlers[type].filter((i2) => i2 !== handler);
    }
    emitToHandlers(name2, subType, payload) {
      var _a2;
      for (const handler of (_a2 = this.handlers[name2]) !== null && _a2 !== void 0 ? _a2 : []) {
        handler(Object.values(payload).find((i2) => !!i2), subType);
      }
    }
    async subscribeToCollection(collectionId) {
      await this.eventApi.subscribe(`${LiveApi.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId } });
    }
    async unsubscribeFromCollection(collectionId) {
      await this.eventApi.unsubscribe(`${LiveApi.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId } });
    }
    async subscribeToProject(collectionId, projectId) {
      await this.eventApi.subscribe(`${LiveApi.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId, projectId } });
    }
    async unsubscribeFromProject(collectionId, projectId) {
      await this.eventApi.unsubscribe(`${LiveApi.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId, projectId } });
    }
    eventCallback(event2) {
      let typeAndSubType = event2.name.split(`${LiveApi.LIVEAPI_EVENT_PREFIX}:`)[1];
      let parts = typeAndSubType.split(":");
      let eventType = LiveApiModel.eventTypeFromJSON(parts[0]);
      let eventSubType = LiveApiModel.eventSubTypeFromJSON(parts[1]);
      this.log.info("processing event: " + eventType + "/" + eventSubType);
      if (LiveApi.liveApiEventMap[eventType]) {
        this.emitToHandlers(eventType, eventSubType, event2.payload);
      }
    }
    _setup(options2) {
      let self2 = this;
      options2.onHeader = function(header) {
        let jwtHeader = header.get("Authorization");
        if (jwtHeader != null) {
          const headerParts = jwtHeader.split(" ");
          if (headerParts.length == 2 && headerParts[0] == "Bearer") {
            let accessToken = headerParts[1];
            self2.log.info("received refresh token");
            self2.accessTokenRefreshCallback(accessToken);
          }
        }
      };
      this.collection = this.clientFactory.create(LiveApiModel.CollectionServiceDefinition, this.channel, { "*": options2 });
      this.project = this.clientFactory.create(LiveApiModel.ProjectServiceDefinition, this.channel, { "*": options2 });
      this.source = this.clientFactory.create(LiveApiModel.SourceServiceDefinition, this.channel, { "*": options2 });
      this.destination = this.clientFactory.create(LiveApiModel.DestinationServiceDefinition, this.channel, { "*": options2 });
      this.authentication = this.clientFactory.create(LiveApiModel.AuthenticationServiceDefinition, this.channel, { "*": options2 });
    }
  }
  LiveApi.LIVEAPI_EVENT_PREFIX = "apistream:live";
  __decorate2([(0, decorator_12.RequiresSdkAuthentication)(), __metadata2("design:type", Object)], LiveApi.prototype, "collection", void 0);
  __decorate2([(0, decorator_12.RequiresSdkAuthentication)(), __metadata2("design:type", Object)], LiveApi.prototype, "project", void 0);
  __decorate2([(0, decorator_12.RequiresSdkAuthentication)(), __metadata2("design:type", Object)], LiveApi.prototype, "source", void 0);
  __decorate2([(0, decorator_12.RequiresSdkAuthentication)(), __metadata2("design:type", Object)], LiveApi.prototype, "destination", void 0);
  __decorate2([(0, decorator_12.RequiresSdkAuthentication)(), __metadata2("design:type", Object)], LiveApi.prototype, "authentication", void 0);
  exports2.LiveApi = LiveApi;
  (function(LiveApi2) {
    LiveApi2.liveApiEventMap = { [LiveApiModel.EventType.EVENT_TYPE_COLLECTION]: "collection", [LiveApiModel.EventType.EVENT_TYPE_PROJECT]: "project", [LiveApiModel.EventType.EVENT_TYPE_SOURCE]: "source", [LiveApiModel.EventType.EVENT_TYPE_DESTINATION]: "destination", [LiveApiModel.EventType.EVENT_TYPE_UNSPECIFIED]: "unspecified" };
  })(LiveApi = exports2.LiveApi || (exports2.LiveApi = {}));
})(liveapi);
var eventapi = {};
var dist$2 = {};
var api = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p2 in b2)
      if (b2.hasOwnProperty(p2))
        d2[p2] = b2[p2];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function isFunction$1(x2) {
  return typeof x2 === "function";
}
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config$2 = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(value) {
  if (value) {
    var error = /* @__PURE__ */ new Error();
    /* @__PURE__ */ console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
  }
  _enable_super_gross_mode_that_will_cause_bad_things = value;
}, get useDeprecatedSynchronousErrorHandling() {
  return _enable_super_gross_mode_that_will_cause_bad_things;
} };
function hostReportError(err) {
  setTimeout(function() {
    throw err;
  }, 0);
}
var empty$2 = { closed: true, next: function(value) {
}, error: function(err) {
  if (config$2.useDeprecatedSynchronousErrorHandling) {
    throw err;
  } else {
    hostReportError(err);
  }
}, complete: function() {
} };
var isArray$2 = /* @__PURE__ */ function() {
  return Array.isArray || function(x2) {
    return x2 && typeof x2.length === "number";
  };
}();
function isObject$4(x2) {
  return x2 !== null && typeof x2 === "object";
}
var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
  function UnsubscriptionErrorImpl2(errors2) {
    Error.call(this);
    this.message = errors2 ? errors2.length + " errors occurred during unsubscription:\n" + errors2.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors2;
    return this;
  }
  UnsubscriptionErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return UnsubscriptionErrorImpl2;
}();
var UnsubscriptionError = UnsubscriptionErrorImpl;
var Subscription = /* @__PURE__ */ function() {
  function Subscription2(unsubscribe) {
    this.closed = false;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (unsubscribe) {
      this._ctorUnsubscribe = true;
      this._unsubscribe = unsubscribe;
    }
  }
  Subscription2.prototype.unsubscribe = function() {
    var errors2;
    if (this.closed) {
      return;
    }
    var _a2 = this, _parentOrParents = _a2._parentOrParents, _ctorUnsubscribe = _a2._ctorUnsubscribe, _unsubscribe = _a2._unsubscribe, _subscriptions = _a2._subscriptions;
    this.closed = true;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (_parentOrParents instanceof Subscription2) {
      _parentOrParents.remove(this);
    } else if (_parentOrParents !== null) {
      for (var index2 = 0; index2 < _parentOrParents.length; ++index2) {
        var parent_1 = _parentOrParents[index2];
        parent_1.remove(this);
      }
    }
    if (isFunction$1(_unsubscribe)) {
      if (_ctorUnsubscribe) {
        this._unsubscribe = void 0;
      }
      try {
        _unsubscribe.call(this);
      } catch (e2) {
        errors2 = e2 instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e2.errors) : [e2];
      }
    }
    if (isArray$2(_subscriptions)) {
      var index2 = -1;
      var len = _subscriptions.length;
      while (++index2 < len) {
        var sub = _subscriptions[index2];
        if (isObject$4(sub)) {
          try {
            sub.unsubscribe();
          } catch (e2) {
            errors2 = errors2 || [];
            if (e2 instanceof UnsubscriptionError) {
              errors2 = errors2.concat(flattenUnsubscriptionErrors(e2.errors));
            } else {
              errors2.push(e2);
            }
          }
        }
      }
    }
    if (errors2) {
      throw new UnsubscriptionError(errors2);
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var subscription = teardown;
    if (!teardown) {
      return Subscription2.EMPTY;
    }
    switch (typeof teardown) {
      case "function":
        subscription = new Subscription2(teardown);
      case "object":
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
          return subscription;
        } else if (this.closed) {
          subscription.unsubscribe();
          return subscription;
        } else if (!(subscription instanceof Subscription2)) {
          var tmp = subscription;
          subscription = new Subscription2();
          subscription._subscriptions = [tmp];
        }
        break;
      default: {
        throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
      }
    }
    var _parentOrParents = subscription._parentOrParents;
    if (_parentOrParents === null) {
      subscription._parentOrParents = this;
    } else if (_parentOrParents instanceof Subscription2) {
      if (_parentOrParents === this) {
        return subscription;
      }
      subscription._parentOrParents = [_parentOrParents, this];
    } else if (_parentOrParents.indexOf(this) === -1) {
      _parentOrParents.push(this);
    } else {
      return subscription;
    }
    var subscriptions = this._subscriptions;
    if (subscriptions === null) {
      this._subscriptions = [subscription];
    } else {
      subscriptions.push(subscription);
    }
    return subscription;
  };
  Subscription2.prototype.remove = function(subscription) {
    var subscriptions = this._subscriptions;
    if (subscriptions) {
      var subscriptionIndex = subscriptions.indexOf(subscription);
      if (subscriptionIndex !== -1) {
        subscriptions.splice(subscriptionIndex, 1);
      }
    }
  };
  Subscription2.EMPTY = function(empty2) {
    empty2.closed = true;
    return empty2;
  }(new Subscription2());
  return Subscription2;
}();
function flattenUnsubscriptionErrors(errors2) {
  return errors2.reduce(function(errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}
var rxSubscriber = /* @__PURE__ */ function() {
  return typeof Symbol === "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
}();
var Subscriber = /* @__PURE__ */ function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destinationOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this.syncErrorValue = null;
    _this.syncErrorThrown = false;
    _this.syncErrorThrowable = false;
    _this.isStopped = false;
    switch (arguments.length) {
      case 0:
        _this.destination = empty$2;
        break;
      case 1:
        if (!destinationOrNext) {
          _this.destination = empty$2;
          break;
        }
        if (typeof destinationOrNext === "object") {
          if (destinationOrNext instanceof Subscriber2) {
            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
            _this.destination = destinationOrNext;
            destinationOrNext.add(_this);
          } else {
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext);
          }
          break;
        }
      default:
        _this.syncErrorThrowable = true;
        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
        break;
    }
    return _this;
  }
  Subscriber2.prototype[rxSubscriber] = function() {
    return this;
  };
  Subscriber2.create = function(next, error, complete) {
    var subscriber = new Subscriber2(next, error, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
  };
  Subscriber2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.isStopped = true;
    _super.prototype.unsubscribe.call(this);
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    this.destination.error(err);
    this.unsubscribe();
  };
  Subscriber2.prototype._complete = function() {
    this.destination.complete();
    this.unsubscribe();
  };
  Subscriber2.prototype._unsubscribeAndRecycle = function() {
    var _parentOrParents = this._parentOrParents;
    this._parentOrParents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parentOrParents = _parentOrParents;
    return this;
  };
  return Subscriber2;
}(Subscription);
var SafeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this._parentSubscriber = _parentSubscriber;
    var next;
    var context2 = _this;
    if (isFunction$1(observerOrNext)) {
      next = observerOrNext;
    } else if (observerOrNext) {
      next = observerOrNext.next;
      error = observerOrNext.error;
      complete = observerOrNext.complete;
      if (observerOrNext !== empty$2) {
        context2 = Object.create(observerOrNext);
        if (isFunction$1(context2.unsubscribe)) {
          _this.add(context2.unsubscribe.bind(context2));
        }
        context2.unsubscribe = _this.unsubscribe.bind(_this);
      }
    }
    _this._context = context2;
    _this._next = next;
    _this._error = error;
    _this._complete = complete;
    return _this;
  }
  SafeSubscriber2.prototype.next = function(value) {
    if (!this.isStopped && this._next) {
      var _parentSubscriber = this._parentSubscriber;
      if (!config$2.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
        this.__tryOrUnsub(this._next, value);
      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      var useDeprecatedSynchronousErrorHandling = config$2.useDeprecatedSynchronousErrorHandling;
      if (this._error) {
        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._error, err);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, this._error, err);
          this.unsubscribe();
        }
      } else if (!_parentSubscriber.syncErrorThrowable) {
        this.unsubscribe();
        if (useDeprecatedSynchronousErrorHandling) {
          throw err;
        }
        hostReportError(err);
      } else {
        if (useDeprecatedSynchronousErrorHandling) {
          _parentSubscriber.syncErrorValue = err;
          _parentSubscriber.syncErrorThrown = true;
        } else {
          hostReportError(err);
        }
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.complete = function() {
    var _this = this;
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      if (this._complete) {
        var wrappedComplete = function() {
          return _this._complete.call(_this._context);
        };
        if (!config$2.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(wrappedComplete);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, wrappedComplete);
          this.unsubscribe();
        }
      } else {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrUnsub = function(fn, value) {
    try {
      fn.call(this._context, value);
    } catch (err) {
      this.unsubscribe();
      if (config$2.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        hostReportError(err);
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrSetError = function(parent2, fn, value) {
    if (!config$2.useDeprecatedSynchronousErrorHandling) {
      throw new Error("bad call");
    }
    try {
      fn.call(this._context, value);
    } catch (err) {
      if (config$2.useDeprecatedSynchronousErrorHandling) {
        parent2.syncErrorValue = err;
        parent2.syncErrorThrown = true;
        return true;
      } else {
        hostReportError(err);
        return true;
      }
    }
    return false;
  };
  SafeSubscriber2.prototype._unsubscribe = function() {
    var _parentSubscriber = this._parentSubscriber;
    this._context = null;
    this._parentSubscriber = null;
    _parentSubscriber.unsubscribe();
  };
  return SafeSubscriber2;
}(Subscriber);
function canReportError(observer) {
  while (observer) {
    var _a2 = observer, closed_1 = _a2.closed, destination = _a2.destination, isStopped = _a2.isStopped;
    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }
  return true;
}
function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber) {
      return nextOrObserver;
    }
    if (nextOrObserver[rxSubscriber]) {
      return nextOrObserver[rxSubscriber]();
    }
  }
  if (!nextOrObserver && !error && !complete) {
    return new Subscriber(empty$2);
  }
  return new Subscriber(nextOrObserver, error, complete);
}
var observable = /* @__PURE__ */ function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x2) {
  return x2;
}
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = /* @__PURE__ */ function() {
  function Observable2(subscribe2) {
    this._isScalar = false;
    if (subscribe2) {
      this._subscribe = subscribe2;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var operator = this.operator;
    var sink = toSubscriber(observerOrNext, error, complete);
    if (operator) {
      sink.add(operator.call(sink, this.source));
    } else {
      sink.add(this.source || config$2.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
    }
    if (config$2.useDeprecatedSynchronousErrorHandling) {
      if (sink.syncErrorThrowable) {
        sink.syncErrorThrowable = false;
        if (sink.syncErrorThrown) {
          throw sink.syncErrorValue;
        }
      }
    }
    return sink;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      if (config$2.useDeprecatedSynchronousErrorHandling) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
      }
      if (canReportError(sink)) {
        sink.error(err);
      } else {
        console.warn(err);
      }
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscription;
      subscription = _this.subscribe(function(value) {
        try {
          next(value);
        } catch (err) {
          reject(err);
          if (subscription) {
            subscription.unsubscribe();
          }
        }
      }, reject, resolve);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var source2 = this.source;
    return source2 && source2.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    if (operations.length === 0) {
      return this;
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe2) {
    return new Observable2(subscribe2);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = Promise;
  }
  if (!promiseCtor) {
    throw new Error("no Promise impl found");
  }
  return promiseCtor;
}
var subscribeToArray = function(array) {
  return function(subscriber) {
    for (var i2 = 0, len = array.length; i2 < len && !subscriber.closed; i2++) {
      subscriber.next(array[i2]);
    }
    subscriber.complete();
  };
};
var subscribeToPromise = function(promise) {
  return function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, hostReportError);
    return subscriber;
  };
};
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = /* @__PURE__ */ getSymbolIterator();
var subscribeToIterable = function(iterable) {
  return function(subscriber) {
    var iterator$1 = iterable[iterator]();
    do {
      var item = void 0;
      try {
        item = iterator$1.next();
      } catch (err) {
        subscriber.error(err);
        return subscriber;
      }
      if (item.done) {
        subscriber.complete();
        break;
      }
      subscriber.next(item.value);
      if (subscriber.closed) {
        break;
      }
    } while (true);
    if (typeof iterator$1.return === "function") {
      subscriber.add(function() {
        if (iterator$1.return) {
          iterator$1.return();
        }
      });
    }
    return subscriber;
  };
};
var subscribeToObservable = function(obj) {
  return function(subscriber) {
    var obs = obj[observable]();
    if (typeof obs.subscribe !== "function") {
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    } else {
      return obs.subscribe(subscriber);
    }
  };
};
var isArrayLike = function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
};
function isPromise(value) {
  return !!value && typeof value.subscribe !== "function" && typeof value.then === "function";
}
var subscribeTo = function(result) {
  if (!!result && typeof result[observable] === "function") {
    return subscribeToObservable(result);
  } else if (isArrayLike(result)) {
    return subscribeToArray(result);
  } else if (isPromise(result)) {
    return subscribeToPromise(result);
  } else if (!!result && typeof result[iterator] === "function") {
    return subscribeToIterable(result);
  } else {
    var value = isObject$4(result) ? "an invalid object" : "'" + result + "'";
    var msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
    throw new TypeError(msg);
  }
};
var SimpleInnerSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SimpleInnerSubscriber2, _super);
  function SimpleInnerSubscriber2(parent2) {
    var _this = _super.call(this) || this;
    _this.parent = parent2;
    return _this;
  }
  SimpleInnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(value);
  };
  SimpleInnerSubscriber2.prototype._error = function(error) {
    this.parent.notifyError(error);
    this.unsubscribe();
  };
  SimpleInnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete();
    this.unsubscribe();
  };
  return SimpleInnerSubscriber2;
}(Subscriber);
var SimpleOuterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SimpleOuterSubscriber2, _super);
  function SimpleOuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  SimpleOuterSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  };
  SimpleOuterSubscriber2.prototype.notifyComplete = function() {
    this.destination.complete();
  };
  return SimpleOuterSubscriber2;
}(Subscriber);
function innerSubscribe(result, innerSubscriber) {
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  var subscription;
  try {
    subscription = subscribeTo(result)(innerSubscriber);
  } catch (error) {
    innerSubscriber.error(error);
  }
  return subscription;
}
function audit(durationSelector) {
  return function auditOperatorFunction(source2) {
    return source2.lift(new AuditOperator(durationSelector));
  };
}
var AuditOperator = /* @__PURE__ */ function() {
  function AuditOperator2(durationSelector) {
    this.durationSelector = durationSelector;
  }
  AuditOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
  };
  return AuditOperator2;
}();
var AuditSubscriber = /* @__PURE__ */ function(_super) {
  __extends(AuditSubscriber2, _super);
  function AuditSubscriber2(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.durationSelector = durationSelector;
    _this.hasValue = false;
    return _this;
  }
  AuditSubscriber2.prototype._next = function(value) {
    this.value = value;
    this.hasValue = true;
    if (!this.throttled) {
      var duration = void 0;
      try {
        var durationSelector = this.durationSelector;
        duration = durationSelector(value);
      } catch (err) {
        return this.destination.error(err);
      }
      var innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
      if (!innerSubscription || innerSubscription.closed) {
        this.clearThrottle();
      } else {
        this.add(this.throttled = innerSubscription);
      }
    }
  };
  AuditSubscriber2.prototype.clearThrottle = function() {
    var _a2 = this, value = _a2.value, hasValue = _a2.hasValue, throttled = _a2.throttled;
    if (throttled) {
      this.remove(throttled);
      this.throttled = void 0;
      throttled.unsubscribe();
    }
    if (hasValue) {
      this.value = void 0;
      this.hasValue = false;
      this.destination.next(value);
    }
  };
  AuditSubscriber2.prototype.notifyNext = function() {
    this.clearThrottle();
  };
  AuditSubscriber2.prototype.notifyComplete = function() {
    this.clearThrottle();
  };
  return AuditSubscriber2;
}(SimpleOuterSubscriber);
var Action = /* @__PURE__ */ function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler2, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state2, delay2) {
    return this;
  };
  return Action2;
}(Subscription);
var AsyncAction = /* @__PURE__ */ function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler2, work) {
    var _this = _super.call(this, scheduler2, work) || this;
    _this.scheduler = scheduler2;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state2;
    var id2 = this.id;
    var scheduler2 = this.scheduler;
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler2, id2, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = this.id || this.requestAsyncId(scheduler2, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return setInterval(scheduler2.flush.bind(scheduler2, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && this.delay === delay2 && this.pending === false) {
      return id2;
    }
    clearInterval(id2);
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state2, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state2, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state2, delay2) {
    var errored = false;
    var errorValue = void 0;
    try {
      this.work(state2);
    } catch (e2) {
      errored = true;
      errorValue = !!e2 && e2 || new Error(e2);
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype._unsubscribe = function() {
    var id2 = this.id;
    var scheduler2 = this.scheduler;
    var actions = scheduler2.actions;
    var index2 = actions.indexOf(this);
    this.work = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;
    if (index2 !== -1) {
      actions.splice(index2, 1);
    }
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler2, id2, null);
    }
    this.delay = null;
  };
  return AsyncAction2;
}(Action);
var Scheduler = /* @__PURE__ */ function() {
  function Scheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler2.now;
    }
    this.SchedulerAction = SchedulerAction;
    this.now = now2;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.SchedulerAction(this, work).schedule(state2, delay2);
  };
  Scheduler2.now = function() {
    return Date.now();
  };
  return Scheduler2;
}();
var AsyncScheduler = /* @__PURE__ */ function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, function() {
      if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
        return AsyncScheduler2.delegate.now();
      } else {
        return now2();
      }
    }) || this;
    _this.actions = [];
    _this.active = false;
    _this.scheduled = void 0;
    return _this;
  }
  AsyncScheduler2.prototype.schedule = function(work, delay2, state2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
      return AsyncScheduler2.delegate.schedule(work, delay2, state2);
    } else {
      return _super.prototype.schedule.call(this, work, delay2, state2);
    }
  };
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this.active) {
      actions.push(action);
      return;
    }
    var error;
    this.active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this.active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);
var asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction);
var async = asyncScheduler;
function isNumeric(val) {
  return !isArray$2(val) && val - parseFloat(val) + 1 >= 0;
}
function isScheduler(value) {
  return value && typeof value.schedule === "function";
}
function timer(dueTime, periodOrScheduler, scheduler2) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  var period = -1;
  if (isNumeric(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if (isScheduler(periodOrScheduler)) {
    scheduler2 = periodOrScheduler;
  }
  if (!isScheduler(scheduler2)) {
    scheduler2 = async;
  }
  return new Observable(function(subscriber) {
    var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler2.now();
    return scheduler2.schedule(dispatch$1, due, { index: 0, period, subscriber });
  });
}
function dispatch$1(state2) {
  var index2 = state2.index, period = state2.period, subscriber = state2.subscriber;
  subscriber.next(index2);
  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }
  state2.index = index2 + 1;
  this.schedule(state2, period);
}
function auditTime(duration, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  return audit(function() {
    return timer(duration, scheduler2);
  });
}
function buffer(closingNotifier) {
  return function bufferOperatorFunction(source2) {
    return source2.lift(new BufferOperator(closingNotifier));
  };
}
var BufferOperator = /* @__PURE__ */ function() {
  function BufferOperator2(closingNotifier) {
    this.closingNotifier = closingNotifier;
  }
  BufferOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
  };
  return BufferOperator2;
}();
var BufferSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferSubscriber2, _super);
  function BufferSubscriber2(destination, closingNotifier) {
    var _this = _super.call(this, destination) || this;
    _this.buffer = [];
    _this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(_this)));
    return _this;
  }
  BufferSubscriber2.prototype._next = function(value) {
    this.buffer.push(value);
  };
  BufferSubscriber2.prototype.notifyNext = function() {
    var buffer2 = this.buffer;
    this.buffer = [];
    this.destination.next(buffer2);
  };
  return BufferSubscriber2;
}(SimpleOuterSubscriber);
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  return function bufferCountOperatorFunction(source2) {
    return source2.lift(new BufferCountOperator(bufferSize, startBufferEvery));
  };
}
var BufferCountOperator = /* @__PURE__ */ function() {
  function BufferCountOperator2(bufferSize, startBufferEvery) {
    this.bufferSize = bufferSize;
    this.startBufferEvery = startBufferEvery;
    if (!startBufferEvery || bufferSize === startBufferEvery) {
      this.subscriberClass = BufferCountSubscriber;
    } else {
      this.subscriberClass = BufferSkipCountSubscriber;
    }
  }
  BufferCountOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
  };
  return BufferCountOperator2;
}();
var BufferCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferCountSubscriber2, _super);
  function BufferCountSubscriber2(destination, bufferSize) {
    var _this = _super.call(this, destination) || this;
    _this.bufferSize = bufferSize;
    _this.buffer = [];
    return _this;
  }
  BufferCountSubscriber2.prototype._next = function(value) {
    var buffer2 = this.buffer;
    buffer2.push(value);
    if (buffer2.length == this.bufferSize) {
      this.destination.next(buffer2);
      this.buffer = [];
    }
  };
  BufferCountSubscriber2.prototype._complete = function() {
    var buffer2 = this.buffer;
    if (buffer2.length > 0) {
      this.destination.next(buffer2);
    }
    _super.prototype._complete.call(this);
  };
  return BufferCountSubscriber2;
}(Subscriber);
var BufferSkipCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferSkipCountSubscriber2, _super);
  function BufferSkipCountSubscriber2(destination, bufferSize, startBufferEvery) {
    var _this = _super.call(this, destination) || this;
    _this.bufferSize = bufferSize;
    _this.startBufferEvery = startBufferEvery;
    _this.buffers = [];
    _this.count = 0;
    return _this;
  }
  BufferSkipCountSubscriber2.prototype._next = function(value) {
    var _a2 = this, bufferSize = _a2.bufferSize, startBufferEvery = _a2.startBufferEvery, buffers = _a2.buffers, count2 = _a2.count;
    this.count++;
    if (count2 % startBufferEvery === 0) {
      buffers.push([]);
    }
    for (var i2 = buffers.length; i2--; ) {
      var buffer2 = buffers[i2];
      buffer2.push(value);
      if (buffer2.length === bufferSize) {
        buffers.splice(i2, 1);
        this.destination.next(buffer2);
      }
    }
  };
  BufferSkipCountSubscriber2.prototype._complete = function() {
    var _a2 = this, buffers = _a2.buffers, destination = _a2.destination;
    while (buffers.length > 0) {
      var buffer2 = buffers.shift();
      if (buffer2.length > 0) {
        destination.next(buffer2);
      }
    }
    _super.prototype._complete.call(this);
  };
  return BufferSkipCountSubscriber2;
}(Subscriber);
function bufferTime(bufferTimeSpan) {
  var length2 = arguments.length;
  var scheduler2 = async;
  if (isScheduler(arguments[arguments.length - 1])) {
    scheduler2 = arguments[arguments.length - 1];
    length2--;
  }
  var bufferCreationInterval = null;
  if (length2 >= 2) {
    bufferCreationInterval = arguments[1];
  }
  var maxBufferSize = Number.POSITIVE_INFINITY;
  if (length2 >= 3) {
    maxBufferSize = arguments[2];
  }
  return function bufferTimeOperatorFunction(source2) {
    return source2.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler2));
  };
}
var BufferTimeOperator = /* @__PURE__ */ function() {
  function BufferTimeOperator2(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler2) {
    this.bufferTimeSpan = bufferTimeSpan;
    this.bufferCreationInterval = bufferCreationInterval;
    this.maxBufferSize = maxBufferSize;
    this.scheduler = scheduler2;
  }
  BufferTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
  };
  return BufferTimeOperator2;
}();
var Context = /* @__PURE__ */ function() {
  function Context2() {
    this.buffer = [];
  }
  return Context2;
}();
var BufferTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferTimeSubscriber2, _super);
  function BufferTimeSubscriber2(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler2) {
    var _this = _super.call(this, destination) || this;
    _this.bufferTimeSpan = bufferTimeSpan;
    _this.bufferCreationInterval = bufferCreationInterval;
    _this.maxBufferSize = maxBufferSize;
    _this.scheduler = scheduler2;
    _this.contexts = [];
    var context2 = _this.openContext();
    _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
    if (_this.timespanOnly) {
      var timeSpanOnlyState = { subscriber: _this, context: context2, bufferTimeSpan };
      _this.add(context2.closeAction = scheduler2.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    } else {
      var closeState = { subscriber: _this, context: context2 };
      var creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: _this, scheduler: scheduler2 };
      _this.add(context2.closeAction = scheduler2.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
      _this.add(scheduler2.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
    }
    return _this;
  }
  BufferTimeSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    var len = contexts.length;
    var filledBufferContext;
    for (var i2 = 0; i2 < len; i2++) {
      var context_1 = contexts[i2];
      var buffer2 = context_1.buffer;
      buffer2.push(value);
      if (buffer2.length == this.maxBufferSize) {
        filledBufferContext = context_1;
      }
    }
    if (filledBufferContext) {
      this.onBufferFull(filledBufferContext);
    }
  };
  BufferTimeSubscriber2.prototype._error = function(err) {
    this.contexts.length = 0;
    _super.prototype._error.call(this, err);
  };
  BufferTimeSubscriber2.prototype._complete = function() {
    var _a2 = this, contexts = _a2.contexts, destination = _a2.destination;
    while (contexts.length > 0) {
      var context_2 = contexts.shift();
      destination.next(context_2.buffer);
    }
    _super.prototype._complete.call(this);
  };
  BufferTimeSubscriber2.prototype._unsubscribe = function() {
    this.contexts = null;
  };
  BufferTimeSubscriber2.prototype.onBufferFull = function(context2) {
    this.closeContext(context2);
    var closeAction = context2.closeAction;
    closeAction.unsubscribe();
    this.remove(closeAction);
    if (!this.closed && this.timespanOnly) {
      context2 = this.openContext();
      var bufferTimeSpan = this.bufferTimeSpan;
      var timeSpanOnlyState = { subscriber: this, context: context2, bufferTimeSpan };
      this.add(context2.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    }
  };
  BufferTimeSubscriber2.prototype.openContext = function() {
    var context2 = new Context();
    this.contexts.push(context2);
    return context2;
  };
  BufferTimeSubscriber2.prototype.closeContext = function(context2) {
    this.destination.next(context2.buffer);
    var contexts = this.contexts;
    var spliceIndex = contexts ? contexts.indexOf(context2) : -1;
    if (spliceIndex >= 0) {
      contexts.splice(contexts.indexOf(context2), 1);
    }
  };
  return BufferTimeSubscriber2;
}(Subscriber);
function dispatchBufferTimeSpanOnly(state2) {
  var subscriber = state2.subscriber;
  var prevContext = state2.context;
  if (prevContext) {
    subscriber.closeContext(prevContext);
  }
  if (!subscriber.closed) {
    state2.context = subscriber.openContext();
    state2.context.closeAction = this.schedule(state2, state2.bufferTimeSpan);
  }
}
function dispatchBufferCreation(state2) {
  var bufferCreationInterval = state2.bufferCreationInterval, bufferTimeSpan = state2.bufferTimeSpan, subscriber = state2.subscriber, scheduler2 = state2.scheduler;
  var context2 = subscriber.openContext();
  var action = this;
  if (!subscriber.closed) {
    subscriber.add(context2.closeAction = scheduler2.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context: context2 }));
    action.schedule(state2, bufferCreationInterval);
  }
}
function dispatchBufferClose(arg) {
  var subscriber = arg.subscriber, context2 = arg.context;
  subscriber.closeContext(context2);
}
var InnerSubscriber = /* @__PURE__ */ function(_super) {
  __extends(InnerSubscriber2, _super);
  function InnerSubscriber2(parent2, outerValue, outerIndex) {
    var _this = _super.call(this) || this;
    _this.parent = parent2;
    _this.outerValue = outerValue;
    _this.outerIndex = outerIndex;
    _this.index = 0;
    return _this;
  }
  InnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
  };
  InnerSubscriber2.prototype._error = function(error) {
    this.parent.notifyError(error, this);
    this.unsubscribe();
  };
  InnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete(this);
    this.unsubscribe();
  };
  return InnerSubscriber2;
}(Subscriber);
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
  if (innerSubscriber === void 0) {
    innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
  }
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  return subscribeTo(result)(innerSubscriber);
}
var OuterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(OuterSubscriber2, _super);
  function OuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  };
  OuterSubscriber2.prototype.notifyError = function(error, innerSub) {
    this.destination.error(error);
  };
  OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.destination.complete();
  };
  return OuterSubscriber2;
}(Subscriber);
function bufferToggle(openings, closingSelector) {
  return function bufferToggleOperatorFunction(source2) {
    return source2.lift(new BufferToggleOperator(openings, closingSelector));
  };
}
var BufferToggleOperator = /* @__PURE__ */ function() {
  function BufferToggleOperator2(openings, closingSelector) {
    this.openings = openings;
    this.closingSelector = closingSelector;
  }
  BufferToggleOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
  };
  return BufferToggleOperator2;
}();
var BufferToggleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferToggleSubscriber2, _super);
  function BufferToggleSubscriber2(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.closingSelector = closingSelector;
    _this.contexts = [];
    _this.add(subscribeToResult(_this, openings));
    return _this;
  }
  BufferToggleSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    var len = contexts.length;
    for (var i2 = 0; i2 < len; i2++) {
      contexts[i2].buffer.push(value);
    }
  };
  BufferToggleSubscriber2.prototype._error = function(err) {
    var contexts = this.contexts;
    while (contexts.length > 0) {
      var context_1 = contexts.shift();
      context_1.subscription.unsubscribe();
      context_1.buffer = null;
      context_1.subscription = null;
    }
    this.contexts = null;
    _super.prototype._error.call(this, err);
  };
  BufferToggleSubscriber2.prototype._complete = function() {
    var contexts = this.contexts;
    while (contexts.length > 0) {
      var context_2 = contexts.shift();
      this.destination.next(context_2.buffer);
      context_2.subscription.unsubscribe();
      context_2.buffer = null;
      context_2.subscription = null;
    }
    this.contexts = null;
    _super.prototype._complete.call(this);
  };
  BufferToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue) {
    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
  };
  BufferToggleSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.closeBuffer(innerSub.context);
  };
  BufferToggleSubscriber2.prototype.openBuffer = function(value) {
    try {
      var closingSelector = this.closingSelector;
      var closingNotifier = closingSelector.call(this, value);
      if (closingNotifier) {
        this.trySubscribe(closingNotifier);
      }
    } catch (err) {
      this._error(err);
    }
  };
  BufferToggleSubscriber2.prototype.closeBuffer = function(context2) {
    var contexts = this.contexts;
    if (contexts && context2) {
      var buffer2 = context2.buffer, subscription = context2.subscription;
      this.destination.next(buffer2);
      contexts.splice(contexts.indexOf(context2), 1);
      this.remove(subscription);
      subscription.unsubscribe();
    }
  };
  BufferToggleSubscriber2.prototype.trySubscribe = function(closingNotifier) {
    var contexts = this.contexts;
    var buffer2 = [];
    var subscription = new Subscription();
    var context2 = { buffer: buffer2, subscription };
    contexts.push(context2);
    var innerSubscription = subscribeToResult(this, closingNotifier, context2);
    if (!innerSubscription || innerSubscription.closed) {
      this.closeBuffer(context2);
    } else {
      innerSubscription.context = context2;
      this.add(innerSubscription);
      subscription.add(innerSubscription);
    }
  };
  return BufferToggleSubscriber2;
}(OuterSubscriber);
function bufferWhen(closingSelector) {
  return function(source2) {
    return source2.lift(new BufferWhenOperator(closingSelector));
  };
}
var BufferWhenOperator = /* @__PURE__ */ function() {
  function BufferWhenOperator2(closingSelector) {
    this.closingSelector = closingSelector;
  }
  BufferWhenOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
  };
  return BufferWhenOperator2;
}();
var BufferWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferWhenSubscriber2, _super);
  function BufferWhenSubscriber2(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.closingSelector = closingSelector;
    _this.subscribing = false;
    _this.openBuffer();
    return _this;
  }
  BufferWhenSubscriber2.prototype._next = function(value) {
    this.buffer.push(value);
  };
  BufferWhenSubscriber2.prototype._complete = function() {
    var buffer2 = this.buffer;
    if (buffer2) {
      this.destination.next(buffer2);
    }
    _super.prototype._complete.call(this);
  };
  BufferWhenSubscriber2.prototype._unsubscribe = function() {
    this.buffer = void 0;
    this.subscribing = false;
  };
  BufferWhenSubscriber2.prototype.notifyNext = function() {
    this.openBuffer();
  };
  BufferWhenSubscriber2.prototype.notifyComplete = function() {
    if (this.subscribing) {
      this.complete();
    } else {
      this.openBuffer();
    }
  };
  BufferWhenSubscriber2.prototype.openBuffer = function() {
    var closingSubscription = this.closingSubscription;
    if (closingSubscription) {
      this.remove(closingSubscription);
      closingSubscription.unsubscribe();
    }
    var buffer2 = this.buffer;
    if (this.buffer) {
      this.destination.next(buffer2);
    }
    this.buffer = [];
    var closingNotifier;
    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (err) {
      return this.error(err);
    }
    closingSubscription = new Subscription();
    this.closingSubscription = closingSubscription;
    this.add(closingSubscription);
    this.subscribing = true;
    closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));
    this.subscribing = false;
  };
  return BufferWhenSubscriber2;
}(SimpleOuterSubscriber);
function catchError(selector) {
  return function catchErrorOperatorFunction(source2) {
    var operator = new CatchOperator(selector);
    var caught = source2.lift(operator);
    return operator.caught = caught;
  };
}
var CatchOperator = /* @__PURE__ */ function() {
  function CatchOperator2(selector) {
    this.selector = selector;
  }
  CatchOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
  };
  return CatchOperator2;
}();
var CatchSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CatchSubscriber2, _super);
  function CatchSubscriber2(destination, selector, caught) {
    var _this = _super.call(this, destination) || this;
    _this.selector = selector;
    _this.caught = caught;
    return _this;
  }
  CatchSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var result = void 0;
      try {
        result = this.selector(err, this.caught);
      } catch (err2) {
        _super.prototype.error.call(this, err2);
        return;
      }
      this._unsubscribeAndRecycle();
      var innerSubscriber = new SimpleInnerSubscriber(this);
      this.add(innerSubscriber);
      var innerSubscription = innerSubscribe(result, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        this.add(innerSubscription);
      }
    }
  };
  return CatchSubscriber2;
}(SimpleOuterSubscriber);
function scheduleArray(input, scheduler2) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var i2 = 0;
    sub.add(scheduler2.schedule(function() {
      if (i2 === input.length) {
        subscriber.complete();
        return;
      }
      subscriber.next(input[i2++]);
      if (!subscriber.closed) {
        sub.add(this.schedule());
      }
    }));
    return sub;
  });
}
function fromArray(input, scheduler2) {
  if (!scheduler2) {
    return new Observable(subscribeToArray(input));
  } else {
    return scheduleArray(input, scheduler2);
  }
}
var NONE = {};
var CombineLatestOperator = /* @__PURE__ */ function() {
  function CombineLatestOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  CombineLatestOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
  };
  return CombineLatestOperator2;
}();
var CombineLatestSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CombineLatestSubscriber2, _super);
  function CombineLatestSubscriber2(destination, resultSelector) {
    var _this = _super.call(this, destination) || this;
    _this.resultSelector = resultSelector;
    _this.active = 0;
    _this.values = [];
    _this.observables = [];
    return _this;
  }
  CombineLatestSubscriber2.prototype._next = function(observable2) {
    this.values.push(NONE);
    this.observables.push(observable2);
  };
  CombineLatestSubscriber2.prototype._complete = function() {
    var observables = this.observables;
    var len = observables.length;
    if (len === 0) {
      this.destination.complete();
    } else {
      this.active = len;
      this.toRespond = len;
      for (var i2 = 0; i2 < len; i2++) {
        var observable2 = observables[i2];
        this.add(subscribeToResult(this, observable2, void 0, i2));
      }
    }
  };
  CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
    if ((this.active -= 1) === 0) {
      this.destination.complete();
    }
  };
  CombineLatestSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    var values2 = this.values;
    var oldVal = values2[outerIndex];
    var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
    values2[outerIndex] = innerValue;
    if (toRespond === 0) {
      if (this.resultSelector) {
        this._tryResultSelector(values2);
      } else {
        this.destination.next(values2.slice());
      }
    }
  };
  CombineLatestSubscriber2.prototype._tryResultSelector = function(values2) {
    var result;
    try {
      result = this.resultSelector.apply(this, values2);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return CombineLatestSubscriber2;
}(OuterSubscriber);
function combineAll(project) {
  return function(source2) {
    return source2.lift(new CombineLatestOperator(project));
  };
}
function scheduleObservable(input, scheduler2) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler2.schedule(function() {
      var observable$1 = input[observable]();
      sub.add(observable$1.subscribe({ next: function(value) {
        sub.add(scheduler2.schedule(function() {
          return subscriber.next(value);
        }));
      }, error: function(err) {
        sub.add(scheduler2.schedule(function() {
          return subscriber.error(err);
        }));
      }, complete: function() {
        sub.add(scheduler2.schedule(function() {
          return subscriber.complete();
        }));
      } }));
    }));
    return sub;
  });
}
function schedulePromise(input, scheduler2) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler2.schedule(function() {
      return input.then(function(value) {
        sub.add(scheduler2.schedule(function() {
          subscriber.next(value);
          sub.add(scheduler2.schedule(function() {
            return subscriber.complete();
          }));
        }));
      }, function(err) {
        sub.add(scheduler2.schedule(function() {
          return subscriber.error(err);
        }));
      });
    }));
    return sub;
  });
}
function scheduleIterable(input, scheduler2) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var iterator$1;
    sub.add(function() {
      if (iterator$1 && typeof iterator$1.return === "function") {
        iterator$1.return();
      }
    });
    sub.add(scheduler2.schedule(function() {
      iterator$1 = input[iterator]();
      sub.add(scheduler2.schedule(function() {
        if (subscriber.closed) {
          return;
        }
        var value;
        var done;
        try {
          var result = iterator$1.next();
          value = result.value;
          done = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}
function isInteropObservable(input) {
  return input && typeof input[observable] === "function";
}
function isIterable(input) {
  return input && typeof input[iterator] === "function";
}
function scheduled(input, scheduler2) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler2);
    } else if (isPromise(input)) {
      return schedulePromise(input, scheduler2);
    } else if (isArrayLike(input)) {
      return scheduleArray(input, scheduler2);
    } else if (isIterable(input) || typeof input === "string") {
      return scheduleIterable(input, scheduler2);
    }
  }
  throw new TypeError((input !== null && typeof input || input) + " is not observable");
}
function from(input, scheduler2) {
  if (!scheduler2) {
    if (input instanceof Observable) {
      return input;
    }
    return new Observable(subscribeTo(input));
  } else {
    return scheduled(input, scheduler2);
  }
}
function combineLatest() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var project = null;
  if (typeof observables[observables.length - 1] === "function") {
    project = observables.pop();
  }
  if (observables.length === 1 && isArray$2(observables[0])) {
    observables = observables[0].slice();
  }
  return function(source2) {
    return source2.lift.call(from([source2].concat(observables)), new CombineLatestOperator(project));
  };
}
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler2 = args[args.length - 1];
  if (isScheduler(scheduler2)) {
    args.pop();
    return scheduleArray(args, scheduler2);
  } else {
    return fromArray(args);
  }
}
function map(project, thisArg) {
  return function mapOperation(source2) {
    if (typeof project !== "function") {
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    }
    return source2.lift(new MapOperator(project, thisArg));
  };
}
var MapOperator = /* @__PURE__ */ function() {
  function MapOperator2(project, thisArg) {
    this.project = project;
    this.thisArg = thisArg;
  }
  MapOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  };
  return MapOperator2;
}();
var MapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MapSubscriber2, _super);
  function MapSubscriber2(destination, project, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.count = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }
  MapSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.project.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return MapSubscriber2;
}(Subscriber);
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return function(source2) {
      return source2.pipe(mergeMap(function(a, i2) {
        return from(project(a, i2)).pipe(map(function(b, ii2) {
          return resultSelector(a, b, i2, ii2);
        }));
      }, concurrent));
    };
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return function(source2) {
    return source2.lift(new MergeMapOperator(project, concurrent));
  };
}
var MergeMapOperator = /* @__PURE__ */ function() {
  function MergeMapOperator2(project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    this.project = project;
    this.concurrent = concurrent;
  }
  MergeMapOperator2.prototype.call = function(observer, source2) {
    return source2.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
  };
  return MergeMapOperator2;
}();
var MergeMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MergeMapSubscriber2, _super);
  function MergeMapSubscriber2(destination, project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.concurrent = concurrent;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }
  MergeMapSubscriber2.prototype._next = function(value) {
    if (this.active < this.concurrent) {
      this._tryNext(value);
    } else {
      this.buffer.push(value);
    }
  };
  MergeMapSubscriber2.prototype._tryNext = function(value) {
    var result;
    var index2 = this.index++;
    try {
      result = this.project(value, index2);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.active++;
    this._innerSub(result);
  };
  MergeMapSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  MergeMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.active === 0 && this.buffer.length === 0) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  MergeMapSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2.length > 0) {
      this._next(buffer2.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      this.destination.complete();
    }
  };
  return MergeMapSubscriber2;
}(SimpleOuterSubscriber);
var flatMap = mergeMap;
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return mergeMap(identity, concurrent);
}
function concatAll() {
  return mergeAll(1);
}
function concat$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return concatAll()(of.apply(void 0, observables));
}
function concat() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source2) {
    return source2.lift.call(concat$1.apply(void 0, [source2].concat(observables)));
  };
}
function concatMap(project, resultSelector) {
  return mergeMap(project, resultSelector, 1);
}
function concatMapTo(innerObservable, resultSelector) {
  return concatMap(function() {
    return innerObservable;
  }, resultSelector);
}
function count(predicate) {
  return function(source2) {
    return source2.lift(new CountOperator(predicate, source2));
  };
}
var CountOperator = /* @__PURE__ */ function() {
  function CountOperator2(predicate, source2) {
    this.predicate = predicate;
    this.source = source2;
  }
  CountOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
  };
  return CountOperator2;
}();
var CountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CountSubscriber2, _super);
  function CountSubscriber2(destination, predicate, source2) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source2;
    _this.count = 0;
    _this.index = 0;
    return _this;
  }
  CountSubscriber2.prototype._next = function(value) {
    if (this.predicate) {
      this._tryPredicate(value);
    } else {
      this.count++;
    }
  };
  CountSubscriber2.prototype._tryPredicate = function(value) {
    var result;
    try {
      result = this.predicate(value, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (result) {
      this.count++;
    }
  };
  CountSubscriber2.prototype._complete = function() {
    this.destination.next(this.count);
    this.destination.complete();
  };
  return CountSubscriber2;
}(Subscriber);
function debounce(durationSelector) {
  return function(source2) {
    return source2.lift(new DebounceOperator(durationSelector));
  };
}
var DebounceOperator = /* @__PURE__ */ function() {
  function DebounceOperator2(durationSelector) {
    this.durationSelector = durationSelector;
  }
  DebounceOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
  };
  return DebounceOperator2;
}();
var DebounceSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DebounceSubscriber2, _super);
  function DebounceSubscriber2(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.durationSelector = durationSelector;
    _this.hasValue = false;
    return _this;
  }
  DebounceSubscriber2.prototype._next = function(value) {
    try {
      var result = this.durationSelector.call(this, value);
      if (result) {
        this._tryNext(value, result);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  DebounceSubscriber2.prototype._complete = function() {
    this.emitValue();
    this.destination.complete();
  };
  DebounceSubscriber2.prototype._tryNext = function(value, duration) {
    var subscription = this.durationSubscription;
    this.value = value;
    this.hasValue = true;
    if (subscription) {
      subscription.unsubscribe();
      this.remove(subscription);
    }
    subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
    if (subscription && !subscription.closed) {
      this.add(this.durationSubscription = subscription);
    }
  };
  DebounceSubscriber2.prototype.notifyNext = function() {
    this.emitValue();
  };
  DebounceSubscriber2.prototype.notifyComplete = function() {
    this.emitValue();
  };
  DebounceSubscriber2.prototype.emitValue = function() {
    if (this.hasValue) {
      var value = this.value;
      var subscription = this.durationSubscription;
      if (subscription) {
        this.durationSubscription = void 0;
        subscription.unsubscribe();
        this.remove(subscription);
      }
      this.value = void 0;
      this.hasValue = false;
      _super.prototype._next.call(this, value);
    }
  };
  return DebounceSubscriber2;
}(SimpleOuterSubscriber);
function debounceTime(dueTime, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  return function(source2) {
    return source2.lift(new DebounceTimeOperator(dueTime, scheduler2));
  };
}
var DebounceTimeOperator = /* @__PURE__ */ function() {
  function DebounceTimeOperator2(dueTime, scheduler2) {
    this.dueTime = dueTime;
    this.scheduler = scheduler2;
  }
  DebounceTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
  };
  return DebounceTimeOperator2;
}();
var DebounceTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DebounceTimeSubscriber2, _super);
  function DebounceTimeSubscriber2(destination, dueTime, scheduler2) {
    var _this = _super.call(this, destination) || this;
    _this.dueTime = dueTime;
    _this.scheduler = scheduler2;
    _this.debouncedSubscription = null;
    _this.lastValue = null;
    _this.hasValue = false;
    return _this;
  }
  DebounceTimeSubscriber2.prototype._next = function(value) {
    this.clearDebounce();
    this.lastValue = value;
    this.hasValue = true;
    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
  };
  DebounceTimeSubscriber2.prototype._complete = function() {
    this.debouncedNext();
    this.destination.complete();
  };
  DebounceTimeSubscriber2.prototype.debouncedNext = function() {
    this.clearDebounce();
    if (this.hasValue) {
      var lastValue = this.lastValue;
      this.lastValue = null;
      this.hasValue = false;
      this.destination.next(lastValue);
    }
  };
  DebounceTimeSubscriber2.prototype.clearDebounce = function() {
    var debouncedSubscription = this.debouncedSubscription;
    if (debouncedSubscription !== null) {
      this.remove(debouncedSubscription);
      debouncedSubscription.unsubscribe();
      this.debouncedSubscription = null;
    }
  };
  return DebounceTimeSubscriber2;
}(Subscriber);
function dispatchNext$1(subscriber) {
  subscriber.debouncedNext();
}
function defaultIfEmpty(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = null;
  }
  return function(source2) {
    return source2.lift(new DefaultIfEmptyOperator(defaultValue));
  };
}
var DefaultIfEmptyOperator = /* @__PURE__ */ function() {
  function DefaultIfEmptyOperator2(defaultValue) {
    this.defaultValue = defaultValue;
  }
  DefaultIfEmptyOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
  };
  return DefaultIfEmptyOperator2;
}();
var DefaultIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(DefaultIfEmptySubscriber2, _super);
  function DefaultIfEmptySubscriber2(destination, defaultValue) {
    var _this = _super.call(this, destination) || this;
    _this.defaultValue = defaultValue;
    _this.isEmpty = true;
    return _this;
  }
  DefaultIfEmptySubscriber2.prototype._next = function(value) {
    this.isEmpty = false;
    this.destination.next(value);
  };
  DefaultIfEmptySubscriber2.prototype._complete = function() {
    if (this.isEmpty) {
      this.destination.next(this.defaultValue);
    }
    this.destination.complete();
  };
  return DefaultIfEmptySubscriber2;
}(Subscriber);
function isDate$1(value) {
  return value instanceof Date && !isNaN(+value);
}
var EMPTY = /* @__PURE__ */ new Observable(function(subscriber) {
  return subscriber.complete();
});
function empty$1(scheduler2) {
  return scheduler2 ? emptyScheduled(scheduler2) : EMPTY;
}
function emptyScheduled(scheduler2) {
  return new Observable(function(subscriber) {
    return scheduler2.schedule(function() {
      return subscriber.complete();
    });
  });
}
function throwError(error, scheduler2) {
  if (!scheduler2) {
    return new Observable(function(subscriber) {
      return subscriber.error(error);
    });
  } else {
    return new Observable(function(subscriber) {
      return scheduler2.schedule(dispatch, 0, { error, subscriber });
    });
  }
}
function dispatch(_a2) {
  var error = _a2.error, subscriber = _a2.subscriber;
  subscriber.error(error);
}
var Notification = /* @__PURE__ */ function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    switch (this.kind) {
      case "N":
        return observer.next && observer.next(this.value);
      case "E":
        return observer.error && observer.error(this.error);
      case "C":
        return observer.complete && observer.complete();
    }
  };
  Notification2.prototype.do = function(next, error, complete) {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return next && next(this.value);
      case "E":
        return error && error(this.error);
      case "C":
        return complete && complete();
    }
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    if (nextOrObserver && typeof nextOrObserver.next === "function") {
      return this.observe(nextOrObserver);
    } else {
      return this.do(nextOrObserver, error, complete);
    }
  };
  Notification2.prototype.toObservable = function() {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return of(this.value);
      case "E":
        return throwError(this.error);
      case "C":
        return empty$1();
    }
    throw new Error("unexpected notification kind value");
  };
  Notification2.createNext = function(value) {
    if (typeof value !== "undefined") {
      return new Notification2("N", value);
    }
    return Notification2.undefinedValueNotification;
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  Notification2.undefinedValueNotification = new Notification2("N", void 0);
  return Notification2;
}();
function delay(delay2, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  var absoluteDelay = isDate$1(delay2);
  var delayFor = absoluteDelay ? +delay2 - scheduler2.now() : Math.abs(delay2);
  return function(source2) {
    return source2.lift(new DelayOperator(delayFor, scheduler2));
  };
}
var DelayOperator = /* @__PURE__ */ function() {
  function DelayOperator2(delay2, scheduler2) {
    this.delay = delay2;
    this.scheduler = scheduler2;
  }
  DelayOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
  };
  return DelayOperator2;
}();
var DelaySubscriber = /* @__PURE__ */ function(_super) {
  __extends(DelaySubscriber2, _super);
  function DelaySubscriber2(destination, delay2, scheduler2) {
    var _this = _super.call(this, destination) || this;
    _this.delay = delay2;
    _this.scheduler = scheduler2;
    _this.queue = [];
    _this.active = false;
    _this.errored = false;
    return _this;
  }
  DelaySubscriber2.dispatch = function(state2) {
    var source2 = state2.source;
    var queue2 = source2.queue;
    var scheduler2 = state2.scheduler;
    var destination = state2.destination;
    while (queue2.length > 0 && queue2[0].time - scheduler2.now() <= 0) {
      queue2.shift().notification.observe(destination);
    }
    if (queue2.length > 0) {
      var delay_1 = Math.max(0, queue2[0].time - scheduler2.now());
      this.schedule(state2, delay_1);
    } else {
      this.unsubscribe();
      source2.active = false;
    }
  };
  DelaySubscriber2.prototype._schedule = function(scheduler2) {
    this.active = true;
    var destination = this.destination;
    destination.add(scheduler2.schedule(DelaySubscriber2.dispatch, this.delay, { source: this, destination: this.destination, scheduler: scheduler2 }));
  };
  DelaySubscriber2.prototype.scheduleNotification = function(notification) {
    if (this.errored === true) {
      return;
    }
    var scheduler2 = this.scheduler;
    var message = new DelayMessage(scheduler2.now() + this.delay, notification);
    this.queue.push(message);
    if (this.active === false) {
      this._schedule(scheduler2);
    }
  };
  DelaySubscriber2.prototype._next = function(value) {
    this.scheduleNotification(Notification.createNext(value));
  };
  DelaySubscriber2.prototype._error = function(err) {
    this.errored = true;
    this.queue = [];
    this.destination.error(err);
    this.unsubscribe();
  };
  DelaySubscriber2.prototype._complete = function() {
    this.scheduleNotification(Notification.createComplete());
    this.unsubscribe();
  };
  return DelaySubscriber2;
}(Subscriber);
var DelayMessage = /* @__PURE__ */ function() {
  function DelayMessage2(time, notification) {
    this.time = time;
    this.notification = notification;
  }
  return DelayMessage2;
}();
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source2) {
      return new SubscriptionDelayObservable(source2, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
    };
  }
  return function(source2) {
    return source2.lift(new DelayWhenOperator(delayDurationSelector));
  };
}
var DelayWhenOperator = /* @__PURE__ */ function() {
  function DelayWhenOperator2(delayDurationSelector) {
    this.delayDurationSelector = delayDurationSelector;
  }
  DelayWhenOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
  };
  return DelayWhenOperator2;
}();
var DelayWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DelayWhenSubscriber2, _super);
  function DelayWhenSubscriber2(destination, delayDurationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.delayDurationSelector = delayDurationSelector;
    _this.completed = false;
    _this.delayNotifierSubscriptions = [];
    _this.index = 0;
    return _this;
  }
  DelayWhenSubscriber2.prototype.notifyNext = function(outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
    this.destination.next(outerValue);
    this.removeSubscription(innerSub);
    this.tryComplete();
  };
  DelayWhenSubscriber2.prototype.notifyError = function(error, innerSub) {
    this._error(error);
  };
  DelayWhenSubscriber2.prototype.notifyComplete = function(innerSub) {
    var value = this.removeSubscription(innerSub);
    if (value) {
      this.destination.next(value);
    }
    this.tryComplete();
  };
  DelayWhenSubscriber2.prototype._next = function(value) {
    var index2 = this.index++;
    try {
      var delayNotifier = this.delayDurationSelector(value, index2);
      if (delayNotifier) {
        this.tryDelay(delayNotifier, value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  DelayWhenSubscriber2.prototype._complete = function() {
    this.completed = true;
    this.tryComplete();
    this.unsubscribe();
  };
  DelayWhenSubscriber2.prototype.removeSubscription = function(subscription) {
    subscription.unsubscribe();
    var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
    if (subscriptionIdx !== -1) {
      this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
    }
    return subscription.outerValue;
  };
  DelayWhenSubscriber2.prototype.tryDelay = function(delayNotifier, value) {
    var notifierSubscription = subscribeToResult(this, delayNotifier, value);
    if (notifierSubscription && !notifierSubscription.closed) {
      var destination = this.destination;
      destination.add(notifierSubscription);
      this.delayNotifierSubscriptions.push(notifierSubscription);
    }
  };
  DelayWhenSubscriber2.prototype.tryComplete = function() {
    if (this.completed && this.delayNotifierSubscriptions.length === 0) {
      this.destination.complete();
    }
  };
  return DelayWhenSubscriber2;
}(OuterSubscriber);
var SubscriptionDelayObservable = /* @__PURE__ */ function(_super) {
  __extends(SubscriptionDelayObservable2, _super);
  function SubscriptionDelayObservable2(source2, subscriptionDelay) {
    var _this = _super.call(this) || this;
    _this.source = source2;
    _this.subscriptionDelay = subscriptionDelay;
    return _this;
  }
  SubscriptionDelayObservable2.prototype._subscribe = function(subscriber) {
    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
  };
  return SubscriptionDelayObservable2;
}(Observable);
var SubscriptionDelaySubscriber = /* @__PURE__ */ function(_super) {
  __extends(SubscriptionDelaySubscriber2, _super);
  function SubscriptionDelaySubscriber2(parent2, source2) {
    var _this = _super.call(this) || this;
    _this.parent = parent2;
    _this.source = source2;
    _this.sourceSubscribed = false;
    return _this;
  }
  SubscriptionDelaySubscriber2.prototype._next = function(unused) {
    this.subscribeToSource();
  };
  SubscriptionDelaySubscriber2.prototype._error = function(err) {
    this.unsubscribe();
    this.parent.error(err);
  };
  SubscriptionDelaySubscriber2.prototype._complete = function() {
    this.unsubscribe();
    this.subscribeToSource();
  };
  SubscriptionDelaySubscriber2.prototype.subscribeToSource = function() {
    if (!this.sourceSubscribed) {
      this.sourceSubscribed = true;
      this.unsubscribe();
      this.source.subscribe(this.parent);
    }
  };
  return SubscriptionDelaySubscriber2;
}(Subscriber);
function dematerialize() {
  return function dematerializeOperatorFunction(source2) {
    return source2.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator = /* @__PURE__ */ function() {
  function DeMaterializeOperator2() {
  }
  DeMaterializeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DeMaterializeSubscriber(subscriber));
  };
  return DeMaterializeOperator2;
}();
var DeMaterializeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DeMaterializeSubscriber2, _super);
  function DeMaterializeSubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  DeMaterializeSubscriber2.prototype._next = function(value) {
    value.observe(this.destination);
  };
  return DeMaterializeSubscriber2;
}(Subscriber);
function distinct(keySelector, flushes) {
  return function(source2) {
    return source2.lift(new DistinctOperator(keySelector, flushes));
  };
}
var DistinctOperator = /* @__PURE__ */ function() {
  function DistinctOperator2(keySelector, flushes) {
    this.keySelector = keySelector;
    this.flushes = flushes;
  }
  DistinctOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
  };
  return DistinctOperator2;
}();
var DistinctSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DistinctSubscriber2, _super);
  function DistinctSubscriber2(destination, keySelector, flushes) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.values = /* @__PURE__ */ new Set();
    if (flushes) {
      _this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(_this)));
    }
    return _this;
  }
  DistinctSubscriber2.prototype.notifyNext = function() {
    this.values.clear();
  };
  DistinctSubscriber2.prototype.notifyError = function(error) {
    this._error(error);
  };
  DistinctSubscriber2.prototype._next = function(value) {
    if (this.keySelector) {
      this._useKeySelector(value);
    } else {
      this._finalizeNext(value, value);
    }
  };
  DistinctSubscriber2.prototype._useKeySelector = function(value) {
    var key;
    var destination = this.destination;
    try {
      key = this.keySelector(value);
    } catch (err) {
      destination.error(err);
      return;
    }
    this._finalizeNext(key, value);
  };
  DistinctSubscriber2.prototype._finalizeNext = function(key, value) {
    var values2 = this.values;
    if (!values2.has(key)) {
      values2.add(key);
      this.destination.next(value);
    }
  };
  return DistinctSubscriber2;
}(SimpleOuterSubscriber);
function distinctUntilChanged(compare, keySelector) {
  return function(source2) {
    return source2.lift(new DistinctUntilChangedOperator(compare, keySelector));
  };
}
var DistinctUntilChangedOperator = /* @__PURE__ */ function() {
  function DistinctUntilChangedOperator2(compare, keySelector) {
    this.compare = compare;
    this.keySelector = keySelector;
  }
  DistinctUntilChangedOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
  };
  return DistinctUntilChangedOperator2;
}();
var DistinctUntilChangedSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DistinctUntilChangedSubscriber2, _super);
  function DistinctUntilChangedSubscriber2(destination, compare, keySelector) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.hasKey = false;
    if (typeof compare === "function") {
      _this.compare = compare;
    }
    return _this;
  }
  DistinctUntilChangedSubscriber2.prototype.compare = function(x2, y2) {
    return x2 === y2;
  };
  DistinctUntilChangedSubscriber2.prototype._next = function(value) {
    var key;
    try {
      var keySelector = this.keySelector;
      key = keySelector ? keySelector(value) : value;
    } catch (err) {
      return this.destination.error(err);
    }
    var result = false;
    if (this.hasKey) {
      try {
        var compare = this.compare;
        result = compare(this.key, key);
      } catch (err) {
        return this.destination.error(err);
      }
    } else {
      this.hasKey = true;
    }
    if (!result) {
      this.key = key;
      this.destination.next(value);
    }
  };
  return DistinctUntilChangedSubscriber2;
}(Subscriber);
function distinctUntilKeyChanged(key, compare) {
  return distinctUntilChanged(function(x2, y2) {
    return compare ? compare(x2[key], y2[key]) : x2[key] === y2[key];
  });
}
var ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {
  function ArgumentOutOfRangeErrorImpl2() {
    Error.call(this);
    this.message = "argument out of range";
    this.name = "ArgumentOutOfRangeError";
    return this;
  }
  ArgumentOutOfRangeErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return ArgumentOutOfRangeErrorImpl2;
}();
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
function filter(predicate, thisArg) {
  return function filterOperatorFunction(source2) {
    return source2.lift(new FilterOperator(predicate, thisArg));
  };
}
var FilterOperator = /* @__PURE__ */ function() {
  function FilterOperator2(predicate, thisArg) {
    this.predicate = predicate;
    this.thisArg = thisArg;
  }
  FilterOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
  };
  return FilterOperator2;
}();
var FilterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(FilterSubscriber2, _super);
  function FilterSubscriber2(destination, predicate, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.count = 0;
    return _this;
  }
  FilterSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.predicate.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (result) {
      this.destination.next(value);
    }
  };
  return FilterSubscriber2;
}(Subscriber);
var EmptyErrorImpl = /* @__PURE__ */ function() {
  function EmptyErrorImpl2() {
    Error.call(this);
    this.message = "no elements in sequence";
    this.name = "EmptyError";
    return this;
  }
  EmptyErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return EmptyErrorImpl2;
}();
var EmptyError = EmptyErrorImpl;
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return function(source2) {
    return source2.lift(new ThrowIfEmptyOperator(errorFactory));
  };
}
var ThrowIfEmptyOperator = /* @__PURE__ */ function() {
  function ThrowIfEmptyOperator2(errorFactory) {
    this.errorFactory = errorFactory;
  }
  ThrowIfEmptyOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
  };
  return ThrowIfEmptyOperator2;
}();
var ThrowIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrowIfEmptySubscriber2, _super);
  function ThrowIfEmptySubscriber2(destination, errorFactory) {
    var _this = _super.call(this, destination) || this;
    _this.errorFactory = errorFactory;
    _this.hasValue = false;
    return _this;
  }
  ThrowIfEmptySubscriber2.prototype._next = function(value) {
    this.hasValue = true;
    this.destination.next(value);
  };
  ThrowIfEmptySubscriber2.prototype._complete = function() {
    if (!this.hasValue) {
      var err = void 0;
      try {
        err = this.errorFactory();
      } catch (e2) {
        err = e2;
      }
      this.destination.error(err);
    } else {
      return this.destination.complete();
    }
  };
  return ThrowIfEmptySubscriber2;
}(Subscriber);
function defaultErrorFactory() {
  return new EmptyError();
}
function take(count2) {
  return function(source2) {
    if (count2 === 0) {
      return empty$1();
    } else {
      return source2.lift(new TakeOperator(count2));
    }
  };
}
var TakeOperator = /* @__PURE__ */ function() {
  function TakeOperator2(total) {
    this.total = total;
    if (this.total < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  TakeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TakeSubscriber(subscriber, this.total));
  };
  return TakeOperator2;
}();
var TakeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeSubscriber2, _super);
  function TakeSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.count = 0;
    return _this;
  }
  TakeSubscriber2.prototype._next = function(value) {
    var total = this.total;
    var count2 = ++this.count;
    if (count2 <= total) {
      this.destination.next(value);
      if (count2 === total) {
        this.destination.complete();
        this.unsubscribe();
      }
    }
  };
  return TakeSubscriber2;
}(Subscriber);
function elementAt(index2, defaultValue) {
  if (index2 < 0) {
    throw new ArgumentOutOfRangeError();
  }
  var hasDefaultValue = arguments.length >= 2;
  return function(source2) {
    return source2.pipe(filter(function(v2, i2) {
      return i2 === index2;
    }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
function endWith() {
  var array = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array[_i] = arguments[_i];
  }
  return function(source2) {
    return concat$1(source2, of.apply(void 0, array));
  };
}
function every(predicate, thisArg) {
  return function(source2) {
    return source2.lift(new EveryOperator(predicate, thisArg, source2));
  };
}
var EveryOperator = /* @__PURE__ */ function() {
  function EveryOperator2(predicate, thisArg, source2) {
    this.predicate = predicate;
    this.thisArg = thisArg;
    this.source = source2;
  }
  EveryOperator2.prototype.call = function(observer, source2) {
    return source2.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
  };
  return EveryOperator2;
}();
var EverySubscriber = /* @__PURE__ */ function(_super) {
  __extends(EverySubscriber2, _super);
  function EverySubscriber2(destination, predicate, thisArg, source2) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.source = source2;
    _this.index = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }
  EverySubscriber2.prototype.notifyComplete = function(everyValueMatch) {
    this.destination.next(everyValueMatch);
    this.destination.complete();
  };
  EverySubscriber2.prototype._next = function(value) {
    var result = false;
    try {
      result = this.predicate.call(this.thisArg, value, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (!result) {
      this.notifyComplete(false);
    }
  };
  EverySubscriber2.prototype._complete = function() {
    this.notifyComplete(true);
  };
  return EverySubscriber2;
}(Subscriber);
function exhaust() {
  return function(source2) {
    return source2.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator = /* @__PURE__ */ function() {
  function SwitchFirstOperator2() {
  }
  SwitchFirstOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SwitchFirstSubscriber(subscriber));
  };
  return SwitchFirstOperator2;
}();
var SwitchFirstSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SwitchFirstSubscriber2, _super);
  function SwitchFirstSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasCompleted = false;
    _this.hasSubscription = false;
    return _this;
  }
  SwitchFirstSubscriber2.prototype._next = function(value) {
    if (!this.hasSubscription) {
      this.hasSubscription = true;
      this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));
    }
  };
  SwitchFirstSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (!this.hasSubscription) {
      this.destination.complete();
    }
  };
  SwitchFirstSubscriber2.prototype.notifyComplete = function() {
    this.hasSubscription = false;
    if (this.hasCompleted) {
      this.destination.complete();
    }
  };
  return SwitchFirstSubscriber2;
}(SimpleOuterSubscriber);
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source2) {
      return source2.pipe(exhaustMap(function(a, i2) {
        return from(project(a, i2)).pipe(map(function(b, ii2) {
          return resultSelector(a, b, i2, ii2);
        }));
      }));
    };
  }
  return function(source2) {
    return source2.lift(new ExhaustMapOperator(project));
  };
}
var ExhaustMapOperator = /* @__PURE__ */ function() {
  function ExhaustMapOperator2(project) {
    this.project = project;
  }
  ExhaustMapOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
  };
  return ExhaustMapOperator2;
}();
var ExhaustMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ExhaustMapSubscriber2, _super);
  function ExhaustMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.hasSubscription = false;
    _this.hasCompleted = false;
    _this.index = 0;
    return _this;
  }
  ExhaustMapSubscriber2.prototype._next = function(value) {
    if (!this.hasSubscription) {
      this.tryNext(value);
    }
  };
  ExhaustMapSubscriber2.prototype.tryNext = function(value) {
    var result;
    var index2 = this.index++;
    try {
      result = this.project(value, index2);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.hasSubscription = true;
    this._innerSub(result);
  };
  ExhaustMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(result, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  ExhaustMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (!this.hasSubscription) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  ExhaustMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  ExhaustMapSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  };
  ExhaustMapSubscriber2.prototype.notifyComplete = function() {
    this.hasSubscription = false;
    if (this.hasCompleted) {
      this.destination.complete();
    }
  };
  return ExhaustMapSubscriber2;
}(SimpleOuterSubscriber);
function expand(project, concurrent, scheduler2) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
  return function(source2) {
    return source2.lift(new ExpandOperator(project, concurrent, scheduler2));
  };
}
var ExpandOperator = /* @__PURE__ */ function() {
  function ExpandOperator2(project, concurrent, scheduler2) {
    this.project = project;
    this.concurrent = concurrent;
    this.scheduler = scheduler2;
  }
  ExpandOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
  };
  return ExpandOperator2;
}();
var ExpandSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ExpandSubscriber2, _super);
  function ExpandSubscriber2(destination, project, concurrent, scheduler2) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.concurrent = concurrent;
    _this.scheduler = scheduler2;
    _this.index = 0;
    _this.active = 0;
    _this.hasCompleted = false;
    if (concurrent < Number.POSITIVE_INFINITY) {
      _this.buffer = [];
    }
    return _this;
  }
  ExpandSubscriber2.dispatch = function(arg) {
    var subscriber = arg.subscriber, result = arg.result, value = arg.value, index2 = arg.index;
    subscriber.subscribeToProjection(result, value, index2);
  };
  ExpandSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    if (destination.closed) {
      this._complete();
      return;
    }
    var index2 = this.index++;
    if (this.active < this.concurrent) {
      destination.next(value);
      try {
        var project = this.project;
        var result = project(value, index2);
        if (!this.scheduler) {
          this.subscribeToProjection(result, value, index2);
        } else {
          var state2 = { subscriber: this, result, value, index: index2 };
          var destination_1 = this.destination;
          destination_1.add(this.scheduler.schedule(ExpandSubscriber2.dispatch, 0, state2));
        }
      } catch (e2) {
        destination.error(e2);
      }
    } else {
      this.buffer.push(value);
    }
  };
  ExpandSubscriber2.prototype.subscribeToProjection = function(result, value, index2) {
    this.active++;
    var destination = this.destination;
    destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));
  };
  ExpandSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.hasCompleted && this.active === 0) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  ExpandSubscriber2.prototype.notifyNext = function(innerValue) {
    this._next(innerValue);
  };
  ExpandSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2 && buffer2.length > 0) {
      this._next(buffer2.shift());
    }
    if (this.hasCompleted && this.active === 0) {
      this.destination.complete();
    }
  };
  return ExpandSubscriber2;
}(SimpleOuterSubscriber);
function finalize(callback) {
  return function(source2) {
    return source2.lift(new FinallyOperator(callback));
  };
}
var FinallyOperator = /* @__PURE__ */ function() {
  function FinallyOperator2(callback) {
    this.callback = callback;
  }
  FinallyOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new FinallySubscriber(subscriber, this.callback));
  };
  return FinallyOperator2;
}();
var FinallySubscriber = /* @__PURE__ */ function(_super) {
  __extends(FinallySubscriber2, _super);
  function FinallySubscriber2(destination, callback) {
    var _this = _super.call(this, destination) || this;
    _this.add(new Subscription(callback));
    return _this;
  }
  return FinallySubscriber2;
}(Subscriber);
function find$1(predicate, thisArg) {
  if (typeof predicate !== "function") {
    throw new TypeError("predicate is not a function");
  }
  return function(source2) {
    return source2.lift(new FindValueOperator(predicate, source2, false, thisArg));
  };
}
var FindValueOperator = /* @__PURE__ */ function() {
  function FindValueOperator2(predicate, source2, yieldIndex, thisArg) {
    this.predicate = predicate;
    this.source = source2;
    this.yieldIndex = yieldIndex;
    this.thisArg = thisArg;
  }
  FindValueOperator2.prototype.call = function(observer, source2) {
    return source2.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
  };
  return FindValueOperator2;
}();
var FindValueSubscriber = /* @__PURE__ */ function(_super) {
  __extends(FindValueSubscriber2, _super);
  function FindValueSubscriber2(destination, predicate, source2, yieldIndex, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source2;
    _this.yieldIndex = yieldIndex;
    _this.thisArg = thisArg;
    _this.index = 0;
    return _this;
  }
  FindValueSubscriber2.prototype.notifyComplete = function(value) {
    var destination = this.destination;
    destination.next(value);
    destination.complete();
    this.unsubscribe();
  };
  FindValueSubscriber2.prototype._next = function(value) {
    var _a2 = this, predicate = _a2.predicate, thisArg = _a2.thisArg;
    var index2 = this.index++;
    try {
      var result = predicate.call(thisArg || this, value, index2, this.source);
      if (result) {
        this.notifyComplete(this.yieldIndex ? index2 : value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  FindValueSubscriber2.prototype._complete = function() {
    this.notifyComplete(this.yieldIndex ? -1 : void 0);
  };
  return FindValueSubscriber2;
}(Subscriber);
function findIndex(predicate, thisArg) {
  return function(source2) {
    return source2.lift(new FindValueOperator(predicate, source2, true, thisArg));
  };
}
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source2) {
    return source2.pipe(predicate ? filter(function(v2, i2) {
      return predicate(v2, i2, source2);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
  function ObjectUnsubscribedErrorImpl2() {
    Error.call(this);
    this.message = "object unsubscribed";
    this.name = "ObjectUnsubscribedError";
    return this;
  }
  ObjectUnsubscribedErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return ObjectUnsubscribedErrorImpl2;
}();
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
var SubjectSubscription = /* @__PURE__ */ function(_super) {
  __extends(SubjectSubscription2, _super);
  function SubjectSubscription2(subject, subscriber) {
    var _this = _super.call(this) || this;
    _this.subject = subject;
    _this.subscriber = subscriber;
    _this.closed = false;
    return _this;
  }
  SubjectSubscription2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.closed = true;
    var subject = this.subject;
    var observers = subject.observers;
    this.subject = null;
    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
      return;
    }
    var subscriberIndex = observers.indexOf(this.subscriber);
    if (subscriberIndex !== -1) {
      observers.splice(subscriberIndex, 1);
    }
  };
  return SubjectSubscription2;
}(Subscription);
var SubjectSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SubjectSubscriber2, _super);
  function SubjectSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    return _this;
  }
  return SubjectSubscriber2;
}(Subscriber);
var Subject = /* @__PURE__ */ function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.observers = [];
    _this.closed = false;
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype[rxSubscriber] = function() {
    return new SubjectSubscriber(this);
  };
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype.next = function(value) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    if (!this.isStopped) {
      var observers = this.observers;
      var len = observers.length;
      var copy = observers.slice();
      for (var i2 = 0; i2 < len; i2++) {
        copy[i2].next(value);
      }
    }
  };
  Subject2.prototype.error = function(err) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.hasError = true;
    this.thrownError = err;
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy = observers.slice();
    for (var i2 = 0; i2 < len; i2++) {
      copy[i2].error(err);
    }
    this.observers.length = 0;
  };
  Subject2.prototype.complete = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy = observers.slice();
    for (var i2 = 0; i2 < len; i2++) {
      copy[i2].complete();
    }
    this.observers.length = 0;
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = true;
    this.closed = true;
    this.observers = null;
  };
  Subject2.prototype._trySubscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return _super.prototype._trySubscribe.call(this, subscriber);
    }
  };
  Subject2.prototype._subscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription.EMPTY;
    } else if (this.isStopped) {
      subscriber.complete();
      return Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      return new SubjectSubscription(this, subscriber);
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source2) {
    return new AnonymousSubject(destination, source2);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = /* @__PURE__ */ function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source2) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source2;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var destination = this.destination;
    if (destination && destination.next) {
      destination.next(value);
    }
  };
  AnonymousSubject2.prototype.error = function(err) {
    var destination = this.destination;
    if (destination && destination.error) {
      this.destination.error(err);
    }
  };
  AnonymousSubject2.prototype.complete = function() {
    var destination = this.destination;
    if (destination && destination.complete) {
      this.destination.complete();
    }
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var source2 = this.source;
    if (source2) {
      return this.source.subscribe(subscriber);
    } else {
      return Subscription.EMPTY;
    }
  };
  return AnonymousSubject2;
}(Subject);
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
  return function(source2) {
    return source2.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
  };
}
var GroupByOperator = /* @__PURE__ */ function() {
  function GroupByOperator2(keySelector, elementSelector, durationSelector, subjectSelector) {
    this.keySelector = keySelector;
    this.elementSelector = elementSelector;
    this.durationSelector = durationSelector;
    this.subjectSelector = subjectSelector;
  }
  GroupByOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  };
  return GroupByOperator2;
}();
var GroupBySubscriber = /* @__PURE__ */ function(_super) {
  __extends(GroupBySubscriber2, _super);
  function GroupBySubscriber2(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.elementSelector = elementSelector;
    _this.durationSelector = durationSelector;
    _this.subjectSelector = subjectSelector;
    _this.groups = null;
    _this.attemptedToUnsubscribe = false;
    _this.count = 0;
    return _this;
  }
  GroupBySubscriber2.prototype._next = function(value) {
    var key;
    try {
      key = this.keySelector(value);
    } catch (err) {
      this.error(err);
      return;
    }
    this._group(value, key);
  };
  GroupBySubscriber2.prototype._group = function(value, key) {
    var groups = this.groups;
    if (!groups) {
      groups = this.groups = /* @__PURE__ */ new Map();
    }
    var group = groups.get(key);
    var element;
    if (this.elementSelector) {
      try {
        element = this.elementSelector(value);
      } catch (err) {
        this.error(err);
      }
    } else {
      element = value;
    }
    if (!group) {
      group = this.subjectSelector ? this.subjectSelector() : new Subject();
      groups.set(key, group);
      var groupedObservable = new GroupedObservable(key, group, this);
      this.destination.next(groupedObservable);
      if (this.durationSelector) {
        var duration = void 0;
        try {
          duration = this.durationSelector(new GroupedObservable(key, group));
        } catch (err) {
          this.error(err);
          return;
        }
        this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
      }
    }
    if (!group.closed) {
      group.next(element);
    }
  };
  GroupBySubscriber2.prototype._error = function(err) {
    var groups = this.groups;
    if (groups) {
      groups.forEach(function(group, key) {
        group.error(err);
      });
      groups.clear();
    }
    this.destination.error(err);
  };
  GroupBySubscriber2.prototype._complete = function() {
    var groups = this.groups;
    if (groups) {
      groups.forEach(function(group, key) {
        group.complete();
      });
      groups.clear();
    }
    this.destination.complete();
  };
  GroupBySubscriber2.prototype.removeGroup = function(key) {
    this.groups.delete(key);
  };
  GroupBySubscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.attemptedToUnsubscribe = true;
      if (this.count === 0) {
        _super.prototype.unsubscribe.call(this);
      }
    }
  };
  return GroupBySubscriber2;
}(Subscriber);
var GroupDurationSubscriber = /* @__PURE__ */ function(_super) {
  __extends(GroupDurationSubscriber2, _super);
  function GroupDurationSubscriber2(key, group, parent2) {
    var _this = _super.call(this, group) || this;
    _this.key = key;
    _this.group = group;
    _this.parent = parent2;
    return _this;
  }
  GroupDurationSubscriber2.prototype._next = function(value) {
    this.complete();
  };
  GroupDurationSubscriber2.prototype._unsubscribe = function() {
    var _a2 = this, parent2 = _a2.parent, key = _a2.key;
    this.key = this.parent = null;
    if (parent2) {
      parent2.removeGroup(key);
    }
  };
  return GroupDurationSubscriber2;
}(Subscriber);
var GroupedObservable = /* @__PURE__ */ function(_super) {
  __extends(GroupedObservable2, _super);
  function GroupedObservable2(key, groupSubject, refCountSubscription) {
    var _this = _super.call(this) || this;
    _this.key = key;
    _this.groupSubject = groupSubject;
    _this.refCountSubscription = refCountSubscription;
    return _this;
  }
  GroupedObservable2.prototype._subscribe = function(subscriber) {
    var subscription = new Subscription();
    var _a2 = this, refCountSubscription = _a2.refCountSubscription, groupSubject = _a2.groupSubject;
    if (refCountSubscription && !refCountSubscription.closed) {
      subscription.add(new InnerRefCountSubscription(refCountSubscription));
    }
    subscription.add(groupSubject.subscribe(subscriber));
    return subscription;
  };
  return GroupedObservable2;
}(Observable);
var InnerRefCountSubscription = /* @__PURE__ */ function(_super) {
  __extends(InnerRefCountSubscription2, _super);
  function InnerRefCountSubscription2(parent2) {
    var _this = _super.call(this) || this;
    _this.parent = parent2;
    parent2.count++;
    return _this;
  }
  InnerRefCountSubscription2.prototype.unsubscribe = function() {
    var parent2 = this.parent;
    if (!parent2.closed && !this.closed) {
      _super.prototype.unsubscribe.call(this);
      parent2.count -= 1;
      if (parent2.count === 0 && parent2.attemptedToUnsubscribe) {
        parent2.unsubscribe();
      }
    }
  };
  return InnerRefCountSubscription2;
}(Subscription);
function ignoreElements() {
  return function ignoreElementsOperatorFunction(source2) {
    return source2.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator = /* @__PURE__ */ function() {
  function IgnoreElementsOperator2() {
  }
  IgnoreElementsOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new IgnoreElementsSubscriber(subscriber));
  };
  return IgnoreElementsOperator2;
}();
var IgnoreElementsSubscriber = /* @__PURE__ */ function(_super) {
  __extends(IgnoreElementsSubscriber2, _super);
  function IgnoreElementsSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IgnoreElementsSubscriber2.prototype._next = function(unused) {
  };
  return IgnoreElementsSubscriber2;
}(Subscriber);
function isEmpty() {
  return function(source2) {
    return source2.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator = /* @__PURE__ */ function() {
  function IsEmptyOperator2() {
  }
  IsEmptyOperator2.prototype.call = function(observer, source2) {
    return source2.subscribe(new IsEmptySubscriber(observer));
  };
  return IsEmptyOperator2;
}();
var IsEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(IsEmptySubscriber2, _super);
  function IsEmptySubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  IsEmptySubscriber2.prototype.notifyComplete = function(isEmpty2) {
    var destination = this.destination;
    destination.next(isEmpty2);
    destination.complete();
  };
  IsEmptySubscriber2.prototype._next = function(value) {
    this.notifyComplete(false);
  };
  IsEmptySubscriber2.prototype._complete = function() {
    this.notifyComplete(true);
  };
  return IsEmptySubscriber2;
}(Subscriber);
function takeLast(count2) {
  return function takeLastOperatorFunction(source2) {
    if (count2 === 0) {
      return empty$1();
    } else {
      return source2.lift(new TakeLastOperator(count2));
    }
  };
}
var TakeLastOperator = /* @__PURE__ */ function() {
  function TakeLastOperator2(total) {
    this.total = total;
    if (this.total < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  TakeLastOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TakeLastSubscriber(subscriber, this.total));
  };
  return TakeLastOperator2;
}();
var TakeLastSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeLastSubscriber2, _super);
  function TakeLastSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.ring = new Array();
    _this.count = 0;
    return _this;
  }
  TakeLastSubscriber2.prototype._next = function(value) {
    var ring = this.ring;
    var total = this.total;
    var count2 = this.count++;
    if (ring.length < total) {
      ring.push(value);
    } else {
      var index2 = count2 % total;
      ring[index2] = value;
    }
  };
  TakeLastSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    var count2 = this.count;
    if (count2 > 0) {
      var total = this.count >= this.total ? this.total : this.count;
      var ring = this.ring;
      for (var i2 = 0; i2 < total; i2++) {
        var idx = count2++ % total;
        destination.next(ring[idx]);
      }
    }
    destination.complete();
  };
  return TakeLastSubscriber2;
}(Subscriber);
function last(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source2) {
    return source2.pipe(predicate ? filter(function(v2, i2) {
      return predicate(v2, i2, source2);
    }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function mapTo(value) {
  return function(source2) {
    return source2.lift(new MapToOperator(value));
  };
}
var MapToOperator = /* @__PURE__ */ function() {
  function MapToOperator2(value) {
    this.value = value;
  }
  MapToOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new MapToSubscriber(subscriber, this.value));
  };
  return MapToOperator2;
}();
var MapToSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MapToSubscriber2, _super);
  function MapToSubscriber2(destination, value) {
    var _this = _super.call(this, destination) || this;
    _this.value = value;
    return _this;
  }
  MapToSubscriber2.prototype._next = function(x2) {
    this.destination.next(this.value);
  };
  return MapToSubscriber2;
}(Subscriber);
function materialize() {
  return function materializeOperatorFunction(source2) {
    return source2.lift(new MaterializeOperator());
  };
}
var MaterializeOperator = /* @__PURE__ */ function() {
  function MaterializeOperator2() {
  }
  MaterializeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new MaterializeSubscriber(subscriber));
  };
  return MaterializeOperator2;
}();
var MaterializeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MaterializeSubscriber2, _super);
  function MaterializeSubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  MaterializeSubscriber2.prototype._next = function(value) {
    this.destination.next(Notification.createNext(value));
  };
  MaterializeSubscriber2.prototype._error = function(err) {
    var destination = this.destination;
    destination.next(Notification.createError(err));
    destination.complete();
  };
  MaterializeSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    destination.next(Notification.createComplete());
    destination.complete();
  };
  return MaterializeSubscriber2;
}(Subscriber);
function scan(accumulator, seed) {
  var hasSeed = false;
  if (arguments.length >= 2) {
    hasSeed = true;
  }
  return function scanOperatorFunction(source2) {
    return source2.lift(new ScanOperator(accumulator, seed, hasSeed));
  };
}
var ScanOperator = /* @__PURE__ */ function() {
  function ScanOperator2(accumulator, seed, hasSeed) {
    if (hasSeed === void 0) {
      hasSeed = false;
    }
    this.accumulator = accumulator;
    this.seed = seed;
    this.hasSeed = hasSeed;
  }
  ScanOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
  };
  return ScanOperator2;
}();
var ScanSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ScanSubscriber2, _super);
  function ScanSubscriber2(destination, accumulator, _seed, hasSeed) {
    var _this = _super.call(this, destination) || this;
    _this.accumulator = accumulator;
    _this._seed = _seed;
    _this.hasSeed = hasSeed;
    _this.index = 0;
    return _this;
  }
  Object.defineProperty(ScanSubscriber2.prototype, "seed", { get: function() {
    return this._seed;
  }, set: function(value) {
    this.hasSeed = true;
    this._seed = value;
  }, enumerable: true, configurable: true });
  ScanSubscriber2.prototype._next = function(value) {
    if (!this.hasSeed) {
      this.seed = value;
      this.destination.next(value);
    } else {
      return this._tryNext(value);
    }
  };
  ScanSubscriber2.prototype._tryNext = function(value) {
    var index2 = this.index++;
    var result;
    try {
      result = this.accumulator(this.seed, value, index2);
    } catch (err) {
      this.destination.error(err);
    }
    this.seed = result;
    this.destination.next(result);
  };
  return ScanSubscriber2;
}(Subscriber);
function reduce(accumulator, seed) {
  if (arguments.length >= 2) {
    return function reduceOperatorFunctionWithSeed(source2) {
      return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source2);
    };
  }
  return function reduceOperatorFunction(source2) {
    return pipe(scan(function(acc, value, index2) {
      return accumulator(acc, value, index2 + 1);
    }), takeLast(1))(source2);
  };
}
function max(comparer) {
  var max2 = typeof comparer === "function" ? function(x2, y2) {
    return comparer(x2, y2) > 0 ? x2 : y2;
  } : function(x2, y2) {
    return x2 > y2 ? x2 : y2;
  };
  return reduce(max2);
}
function merge$2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var concurrent = Number.POSITIVE_INFINITY;
  var scheduler2 = null;
  var last2 = observables[observables.length - 1];
  if (isScheduler(last2)) {
    scheduler2 = observables.pop();
    if (observables.length > 1 && typeof observables[observables.length - 1] === "number") {
      concurrent = observables.pop();
    }
  } else if (typeof last2 === "number") {
    concurrent = observables.pop();
  }
  if (scheduler2 === null && observables.length === 1 && observables[0] instanceof Observable) {
    return observables[0];
  }
  return mergeAll(concurrent)(fromArray(observables, scheduler2));
}
function merge$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source2) {
    return source2.lift.call(merge$2.apply(void 0, [source2].concat(observables)));
  };
}
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap(function() {
    return innerObservable;
  }, concurrent);
}
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return function(source2) {
    return source2.lift(new MergeScanOperator(accumulator, seed, concurrent));
  };
}
var MergeScanOperator = /* @__PURE__ */ function() {
  function MergeScanOperator2(accumulator, seed, concurrent) {
    this.accumulator = accumulator;
    this.seed = seed;
    this.concurrent = concurrent;
  }
  MergeScanOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
  };
  return MergeScanOperator2;
}();
var MergeScanSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MergeScanSubscriber2, _super);
  function MergeScanSubscriber2(destination, accumulator, acc, concurrent) {
    var _this = _super.call(this, destination) || this;
    _this.accumulator = accumulator;
    _this.acc = acc;
    _this.concurrent = concurrent;
    _this.hasValue = false;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }
  MergeScanSubscriber2.prototype._next = function(value) {
    if (this.active < this.concurrent) {
      var index2 = this.index++;
      var destination = this.destination;
      var ish = void 0;
      try {
        var accumulator = this.accumulator;
        ish = accumulator(this.acc, value, index2);
      } catch (e2) {
        return destination.error(e2);
      }
      this.active++;
      this._innerSub(ish);
    } else {
      this.buffer.push(value);
    }
  };
  MergeScanSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  MergeScanSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.active === 0 && this.buffer.length === 0) {
      if (this.hasValue === false) {
        this.destination.next(this.acc);
      }
      this.destination.complete();
    }
    this.unsubscribe();
  };
  MergeScanSubscriber2.prototype.notifyNext = function(innerValue) {
    var destination = this.destination;
    this.acc = innerValue;
    this.hasValue = true;
    destination.next(innerValue);
  };
  MergeScanSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2.length > 0) {
      this._next(buffer2.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      if (this.hasValue === false) {
        this.destination.next(this.acc);
      }
      this.destination.complete();
    }
  };
  return MergeScanSubscriber2;
}(SimpleOuterSubscriber);
function min(comparer) {
  var min2 = typeof comparer === "function" ? function(x2, y2) {
    return comparer(x2, y2) < 0 ? x2 : y2;
  } : function(x2, y2) {
    return x2 < y2 ? x2 : y2;
  };
  return reduce(min2);
}
function refCount() {
  return function refCountOperatorFunction(source2) {
    return source2.lift(new RefCountOperator(source2));
  };
}
var RefCountOperator = /* @__PURE__ */ function() {
  function RefCountOperator2(connectable) {
    this.connectable = connectable;
  }
  RefCountOperator2.prototype.call = function(subscriber, source2) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable);
    var subscription = source2.subscribe(refCounter);
    if (!refCounter.closed) {
      refCounter.connection = connectable.connect();
    }
    return subscription;
  };
  return RefCountOperator2;
}();
var RefCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RefCountSubscriber2, _super);
  function RefCountSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  RefCountSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (!connectable) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var refCount2 = connectable._refCount;
    if (refCount2 <= 0) {
      this.connection = null;
      return;
    }
    connectable._refCount = refCount2 - 1;
    if (refCount2 > 1) {
      this.connection = null;
      return;
    }
    var connection = this.connection;
    var sharedConnection = connectable._connection;
    this.connection = null;
    if (sharedConnection && (!connection || sharedConnection === connection)) {
      sharedConnection.unsubscribe();
    }
  };
  return RefCountSubscriber2;
}(Subscriber);
var ConnectableObservable = /* @__PURE__ */ function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source2, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source2;
    _this.subjectFactory = subjectFactory;
    _this._refCount = 0;
    _this._isComplete = false;
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype.connect = function() {
    var connection = this._connection;
    if (!connection) {
      this._isComplete = false;
      connection = this._connection = new Subscription();
      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);
var connectableObservableDescriptor = /* @__PURE__ */ function() {
  var connectableProto = ConnectableObservable.prototype;
  return { operator: { value: null }, _refCount: { value: 0, writable: true }, _subject: { value: null, writable: true }, _connection: { value: null, writable: true }, _subscribe: { value: connectableProto._subscribe }, _isComplete: { value: connectableProto._isComplete, writable: true }, getSubject: { value: connectableProto.getSubject }, connect: { value: connectableProto.connect }, refCount: { value: connectableProto.refCount } };
}();
var ConnectableSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ConnectableSubscriber2, _super);
  function ConnectableSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  ConnectableSubscriber2.prototype._error = function(err) {
    this._unsubscribe();
    _super.prototype._error.call(this, err);
  };
  ConnectableSubscriber2.prototype._complete = function() {
    this.connectable._isComplete = true;
    this._unsubscribe();
    _super.prototype._complete.call(this);
  };
  ConnectableSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (connectable) {
      this.connectable = null;
      var connection = connectable._connection;
      connectable._refCount = 0;
      connectable._subject = null;
      connectable._connection = null;
      if (connection) {
        connection.unsubscribe();
      }
    }
  };
  return ConnectableSubscriber2;
}(SubjectSubscriber);
function multicast(subjectOrSubjectFactory, selector) {
  return function multicastOperatorFunction(source2) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === "function") {
      subjectFactory = subjectOrSubjectFactory;
    } else {
      subjectFactory = function subjectFactory2() {
        return subjectOrSubjectFactory;
      };
    }
    if (typeof selector === "function") {
      return source2.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(source2, connectableObservableDescriptor);
    connectable.source = source2;
    connectable.subjectFactory = subjectFactory;
    return connectable;
  };
}
var MulticastOperator = /* @__PURE__ */ function() {
  function MulticastOperator2(subjectFactory, selector) {
    this.subjectFactory = subjectFactory;
    this.selector = selector;
  }
  MulticastOperator2.prototype.call = function(subscriber, source2) {
    var selector = this.selector;
    var subject = this.subjectFactory();
    var subscription = selector(subject).subscribe(subscriber);
    subscription.add(source2.subscribe(subject));
    return subscription;
  };
  return MulticastOperator2;
}();
function observeOn(scheduler2, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function observeOnOperatorFunction(source2) {
    return source2.lift(new ObserveOnOperator(scheduler2, delay2));
  };
}
var ObserveOnOperator = /* @__PURE__ */ function() {
  function ObserveOnOperator2(scheduler2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.scheduler = scheduler2;
    this.delay = delay2;
  }
  ObserveOnOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
  };
  return ObserveOnOperator2;
}();
var ObserveOnSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ObserveOnSubscriber2, _super);
  function ObserveOnSubscriber2(destination, scheduler2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    var _this = _super.call(this, destination) || this;
    _this.scheduler = scheduler2;
    _this.delay = delay2;
    return _this;
  }
  ObserveOnSubscriber2.dispatch = function(arg) {
    var notification = arg.notification, destination = arg.destination;
    notification.observe(destination);
    this.unsubscribe();
  };
  ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
    var destination = this.destination;
    destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
  };
  ObserveOnSubscriber2.prototype._next = function(value) {
    this.scheduleMessage(Notification.createNext(value));
  };
  ObserveOnSubscriber2.prototype._error = function(err) {
    this.scheduleMessage(Notification.createError(err));
    this.unsubscribe();
  };
  ObserveOnSubscriber2.prototype._complete = function() {
    this.scheduleMessage(Notification.createComplete());
    this.unsubscribe();
  };
  return ObserveOnSubscriber2;
}(Subscriber);
var ObserveOnMessage = /* @__PURE__ */ function() {
  function ObserveOnMessage2(notification, destination) {
    this.notification = notification;
    this.destination = destination;
  }
  return ObserveOnMessage2;
}();
function onErrorResumeNext() {
  var nextSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    nextSources[_i] = arguments[_i];
  }
  if (nextSources.length === 1 && isArray$2(nextSources[0])) {
    nextSources = nextSources[0];
  }
  return function(source2) {
    return source2.lift(new OnErrorResumeNextOperator(nextSources));
  };
}
var OnErrorResumeNextOperator = /* @__PURE__ */ function() {
  function OnErrorResumeNextOperator2(nextSources) {
    this.nextSources = nextSources;
  }
  OnErrorResumeNextOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
  };
  return OnErrorResumeNextOperator2;
}();
var OnErrorResumeNextSubscriber = /* @__PURE__ */ function(_super) {
  __extends(OnErrorResumeNextSubscriber2, _super);
  function OnErrorResumeNextSubscriber2(destination, nextSources) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.nextSources = nextSources;
    return _this;
  }
  OnErrorResumeNextSubscriber2.prototype.notifyError = function() {
    this.subscribeToNextSource();
  };
  OnErrorResumeNextSubscriber2.prototype.notifyComplete = function() {
    this.subscribeToNextSource();
  };
  OnErrorResumeNextSubscriber2.prototype._error = function(err) {
    this.subscribeToNextSource();
    this.unsubscribe();
  };
  OnErrorResumeNextSubscriber2.prototype._complete = function() {
    this.subscribeToNextSource();
    this.unsubscribe();
  };
  OnErrorResumeNextSubscriber2.prototype.subscribeToNextSource = function() {
    var next = this.nextSources.shift();
    if (!!next) {
      var innerSubscriber = new SimpleInnerSubscriber(this);
      var destination = this.destination;
      destination.add(innerSubscriber);
      var innerSubscription = innerSubscribe(next, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        destination.add(innerSubscription);
      }
    } else {
      this.destination.complete();
    }
  };
  return OnErrorResumeNextSubscriber2;
}(SimpleOuterSubscriber);
function pairwise() {
  return function(source2) {
    return source2.lift(new PairwiseOperator());
  };
}
var PairwiseOperator = /* @__PURE__ */ function() {
  function PairwiseOperator2() {
  }
  PairwiseOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new PairwiseSubscriber(subscriber));
  };
  return PairwiseOperator2;
}();
var PairwiseSubscriber = /* @__PURE__ */ function(_super) {
  __extends(PairwiseSubscriber2, _super);
  function PairwiseSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasPrev = false;
    return _this;
  }
  PairwiseSubscriber2.prototype._next = function(value) {
    var pair;
    if (this.hasPrev) {
      pair = [this.prev, value];
    } else {
      this.hasPrev = true;
    }
    this.prev = value;
    if (pair) {
      this.destination.next(pair);
    }
  };
  return PairwiseSubscriber2;
}(Subscriber);
function not(pred, thisArg) {
  function notPred() {
    return !notPred.pred.apply(notPred.thisArg, arguments);
  }
  notPred.pred = pred;
  notPred.thisArg = thisArg;
  return notPred;
}
function partition(predicate, thisArg) {
  return function(source2) {
    return [filter(predicate, thisArg)(source2), filter(not(predicate, thisArg))(source2)];
  };
}
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length2 = properties.length;
  if (length2 === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return function(source2) {
    return map(plucker(properties, length2))(source2);
  };
}
function plucker(props, length2) {
  var mapper = function(x2) {
    var currentProp = x2;
    for (var i2 = 0; i2 < length2; i2++) {
      var p2 = currentProp != null ? currentProp[props[i2]] : void 0;
      if (p2 !== void 0) {
        currentProp = p2;
      } else {
        return void 0;
      }
    }
    return currentProp;
  };
  return mapper;
}
function publish(selector) {
  return selector ? multicast(function() {
    return new Subject();
  }, selector) : multicast(new Subject());
}
var BehaviorSubject = /* @__PURE__ */ function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", { get: function() {
    return this.getValue();
  }, enumerable: true, configurable: true });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    if (subscription && !subscription.closed) {
      subscriber.next(this._value);
    }
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    if (this.hasError) {
      throw this.thrownError;
    } else if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return this._value;
    }
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);
function publishBehavior(value) {
  return function(source2) {
    return multicast(new BehaviorSubject(value))(source2);
  };
}
var AsyncSubject = /* @__PURE__ */ function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.value = null;
    _this.hasNext = false;
    _this.hasCompleted = false;
    return _this;
  }
  AsyncSubject2.prototype._subscribe = function(subscriber) {
    if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription.EMPTY;
    } else if (this.hasCompleted && this.hasNext) {
      subscriber.next(this.value);
      subscriber.complete();
      return Subscription.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.hasCompleted) {
      this.value = value;
      this.hasNext = true;
    }
  };
  AsyncSubject2.prototype.error = function(error) {
    if (!this.hasCompleted) {
      _super.prototype.error.call(this, error);
    }
  };
  AsyncSubject2.prototype.complete = function() {
    this.hasCompleted = true;
    if (this.hasNext) {
      _super.prototype.next.call(this, this.value);
    }
    _super.prototype.complete.call(this);
  };
  return AsyncSubject2;
}(Subject);
function publishLast() {
  return function(source2) {
    return multicast(new AsyncSubject())(source2);
  };
}
var QueueAction = /* @__PURE__ */ function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler2, work) {
    var _this = _super.call(this, scheduler2, work) || this;
    _this.scheduler = scheduler2;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state2, delay2);
    }
    this.delay = delay2;
    this.state = state2;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state2, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state2, delay2) : this._execute(state2, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler2, id2, delay2);
    }
    return scheduler2.flush(this);
  };
  return QueueAction2;
}(AsyncAction);
var QueueScheduler = /* @__PURE__ */ function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);
var queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction);
var queue = queueScheduler;
var ReplaySubject = /* @__PURE__ */ function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(bufferSize, windowTime2, scheduler2) {
    if (bufferSize === void 0) {
      bufferSize = Number.POSITIVE_INFINITY;
    }
    if (windowTime2 === void 0) {
      windowTime2 = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this) || this;
    _this.scheduler = scheduler2;
    _this._events = [];
    _this._infiniteTimeWindow = false;
    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
    _this._windowTime = windowTime2 < 1 ? 1 : windowTime2;
    if (windowTime2 === Number.POSITIVE_INFINITY) {
      _this._infiniteTimeWindow = true;
      _this.next = _this.nextInfiniteTimeWindow;
    } else {
      _this.next = _this.nextTimeWindow;
    }
    return _this;
  }
  ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value) {
    if (!this.isStopped) {
      var _events = this._events;
      _events.push(value);
      if (_events.length > this._bufferSize) {
        _events.shift();
      }
    }
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype.nextTimeWindow = function(value) {
    if (!this.isStopped) {
      this._events.push(new ReplayEvent(this._getNow(), value));
      this._trimBufferThenGetEvents();
    }
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    var _infiniteTimeWindow = this._infiniteTimeWindow;
    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
    var scheduler2 = this.scheduler;
    var len = _events.length;
    var subscription;
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.isStopped || this.hasError) {
      subscription = Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      subscription = new SubjectSubscription(this, subscriber);
    }
    if (scheduler2) {
      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler2));
    }
    if (_infiniteTimeWindow) {
      for (var i2 = 0; i2 < len && !subscriber.closed; i2++) {
        subscriber.next(_events[i2]);
      }
    } else {
      for (var i2 = 0; i2 < len && !subscriber.closed; i2++) {
        subscriber.next(_events[i2].value);
      }
    }
    if (this.hasError) {
      subscriber.error(this.thrownError);
    } else if (this.isStopped) {
      subscriber.complete();
    }
    return subscription;
  };
  ReplaySubject2.prototype._getNow = function() {
    return (this.scheduler || queue).now();
  };
  ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
    var now2 = this._getNow();
    var _bufferSize = this._bufferSize;
    var _windowTime = this._windowTime;
    var _events = this._events;
    var eventsCount = _events.length;
    var spliceCount = 0;
    while (spliceCount < eventsCount) {
      if (now2 - _events[spliceCount].time < _windowTime) {
        break;
      }
      spliceCount++;
    }
    if (eventsCount > _bufferSize) {
      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
    }
    if (spliceCount > 0) {
      _events.splice(0, spliceCount);
    }
    return _events;
  };
  return ReplaySubject2;
}(Subject);
var ReplayEvent = /* @__PURE__ */ function() {
  function ReplayEvent2(time, value) {
    this.time = time;
    this.value = value;
  }
  return ReplayEvent2;
}();
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, scheduler2) {
  if (selectorOrScheduler && typeof selectorOrScheduler !== "function") {
    scheduler2 = selectorOrScheduler;
  }
  var selector = typeof selectorOrScheduler === "function" ? selectorOrScheduler : void 0;
  var subject = new ReplaySubject(bufferSize, windowTime2, scheduler2);
  return function(source2) {
    return multicast(function() {
      return subject;
    }, selector)(source2);
  };
}
function race$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  if (observables.length === 1) {
    if (isArray$2(observables[0])) {
      observables = observables[0];
    } else {
      return observables[0];
    }
  }
  return fromArray(observables, void 0).lift(new RaceOperator());
}
var RaceOperator = /* @__PURE__ */ function() {
  function RaceOperator2() {
  }
  RaceOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RaceSubscriber(subscriber));
  };
  return RaceOperator2;
}();
var RaceSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RaceSubscriber2, _super);
  function RaceSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasFirst = false;
    _this.observables = [];
    _this.subscriptions = [];
    return _this;
  }
  RaceSubscriber2.prototype._next = function(observable2) {
    this.observables.push(observable2);
  };
  RaceSubscriber2.prototype._complete = function() {
    var observables = this.observables;
    var len = observables.length;
    if (len === 0) {
      this.destination.complete();
    } else {
      for (var i2 = 0; i2 < len && !this.hasFirst; i2++) {
        var observable2 = observables[i2];
        var subscription = subscribeToResult(this, observable2, void 0, i2);
        if (this.subscriptions) {
          this.subscriptions.push(subscription);
        }
        this.add(subscription);
      }
      this.observables = null;
    }
  };
  RaceSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    if (!this.hasFirst) {
      this.hasFirst = true;
      for (var i2 = 0; i2 < this.subscriptions.length; i2++) {
        if (i2 !== outerIndex) {
          var subscription = this.subscriptions[i2];
          subscription.unsubscribe();
          this.remove(subscription);
        }
      }
      this.subscriptions = null;
    }
    this.destination.next(innerValue);
  };
  return RaceSubscriber2;
}(OuterSubscriber);
function race() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function raceOperatorFunction(source2) {
    if (observables.length === 1 && isArray$2(observables[0])) {
      observables = observables[0];
    }
    return source2.lift.call(race$1.apply(void 0, [source2].concat(observables)));
  };
}
function repeat(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source2) {
    if (count2 === 0) {
      return empty$1();
    } else if (count2 < 0) {
      return source2.lift(new RepeatOperator(-1, source2));
    } else {
      return source2.lift(new RepeatOperator(count2 - 1, source2));
    }
  };
}
var RepeatOperator = /* @__PURE__ */ function() {
  function RepeatOperator2(count2, source2) {
    this.count = count2;
    this.source = source2;
  }
  RepeatOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
  };
  return RepeatOperator2;
}();
var RepeatSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RepeatSubscriber2, _super);
  function RepeatSubscriber2(destination, count2, source2) {
    var _this = _super.call(this, destination) || this;
    _this.count = count2;
    _this.source = source2;
    return _this;
  }
  RepeatSubscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      var _a2 = this, source2 = _a2.source, count2 = _a2.count;
      if (count2 === 0) {
        return _super.prototype.complete.call(this);
      } else if (count2 > -1) {
        this.count = count2 - 1;
      }
      source2.subscribe(this._unsubscribeAndRecycle());
    }
  };
  return RepeatSubscriber2;
}(Subscriber);
function repeatWhen(notifier) {
  return function(source2) {
    return source2.lift(new RepeatWhenOperator(notifier));
  };
}
var RepeatWhenOperator = /* @__PURE__ */ function() {
  function RepeatWhenOperator2(notifier) {
    this.notifier = notifier;
  }
  RepeatWhenOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source2));
  };
  return RepeatWhenOperator2;
}();
var RepeatWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RepeatWhenSubscriber2, _super);
  function RepeatWhenSubscriber2(destination, notifier, source2) {
    var _this = _super.call(this, destination) || this;
    _this.notifier = notifier;
    _this.source = source2;
    _this.sourceIsBeingSubscribedTo = true;
    return _this;
  }
  RepeatWhenSubscriber2.prototype.notifyNext = function() {
    this.sourceIsBeingSubscribedTo = true;
    this.source.subscribe(this);
  };
  RepeatWhenSubscriber2.prototype.notifyComplete = function() {
    if (this.sourceIsBeingSubscribedTo === false) {
      return _super.prototype.complete.call(this);
    }
  };
  RepeatWhenSubscriber2.prototype.complete = function() {
    this.sourceIsBeingSubscribedTo = false;
    if (!this.isStopped) {
      if (!this.retries) {
        this.subscribeToRetries();
      }
      if (!this.retriesSubscription || this.retriesSubscription.closed) {
        return _super.prototype.complete.call(this);
      }
      this._unsubscribeAndRecycle();
      this.notifications.next(void 0);
    }
  };
  RepeatWhenSubscriber2.prototype._unsubscribe = function() {
    var _a2 = this, notifications = _a2.notifications, retriesSubscription = _a2.retriesSubscription;
    if (notifications) {
      notifications.unsubscribe();
      this.notifications = void 0;
    }
    if (retriesSubscription) {
      retriesSubscription.unsubscribe();
      this.retriesSubscription = void 0;
    }
    this.retries = void 0;
  };
  RepeatWhenSubscriber2.prototype._unsubscribeAndRecycle = function() {
    var _unsubscribe = this._unsubscribe;
    this._unsubscribe = null;
    _super.prototype._unsubscribeAndRecycle.call(this);
    this._unsubscribe = _unsubscribe;
    return this;
  };
  RepeatWhenSubscriber2.prototype.subscribeToRetries = function() {
    this.notifications = new Subject();
    var retries;
    try {
      var notifier = this.notifier;
      retries = notifier(this.notifications);
    } catch (e2) {
      return _super.prototype.complete.call(this);
    }
    this.retries = retries;
    this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
  };
  return RepeatWhenSubscriber2;
}(SimpleOuterSubscriber);
function retry(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source2) {
    return source2.lift(new RetryOperator(count2, source2));
  };
}
var RetryOperator = /* @__PURE__ */ function() {
  function RetryOperator2(count2, source2) {
    this.count = count2;
    this.source = source2;
  }
  RetryOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
  };
  return RetryOperator2;
}();
var RetrySubscriber = /* @__PURE__ */ function(_super) {
  __extends(RetrySubscriber2, _super);
  function RetrySubscriber2(destination, count2, source2) {
    var _this = _super.call(this, destination) || this;
    _this.count = count2;
    _this.source = source2;
    return _this;
  }
  RetrySubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _a2 = this, source2 = _a2.source, count2 = _a2.count;
      if (count2 === 0) {
        return _super.prototype.error.call(this, err);
      } else if (count2 > -1) {
        this.count = count2 - 1;
      }
      source2.subscribe(this._unsubscribeAndRecycle());
    }
  };
  return RetrySubscriber2;
}(Subscriber);
function retryWhen(notifier) {
  return function(source2) {
    return source2.lift(new RetryWhenOperator(notifier, source2));
  };
}
var RetryWhenOperator = /* @__PURE__ */ function() {
  function RetryWhenOperator2(notifier, source2) {
    this.notifier = notifier;
    this.source = source2;
  }
  RetryWhenOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
  };
  return RetryWhenOperator2;
}();
var RetryWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RetryWhenSubscriber2, _super);
  function RetryWhenSubscriber2(destination, notifier, source2) {
    var _this = _super.call(this, destination) || this;
    _this.notifier = notifier;
    _this.source = source2;
    return _this;
  }
  RetryWhenSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var errors2 = this.errors;
      var retries = this.retries;
      var retriesSubscription = this.retriesSubscription;
      if (!retries) {
        errors2 = new Subject();
        try {
          var notifier = this.notifier;
          retries = notifier(errors2);
        } catch (e2) {
          return _super.prototype.error.call(this, e2);
        }
        retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
      } else {
        this.errors = void 0;
        this.retriesSubscription = void 0;
      }
      this._unsubscribeAndRecycle();
      this.errors = errors2;
      this.retries = retries;
      this.retriesSubscription = retriesSubscription;
      errors2.next(err);
    }
  };
  RetryWhenSubscriber2.prototype._unsubscribe = function() {
    var _a2 = this, errors2 = _a2.errors, retriesSubscription = _a2.retriesSubscription;
    if (errors2) {
      errors2.unsubscribe();
      this.errors = void 0;
    }
    if (retriesSubscription) {
      retriesSubscription.unsubscribe();
      this.retriesSubscription = void 0;
    }
    this.retries = void 0;
  };
  RetryWhenSubscriber2.prototype.notifyNext = function() {
    var _unsubscribe = this._unsubscribe;
    this._unsubscribe = null;
    this._unsubscribeAndRecycle();
    this._unsubscribe = _unsubscribe;
    this.source.subscribe(this);
  };
  return RetryWhenSubscriber2;
}(SimpleOuterSubscriber);
function sample(notifier) {
  return function(source2) {
    return source2.lift(new SampleOperator(notifier));
  };
}
var SampleOperator = /* @__PURE__ */ function() {
  function SampleOperator2(notifier) {
    this.notifier = notifier;
  }
  SampleOperator2.prototype.call = function(subscriber, source2) {
    var sampleSubscriber = new SampleSubscriber(subscriber);
    var subscription = source2.subscribe(sampleSubscriber);
    subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber)));
    return subscription;
  };
  return SampleOperator2;
}();
var SampleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SampleSubscriber2, _super);
  function SampleSubscriber2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.hasValue = false;
    return _this;
  }
  SampleSubscriber2.prototype._next = function(value) {
    this.value = value;
    this.hasValue = true;
  };
  SampleSubscriber2.prototype.notifyNext = function() {
    this.emitValue();
  };
  SampleSubscriber2.prototype.notifyComplete = function() {
    this.emitValue();
  };
  SampleSubscriber2.prototype.emitValue = function() {
    if (this.hasValue) {
      this.hasValue = false;
      this.destination.next(this.value);
    }
  };
  return SampleSubscriber2;
}(SimpleOuterSubscriber);
function sampleTime(period, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  return function(source2) {
    return source2.lift(new SampleTimeOperator(period, scheduler2));
  };
}
var SampleTimeOperator = /* @__PURE__ */ function() {
  function SampleTimeOperator2(period, scheduler2) {
    this.period = period;
    this.scheduler = scheduler2;
  }
  SampleTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
  };
  return SampleTimeOperator2;
}();
var SampleTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SampleTimeSubscriber2, _super);
  function SampleTimeSubscriber2(destination, period, scheduler2) {
    var _this = _super.call(this, destination) || this;
    _this.period = period;
    _this.scheduler = scheduler2;
    _this.hasValue = false;
    _this.add(scheduler2.schedule(dispatchNotification, period, { subscriber: _this, period }));
    return _this;
  }
  SampleTimeSubscriber2.prototype._next = function(value) {
    this.lastValue = value;
    this.hasValue = true;
  };
  SampleTimeSubscriber2.prototype.notifyNext = function() {
    if (this.hasValue) {
      this.hasValue = false;
      this.destination.next(this.lastValue);
    }
  };
  return SampleTimeSubscriber2;
}(Subscriber);
function dispatchNotification(state2) {
  var subscriber = state2.subscriber, period = state2.period;
  subscriber.notifyNext();
  this.schedule(state2, period);
}
function sequenceEqual(compareTo, comparator) {
  return function(source2) {
    return source2.lift(new SequenceEqualOperator(compareTo, comparator));
  };
}
var SequenceEqualOperator = /* @__PURE__ */ function() {
  function SequenceEqualOperator2(compareTo, comparator) {
    this.compareTo = compareTo;
    this.comparator = comparator;
  }
  SequenceEqualOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
  };
  return SequenceEqualOperator2;
}();
var SequenceEqualSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SequenceEqualSubscriber2, _super);
  function SequenceEqualSubscriber2(destination, compareTo, comparator) {
    var _this = _super.call(this, destination) || this;
    _this.compareTo = compareTo;
    _this.comparator = comparator;
    _this._a = [];
    _this._b = [];
    _this._oneComplete = false;
    _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
    return _this;
  }
  SequenceEqualSubscriber2.prototype._next = function(value) {
    if (this._oneComplete && this._b.length === 0) {
      this.emit(false);
    } else {
      this._a.push(value);
      this.checkValues();
    }
  };
  SequenceEqualSubscriber2.prototype._complete = function() {
    if (this._oneComplete) {
      this.emit(this._a.length === 0 && this._b.length === 0);
    } else {
      this._oneComplete = true;
    }
    this.unsubscribe();
  };
  SequenceEqualSubscriber2.prototype.checkValues = function() {
    var _c = this, _a2 = _c._a, _b = _c._b, comparator = _c.comparator;
    while (_a2.length > 0 && _b.length > 0) {
      var a = _a2.shift();
      var b = _b.shift();
      var areEqual = false;
      try {
        areEqual = comparator ? comparator(a, b) : a === b;
      } catch (e2) {
        this.destination.error(e2);
      }
      if (!areEqual) {
        this.emit(false);
      }
    }
  };
  SequenceEqualSubscriber2.prototype.emit = function(value) {
    var destination = this.destination;
    destination.next(value);
    destination.complete();
  };
  SequenceEqualSubscriber2.prototype.nextB = function(value) {
    if (this._oneComplete && this._a.length === 0) {
      this.emit(false);
    } else {
      this._b.push(value);
      this.checkValues();
    }
  };
  SequenceEqualSubscriber2.prototype.completeB = function() {
    if (this._oneComplete) {
      this.emit(this._a.length === 0 && this._b.length === 0);
    } else {
      this._oneComplete = true;
    }
  };
  return SequenceEqualSubscriber2;
}(Subscriber);
var SequenceEqualCompareToSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SequenceEqualCompareToSubscriber2, _super);
  function SequenceEqualCompareToSubscriber2(destination, parent2) {
    var _this = _super.call(this, destination) || this;
    _this.parent = parent2;
    return _this;
  }
  SequenceEqualCompareToSubscriber2.prototype._next = function(value) {
    this.parent.nextB(value);
  };
  SequenceEqualCompareToSubscriber2.prototype._error = function(err) {
    this.parent.error(err);
    this.unsubscribe();
  };
  SequenceEqualCompareToSubscriber2.prototype._complete = function() {
    this.parent.completeB();
    this.unsubscribe();
  };
  return SequenceEqualCompareToSubscriber2;
}(Subscriber);
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(source2) {
    return refCount()(multicast(shareSubjectFactory)(source2));
  };
}
function shareReplay(configOrBufferSize, windowTime2, scheduler2) {
  var config2;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    config2 = configOrBufferSize;
  } else {
    config2 = { bufferSize: configOrBufferSize, windowTime: windowTime2, refCount: false, scheduler: scheduler2 };
  }
  return function(source2) {
    return source2.lift(shareReplayOperator(config2));
  };
}
function shareReplayOperator(_a2) {
  var _b = _a2.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a2.windowTime, windowTime2 = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a2.refCount, scheduler2 = _a2.scheduler;
  var subject;
  var refCount2 = 0;
  var subscription;
  var hasError = false;
  var isComplete = false;
  return function shareReplayOperation(source2) {
    refCount2++;
    var innerSub;
    if (!subject || hasError) {
      hasError = false;
      subject = new ReplaySubject(bufferSize, windowTime2, scheduler2);
      innerSub = subject.subscribe(this);
      subscription = source2.subscribe({ next: function(value) {
        subject.next(value);
      }, error: function(err) {
        hasError = true;
        subject.error(err);
      }, complete: function() {
        isComplete = true;
        subscription = void 0;
        subject.complete();
      } });
      if (isComplete) {
        subscription = void 0;
      }
    } else {
      innerSub = subject.subscribe(this);
    }
    this.add(function() {
      refCount2--;
      innerSub.unsubscribe();
      innerSub = void 0;
      if (subscription && !isComplete && useRefCount && refCount2 === 0) {
        subscription.unsubscribe();
        subscription = void 0;
        subject = void 0;
      }
    });
  };
}
function single(predicate) {
  return function(source2) {
    return source2.lift(new SingleOperator(predicate, source2));
  };
}
var SingleOperator = /* @__PURE__ */ function() {
  function SingleOperator2(predicate, source2) {
    this.predicate = predicate;
    this.source = source2;
  }
  SingleOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
  };
  return SingleOperator2;
}();
var SingleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SingleSubscriber2, _super);
  function SingleSubscriber2(destination, predicate, source2) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source2;
    _this.seenValue = false;
    _this.index = 0;
    return _this;
  }
  SingleSubscriber2.prototype.applySingleValue = function(value) {
    if (this.seenValue) {
      this.destination.error("Sequence contains more than one element");
    } else {
      this.seenValue = true;
      this.singleValue = value;
    }
  };
  SingleSubscriber2.prototype._next = function(value) {
    var index2 = this.index++;
    if (this.predicate) {
      this.tryNext(value, index2);
    } else {
      this.applySingleValue(value);
    }
  };
  SingleSubscriber2.prototype.tryNext = function(value, index2) {
    try {
      if (this.predicate(value, index2, this.source)) {
        this.applySingleValue(value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  SingleSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    if (this.index > 0) {
      destination.next(this.seenValue ? this.singleValue : void 0);
      destination.complete();
    } else {
      destination.error(new EmptyError());
    }
  };
  return SingleSubscriber2;
}(Subscriber);
function skip(count2) {
  return function(source2) {
    return source2.lift(new SkipOperator(count2));
  };
}
var SkipOperator = /* @__PURE__ */ function() {
  function SkipOperator2(total) {
    this.total = total;
  }
  SkipOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SkipSubscriber(subscriber, this.total));
  };
  return SkipOperator2;
}();
var SkipSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipSubscriber2, _super);
  function SkipSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.count = 0;
    return _this;
  }
  SkipSubscriber2.prototype._next = function(x2) {
    if (++this.count > this.total) {
      this.destination.next(x2);
    }
  };
  return SkipSubscriber2;
}(Subscriber);
function skipLast(count2) {
  return function(source2) {
    return source2.lift(new SkipLastOperator(count2));
  };
}
var SkipLastOperator = /* @__PURE__ */ function() {
  function SkipLastOperator2(_skipCount) {
    this._skipCount = _skipCount;
    if (this._skipCount < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  SkipLastOperator2.prototype.call = function(subscriber, source2) {
    if (this._skipCount === 0) {
      return source2.subscribe(new Subscriber(subscriber));
    } else {
      return source2.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
    }
  };
  return SkipLastOperator2;
}();
var SkipLastSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipLastSubscriber2, _super);
  function SkipLastSubscriber2(destination, _skipCount) {
    var _this = _super.call(this, destination) || this;
    _this._skipCount = _skipCount;
    _this._count = 0;
    _this._ring = new Array(_skipCount);
    return _this;
  }
  SkipLastSubscriber2.prototype._next = function(value) {
    var skipCount = this._skipCount;
    var count2 = this._count++;
    if (count2 < skipCount) {
      this._ring[count2] = value;
    } else {
      var currentIndex = count2 % skipCount;
      var ring = this._ring;
      var oldValue = ring[currentIndex];
      ring[currentIndex] = value;
      this.destination.next(oldValue);
    }
  };
  return SkipLastSubscriber2;
}(Subscriber);
function skipUntil(notifier) {
  return function(source2) {
    return source2.lift(new SkipUntilOperator(notifier));
  };
}
var SkipUntilOperator = /* @__PURE__ */ function() {
  function SkipUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  SkipUntilOperator2.prototype.call = function(destination, source2) {
    return source2.subscribe(new SkipUntilSubscriber(destination, this.notifier));
  };
  return SkipUntilOperator2;
}();
var SkipUntilSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipUntilSubscriber2, _super);
  function SkipUntilSubscriber2(destination, notifier) {
    var _this = _super.call(this, destination) || this;
    _this.hasValue = false;
    var innerSubscriber = new SimpleInnerSubscriber(_this);
    _this.add(innerSubscriber);
    _this.innerSubscription = innerSubscriber;
    var innerSubscription = innerSubscribe(notifier, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      _this.add(innerSubscription);
      _this.innerSubscription = innerSubscription;
    }
    return _this;
  }
  SkipUntilSubscriber2.prototype._next = function(value) {
    if (this.hasValue) {
      _super.prototype._next.call(this, value);
    }
  };
  SkipUntilSubscriber2.prototype.notifyNext = function() {
    this.hasValue = true;
    if (this.innerSubscription) {
      this.innerSubscription.unsubscribe();
    }
  };
  SkipUntilSubscriber2.prototype.notifyComplete = function() {
  };
  return SkipUntilSubscriber2;
}(SimpleOuterSubscriber);
function skipWhile(predicate) {
  return function(source2) {
    return source2.lift(new SkipWhileOperator(predicate));
  };
}
var SkipWhileOperator = /* @__PURE__ */ function() {
  function SkipWhileOperator2(predicate) {
    this.predicate = predicate;
  }
  SkipWhileOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
  };
  return SkipWhileOperator2;
}();
var SkipWhileSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipWhileSubscriber2, _super);
  function SkipWhileSubscriber2(destination, predicate) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.skipping = true;
    _this.index = 0;
    return _this;
  }
  SkipWhileSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    if (this.skipping) {
      this.tryCallPredicate(value);
    }
    if (!this.skipping) {
      destination.next(value);
    }
  };
  SkipWhileSubscriber2.prototype.tryCallPredicate = function(value) {
    try {
      var result = this.predicate(value, this.index++);
      this.skipping = Boolean(result);
    } catch (err) {
      this.destination.error(err);
    }
  };
  return SkipWhileSubscriber2;
}(Subscriber);
function startWith() {
  var array = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array[_i] = arguments[_i];
  }
  var scheduler2 = array[array.length - 1];
  if (isScheduler(scheduler2)) {
    array.pop();
    return function(source2) {
      return concat$1(array, source2, scheduler2);
    };
  } else {
    return function(source2) {
      return concat$1(array, source2);
    };
  }
}
var nextHandle = 1;
var RESOLVED = /* @__PURE__ */ function() {
  return /* @__PURE__ */ Promise.resolve();
}();
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = { setImmediate: function(cb2) {
  var handle = nextHandle++;
  activeHandles[handle] = true;
  RESOLVED.then(function() {
    return findAndClearHandle(handle) && cb2();
  });
  return handle;
}, clearImmediate: function(handle) {
  findAndClearHandle(handle);
} };
var AsapAction = /* @__PURE__ */ function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler2, work) {
    var _this = _super.call(this, scheduler2, work) || this;
    _this.scheduler = scheduler2;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler2, id2, delay2);
    }
    scheduler2.actions.push(this);
    return scheduler2.scheduled || (scheduler2.scheduled = Immediate.setImmediate(scheduler2.flush.bind(scheduler2, null)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler2, id2, delay2);
    }
    if (scheduler2.actions.length === 0) {
      Immediate.clearImmediate(id2);
      scheduler2.scheduled = void 0;
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);
var AsapScheduler = /* @__PURE__ */ function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this.active = true;
    this.scheduled = void 0;
    var actions = this.actions;
    var error;
    var index2 = -1;
    var count2 = actions.length;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index2 < count2 && (action = actions.shift()));
    this.active = false;
    if (error) {
      while (++index2 < count2 && (action = actions.shift())) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);
var asapScheduler = /* @__PURE__ */ new AsapScheduler(AsapAction);
var asap = asapScheduler;
var SubscribeOnObservable = /* @__PURE__ */ function(_super) {
  __extends(SubscribeOnObservable2, _super);
  function SubscribeOnObservable2(source2, delayTime, scheduler2) {
    if (delayTime === void 0) {
      delayTime = 0;
    }
    if (scheduler2 === void 0) {
      scheduler2 = asap;
    }
    var _this = _super.call(this) || this;
    _this.source = source2;
    _this.delayTime = delayTime;
    _this.scheduler = scheduler2;
    if (!isNumeric(delayTime) || delayTime < 0) {
      _this.delayTime = 0;
    }
    if (!scheduler2 || typeof scheduler2.schedule !== "function") {
      _this.scheduler = asap;
    }
    return _this;
  }
  SubscribeOnObservable2.create = function(source2, delay2, scheduler2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (scheduler2 === void 0) {
      scheduler2 = asap;
    }
    return new SubscribeOnObservable2(source2, delay2, scheduler2);
  };
  SubscribeOnObservable2.dispatch = function(arg) {
    var source2 = arg.source, subscriber = arg.subscriber;
    return this.add(source2.subscribe(subscriber));
  };
  SubscribeOnObservable2.prototype._subscribe = function(subscriber) {
    var delay2 = this.delayTime;
    var source2 = this.source;
    var scheduler2 = this.scheduler;
    return scheduler2.schedule(SubscribeOnObservable2.dispatch, delay2, { source: source2, subscriber });
  };
  return SubscribeOnObservable2;
}(Observable);
function subscribeOn(scheduler2, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function subscribeOnOperatorFunction(source2) {
    return source2.lift(new SubscribeOnOperator(scheduler2, delay2));
  };
}
var SubscribeOnOperator = /* @__PURE__ */ function() {
  function SubscribeOnOperator2(scheduler2, delay2) {
    this.scheduler = scheduler2;
    this.delay = delay2;
  }
  SubscribeOnOperator2.prototype.call = function(subscriber, source2) {
    return new SubscribeOnObservable(source2, this.delay, this.scheduler).subscribe(subscriber);
  };
  return SubscribeOnOperator2;
}();
function switchMap(project, resultSelector) {
  if (typeof resultSelector === "function") {
    return function(source2) {
      return source2.pipe(switchMap(function(a, i2) {
        return from(project(a, i2)).pipe(map(function(b, ii2) {
          return resultSelector(a, b, i2, ii2);
        }));
      }));
    };
  }
  return function(source2) {
    return source2.lift(new SwitchMapOperator(project));
  };
}
var SwitchMapOperator = /* @__PURE__ */ function() {
  function SwitchMapOperator2(project) {
    this.project = project;
  }
  SwitchMapOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SwitchMapSubscriber(subscriber, this.project));
  };
  return SwitchMapOperator2;
}();
var SwitchMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SwitchMapSubscriber2, _super);
  function SwitchMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.index = 0;
    return _this;
  }
  SwitchMapSubscriber2.prototype._next = function(value) {
    var result;
    var index2 = this.index++;
    try {
      result = this.project(value, index2);
    } catch (error) {
      this.destination.error(error);
      return;
    }
    this._innerSub(result);
  };
  SwitchMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscription = this.innerSubscription;
    if (innerSubscription) {
      innerSubscription.unsubscribe();
    }
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    this.innerSubscription = innerSubscribe(result, innerSubscriber);
    if (this.innerSubscription !== innerSubscriber) {
      destination.add(this.innerSubscription);
    }
  };
  SwitchMapSubscriber2.prototype._complete = function() {
    var innerSubscription = this.innerSubscription;
    if (!innerSubscription || innerSubscription.closed) {
      _super.prototype._complete.call(this);
    }
    this.unsubscribe();
  };
  SwitchMapSubscriber2.prototype._unsubscribe = function() {
    this.innerSubscription = void 0;
  };
  SwitchMapSubscriber2.prototype.notifyComplete = function() {
    this.innerSubscription = void 0;
    if (this.isStopped) {
      _super.prototype._complete.call(this);
    }
  };
  SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  return SwitchMapSubscriber2;
}(SimpleOuterSubscriber);
function switchAll() {
  return switchMap(identity);
}
function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap(function() {
    return innerObservable;
  });
}
function takeUntil(notifier) {
  return function(source2) {
    return source2.lift(new TakeUntilOperator(notifier));
  };
}
var TakeUntilOperator = /* @__PURE__ */ function() {
  function TakeUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  TakeUntilOperator2.prototype.call = function(subscriber, source2) {
    var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
    var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
    if (notifierSubscription && !takeUntilSubscriber.seenValue) {
      takeUntilSubscriber.add(notifierSubscription);
      return source2.subscribe(takeUntilSubscriber);
    }
    return takeUntilSubscriber;
  };
  return TakeUntilOperator2;
}();
var TakeUntilSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeUntilSubscriber2, _super);
  function TakeUntilSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.seenValue = false;
    return _this;
  }
  TakeUntilSubscriber2.prototype.notifyNext = function() {
    this.seenValue = true;
    this.complete();
  };
  TakeUntilSubscriber2.prototype.notifyComplete = function() {
  };
  return TakeUntilSubscriber2;
}(SimpleOuterSubscriber);
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return function(source2) {
    return source2.lift(new TakeWhileOperator(predicate, inclusive));
  };
}
var TakeWhileOperator = /* @__PURE__ */ function() {
  function TakeWhileOperator2(predicate, inclusive) {
    this.predicate = predicate;
    this.inclusive = inclusive;
  }
  TakeWhileOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
  };
  return TakeWhileOperator2;
}();
var TakeWhileSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeWhileSubscriber2, _super);
  function TakeWhileSubscriber2(destination, predicate, inclusive) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.inclusive = inclusive;
    _this.index = 0;
    return _this;
  }
  TakeWhileSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    var result;
    try {
      result = this.predicate(value, this.index++);
    } catch (err) {
      destination.error(err);
      return;
    }
    this.nextOrComplete(value, result);
  };
  TakeWhileSubscriber2.prototype.nextOrComplete = function(value, predicateResult) {
    var destination = this.destination;
    if (Boolean(predicateResult)) {
      destination.next(value);
    } else {
      if (this.inclusive) {
        destination.next(value);
      }
      destination.complete();
    }
  };
  return TakeWhileSubscriber2;
}(Subscriber);
function noop$1() {
}
function tap(nextOrObserver, error, complete) {
  return function tapOperatorFunction(source2) {
    return source2.lift(new DoOperator(nextOrObserver, error, complete));
  };
}
var DoOperator = /* @__PURE__ */ function() {
  function DoOperator2(nextOrObserver, error, complete) {
    this.nextOrObserver = nextOrObserver;
    this.error = error;
    this.complete = complete;
  }
  DoOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
  };
  return DoOperator2;
}();
var TapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TapSubscriber2, _super);
  function TapSubscriber2(destination, observerOrNext, error, complete) {
    var _this = _super.call(this, destination) || this;
    _this._tapNext = noop$1;
    _this._tapError = noop$1;
    _this._tapComplete = noop$1;
    _this._tapError = error || noop$1;
    _this._tapComplete = complete || noop$1;
    if (isFunction$1(observerOrNext)) {
      _this._context = _this;
      _this._tapNext = observerOrNext;
    } else if (observerOrNext) {
      _this._context = observerOrNext;
      _this._tapNext = observerOrNext.next || noop$1;
      _this._tapError = observerOrNext.error || noop$1;
      _this._tapComplete = observerOrNext.complete || noop$1;
    }
    return _this;
  }
  TapSubscriber2.prototype._next = function(value) {
    try {
      this._tapNext.call(this._context, value);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(value);
  };
  TapSubscriber2.prototype._error = function(err) {
    try {
      this._tapError.call(this._context, err);
    } catch (err2) {
      this.destination.error(err2);
      return;
    }
    this.destination.error(err);
  };
  TapSubscriber2.prototype._complete = function() {
    try {
      this._tapComplete.call(this._context);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    return this.destination.complete();
  };
  return TapSubscriber2;
}(Subscriber);
var defaultThrottleConfig = { leading: true, trailing: false };
function throttle(durationSelector, config2) {
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source2) {
    return source2.lift(new ThrottleOperator(durationSelector, !!config2.leading, !!config2.trailing));
  };
}
var ThrottleOperator = /* @__PURE__ */ function() {
  function ThrottleOperator2(durationSelector, leading, trailing) {
    this.durationSelector = durationSelector;
    this.leading = leading;
    this.trailing = trailing;
  }
  ThrottleOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
  };
  return ThrottleOperator2;
}();
var ThrottleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrottleSubscriber2, _super);
  function ThrottleSubscriber2(destination, durationSelector, _leading, _trailing) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.durationSelector = durationSelector;
    _this._leading = _leading;
    _this._trailing = _trailing;
    _this._hasValue = false;
    return _this;
  }
  ThrottleSubscriber2.prototype._next = function(value) {
    this._hasValue = true;
    this._sendValue = value;
    if (!this._throttled) {
      if (this._leading) {
        this.send();
      } else {
        this.throttle(value);
      }
    }
  };
  ThrottleSubscriber2.prototype.send = function() {
    var _a2 = this, _hasValue = _a2._hasValue, _sendValue = _a2._sendValue;
    if (_hasValue) {
      this.destination.next(_sendValue);
      this.throttle(_sendValue);
    }
    this._hasValue = false;
    this._sendValue = void 0;
  };
  ThrottleSubscriber2.prototype.throttle = function(value) {
    var duration = this.tryDurationSelector(value);
    if (!!duration) {
      this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
    }
  };
  ThrottleSubscriber2.prototype.tryDurationSelector = function(value) {
    try {
      return this.durationSelector(value);
    } catch (err) {
      this.destination.error(err);
      return null;
    }
  };
  ThrottleSubscriber2.prototype.throttlingDone = function() {
    var _a2 = this, _throttled = _a2._throttled, _trailing = _a2._trailing;
    if (_throttled) {
      _throttled.unsubscribe();
    }
    this._throttled = void 0;
    if (_trailing) {
      this.send();
    }
  };
  ThrottleSubscriber2.prototype.notifyNext = function() {
    this.throttlingDone();
  };
  ThrottleSubscriber2.prototype.notifyComplete = function() {
    this.throttlingDone();
  };
  return ThrottleSubscriber2;
}(SimpleOuterSubscriber);
function throttleTime(duration, scheduler2, config2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source2) {
    return source2.lift(new ThrottleTimeOperator(duration, scheduler2, config2.leading, config2.trailing));
  };
}
var ThrottleTimeOperator = /* @__PURE__ */ function() {
  function ThrottleTimeOperator2(duration, scheduler2, leading, trailing) {
    this.duration = duration;
    this.scheduler = scheduler2;
    this.leading = leading;
    this.trailing = trailing;
  }
  ThrottleTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
  };
  return ThrottleTimeOperator2;
}();
var ThrottleTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrottleTimeSubscriber2, _super);
  function ThrottleTimeSubscriber2(destination, duration, scheduler2, leading, trailing) {
    var _this = _super.call(this, destination) || this;
    _this.duration = duration;
    _this.scheduler = scheduler2;
    _this.leading = leading;
    _this.trailing = trailing;
    _this._hasTrailingValue = false;
    _this._trailingValue = null;
    return _this;
  }
  ThrottleTimeSubscriber2.prototype._next = function(value) {
    if (this.throttled) {
      if (this.trailing) {
        this._trailingValue = value;
        this._hasTrailingValue = true;
      }
    } else {
      this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
      if (this.leading) {
        this.destination.next(value);
      } else if (this.trailing) {
        this._trailingValue = value;
        this._hasTrailingValue = true;
      }
    }
  };
  ThrottleTimeSubscriber2.prototype._complete = function() {
    if (this._hasTrailingValue) {
      this.destination.next(this._trailingValue);
      this.destination.complete();
    } else {
      this.destination.complete();
    }
  };
  ThrottleTimeSubscriber2.prototype.clearThrottle = function() {
    var throttled = this.throttled;
    if (throttled) {
      if (this.trailing && this._hasTrailingValue) {
        this.destination.next(this._trailingValue);
        this._trailingValue = null;
        this._hasTrailingValue = false;
      }
      throttled.unsubscribe();
      this.remove(throttled);
      this.throttled = null;
    }
  };
  return ThrottleTimeSubscriber2;
}(Subscriber);
function dispatchNext(arg) {
  var subscriber = arg.subscriber;
  subscriber.clearThrottle();
}
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    var input;
    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source2 = input ? from(input) : empty$1();
    return source2.subscribe(subscriber);
  });
}
function timeInterval(scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  return function(source2) {
    return defer(function() {
      return source2.pipe(scan(function(_a2, value) {
        var current = _a2.current;
        return { value, current: scheduler2.now(), last: current };
      }, { current: scheduler2.now(), value: void 0, last: void 0 }), map(function(_a2) {
        var current = _a2.current, last2 = _a2.last, value = _a2.value;
        return new TimeInterval(value, current - last2);
      }));
    });
  };
}
var TimeInterval = /* @__PURE__ */ function() {
  function TimeInterval2(value, interval) {
    this.value = value;
    this.interval = interval;
  }
  return TimeInterval2;
}();
var TimeoutErrorImpl = /* @__PURE__ */ function() {
  function TimeoutErrorImpl2() {
    Error.call(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    return this;
  }
  TimeoutErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return TimeoutErrorImpl2;
}();
var TimeoutError = TimeoutErrorImpl;
function timeoutWith(due, withObservable, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  return function(source2) {
    var absoluteTimeout = isDate$1(due);
    var waitFor = absoluteTimeout ? +due - scheduler2.now() : Math.abs(due);
    return source2.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler2));
  };
}
var TimeoutWithOperator = /* @__PURE__ */ function() {
  function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler2) {
    this.waitFor = waitFor;
    this.absoluteTimeout = absoluteTimeout;
    this.withObservable = withObservable;
    this.scheduler = scheduler2;
  }
  TimeoutWithOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  };
  return TimeoutWithOperator2;
}();
var TimeoutWithSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TimeoutWithSubscriber2, _super);
  function TimeoutWithSubscriber2(destination, absoluteTimeout, waitFor, withObservable, scheduler2) {
    var _this = _super.call(this, destination) || this;
    _this.absoluteTimeout = absoluteTimeout;
    _this.waitFor = waitFor;
    _this.withObservable = withObservable;
    _this.scheduler = scheduler2;
    _this.scheduleTimeout();
    return _this;
  }
  TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
    var withObservable = subscriber.withObservable;
    subscriber._unsubscribeAndRecycle();
    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
  };
  TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
    var action = this.action;
    if (action) {
      this.action = action.schedule(this, this.waitFor);
    } else {
      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
    }
  };
  TimeoutWithSubscriber2.prototype._next = function(value) {
    if (!this.absoluteTimeout) {
      this.scheduleTimeout();
    }
    _super.prototype._next.call(this, value);
  };
  TimeoutWithSubscriber2.prototype._unsubscribe = function() {
    this.action = void 0;
    this.scheduler = null;
    this.withObservable = null;
  };
  return TimeoutWithSubscriber2;
}(SimpleOuterSubscriber);
function timeout(due, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  return timeoutWith(due, throwError(new TimeoutError()), scheduler2);
}
function timestamp(scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async;
  }
  return map(function(value) {
    return new Timestamp(value, scheduler2.now());
  });
}
var Timestamp = /* @__PURE__ */ function() {
  function Timestamp2(value, timestamp2) {
    this.value = value;
    this.timestamp = timestamp2;
  }
  return Timestamp2;
}();
function toArrayReducer(arr, item, index2) {
  if (index2 === 0) {
    return [item];
  }
  arr.push(item);
  return arr;
}
function toArray() {
  return reduce(toArrayReducer, []);
}
function window$1(windowBoundaries) {
  return function windowOperatorFunction(source2) {
    return source2.lift(new WindowOperator$1(windowBoundaries));
  };
}
var WindowOperator$1 = /* @__PURE__ */ function() {
  function WindowOperator2(windowBoundaries) {
    this.windowBoundaries = windowBoundaries;
  }
  WindowOperator2.prototype.call = function(subscriber, source2) {
    var windowSubscriber = new WindowSubscriber$1(subscriber);
    var sourceSubscription = source2.subscribe(windowSubscriber);
    if (!sourceSubscription.closed) {
      windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber)));
    }
    return sourceSubscription;
  };
  return WindowOperator2;
}();
var WindowSubscriber$1 = /* @__PURE__ */ function(_super) {
  __extends(WindowSubscriber2, _super);
  function WindowSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.window = new Subject();
    destination.next(_this.window);
    return _this;
  }
  WindowSubscriber2.prototype.notifyNext = function() {
    this.openWindow();
  };
  WindowSubscriber2.prototype.notifyError = function(error) {
    this._error(error);
  };
  WindowSubscriber2.prototype.notifyComplete = function() {
    this._complete();
  };
  WindowSubscriber2.prototype._next = function(value) {
    this.window.next(value);
  };
  WindowSubscriber2.prototype._error = function(err) {
    this.window.error(err);
    this.destination.error(err);
  };
  WindowSubscriber2.prototype._complete = function() {
    this.window.complete();
    this.destination.complete();
  };
  WindowSubscriber2.prototype._unsubscribe = function() {
    this.window = null;
  };
  WindowSubscriber2.prototype.openWindow = function() {
    var prevWindow = this.window;
    if (prevWindow) {
      prevWindow.complete();
    }
    var destination = this.destination;
    var newWindow = this.window = new Subject();
    destination.next(newWindow);
  };
  return WindowSubscriber2;
}(SimpleOuterSubscriber);
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }
  return function windowCountOperatorFunction(source2) {
    return source2.lift(new WindowCountOperator(windowSize, startWindowEvery));
  };
}
var WindowCountOperator = /* @__PURE__ */ function() {
  function WindowCountOperator2(windowSize, startWindowEvery) {
    this.windowSize = windowSize;
    this.startWindowEvery = startWindowEvery;
  }
  WindowCountOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
  };
  return WindowCountOperator2;
}();
var WindowCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowCountSubscriber2, _super);
  function WindowCountSubscriber2(destination, windowSize, startWindowEvery) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.windowSize = windowSize;
    _this.startWindowEvery = startWindowEvery;
    _this.windows = [new Subject()];
    _this.count = 0;
    destination.next(_this.windows[0]);
    return _this;
  }
  WindowCountSubscriber2.prototype._next = function(value) {
    var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
    var destination = this.destination;
    var windowSize = this.windowSize;
    var windows = this.windows;
    var len = windows.length;
    for (var i2 = 0; i2 < len && !this.closed; i2++) {
      windows[i2].next(value);
    }
    var c = this.count - windowSize + 1;
    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
      windows.shift().complete();
    }
    if (++this.count % startWindowEvery === 0 && !this.closed) {
      var window_1 = new Subject();
      windows.push(window_1);
      destination.next(window_1);
    }
  };
  WindowCountSubscriber2.prototype._error = function(err) {
    var windows = this.windows;
    if (windows) {
      while (windows.length > 0 && !this.closed) {
        windows.shift().error(err);
      }
    }
    this.destination.error(err);
  };
  WindowCountSubscriber2.prototype._complete = function() {
    var windows = this.windows;
    if (windows) {
      while (windows.length > 0 && !this.closed) {
        windows.shift().complete();
      }
    }
    this.destination.complete();
  };
  WindowCountSubscriber2.prototype._unsubscribe = function() {
    this.count = 0;
    this.windows = null;
  };
  return WindowCountSubscriber2;
}(Subscriber);
function windowTime(windowTimeSpan) {
  var scheduler2 = async;
  var windowCreationInterval = null;
  var maxWindowSize = Number.POSITIVE_INFINITY;
  if (isScheduler(arguments[3])) {
    scheduler2 = arguments[3];
  }
  if (isScheduler(arguments[2])) {
    scheduler2 = arguments[2];
  } else if (isNumeric(arguments[2])) {
    maxWindowSize = Number(arguments[2]);
  }
  if (isScheduler(arguments[1])) {
    scheduler2 = arguments[1];
  } else if (isNumeric(arguments[1])) {
    windowCreationInterval = Number(arguments[1]);
  }
  return function windowTimeOperatorFunction(source2) {
    return source2.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler2));
  };
}
var WindowTimeOperator = /* @__PURE__ */ function() {
  function WindowTimeOperator2(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler2) {
    this.windowTimeSpan = windowTimeSpan;
    this.windowCreationInterval = windowCreationInterval;
    this.maxWindowSize = maxWindowSize;
    this.scheduler = scheduler2;
  }
  WindowTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
  };
  return WindowTimeOperator2;
}();
var CountedSubject = /* @__PURE__ */ function(_super) {
  __extends(CountedSubject2, _super);
  function CountedSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._numberOfNextedValues = 0;
    return _this;
  }
  CountedSubject2.prototype.next = function(value) {
    this._numberOfNextedValues++;
    _super.prototype.next.call(this, value);
  };
  Object.defineProperty(CountedSubject2.prototype, "numberOfNextedValues", { get: function() {
    return this._numberOfNextedValues;
  }, enumerable: true, configurable: true });
  return CountedSubject2;
}(Subject);
var WindowTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowTimeSubscriber2, _super);
  function WindowTimeSubscriber2(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler2) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.windowTimeSpan = windowTimeSpan;
    _this.windowCreationInterval = windowCreationInterval;
    _this.maxWindowSize = maxWindowSize;
    _this.scheduler = scheduler2;
    _this.windows = [];
    var window2 = _this.openWindow();
    if (windowCreationInterval !== null && windowCreationInterval >= 0) {
      var closeState = { subscriber: _this, window: window2, context: null };
      var creationState = { windowTimeSpan, windowCreationInterval, subscriber: _this, scheduler: scheduler2 };
      _this.add(scheduler2.schedule(dispatchWindowClose, windowTimeSpan, closeState));
      _this.add(scheduler2.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
    } else {
      var timeSpanOnlyState = { subscriber: _this, window: window2, windowTimeSpan };
      _this.add(scheduler2.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
    }
    return _this;
  }
  WindowTimeSubscriber2.prototype._next = function(value) {
    var windows = this.windows;
    var len = windows.length;
    for (var i2 = 0; i2 < len; i2++) {
      var window_1 = windows[i2];
      if (!window_1.closed) {
        window_1.next(value);
        if (window_1.numberOfNextedValues >= this.maxWindowSize) {
          this.closeWindow(window_1);
        }
      }
    }
  };
  WindowTimeSubscriber2.prototype._error = function(err) {
    var windows = this.windows;
    while (windows.length > 0) {
      windows.shift().error(err);
    }
    this.destination.error(err);
  };
  WindowTimeSubscriber2.prototype._complete = function() {
    var windows = this.windows;
    while (windows.length > 0) {
      var window_2 = windows.shift();
      if (!window_2.closed) {
        window_2.complete();
      }
    }
    this.destination.complete();
  };
  WindowTimeSubscriber2.prototype.openWindow = function() {
    var window2 = new CountedSubject();
    this.windows.push(window2);
    var destination = this.destination;
    destination.next(window2);
    return window2;
  };
  WindowTimeSubscriber2.prototype.closeWindow = function(window2) {
    window2.complete();
    var windows = this.windows;
    windows.splice(windows.indexOf(window2), 1);
  };
  return WindowTimeSubscriber2;
}(Subscriber);
function dispatchWindowTimeSpanOnly(state2) {
  var subscriber = state2.subscriber, windowTimeSpan = state2.windowTimeSpan, window2 = state2.window;
  if (window2) {
    subscriber.closeWindow(window2);
  }
  state2.window = subscriber.openWindow();
  this.schedule(state2, windowTimeSpan);
}
function dispatchWindowCreation(state2) {
  var windowTimeSpan = state2.windowTimeSpan, subscriber = state2.subscriber, scheduler2 = state2.scheduler, windowCreationInterval = state2.windowCreationInterval;
  var window2 = subscriber.openWindow();
  var action = this;
  var context2 = { action, subscription: null };
  var timeSpanState = { subscriber, window: window2, context: context2 };
  context2.subscription = scheduler2.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
  action.add(context2.subscription);
  action.schedule(state2, windowCreationInterval);
}
function dispatchWindowClose(state2) {
  var subscriber = state2.subscriber, window2 = state2.window, context2 = state2.context;
  if (context2 && context2.action && context2.subscription) {
    context2.action.remove(context2.subscription);
  }
  subscriber.closeWindow(window2);
}
function windowToggle(openings, closingSelector) {
  return function(source2) {
    return source2.lift(new WindowToggleOperator(openings, closingSelector));
  };
}
var WindowToggleOperator = /* @__PURE__ */ function() {
  function WindowToggleOperator2(openings, closingSelector) {
    this.openings = openings;
    this.closingSelector = closingSelector;
  }
  WindowToggleOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
  };
  return WindowToggleOperator2;
}();
var WindowToggleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowToggleSubscriber2, _super);
  function WindowToggleSubscriber2(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.openings = openings;
    _this.closingSelector = closingSelector;
    _this.contexts = [];
    _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
    return _this;
  }
  WindowToggleSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    if (contexts) {
      var len = contexts.length;
      for (var i2 = 0; i2 < len; i2++) {
        contexts[i2].window.next(value);
      }
    }
  };
  WindowToggleSubscriber2.prototype._error = function(err) {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len = contexts.length;
      var index2 = -1;
      while (++index2 < len) {
        var context_1 = contexts[index2];
        context_1.window.error(err);
        context_1.subscription.unsubscribe();
      }
    }
    _super.prototype._error.call(this, err);
  };
  WindowToggleSubscriber2.prototype._complete = function() {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len = contexts.length;
      var index2 = -1;
      while (++index2 < len) {
        var context_2 = contexts[index2];
        context_2.window.complete();
        context_2.subscription.unsubscribe();
      }
    }
    _super.prototype._complete.call(this);
  };
  WindowToggleSubscriber2.prototype._unsubscribe = function() {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len = contexts.length;
      var index2 = -1;
      while (++index2 < len) {
        var context_3 = contexts[index2];
        context_3.window.unsubscribe();
        context_3.subscription.unsubscribe();
      }
    }
  };
  WindowToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    if (outerValue === this.openings) {
      var closingNotifier = void 0;
      try {
        var closingSelector = this.closingSelector;
        closingNotifier = closingSelector(innerValue);
      } catch (e2) {
        return this.error(e2);
      }
      var window_1 = new Subject();
      var subscription = new Subscription();
      var context_4 = { window: window_1, subscription };
      this.contexts.push(context_4);
      var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
      if (innerSubscription.closed) {
        this.closeWindow(this.contexts.length - 1);
      } else {
        innerSubscription.context = context_4;
        subscription.add(innerSubscription);
      }
      this.destination.next(window_1);
    } else {
      this.closeWindow(this.contexts.indexOf(outerValue));
    }
  };
  WindowToggleSubscriber2.prototype.notifyError = function(err) {
    this.error(err);
  };
  WindowToggleSubscriber2.prototype.notifyComplete = function(inner) {
    if (inner !== this.openSubscription) {
      this.closeWindow(this.contexts.indexOf(inner.context));
    }
  };
  WindowToggleSubscriber2.prototype.closeWindow = function(index2) {
    if (index2 === -1) {
      return;
    }
    var contexts = this.contexts;
    var context2 = contexts[index2];
    var window2 = context2.window, subscription = context2.subscription;
    contexts.splice(index2, 1);
    window2.complete();
    subscription.unsubscribe();
  };
  return WindowToggleSubscriber2;
}(OuterSubscriber);
function windowWhen(closingSelector) {
  return function windowWhenOperatorFunction(source2) {
    return source2.lift(new WindowOperator(closingSelector));
  };
}
var WindowOperator = /* @__PURE__ */ function() {
  function WindowOperator2(closingSelector) {
    this.closingSelector = closingSelector;
  }
  WindowOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
  };
  return WindowOperator2;
}();
var WindowSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowSubscriber2, _super);
  function WindowSubscriber2(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.closingSelector = closingSelector;
    _this.openWindow();
    return _this;
  }
  WindowSubscriber2.prototype.notifyNext = function(_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
    this.openWindow(innerSub);
  };
  WindowSubscriber2.prototype.notifyError = function(error) {
    this._error(error);
  };
  WindowSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.openWindow(innerSub);
  };
  WindowSubscriber2.prototype._next = function(value) {
    this.window.next(value);
  };
  WindowSubscriber2.prototype._error = function(err) {
    this.window.error(err);
    this.destination.error(err);
    this.unsubscribeClosingNotification();
  };
  WindowSubscriber2.prototype._complete = function() {
    this.window.complete();
    this.destination.complete();
    this.unsubscribeClosingNotification();
  };
  WindowSubscriber2.prototype.unsubscribeClosingNotification = function() {
    if (this.closingNotification) {
      this.closingNotification.unsubscribe();
    }
  };
  WindowSubscriber2.prototype.openWindow = function(innerSub) {
    if (innerSub === void 0) {
      innerSub = null;
    }
    if (innerSub) {
      this.remove(innerSub);
      innerSub.unsubscribe();
    }
    var prevWindow = this.window;
    if (prevWindow) {
      prevWindow.complete();
    }
    var window2 = this.window = new Subject();
    this.destination.next(window2);
    var closingNotifier;
    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (e2) {
      this.destination.error(e2);
      this.window.error(e2);
      return;
    }
    this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
  };
  return WindowSubscriber2;
}(OuterSubscriber);
function withLatestFrom() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return function(source2) {
    var project;
    if (typeof args[args.length - 1] === "function") {
      project = args.pop();
    }
    var observables = args;
    return source2.lift(new WithLatestFromOperator(observables, project));
  };
}
var WithLatestFromOperator = /* @__PURE__ */ function() {
  function WithLatestFromOperator2(observables, project) {
    this.observables = observables;
    this.project = project;
  }
  WithLatestFromOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
  };
  return WithLatestFromOperator2;
}();
var WithLatestFromSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WithLatestFromSubscriber2, _super);
  function WithLatestFromSubscriber2(destination, observables, project) {
    var _this = _super.call(this, destination) || this;
    _this.observables = observables;
    _this.project = project;
    _this.toRespond = [];
    var len = observables.length;
    _this.values = new Array(len);
    for (var i2 = 0; i2 < len; i2++) {
      _this.toRespond.push(i2);
    }
    for (var i2 = 0; i2 < len; i2++) {
      var observable2 = observables[i2];
      _this.add(subscribeToResult(_this, observable2, void 0, i2));
    }
    return _this;
  }
  WithLatestFromSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    this.values[outerIndex] = innerValue;
    var toRespond = this.toRespond;
    if (toRespond.length > 0) {
      var found = toRespond.indexOf(outerIndex);
      if (found !== -1) {
        toRespond.splice(found, 1);
      }
    }
  };
  WithLatestFromSubscriber2.prototype.notifyComplete = function() {
  };
  WithLatestFromSubscriber2.prototype._next = function(value) {
    if (this.toRespond.length === 0) {
      var args = [value].concat(this.values);
      if (this.project) {
        this._tryProject(args);
      } else {
        this.destination.next(args);
      }
    }
  };
  WithLatestFromSubscriber2.prototype._tryProject = function(args) {
    var result;
    try {
      result = this.project.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return WithLatestFromSubscriber2;
}(OuterSubscriber);
function zip$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = observables[observables.length - 1];
  if (typeof resultSelector === "function") {
    observables.pop();
  }
  return fromArray(observables, void 0).lift(new ZipOperator(resultSelector));
}
var ZipOperator = /* @__PURE__ */ function() {
  function ZipOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  ZipOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
  };
  return ZipOperator2;
}();
var ZipSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ZipSubscriber2, _super);
  function ZipSubscriber2(destination, resultSelector, values2) {
    var _this = _super.call(this, destination) || this;
    _this.resultSelector = resultSelector;
    _this.iterators = [];
    _this.active = 0;
    _this.resultSelector = typeof resultSelector === "function" ? resultSelector : void 0;
    return _this;
  }
  ZipSubscriber2.prototype._next = function(value) {
    var iterators = this.iterators;
    if (isArray$2(value)) {
      iterators.push(new StaticArrayIterator(value));
    } else if (typeof value[iterator] === "function") {
      iterators.push(new StaticIterator(value[iterator]()));
    } else {
      iterators.push(new ZipBufferIterator(this.destination, this, value));
    }
  };
  ZipSubscriber2.prototype._complete = function() {
    var iterators = this.iterators;
    var len = iterators.length;
    this.unsubscribe();
    if (len === 0) {
      this.destination.complete();
      return;
    }
    this.active = len;
    for (var i2 = 0; i2 < len; i2++) {
      var iterator2 = iterators[i2];
      if (iterator2.stillUnsubscribed) {
        var destination = this.destination;
        destination.add(iterator2.subscribe());
      } else {
        this.active--;
      }
    }
  };
  ZipSubscriber2.prototype.notifyInactive = function() {
    this.active--;
    if (this.active === 0) {
      this.destination.complete();
    }
  };
  ZipSubscriber2.prototype.checkIterators = function() {
    var iterators = this.iterators;
    var len = iterators.length;
    var destination = this.destination;
    for (var i2 = 0; i2 < len; i2++) {
      var iterator2 = iterators[i2];
      if (typeof iterator2.hasValue === "function" && !iterator2.hasValue()) {
        return;
      }
    }
    var shouldComplete = false;
    var args = [];
    for (var i2 = 0; i2 < len; i2++) {
      var iterator2 = iterators[i2];
      var result = iterator2.next();
      if (iterator2.hasCompleted()) {
        shouldComplete = true;
      }
      if (result.done) {
        destination.complete();
        return;
      }
      args.push(result.value);
    }
    if (this.resultSelector) {
      this._tryresultSelector(args);
    } else {
      destination.next(args);
    }
    if (shouldComplete) {
      destination.complete();
    }
  };
  ZipSubscriber2.prototype._tryresultSelector = function(args) {
    var result;
    try {
      result = this.resultSelector.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return ZipSubscriber2;
}(Subscriber);
var StaticIterator = /* @__PURE__ */ function() {
  function StaticIterator2(iterator2) {
    this.iterator = iterator2;
    this.nextResult = iterator2.next();
  }
  StaticIterator2.prototype.hasValue = function() {
    return true;
  };
  StaticIterator2.prototype.next = function() {
    var result = this.nextResult;
    this.nextResult = this.iterator.next();
    return result;
  };
  StaticIterator2.prototype.hasCompleted = function() {
    var nextResult = this.nextResult;
    return Boolean(nextResult && nextResult.done);
  };
  return StaticIterator2;
}();
var StaticArrayIterator = /* @__PURE__ */ function() {
  function StaticArrayIterator2(array) {
    this.array = array;
    this.index = 0;
    this.length = 0;
    this.length = array.length;
  }
  StaticArrayIterator2.prototype[iterator] = function() {
    return this;
  };
  StaticArrayIterator2.prototype.next = function(value) {
    var i2 = this.index++;
    var array = this.array;
    return i2 < this.length ? { value: array[i2], done: false } : { value: null, done: true };
  };
  StaticArrayIterator2.prototype.hasValue = function() {
    return this.array.length > this.index;
  };
  StaticArrayIterator2.prototype.hasCompleted = function() {
    return this.array.length === this.index;
  };
  return StaticArrayIterator2;
}();
var ZipBufferIterator = /* @__PURE__ */ function(_super) {
  __extends(ZipBufferIterator2, _super);
  function ZipBufferIterator2(destination, parent2, observable2) {
    var _this = _super.call(this, destination) || this;
    _this.parent = parent2;
    _this.observable = observable2;
    _this.stillUnsubscribed = true;
    _this.buffer = [];
    _this.isComplete = false;
    return _this;
  }
  ZipBufferIterator2.prototype[iterator] = function() {
    return this;
  };
  ZipBufferIterator2.prototype.next = function() {
    var buffer2 = this.buffer;
    if (buffer2.length === 0 && this.isComplete) {
      return { value: null, done: true };
    } else {
      return { value: buffer2.shift(), done: false };
    }
  };
  ZipBufferIterator2.prototype.hasValue = function() {
    return this.buffer.length > 0;
  };
  ZipBufferIterator2.prototype.hasCompleted = function() {
    return this.buffer.length === 0 && this.isComplete;
  };
  ZipBufferIterator2.prototype.notifyComplete = function() {
    if (this.buffer.length > 0) {
      this.isComplete = true;
      this.parent.notifyInactive();
    } else {
      this.destination.complete();
    }
  };
  ZipBufferIterator2.prototype.notifyNext = function(innerValue) {
    this.buffer.push(innerValue);
    this.parent.checkIterators();
  };
  ZipBufferIterator2.prototype.subscribe = function() {
    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
  };
  return ZipBufferIterator2;
}(SimpleOuterSubscriber);
function zip() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function zipOperatorFunction(source2) {
    return source2.lift.call(zip$1.apply(void 0, [source2].concat(observables)));
  };
}
function zipAll(project) {
  return function(source2) {
    return source2.lift(new ZipOperator(project));
  };
}
var operators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, audit, auditTime, buffer, bufferCount, bufferTime, bufferToggle, bufferWhen, catchError, combineAll, combineLatest, concat, concatAll, concatMap, concatMapTo, count, debounce, debounceTime, defaultIfEmpty, delay, delayWhen, dematerialize, distinct, distinctUntilChanged, distinctUntilKeyChanged, elementAt, endWith, every, exhaust, exhaustMap, expand, filter, finalize, find: find$1, findIndex, first, groupBy, ignoreElements, isEmpty, last, map, mapTo, materialize, max, merge: merge$1, mergeAll, mergeMap, flatMap, mergeMapTo, mergeScan, min, multicast, observeOn, onErrorResumeNext, pairwise, partition, pluck, publish, publishBehavior, publishLast, publishReplay, race, reduce, repeat, repeatWhen, retry, retryWhen, refCount, sample, sampleTime, scan, sequenceEqual, share, shareReplay, single, skip, skipLast, skipUntil, skipWhile, startWith, subscribeOn, switchAll, switchMap, switchMapTo, take, takeLast, takeUntil, takeWhile, tap, throttle, throttleTime, throwIfEmpty, timeInterval, timeout, timeoutWith, timestamp, toArray, window: window$1, windowCount, windowTime, windowToggle, windowWhen, withLatestFrom, zip, zipAll }, Symbol.toStringTag, { value: "Module" }));
var require$$2 = /* @__PURE__ */ getAugmentedNamespace(operators);
var struct = {};
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m2[k];
    } });
  } : function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ListValue = exports2.Value = exports2.Struct_FieldsEntry = exports2.Struct = exports2.nullValueToNumber = exports2.nullValueToJSON = exports2.nullValueFromJSON = exports2.NullValue = exports2.protobufPackage = void 0;
  const long_12 = __importDefault2(umd.exports);
  const _m02 = __importStar2(minimal);
  exports2.protobufPackage = "google.protobuf";
  var NullValue;
  (function(NullValue2) {
    NullValue2["NULL_VALUE"] = "NULL_VALUE";
  })(NullValue = exports2.NullValue || (exports2.NullValue = {}));
  function nullValueFromJSON(object) {
    switch (object) {
      case 0:
      case "NULL_VALUE":
        return NullValue.NULL_VALUE;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum NullValue");
    }
  }
  exports2.nullValueFromJSON = nullValueFromJSON;
  function nullValueToJSON(object) {
    switch (object) {
      case NullValue.NULL_VALUE:
        return "NULL_VALUE";
      default:
        return "UNKNOWN";
    }
  }
  exports2.nullValueToJSON = nullValueToJSON;
  function nullValueToNumber(object) {
    switch (object) {
      case NullValue.NULL_VALUE:
        return 0;
      default:
        return 0;
    }
  }
  exports2.nullValueToNumber = nullValueToNumber;
  function createBaseStruct() {
    return { fields: {} };
  }
  exports2.Struct = { encode(message, writer2 = _m02.Writer.create()) {
    Object.entries(message.fields).forEach(([key, value]) => {
      if (value !== void 0) {
        exports2.Struct_FieldsEntry.encode({ key, value }, writer2.uint32(10).fork()).ldelim();
      }
    });
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStruct();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = exports2.Struct_FieldsEntry.decode(reader2, reader2.uint32());
          if (entry1.value !== void 0) {
            message.fields[entry1.key] = entry1.value;
          }
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { fields: isObject2(object.fields) ? Object.entries(object.fields).reduce((acc, [key, value]) => {
      acc[key] = value;
      return acc;
    }, {}) : {} };
  }, toJSON(message) {
    const obj = {};
    obj.fields = {};
    if (message.fields) {
      Object.entries(message.fields).forEach(([k, v2]) => {
        obj.fields[k] = v2;
      });
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseStruct();
    message.fields = Object.entries((_a2 = object.fields) !== null && _a2 !== void 0 ? _a2 : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = value;
      }
      return acc;
    }, {});
    return message;
  }, wrap(object) {
    const struct2 = createBaseStruct();
    if (object !== void 0) {
      Object.keys(object).forEach((key) => {
        struct2.fields[key] = object[key];
      });
    }
    return struct2;
  }, unwrap(message) {
    const object = {};
    Object.keys(message.fields).forEach((key) => {
      object[key] = message.fields[key];
    });
    return object;
  } };
  function createBaseStruct_FieldsEntry() {
    return { key: "", value: void 0 };
  }
  exports2.Struct_FieldsEntry = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.key !== "") {
      writer2.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      exports2.Value.encode(exports2.Value.wrap(message.value), writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStruct_FieldsEntry();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader2.string();
          break;
        case 2:
          message.value = exports2.Value.unwrap(exports2.Value.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { key: isSet2(object.key) ? String(object.key) : "", value: isSet2(object === null || object === void 0 ? void 0 : object.value) ? object.value : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseStruct_FieldsEntry();
    message.key = (_a2 = object.key) !== null && _a2 !== void 0 ? _a2 : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : void 0;
    return message;
  } };
  function createBaseValue() {
    return { nullValue: void 0, numberValue: void 0, stringValue: void 0, boolValue: void 0, structValue: void 0, listValue: void 0 };
  }
  exports2.Value = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.nullValue !== void 0) {
      writer2.uint32(8).int32(nullValueToNumber(message.nullValue));
    }
    if (message.numberValue !== void 0) {
      writer2.uint32(17).double(message.numberValue);
    }
    if (message.stringValue !== void 0) {
      writer2.uint32(26).string(message.stringValue);
    }
    if (message.boolValue !== void 0) {
      writer2.uint32(32).bool(message.boolValue);
    }
    if (message.structValue !== void 0) {
      exports2.Struct.encode(exports2.Struct.wrap(message.structValue), writer2.uint32(42).fork()).ldelim();
    }
    if (message.listValue !== void 0) {
      exports2.ListValue.encode(exports2.ListValue.wrap(message.listValue), writer2.uint32(50).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseValue();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.nullValue = nullValueFromJSON(reader2.int32());
          break;
        case 2:
          message.numberValue = reader2.double();
          break;
        case 3:
          message.stringValue = reader2.string();
          break;
        case 4:
          message.boolValue = reader2.bool();
          break;
        case 5:
          message.structValue = exports2.Struct.unwrap(exports2.Struct.decode(reader2, reader2.uint32()));
          break;
        case 6:
          message.listValue = exports2.ListValue.unwrap(exports2.ListValue.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { nullValue: isSet2(object.nullValue) ? nullValueFromJSON(object.nullValue) : void 0, numberValue: isSet2(object.numberValue) ? Number(object.numberValue) : void 0, stringValue: isSet2(object.stringValue) ? String(object.stringValue) : void 0, boolValue: isSet2(object.boolValue) ? Boolean(object.boolValue) : void 0, structValue: isObject2(object.structValue) ? object.structValue : void 0, listValue: Array.isArray(object.listValue) ? [...object.listValue] : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.nullValue !== void 0 && (obj.nullValue = message.nullValue !== void 0 ? nullValueToJSON(message.nullValue) : void 0);
    message.numberValue !== void 0 && (obj.numberValue = message.numberValue);
    message.stringValue !== void 0 && (obj.stringValue = message.stringValue);
    message.boolValue !== void 0 && (obj.boolValue = message.boolValue);
    message.structValue !== void 0 && (obj.structValue = message.structValue);
    message.listValue !== void 0 && (obj.listValue = message.listValue);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f;
    const message = createBaseValue();
    message.nullValue = (_a2 = object.nullValue) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.numberValue = (_b = object.numberValue) !== null && _b !== void 0 ? _b : void 0;
    message.stringValue = (_c = object.stringValue) !== null && _c !== void 0 ? _c : void 0;
    message.boolValue = (_d = object.boolValue) !== null && _d !== void 0 ? _d : void 0;
    message.structValue = (_e = object.structValue) !== null && _e !== void 0 ? _e : void 0;
    message.listValue = (_f = object.listValue) !== null && _f !== void 0 ? _f : void 0;
    return message;
  }, wrap(value) {
    const result = createBaseValue();
    if (value === null) {
      result.nullValue = NullValue.NULL_VALUE;
    } else if (typeof value === "boolean") {
      result.boolValue = value;
    } else if (typeof value === "number") {
      result.numberValue = value;
    } else if (typeof value === "string") {
      result.stringValue = value;
    } else if (Array.isArray(value)) {
      result.listValue = value;
    } else if (typeof value === "object") {
      result.structValue = value;
    } else if (typeof value !== "undefined") {
      throw new Error("Unsupported any value type: " + typeof value);
    }
    return result;
  }, unwrap(message) {
    if ((message === null || message === void 0 ? void 0 : message.stringValue) !== void 0) {
      return message.stringValue;
    } else if ((message === null || message === void 0 ? void 0 : message.numberValue) !== void 0) {
      return message.numberValue;
    } else if ((message === null || message === void 0 ? void 0 : message.boolValue) !== void 0) {
      return message.boolValue;
    } else if ((message === null || message === void 0 ? void 0 : message.structValue) !== void 0) {
      return message.structValue;
    } else if ((message === null || message === void 0 ? void 0 : message.listValue) !== void 0) {
      return message.listValue;
    } else if ((message === null || message === void 0 ? void 0 : message.nullValue) !== void 0) {
      return null;
    }
    return void 0;
  } };
  function createBaseListValue() {
    return { values: [] };
  }
  exports2.ListValue = { encode(message, writer2 = _m02.Writer.create()) {
    for (const v2 of message.values) {
      exports2.Value.encode(exports2.Value.wrap(v2), writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseListValue();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.values.push(exports2.Value.unwrap(exports2.Value.decode(reader2, reader2.uint32())));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { values: Array.isArray(object === null || object === void 0 ? void 0 : object.values) ? [...object.values] : [] };
  }, toJSON(message) {
    const obj = {};
    if (message.values) {
      obj.values = message.values.map((e2) => e2);
    } else {
      obj.values = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseListValue();
    message.values = ((_a2 = object.values) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
    return message;
  }, wrap(value) {
    const result = createBaseListValue();
    result.values = value !== null && value !== void 0 ? value : [];
    return result;
  }, unwrap(message) {
    return message.values;
  } };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal !== "undefined")
      return commonjsGlobal;
    throw "Unable to locate global object";
  })();
  if (_m02.util.Long !== long_12.default) {
    _m02.util.Long = long_12.default;
    _m02.configure();
  }
  function isObject2(value) {
    return typeof value === "object" && value !== null;
  }
  function isSet2(value) {
    return value !== null && value !== void 0;
  }
})(struct);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m2[k];
    } });
  } : function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.EventServiceDefinition = exports2.EventServiceClientImpl = exports2.EventsStreamResponse = exports2.EventsStreamRequest = exports2.EventsStreamReconnectRequest = exports2.EventsStreamError = exports2.SubscribePayload = exports2.PublishEventResponse = exports2.PublishEventRequest = exports2.EventTarget = exports2.eventsStreamMessageTypeToNumber = exports2.eventsStreamMessageTypeToJSON = exports2.eventsStreamMessageTypeFromJSON = exports2.EventsStreamMessageType = exports2.protobufPackage = void 0;
  const long_12 = __importDefault2(umd.exports);
  const _m02 = __importStar2(minimal);
  const operators_1 = require$$2;
  const struct_1 = struct;
  exports2.protobufPackage = "apis.event.v2";
  var EventsStreamMessageType;
  (function(EventsStreamMessageType2) {
    EventsStreamMessageType2["EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED"] = "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED";
    EventsStreamMessageType2["EVENTS_STREAM_MESSAGE_TYPE_PING"] = "EVENTS_STREAM_MESSAGE_TYPE_PING";
    EventsStreamMessageType2["EVENTS_STREAM_MESSAGE_TYPE_ERROR"] = "EVENTS_STREAM_MESSAGE_TYPE_ERROR";
    EventsStreamMessageType2["EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED"] = "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED";
    EventsStreamMessageType2["EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED"] = "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED";
    EventsStreamMessageType2["EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED"] = "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED";
  })(EventsStreamMessageType = exports2.EventsStreamMessageType || (exports2.EventsStreamMessageType = {}));
  function eventsStreamMessageTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED":
        return EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED;
      case 1:
      case "EVENTS_STREAM_MESSAGE_TYPE_PING":
        return EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_PING;
      case 2:
      case "EVENTS_STREAM_MESSAGE_TYPE_ERROR":
        return EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_ERROR;
      case 3:
      case "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED":
        return EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED;
      case 4:
      case "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED":
        return EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED;
      case 5:
      case "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED":
        return EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum EventsStreamMessageType");
    }
  }
  exports2.eventsStreamMessageTypeFromJSON = eventsStreamMessageTypeFromJSON;
  function eventsStreamMessageTypeToJSON(object) {
    switch (object) {
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED:
        return "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED";
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_PING:
        return "EVENTS_STREAM_MESSAGE_TYPE_PING";
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_ERROR:
        return "EVENTS_STREAM_MESSAGE_TYPE_ERROR";
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED:
        return "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED";
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED:
        return "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED";
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED:
        return "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED";
      default:
        return "UNKNOWN";
    }
  }
  exports2.eventsStreamMessageTypeToJSON = eventsStreamMessageTypeToJSON;
  function eventsStreamMessageTypeToNumber(object) {
    switch (object) {
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED:
        return 0;
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_PING:
        return 1;
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_ERROR:
        return 2;
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED:
        return 3;
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED:
        return 4;
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED:
        return 5;
      default:
        return 0;
    }
  }
  exports2.eventsStreamMessageTypeToNumber = eventsStreamMessageTypeToNumber;
  function createBaseEventTarget() {
    return { collectionId: void 0, projectId: void 0, layoutId: void 0 };
  }
  exports2.EventTarget = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.collectionId !== void 0) {
      writer2.uint32(42).string(message.collectionId);
    }
    if (message.projectId !== void 0) {
      writer2.uint32(34).string(message.projectId);
    }
    if (message.layoutId !== void 0) {
      writer2.uint32(10).string(message.layoutId);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseEventTarget();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 5:
          message.collectionId = reader2.string();
          break;
        case 4:
          message.projectId = reader2.string();
          break;
        case 1:
          message.layoutId = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { collectionId: isSet2(object.collectionId) ? String(object.collectionId) : void 0, projectId: isSet2(object.projectId) ? String(object.projectId) : void 0, layoutId: isSet2(object.layoutId) ? String(object.layoutId) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
    message.projectId !== void 0 && (obj.projectId = message.projectId);
    message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseEventTarget();
    message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : void 0;
    message.layoutId = (_c = object.layoutId) !== null && _c !== void 0 ? _c : void 0;
    return message;
  } };
  function createBasePublishEventRequest() {
    return { name: "", payload: void 0, requestMetadata: void 0, target: void 0 };
  }
  exports2.PublishEventRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.name !== "") {
      writer2.uint32(10).string(message.name);
    }
    if (message.payload !== void 0) {
      struct_1.Struct.encode(struct_1.Struct.wrap(message.payload), writer2.uint32(18).fork()).ldelim();
    }
    if (message.requestMetadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(34).fork()).ldelim();
    }
    if (message.target !== void 0) {
      exports2.EventTarget.encode(message.target, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBasePublishEventRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader2.string();
          break;
        case 2:
          message.payload = struct_1.Struct.unwrap(struct_1.Struct.decode(reader2, reader2.uint32()));
          break;
        case 4:
          message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 3:
          message.target = exports2.EventTarget.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { name: isSet2(object.name) ? String(object.name) : "", payload: isObject2(object.payload) ? object.payload : void 0, requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0, target: isSet2(object.target) ? exports2.EventTarget.fromJSON(object.target) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.payload !== void 0 && (obj.payload = message.payload);
    message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
    message.target !== void 0 && (obj.target = message.target ? exports2.EventTarget.toJSON(message.target) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBasePublishEventRequest();
    message.name = (_a2 = object.name) !== null && _a2 !== void 0 ? _a2 : "";
    message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : void 0;
    message.requestMetadata = (_c = object.requestMetadata) !== null && _c !== void 0 ? _c : void 0;
    message.target = object.target !== void 0 && object.target !== null ? exports2.EventTarget.fromPartial(object.target) : void 0;
    return message;
  } };
  function createBasePublishEventResponse() {
    return { name: "", payload: void 0, target: void 0, requestMetadata: void 0, id: "" };
  }
  exports2.PublishEventResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.name !== "") {
      writer2.uint32(10).string(message.name);
    }
    if (message.payload !== void 0) {
      struct_1.Struct.encode(struct_1.Struct.wrap(message.payload), writer2.uint32(18).fork()).ldelim();
    }
    if (message.target !== void 0) {
      exports2.EventTarget.encode(message.target, writer2.uint32(26).fork()).ldelim();
    }
    if (message.requestMetadata !== void 0) {
      struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(34).fork()).ldelim();
    }
    if (message.id !== "") {
      writer2.uint32(42).string(message.id);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBasePublishEventResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader2.string();
          break;
        case 2:
          message.payload = struct_1.Struct.unwrap(struct_1.Struct.decode(reader2, reader2.uint32()));
          break;
        case 3:
          message.target = exports2.EventTarget.decode(reader2, reader2.uint32());
          break;
        case 4:
          message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
          break;
        case 5:
          message.id = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { name: isSet2(object.name) ? String(object.name) : "", payload: isObject2(object.payload) ? object.payload : void 0, target: isSet2(object.target) ? exports2.EventTarget.fromJSON(object.target) : void 0, requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0, id: isSet2(object.id) ? String(object.id) : "" };
  }, toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.payload !== void 0 && (obj.payload = message.payload);
    message.target !== void 0 && (obj.target = message.target ? exports2.EventTarget.toJSON(message.target) : void 0);
    message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
    message.id !== void 0 && (obj.id = message.id);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBasePublishEventResponse();
    message.name = (_a2 = object.name) !== null && _a2 !== void 0 ? _a2 : "";
    message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : void 0;
    message.target = object.target !== void 0 && object.target !== null ? exports2.EventTarget.fromPartial(object.target) : void 0;
    message.requestMetadata = (_c = object.requestMetadata) !== null && _c !== void 0 ? _c : void 0;
    message.id = (_d = object.id) !== null && _d !== void 0 ? _d : "";
    return message;
  } };
  function createBaseSubscribePayload() {
    return { name: "", target: void 0 };
  }
  exports2.SubscribePayload = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.name !== "") {
      writer2.uint32(10).string(message.name);
    }
    if (message.target !== void 0) {
      exports2.EventTarget.encode(message.target, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSubscribePayload();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader2.string();
          break;
        case 2:
          message.target = exports2.EventTarget.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { name: isSet2(object.name) ? String(object.name) : "", target: isSet2(object.target) ? exports2.EventTarget.fromJSON(object.target) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.target !== void 0 && (obj.target = message.target ? exports2.EventTarget.toJSON(message.target) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = createBaseSubscribePayload();
    message.name = (_a2 = object.name) !== null && _a2 !== void 0 ? _a2 : "";
    message.target = object.target !== void 0 && object.target !== null ? exports2.EventTarget.fromPartial(object.target) : void 0;
    return message;
  } };
  function createBaseEventsStreamError() {
    return { code: 0, message: "" };
  }
  exports2.EventsStreamError = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.code !== 0) {
      writer2.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer2.uint32(18).string(message.message);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseEventsStreamError();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.code = reader2.int32();
          break;
        case 2:
          message.message = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { code: isSet2(object.code) ? Number(object.code) : 0, message: isSet2(object.message) ? String(object.message) : "" };
  }, toJSON(message) {
    const obj = {};
    message.code !== void 0 && (obj.code = Math.round(message.code));
    message.message !== void 0 && (obj.message = message.message);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseEventsStreamError();
    message.code = (_a2 = object.code) !== null && _a2 !== void 0 ? _a2 : 0;
    message.message = (_b = object.message) !== null && _b !== void 0 ? _b : "";
    return message;
  } };
  function createBaseEventsStreamReconnectRequest() {
    return { reauthenticate: false, beforeTimestamp: "" };
  }
  exports2.EventsStreamReconnectRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.reauthenticate === true) {
      writer2.uint32(8).bool(message.reauthenticate);
    }
    if (message.beforeTimestamp !== "") {
      writer2.uint32(18).string(message.beforeTimestamp);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseEventsStreamReconnectRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.reauthenticate = reader2.bool();
          break;
        case 2:
          message.beforeTimestamp = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { reauthenticate: isSet2(object.reauthenticate) ? Boolean(object.reauthenticate) : false, beforeTimestamp: isSet2(object.beforeTimestamp) ? String(object.beforeTimestamp) : "" };
  }, toJSON(message) {
    const obj = {};
    message.reauthenticate !== void 0 && (obj.reauthenticate = message.reauthenticate);
    message.beforeTimestamp !== void 0 && (obj.beforeTimestamp = message.beforeTimestamp);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseEventsStreamReconnectRequest();
    message.reauthenticate = (_a2 = object.reauthenticate) !== null && _a2 !== void 0 ? _a2 : false;
    message.beforeTimestamp = (_b = object.beforeTimestamp) !== null && _b !== void 0 ? _b : "";
    return message;
  } };
  function createBaseEventsStreamRequest() {
    return { correlationId: void 0, subscribe: void 0, unsubscribe: void 0, publish: void 0, ping: void 0 };
  }
  exports2.EventsStreamRequest = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.correlationId !== void 0) {
      writer2.uint32(10).string(message.correlationId);
    }
    if (message.subscribe !== void 0) {
      exports2.SubscribePayload.encode(message.subscribe, writer2.uint32(802).fork()).ldelim();
    }
    if (message.unsubscribe !== void 0) {
      exports2.SubscribePayload.encode(message.unsubscribe, writer2.uint32(810).fork()).ldelim();
    }
    if (message.publish !== void 0) {
      exports2.PublishEventRequest.encode(message.publish, writer2.uint32(818).fork()).ldelim();
    }
    if (message.ping !== void 0) {
      writer2.uint32(826).string(message.ping);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseEventsStreamRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.correlationId = reader2.string();
          break;
        case 100:
          message.subscribe = exports2.SubscribePayload.decode(reader2, reader2.uint32());
          break;
        case 101:
          message.unsubscribe = exports2.SubscribePayload.decode(reader2, reader2.uint32());
          break;
        case 102:
          message.publish = exports2.PublishEventRequest.decode(reader2, reader2.uint32());
          break;
        case 103:
          message.ping = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { correlationId: isSet2(object.correlationId) ? String(object.correlationId) : void 0, subscribe: isSet2(object.subscribe) ? exports2.SubscribePayload.fromJSON(object.subscribe) : void 0, unsubscribe: isSet2(object.unsubscribe) ? exports2.SubscribePayload.fromJSON(object.unsubscribe) : void 0, publish: isSet2(object.publish) ? exports2.PublishEventRequest.fromJSON(object.publish) : void 0, ping: isSet2(object.ping) ? String(object.ping) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.correlationId !== void 0 && (obj.correlationId = message.correlationId);
    message.subscribe !== void 0 && (obj.subscribe = message.subscribe ? exports2.SubscribePayload.toJSON(message.subscribe) : void 0);
    message.unsubscribe !== void 0 && (obj.unsubscribe = message.unsubscribe ? exports2.SubscribePayload.toJSON(message.unsubscribe) : void 0);
    message.publish !== void 0 && (obj.publish = message.publish ? exports2.PublishEventRequest.toJSON(message.publish) : void 0);
    message.ping !== void 0 && (obj.ping = message.ping);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = createBaseEventsStreamRequest();
    message.correlationId = (_a2 = object.correlationId) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.subscribe = object.subscribe !== void 0 && object.subscribe !== null ? exports2.SubscribePayload.fromPartial(object.subscribe) : void 0;
    message.unsubscribe = object.unsubscribe !== void 0 && object.unsubscribe !== null ? exports2.SubscribePayload.fromPartial(object.unsubscribe) : void 0;
    message.publish = object.publish !== void 0 && object.publish !== null ? exports2.PublishEventRequest.fromPartial(object.publish) : void 0;
    message.ping = (_b = object.ping) !== null && _b !== void 0 ? _b : void 0;
    return message;
  } };
  function createBaseEventsStreamResponse() {
    return { correlationId: void 0, sessionId: void 0, event: void 0, pong: void 0, error: void 0, subscribed: void 0, unsubscribed: void 0, published: void 0, reconnectBefore: void 0 };
  }
  exports2.EventsStreamResponse = { encode(message, writer2 = _m02.Writer.create()) {
    if (message.correlationId !== void 0) {
      writer2.uint32(18).string(message.correlationId);
    }
    if (message.sessionId !== void 0) {
      writer2.uint32(26).string(message.sessionId);
    }
    if (message.event !== void 0) {
      exports2.PublishEventResponse.encode(message.event, writer2.uint32(802).fork()).ldelim();
    }
    if (message.pong !== void 0) {
      writer2.uint32(1602).string(message.pong);
    }
    if (message.error !== void 0) {
      exports2.EventsStreamError.encode(message.error, writer2.uint32(1610).fork()).ldelim();
    }
    if (message.subscribed !== void 0) {
      exports2.SubscribePayload.encode(message.subscribed, writer2.uint32(1618).fork()).ldelim();
    }
    if (message.unsubscribed !== void 0) {
      exports2.SubscribePayload.encode(message.unsubscribed, writer2.uint32(1626).fork()).ldelim();
    }
    if (message.published !== void 0) {
      exports2.PublishEventResponse.encode(message.published, writer2.uint32(1634).fork()).ldelim();
    }
    if (message.reconnectBefore !== void 0) {
      exports2.EventsStreamReconnectRequest.encode(message.reconnectBefore, writer2.uint32(1642).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseEventsStreamResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 2:
          message.correlationId = reader2.string();
          break;
        case 3:
          message.sessionId = reader2.string();
          break;
        case 100:
          message.event = exports2.PublishEventResponse.decode(reader2, reader2.uint32());
          break;
        case 200:
          message.pong = reader2.string();
          break;
        case 201:
          message.error = exports2.EventsStreamError.decode(reader2, reader2.uint32());
          break;
        case 202:
          message.subscribed = exports2.SubscribePayload.decode(reader2, reader2.uint32());
          break;
        case 203:
          message.unsubscribed = exports2.SubscribePayload.decode(reader2, reader2.uint32());
          break;
        case 204:
          message.published = exports2.PublishEventResponse.decode(reader2, reader2.uint32());
          break;
        case 205:
          message.reconnectBefore = exports2.EventsStreamReconnectRequest.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    return { correlationId: isSet2(object.correlationId) ? String(object.correlationId) : void 0, sessionId: isSet2(object.sessionId) ? String(object.sessionId) : void 0, event: isSet2(object.event) ? exports2.PublishEventResponse.fromJSON(object.event) : void 0, pong: isSet2(object.pong) ? String(object.pong) : void 0, error: isSet2(object.error) ? exports2.EventsStreamError.fromJSON(object.error) : void 0, subscribed: isSet2(object.subscribed) ? exports2.SubscribePayload.fromJSON(object.subscribed) : void 0, unsubscribed: isSet2(object.unsubscribed) ? exports2.SubscribePayload.fromJSON(object.unsubscribed) : void 0, published: isSet2(object.published) ? exports2.PublishEventResponse.fromJSON(object.published) : void 0, reconnectBefore: isSet2(object.reconnectBefore) ? exports2.EventsStreamReconnectRequest.fromJSON(object.reconnectBefore) : void 0 };
  }, toJSON(message) {
    const obj = {};
    message.correlationId !== void 0 && (obj.correlationId = message.correlationId);
    message.sessionId !== void 0 && (obj.sessionId = message.sessionId);
    message.event !== void 0 && (obj.event = message.event ? exports2.PublishEventResponse.toJSON(message.event) : void 0);
    message.pong !== void 0 && (obj.pong = message.pong);
    message.error !== void 0 && (obj.error = message.error ? exports2.EventsStreamError.toJSON(message.error) : void 0);
    message.subscribed !== void 0 && (obj.subscribed = message.subscribed ? exports2.SubscribePayload.toJSON(message.subscribed) : void 0);
    message.unsubscribed !== void 0 && (obj.unsubscribed = message.unsubscribed ? exports2.SubscribePayload.toJSON(message.unsubscribed) : void 0);
    message.published !== void 0 && (obj.published = message.published ? exports2.PublishEventResponse.toJSON(message.published) : void 0);
    message.reconnectBefore !== void 0 && (obj.reconnectBefore = message.reconnectBefore ? exports2.EventsStreamReconnectRequest.toJSON(message.reconnectBefore) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseEventsStreamResponse();
    message.correlationId = (_a2 = object.correlationId) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.sessionId = (_b = object.sessionId) !== null && _b !== void 0 ? _b : void 0;
    message.event = object.event !== void 0 && object.event !== null ? exports2.PublishEventResponse.fromPartial(object.event) : void 0;
    message.pong = (_c = object.pong) !== null && _c !== void 0 ? _c : void 0;
    message.error = object.error !== void 0 && object.error !== null ? exports2.EventsStreamError.fromPartial(object.error) : void 0;
    message.subscribed = object.subscribed !== void 0 && object.subscribed !== null ? exports2.SubscribePayload.fromPartial(object.subscribed) : void 0;
    message.unsubscribed = object.unsubscribed !== void 0 && object.unsubscribed !== null ? exports2.SubscribePayload.fromPartial(object.unsubscribed) : void 0;
    message.published = object.published !== void 0 && object.published !== null ? exports2.PublishEventResponse.fromPartial(object.published) : void 0;
    message.reconnectBefore = object.reconnectBefore !== void 0 && object.reconnectBefore !== null ? exports2.EventsStreamReconnectRequest.fromPartial(object.reconnectBefore) : void 0;
    return message;
  } };
  class EventServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.Stream = this.Stream.bind(this);
      this.Publish = this.Publish.bind(this);
    }
    Stream(request3) {
      const data2 = request3.pipe(operators_1.map((request4) => exports2.EventsStreamRequest.encode(request4).finish()));
      const result = this.rpc.bidirectionalStreamingRequest("apis.event.v2.EventService", "Stream", data2);
      return result.pipe(operators_1.map((data3) => exports2.EventsStreamResponse.decode(new _m02.Reader(data3))));
    }
    Publish(request3) {
      const data2 = exports2.PublishEventRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.event.v2.EventService", "Publish", data2);
      return promise.then((data3) => exports2.PublishEventResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.EventServiceClientImpl = EventServiceClientImpl;
  exports2.EventServiceDefinition = { name: "EventService", fullName: "apis.event.v2.EventService", methods: { stream: { name: "Stream", requestType: exports2.EventsStreamRequest, requestStream: true, responseType: exports2.EventsStreamResponse, responseStream: true, options: {} }, publish: { name: "Publish", requestType: exports2.PublishEventRequest, requestStream: false, responseType: exports2.PublishEventResponse, responseStream: false, options: {} } } };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal !== "undefined")
      return commonjsGlobal;
    throw "Unable to locate global object";
  })();
  if (_m02.util.Long !== long_12.default) {
    _m02.util.Long = long_12.default;
    _m02.configure();
  }
  function isObject2(value) {
    return typeof value === "object" && value !== null;
  }
  function isSet2(value) {
    return value !== null && value !== void 0;
  }
})(api);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m2[k];
    } });
  } : function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !exports3.hasOwnProperty(p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.eventsApiSupportedEvents = exports2.eventsApiEventRpcCalls = void 0;
  __exportStar(api, exports2);
  exports2.eventsApiEventRpcCalls = { ping: "pong", publish: "published", subscribe: "subscribed", unsubscribe: "unsubscribed" };
  exports2.eventsApiSupportedEvents = [...Object.values(exports2.eventsApiEventRpcCalls), "error", "event", "reconnectBefore"];
})(dist$2);
var ws = null;
if (typeof WebSocket !== "undefined") {
  ws = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws = MozWebSocket;
} else if (typeof commonjsGlobal !== "undefined") {
  ws = commonjsGlobal.WebSocket || commonjsGlobal.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws = self.WebSocket || self.MozWebSocket;
}
var browser$1 = ws;
var matcher = { exports: {} };
var escapeStringRegexp$1 = (string) => {
  if (typeof string !== "string") {
    throw new TypeError("Expected a string");
  }
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
const escapeStringRegexp = escapeStringRegexp$1;
const regexpCache = /* @__PURE__ */ new Map();
function sanitizeArray(input, inputName) {
  if (!Array.isArray(input)) {
    switch (typeof input) {
      case "string":
        input = [input];
        break;
      case "undefined":
        input = [];
        break;
      default:
        throw new TypeError(`Expected '${inputName}' to be a string or an array, but got a type of '${typeof input}'`);
    }
  }
  return input.filter((string) => {
    if (typeof string !== "string") {
      if (typeof string === "undefined") {
        return false;
      }
      throw new TypeError(`Expected '${inputName}' to be an array of strings, but found a type of '${typeof string}' in the array`);
    }
    return true;
  });
}
function makeRegexp(pattern, options2) {
  options2 = { caseSensitive: false, ...options2 };
  const cacheKey = pattern + JSON.stringify(options2);
  if (regexpCache.has(cacheKey)) {
    return regexpCache.get(cacheKey);
  }
  const negated = pattern[0] === "!";
  if (negated) {
    pattern = pattern.slice(1);
  }
  pattern = escapeStringRegexp(pattern).replace(/\\\*/g, "[\\s\\S]*");
  const regexp = new RegExp(`^${pattern}$`, options2.caseSensitive ? "" : "i");
  regexp.negated = negated;
  regexpCache.set(cacheKey, regexp);
  return regexp;
}
matcher.exports = (inputs, patterns, options2) => {
  inputs = sanitizeArray(inputs, "inputs");
  patterns = sanitizeArray(patterns, "patterns");
  if (patterns.length === 0) {
    return [];
  }
  const isFirstPatternNegated = patterns[0][0] === "!";
  patterns = patterns.map((pattern) => makeRegexp(pattern, options2));
  const result = [];
  for (const input of inputs) {
    let matches = isFirstPatternNegated;
    for (const pattern of patterns) {
      if (pattern.test(input)) {
        matches = !pattern.negated;
      }
    }
    if (matches) {
      result.push(input);
    }
  }
  return result;
};
matcher.exports.isMatch = (inputs, patterns, options2) => {
  inputs = sanitizeArray(inputs, "inputs");
  patterns = sanitizeArray(patterns, "patterns");
  if (patterns.length === 0) {
    return false;
  }
  return inputs.some((input) => {
    return patterns.every((pattern) => {
      const regexp = makeRegexp(pattern, options2);
      const matches = regexp.test(input);
      return regexp.negated ? !matches : matches;
    });
  });
};
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o2, k2, desc);
} : function(o2, m2, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o2[k2] = m2[k];
});
var __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k in mod2)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
        __createBinding$1(result, mod2, k);
  }
  __setModuleDefault$1(result, mod2);
  return result;
};
var __importDefault$e = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(eventapi, "__esModule", { value: true });
eventapi.EventApi = void 0;
const EventApiModel = __importStar$1(dist$2);
const isomorphic_ws_1 = __importDefault$e(browser$1);
const uuid_1 = require$$1$2;
const NiceGrpc = __importStar$1(lib$1);
const matcher_1 = matcher.exports;
const api_1 = api$2;
const clientVersion = version$2;
const WS_PING_INTERVAL = 2e4;
const WS_PING_TIMEOUT = 1e4;
const WS_RECONNECT_DELAY = 2e3;
const WS_MAX_BADAUTH_ATTEMPTS = 3;
const LOG_CATEGORY = "EventApi";
class EventApi extends api_1.ApiClient {
  constructor(sessionId, server, websocketServer, sdkVersion, apiLogCallback, eventLogCallback) {
    super(sessionId, server, sdkVersion, LOG_CATEGORY, apiLogCallback, eventLogCallback);
    this.websocketServer = websocketServer;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.eventHandlers = {};
    this.calls = {};
    this.messageQueue = [];
    this.websocketReady = false;
    this.reconnectionAttempts = 0;
    this.badAuthentication = false;
    this.eventsClient = null;
  }
  publish(...request3) {
    if (this.websocketReady) {
      return this.call("publish", request3[0]);
    } else {
      return this.eventsClient.publish(...request3);
    }
  }
  connect() {
    if (!this.ws) {
      this.cleanup();
      const currentAccessToken = this.accessToken;
      const query = [`version=${clientVersion}`, `sessionid=${this.sessionId}`];
      if (this.sdkVersion) {
        query.push(`sdkversion=${this.sdkVersion}`);
      }
      this.ws = new isomorphic_ws_1.default(`${this.websocketServer}/stream?${query.join("&")}`, ["Bearer", this.accessToken]);
      let error;
      this.ws.addEventListener("message", (msg) => {
        const data2 = JSON.parse(msg.data.toString());
        const message = data2.result;
        if (data2.error) {
          error = data2.error;
          this.handleEvent("error", { error: { code: data2.code, message: data2.message } });
          if (["You do not have permission to this resource", "You do not have permission to this resource"].includes(data2.message)) {
            this.badAuthentication = true;
          }
        }
        if (!message) {
          return;
        }
        if (message.reconnectBefore && message.reconnectBefore.reauthenticate && this.accessToken === currentAccessToken) {
          this.badAuthentication = true;
        }
        const eventName = EventApiModel.eventsApiSupportedEvents.find((name2) => !!message[name2]);
        if (eventName) {
          this.handleEvent(eventName, message);
        }
      });
      this.ws.addEventListener("open", () => {
        this.log.info("websocket connected");
        this.call("ping", "hello", { timeout: WS_PING_TIMEOUT, skipQueue: true }).then(() => {
          this.ready();
        }).catch((e2) => {
          if (!error && e2.message !== "Stream connection closed") {
            this.disconnect("hello timeout");
          }
        });
      });
      this.ws.addEventListener("close", (event2) => {
        var _a2;
        if (error) {
          this.reconnect(`${(_a2 = error === null || error === void 0 ? void 0 : error.message) !== null && _a2 !== void 0 ? _a2 : "unknown"}`);
        } else {
          this.reconnect(`closed - ${event2.reason || event2.code}`);
        }
      });
      this.ws.addEventListener("error", (err) => {
        error = err;
      });
    }
  }
  async subscribe(name2, payload = {}) {
    return this.call("subscribe", { name: name2, ...payload }).then(() => {
      this.subscriptions.add(JSON.stringify({ name: name2, ...payload }));
    });
  }
  async unsubscribe(name2, payload = {}) {
    this.subscriptions.delete(JSON.stringify({ name: name2, payload }));
    await this.call("unsubscribe", { name: name2, ...payload });
  }
  on(type, dataOrFn, fn) {
    const handler = fn ? fn : dataOrFn;
    const options2 = { ignoreSessionEvents: false, allowedSessionEvents: [], ...fn ? dataOrFn : {} };
    if (!this.eventHandlers[type]) {
      this.eventHandlers[type] = [];
    }
    this.eventHandlers[type].push({ ...options2, handler });
  }
  off(type, dataOrFn, fn) {
    var _a2;
    const handler = fn ? fn : dataOrFn;
    const options2 = { ignoreSessionEvents: false, allowedSessionEvents: [], ...fn ? dataOrFn : {} };
    this.eventHandlers[type] = ((_a2 = this.eventHandlers[type]) !== null && _a2 !== void 0 ? _a2 : []).filter((eventHandler) => {
      if (eventHandler.ignoreSessionEvents === options2.ignoreSessionEvents && eventHandler.allowedSessionEvents === options2.allowedSessionEvents && eventHandler.handler === handler && eventHandler.name === options2.name) {
        return false;
      }
      return true;
    });
  }
  disconnect(reason) {
    this.log.warn(`disconnected from events reason=${reason}`);
    Object.values(this.calls).forEach((i2) => {
      clearTimeout(i2.timeout);
      i2.reject(new Error("Stream connection closed"));
    });
    this.calls = {};
    this.cleanup();
  }
  _setup(options2) {
    this.eventsClient = this.clientFactory.create(EventApiModel.EventServiceDefinition, this.channel, { "*": options2 });
    if (this.badAuthentication) {
      this.badAuthentication = false;
      this.reconnectionAttempts = 0;
      this.reconnect("updated token");
    }
  }
  ready() {
    this.reconnectionAttempts = 0;
    this.badAuthentication = false;
    this.websocketReady = true;
    this.handleEvent("connected", { connected: void 0 });
    for (const sub of this.subscriptions.values()) {
      this.send({ subscribe: JSON.parse(sub), correlationId: (0, uuid_1.v4)() });
    }
    for (const msg of this.messageQueue) {
      this.send(msg);
    }
    this.messageQueue = [];
    this.pingLoop = setInterval(() => {
      this.ping();
    }, WS_PING_INTERVAL);
  }
  ping() {
    this.call("ping", `${+new Date()}`, { timeout: WS_PING_TIMEOUT }).catch(() => {
      this.reconnect("connection stalled");
    });
  }
  reconnect(reason) {
    this.disconnect(reason);
    this.reconnectTimeout = setTimeout(() => {
      this.reconnectionAttempts++;
      if (this.badAuthentication && this.reconnectionAttempts >= WS_MAX_BADAUTH_ATTEMPTS) {
        this.log.warn("Maximum number of reconnection attempts reached with bad authentication, please re-authenticate the SDK");
        return;
      }
      this.connect();
    }, WS_RECONNECT_DELAY);
  }
  send(data2) {
    if (this.ws && this.ws.readyState === this.ws.OPEN) {
      this.ws.send(JSON.stringify(data2));
    } else {
      this.log.warn("Message sent to a disconnected stream");
    }
  }
  handleEvent(name2, payload) {
    var _a2;
    if (this.calls[payload.correlationId]) {
      const isMatchingResponse = EventApiModel.eventsApiEventRpcCalls[this.calls[payload.correlationId].method] === name2;
      const isError = !!payload.error;
      if (isMatchingResponse || isError) {
        this.resolveCall(name2, payload);
        return;
      }
    }
    for (const handler of (_a2 = this.eventHandlers[name2]) !== null && _a2 !== void 0 ? _a2 : []) {
      if (name2 === "event" && payload.event) {
        if (payload.sessionId === this.sessionId && handler.ignoreSessionEvents && !handler.allowedSessionEvents.includes(payload.event.name)) {
          this.log.trace("ignorning user event from self: " + payload.event.name + ", payload.sessionId=" + payload.sessionId + ", this.sessionId");
          continue;
        }
        if (handler.name && !(0, matcher_1.isMatch)(payload.event.name, handler.name)) {
          continue;
        }
        if (this.eventLogCallback) {
          let eventService = void 0;
          let eventType = payload.event.name;
          let eventSubType = void 0;
          if (payload.event.name.startsWith(EventApi.APISTREAM_EVENT_PREFIX)) {
            let parts = payload.event.name.split(":");
            if (parts.length == 4) {
              eventService = parts[1];
              eventType = parts[2];
              eventSubType = parts[3];
            }
            this.eventLogCallback(eventService, eventType, eventSubType, payload);
          }
        }
      } else {
        if (payload.sessionId === this.sessionId && handler.ignoreSessionEvents) {
          this.log.trace("ignorning event from self: " + payload.event.name + ", payload.sessionId=" + payload.sessionId + ", this.sessionId");
          continue;
        }
      }
      this.log.trace("processing event: payload.sessionId=" + payload.sessionId + ", this.sessionId");
      handler.handler(payload ? payload[name2] : void 0, { isFromCurrentSession: payload.sessionId === this.sessionId });
    }
  }
  async call(method, payload, opts = { timeout: 2e4, skipQueue: false }) {
    if (!this.ws) {
      this.connect();
    }
    const correlationId = (0, uuid_1.v4)();
    return new Promise((resolve, reject) => {
      const timeout2 = setTimeout(() => {
        delete this.calls[correlationId];
        reject(new Error("Request timed out"));
      }, opts.timeout);
      this.calls[correlationId] = { resolve, reject, timeout: timeout2, method };
      if (this.websocketReady || opts.skipQueue) {
        this.send({ [method]: payload, correlationId });
      } else {
        this.messageQueue.push({ [method]: payload, correlationId });
      }
    });
  }
  resolveCall(name2, payload) {
    const callHandler = this.calls[payload.correlationId];
    if (!callHandler) {
      return;
    }
    clearTimeout(callHandler.timeout);
    delete this.calls[payload.correlationId];
    if (name2 === "error" && payload.error) {
      callHandler.reject(new NiceGrpc.ClientError("error", payload.error.code, payload.error.message));
      return;
    }
    callHandler.resolve(payload[name2]);
  }
  cleanup() {
    clearTimeout(this.pingLoop);
    clearTimeout(this.reconnectTimeout);
    this.websocketReady = false;
    if (this.ws) {
      this.ws.onclose = function() {
      };
      this.ws.close();
      this.ws = null;
    }
  }
}
eventapi.EventApi = EventApi;
EventApi.APISTREAM_EVENT_PREFIX = "apistream";
var livekit = {};
var __importDefault$d = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(livekit, "__esModule", { value: true });
livekit.LiveKitUtils = void 0;
const jwt_decode_1 = __importDefault$d(require$$0$2);
class LiveKitUtils {
  static decodeJwt(sfuToken) {
    return (0, jwt_decode_1.default)(sfuToken, { header: false });
  }
  static isRoomAdmin(sfuToken) {
    let grants2 = LiveKitUtils.decodeJwt(sfuToken);
    return grants2.video.roomAdmin;
  }
  static getRoomName(sfuToken) {
    let grants2 = LiveKitUtils.decodeJwt(sfuToken);
    return grants2.video.room;
  }
}
livekit.LiveKitUtils = LiveKitUtils;
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ApiStream = exports2.LiveKitUtils = exports2.EventApiModel = exports2.LayoutApiModel = exports2.LiveApiModel = void 0;
  const jwt_decode_12 = __importDefault2(require$$0$2);
  const uuid_12 = require$$1$2;
  const typescript_logging_12 = require$$2$1;
  const layoutapi_1 = layoutapi;
  const liveapi_1 = liveapi;
  const eventapi_1 = eventapi;
  const LiveApiModel = __importStar2(api$1);
  exports2.LiveApiModel = LiveApiModel;
  const LayoutApiModel2 = __importStar2(dist$3);
  exports2.LayoutApiModel = LayoutApiModel2;
  const EventApiModel2 = __importStar2(dist$2);
  exports2.EventApiModel = EventApiModel2;
  const livekit_1 = livekit;
  Object.defineProperty(exports2, "LiveKitUtils", { enumerable: true, get: function() {
    return livekit_1.LiveKitUtils;
  } });
  const logger_12 = logger$1;
  const CLIENT_VERSION = version$2;
  const LIVEAPI_SERVERS = { "dev": "http://127.0.0.1:8081", "stage": "https://live.stream.horse/grpcweb/live/v2", "prod": "https://live.api.stream/grpcweb/live/v2" };
  const LAYOUTAPI_SERVERS = { "dev": "https://live.stream.horse/grpcweb/layout/v2", "stage": "https://live.stream.horse/grpcweb/layout/v2", "prod": "https://live.api.stream/grpcweb/layout/v2" };
  const EVENTAPI_WS_SERVERS = { "dev": "wss://live.stream.horse/event/v2", "stage": "wss://live.stream.horse/event/v2", "prod": "wss://live.api.stream/event/v2" };
  const EVENTAPI_SERVERS = { "dev": "https://live.stream.horse/grpcweb/event/v2", "stage": "https://live.stream.horse/grpcweb/event/v2", "prod": "https://live.api.stream/grpcweb/event/v2" };
  const LIVEKIT_SERVERS = { "dev": "wss://live.stream.horse/webrtc/v2", "stage": "wss://live.stream.horse/webrtc/v2", "prod": "wss://live.api.stream/webrtc/v2" };
  const LIVEKIT_ADMIN_SERVERS = { "dev": "https://live.stream.horse/webrtc/v2", "stage": "https://live.stream.horse/webrtc/v2", "prod": "https://live.api.stream/webrtc/v2" };
  class ApiStream {
    constructor(opts = {}) {
      var _a2;
      const options2 = { env: "prod", logLevel: "Warn", ...opts };
      this.env = options2.env;
      let sessionId = (0, uuid_12.v4)();
      if (options2.sessionId != void 0)
        sessionId = options2.sessionId;
      this.log = logger_12.logger.getCategory("ApiStream");
      this.setLogLevel(options2.env == "dev" ? "Trace" : options2.logLevel);
      const overrideEndpoints = (_a2 = options2.overrideEndpoints) !== null && _a2 !== void 0 ? _a2 : {};
      if (overrideEndpoints.liveApiServer == void 0)
        overrideEndpoints.liveApiServer = LIVEAPI_SERVERS[this.env];
      if (overrideEndpoints.layoutApiServer == void 0)
        overrideEndpoints.layoutApiServer = LAYOUTAPI_SERVERS[this.env];
      if (overrideEndpoints.eventApiServer == void 0)
        overrideEndpoints.eventApiServer = EVENTAPI_SERVERS[this.env];
      if (overrideEndpoints.eventApiWebSocketServer == void 0)
        overrideEndpoints.eventApiWebSocketServer = EVENTAPI_WS_SERVERS[this.env];
      this.eventApi = new eventapi_1.EventApi(sessionId, overrideEndpoints.eventApiServer, overrideEndpoints.eventApiWebSocketServer, options2.sdkVersion, options2.apiLogCallback, options2.eventLogCallback);
      this.layoutApi = new layoutapi_1.LayoutApi(sessionId, this.eventApi, overrideEndpoints.layoutApiServer, options2.sdkVersion, options2.apiLogCallback);
      this.liveApi = new liveapi_1.LiveApi(sessionId, this.eventApi, overrideEndpoints.liveApiServer, this.setAccessToken.bind(this), options2.apiKey, options2.sdkVersion, options2.apiLogCallback);
      this.eventApi.on("reconnectBefore", (evt) => {
        if (evt.reauthenticate) {
          this.liveApi.authentication.refreshAccessToken({}).catch(() => {
          });
        }
      });
      this.log.info("api.stream: sessionid=" + sessionId + ", version=" + CLIENT_VERSION + ", sdkVersion=" + options2.sdkVersion);
    }
    LiveApi() {
      return this.liveApi;
    }
    LayoutApi() {
      return this.layoutApi;
    }
    EventApi() {
      return this.eventApi;
    }
    setLogLevel(level) {
      try {
        let logLevel = typescript_logging_12.LogLevel.toLogLevel(level);
        logger_12.logger.updateRuntimeSettings({ level: logLevel });
      } catch (err) {
        this.log.warn(`unknown logging level ${level}`);
      }
    }
    setAccessToken(accessToken) {
      this.decodedAccessToken = ApiStream.decodeAccessToken(accessToken);
      this.log.debug("setting accessToken", accessToken, this.decodedAccessToken);
      this.layoutApi.setAccessToken(accessToken);
      this.liveApi.setAccessToken(accessToken);
      this.eventApi.setAccessToken(accessToken);
    }
    getAccessToken() {
      return this.decodedAccessToken;
    }
    getGuestProject() {
      return this.decodedAccessToken.guestControl;
    }
    async load(accessToken) {
      if (accessToken == void 0 && typeof window != "undefined") {
        let queryParameters = this.parseQuery();
        if (queryParameters.get(ApiStream.ACCESS_TOKEN_QUERY_PARAM) != null) {
          accessToken = queryParameters.get(ApiStream.ACCESS_TOKEN_QUERY_PARAM);
        }
      }
      if (accessToken != void 0) {
        this.setAccessToken(accessToken);
        if (this.decodedAccessToken.guestControl != void 0) {
          this.log.info("loading guest token and exchanging");
          await this.LiveApi().authentication.refreshAccessToken({});
          this.log.info("auto-loading project = " + JSON.stringify(this.decodedAccessToken.guestControl));
          return this.decodedAccessToken.guestControl;
        }
      }
      return null;
    }
    getLiveKitServer(admin = false) {
      if (admin)
        return LIVEKIT_ADMIN_SERVERS[this.env];
      else
        return LIVEKIT_SERVERS[this.env];
    }
    parseQuery() {
      let queryString = window.location.search;
      let query = /* @__PURE__ */ new Map();
      let pairs = (queryString[0] === "?" ? queryString.substr(1) : queryString).split("&");
      for (let i2 = 0; i2 < pairs.length; i2++) {
        let pair = pairs[i2].split("=");
        if (pair.length == 2) {
          query.set(decodeURIComponent(pair[0]), decodeURIComponent(pair[1] || ""));
          this.log.debug(`found query param: ${decodeURIComponent(pair[0])}=${decodeURIComponent(pair[1] || "")}`);
        }
      }
      return query;
    }
    static decodeAccessToken(accessToken) {
      let rawDecodedAccessToken = (0, jwt_decode_12.default)(accessToken, { header: false });
      let decodedAccessToken = { serviceUserId: rawDecodedAccessToken.user.serviceUserId, userId: rawDecodedAccessToken.user.userId, displayName: rawDecodedAccessToken.user.displayName, trial: rawDecodedAccessToken.user.trial, demo: rawDecodedAccessToken.user.demo };
      if (rawDecodedAccessToken.guestControl != null) {
        decodedAccessToken.guestControl = { collectionId: rawDecodedAccessToken.guestControl.collectionId, projectId: rawDecodedAccessToken.guestControl.projectId, role: LiveApiModel.roleFromJSON(rawDecodedAccessToken.guestControl.role) };
      }
      return decodedAccessToken;
    }
  }
  exports2.ApiStream = ApiStream;
  ApiStream.ACCESS_TOKEN_QUERY_PARAM = "at";
})(lib$2);
var dist$1 = {};
var logger = {};
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.setLogLevel = exports2.LogLevel = void 0;
  const loglevel_1 = __importDefault2(loglevel.exports);
  var LogLevel2;
  (function(LogLevel3) {
    LogLevel3["trace"] = "trace";
    LogLevel3["debug"] = "debug";
    LogLevel3["info"] = "info";
    LogLevel3["warn"] = "warn";
    LogLevel3["error"] = "error";
    LogLevel3["silent"] = "silent";
  })(LogLevel2 = exports2.LogLevel || (exports2.LogLevel = {}));
  const livekitLogger = loglevel_1.default.getLogger("livekit");
  livekitLogger.setLevel(LogLevel2.info);
  exports2.default = livekitLogger;
  function setLogLevel(level) {
    livekitLogger.setLevel(level);
  }
  exports2.setLogLevel = setLogLevel;
})(logger);
var livekit_models$1 = {};
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ClientInfo = exports2.ParticipantTracks = exports2.UserPacket = exports2.SpeakerInfo = exports2.ActiveSpeakerUpdate = exports2.DataPacket = exports2.VideoLayer = exports2.TrackInfo = exports2.ParticipantInfo = exports2.Codec = exports2.Room = exports2.clientInfo_SDKToJSON = exports2.clientInfo_SDKFromJSON = exports2.ClientInfo_SDK = exports2.dataPacket_KindToJSON = exports2.dataPacket_KindFromJSON = exports2.DataPacket_Kind = exports2.participantInfo_StateToJSON = exports2.participantInfo_StateFromJSON = exports2.ParticipantInfo_State = exports2.connectionQualityToJSON = exports2.connectionQualityFromJSON = exports2.ConnectionQuality = exports2.videoQualityToJSON = exports2.videoQualityFromJSON = exports2.VideoQuality = exports2.trackSourceToJSON = exports2.trackSourceFromJSON = exports2.TrackSource = exports2.trackTypeToJSON = exports2.trackTypeFromJSON = exports2.TrackType = exports2.protobufPackage = void 0;
  const long_12 = __importDefault2(umd.exports);
  const minimal_1 = __importDefault2(minimal);
  exports2.protobufPackage = "livekit";
  var TrackType;
  (function(TrackType2) {
    TrackType2[TrackType2["AUDIO"] = 0] = "AUDIO";
    TrackType2[TrackType2["VIDEO"] = 1] = "VIDEO";
    TrackType2[TrackType2["DATA"] = 2] = "DATA";
    TrackType2[TrackType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(TrackType = exports2.TrackType || (exports2.TrackType = {}));
  function trackTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "AUDIO":
        return TrackType.AUDIO;
      case 1:
      case "VIDEO":
        return TrackType.VIDEO;
      case 2:
      case "DATA":
        return TrackType.DATA;
      case -1:
      case "UNRECOGNIZED":
      default:
        return TrackType.UNRECOGNIZED;
    }
  }
  exports2.trackTypeFromJSON = trackTypeFromJSON;
  function trackTypeToJSON(object) {
    switch (object) {
      case TrackType.AUDIO:
        return "AUDIO";
      case TrackType.VIDEO:
        return "VIDEO";
      case TrackType.DATA:
        return "DATA";
      default:
        return "UNKNOWN";
    }
  }
  exports2.trackTypeToJSON = trackTypeToJSON;
  var TrackSource;
  (function(TrackSource2) {
    TrackSource2[TrackSource2["UNKNOWN"] = 0] = "UNKNOWN";
    TrackSource2[TrackSource2["CAMERA"] = 1] = "CAMERA";
    TrackSource2[TrackSource2["MICROPHONE"] = 2] = "MICROPHONE";
    TrackSource2[TrackSource2["SCREEN_SHARE"] = 3] = "SCREEN_SHARE";
    TrackSource2[TrackSource2["SCREEN_SHARE_AUDIO"] = 4] = "SCREEN_SHARE_AUDIO";
    TrackSource2[TrackSource2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(TrackSource = exports2.TrackSource || (exports2.TrackSource = {}));
  function trackSourceFromJSON(object) {
    switch (object) {
      case 0:
      case "UNKNOWN":
        return TrackSource.UNKNOWN;
      case 1:
      case "CAMERA":
        return TrackSource.CAMERA;
      case 2:
      case "MICROPHONE":
        return TrackSource.MICROPHONE;
      case 3:
      case "SCREEN_SHARE":
        return TrackSource.SCREEN_SHARE;
      case 4:
      case "SCREEN_SHARE_AUDIO":
        return TrackSource.SCREEN_SHARE_AUDIO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return TrackSource.UNRECOGNIZED;
    }
  }
  exports2.trackSourceFromJSON = trackSourceFromJSON;
  function trackSourceToJSON(object) {
    switch (object) {
      case TrackSource.UNKNOWN:
        return "UNKNOWN";
      case TrackSource.CAMERA:
        return "CAMERA";
      case TrackSource.MICROPHONE:
        return "MICROPHONE";
      case TrackSource.SCREEN_SHARE:
        return "SCREEN_SHARE";
      case TrackSource.SCREEN_SHARE_AUDIO:
        return "SCREEN_SHARE_AUDIO";
      default:
        return "UNKNOWN";
    }
  }
  exports2.trackSourceToJSON = trackSourceToJSON;
  var VideoQuality;
  (function(VideoQuality2) {
    VideoQuality2[VideoQuality2["LOW"] = 0] = "LOW";
    VideoQuality2[VideoQuality2["MEDIUM"] = 1] = "MEDIUM";
    VideoQuality2[VideoQuality2["HIGH"] = 2] = "HIGH";
    VideoQuality2[VideoQuality2["OFF"] = 3] = "OFF";
    VideoQuality2[VideoQuality2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(VideoQuality = exports2.VideoQuality || (exports2.VideoQuality = {}));
  function videoQualityFromJSON(object) {
    switch (object) {
      case 0:
      case "LOW":
        return VideoQuality.LOW;
      case 1:
      case "MEDIUM":
        return VideoQuality.MEDIUM;
      case 2:
      case "HIGH":
        return VideoQuality.HIGH;
      case 3:
      case "OFF":
        return VideoQuality.OFF;
      case -1:
      case "UNRECOGNIZED":
      default:
        return VideoQuality.UNRECOGNIZED;
    }
  }
  exports2.videoQualityFromJSON = videoQualityFromJSON;
  function videoQualityToJSON(object) {
    switch (object) {
      case VideoQuality.LOW:
        return "LOW";
      case VideoQuality.MEDIUM:
        return "MEDIUM";
      case VideoQuality.HIGH:
        return "HIGH";
      case VideoQuality.OFF:
        return "OFF";
      default:
        return "UNKNOWN";
    }
  }
  exports2.videoQualityToJSON = videoQualityToJSON;
  var ConnectionQuality;
  (function(ConnectionQuality2) {
    ConnectionQuality2[ConnectionQuality2["POOR"] = 0] = "POOR";
    ConnectionQuality2[ConnectionQuality2["GOOD"] = 1] = "GOOD";
    ConnectionQuality2[ConnectionQuality2["EXCELLENT"] = 2] = "EXCELLENT";
    ConnectionQuality2[ConnectionQuality2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(ConnectionQuality = exports2.ConnectionQuality || (exports2.ConnectionQuality = {}));
  function connectionQualityFromJSON(object) {
    switch (object) {
      case 0:
      case "POOR":
        return ConnectionQuality.POOR;
      case 1:
      case "GOOD":
        return ConnectionQuality.GOOD;
      case 2:
      case "EXCELLENT":
        return ConnectionQuality.EXCELLENT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ConnectionQuality.UNRECOGNIZED;
    }
  }
  exports2.connectionQualityFromJSON = connectionQualityFromJSON;
  function connectionQualityToJSON(object) {
    switch (object) {
      case ConnectionQuality.POOR:
        return "POOR";
      case ConnectionQuality.GOOD:
        return "GOOD";
      case ConnectionQuality.EXCELLENT:
        return "EXCELLENT";
      default:
        return "UNKNOWN";
    }
  }
  exports2.connectionQualityToJSON = connectionQualityToJSON;
  var ParticipantInfo_State;
  (function(ParticipantInfo_State2) {
    ParticipantInfo_State2[ParticipantInfo_State2["JOINING"] = 0] = "JOINING";
    ParticipantInfo_State2[ParticipantInfo_State2["JOINED"] = 1] = "JOINED";
    ParticipantInfo_State2[ParticipantInfo_State2["ACTIVE"] = 2] = "ACTIVE";
    ParticipantInfo_State2[ParticipantInfo_State2["DISCONNECTED"] = 3] = "DISCONNECTED";
    ParticipantInfo_State2[ParticipantInfo_State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(ParticipantInfo_State = exports2.ParticipantInfo_State || (exports2.ParticipantInfo_State = {}));
  function participantInfo_StateFromJSON(object) {
    switch (object) {
      case 0:
      case "JOINING":
        return ParticipantInfo_State.JOINING;
      case 1:
      case "JOINED":
        return ParticipantInfo_State.JOINED;
      case 2:
      case "ACTIVE":
        return ParticipantInfo_State.ACTIVE;
      case 3:
      case "DISCONNECTED":
        return ParticipantInfo_State.DISCONNECTED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ParticipantInfo_State.UNRECOGNIZED;
    }
  }
  exports2.participantInfo_StateFromJSON = participantInfo_StateFromJSON;
  function participantInfo_StateToJSON(object) {
    switch (object) {
      case ParticipantInfo_State.JOINING:
        return "JOINING";
      case ParticipantInfo_State.JOINED:
        return "JOINED";
      case ParticipantInfo_State.ACTIVE:
        return "ACTIVE";
      case ParticipantInfo_State.DISCONNECTED:
        return "DISCONNECTED";
      default:
        return "UNKNOWN";
    }
  }
  exports2.participantInfo_StateToJSON = participantInfo_StateToJSON;
  var DataPacket_Kind;
  (function(DataPacket_Kind2) {
    DataPacket_Kind2[DataPacket_Kind2["RELIABLE"] = 0] = "RELIABLE";
    DataPacket_Kind2[DataPacket_Kind2["LOSSY"] = 1] = "LOSSY";
    DataPacket_Kind2[DataPacket_Kind2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(DataPacket_Kind = exports2.DataPacket_Kind || (exports2.DataPacket_Kind = {}));
  function dataPacket_KindFromJSON(object) {
    switch (object) {
      case 0:
      case "RELIABLE":
        return DataPacket_Kind.RELIABLE;
      case 1:
      case "LOSSY":
        return DataPacket_Kind.LOSSY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return DataPacket_Kind.UNRECOGNIZED;
    }
  }
  exports2.dataPacket_KindFromJSON = dataPacket_KindFromJSON;
  function dataPacket_KindToJSON(object) {
    switch (object) {
      case DataPacket_Kind.RELIABLE:
        return "RELIABLE";
      case DataPacket_Kind.LOSSY:
        return "LOSSY";
      default:
        return "UNKNOWN";
    }
  }
  exports2.dataPacket_KindToJSON = dataPacket_KindToJSON;
  var ClientInfo_SDK;
  (function(ClientInfo_SDK2) {
    ClientInfo_SDK2[ClientInfo_SDK2["UNKNOWN"] = 0] = "UNKNOWN";
    ClientInfo_SDK2[ClientInfo_SDK2["JS"] = 1] = "JS";
    ClientInfo_SDK2[ClientInfo_SDK2["SWIFT"] = 2] = "SWIFT";
    ClientInfo_SDK2[ClientInfo_SDK2["ANDROID"] = 3] = "ANDROID";
    ClientInfo_SDK2[ClientInfo_SDK2["FLUTTER"] = 4] = "FLUTTER";
    ClientInfo_SDK2[ClientInfo_SDK2["GO"] = 5] = "GO";
    ClientInfo_SDK2[ClientInfo_SDK2["UNITY"] = 6] = "UNITY";
    ClientInfo_SDK2[ClientInfo_SDK2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(ClientInfo_SDK = exports2.ClientInfo_SDK || (exports2.ClientInfo_SDK = {}));
  function clientInfo_SDKFromJSON(object) {
    switch (object) {
      case 0:
      case "UNKNOWN":
        return ClientInfo_SDK.UNKNOWN;
      case 1:
      case "JS":
        return ClientInfo_SDK.JS;
      case 2:
      case "SWIFT":
        return ClientInfo_SDK.SWIFT;
      case 3:
      case "ANDROID":
        return ClientInfo_SDK.ANDROID;
      case 4:
      case "FLUTTER":
        return ClientInfo_SDK.FLUTTER;
      case 5:
      case "GO":
        return ClientInfo_SDK.GO;
      case 6:
      case "UNITY":
        return ClientInfo_SDK.UNITY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ClientInfo_SDK.UNRECOGNIZED;
    }
  }
  exports2.clientInfo_SDKFromJSON = clientInfo_SDKFromJSON;
  function clientInfo_SDKToJSON(object) {
    switch (object) {
      case ClientInfo_SDK.UNKNOWN:
        return "UNKNOWN";
      case ClientInfo_SDK.JS:
        return "JS";
      case ClientInfo_SDK.SWIFT:
        return "SWIFT";
      case ClientInfo_SDK.ANDROID:
        return "ANDROID";
      case ClientInfo_SDK.FLUTTER:
        return "FLUTTER";
      case ClientInfo_SDK.GO:
        return "GO";
      case ClientInfo_SDK.UNITY:
        return "UNITY";
      default:
        return "UNKNOWN";
    }
  }
  exports2.clientInfo_SDKToJSON = clientInfo_SDKToJSON;
  const baseRoom = { sid: "", name: "", emptyTimeout: 0, maxParticipants: 0, creationTime: 0, turnPassword: "", metadata: "", numParticipants: 0, activeRecording: false };
  exports2.Room = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.sid !== "") {
      writer2.uint32(10).string(message.sid);
    }
    if (message.name !== "") {
      writer2.uint32(18).string(message.name);
    }
    if (message.emptyTimeout !== 0) {
      writer2.uint32(24).uint32(message.emptyTimeout);
    }
    if (message.maxParticipants !== 0) {
      writer2.uint32(32).uint32(message.maxParticipants);
    }
    if (message.creationTime !== 0) {
      writer2.uint32(40).int64(message.creationTime);
    }
    if (message.turnPassword !== "") {
      writer2.uint32(50).string(message.turnPassword);
    }
    for (const v2 of message.enabledCodecs) {
      exports2.Codec.encode(v2, writer2.uint32(58).fork()).ldelim();
    }
    if (message.metadata !== "") {
      writer2.uint32(66).string(message.metadata);
    }
    if (message.numParticipants !== 0) {
      writer2.uint32(72).uint32(message.numParticipants);
    }
    if (message.activeRecording === true) {
      writer2.uint32(80).bool(message.activeRecording);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseRoom);
    message.enabledCodecs = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sid = reader2.string();
          break;
        case 2:
          message.name = reader2.string();
          break;
        case 3:
          message.emptyTimeout = reader2.uint32();
          break;
        case 4:
          message.maxParticipants = reader2.uint32();
          break;
        case 5:
          message.creationTime = longToNumber2(reader2.int64());
          break;
        case 6:
          message.turnPassword = reader2.string();
          break;
        case 7:
          message.enabledCodecs.push(exports2.Codec.decode(reader2, reader2.uint32()));
          break;
        case 8:
          message.metadata = reader2.string();
          break;
        case 9:
          message.numParticipants = reader2.uint32();
          break;
        case 10:
          message.activeRecording = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseRoom);
    message.enabledCodecs = [];
    if (object.sid !== void 0 && object.sid !== null) {
      message.sid = String(object.sid);
    } else {
      message.sid = "";
    }
    if (object.name !== void 0 && object.name !== null) {
      message.name = String(object.name);
    } else {
      message.name = "";
    }
    if (object.emptyTimeout !== void 0 && object.emptyTimeout !== null) {
      message.emptyTimeout = Number(object.emptyTimeout);
    } else {
      message.emptyTimeout = 0;
    }
    if (object.maxParticipants !== void 0 && object.maxParticipants !== null) {
      message.maxParticipants = Number(object.maxParticipants);
    } else {
      message.maxParticipants = 0;
    }
    if (object.creationTime !== void 0 && object.creationTime !== null) {
      message.creationTime = Number(object.creationTime);
    } else {
      message.creationTime = 0;
    }
    if (object.turnPassword !== void 0 && object.turnPassword !== null) {
      message.turnPassword = String(object.turnPassword);
    } else {
      message.turnPassword = "";
    }
    if (object.enabledCodecs !== void 0 && object.enabledCodecs !== null) {
      for (const e2 of object.enabledCodecs) {
        message.enabledCodecs.push(exports2.Codec.fromJSON(e2));
      }
    }
    if (object.metadata !== void 0 && object.metadata !== null) {
      message.metadata = String(object.metadata);
    } else {
      message.metadata = "";
    }
    if (object.numParticipants !== void 0 && object.numParticipants !== null) {
      message.numParticipants = Number(object.numParticipants);
    } else {
      message.numParticipants = 0;
    }
    if (object.activeRecording !== void 0 && object.activeRecording !== null) {
      message.activeRecording = Boolean(object.activeRecording);
    } else {
      message.activeRecording = false;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.sid !== void 0 && (obj.sid = message.sid);
    message.name !== void 0 && (obj.name = message.name);
    message.emptyTimeout !== void 0 && (obj.emptyTimeout = message.emptyTimeout);
    message.maxParticipants !== void 0 && (obj.maxParticipants = message.maxParticipants);
    message.creationTime !== void 0 && (obj.creationTime = message.creationTime);
    message.turnPassword !== void 0 && (obj.turnPassword = message.turnPassword);
    if (message.enabledCodecs) {
      obj.enabledCodecs = message.enabledCodecs.map((e2) => e2 ? exports2.Codec.toJSON(e2) : void 0);
    } else {
      obj.enabledCodecs = [];
    }
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.numParticipants !== void 0 && (obj.numParticipants = message.numParticipants);
    message.activeRecording !== void 0 && (obj.activeRecording = message.activeRecording);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
    const message = Object.assign({}, baseRoom);
    message.sid = (_a2 = object.sid) !== null && _a2 !== void 0 ? _a2 : "";
    message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
    message.emptyTimeout = (_c = object.emptyTimeout) !== null && _c !== void 0 ? _c : 0;
    message.maxParticipants = (_d = object.maxParticipants) !== null && _d !== void 0 ? _d : 0;
    message.creationTime = (_e = object.creationTime) !== null && _e !== void 0 ? _e : 0;
    message.turnPassword = (_f = object.turnPassword) !== null && _f !== void 0 ? _f : "";
    message.enabledCodecs = [];
    if (object.enabledCodecs !== void 0 && object.enabledCodecs !== null) {
      for (const e2 of object.enabledCodecs) {
        message.enabledCodecs.push(exports2.Codec.fromPartial(e2));
      }
    }
    message.metadata = (_g = object.metadata) !== null && _g !== void 0 ? _g : "";
    message.numParticipants = (_h = object.numParticipants) !== null && _h !== void 0 ? _h : 0;
    message.activeRecording = (_j = object.activeRecording) !== null && _j !== void 0 ? _j : false;
    return message;
  } };
  const baseCodec = { mime: "", fmtpLine: "" };
  exports2.Codec = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.mime !== "") {
      writer2.uint32(10).string(message.mime);
    }
    if (message.fmtpLine !== "") {
      writer2.uint32(18).string(message.fmtpLine);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseCodec);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mime = reader2.string();
          break;
        case 2:
          message.fmtpLine = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseCodec);
    if (object.mime !== void 0 && object.mime !== null) {
      message.mime = String(object.mime);
    } else {
      message.mime = "";
    }
    if (object.fmtpLine !== void 0 && object.fmtpLine !== null) {
      message.fmtpLine = String(object.fmtpLine);
    } else {
      message.fmtpLine = "";
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.mime !== void 0 && (obj.mime = message.mime);
    message.fmtpLine !== void 0 && (obj.fmtpLine = message.fmtpLine);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = Object.assign({}, baseCodec);
    message.mime = (_a2 = object.mime) !== null && _a2 !== void 0 ? _a2 : "";
    message.fmtpLine = (_b = object.fmtpLine) !== null && _b !== void 0 ? _b : "";
    return message;
  } };
  const baseParticipantInfo = { sid: "", identity: "", state: 0, metadata: "", joinedAt: 0, hidden: false, recorder: false, name: "" };
  exports2.ParticipantInfo = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.sid !== "") {
      writer2.uint32(10).string(message.sid);
    }
    if (message.identity !== "") {
      writer2.uint32(18).string(message.identity);
    }
    if (message.state !== 0) {
      writer2.uint32(24).int32(message.state);
    }
    for (const v2 of message.tracks) {
      exports2.TrackInfo.encode(v2, writer2.uint32(34).fork()).ldelim();
    }
    if (message.metadata !== "") {
      writer2.uint32(42).string(message.metadata);
    }
    if (message.joinedAt !== 0) {
      writer2.uint32(48).int64(message.joinedAt);
    }
    if (message.hidden === true) {
      writer2.uint32(56).bool(message.hidden);
    }
    if (message.recorder === true) {
      writer2.uint32(64).bool(message.recorder);
    }
    if (message.name !== "") {
      writer2.uint32(74).string(message.name);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseParticipantInfo);
    message.tracks = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sid = reader2.string();
          break;
        case 2:
          message.identity = reader2.string();
          break;
        case 3:
          message.state = reader2.int32();
          break;
        case 4:
          message.tracks.push(exports2.TrackInfo.decode(reader2, reader2.uint32()));
          break;
        case 5:
          message.metadata = reader2.string();
          break;
        case 6:
          message.joinedAt = longToNumber2(reader2.int64());
          break;
        case 7:
          message.hidden = reader2.bool();
          break;
        case 8:
          message.recorder = reader2.bool();
          break;
        case 9:
          message.name = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseParticipantInfo);
    message.tracks = [];
    if (object.sid !== void 0 && object.sid !== null) {
      message.sid = String(object.sid);
    } else {
      message.sid = "";
    }
    if (object.identity !== void 0 && object.identity !== null) {
      message.identity = String(object.identity);
    } else {
      message.identity = "";
    }
    if (object.state !== void 0 && object.state !== null) {
      message.state = participantInfo_StateFromJSON(object.state);
    } else {
      message.state = 0;
    }
    if (object.tracks !== void 0 && object.tracks !== null) {
      for (const e2 of object.tracks) {
        message.tracks.push(exports2.TrackInfo.fromJSON(e2));
      }
    }
    if (object.metadata !== void 0 && object.metadata !== null) {
      message.metadata = String(object.metadata);
    } else {
      message.metadata = "";
    }
    if (object.joinedAt !== void 0 && object.joinedAt !== null) {
      message.joinedAt = Number(object.joinedAt);
    } else {
      message.joinedAt = 0;
    }
    if (object.hidden !== void 0 && object.hidden !== null) {
      message.hidden = Boolean(object.hidden);
    } else {
      message.hidden = false;
    }
    if (object.recorder !== void 0 && object.recorder !== null) {
      message.recorder = Boolean(object.recorder);
    } else {
      message.recorder = false;
    }
    if (object.name !== void 0 && object.name !== null) {
      message.name = String(object.name);
    } else {
      message.name = "";
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.sid !== void 0 && (obj.sid = message.sid);
    message.identity !== void 0 && (obj.identity = message.identity);
    message.state !== void 0 && (obj.state = participantInfo_StateToJSON(message.state));
    if (message.tracks) {
      obj.tracks = message.tracks.map((e2) => e2 ? exports2.TrackInfo.toJSON(e2) : void 0);
    } else {
      obj.tracks = [];
    }
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.joinedAt !== void 0 && (obj.joinedAt = message.joinedAt);
    message.hidden !== void 0 && (obj.hidden = message.hidden);
    message.recorder !== void 0 && (obj.recorder = message.recorder);
    message.name !== void 0 && (obj.name = message.name);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    const message = Object.assign({}, baseParticipantInfo);
    message.sid = (_a2 = object.sid) !== null && _a2 !== void 0 ? _a2 : "";
    message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : "";
    message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;
    message.tracks = [];
    if (object.tracks !== void 0 && object.tracks !== null) {
      for (const e2 of object.tracks) {
        message.tracks.push(exports2.TrackInfo.fromPartial(e2));
      }
    }
    message.metadata = (_d = object.metadata) !== null && _d !== void 0 ? _d : "";
    message.joinedAt = (_e = object.joinedAt) !== null && _e !== void 0 ? _e : 0;
    message.hidden = (_f = object.hidden) !== null && _f !== void 0 ? _f : false;
    message.recorder = (_g = object.recorder) !== null && _g !== void 0 ? _g : false;
    message.name = (_h = object.name) !== null && _h !== void 0 ? _h : "";
    return message;
  } };
  const baseTrackInfo = { sid: "", type: 0, name: "", muted: false, width: 0, height: 0, simulcast: false, disableDtx: false, source: 0, mimeType: "", mid: "" };
  exports2.TrackInfo = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.sid !== "") {
      writer2.uint32(10).string(message.sid);
    }
    if (message.type !== 0) {
      writer2.uint32(16).int32(message.type);
    }
    if (message.name !== "") {
      writer2.uint32(26).string(message.name);
    }
    if (message.muted === true) {
      writer2.uint32(32).bool(message.muted);
    }
    if (message.width !== 0) {
      writer2.uint32(40).uint32(message.width);
    }
    if (message.height !== 0) {
      writer2.uint32(48).uint32(message.height);
    }
    if (message.simulcast === true) {
      writer2.uint32(56).bool(message.simulcast);
    }
    if (message.disableDtx === true) {
      writer2.uint32(64).bool(message.disableDtx);
    }
    if (message.source !== 0) {
      writer2.uint32(72).int32(message.source);
    }
    for (const v2 of message.layers) {
      exports2.VideoLayer.encode(v2, writer2.uint32(82).fork()).ldelim();
    }
    if (message.mimeType !== "") {
      writer2.uint32(90).string(message.mimeType);
    }
    if (message.mid !== "") {
      writer2.uint32(98).string(message.mid);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseTrackInfo);
    message.layers = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sid = reader2.string();
          break;
        case 2:
          message.type = reader2.int32();
          break;
        case 3:
          message.name = reader2.string();
          break;
        case 4:
          message.muted = reader2.bool();
          break;
        case 5:
          message.width = reader2.uint32();
          break;
        case 6:
          message.height = reader2.uint32();
          break;
        case 7:
          message.simulcast = reader2.bool();
          break;
        case 8:
          message.disableDtx = reader2.bool();
          break;
        case 9:
          message.source = reader2.int32();
          break;
        case 10:
          message.layers.push(exports2.VideoLayer.decode(reader2, reader2.uint32()));
          break;
        case 11:
          message.mimeType = reader2.string();
          break;
        case 12:
          message.mid = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseTrackInfo);
    message.layers = [];
    if (object.sid !== void 0 && object.sid !== null) {
      message.sid = String(object.sid);
    } else {
      message.sid = "";
    }
    if (object.type !== void 0 && object.type !== null) {
      message.type = trackTypeFromJSON(object.type);
    } else {
      message.type = 0;
    }
    if (object.name !== void 0 && object.name !== null) {
      message.name = String(object.name);
    } else {
      message.name = "";
    }
    if (object.muted !== void 0 && object.muted !== null) {
      message.muted = Boolean(object.muted);
    } else {
      message.muted = false;
    }
    if (object.width !== void 0 && object.width !== null) {
      message.width = Number(object.width);
    } else {
      message.width = 0;
    }
    if (object.height !== void 0 && object.height !== null) {
      message.height = Number(object.height);
    } else {
      message.height = 0;
    }
    if (object.simulcast !== void 0 && object.simulcast !== null) {
      message.simulcast = Boolean(object.simulcast);
    } else {
      message.simulcast = false;
    }
    if (object.disableDtx !== void 0 && object.disableDtx !== null) {
      message.disableDtx = Boolean(object.disableDtx);
    } else {
      message.disableDtx = false;
    }
    if (object.source !== void 0 && object.source !== null) {
      message.source = trackSourceFromJSON(object.source);
    } else {
      message.source = 0;
    }
    if (object.layers !== void 0 && object.layers !== null) {
      for (const e2 of object.layers) {
        message.layers.push(exports2.VideoLayer.fromJSON(e2));
      }
    }
    if (object.mimeType !== void 0 && object.mimeType !== null) {
      message.mimeType = String(object.mimeType);
    } else {
      message.mimeType = "";
    }
    if (object.mid !== void 0 && object.mid !== null) {
      message.mid = String(object.mid);
    } else {
      message.mid = "";
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.sid !== void 0 && (obj.sid = message.sid);
    message.type !== void 0 && (obj.type = trackTypeToJSON(message.type));
    message.name !== void 0 && (obj.name = message.name);
    message.muted !== void 0 && (obj.muted = message.muted);
    message.width !== void 0 && (obj.width = message.width);
    message.height !== void 0 && (obj.height = message.height);
    message.simulcast !== void 0 && (obj.simulcast = message.simulcast);
    message.disableDtx !== void 0 && (obj.disableDtx = message.disableDtx);
    message.source !== void 0 && (obj.source = trackSourceToJSON(message.source));
    if (message.layers) {
      obj.layers = message.layers.map((e2) => e2 ? exports2.VideoLayer.toJSON(e2) : void 0);
    } else {
      obj.layers = [];
    }
    message.mimeType !== void 0 && (obj.mimeType = message.mimeType);
    message.mid !== void 0 && (obj.mid = message.mid);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const message = Object.assign({}, baseTrackInfo);
    message.sid = (_a2 = object.sid) !== null && _a2 !== void 0 ? _a2 : "";
    message.type = (_b = object.type) !== null && _b !== void 0 ? _b : 0;
    message.name = (_c = object.name) !== null && _c !== void 0 ? _c : "";
    message.muted = (_d = object.muted) !== null && _d !== void 0 ? _d : false;
    message.width = (_e = object.width) !== null && _e !== void 0 ? _e : 0;
    message.height = (_f = object.height) !== null && _f !== void 0 ? _f : 0;
    message.simulcast = (_g = object.simulcast) !== null && _g !== void 0 ? _g : false;
    message.disableDtx = (_h = object.disableDtx) !== null && _h !== void 0 ? _h : false;
    message.source = (_j = object.source) !== null && _j !== void 0 ? _j : 0;
    message.layers = [];
    if (object.layers !== void 0 && object.layers !== null) {
      for (const e2 of object.layers) {
        message.layers.push(exports2.VideoLayer.fromPartial(e2));
      }
    }
    message.mimeType = (_k = object.mimeType) !== null && _k !== void 0 ? _k : "";
    message.mid = (_l = object.mid) !== null && _l !== void 0 ? _l : "";
    return message;
  } };
  const baseVideoLayer = { quality: 0, width: 0, height: 0, bitrate: 0, ssrc: 0 };
  exports2.VideoLayer = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.quality !== 0) {
      writer2.uint32(8).int32(message.quality);
    }
    if (message.width !== 0) {
      writer2.uint32(16).uint32(message.width);
    }
    if (message.height !== 0) {
      writer2.uint32(24).uint32(message.height);
    }
    if (message.bitrate !== 0) {
      writer2.uint32(32).uint32(message.bitrate);
    }
    if (message.ssrc !== 0) {
      writer2.uint32(40).uint32(message.ssrc);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseVideoLayer);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.quality = reader2.int32();
          break;
        case 2:
          message.width = reader2.uint32();
          break;
        case 3:
          message.height = reader2.uint32();
          break;
        case 4:
          message.bitrate = reader2.uint32();
          break;
        case 5:
          message.ssrc = reader2.uint32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseVideoLayer);
    if (object.quality !== void 0 && object.quality !== null) {
      message.quality = videoQualityFromJSON(object.quality);
    } else {
      message.quality = 0;
    }
    if (object.width !== void 0 && object.width !== null) {
      message.width = Number(object.width);
    } else {
      message.width = 0;
    }
    if (object.height !== void 0 && object.height !== null) {
      message.height = Number(object.height);
    } else {
      message.height = 0;
    }
    if (object.bitrate !== void 0 && object.bitrate !== null) {
      message.bitrate = Number(object.bitrate);
    } else {
      message.bitrate = 0;
    }
    if (object.ssrc !== void 0 && object.ssrc !== null) {
      message.ssrc = Number(object.ssrc);
    } else {
      message.ssrc = 0;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.quality !== void 0 && (obj.quality = videoQualityToJSON(message.quality));
    message.width !== void 0 && (obj.width = message.width);
    message.height !== void 0 && (obj.height = message.height);
    message.bitrate !== void 0 && (obj.bitrate = message.bitrate);
    message.ssrc !== void 0 && (obj.ssrc = message.ssrc);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e;
    const message = Object.assign({}, baseVideoLayer);
    message.quality = (_a2 = object.quality) !== null && _a2 !== void 0 ? _a2 : 0;
    message.width = (_b = object.width) !== null && _b !== void 0 ? _b : 0;
    message.height = (_c = object.height) !== null && _c !== void 0 ? _c : 0;
    message.bitrate = (_d = object.bitrate) !== null && _d !== void 0 ? _d : 0;
    message.ssrc = (_e = object.ssrc) !== null && _e !== void 0 ? _e : 0;
    return message;
  } };
  const baseDataPacket = { kind: 0 };
  exports2.DataPacket = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.kind !== 0) {
      writer2.uint32(8).int32(message.kind);
    }
    if (message.user !== void 0) {
      exports2.UserPacket.encode(message.user, writer2.uint32(18).fork()).ldelim();
    }
    if (message.speaker !== void 0) {
      exports2.ActiveSpeakerUpdate.encode(message.speaker, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseDataPacket);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader2.int32();
          break;
        case 2:
          message.user = exports2.UserPacket.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.speaker = exports2.ActiveSpeakerUpdate.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseDataPacket);
    if (object.kind !== void 0 && object.kind !== null) {
      message.kind = dataPacket_KindFromJSON(object.kind);
    } else {
      message.kind = 0;
    }
    if (object.user !== void 0 && object.user !== null) {
      message.user = exports2.UserPacket.fromJSON(object.user);
    } else {
      message.user = void 0;
    }
    if (object.speaker !== void 0 && object.speaker !== null) {
      message.speaker = exports2.ActiveSpeakerUpdate.fromJSON(object.speaker);
    } else {
      message.speaker = void 0;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = dataPacket_KindToJSON(message.kind));
    message.user !== void 0 && (obj.user = message.user ? exports2.UserPacket.toJSON(message.user) : void 0);
    message.speaker !== void 0 && (obj.speaker = message.speaker ? exports2.ActiveSpeakerUpdate.toJSON(message.speaker) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = Object.assign({}, baseDataPacket);
    message.kind = (_a2 = object.kind) !== null && _a2 !== void 0 ? _a2 : 0;
    if (object.user !== void 0 && object.user !== null) {
      message.user = exports2.UserPacket.fromPartial(object.user);
    } else {
      message.user = void 0;
    }
    if (object.speaker !== void 0 && object.speaker !== null) {
      message.speaker = exports2.ActiveSpeakerUpdate.fromPartial(object.speaker);
    } else {
      message.speaker = void 0;
    }
    return message;
  } };
  const baseActiveSpeakerUpdate = {};
  exports2.ActiveSpeakerUpdate = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    for (const v2 of message.speakers) {
      exports2.SpeakerInfo.encode(v2, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseActiveSpeakerUpdate);
    message.speakers = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.speakers.push(exports2.SpeakerInfo.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseActiveSpeakerUpdate);
    message.speakers = [];
    if (object.speakers !== void 0 && object.speakers !== null) {
      for (const e2 of object.speakers) {
        message.speakers.push(exports2.SpeakerInfo.fromJSON(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    if (message.speakers) {
      obj.speakers = message.speakers.map((e2) => e2 ? exports2.SpeakerInfo.toJSON(e2) : void 0);
    } else {
      obj.speakers = [];
    }
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseActiveSpeakerUpdate);
    message.speakers = [];
    if (object.speakers !== void 0 && object.speakers !== null) {
      for (const e2 of object.speakers) {
        message.speakers.push(exports2.SpeakerInfo.fromPartial(e2));
      }
    }
    return message;
  } };
  const baseSpeakerInfo = { sid: "", level: 0, active: false };
  exports2.SpeakerInfo = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.sid !== "") {
      writer2.uint32(10).string(message.sid);
    }
    if (message.level !== 0) {
      writer2.uint32(21).float(message.level);
    }
    if (message.active === true) {
      writer2.uint32(24).bool(message.active);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseSpeakerInfo);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sid = reader2.string();
          break;
        case 2:
          message.level = reader2.float();
          break;
        case 3:
          message.active = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseSpeakerInfo);
    if (object.sid !== void 0 && object.sid !== null) {
      message.sid = String(object.sid);
    } else {
      message.sid = "";
    }
    if (object.level !== void 0 && object.level !== null) {
      message.level = Number(object.level);
    } else {
      message.level = 0;
    }
    if (object.active !== void 0 && object.active !== null) {
      message.active = Boolean(object.active);
    } else {
      message.active = false;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.sid !== void 0 && (obj.sid = message.sid);
    message.level !== void 0 && (obj.level = message.level);
    message.active !== void 0 && (obj.active = message.active);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = Object.assign({}, baseSpeakerInfo);
    message.sid = (_a2 = object.sid) !== null && _a2 !== void 0 ? _a2 : "";
    message.level = (_b = object.level) !== null && _b !== void 0 ? _b : 0;
    message.active = (_c = object.active) !== null && _c !== void 0 ? _c : false;
    return message;
  } };
  const baseUserPacket = { participantSid: "", destinationSids: "" };
  exports2.UserPacket = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.participantSid !== "") {
      writer2.uint32(10).string(message.participantSid);
    }
    if (message.payload.length !== 0) {
      writer2.uint32(18).bytes(message.payload);
    }
    for (const v2 of message.destinationSids) {
      writer2.uint32(26).string(v2);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseUserPacket);
    message.destinationSids = [];
    message.payload = new Uint8Array();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participantSid = reader2.string();
          break;
        case 2:
          message.payload = reader2.bytes();
          break;
        case 3:
          message.destinationSids.push(reader2.string());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseUserPacket);
    message.destinationSids = [];
    message.payload = new Uint8Array();
    if (object.participantSid !== void 0 && object.participantSid !== null) {
      message.participantSid = String(object.participantSid);
    } else {
      message.participantSid = "";
    }
    if (object.payload !== void 0 && object.payload !== null) {
      message.payload = bytesFromBase64(object.payload);
    }
    if (object.destinationSids !== void 0 && object.destinationSids !== null) {
      for (const e2 of object.destinationSids) {
        message.destinationSids.push(String(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
    message.payload !== void 0 && (obj.payload = base64FromBytes(message.payload !== void 0 ? message.payload : new Uint8Array()));
    if (message.destinationSids) {
      obj.destinationSids = message.destinationSids.map((e2) => e2);
    } else {
      obj.destinationSids = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = Object.assign({}, baseUserPacket);
    message.participantSid = (_a2 = object.participantSid) !== null && _a2 !== void 0 ? _a2 : "";
    message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : new Uint8Array();
    message.destinationSids = [];
    if (object.destinationSids !== void 0 && object.destinationSids !== null) {
      for (const e2 of object.destinationSids) {
        message.destinationSids.push(e2);
      }
    }
    return message;
  } };
  const baseParticipantTracks = { participantSid: "", trackSids: "" };
  exports2.ParticipantTracks = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.participantSid !== "") {
      writer2.uint32(10).string(message.participantSid);
    }
    for (const v2 of message.trackSids) {
      writer2.uint32(18).string(v2);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseParticipantTracks);
    message.trackSids = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participantSid = reader2.string();
          break;
        case 2:
          message.trackSids.push(reader2.string());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseParticipantTracks);
    message.trackSids = [];
    if (object.participantSid !== void 0 && object.participantSid !== null) {
      message.participantSid = String(object.participantSid);
    } else {
      message.participantSid = "";
    }
    if (object.trackSids !== void 0 && object.trackSids !== null) {
      for (const e2 of object.trackSids) {
        message.trackSids.push(String(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
    if (message.trackSids) {
      obj.trackSids = message.trackSids.map((e2) => e2);
    } else {
      obj.trackSids = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = Object.assign({}, baseParticipantTracks);
    message.participantSid = (_a2 = object.participantSid) !== null && _a2 !== void 0 ? _a2 : "";
    message.trackSids = [];
    if (object.trackSids !== void 0 && object.trackSids !== null) {
      for (const e2 of object.trackSids) {
        message.trackSids.push(e2);
      }
    }
    return message;
  } };
  const baseClientInfo = { sdk: 0, version: "", protocol: 0, os: "", osVersion: "", deviceModel: "", browser: "", browserVersion: "" };
  exports2.ClientInfo = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.sdk !== 0) {
      writer2.uint32(8).int32(message.sdk);
    }
    if (message.version !== "") {
      writer2.uint32(18).string(message.version);
    }
    if (message.protocol !== 0) {
      writer2.uint32(24).int32(message.protocol);
    }
    if (message.os !== "") {
      writer2.uint32(34).string(message.os);
    }
    if (message.osVersion !== "") {
      writer2.uint32(42).string(message.osVersion);
    }
    if (message.deviceModel !== "") {
      writer2.uint32(50).string(message.deviceModel);
    }
    if (message.browser !== "") {
      writer2.uint32(58).string(message.browser);
    }
    if (message.browserVersion !== "") {
      writer2.uint32(66).string(message.browserVersion);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseClientInfo);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sdk = reader2.int32();
          break;
        case 2:
          message.version = reader2.string();
          break;
        case 3:
          message.protocol = reader2.int32();
          break;
        case 4:
          message.os = reader2.string();
          break;
        case 5:
          message.osVersion = reader2.string();
          break;
        case 6:
          message.deviceModel = reader2.string();
          break;
        case 7:
          message.browser = reader2.string();
          break;
        case 8:
          message.browserVersion = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseClientInfo);
    if (object.sdk !== void 0 && object.sdk !== null) {
      message.sdk = clientInfo_SDKFromJSON(object.sdk);
    } else {
      message.sdk = 0;
    }
    if (object.version !== void 0 && object.version !== null) {
      message.version = String(object.version);
    } else {
      message.version = "";
    }
    if (object.protocol !== void 0 && object.protocol !== null) {
      message.protocol = Number(object.protocol);
    } else {
      message.protocol = 0;
    }
    if (object.os !== void 0 && object.os !== null) {
      message.os = String(object.os);
    } else {
      message.os = "";
    }
    if (object.osVersion !== void 0 && object.osVersion !== null) {
      message.osVersion = String(object.osVersion);
    } else {
      message.osVersion = "";
    }
    if (object.deviceModel !== void 0 && object.deviceModel !== null) {
      message.deviceModel = String(object.deviceModel);
    } else {
      message.deviceModel = "";
    }
    if (object.browser !== void 0 && object.browser !== null) {
      message.browser = String(object.browser);
    } else {
      message.browser = "";
    }
    if (object.browserVersion !== void 0 && object.browserVersion !== null) {
      message.browserVersion = String(object.browserVersion);
    } else {
      message.browserVersion = "";
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.sdk !== void 0 && (obj.sdk = clientInfo_SDKToJSON(message.sdk));
    message.version !== void 0 && (obj.version = message.version);
    message.protocol !== void 0 && (obj.protocol = message.protocol);
    message.os !== void 0 && (obj.os = message.os);
    message.osVersion !== void 0 && (obj.osVersion = message.osVersion);
    message.deviceModel !== void 0 && (obj.deviceModel = message.deviceModel);
    message.browser !== void 0 && (obj.browser = message.browser);
    message.browserVersion !== void 0 && (obj.browserVersion = message.browserVersion);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    const message = Object.assign({}, baseClientInfo);
    message.sdk = (_a2 = object.sdk) !== null && _a2 !== void 0 ? _a2 : 0;
    message.version = (_b = object.version) !== null && _b !== void 0 ? _b : "";
    message.protocol = (_c = object.protocol) !== null && _c !== void 0 ? _c : 0;
    message.os = (_d = object.os) !== null && _d !== void 0 ? _d : "";
    message.osVersion = (_e = object.osVersion) !== null && _e !== void 0 ? _e : "";
    message.deviceModel = (_f = object.deviceModel) !== null && _f !== void 0 ? _f : "";
    message.browser = (_g = object.browser) !== null && _g !== void 0 ? _g : "";
    message.browserVersion = (_h = object.browserVersion) !== null && _h !== void 0 ? _h : "";
    return message;
  } };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal !== "undefined")
      return commonjsGlobal;
    throw "Unable to locate global object";
  })();
  const atob2 = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
  function bytesFromBase64(b64) {
    const bin = atob2(b64);
    const arr = new Uint8Array(bin.length);
    for (let i2 = 0; i2 < bin.length; ++i2) {
      arr[i2] = bin.charCodeAt(i2);
    }
    return arr;
  }
  const btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
  function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
      bin.push(String.fromCharCode(byte));
    }
    return btoa2(bin.join(""));
  }
  function longToNumber2(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
      throw new globalThis2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
  }
  if (minimal_1.default.util.Long !== long_12.default) {
    minimal_1.default.util.Long = long_12.default;
    minimal_1.default.configure();
  }
})(livekit_models$1);
var LocalParticipant$1 = {};
var livekit_rtc = {};
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.SimulateScenario = exports2.SyncState = exports2.SubscriptionPermissionUpdate = exports2.UpdateSubscriptionPermissions = exports2.TrackPermission = exports2.SubscribedQualityUpdate = exports2.SubscribedQuality = exports2.StreamStateUpdate = exports2.StreamStateInfo = exports2.ConnectionQualityUpdate = exports2.ConnectionQualityInfo = exports2.RoomUpdate = exports2.SpeakersChanged = exports2.ICEServer = exports2.UpdateVideoLayers = exports2.LeaveRequest = exports2.UpdateTrackSettings = exports2.UpdateSubscription = exports2.ParticipantUpdate = exports2.SessionDescription = exports2.TrackPublishedResponse = exports2.JoinResponse = exports2.MuteTrackRequest = exports2.TrickleRequest = exports2.AddTrackRequest = exports2.SignalResponse = exports2.SignalRequest = exports2.streamStateToJSON = exports2.streamStateFromJSON = exports2.StreamState = exports2.signalTargetToJSON = exports2.signalTargetFromJSON = exports2.SignalTarget = exports2.protobufPackage = void 0;
  const long_12 = __importDefault2(umd.exports);
  const minimal_1 = __importDefault2(minimal);
  const livekit_models_12 = livekit_models$1;
  exports2.protobufPackage = "livekit";
  var SignalTarget;
  (function(SignalTarget2) {
    SignalTarget2[SignalTarget2["PUBLISHER"] = 0] = "PUBLISHER";
    SignalTarget2[SignalTarget2["SUBSCRIBER"] = 1] = "SUBSCRIBER";
    SignalTarget2[SignalTarget2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(SignalTarget = exports2.SignalTarget || (exports2.SignalTarget = {}));
  function signalTargetFromJSON(object) {
    switch (object) {
      case 0:
      case "PUBLISHER":
        return SignalTarget.PUBLISHER;
      case 1:
      case "SUBSCRIBER":
        return SignalTarget.SUBSCRIBER;
      case -1:
      case "UNRECOGNIZED":
      default:
        return SignalTarget.UNRECOGNIZED;
    }
  }
  exports2.signalTargetFromJSON = signalTargetFromJSON;
  function signalTargetToJSON(object) {
    switch (object) {
      case SignalTarget.PUBLISHER:
        return "PUBLISHER";
      case SignalTarget.SUBSCRIBER:
        return "SUBSCRIBER";
      default:
        return "UNKNOWN";
    }
  }
  exports2.signalTargetToJSON = signalTargetToJSON;
  var StreamState;
  (function(StreamState2) {
    StreamState2[StreamState2["ACTIVE"] = 0] = "ACTIVE";
    StreamState2[StreamState2["PAUSED"] = 1] = "PAUSED";
    StreamState2[StreamState2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(StreamState = exports2.StreamState || (exports2.StreamState = {}));
  function streamStateFromJSON(object) {
    switch (object) {
      case 0:
      case "ACTIVE":
        return StreamState.ACTIVE;
      case 1:
      case "PAUSED":
        return StreamState.PAUSED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return StreamState.UNRECOGNIZED;
    }
  }
  exports2.streamStateFromJSON = streamStateFromJSON;
  function streamStateToJSON(object) {
    switch (object) {
      case StreamState.ACTIVE:
        return "ACTIVE";
      case StreamState.PAUSED:
        return "PAUSED";
      default:
        return "UNKNOWN";
    }
  }
  exports2.streamStateToJSON = streamStateToJSON;
  const baseSignalRequest = {};
  exports2.SignalRequest = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.offer !== void 0) {
      exports2.SessionDescription.encode(message.offer, writer2.uint32(10).fork()).ldelim();
    }
    if (message.answer !== void 0) {
      exports2.SessionDescription.encode(message.answer, writer2.uint32(18).fork()).ldelim();
    }
    if (message.trickle !== void 0) {
      exports2.TrickleRequest.encode(message.trickle, writer2.uint32(26).fork()).ldelim();
    }
    if (message.addTrack !== void 0) {
      exports2.AddTrackRequest.encode(message.addTrack, writer2.uint32(34).fork()).ldelim();
    }
    if (message.mute !== void 0) {
      exports2.MuteTrackRequest.encode(message.mute, writer2.uint32(42).fork()).ldelim();
    }
    if (message.subscription !== void 0) {
      exports2.UpdateSubscription.encode(message.subscription, writer2.uint32(50).fork()).ldelim();
    }
    if (message.trackSetting !== void 0) {
      exports2.UpdateTrackSettings.encode(message.trackSetting, writer2.uint32(58).fork()).ldelim();
    }
    if (message.leave !== void 0) {
      exports2.LeaveRequest.encode(message.leave, writer2.uint32(66).fork()).ldelim();
    }
    if (message.updateLayers !== void 0) {
      exports2.UpdateVideoLayers.encode(message.updateLayers, writer2.uint32(82).fork()).ldelim();
    }
    if (message.subscriptionPermissions !== void 0) {
      exports2.UpdateSubscriptionPermissions.encode(message.subscriptionPermissions, writer2.uint32(90).fork()).ldelim();
    }
    if (message.syncState !== void 0) {
      exports2.SyncState.encode(message.syncState, writer2.uint32(98).fork()).ldelim();
    }
    if (message.simulate !== void 0) {
      exports2.SimulateScenario.encode(message.simulate, writer2.uint32(106).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseSignalRequest);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.offer = exports2.SessionDescription.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.answer = exports2.SessionDescription.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.trickle = exports2.TrickleRequest.decode(reader2, reader2.uint32());
          break;
        case 4:
          message.addTrack = exports2.AddTrackRequest.decode(reader2, reader2.uint32());
          break;
        case 5:
          message.mute = exports2.MuteTrackRequest.decode(reader2, reader2.uint32());
          break;
        case 6:
          message.subscription = exports2.UpdateSubscription.decode(reader2, reader2.uint32());
          break;
        case 7:
          message.trackSetting = exports2.UpdateTrackSettings.decode(reader2, reader2.uint32());
          break;
        case 8:
          message.leave = exports2.LeaveRequest.decode(reader2, reader2.uint32());
          break;
        case 10:
          message.updateLayers = exports2.UpdateVideoLayers.decode(reader2, reader2.uint32());
          break;
        case 11:
          message.subscriptionPermissions = exports2.UpdateSubscriptionPermissions.decode(reader2, reader2.uint32());
          break;
        case 12:
          message.syncState = exports2.SyncState.decode(reader2, reader2.uint32());
          break;
        case 13:
          message.simulate = exports2.SimulateScenario.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseSignalRequest);
    if (object.offer !== void 0 && object.offer !== null) {
      message.offer = exports2.SessionDescription.fromJSON(object.offer);
    } else {
      message.offer = void 0;
    }
    if (object.answer !== void 0 && object.answer !== null) {
      message.answer = exports2.SessionDescription.fromJSON(object.answer);
    } else {
      message.answer = void 0;
    }
    if (object.trickle !== void 0 && object.trickle !== null) {
      message.trickle = exports2.TrickleRequest.fromJSON(object.trickle);
    } else {
      message.trickle = void 0;
    }
    if (object.addTrack !== void 0 && object.addTrack !== null) {
      message.addTrack = exports2.AddTrackRequest.fromJSON(object.addTrack);
    } else {
      message.addTrack = void 0;
    }
    if (object.mute !== void 0 && object.mute !== null) {
      message.mute = exports2.MuteTrackRequest.fromJSON(object.mute);
    } else {
      message.mute = void 0;
    }
    if (object.subscription !== void 0 && object.subscription !== null) {
      message.subscription = exports2.UpdateSubscription.fromJSON(object.subscription);
    } else {
      message.subscription = void 0;
    }
    if (object.trackSetting !== void 0 && object.trackSetting !== null) {
      message.trackSetting = exports2.UpdateTrackSettings.fromJSON(object.trackSetting);
    } else {
      message.trackSetting = void 0;
    }
    if (object.leave !== void 0 && object.leave !== null) {
      message.leave = exports2.LeaveRequest.fromJSON(object.leave);
    } else {
      message.leave = void 0;
    }
    if (object.updateLayers !== void 0 && object.updateLayers !== null) {
      message.updateLayers = exports2.UpdateVideoLayers.fromJSON(object.updateLayers);
    } else {
      message.updateLayers = void 0;
    }
    if (object.subscriptionPermissions !== void 0 && object.subscriptionPermissions !== null) {
      message.subscriptionPermissions = exports2.UpdateSubscriptionPermissions.fromJSON(object.subscriptionPermissions);
    } else {
      message.subscriptionPermissions = void 0;
    }
    if (object.syncState !== void 0 && object.syncState !== null) {
      message.syncState = exports2.SyncState.fromJSON(object.syncState);
    } else {
      message.syncState = void 0;
    }
    if (object.simulate !== void 0 && object.simulate !== null) {
      message.simulate = exports2.SimulateScenario.fromJSON(object.simulate);
    } else {
      message.simulate = void 0;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.offer !== void 0 && (obj.offer = message.offer ? exports2.SessionDescription.toJSON(message.offer) : void 0);
    message.answer !== void 0 && (obj.answer = message.answer ? exports2.SessionDescription.toJSON(message.answer) : void 0);
    message.trickle !== void 0 && (obj.trickle = message.trickle ? exports2.TrickleRequest.toJSON(message.trickle) : void 0);
    message.addTrack !== void 0 && (obj.addTrack = message.addTrack ? exports2.AddTrackRequest.toJSON(message.addTrack) : void 0);
    message.mute !== void 0 && (obj.mute = message.mute ? exports2.MuteTrackRequest.toJSON(message.mute) : void 0);
    message.subscription !== void 0 && (obj.subscription = message.subscription ? exports2.UpdateSubscription.toJSON(message.subscription) : void 0);
    message.trackSetting !== void 0 && (obj.trackSetting = message.trackSetting ? exports2.UpdateTrackSettings.toJSON(message.trackSetting) : void 0);
    message.leave !== void 0 && (obj.leave = message.leave ? exports2.LeaveRequest.toJSON(message.leave) : void 0);
    message.updateLayers !== void 0 && (obj.updateLayers = message.updateLayers ? exports2.UpdateVideoLayers.toJSON(message.updateLayers) : void 0);
    message.subscriptionPermissions !== void 0 && (obj.subscriptionPermissions = message.subscriptionPermissions ? exports2.UpdateSubscriptionPermissions.toJSON(message.subscriptionPermissions) : void 0);
    message.syncState !== void 0 && (obj.syncState = message.syncState ? exports2.SyncState.toJSON(message.syncState) : void 0);
    message.simulate !== void 0 && (obj.simulate = message.simulate ? exports2.SimulateScenario.toJSON(message.simulate) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseSignalRequest);
    if (object.offer !== void 0 && object.offer !== null) {
      message.offer = exports2.SessionDescription.fromPartial(object.offer);
    } else {
      message.offer = void 0;
    }
    if (object.answer !== void 0 && object.answer !== null) {
      message.answer = exports2.SessionDescription.fromPartial(object.answer);
    } else {
      message.answer = void 0;
    }
    if (object.trickle !== void 0 && object.trickle !== null) {
      message.trickle = exports2.TrickleRequest.fromPartial(object.trickle);
    } else {
      message.trickle = void 0;
    }
    if (object.addTrack !== void 0 && object.addTrack !== null) {
      message.addTrack = exports2.AddTrackRequest.fromPartial(object.addTrack);
    } else {
      message.addTrack = void 0;
    }
    if (object.mute !== void 0 && object.mute !== null) {
      message.mute = exports2.MuteTrackRequest.fromPartial(object.mute);
    } else {
      message.mute = void 0;
    }
    if (object.subscription !== void 0 && object.subscription !== null) {
      message.subscription = exports2.UpdateSubscription.fromPartial(object.subscription);
    } else {
      message.subscription = void 0;
    }
    if (object.trackSetting !== void 0 && object.trackSetting !== null) {
      message.trackSetting = exports2.UpdateTrackSettings.fromPartial(object.trackSetting);
    } else {
      message.trackSetting = void 0;
    }
    if (object.leave !== void 0 && object.leave !== null) {
      message.leave = exports2.LeaveRequest.fromPartial(object.leave);
    } else {
      message.leave = void 0;
    }
    if (object.updateLayers !== void 0 && object.updateLayers !== null) {
      message.updateLayers = exports2.UpdateVideoLayers.fromPartial(object.updateLayers);
    } else {
      message.updateLayers = void 0;
    }
    if (object.subscriptionPermissions !== void 0 && object.subscriptionPermissions !== null) {
      message.subscriptionPermissions = exports2.UpdateSubscriptionPermissions.fromPartial(object.subscriptionPermissions);
    } else {
      message.subscriptionPermissions = void 0;
    }
    if (object.syncState !== void 0 && object.syncState !== null) {
      message.syncState = exports2.SyncState.fromPartial(object.syncState);
    } else {
      message.syncState = void 0;
    }
    if (object.simulate !== void 0 && object.simulate !== null) {
      message.simulate = exports2.SimulateScenario.fromPartial(object.simulate);
    } else {
      message.simulate = void 0;
    }
    return message;
  } };
  const baseSignalResponse = {};
  exports2.SignalResponse = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.join !== void 0) {
      exports2.JoinResponse.encode(message.join, writer2.uint32(10).fork()).ldelim();
    }
    if (message.answer !== void 0) {
      exports2.SessionDescription.encode(message.answer, writer2.uint32(18).fork()).ldelim();
    }
    if (message.offer !== void 0) {
      exports2.SessionDescription.encode(message.offer, writer2.uint32(26).fork()).ldelim();
    }
    if (message.trickle !== void 0) {
      exports2.TrickleRequest.encode(message.trickle, writer2.uint32(34).fork()).ldelim();
    }
    if (message.update !== void 0) {
      exports2.ParticipantUpdate.encode(message.update, writer2.uint32(42).fork()).ldelim();
    }
    if (message.trackPublished !== void 0) {
      exports2.TrackPublishedResponse.encode(message.trackPublished, writer2.uint32(50).fork()).ldelim();
    }
    if (message.leave !== void 0) {
      exports2.LeaveRequest.encode(message.leave, writer2.uint32(66).fork()).ldelim();
    }
    if (message.mute !== void 0) {
      exports2.MuteTrackRequest.encode(message.mute, writer2.uint32(74).fork()).ldelim();
    }
    if (message.speakersChanged !== void 0) {
      exports2.SpeakersChanged.encode(message.speakersChanged, writer2.uint32(82).fork()).ldelim();
    }
    if (message.roomUpdate !== void 0) {
      exports2.RoomUpdate.encode(message.roomUpdate, writer2.uint32(90).fork()).ldelim();
    }
    if (message.connectionQuality !== void 0) {
      exports2.ConnectionQualityUpdate.encode(message.connectionQuality, writer2.uint32(98).fork()).ldelim();
    }
    if (message.streamStateUpdate !== void 0) {
      exports2.StreamStateUpdate.encode(message.streamStateUpdate, writer2.uint32(106).fork()).ldelim();
    }
    if (message.subscribedQualityUpdate !== void 0) {
      exports2.SubscribedQualityUpdate.encode(message.subscribedQualityUpdate, writer2.uint32(114).fork()).ldelim();
    }
    if (message.subscriptionPermissionUpdate !== void 0) {
      exports2.SubscriptionPermissionUpdate.encode(message.subscriptionPermissionUpdate, writer2.uint32(122).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseSignalResponse);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.join = exports2.JoinResponse.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.answer = exports2.SessionDescription.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.offer = exports2.SessionDescription.decode(reader2, reader2.uint32());
          break;
        case 4:
          message.trickle = exports2.TrickleRequest.decode(reader2, reader2.uint32());
          break;
        case 5:
          message.update = exports2.ParticipantUpdate.decode(reader2, reader2.uint32());
          break;
        case 6:
          message.trackPublished = exports2.TrackPublishedResponse.decode(reader2, reader2.uint32());
          break;
        case 8:
          message.leave = exports2.LeaveRequest.decode(reader2, reader2.uint32());
          break;
        case 9:
          message.mute = exports2.MuteTrackRequest.decode(reader2, reader2.uint32());
          break;
        case 10:
          message.speakersChanged = exports2.SpeakersChanged.decode(reader2, reader2.uint32());
          break;
        case 11:
          message.roomUpdate = exports2.RoomUpdate.decode(reader2, reader2.uint32());
          break;
        case 12:
          message.connectionQuality = exports2.ConnectionQualityUpdate.decode(reader2, reader2.uint32());
          break;
        case 13:
          message.streamStateUpdate = exports2.StreamStateUpdate.decode(reader2, reader2.uint32());
          break;
        case 14:
          message.subscribedQualityUpdate = exports2.SubscribedQualityUpdate.decode(reader2, reader2.uint32());
          break;
        case 15:
          message.subscriptionPermissionUpdate = exports2.SubscriptionPermissionUpdate.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseSignalResponse);
    if (object.join !== void 0 && object.join !== null) {
      message.join = exports2.JoinResponse.fromJSON(object.join);
    } else {
      message.join = void 0;
    }
    if (object.answer !== void 0 && object.answer !== null) {
      message.answer = exports2.SessionDescription.fromJSON(object.answer);
    } else {
      message.answer = void 0;
    }
    if (object.offer !== void 0 && object.offer !== null) {
      message.offer = exports2.SessionDescription.fromJSON(object.offer);
    } else {
      message.offer = void 0;
    }
    if (object.trickle !== void 0 && object.trickle !== null) {
      message.trickle = exports2.TrickleRequest.fromJSON(object.trickle);
    } else {
      message.trickle = void 0;
    }
    if (object.update !== void 0 && object.update !== null) {
      message.update = exports2.ParticipantUpdate.fromJSON(object.update);
    } else {
      message.update = void 0;
    }
    if (object.trackPublished !== void 0 && object.trackPublished !== null) {
      message.trackPublished = exports2.TrackPublishedResponse.fromJSON(object.trackPublished);
    } else {
      message.trackPublished = void 0;
    }
    if (object.leave !== void 0 && object.leave !== null) {
      message.leave = exports2.LeaveRequest.fromJSON(object.leave);
    } else {
      message.leave = void 0;
    }
    if (object.mute !== void 0 && object.mute !== null) {
      message.mute = exports2.MuteTrackRequest.fromJSON(object.mute);
    } else {
      message.mute = void 0;
    }
    if (object.speakersChanged !== void 0 && object.speakersChanged !== null) {
      message.speakersChanged = exports2.SpeakersChanged.fromJSON(object.speakersChanged);
    } else {
      message.speakersChanged = void 0;
    }
    if (object.roomUpdate !== void 0 && object.roomUpdate !== null) {
      message.roomUpdate = exports2.RoomUpdate.fromJSON(object.roomUpdate);
    } else {
      message.roomUpdate = void 0;
    }
    if (object.connectionQuality !== void 0 && object.connectionQuality !== null) {
      message.connectionQuality = exports2.ConnectionQualityUpdate.fromJSON(object.connectionQuality);
    } else {
      message.connectionQuality = void 0;
    }
    if (object.streamStateUpdate !== void 0 && object.streamStateUpdate !== null) {
      message.streamStateUpdate = exports2.StreamStateUpdate.fromJSON(object.streamStateUpdate);
    } else {
      message.streamStateUpdate = void 0;
    }
    if (object.subscribedQualityUpdate !== void 0 && object.subscribedQualityUpdate !== null) {
      message.subscribedQualityUpdate = exports2.SubscribedQualityUpdate.fromJSON(object.subscribedQualityUpdate);
    } else {
      message.subscribedQualityUpdate = void 0;
    }
    if (object.subscriptionPermissionUpdate !== void 0 && object.subscriptionPermissionUpdate !== null) {
      message.subscriptionPermissionUpdate = exports2.SubscriptionPermissionUpdate.fromJSON(object.subscriptionPermissionUpdate);
    } else {
      message.subscriptionPermissionUpdate = void 0;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.join !== void 0 && (obj.join = message.join ? exports2.JoinResponse.toJSON(message.join) : void 0);
    message.answer !== void 0 && (obj.answer = message.answer ? exports2.SessionDescription.toJSON(message.answer) : void 0);
    message.offer !== void 0 && (obj.offer = message.offer ? exports2.SessionDescription.toJSON(message.offer) : void 0);
    message.trickle !== void 0 && (obj.trickle = message.trickle ? exports2.TrickleRequest.toJSON(message.trickle) : void 0);
    message.update !== void 0 && (obj.update = message.update ? exports2.ParticipantUpdate.toJSON(message.update) : void 0);
    message.trackPublished !== void 0 && (obj.trackPublished = message.trackPublished ? exports2.TrackPublishedResponse.toJSON(message.trackPublished) : void 0);
    message.leave !== void 0 && (obj.leave = message.leave ? exports2.LeaveRequest.toJSON(message.leave) : void 0);
    message.mute !== void 0 && (obj.mute = message.mute ? exports2.MuteTrackRequest.toJSON(message.mute) : void 0);
    message.speakersChanged !== void 0 && (obj.speakersChanged = message.speakersChanged ? exports2.SpeakersChanged.toJSON(message.speakersChanged) : void 0);
    message.roomUpdate !== void 0 && (obj.roomUpdate = message.roomUpdate ? exports2.RoomUpdate.toJSON(message.roomUpdate) : void 0);
    message.connectionQuality !== void 0 && (obj.connectionQuality = message.connectionQuality ? exports2.ConnectionQualityUpdate.toJSON(message.connectionQuality) : void 0);
    message.streamStateUpdate !== void 0 && (obj.streamStateUpdate = message.streamStateUpdate ? exports2.StreamStateUpdate.toJSON(message.streamStateUpdate) : void 0);
    message.subscribedQualityUpdate !== void 0 && (obj.subscribedQualityUpdate = message.subscribedQualityUpdate ? exports2.SubscribedQualityUpdate.toJSON(message.subscribedQualityUpdate) : void 0);
    message.subscriptionPermissionUpdate !== void 0 && (obj.subscriptionPermissionUpdate = message.subscriptionPermissionUpdate ? exports2.SubscriptionPermissionUpdate.toJSON(message.subscriptionPermissionUpdate) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseSignalResponse);
    if (object.join !== void 0 && object.join !== null) {
      message.join = exports2.JoinResponse.fromPartial(object.join);
    } else {
      message.join = void 0;
    }
    if (object.answer !== void 0 && object.answer !== null) {
      message.answer = exports2.SessionDescription.fromPartial(object.answer);
    } else {
      message.answer = void 0;
    }
    if (object.offer !== void 0 && object.offer !== null) {
      message.offer = exports2.SessionDescription.fromPartial(object.offer);
    } else {
      message.offer = void 0;
    }
    if (object.trickle !== void 0 && object.trickle !== null) {
      message.trickle = exports2.TrickleRequest.fromPartial(object.trickle);
    } else {
      message.trickle = void 0;
    }
    if (object.update !== void 0 && object.update !== null) {
      message.update = exports2.ParticipantUpdate.fromPartial(object.update);
    } else {
      message.update = void 0;
    }
    if (object.trackPublished !== void 0 && object.trackPublished !== null) {
      message.trackPublished = exports2.TrackPublishedResponse.fromPartial(object.trackPublished);
    } else {
      message.trackPublished = void 0;
    }
    if (object.leave !== void 0 && object.leave !== null) {
      message.leave = exports2.LeaveRequest.fromPartial(object.leave);
    } else {
      message.leave = void 0;
    }
    if (object.mute !== void 0 && object.mute !== null) {
      message.mute = exports2.MuteTrackRequest.fromPartial(object.mute);
    } else {
      message.mute = void 0;
    }
    if (object.speakersChanged !== void 0 && object.speakersChanged !== null) {
      message.speakersChanged = exports2.SpeakersChanged.fromPartial(object.speakersChanged);
    } else {
      message.speakersChanged = void 0;
    }
    if (object.roomUpdate !== void 0 && object.roomUpdate !== null) {
      message.roomUpdate = exports2.RoomUpdate.fromPartial(object.roomUpdate);
    } else {
      message.roomUpdate = void 0;
    }
    if (object.connectionQuality !== void 0 && object.connectionQuality !== null) {
      message.connectionQuality = exports2.ConnectionQualityUpdate.fromPartial(object.connectionQuality);
    } else {
      message.connectionQuality = void 0;
    }
    if (object.streamStateUpdate !== void 0 && object.streamStateUpdate !== null) {
      message.streamStateUpdate = exports2.StreamStateUpdate.fromPartial(object.streamStateUpdate);
    } else {
      message.streamStateUpdate = void 0;
    }
    if (object.subscribedQualityUpdate !== void 0 && object.subscribedQualityUpdate !== null) {
      message.subscribedQualityUpdate = exports2.SubscribedQualityUpdate.fromPartial(object.subscribedQualityUpdate);
    } else {
      message.subscribedQualityUpdate = void 0;
    }
    if (object.subscriptionPermissionUpdate !== void 0 && object.subscriptionPermissionUpdate !== null) {
      message.subscriptionPermissionUpdate = exports2.SubscriptionPermissionUpdate.fromPartial(object.subscriptionPermissionUpdate);
    } else {
      message.subscriptionPermissionUpdate = void 0;
    }
    return message;
  } };
  const baseAddTrackRequest = { cid: "", name: "", type: 0, width: 0, height: 0, muted: false, disableDtx: false, source: 0 };
  exports2.AddTrackRequest = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.cid !== "") {
      writer2.uint32(10).string(message.cid);
    }
    if (message.name !== "") {
      writer2.uint32(18).string(message.name);
    }
    if (message.type !== 0) {
      writer2.uint32(24).int32(message.type);
    }
    if (message.width !== 0) {
      writer2.uint32(32).uint32(message.width);
    }
    if (message.height !== 0) {
      writer2.uint32(40).uint32(message.height);
    }
    if (message.muted === true) {
      writer2.uint32(48).bool(message.muted);
    }
    if (message.disableDtx === true) {
      writer2.uint32(56).bool(message.disableDtx);
    }
    if (message.source !== 0) {
      writer2.uint32(64).int32(message.source);
    }
    for (const v2 of message.layers) {
      livekit_models_12.VideoLayer.encode(v2, writer2.uint32(74).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseAddTrackRequest);
    message.layers = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.cid = reader2.string();
          break;
        case 2:
          message.name = reader2.string();
          break;
        case 3:
          message.type = reader2.int32();
          break;
        case 4:
          message.width = reader2.uint32();
          break;
        case 5:
          message.height = reader2.uint32();
          break;
        case 6:
          message.muted = reader2.bool();
          break;
        case 7:
          message.disableDtx = reader2.bool();
          break;
        case 8:
          message.source = reader2.int32();
          break;
        case 9:
          message.layers.push(livekit_models_12.VideoLayer.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseAddTrackRequest);
    message.layers = [];
    if (object.cid !== void 0 && object.cid !== null) {
      message.cid = String(object.cid);
    } else {
      message.cid = "";
    }
    if (object.name !== void 0 && object.name !== null) {
      message.name = String(object.name);
    } else {
      message.name = "";
    }
    if (object.type !== void 0 && object.type !== null) {
      message.type = livekit_models_12.trackTypeFromJSON(object.type);
    } else {
      message.type = 0;
    }
    if (object.width !== void 0 && object.width !== null) {
      message.width = Number(object.width);
    } else {
      message.width = 0;
    }
    if (object.height !== void 0 && object.height !== null) {
      message.height = Number(object.height);
    } else {
      message.height = 0;
    }
    if (object.muted !== void 0 && object.muted !== null) {
      message.muted = Boolean(object.muted);
    } else {
      message.muted = false;
    }
    if (object.disableDtx !== void 0 && object.disableDtx !== null) {
      message.disableDtx = Boolean(object.disableDtx);
    } else {
      message.disableDtx = false;
    }
    if (object.source !== void 0 && object.source !== null) {
      message.source = livekit_models_12.trackSourceFromJSON(object.source);
    } else {
      message.source = 0;
    }
    if (object.layers !== void 0 && object.layers !== null) {
      for (const e2 of object.layers) {
        message.layers.push(livekit_models_12.VideoLayer.fromJSON(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.cid !== void 0 && (obj.cid = message.cid);
    message.name !== void 0 && (obj.name = message.name);
    message.type !== void 0 && (obj.type = livekit_models_12.trackTypeToJSON(message.type));
    message.width !== void 0 && (obj.width = message.width);
    message.height !== void 0 && (obj.height = message.height);
    message.muted !== void 0 && (obj.muted = message.muted);
    message.disableDtx !== void 0 && (obj.disableDtx = message.disableDtx);
    message.source !== void 0 && (obj.source = livekit_models_12.trackSourceToJSON(message.source));
    if (message.layers) {
      obj.layers = message.layers.map((e2) => e2 ? livekit_models_12.VideoLayer.toJSON(e2) : void 0);
    } else {
      obj.layers = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    const message = Object.assign({}, baseAddTrackRequest);
    message.cid = (_a2 = object.cid) !== null && _a2 !== void 0 ? _a2 : "";
    message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
    message.type = (_c = object.type) !== null && _c !== void 0 ? _c : 0;
    message.width = (_d = object.width) !== null && _d !== void 0 ? _d : 0;
    message.height = (_e = object.height) !== null && _e !== void 0 ? _e : 0;
    message.muted = (_f = object.muted) !== null && _f !== void 0 ? _f : false;
    message.disableDtx = (_g = object.disableDtx) !== null && _g !== void 0 ? _g : false;
    message.source = (_h = object.source) !== null && _h !== void 0 ? _h : 0;
    message.layers = [];
    if (object.layers !== void 0 && object.layers !== null) {
      for (const e2 of object.layers) {
        message.layers.push(livekit_models_12.VideoLayer.fromPartial(e2));
      }
    }
    return message;
  } };
  const baseTrickleRequest = { candidateInit: "", target: 0 };
  exports2.TrickleRequest = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.candidateInit !== "") {
      writer2.uint32(10).string(message.candidateInit);
    }
    if (message.target !== 0) {
      writer2.uint32(16).int32(message.target);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseTrickleRequest);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.candidateInit = reader2.string();
          break;
        case 2:
          message.target = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseTrickleRequest);
    if (object.candidateInit !== void 0 && object.candidateInit !== null) {
      message.candidateInit = String(object.candidateInit);
    } else {
      message.candidateInit = "";
    }
    if (object.target !== void 0 && object.target !== null) {
      message.target = signalTargetFromJSON(object.target);
    } else {
      message.target = 0;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.candidateInit !== void 0 && (obj.candidateInit = message.candidateInit);
    message.target !== void 0 && (obj.target = signalTargetToJSON(message.target));
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = Object.assign({}, baseTrickleRequest);
    message.candidateInit = (_a2 = object.candidateInit) !== null && _a2 !== void 0 ? _a2 : "";
    message.target = (_b = object.target) !== null && _b !== void 0 ? _b : 0;
    return message;
  } };
  const baseMuteTrackRequest = { sid: "", muted: false };
  exports2.MuteTrackRequest = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.sid !== "") {
      writer2.uint32(10).string(message.sid);
    }
    if (message.muted === true) {
      writer2.uint32(16).bool(message.muted);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseMuteTrackRequest);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sid = reader2.string();
          break;
        case 2:
          message.muted = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseMuteTrackRequest);
    if (object.sid !== void 0 && object.sid !== null) {
      message.sid = String(object.sid);
    } else {
      message.sid = "";
    }
    if (object.muted !== void 0 && object.muted !== null) {
      message.muted = Boolean(object.muted);
    } else {
      message.muted = false;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.sid !== void 0 && (obj.sid = message.sid);
    message.muted !== void 0 && (obj.muted = message.muted);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = Object.assign({}, baseMuteTrackRequest);
    message.sid = (_a2 = object.sid) !== null && _a2 !== void 0 ? _a2 : "";
    message.muted = (_b = object.muted) !== null && _b !== void 0 ? _b : false;
    return message;
  } };
  const baseJoinResponse = { serverVersion: "", subscriberPrimary: false, alternativeUrl: "" };
  exports2.JoinResponse = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.room !== void 0) {
      livekit_models_12.Room.encode(message.room, writer2.uint32(10).fork()).ldelim();
    }
    if (message.participant !== void 0) {
      livekit_models_12.ParticipantInfo.encode(message.participant, writer2.uint32(18).fork()).ldelim();
    }
    for (const v2 of message.otherParticipants) {
      livekit_models_12.ParticipantInfo.encode(v2, writer2.uint32(26).fork()).ldelim();
    }
    if (message.serverVersion !== "") {
      writer2.uint32(34).string(message.serverVersion);
    }
    for (const v2 of message.iceServers) {
      exports2.ICEServer.encode(v2, writer2.uint32(42).fork()).ldelim();
    }
    if (message.subscriberPrimary === true) {
      writer2.uint32(48).bool(message.subscriberPrimary);
    }
    if (message.alternativeUrl !== "") {
      writer2.uint32(58).string(message.alternativeUrl);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseJoinResponse);
    message.otherParticipants = [];
    message.iceServers = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.room = livekit_models_12.Room.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.participant = livekit_models_12.ParticipantInfo.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.otherParticipants.push(livekit_models_12.ParticipantInfo.decode(reader2, reader2.uint32()));
          break;
        case 4:
          message.serverVersion = reader2.string();
          break;
        case 5:
          message.iceServers.push(exports2.ICEServer.decode(reader2, reader2.uint32()));
          break;
        case 6:
          message.subscriberPrimary = reader2.bool();
          break;
        case 7:
          message.alternativeUrl = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseJoinResponse);
    message.otherParticipants = [];
    message.iceServers = [];
    if (object.room !== void 0 && object.room !== null) {
      message.room = livekit_models_12.Room.fromJSON(object.room);
    } else {
      message.room = void 0;
    }
    if (object.participant !== void 0 && object.participant !== null) {
      message.participant = livekit_models_12.ParticipantInfo.fromJSON(object.participant);
    } else {
      message.participant = void 0;
    }
    if (object.otherParticipants !== void 0 && object.otherParticipants !== null) {
      for (const e2 of object.otherParticipants) {
        message.otherParticipants.push(livekit_models_12.ParticipantInfo.fromJSON(e2));
      }
    }
    if (object.serverVersion !== void 0 && object.serverVersion !== null) {
      message.serverVersion = String(object.serverVersion);
    } else {
      message.serverVersion = "";
    }
    if (object.iceServers !== void 0 && object.iceServers !== null) {
      for (const e2 of object.iceServers) {
        message.iceServers.push(exports2.ICEServer.fromJSON(e2));
      }
    }
    if (object.subscriberPrimary !== void 0 && object.subscriberPrimary !== null) {
      message.subscriberPrimary = Boolean(object.subscriberPrimary);
    } else {
      message.subscriberPrimary = false;
    }
    if (object.alternativeUrl !== void 0 && object.alternativeUrl !== null) {
      message.alternativeUrl = String(object.alternativeUrl);
    } else {
      message.alternativeUrl = "";
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.room !== void 0 && (obj.room = message.room ? livekit_models_12.Room.toJSON(message.room) : void 0);
    message.participant !== void 0 && (obj.participant = message.participant ? livekit_models_12.ParticipantInfo.toJSON(message.participant) : void 0);
    if (message.otherParticipants) {
      obj.otherParticipants = message.otherParticipants.map((e2) => e2 ? livekit_models_12.ParticipantInfo.toJSON(e2) : void 0);
    } else {
      obj.otherParticipants = [];
    }
    message.serverVersion !== void 0 && (obj.serverVersion = message.serverVersion);
    if (message.iceServers) {
      obj.iceServers = message.iceServers.map((e2) => e2 ? exports2.ICEServer.toJSON(e2) : void 0);
    } else {
      obj.iceServers = [];
    }
    message.subscriberPrimary !== void 0 && (obj.subscriberPrimary = message.subscriberPrimary);
    message.alternativeUrl !== void 0 && (obj.alternativeUrl = message.alternativeUrl);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = Object.assign({}, baseJoinResponse);
    if (object.room !== void 0 && object.room !== null) {
      message.room = livekit_models_12.Room.fromPartial(object.room);
    } else {
      message.room = void 0;
    }
    if (object.participant !== void 0 && object.participant !== null) {
      message.participant = livekit_models_12.ParticipantInfo.fromPartial(object.participant);
    } else {
      message.participant = void 0;
    }
    message.otherParticipants = [];
    if (object.otherParticipants !== void 0 && object.otherParticipants !== null) {
      for (const e2 of object.otherParticipants) {
        message.otherParticipants.push(livekit_models_12.ParticipantInfo.fromPartial(e2));
      }
    }
    message.serverVersion = (_a2 = object.serverVersion) !== null && _a2 !== void 0 ? _a2 : "";
    message.iceServers = [];
    if (object.iceServers !== void 0 && object.iceServers !== null) {
      for (const e2 of object.iceServers) {
        message.iceServers.push(exports2.ICEServer.fromPartial(e2));
      }
    }
    message.subscriberPrimary = (_b = object.subscriberPrimary) !== null && _b !== void 0 ? _b : false;
    message.alternativeUrl = (_c = object.alternativeUrl) !== null && _c !== void 0 ? _c : "";
    return message;
  } };
  const baseTrackPublishedResponse = { cid: "" };
  exports2.TrackPublishedResponse = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.cid !== "") {
      writer2.uint32(10).string(message.cid);
    }
    if (message.track !== void 0) {
      livekit_models_12.TrackInfo.encode(message.track, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseTrackPublishedResponse);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.cid = reader2.string();
          break;
        case 2:
          message.track = livekit_models_12.TrackInfo.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseTrackPublishedResponse);
    if (object.cid !== void 0 && object.cid !== null) {
      message.cid = String(object.cid);
    } else {
      message.cid = "";
    }
    if (object.track !== void 0 && object.track !== null) {
      message.track = livekit_models_12.TrackInfo.fromJSON(object.track);
    } else {
      message.track = void 0;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.cid !== void 0 && (obj.cid = message.cid);
    message.track !== void 0 && (obj.track = message.track ? livekit_models_12.TrackInfo.toJSON(message.track) : void 0);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = Object.assign({}, baseTrackPublishedResponse);
    message.cid = (_a2 = object.cid) !== null && _a2 !== void 0 ? _a2 : "";
    if (object.track !== void 0 && object.track !== null) {
      message.track = livekit_models_12.TrackInfo.fromPartial(object.track);
    } else {
      message.track = void 0;
    }
    return message;
  } };
  const baseSessionDescription = { type: "", sdp: "" };
  exports2.SessionDescription = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.type !== "") {
      writer2.uint32(10).string(message.type);
    }
    if (message.sdp !== "") {
      writer2.uint32(18).string(message.sdp);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseSessionDescription);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader2.string();
          break;
        case 2:
          message.sdp = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseSessionDescription);
    if (object.type !== void 0 && object.type !== null) {
      message.type = String(object.type);
    } else {
      message.type = "";
    }
    if (object.sdp !== void 0 && object.sdp !== null) {
      message.sdp = String(object.sdp);
    } else {
      message.sdp = "";
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = message.type);
    message.sdp !== void 0 && (obj.sdp = message.sdp);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = Object.assign({}, baseSessionDescription);
    message.type = (_a2 = object.type) !== null && _a2 !== void 0 ? _a2 : "";
    message.sdp = (_b = object.sdp) !== null && _b !== void 0 ? _b : "";
    return message;
  } };
  const baseParticipantUpdate = {};
  exports2.ParticipantUpdate = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    for (const v2 of message.participants) {
      livekit_models_12.ParticipantInfo.encode(v2, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseParticipantUpdate);
    message.participants = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participants.push(livekit_models_12.ParticipantInfo.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseParticipantUpdate);
    message.participants = [];
    if (object.participants !== void 0 && object.participants !== null) {
      for (const e2 of object.participants) {
        message.participants.push(livekit_models_12.ParticipantInfo.fromJSON(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    if (message.participants) {
      obj.participants = message.participants.map((e2) => e2 ? livekit_models_12.ParticipantInfo.toJSON(e2) : void 0);
    } else {
      obj.participants = [];
    }
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseParticipantUpdate);
    message.participants = [];
    if (object.participants !== void 0 && object.participants !== null) {
      for (const e2 of object.participants) {
        message.participants.push(livekit_models_12.ParticipantInfo.fromPartial(e2));
      }
    }
    return message;
  } };
  const baseUpdateSubscription = { trackSids: "", subscribe: false };
  exports2.UpdateSubscription = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    for (const v2 of message.trackSids) {
      writer2.uint32(10).string(v2);
    }
    if (message.subscribe === true) {
      writer2.uint32(16).bool(message.subscribe);
    }
    for (const v2 of message.participantTracks) {
      livekit_models_12.ParticipantTracks.encode(v2, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseUpdateSubscription);
    message.trackSids = [];
    message.participantTracks = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trackSids.push(reader2.string());
          break;
        case 2:
          message.subscribe = reader2.bool();
          break;
        case 3:
          message.participantTracks.push(livekit_models_12.ParticipantTracks.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseUpdateSubscription);
    message.trackSids = [];
    message.participantTracks = [];
    if (object.trackSids !== void 0 && object.trackSids !== null) {
      for (const e2 of object.trackSids) {
        message.trackSids.push(String(e2));
      }
    }
    if (object.subscribe !== void 0 && object.subscribe !== null) {
      message.subscribe = Boolean(object.subscribe);
    } else {
      message.subscribe = false;
    }
    if (object.participantTracks !== void 0 && object.participantTracks !== null) {
      for (const e2 of object.participantTracks) {
        message.participantTracks.push(livekit_models_12.ParticipantTracks.fromJSON(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    if (message.trackSids) {
      obj.trackSids = message.trackSids.map((e2) => e2);
    } else {
      obj.trackSids = [];
    }
    message.subscribe !== void 0 && (obj.subscribe = message.subscribe);
    if (message.participantTracks) {
      obj.participantTracks = message.participantTracks.map((e2) => e2 ? livekit_models_12.ParticipantTracks.toJSON(e2) : void 0);
    } else {
      obj.participantTracks = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = Object.assign({}, baseUpdateSubscription);
    message.trackSids = [];
    if (object.trackSids !== void 0 && object.trackSids !== null) {
      for (const e2 of object.trackSids) {
        message.trackSids.push(e2);
      }
    }
    message.subscribe = (_a2 = object.subscribe) !== null && _a2 !== void 0 ? _a2 : false;
    message.participantTracks = [];
    if (object.participantTracks !== void 0 && object.participantTracks !== null) {
      for (const e2 of object.participantTracks) {
        message.participantTracks.push(livekit_models_12.ParticipantTracks.fromPartial(e2));
      }
    }
    return message;
  } };
  const baseUpdateTrackSettings = { trackSids: "", disabled: false, quality: 0, width: 0, height: 0 };
  exports2.UpdateTrackSettings = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    for (const v2 of message.trackSids) {
      writer2.uint32(10).string(v2);
    }
    if (message.disabled === true) {
      writer2.uint32(24).bool(message.disabled);
    }
    if (message.quality !== 0) {
      writer2.uint32(32).int32(message.quality);
    }
    if (message.width !== 0) {
      writer2.uint32(40).uint32(message.width);
    }
    if (message.height !== 0) {
      writer2.uint32(48).uint32(message.height);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseUpdateTrackSettings);
    message.trackSids = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trackSids.push(reader2.string());
          break;
        case 3:
          message.disabled = reader2.bool();
          break;
        case 4:
          message.quality = reader2.int32();
          break;
        case 5:
          message.width = reader2.uint32();
          break;
        case 6:
          message.height = reader2.uint32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseUpdateTrackSettings);
    message.trackSids = [];
    if (object.trackSids !== void 0 && object.trackSids !== null) {
      for (const e2 of object.trackSids) {
        message.trackSids.push(String(e2));
      }
    }
    if (object.disabled !== void 0 && object.disabled !== null) {
      message.disabled = Boolean(object.disabled);
    } else {
      message.disabled = false;
    }
    if (object.quality !== void 0 && object.quality !== null) {
      message.quality = livekit_models_12.videoQualityFromJSON(object.quality);
    } else {
      message.quality = 0;
    }
    if (object.width !== void 0 && object.width !== null) {
      message.width = Number(object.width);
    } else {
      message.width = 0;
    }
    if (object.height !== void 0 && object.height !== null) {
      message.height = Number(object.height);
    } else {
      message.height = 0;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    if (message.trackSids) {
      obj.trackSids = message.trackSids.map((e2) => e2);
    } else {
      obj.trackSids = [];
    }
    message.disabled !== void 0 && (obj.disabled = message.disabled);
    message.quality !== void 0 && (obj.quality = livekit_models_12.videoQualityToJSON(message.quality));
    message.width !== void 0 && (obj.width = message.width);
    message.height !== void 0 && (obj.height = message.height);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = Object.assign({}, baseUpdateTrackSettings);
    message.trackSids = [];
    if (object.trackSids !== void 0 && object.trackSids !== null) {
      for (const e2 of object.trackSids) {
        message.trackSids.push(e2);
      }
    }
    message.disabled = (_a2 = object.disabled) !== null && _a2 !== void 0 ? _a2 : false;
    message.quality = (_b = object.quality) !== null && _b !== void 0 ? _b : 0;
    message.width = (_c = object.width) !== null && _c !== void 0 ? _c : 0;
    message.height = (_d = object.height) !== null && _d !== void 0 ? _d : 0;
    return message;
  } };
  const baseLeaveRequest = { canReconnect: false };
  exports2.LeaveRequest = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.canReconnect === true) {
      writer2.uint32(8).bool(message.canReconnect);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseLeaveRequest);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.canReconnect = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseLeaveRequest);
    if (object.canReconnect !== void 0 && object.canReconnect !== null) {
      message.canReconnect = Boolean(object.canReconnect);
    } else {
      message.canReconnect = false;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.canReconnect !== void 0 && (obj.canReconnect = message.canReconnect);
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = Object.assign({}, baseLeaveRequest);
    message.canReconnect = (_a2 = object.canReconnect) !== null && _a2 !== void 0 ? _a2 : false;
    return message;
  } };
  const baseUpdateVideoLayers = { trackSid: "" };
  exports2.UpdateVideoLayers = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.trackSid !== "") {
      writer2.uint32(10).string(message.trackSid);
    }
    for (const v2 of message.layers) {
      livekit_models_12.VideoLayer.encode(v2, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseUpdateVideoLayers);
    message.layers = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trackSid = reader2.string();
          break;
        case 2:
          message.layers.push(livekit_models_12.VideoLayer.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseUpdateVideoLayers);
    message.layers = [];
    if (object.trackSid !== void 0 && object.trackSid !== null) {
      message.trackSid = String(object.trackSid);
    } else {
      message.trackSid = "";
    }
    if (object.layers !== void 0 && object.layers !== null) {
      for (const e2 of object.layers) {
        message.layers.push(livekit_models_12.VideoLayer.fromJSON(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);
    if (message.layers) {
      obj.layers = message.layers.map((e2) => e2 ? livekit_models_12.VideoLayer.toJSON(e2) : void 0);
    } else {
      obj.layers = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = Object.assign({}, baseUpdateVideoLayers);
    message.trackSid = (_a2 = object.trackSid) !== null && _a2 !== void 0 ? _a2 : "";
    message.layers = [];
    if (object.layers !== void 0 && object.layers !== null) {
      for (const e2 of object.layers) {
        message.layers.push(livekit_models_12.VideoLayer.fromPartial(e2));
      }
    }
    return message;
  } };
  const baseICEServer = { urls: "", username: "", credential: "" };
  exports2.ICEServer = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    for (const v2 of message.urls) {
      writer2.uint32(10).string(v2);
    }
    if (message.username !== "") {
      writer2.uint32(18).string(message.username);
    }
    if (message.credential !== "") {
      writer2.uint32(26).string(message.credential);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseICEServer);
    message.urls = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.urls.push(reader2.string());
          break;
        case 2:
          message.username = reader2.string();
          break;
        case 3:
          message.credential = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseICEServer);
    message.urls = [];
    if (object.urls !== void 0 && object.urls !== null) {
      for (const e2 of object.urls) {
        message.urls.push(String(e2));
      }
    }
    if (object.username !== void 0 && object.username !== null) {
      message.username = String(object.username);
    } else {
      message.username = "";
    }
    if (object.credential !== void 0 && object.credential !== null) {
      message.credential = String(object.credential);
    } else {
      message.credential = "";
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    if (message.urls) {
      obj.urls = message.urls.map((e2) => e2);
    } else {
      obj.urls = [];
    }
    message.username !== void 0 && (obj.username = message.username);
    message.credential !== void 0 && (obj.credential = message.credential);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = Object.assign({}, baseICEServer);
    message.urls = [];
    if (object.urls !== void 0 && object.urls !== null) {
      for (const e2 of object.urls) {
        message.urls.push(e2);
      }
    }
    message.username = (_a2 = object.username) !== null && _a2 !== void 0 ? _a2 : "";
    message.credential = (_b = object.credential) !== null && _b !== void 0 ? _b : "";
    return message;
  } };
  const baseSpeakersChanged = {};
  exports2.SpeakersChanged = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    for (const v2 of message.speakers) {
      livekit_models_12.SpeakerInfo.encode(v2, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseSpeakersChanged);
    message.speakers = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.speakers.push(livekit_models_12.SpeakerInfo.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseSpeakersChanged);
    message.speakers = [];
    if (object.speakers !== void 0 && object.speakers !== null) {
      for (const e2 of object.speakers) {
        message.speakers.push(livekit_models_12.SpeakerInfo.fromJSON(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    if (message.speakers) {
      obj.speakers = message.speakers.map((e2) => e2 ? livekit_models_12.SpeakerInfo.toJSON(e2) : void 0);
    } else {
      obj.speakers = [];
    }
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseSpeakersChanged);
    message.speakers = [];
    if (object.speakers !== void 0 && object.speakers !== null) {
      for (const e2 of object.speakers) {
        message.speakers.push(livekit_models_12.SpeakerInfo.fromPartial(e2));
      }
    }
    return message;
  } };
  const baseRoomUpdate = {};
  exports2.RoomUpdate = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.room !== void 0) {
      livekit_models_12.Room.encode(message.room, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseRoomUpdate);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.room = livekit_models_12.Room.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseRoomUpdate);
    if (object.room !== void 0 && object.room !== null) {
      message.room = livekit_models_12.Room.fromJSON(object.room);
    } else {
      message.room = void 0;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.room !== void 0 && (obj.room = message.room ? livekit_models_12.Room.toJSON(message.room) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseRoomUpdate);
    if (object.room !== void 0 && object.room !== null) {
      message.room = livekit_models_12.Room.fromPartial(object.room);
    } else {
      message.room = void 0;
    }
    return message;
  } };
  const baseConnectionQualityInfo = { participantSid: "", quality: 0, score: 0 };
  exports2.ConnectionQualityInfo = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.participantSid !== "") {
      writer2.uint32(10).string(message.participantSid);
    }
    if (message.quality !== 0) {
      writer2.uint32(16).int32(message.quality);
    }
    if (message.score !== 0) {
      writer2.uint32(29).float(message.score);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseConnectionQualityInfo);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participantSid = reader2.string();
          break;
        case 2:
          message.quality = reader2.int32();
          break;
        case 3:
          message.score = reader2.float();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseConnectionQualityInfo);
    if (object.participantSid !== void 0 && object.participantSid !== null) {
      message.participantSid = String(object.participantSid);
    } else {
      message.participantSid = "";
    }
    if (object.quality !== void 0 && object.quality !== null) {
      message.quality = livekit_models_12.connectionQualityFromJSON(object.quality);
    } else {
      message.quality = 0;
    }
    if (object.score !== void 0 && object.score !== null) {
      message.score = Number(object.score);
    } else {
      message.score = 0;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
    message.quality !== void 0 && (obj.quality = livekit_models_12.connectionQualityToJSON(message.quality));
    message.score !== void 0 && (obj.score = message.score);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = Object.assign({}, baseConnectionQualityInfo);
    message.participantSid = (_a2 = object.participantSid) !== null && _a2 !== void 0 ? _a2 : "";
    message.quality = (_b = object.quality) !== null && _b !== void 0 ? _b : 0;
    message.score = (_c = object.score) !== null && _c !== void 0 ? _c : 0;
    return message;
  } };
  const baseConnectionQualityUpdate = {};
  exports2.ConnectionQualityUpdate = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    for (const v2 of message.updates) {
      exports2.ConnectionQualityInfo.encode(v2, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseConnectionQualityUpdate);
    message.updates = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.updates.push(exports2.ConnectionQualityInfo.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseConnectionQualityUpdate);
    message.updates = [];
    if (object.updates !== void 0 && object.updates !== null) {
      for (const e2 of object.updates) {
        message.updates.push(exports2.ConnectionQualityInfo.fromJSON(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    if (message.updates) {
      obj.updates = message.updates.map((e2) => e2 ? exports2.ConnectionQualityInfo.toJSON(e2) : void 0);
    } else {
      obj.updates = [];
    }
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseConnectionQualityUpdate);
    message.updates = [];
    if (object.updates !== void 0 && object.updates !== null) {
      for (const e2 of object.updates) {
        message.updates.push(exports2.ConnectionQualityInfo.fromPartial(e2));
      }
    }
    return message;
  } };
  const baseStreamStateInfo = { participantSid: "", trackSid: "", state: 0 };
  exports2.StreamStateInfo = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.participantSid !== "") {
      writer2.uint32(10).string(message.participantSid);
    }
    if (message.trackSid !== "") {
      writer2.uint32(18).string(message.trackSid);
    }
    if (message.state !== 0) {
      writer2.uint32(24).int32(message.state);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseStreamStateInfo);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participantSid = reader2.string();
          break;
        case 2:
          message.trackSid = reader2.string();
          break;
        case 3:
          message.state = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseStreamStateInfo);
    if (object.participantSid !== void 0 && object.participantSid !== null) {
      message.participantSid = String(object.participantSid);
    } else {
      message.participantSid = "";
    }
    if (object.trackSid !== void 0 && object.trackSid !== null) {
      message.trackSid = String(object.trackSid);
    } else {
      message.trackSid = "";
    }
    if (object.state !== void 0 && object.state !== null) {
      message.state = streamStateFromJSON(object.state);
    } else {
      message.state = 0;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);
    message.state !== void 0 && (obj.state = streamStateToJSON(message.state));
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = Object.assign({}, baseStreamStateInfo);
    message.participantSid = (_a2 = object.participantSid) !== null && _a2 !== void 0 ? _a2 : "";
    message.trackSid = (_b = object.trackSid) !== null && _b !== void 0 ? _b : "";
    message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;
    return message;
  } };
  const baseStreamStateUpdate = {};
  exports2.StreamStateUpdate = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    for (const v2 of message.streamStates) {
      exports2.StreamStateInfo.encode(v2, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseStreamStateUpdate);
    message.streamStates = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.streamStates.push(exports2.StreamStateInfo.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseStreamStateUpdate);
    message.streamStates = [];
    if (object.streamStates !== void 0 && object.streamStates !== null) {
      for (const e2 of object.streamStates) {
        message.streamStates.push(exports2.StreamStateInfo.fromJSON(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    if (message.streamStates) {
      obj.streamStates = message.streamStates.map((e2) => e2 ? exports2.StreamStateInfo.toJSON(e2) : void 0);
    } else {
      obj.streamStates = [];
    }
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseStreamStateUpdate);
    message.streamStates = [];
    if (object.streamStates !== void 0 && object.streamStates !== null) {
      for (const e2 of object.streamStates) {
        message.streamStates.push(exports2.StreamStateInfo.fromPartial(e2));
      }
    }
    return message;
  } };
  const baseSubscribedQuality = { quality: 0, enabled: false };
  exports2.SubscribedQuality = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.quality !== 0) {
      writer2.uint32(8).int32(message.quality);
    }
    if (message.enabled === true) {
      writer2.uint32(16).bool(message.enabled);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseSubscribedQuality);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.quality = reader2.int32();
          break;
        case 2:
          message.enabled = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseSubscribedQuality);
    if (object.quality !== void 0 && object.quality !== null) {
      message.quality = livekit_models_12.videoQualityFromJSON(object.quality);
    } else {
      message.quality = 0;
    }
    if (object.enabled !== void 0 && object.enabled !== null) {
      message.enabled = Boolean(object.enabled);
    } else {
      message.enabled = false;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.quality !== void 0 && (obj.quality = livekit_models_12.videoQualityToJSON(message.quality));
    message.enabled !== void 0 && (obj.enabled = message.enabled);
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = Object.assign({}, baseSubscribedQuality);
    message.quality = (_a2 = object.quality) !== null && _a2 !== void 0 ? _a2 : 0;
    message.enabled = (_b = object.enabled) !== null && _b !== void 0 ? _b : false;
    return message;
  } };
  const baseSubscribedQualityUpdate = { trackSid: "" };
  exports2.SubscribedQualityUpdate = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.trackSid !== "") {
      writer2.uint32(10).string(message.trackSid);
    }
    for (const v2 of message.subscribedQualities) {
      exports2.SubscribedQuality.encode(v2, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseSubscribedQualityUpdate);
    message.subscribedQualities = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trackSid = reader2.string();
          break;
        case 2:
          message.subscribedQualities.push(exports2.SubscribedQuality.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseSubscribedQualityUpdate);
    message.subscribedQualities = [];
    if (object.trackSid !== void 0 && object.trackSid !== null) {
      message.trackSid = String(object.trackSid);
    } else {
      message.trackSid = "";
    }
    if (object.subscribedQualities !== void 0 && object.subscribedQualities !== null) {
      for (const e2 of object.subscribedQualities) {
        message.subscribedQualities.push(exports2.SubscribedQuality.fromJSON(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);
    if (message.subscribedQualities) {
      obj.subscribedQualities = message.subscribedQualities.map((e2) => e2 ? exports2.SubscribedQuality.toJSON(e2) : void 0);
    } else {
      obj.subscribedQualities = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = Object.assign({}, baseSubscribedQualityUpdate);
    message.trackSid = (_a2 = object.trackSid) !== null && _a2 !== void 0 ? _a2 : "";
    message.subscribedQualities = [];
    if (object.subscribedQualities !== void 0 && object.subscribedQualities !== null) {
      for (const e2 of object.subscribedQualities) {
        message.subscribedQualities.push(exports2.SubscribedQuality.fromPartial(e2));
      }
    }
    return message;
  } };
  const baseTrackPermission = { participantSid: "", allTracks: false, trackSids: "" };
  exports2.TrackPermission = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.participantSid !== "") {
      writer2.uint32(10).string(message.participantSid);
    }
    if (message.allTracks === true) {
      writer2.uint32(16).bool(message.allTracks);
    }
    for (const v2 of message.trackSids) {
      writer2.uint32(26).string(v2);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseTrackPermission);
    message.trackSids = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participantSid = reader2.string();
          break;
        case 2:
          message.allTracks = reader2.bool();
          break;
        case 3:
          message.trackSids.push(reader2.string());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseTrackPermission);
    message.trackSids = [];
    if (object.participantSid !== void 0 && object.participantSid !== null) {
      message.participantSid = String(object.participantSid);
    } else {
      message.participantSid = "";
    }
    if (object.allTracks !== void 0 && object.allTracks !== null) {
      message.allTracks = Boolean(object.allTracks);
    } else {
      message.allTracks = false;
    }
    if (object.trackSids !== void 0 && object.trackSids !== null) {
      for (const e2 of object.trackSids) {
        message.trackSids.push(String(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
    message.allTracks !== void 0 && (obj.allTracks = message.allTracks);
    if (message.trackSids) {
      obj.trackSids = message.trackSids.map((e2) => e2);
    } else {
      obj.trackSids = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2, _b;
    const message = Object.assign({}, baseTrackPermission);
    message.participantSid = (_a2 = object.participantSid) !== null && _a2 !== void 0 ? _a2 : "";
    message.allTracks = (_b = object.allTracks) !== null && _b !== void 0 ? _b : false;
    message.trackSids = [];
    if (object.trackSids !== void 0 && object.trackSids !== null) {
      for (const e2 of object.trackSids) {
        message.trackSids.push(e2);
      }
    }
    return message;
  } };
  const baseUpdateSubscriptionPermissions = { allParticipants: false };
  exports2.UpdateSubscriptionPermissions = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.allParticipants === true) {
      writer2.uint32(8).bool(message.allParticipants);
    }
    for (const v2 of message.trackPermissions) {
      exports2.TrackPermission.encode(v2, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseUpdateSubscriptionPermissions);
    message.trackPermissions = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.allParticipants = reader2.bool();
          break;
        case 2:
          message.trackPermissions.push(exports2.TrackPermission.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseUpdateSubscriptionPermissions);
    message.trackPermissions = [];
    if (object.allParticipants !== void 0 && object.allParticipants !== null) {
      message.allParticipants = Boolean(object.allParticipants);
    } else {
      message.allParticipants = false;
    }
    if (object.trackPermissions !== void 0 && object.trackPermissions !== null) {
      for (const e2 of object.trackPermissions) {
        message.trackPermissions.push(exports2.TrackPermission.fromJSON(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.allParticipants !== void 0 && (obj.allParticipants = message.allParticipants);
    if (message.trackPermissions) {
      obj.trackPermissions = message.trackPermissions.map((e2) => e2 ? exports2.TrackPermission.toJSON(e2) : void 0);
    } else {
      obj.trackPermissions = [];
    }
    return obj;
  }, fromPartial(object) {
    var _a2;
    const message = Object.assign({}, baseUpdateSubscriptionPermissions);
    message.allParticipants = (_a2 = object.allParticipants) !== null && _a2 !== void 0 ? _a2 : false;
    message.trackPermissions = [];
    if (object.trackPermissions !== void 0 && object.trackPermissions !== null) {
      for (const e2 of object.trackPermissions) {
        message.trackPermissions.push(exports2.TrackPermission.fromPartial(e2));
      }
    }
    return message;
  } };
  const baseSubscriptionPermissionUpdate = { participantSid: "", trackSid: "", allowed: false };
  exports2.SubscriptionPermissionUpdate = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.participantSid !== "") {
      writer2.uint32(10).string(message.participantSid);
    }
    if (message.trackSid !== "") {
      writer2.uint32(18).string(message.trackSid);
    }
    if (message.allowed === true) {
      writer2.uint32(24).bool(message.allowed);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseSubscriptionPermissionUpdate);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participantSid = reader2.string();
          break;
        case 2:
          message.trackSid = reader2.string();
          break;
        case 3:
          message.allowed = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseSubscriptionPermissionUpdate);
    if (object.participantSid !== void 0 && object.participantSid !== null) {
      message.participantSid = String(object.participantSid);
    } else {
      message.participantSid = "";
    }
    if (object.trackSid !== void 0 && object.trackSid !== null) {
      message.trackSid = String(object.trackSid);
    } else {
      message.trackSid = "";
    }
    if (object.allowed !== void 0 && object.allowed !== null) {
      message.allowed = Boolean(object.allowed);
    } else {
      message.allowed = false;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);
    message.allowed !== void 0 && (obj.allowed = message.allowed);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c;
    const message = Object.assign({}, baseSubscriptionPermissionUpdate);
    message.participantSid = (_a2 = object.participantSid) !== null && _a2 !== void 0 ? _a2 : "";
    message.trackSid = (_b = object.trackSid) !== null && _b !== void 0 ? _b : "";
    message.allowed = (_c = object.allowed) !== null && _c !== void 0 ? _c : false;
    return message;
  } };
  const baseSyncState = {};
  exports2.SyncState = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.answer !== void 0) {
      exports2.SessionDescription.encode(message.answer, writer2.uint32(10).fork()).ldelim();
    }
    if (message.subscription !== void 0) {
      exports2.UpdateSubscription.encode(message.subscription, writer2.uint32(18).fork()).ldelim();
    }
    for (const v2 of message.publishTracks) {
      exports2.TrackPublishedResponse.encode(v2, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseSyncState);
    message.publishTracks = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.answer = exports2.SessionDescription.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.subscription = exports2.UpdateSubscription.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.publishTracks.push(exports2.TrackPublishedResponse.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseSyncState);
    message.publishTracks = [];
    if (object.answer !== void 0 && object.answer !== null) {
      message.answer = exports2.SessionDescription.fromJSON(object.answer);
    } else {
      message.answer = void 0;
    }
    if (object.subscription !== void 0 && object.subscription !== null) {
      message.subscription = exports2.UpdateSubscription.fromJSON(object.subscription);
    } else {
      message.subscription = void 0;
    }
    if (object.publishTracks !== void 0 && object.publishTracks !== null) {
      for (const e2 of object.publishTracks) {
        message.publishTracks.push(exports2.TrackPublishedResponse.fromJSON(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.answer !== void 0 && (obj.answer = message.answer ? exports2.SessionDescription.toJSON(message.answer) : void 0);
    message.subscription !== void 0 && (obj.subscription = message.subscription ? exports2.UpdateSubscription.toJSON(message.subscription) : void 0);
    if (message.publishTracks) {
      obj.publishTracks = message.publishTracks.map((e2) => e2 ? exports2.TrackPublishedResponse.toJSON(e2) : void 0);
    } else {
      obj.publishTracks = [];
    }
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseSyncState);
    if (object.answer !== void 0 && object.answer !== null) {
      message.answer = exports2.SessionDescription.fromPartial(object.answer);
    } else {
      message.answer = void 0;
    }
    if (object.subscription !== void 0 && object.subscription !== null) {
      message.subscription = exports2.UpdateSubscription.fromPartial(object.subscription);
    } else {
      message.subscription = void 0;
    }
    message.publishTracks = [];
    if (object.publishTracks !== void 0 && object.publishTracks !== null) {
      for (const e2 of object.publishTracks) {
        message.publishTracks.push(exports2.TrackPublishedResponse.fromPartial(e2));
      }
    }
    return message;
  } };
  const baseSimulateScenario = {};
  exports2.SimulateScenario = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.speakerUpdate !== void 0) {
      writer2.uint32(8).int32(message.speakerUpdate);
    }
    if (message.nodeFailure !== void 0) {
      writer2.uint32(16).bool(message.nodeFailure);
    }
    if (message.migration !== void 0) {
      writer2.uint32(24).bool(message.migration);
    }
    if (message.serverLeave !== void 0) {
      writer2.uint32(32).bool(message.serverLeave);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseSimulateScenario);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.speakerUpdate = reader2.int32();
          break;
        case 2:
          message.nodeFailure = reader2.bool();
          break;
        case 3:
          message.migration = reader2.bool();
          break;
        case 4:
          message.serverLeave = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseSimulateScenario);
    if (object.speakerUpdate !== void 0 && object.speakerUpdate !== null) {
      message.speakerUpdate = Number(object.speakerUpdate);
    } else {
      message.speakerUpdate = void 0;
    }
    if (object.nodeFailure !== void 0 && object.nodeFailure !== null) {
      message.nodeFailure = Boolean(object.nodeFailure);
    } else {
      message.nodeFailure = void 0;
    }
    if (object.migration !== void 0 && object.migration !== null) {
      message.migration = Boolean(object.migration);
    } else {
      message.migration = void 0;
    }
    if (object.serverLeave !== void 0 && object.serverLeave !== null) {
      message.serverLeave = Boolean(object.serverLeave);
    } else {
      message.serverLeave = void 0;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.speakerUpdate !== void 0 && (obj.speakerUpdate = message.speakerUpdate);
    message.nodeFailure !== void 0 && (obj.nodeFailure = message.nodeFailure);
    message.migration !== void 0 && (obj.migration = message.migration);
    message.serverLeave !== void 0 && (obj.serverLeave = message.serverLeave);
    return obj;
  }, fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = Object.assign({}, baseSimulateScenario);
    message.speakerUpdate = (_a2 = object.speakerUpdate) !== null && _a2 !== void 0 ? _a2 : void 0;
    message.nodeFailure = (_b = object.nodeFailure) !== null && _b !== void 0 ? _b : void 0;
    message.migration = (_c = object.migration) !== null && _c !== void 0 ? _c : void 0;
    message.serverLeave = (_d = object.serverLeave) !== null && _d !== void 0 ? _d : void 0;
    return message;
  } };
  if (minimal_1.default.util.Long !== long_12.default) {
    minimal_1.default.util.Long = long_12.default;
    minimal_1.default.configure();
  }
})(livekit_rtc);
var errors = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.MediaDeviceFailure = exports2.PublishDataError = exports2.UnexpectedConnectionState = exports2.UnsupportedServer = exports2.TrackInvalidError = exports2.ConnectionError = exports2.LivekitError = void 0;
  class LivekitError extends Error {
    constructor(code, message) {
      super(message || "an error has occured");
      this.code = code;
    }
  }
  exports2.LivekitError = LivekitError;
  class ConnectionError extends LivekitError {
    constructor(message) {
      super(1, message);
    }
  }
  exports2.ConnectionError = ConnectionError;
  class TrackInvalidError extends LivekitError {
    constructor(message) {
      super(20, message || "Track is invalid");
    }
  }
  exports2.TrackInvalidError = TrackInvalidError;
  class UnsupportedServer extends LivekitError {
    constructor(message) {
      super(10, message || "Unsupported server");
    }
  }
  exports2.UnsupportedServer = UnsupportedServer;
  class UnexpectedConnectionState extends LivekitError {
    constructor(message) {
      super(12, message || "Unexpected connection state");
    }
  }
  exports2.UnexpectedConnectionState = UnexpectedConnectionState;
  class PublishDataError extends LivekitError {
    constructor(message) {
      super(13, message || "Unable to publish data");
    }
  }
  exports2.PublishDataError = PublishDataError;
  (function(MediaDeviceFailure) {
    MediaDeviceFailure["PermissionDenied"] = "PermissionDenied";
    MediaDeviceFailure["NotFound"] = "NotFound";
    MediaDeviceFailure["DeviceInUse"] = "DeviceInUse";
    MediaDeviceFailure["Other"] = "Other";
  })(exports2.MediaDeviceFailure || (exports2.MediaDeviceFailure = {}));
  (function(MediaDeviceFailure) {
    function getFailure(error) {
      if (error && "name" in error) {
        if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") {
          return MediaDeviceFailure.NotFound;
        }
        if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
          return MediaDeviceFailure.PermissionDenied;
        }
        if (error.name === "NotReadableError" || error.name === "TrackStartError") {
          return MediaDeviceFailure.DeviceInUse;
        }
        return MediaDeviceFailure.Other;
      }
    }
    MediaDeviceFailure.getFailure = getFailure;
  })(exports2.MediaDeviceFailure || (exports2.MediaDeviceFailure = {}));
})(errors);
var events$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TrackEvent = exports2.EngineEvent = exports2.ParticipantEvent = exports2.RoomEvent = void 0;
  (function(RoomEvent) {
    RoomEvent["Reconnecting"] = "reconnecting";
    RoomEvent["Reconnected"] = "reconnected";
    RoomEvent["Disconnected"] = "disconnected";
    RoomEvent["MediaDevicesChanged"] = "mediaDevicesChanged";
    RoomEvent["ParticipantConnected"] = "participantConnected";
    RoomEvent["ParticipantDisconnected"] = "participantDisconnected";
    RoomEvent["TrackPublished"] = "trackPublished";
    RoomEvent["TrackSubscribed"] = "trackSubscribed";
    RoomEvent["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
    RoomEvent["TrackUnpublished"] = "trackUnpublished";
    RoomEvent["TrackUnsubscribed"] = "trackUnsubscribed";
    RoomEvent["TrackMuted"] = "trackMuted";
    RoomEvent["TrackUnmuted"] = "trackUnmuted";
    RoomEvent["LocalTrackPublished"] = "localTrackPublished";
    RoomEvent["LocalTrackUnpublished"] = "localTrackUnpublished";
    RoomEvent["ActiveSpeakersChanged"] = "activeSpeakersChanged";
    RoomEvent["MetadataChanged"] = "metadataChanged";
    RoomEvent["ParticipantMetadataChanged"] = "participantMetaDataChanged";
    RoomEvent["RoomMetadataChanged"] = "roomMetadataChanged";
    RoomEvent["DataReceived"] = "dataReceived";
    RoomEvent["ConnectionQualityChanged"] = "connectionQualityChanged";
    RoomEvent["TrackStreamStateChanged"] = "trackStreamStateChanged";
    RoomEvent["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";
    RoomEvent["AudioPlaybackStatusChanged"] = "audioPlaybackChanged";
    RoomEvent["MediaDevicesError"] = "mediaDevicesError";
  })(exports2.RoomEvent || (exports2.RoomEvent = {}));
  (function(ParticipantEvent) {
    ParticipantEvent["TrackPublished"] = "trackPublished";
    ParticipantEvent["TrackSubscribed"] = "trackSubscribed";
    ParticipantEvent["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
    ParticipantEvent["TrackUnpublished"] = "trackUnpublished";
    ParticipantEvent["TrackUnsubscribed"] = "trackUnsubscribed";
    ParticipantEvent["TrackMuted"] = "trackMuted";
    ParticipantEvent["TrackUnmuted"] = "trackUnmuted";
    ParticipantEvent["LocalTrackPublished"] = "localTrackPublished";
    ParticipantEvent["LocalTrackUnpublished"] = "localTrackUnpublished";
    ParticipantEvent["MetadataChanged"] = "metadataChanged";
    ParticipantEvent["ParticipantMetadataChanged"] = "participantMetadataChanged";
    ParticipantEvent["DataReceived"] = "dataReceived";
    ParticipantEvent["IsSpeakingChanged"] = "isSpeakingChanged";
    ParticipantEvent["ConnectionQualityChanged"] = "connectionQualityChanged";
    ParticipantEvent["TrackStreamStateChanged"] = "trackStreamStateChanged";
    ParticipantEvent["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";
    ParticipantEvent["MediaDevicesError"] = "mediaDevicesError";
  })(exports2.ParticipantEvent || (exports2.ParticipantEvent = {}));
  (function(EngineEvent) {
    EngineEvent["Connected"] = "connected";
    EngineEvent["Disconnected"] = "disconnected";
    EngineEvent["Reconnecting"] = "reconnecting";
    EngineEvent["Reconnected"] = "reconnected";
    EngineEvent["SignalConnected"] = "singalConnected";
    EngineEvent["MediaTrackAdded"] = "mediaTrackAdded";
    EngineEvent["ActiveSpeakersUpdate"] = "activeSpeakersUpdate";
    EngineEvent["DataPacketReceived"] = "dataPacketReceived";
  })(exports2.EngineEvent || (exports2.EngineEvent = {}));
  (function(TrackEvent) {
    TrackEvent["Message"] = "message";
    TrackEvent["Muted"] = "muted";
    TrackEvent["Unmuted"] = "unmuted";
    TrackEvent["Ended"] = "ended";
    TrackEvent["UpdateSettings"] = "updateSettings";
    TrackEvent["UpdateSubscription"] = "updateSubscription";
    TrackEvent["AudioPlaybackStarted"] = "audioPlaybackStarted";
    TrackEvent["AudioPlaybackFailed"] = "audioPlaybackFailed";
    TrackEvent["VisibilityChanged"] = "visibilityChanged";
    TrackEvent["VideoDimensionsChanged"] = "videoDimensionsChanged";
  })(exports2.TrackEvent || (exports2.TrackEvent = {}));
})(events$1);
var LocalAudioTrack$1 = {};
var stats = {};
Object.defineProperty(stats, "__esModule", { value: true });
stats.computeBitrate = stats.monitorFrequency = void 0;
stats.monitorFrequency = 2e3;
function computeBitrate(currentStats, prevStats) {
  if (!prevStats) {
    return 0;
  }
  let bytesNow;
  let bytesPrev;
  if ("bytesReceived" in currentStats) {
    bytesNow = currentStats.bytesReceived;
    bytesPrev = prevStats.bytesReceived;
  } else if ("bytesSent" in currentStats) {
    bytesNow = currentStats.bytesSent;
    bytesPrev = prevStats.bytesSent;
  }
  if (bytesNow === void 0 || bytesPrev === void 0 || currentStats.timestamp === void 0 || prevStats.timestamp === void 0) {
    return 0;
  }
  return (bytesNow - bytesPrev) * 8 * 1e3 / (currentStats.timestamp - prevStats.timestamp);
}
stats.computeBitrate = computeBitrate;
var LocalTrack$1 = {};
var DeviceManager$1 = {};
var __awaiter$c = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(DeviceManager$1, "__esModule", { value: true });
const defaultId = "default";
class DeviceManager {
  static getInstance() {
    if (this.instance === void 0) {
      this.instance = new DeviceManager();
    }
    return this.instance;
  }
  getDevices(kind) {
    return __awaiter$c(this, void 0, void 0, function* () {
      let devices = yield navigator.mediaDevices.enumerateDevices();
      devices = devices.filter((device) => device.kind === kind);
      if (devices.length > 1 && devices[0].deviceId === defaultId) {
        const defaultDevice = devices[0];
        for (let i2 = 1; i2 < devices.length; i2 += 1) {
          if (devices[i2].groupId === defaultDevice.groupId) {
            const temp = devices[0];
            devices[0] = devices[i2];
            devices[i2] = temp;
            break;
          }
        }
        return devices.filter((device) => device !== defaultDevice);
      }
      return devices;
    });
  }
  normalizeDeviceId(kind, deviceId, groupId) {
    return __awaiter$c(this, void 0, void 0, function* () {
      if (deviceId !== defaultId) {
        return deviceId;
      }
      const devices = yield this.getDevices(kind);
      const device = devices.find((d) => d.groupId === groupId && d.deviceId !== defaultId);
      return device === null || device === void 0 ? void 0 : device.deviceId;
    });
  }
}
DeviceManager$1.default = DeviceManager;
DeviceManager.mediaDeviceKinds = ["audioinput", "audiooutput", "videoinput"];
var Track = {};
var events = { exports: {} };
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", { enumerable: true, get: function() {
  return defaultMaxListeners;
}, set: function(arg) {
  if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
  }
  defaultMaxListeners = arg;
} });
EventEmitter.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
  if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
  }
  this._maxListeners = n2;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit2(type) {
  var args = [];
  for (var i2 = 1; i2 < arguments.length; i2++)
    args.push(arguments[i2]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      ReflectApply(listeners2[i2], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m2;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w2.name = "MaxListenersExceededWarning";
      w2.emitter = target;
      w2.type = type;
      w2.count = existing.length;
      ProcessEmitWarning(w2);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state2 = { fired: false, wrapFn: void 0, target, type, listener };
  var wrapped = onceWrapper.bind(state2);
  wrapped.listener = listener;
  state2.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once2(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events2, position, i2, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i2 = list.length - 1; i2 >= 0; i2--) {
      if (list[i2] === listener || list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1)
      events2[type] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2, i2;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    var key;
    for (i2 = 0; i2 < keys2.length; ++i2) {
      key = keys2[i2];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (i2 = listeners2.length - 1; i2 >= 0; i2--) {
      this.removeListener(type, listeners2[i2]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n2) {
  var copy = new Array(n2);
  for (var i2 = 0; i2 < n2; ++i2)
    copy[i2] = arr[i2];
  return copy;
}
function spliceOne(list, index2) {
  for (; index2 + 1 < list.length; index2++)
    list[index2] = list[index2 + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr[i2].listener || arr[i2];
  }
  return ret;
}
function once(emitter, name2) {
  return new Promise(function(resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name2, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
    if (name2 !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name2, listener);
    } else {
      emitter.on(name2, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name2, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name2, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var utils$f = {};
var uaParser = { exports: {} };
(function(module2, exports2) {
  (function(window2, undefined$1) {
    var LIBVERSION = "1.0.2", EMPTY2 = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 255;
    var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook";
    var extend2 = function(regexes2, extensions) {
      var mergedRegexes = {};
      for (var i2 in regexes2) {
        if (extensions[i2] && extensions[i2].length % 2 === 0) {
          mergedRegexes[i2] = extensions[i2].concat(regexes2[i2]);
        } else {
          mergedRegexes[i2] = regexes2[i2];
        }
      }
      return mergedRegexes;
    }, enumerize = function(arr) {
      var enums = {};
      for (var i2 = 0; i2 < arr.length; i2++) {
        enums[arr[i2].toUpperCase()] = arr[i2];
      }
      return enums;
    }, has2 = function(str1, str2) {
      return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
    }, lowerize = function(str) {
      return str.toLowerCase();
    }, majorize = function(version2) {
      return typeof version2 === STR_TYPE ? version2.replace(/[^\d\.]/g, EMPTY2).split(".")[0] : undefined$1;
    }, trim2 = function(str, len) {
      if (typeof str === STR_TYPE) {
        str = str.replace(/^\s\s*/, EMPTY2).replace(/\s\s*$/, EMPTY2);
        return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
      }
    };
    var rgxMapper = function(ua2, arrays) {
      var i2 = 0, j, k, p2, q2, matches, match;
      while (i2 < arrays.length && !matches) {
        var regex = arrays[i2], props = arrays[i2 + 1];
        j = k = 0;
        while (j < regex.length && !matches) {
          matches = regex[j++].exec(ua2);
          if (!!matches) {
            for (p2 = 0; p2 < props.length; p2++) {
              match = matches[++k];
              q2 = props[p2];
              if (typeof q2 === OBJ_TYPE && q2.length > 0) {
                if (q2.length === 2) {
                  if (typeof q2[1] == FUNC_TYPE) {
                    this[q2[0]] = q2[1].call(this, match);
                  } else {
                    this[q2[0]] = q2[1];
                  }
                } else if (q2.length === 3) {
                  if (typeof q2[1] === FUNC_TYPE && !(q2[1].exec && q2[1].test)) {
                    this[q2[0]] = match ? q2[1].call(this, match, q2[2]) : undefined$1;
                  } else {
                    this[q2[0]] = match ? match.replace(q2[1], q2[2]) : undefined$1;
                  }
                } else if (q2.length === 4) {
                  this[q2[0]] = match ? q2[3].call(this, match.replace(q2[1], q2[2])) : undefined$1;
                }
              } else {
                this[q2] = match ? match : undefined$1;
              }
            }
          }
        }
        i2 += 2;
      }
    }, strMapper = function(str, map2) {
      for (var i2 in map2) {
        if (typeof map2[i2] === OBJ_TYPE && map2[i2].length > 0) {
          for (var j = 0; j < map2[i2].length; j++) {
            if (has2(map2[i2][j], str)) {
              return i2 === UNKNOWN ? undefined$1 : i2;
            }
          }
        } else if (has2(map2[i2], str)) {
          return i2 === UNKNOWN ? undefined$1 : i2;
        }
      }
      return str;
    };
    var oldSafariMap = { "1.0": "/8", "1.2": "/1", "1.3": "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }, windowsVersionMap = { "ME": "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", "2000": "NT 5.0", "XP": ["NT 5.1", "NT 5.2"], "Vista": "NT 6.0", "7": "NT 6.1", "8": "NT 6.2", "8.1": "NT 6.3", "10": ["NT 6.4", "NT 10.0"], "RT": "ARM" };
    var regexes = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [VERSION, [NAME, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [VERSION, [NAME, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [NAME, VERSION], [/opios[\/ ]+([\w\.]+)/i], [VERSION, [NAME, OPERA + " Mini"]], [/\bopr\/([\w\.]+)/i], [VERSION, [NAME, OPERA]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [NAME, VERSION], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [VERSION, [NAME, "UC" + BROWSER]], [/\bqbcore\/([\w\.]+)/i], [VERSION, [NAME, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [VERSION, [NAME, "WeChat"]], [/konqueror\/([\w\.]+)/i], [VERSION, [NAME, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [VERSION, [NAME, "IE"]], [/yabrowser\/([\w\.]+)/i], [VERSION, [NAME, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION], [/\bfocus\/([\w\.]+)/i], [VERSION, [NAME, FIREFOX + " Focus"]], [/\bopt\/([\w\.]+)/i], [VERSION, [NAME, OPERA + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [VERSION, [NAME, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [VERSION, [NAME, "Dolphin"]], [/coast\/([\w\.]+)/i], [VERSION, [NAME, OPERA + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [VERSION, [NAME, "MIUI " + BROWSER]], [/fxios\/([-\w\.]+)/i], [VERSION, [NAME, FIREFOX]], [/\bqihu|(qi?ho?o?|360)browser/i], [[NAME, "360 " + BROWSER]], [/(oculus|samsung|sailfish)browser\/([\w\.]+)/i], [[NAME, /(.+)/, "$1 " + BROWSER], VERSION], [/(comodo_dragon)\/([\w\.]+)/i], [[NAME, /_/g, " "], VERSION], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [NAME, VERSION], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i], [NAME], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[NAME, FACEBOOK], VERSION], [/safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [NAME, VERSION], [/\bgsa\/([\w\.]+) .*safari\//i], [VERSION, [NAME, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [VERSION, [NAME, CHROME + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[NAME, CHROME + " WebView"], VERSION], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [VERSION, [NAME, "Android " + BROWSER]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [NAME, VERSION], [/version\/([\w\.]+) .*mobile\/\w+ (safari)/i], [VERSION, [NAME, "Mobile Safari"]], [/version\/([\w\.]+) .*(mobile ?safari|safari)/i], [VERSION, NAME], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [NAME, [VERSION, strMapper, oldSafariMap]], [/(webkit|khtml)\/([\w\.]+)/i], [NAME, VERSION], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[NAME, "Netscape"], VERSION], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [VERSION, [NAME, FIREFOX + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i], [NAME, VERSION]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[ARCHITECTURE, "amd64"]], [/(ia32(?=;))/i], [[ARCHITECTURE, lowerize]], [/((?:i[346]|x)86)[;\)]/i], [[ARCHITECTURE, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[ARCHITECTURE, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[ARCHITECTURE, "armhf"]], [/windows (ce|mobile); ppc;/i], [[ARCHITECTURE, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[ARCHITECTURE, /ower/, EMPTY2, lowerize]], [/(sun4\w)[;\)]/i], [[ARCHITECTURE, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[ARCHITECTURE, lowerize]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[pt]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [/\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [/\((ip(?:hone|od)[\w ]*);/i], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}-[atu]?[ln][01259x][012359][an]?)\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[MODEL, /_/g, " "], [VENDOR, "Nokia"], [TYPE, MOBILE]], [/(pixel c)\b/i], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [/droid.+ ([c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]], [/(playbook);[-\w\),; ]+(rim)/i], [MODEL, VENDOR, [TYPE, TABLET]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [/(nexus 9)/i], [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic|sony)[-_ ]?([-\w]*)/i], [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [MODEL, [VENDOR, "Sharp"], [TYPE, MOBILE]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [VENDOR, MODEL, [TYPE, MOBILE]], [/(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [VENDOR, MODEL, [TYPE, TABLET]], [/(surface duo)/i], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]], [/(u304aa)/i], [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]], [/\bsie-(\w*)/i], [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]], [/\b(rct\w+) b/i], [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]], [/\b(venue[\d ]{2,7}) b/i], [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]], [/\b(q(?:mv|ta)\w+) b/i], [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]], [/\b(tm\d{3}\w+) b/i], [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]], [/\b(k88) b/i], [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]], [/\b(nx\d{3}j) b/i], [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]], [/\b(gen\d{3}) b.+49h/i], [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]], [/\b(zur\d{3}) b/i], [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]], [/\b((zeki)?tb.*\b) b/i], [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]], [/\b(ns-?\w{0,9}) b/i], [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]], [/\b((nxa|next)-?\w{0,9}) b/i], [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]], [/\b(lvtel\-)?(v1[12]) b/i], [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]], [/\b(ph-1) /i], [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]], [/\b(trio[-\w\. ]+) b/i], [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]], [/\btu_(1491) b/i], [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]], [/(shield[\w ]+) b/i], [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]], [/(sprint) (\w+)/i], [VENDOR, MODEL, [TYPE, MOBILE]], [/(kin\.[onetw]{3})/i], [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [VENDOR, MODEL, [TYPE, CONSOLE]], [/droid.+; (shield) bui/i], [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]], [/(playstation [345portablevi]+)/i], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [/smart-tv.+(samsung)/i], [VENDOR, [TYPE, SMARTTV]], [/hbbtv.+maple;(\d+)/i], [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[VENDOR, LG], [TYPE, SMARTTV]], [/(apple) ?tv/i], [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]], [/crkey/i], [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/droid.+aft(\w)( bui|\))/i], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [/\(dtv[\);].+(aquos)/i], [MODEL, [VENDOR, "Sharp"], [TYPE, SMARTTV]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i], [[VENDOR, trim2], [MODEL, trim2], [TYPE, SMARTTV]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[TYPE, SMARTTV]], [/((pebble))app/i], [VENDOR, MODEL, [TYPE, WEARABLE]], [/droid.+; (glass) \d/i], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [/droid.+; (wt63?0{2,3})\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [/(quest( 2)?)/i], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [VENDOR, [TYPE, EMBEDDED]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [MODEL, [TYPE, MOBILE]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [MODEL, [TYPE, TABLET]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[TYPE, TABLET]], [/(phone|mobile(?:[;\/]| safari)|pda(?=.+windows ce))/i], [[TYPE, MOBILE]], [/(android[-\w\. ]{0,9});.+buil/i], [MODEL, [VENDOR, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [VERSION, [NAME, EDGE + "HTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [VERSION, [NAME, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [NAME, VERSION], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [VERSION, NAME]], os: [[/microsoft (windows) (vista|xp)/i], [NAME, VERSION], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [NAME, [VERSION, strMapper, windowsVersionMap]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[NAME, "Windows"], [VERSION, strMapper, windowsVersionMap]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[VERSION, /_/g, "."], [NAME, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[NAME, "Mac OS"], [VERSION, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86)/i], [VERSION, NAME], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [NAME, VERSION], [/\(bb(10);/i], [VERSION, [NAME, BLACKBERRY]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [VERSION, [NAME, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [VERSION, [NAME, FIREFOX + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [VERSION, [NAME, "webOS"]], [/crkey\/([\d\.]+)/i], [VERSION, [NAME, CHROME + "cast"]], [/(cros) [\w]+ ([\w\.]+\w)/i], [[NAME, "Chromium OS"], VERSION], [/(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [NAME, VERSION], [/(sunos) ?([\w\.\d]*)/i], [[NAME, "Solaris"], VERSION], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [NAME, VERSION]] };
    var UAParser = function(ua2, extensions) {
      if (typeof ua2 === OBJ_TYPE) {
        extensions = ua2;
        ua2 = undefined$1;
      }
      if (!(this instanceof UAParser)) {
        return new UAParser(ua2, extensions).getResult();
      }
      var _ua = ua2 || (typeof window2 !== UNDEF_TYPE && window2.navigator && window2.navigator.userAgent ? window2.navigator.userAgent : EMPTY2);
      var _rgxmap = extensions ? extend2(regexes, extensions) : regexes;
      this.getBrowser = function() {
        var _browser = {};
        _browser[NAME] = undefined$1;
        _browser[VERSION] = undefined$1;
        rgxMapper.call(_browser, _ua, _rgxmap.browser);
        _browser.major = majorize(_browser.version);
        return _browser;
      };
      this.getCPU = function() {
        var _cpu = {};
        _cpu[ARCHITECTURE] = undefined$1;
        rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
        return _cpu;
      };
      this.getDevice = function() {
        var _device = {};
        _device[VENDOR] = undefined$1;
        _device[MODEL] = undefined$1;
        _device[TYPE] = undefined$1;
        rgxMapper.call(_device, _ua, _rgxmap.device);
        return _device;
      };
      this.getEngine = function() {
        var _engine = {};
        _engine[NAME] = undefined$1;
        _engine[VERSION] = undefined$1;
        rgxMapper.call(_engine, _ua, _rgxmap.engine);
        return _engine;
      };
      this.getOS = function() {
        var _os = {};
        _os[NAME] = undefined$1;
        _os[VERSION] = undefined$1;
        rgxMapper.call(_os, _ua, _rgxmap.os);
        return _os;
      };
      this.getResult = function() {
        return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
      };
      this.getUA = function() {
        return _ua;
      };
      this.setUA = function(ua22) {
        _ua = typeof ua22 === STR_TYPE && ua22.length > UA_MAX_LENGTH ? trim2(ua22, UA_MAX_LENGTH) : ua22;
        return this;
      };
      this.setUA(_ua);
      return this;
    };
    UAParser.VERSION = LIBVERSION;
    UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]);
    UAParser.CPU = enumerize([ARCHITECTURE]);
    UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
    UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);
    {
      if (module2.exports) {
        exports2 = module2.exports = UAParser;
      }
      exports2.UAParser = UAParser;
    }
    var $ = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);
    if ($ && !$.ua) {
      var parser = new UAParser();
      $.ua = parser.getResult();
      $.ua.get = function() {
        return parser.getUA();
      };
      $.ua.set = function(ua2) {
        parser.setUA(ua2);
        var result = parser.getResult();
        for (var prop in result) {
          $.ua[prop] = result[prop];
        }
      };
    }
  })(typeof window === "object" ? window : commonjsGlobal);
})(uaParser, uaParser.exports);
var version$1 = {};
Object.defineProperty(version$1, "__esModule", { value: true });
version$1.protocolVersion = version$1.version = void 0;
version$1.version = "0.15.4";
version$1.protocolVersion = 5;
var __awaiter$b = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$c = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(utils$f, "__esModule", { value: true });
utils$f.getClientInfo = utils$f.getIntersectionObserver = utils$f.getResizeObserver = utils$f.isFireFox = utils$f.sleep = utils$f.unpackStreamId = void 0;
const ua_parser_js_1 = __importDefault$c(uaParser.exports);
const livekit_models_1$3 = livekit_models$1;
const version_1 = version$1;
const separator = "|";
function unpackStreamId(packed) {
  const parts = packed.split(separator);
  if (parts.length > 1) {
    return [parts[0], packed.substr(parts[0].length + 1)];
  }
  return [packed, ""];
}
utils$f.unpackStreamId = unpackStreamId;
function sleep(duration) {
  return __awaiter$b(this, void 0, void 0, function* () {
    return new Promise((resolve) => setTimeout(resolve, duration));
  });
}
utils$f.sleep = sleep;
function isFireFox() {
  return navigator.userAgent.indexOf("Firefox") !== -1;
}
utils$f.isFireFox = isFireFox;
function roDispatchCallback(entries) {
  for (const entry of entries) {
    entry.target.handleResize(entry);
  }
}
function ioDispatchCallback(entries) {
  for (const entry of entries) {
    entry.target.handleVisibilityChanged(entry);
  }
}
let resizeObserver = null;
const getResizeObserver = () => {
  if (!resizeObserver)
    resizeObserver = new ResizeObserver(roDispatchCallback);
  return resizeObserver;
};
utils$f.getResizeObserver = getResizeObserver;
let intersectionObserver = null;
const getIntersectionObserver = () => {
  if (!intersectionObserver)
    intersectionObserver = new IntersectionObserver(ioDispatchCallback);
  return intersectionObserver;
};
utils$f.getIntersectionObserver = getIntersectionObserver;
function getClientInfo() {
  const ua2 = ua_parser_js_1.default(navigator.userAgent);
  const info = livekit_models_1$3.ClientInfo.fromPartial({ sdk: livekit_models_1$3.ClientInfo_SDK.JS, protocol: version_1.protocolVersion, version: version_1.version, os: ua2.os.name, osVersion: ua2.os.version, browser: ua2.browser.name, browserVersion: ua2.browser.version });
  let model = "";
  if (ua2.device.vendor) {
    model += ua2.device.vendor;
  }
  if (ua2.device.model) {
    if (model)
      model += " ";
    model += ua2.device.model;
  }
  if (model)
    info.deviceModel = model;
  return info;
}
utils$f.getClientInfo = getClientInfo;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.detachTrack = exports2.attachToElement = exports2.Track = void 0;
  const events_12 = events.exports;
  const livekit_models_12 = livekit_models$1;
  const livekit_rtc_12 = livekit_rtc;
  const events_2 = events$1;
  const utils_12 = utils$f;
  const recycledElements = [];
  class Track2 extends events_12.EventEmitter {
    constructor(mediaTrack, kind) {
      super();
      this.attachedElements = [];
      this.isMuted = false;
      this.streamState = Track2.StreamState.Active;
      this._currentBitrate = 0;
      this.kind = kind;
      this.mediaStreamTrack = mediaTrack;
      this.source = Track2.Source.Unknown;
    }
    get currentBitrate() {
      return this._currentBitrate;
    }
    attach(element) {
      let elementType = "audio";
      if (this.kind === Track2.Kind.Video) {
        elementType = "video";
      }
      if (!element) {
        if (elementType === "audio") {
          recycledElements.forEach((e2) => {
            if (e2.parentElement === null && !element) {
              element = e2;
            }
          });
          if (element) {
            recycledElements.splice(recycledElements.indexOf(element), 1);
          }
        }
        if (!element) {
          element = document.createElement(elementType);
        }
      }
      if (element instanceof HTMLVideoElement) {
        element.playsInline = true;
        element.autoplay = true;
      }
      if (this.attachedElements.includes(element)) {
        return element;
      }
      attachToElement(this.mediaStreamTrack, element);
      this.attachedElements.push(element);
      if (element instanceof HTMLAudioElement) {
        element.play().then(() => {
          this.emit(events_2.TrackEvent.AudioPlaybackStarted);
        }).catch((e2) => {
          this.emit(events_2.TrackEvent.AudioPlaybackFailed, e2);
        });
      }
      return element;
    }
    detach(element) {
      if (element) {
        detachTrack(this.mediaStreamTrack, element);
        const idx = this.attachedElements.indexOf(element);
        if (idx >= 0) {
          this.attachedElements.splice(idx, 1);
          this.recycleElement(element);
        }
        return element;
      }
      const detached = [];
      this.attachedElements.forEach((elm) => {
        detachTrack(this.mediaStreamTrack, elm);
        detached.push(elm);
        this.recycleElement(elm);
      });
      this.attachedElements = [];
      return detached;
    }
    stop() {
      this.mediaStreamTrack.stop();
    }
    enable() {
      this.mediaStreamTrack.enabled = true;
    }
    disable() {
      this.mediaStreamTrack.enabled = false;
    }
    recycleElement(element) {
      if (element instanceof HTMLAudioElement) {
        let shouldCache = true;
        element.pause();
        recycledElements.forEach((e2) => {
          if (!e2.parentElement) {
            shouldCache = false;
          }
        });
        if (shouldCache) {
          recycledElements.push(element);
        }
      }
    }
  }
  exports2.Track = Track2;
  function attachToElement(track, element) {
    let mediaStream;
    if (element.srcObject instanceof MediaStream) {
      mediaStream = element.srcObject;
    } else {
      mediaStream = new MediaStream();
      element.srcObject = mediaStream;
    }
    let existingTracks;
    if (track.kind === "audio") {
      existingTracks = mediaStream.getAudioTracks();
    } else {
      existingTracks = mediaStream.getVideoTracks();
    }
    existingTracks.forEach((et) => {
      mediaStream.removeTrack(et);
    });
    mediaStream.addTrack(track);
    if (utils_12.isFireFox()) {
      setTimeout(() => {
        element.srcObject = mediaStream;
      }, 1);
    }
  }
  exports2.attachToElement = attachToElement;
  function detachTrack(track, element) {
    if (element.srcObject instanceof MediaStream) {
      const mediaStream = element.srcObject;
      mediaStream.removeTrack(track);
      element.srcObject = null;
    }
  }
  exports2.detachTrack = detachTrack;
  (function(Track3) {
    let Kind;
    (function(Kind2) {
      Kind2["Audio"] = "audio";
      Kind2["Video"] = "video";
      Kind2["Unknown"] = "unknown";
    })(Kind = Track3.Kind || (Track3.Kind = {}));
    let Source;
    (function(Source2) {
      Source2["Camera"] = "camera";
      Source2["Microphone"] = "microphone";
      Source2["ScreenShare"] = "screen_share";
      Source2["ScreenShareAudio"] = "screen_share_audio";
      Source2["Unknown"] = "unknown";
    })(Source = Track3.Source || (Track3.Source = {}));
    let StreamState;
    (function(StreamState2) {
      StreamState2["Active"] = "active";
      StreamState2["Paused"] = "paused";
      StreamState2["Unknown"] = "unknown";
    })(StreamState = Track3.StreamState || (Track3.StreamState = {}));
    function kindToProto(k) {
      switch (k) {
        case Kind.Audio:
          return livekit_models_12.TrackType.AUDIO;
        case Kind.Video:
          return livekit_models_12.TrackType.VIDEO;
        default:
          return livekit_models_12.TrackType.UNRECOGNIZED;
      }
    }
    Track3.kindToProto = kindToProto;
    function kindFromProto(t2) {
      switch (t2) {
        case livekit_models_12.TrackType.AUDIO:
          return Kind.Audio;
        case livekit_models_12.TrackType.VIDEO:
          return Kind.Video;
        default:
          return Kind.Unknown;
      }
    }
    Track3.kindFromProto = kindFromProto;
    function sourceToProto(s) {
      switch (s) {
        case Source.Camera:
          return livekit_models_12.TrackSource.CAMERA;
        case Source.Microphone:
          return livekit_models_12.TrackSource.MICROPHONE;
        case Source.ScreenShare:
          return livekit_models_12.TrackSource.SCREEN_SHARE;
        case Source.ScreenShareAudio:
          return livekit_models_12.TrackSource.SCREEN_SHARE_AUDIO;
        default:
          return livekit_models_12.TrackSource.UNRECOGNIZED;
      }
    }
    Track3.sourceToProto = sourceToProto;
    function sourceFromProto(s) {
      switch (s) {
        case livekit_models_12.TrackSource.CAMERA:
          return Source.Camera;
        case livekit_models_12.TrackSource.MICROPHONE:
          return Source.Microphone;
        case livekit_models_12.TrackSource.SCREEN_SHARE:
          return Source.ScreenShare;
        case livekit_models_12.TrackSource.SCREEN_SHARE_AUDIO:
          return Source.ScreenShareAudio;
        default:
          return Source.Unknown;
      }
    }
    Track3.sourceFromProto = sourceFromProto;
    function streamStateFromProto(s) {
      switch (s) {
        case livekit_rtc_12.StreamState.ACTIVE:
          return StreamState.Active;
        case livekit_rtc_12.StreamState.PAUSED:
          return StreamState.Paused;
        default:
          return StreamState.Unknown;
      }
    }
    Track3.streamStateFromProto = streamStateFromProto;
  })(Track2 = exports2.Track || (exports2.Track = {}));
})(Track);
var __awaiter$a = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$b = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(LocalTrack$1, "__esModule", { value: true });
const logger_1$7 = __importDefault$b(logger);
const DeviceManager_1 = __importDefault$b(DeviceManager$1);
const errors_1$3 = errors;
const events_1$6 = events$1;
const Track_1$8 = Track;
class LocalTrack extends Track_1$8.Track {
  constructor(mediaTrack, kind, constraints) {
    super(mediaTrack, kind);
    this.handleEnded = () => {
      this.emit(events_1$6.TrackEvent.Ended, this);
    };
    this.mediaStreamTrack.addEventListener("ended", this.handleEnded);
    this.constraints = constraints !== null && constraints !== void 0 ? constraints : mediaTrack.getConstraints();
  }
  get id() {
    return this.mediaStreamTrack.id;
  }
  get dimensions() {
    if (this.kind !== Track_1$8.Track.Kind.Video) {
      return void 0;
    }
    const { width, height } = this.mediaStreamTrack.getSettings();
    if (width && height) {
      return { width, height };
    }
    return void 0;
  }
  getDeviceId() {
    return __awaiter$a(this, void 0, void 0, function* () {
      if (this.source === Track_1$8.Track.Source.ScreenShare) {
        return;
      }
      const { deviceId, groupId } = this.mediaStreamTrack.getSettings();
      const kind = this.kind === Track_1$8.Track.Kind.Audio ? "audioinput" : "videoinput";
      return DeviceManager_1.default.getInstance().normalizeDeviceId(kind, deviceId, groupId);
    });
  }
  mute() {
    return __awaiter$a(this, void 0, void 0, function* () {
      this.setTrackMuted(true);
      return this;
    });
  }
  unmute() {
    return __awaiter$a(this, void 0, void 0, function* () {
      this.setTrackMuted(false);
      return this;
    });
  }
  restart(constraints) {
    return __awaiter$a(this, void 0, void 0, function* () {
      if (!this.sender) {
        throw new errors_1$3.TrackInvalidError("unable to restart an unpublished track");
      }
      if (!constraints) {
        constraints = this.constraints;
      }
      logger_1$7.default.debug("restarting track with constraints", constraints);
      const streamConstraints = { audio: false, video: false };
      if (this.kind === Track_1$8.Track.Kind.Video) {
        streamConstraints.video = constraints;
      } else {
        streamConstraints.audio = constraints;
      }
      this.attachedElements.forEach((el) => {
        Track_1$8.detachTrack(this.mediaStreamTrack, el);
      });
      this.mediaStreamTrack.removeEventListener("ended", this.handleEnded);
      this.mediaStreamTrack.stop();
      const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);
      const newTrack = mediaStream.getTracks()[0];
      newTrack.addEventListener("ended", this.handleEnded);
      logger_1$7.default.debug("re-acquired MediaStreamTrack");
      yield this.sender.replaceTrack(newTrack);
      this.mediaStreamTrack = newTrack;
      this.attachedElements.forEach((el) => {
        Track_1$8.attachToElement(newTrack, el);
      });
      this.constraints = constraints;
      return this;
    });
  }
  setTrackMuted(muted) {
    if (this.isMuted === muted) {
      return;
    }
    this.isMuted = muted;
    this.mediaStreamTrack.enabled = !muted;
    this.emit(muted ? events_1$6.TrackEvent.Muted : events_1$6.TrackEvent.Unmuted, this);
  }
}
LocalTrack$1.default = LocalTrack;
var utils$e = {};
Object.defineProperty(utils$e, "__esModule", { value: true });
utils$e.constraintsForOptions = utils$e.mergeDefaultOptions = void 0;
function mergeDefaultOptions(options2, audioDefaults, videoDefaults) {
  const opts = Object.assign({}, options2);
  if (opts.audio === true)
    opts.audio = {};
  if (opts.video === true)
    opts.video = {};
  if (opts.audio) {
    mergeObjectWithoutOverwriting(opts.audio, audioDefaults);
  }
  if (opts.video) {
    mergeObjectWithoutOverwriting(opts.video, videoDefaults);
  }
  return opts;
}
utils$e.mergeDefaultOptions = mergeDefaultOptions;
function mergeObjectWithoutOverwriting(mainObject, objectToMerge) {
  Object.keys(objectToMerge).forEach((key) => {
    if (mainObject[key] === void 0)
      mainObject[key] = objectToMerge[key];
  });
  return mainObject;
}
function constraintsForOptions(options2) {
  const constraints = {};
  if (options2.video) {
    if (typeof options2.video === "object") {
      const videoOptions = {};
      const target = videoOptions;
      const source2 = options2.video;
      Object.keys(source2).forEach((key) => {
        switch (key) {
          case "resolution":
            mergeObjectWithoutOverwriting(target, source2.resolution);
            break;
          default:
            target[key] = source2[key];
        }
      });
      constraints.video = videoOptions;
    } else {
      constraints.video = options2.video;
    }
  } else {
    constraints.video = false;
  }
  if (options2.audio) {
    if (typeof options2.audio === "object") {
      constraints.audio = options2.audio;
    } else {
      constraints.audio = true;
    }
  } else {
    constraints.audio = false;
  }
  return constraints;
}
utils$e.constraintsForOptions = constraintsForOptions;
var __awaiter$9 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$a = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(LocalAudioTrack$1, "__esModule", { value: true });
const logger_1$6 = __importDefault$a(logger);
const stats_1$4 = stats;
const LocalTrack_1$1 = __importDefault$a(LocalTrack$1);
const Track_1$7 = Track;
const utils_1$5 = utils$e;
class LocalAudioTrack extends LocalTrack_1$1.default {
  constructor(mediaTrack, constraints) {
    super(mediaTrack, Track_1$7.Track.Kind.Audio, constraints);
    this.stopOnMute = false;
    this.monitorSender = () => __awaiter$9(this, void 0, void 0, function* () {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      const stats2 = yield this.getSenderStats();
      if (stats2 && this.prevStats) {
        this._currentBitrate = stats_1$4.computeBitrate(stats2, this.prevStats);
      }
      this.prevStats = stats2;
      setTimeout(() => {
        this.monitorSender();
      }, stats_1$4.monitorFrequency);
    });
  }
  setDeviceId(deviceId) {
    return __awaiter$9(this, void 0, void 0, function* () {
      if (this.constraints.deviceId === deviceId) {
        return;
      }
      this.constraints.deviceId = deviceId;
      if (!this.isMuted) {
        yield this.restartTrack();
      }
    });
  }
  mute() {
    const _super = Object.create(null, { mute: { get: () => super.mute } });
    return __awaiter$9(this, void 0, void 0, function* () {
      if (this.source === Track_1$7.Track.Source.Microphone && this.stopOnMute) {
        logger_1$6.default.debug("stopping mic track");
        this.mediaStreamTrack.stop();
      }
      yield _super.mute.call(this);
      return this;
    });
  }
  unmute() {
    const _super = Object.create(null, { unmute: { get: () => super.unmute } });
    return __awaiter$9(this, void 0, void 0, function* () {
      if (this.source === Track_1$7.Track.Source.Microphone && this.stopOnMute) {
        logger_1$6.default.debug("reacquiring mic track");
        yield this.restartTrack();
      }
      yield _super.unmute.call(this);
      return this;
    });
  }
  restartTrack(options2) {
    return __awaiter$9(this, void 0, void 0, function* () {
      let constraints;
      if (options2) {
        const streamConstraints = utils_1$5.constraintsForOptions({ audio: options2 });
        if (typeof streamConstraints.audio !== "boolean") {
          constraints = streamConstraints.audio;
        }
      }
      yield this.restart(constraints);
    });
  }
  startMonitor() {
    setTimeout(() => {
      this.monitorSender();
    }, stats_1$4.monitorFrequency);
  }
  getSenderStats() {
    return __awaiter$9(this, void 0, void 0, function* () {
      if (!this.sender) {
        return void 0;
      }
      const stats2 = yield this.sender.getStats();
      let audioStats;
      stats2.forEach((v2) => {
        if (v2.type === "outbound-rtp") {
          audioStats = { type: "audio", streamId: v2.id, packetsSent: v2.packetsSent, packetsLost: v2.packetsLost, bytesSent: v2.bytesSent, timestamp: v2.timestamp, roundTripTime: v2.roundTripTime, jitter: v2.jitter };
        }
      });
      return audioStats;
    });
  }
}
LocalAudioTrack$1.default = LocalAudioTrack;
var LocalTrackPublication$1 = {};
var TrackPublication = {};
var LocalVideoTrack$1 = {};
var __awaiter$8 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$9 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(LocalVideoTrack$1, "__esModule", { value: true });
LocalVideoTrack$1.videoLayersFromEncodings = LocalVideoTrack$1.videoQualityForRid = void 0;
const logger_1$5 = __importDefault$9(logger);
const livekit_models_1$2 = livekit_models$1;
const stats_1$3 = stats;
const utils_1$4 = utils$f;
const LocalTrack_1 = __importDefault$9(LocalTrack$1);
const Track_1$6 = Track;
const utils_2 = utils$e;
const QUALITY_UPGRADE_DELAY = 60 * 1e3;
const QUALITY_DOWNGRADE_DELAY = 5 * 1e3;
const ridOrder = ["q", "h", "f"];
class LocalVideoTrack extends LocalTrack_1.default {
  constructor(mediaTrack, constraints) {
    super(mediaTrack, Track_1$6.Track.Kind.Video, constraints);
    this.monitorSender = (disableLayerPause) => __awaiter$8(this, void 0, void 0, function* () {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      const stats2 = yield this.getSenderStats();
      const statsMap = new Map(stats2.map((s) => [s.rid, s]));
      if (!disableLayerPause && this.prevStats && this.isSimulcast) {
        this.checkAndUpdateSimulcast(statsMap);
      }
      if (this.prevStats) {
        let totalBitrate = 0;
        statsMap.forEach((s, key) => {
          var _a2;
          const prev = (_a2 = this.prevStats) === null || _a2 === void 0 ? void 0 : _a2.get(key);
          totalBitrate += stats_1$3.computeBitrate(s, prev);
        });
        this._currentBitrate = totalBitrate;
      }
      this.prevStats = statsMap;
      setTimeout(() => {
        this.monitorSender(disableLayerPause);
      }, stats_1$3.monitorFrequency);
    });
  }
  get isSimulcast() {
    if (this.sender && this.sender.getParameters().encodings.length > 1) {
      return true;
    }
    return false;
  }
  startMonitor(signalClient, disableLayerPause) {
    var _a2;
    this.signalClient = signalClient;
    const params = (_a2 = this.sender) === null || _a2 === void 0 ? void 0 : _a2.getParameters();
    if (params) {
      this.encodings = params.encodings;
    }
    setTimeout(() => {
      this.monitorSender(disableLayerPause);
    }, stats_1$3.monitorFrequency);
  }
  stop() {
    this.sender = void 0;
    this.mediaStreamTrack.getConstraints();
    super.stop();
  }
  mute() {
    const _super = Object.create(null, { mute: { get: () => super.mute } });
    return __awaiter$8(this, void 0, void 0, function* () {
      if (this.source === Track_1$6.Track.Source.Camera) {
        logger_1$5.default.debug("stopping camera track");
        this.mediaStreamTrack.stop();
      }
      yield _super.mute.call(this);
      return this;
    });
  }
  unmute() {
    const _super = Object.create(null, { unmute: { get: () => super.unmute } });
    return __awaiter$8(this, void 0, void 0, function* () {
      if (this.source === Track_1$6.Track.Source.Camera) {
        logger_1$5.default.debug("reacquiring camera track");
        yield this.restartTrack();
      }
      yield _super.unmute.call(this);
      return this;
    });
  }
  getSenderStats() {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (!this.sender) {
        return [];
      }
      const items = [];
      const stats2 = yield this.sender.getStats();
      stats2.forEach((v2) => {
        var _a2;
        if (v2.type === "outbound-rtp") {
          const vs = { type: "video", streamId: v2.id, frameHeight: v2.frameHeight, frameWidth: v2.frameWidth, firCount: v2.firCount, pliCount: v2.pliCount, nackCount: v2.nackCount, packetsSent: v2.packetsSent, bytesSent: v2.bytesSent, framesSent: v2.framesSent, timestamp: v2.timestamp, rid: (_a2 = v2.rid) !== null && _a2 !== void 0 ? _a2 : "", retransmittedPacketsSent: v2.retransmittedPacketsSent, qualityLimitationReason: v2.qualityLimitationReason, qualityLimitationResolutionChanges: v2.qualityLimitationResolutionChanges };
          const r2 = stats2.get(v2.remoteId);
          if (r2) {
            vs.jitter = r2.jitter;
            vs.packetsLost = r2.packetsLost;
            vs.roundTripTime = r2.roundTripTime;
          }
          items.push(vs);
        }
      });
      return items;
    });
  }
  setPublishingQuality(maxQuality) {
    const qualities = [];
    for (let q2 = livekit_models_1$2.VideoQuality.LOW; q2 <= livekit_models_1$2.VideoQuality.HIGH; q2 += 1) {
      qualities.push({ quality: q2, enabled: q2 <= maxQuality });
    }
    logger_1$5.default.debug("setting publishing quality. max quality", maxQuality);
    this.setPublishingLayers(qualities);
  }
  setDeviceId(deviceId) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (this.constraints.deviceId === deviceId) {
        return;
      }
      this.constraints.deviceId = deviceId;
      if (!this.isMuted) {
        yield this.restartTrack();
      }
    });
  }
  restartTrack(options2) {
    return __awaiter$8(this, void 0, void 0, function* () {
      let constraints;
      if (options2) {
        const streamConstraints = utils_2.constraintsForOptions({ video: options2 });
        if (typeof streamConstraints.video !== "boolean") {
          constraints = streamConstraints.video;
        }
      }
      yield this.restart(constraints);
    });
  }
  setPublishingLayers(qualities) {
    return __awaiter$8(this, void 0, void 0, function* () {
      logger_1$5.default.debug("setting publishing layers", qualities);
      if (!this.sender || !this.encodings) {
        return;
      }
      const params = this.sender.getParameters();
      const { encodings } = params;
      if (!encodings) {
        return;
      }
      if (encodings.length !== this.encodings.length) {
        logger_1$5.default.warn("cannot set publishing layers, encodings mismatch");
        return;
      }
      this.activeQualities = qualities;
      let hasChanged = false;
      encodings.forEach((encoding, idx) => {
        var _a2;
        let rid = (_a2 = encoding.rid) !== null && _a2 !== void 0 ? _a2 : "";
        if (rid === "") {
          rid = "q";
        }
        const quality = videoQualityForRid(rid);
        const subscribedQuality = qualities.find((q2) => q2.quality === quality);
        if (!subscribedQuality) {
          return;
        }
        if (encoding.active !== subscribedQuality.enabled) {
          hasChanged = true;
          encoding.active = subscribedQuality.enabled;
          logger_1$5.default.debug(`setting layer ${subscribedQuality.quality} to ${encoding.active ? "enabled" : "disabled"}`);
          if (utils_1$4.isFireFox()) {
            if (subscribedQuality.enabled) {
              encoding.scaleResolutionDownBy = this.encodings[idx].scaleResolutionDownBy;
              encoding.maxBitrate = this.encodings[idx].maxBitrate;
              encoding.maxFrameRate = this.encodings[idx].maxFrameRate;
            } else {
              encoding.scaleResolutionDownBy = 4;
              encoding.maxBitrate = 10;
              encoding.maxFrameRate = 2;
            }
          }
        }
      });
      if (hasChanged) {
        params.encodings = encodings;
        yield this.sender.setParameters(params);
      }
    });
  }
  checkAndUpdateSimulcast(statsMap) {
    var _a2, _b;
    if (!this.sender || this.isMuted || !this.encodings) {
      return;
    }
    let bestEncoding;
    const { encodings } = this.sender.getParameters();
    encodings.forEach((encoding) => {
      if (!encoding.active)
        return;
      if (bestEncoding === void 0) {
        bestEncoding = encoding;
      } else if (bestEncoding.rid && encoding.rid && ridOrder.indexOf(bestEncoding.rid) < ridOrder.indexOf(encoding.rid)) {
        bestEncoding = encoding;
      } else if (bestEncoding.maxBitrate !== void 0 && encoding.maxBitrate !== void 0 && bestEncoding.maxBitrate < encoding.maxBitrate) {
        bestEncoding = encoding;
      }
    });
    if (!bestEncoding) {
      return;
    }
    const rid = (_a2 = bestEncoding.rid) !== null && _a2 !== void 0 ? _a2 : "";
    const sendStats = statsMap.get(rid);
    const lastStats = (_b = this.prevStats) === null || _b === void 0 ? void 0 : _b.get(rid);
    if (!sendStats || !lastStats) {
      return;
    }
    const currentQuality = videoQualityForRid(rid);
    if (sendStats.qualityLimitationResolutionChanges - lastStats.qualityLimitationResolutionChanges > 0) {
      this.lastQualityChange = new Date().getTime();
    }
    if (sendStats.framesSent - lastStats.framesSent > 0) {
      if (currentQuality === livekit_models_1$2.VideoQuality.HIGH || !this.lastQualityChange)
        return;
      const nextQuality = currentQuality + 1;
      if (new Date().getTime() - this.lastQualityChange < QUALITY_UPGRADE_DELAY) {
        return;
      }
      if (this.activeQualities && this.activeQualities.some((q2) => q2.quality === nextQuality && !q2.enabled)) {
        return;
      }
      let bestQuality = livekit_models_1$2.VideoQuality.LOW;
      encodings.forEach((encoding) => {
        var _a3;
        const quality = videoQualityForRid((_a3 = encoding.rid) !== null && _a3 !== void 0 ? _a3 : "");
        if (quality > bestQuality) {
          bestQuality = quality;
        }
      });
      if (nextQuality > bestQuality) {
        return;
      }
      logger_1$5.default.debug("upgrading video quality to", nextQuality);
      this.setPublishingQuality(nextQuality);
      return;
    }
    if (sendStats.framesSent === 0)
      return;
    if (this.lastExplicitQualityChange && new Date().getTime() - this.lastExplicitQualityChange < QUALITY_DOWNGRADE_DELAY) {
      return;
    }
    if (currentQuality === livekit_models_1$2.VideoQuality.UNRECOGNIZED) {
      return;
    }
    if (currentQuality === livekit_models_1$2.VideoQuality.LOW) {
      return;
    }
    logger_1$5.default.debug("downgrading video quality to", currentQuality - 1);
    this.setPublishingQuality(currentQuality - 1);
  }
}
LocalVideoTrack$1.default = LocalVideoTrack;
function videoQualityForRid(rid) {
  switch (rid) {
    case "f":
      return livekit_models_1$2.VideoQuality.HIGH;
    case "h":
      return livekit_models_1$2.VideoQuality.MEDIUM;
    case "q":
      return livekit_models_1$2.VideoQuality.LOW;
    default:
      return livekit_models_1$2.VideoQuality.UNRECOGNIZED;
  }
}
LocalVideoTrack$1.videoQualityForRid = videoQualityForRid;
function videoLayersFromEncodings(width, height, encodings) {
  if (!encodings) {
    return [{ quality: livekit_models_1$2.VideoQuality.HIGH, width, height, bitrate: 0, ssrc: 0 }];
  }
  return encodings.map((encoding) => {
    var _a2, _b, _c;
    const scale = (_a2 = encoding.scaleResolutionDownBy) !== null && _a2 !== void 0 ? _a2 : 1;
    let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : "");
    if (quality === livekit_models_1$2.VideoQuality.UNRECOGNIZED && encodings.length === 1) {
      quality = livekit_models_1$2.VideoQuality.HIGH;
    }
    return { quality, width: width / scale, height: height / scale, bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0, ssrc: 0 };
  });
}
LocalVideoTrack$1.videoLayersFromEncodings = videoLayersFromEncodings;
var RemoteAudioTrack$1 = {};
var RemoteTrack$1 = {};
Object.defineProperty(RemoteTrack$1, "__esModule", { value: true });
const events_1$5 = events$1;
const stats_1$2 = stats;
const Track_1$5 = Track;
class RemoteTrack extends Track_1$5.Track {
  constructor(mediaTrack, sid, kind, receiver) {
    super(mediaTrack, kind);
    this.sid = sid;
    this.receiver = receiver;
  }
  setMuted(muted) {
    if (this.isMuted !== muted) {
      this.isMuted = muted;
      this.emit(muted ? events_1$5.TrackEvent.Muted : events_1$5.TrackEvent.Unmuted, this);
    }
  }
  setMediaStream(stream) {
    stream.onremovetrack = () => {
      this.receiver = void 0;
      this._currentBitrate = 0;
      this.emit(events_1$5.TrackEvent.Ended, this);
    };
  }
  start() {
    this.startMonitor();
    super.enable();
  }
  stop() {
    super.disable();
  }
  startMonitor() {
    setTimeout(() => {
      this.monitorReceiver();
    }, stats_1$2.monitorFrequency);
  }
}
RemoteTrack$1.default = RemoteTrack;
var __awaiter$7 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(RemoteAudioTrack$1, "__esModule", { value: true });
const stats_1$1 = stats;
const RemoteTrack_1$1 = __importDefault$8(RemoteTrack$1);
const Track_1$4 = Track;
class RemoteAudioTrack extends RemoteTrack_1$1.default {
  constructor(mediaTrack, sid, receiver) {
    super(mediaTrack, sid, Track_1$4.Track.Kind.Audio, receiver);
    this.monitorReceiver = () => __awaiter$7(this, void 0, void 0, function* () {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const stats2 = yield this.getReceiverStats();
      if (stats2 && this.prevStats && this.receiver) {
        this._currentBitrate = stats_1$1.computeBitrate(stats2, this.prevStats);
      }
      this.prevStats = stats2;
      setTimeout(() => {
        this.monitorReceiver();
      }, stats_1$1.monitorFrequency);
    });
  }
  getReceiverStats() {
    return __awaiter$7(this, void 0, void 0, function* () {
      if (!this.receiver) {
        return;
      }
      const stats2 = yield this.receiver.getStats();
      let receiverStats;
      stats2.forEach((v2) => {
        if (v2.type === "inbound-rtp") {
          receiverStats = { type: "audio", timestamp: v2.timestamp, jitter: v2.jitter, bytesReceived: v2.bytesReceived, concealedSamples: v2.concealedSamples, concealmentEvents: v2.concealmentEvents, silentConcealedSamples: v2.silentConcealedSamples, silentConcealmentEvents: v2.silentConcealmentEvents, totalAudioEnergy: v2.totalAudioEnergy, totalSamplesDuration: v2.totalSamplesDuration };
        }
      });
      return receiverStats;
    });
  }
}
RemoteAudioTrack$1.default = RemoteAudioTrack;
var RemoteVideoTrack$1 = {};
function r(r2, e2, n2) {
  var i2, t2, o2;
  void 0 === e2 && (e2 = 50), void 0 === n2 && (n2 = {});
  var a = null != (i2 = n2.isImmediate) && i2, u2 = null != (t2 = n2.callback) && t2, c = n2.maxWait, v2 = Date.now(), l2 = [];
  function f2() {
    if (void 0 !== c) {
      var r3 = Date.now() - v2;
      if (r3 + e2 >= c)
        return c - r3;
    }
    return e2;
  }
  var d = function() {
    var e3 = [].slice.call(arguments), n3 = this;
    return new Promise(function(i3, t3) {
      var c2 = a && void 0 === o2;
      if (void 0 !== o2 && clearTimeout(o2), o2 = setTimeout(function() {
        if (o2 = void 0, v2 = Date.now(), !a) {
          var i4 = r2.apply(n3, e3);
          u2 && u2(i4), l2.forEach(function(r3) {
            return (0, r3.resolve)(i4);
          }), l2 = [];
        }
      }, f2()), c2) {
        var d2 = r2.apply(n3, e3);
        return u2 && u2(d2), i3(d2);
      }
      l2.push({ resolve: i3, reject: t3 });
    });
  };
  return d.cancel = function(r3) {
    void 0 !== o2 && clearTimeout(o2), l2.forEach(function(e3) {
      return (0, e3.reject)(r3);
    }), l2 = [];
  }, d;
}
var index_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, debounce: r }, Symbol.toStringTag, { value: "Module" }));
var require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(index_esm);
var __awaiter$6 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(RemoteVideoTrack$1, "__esModule", { value: true });
const ts_debounce_1$1 = require$$0$1;
const events_1$4 = events$1;
const stats_1 = stats;
const utils_1$3 = utils$f;
const RemoteTrack_1 = __importDefault$7(RemoteTrack$1);
const Track_1$3 = Track;
const REACTION_DELAY = 100;
class RemoteVideoTrack extends RemoteTrack_1.default {
  constructor(mediaTrack, sid, receiver, adaptiveStream) {
    super(mediaTrack, sid, Track_1$3.Track.Kind.Video, receiver);
    this.elementInfos = [];
    this.monitorReceiver = () => __awaiter$6(this, void 0, void 0, function* () {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const stats2 = yield this.getReceiverStats();
      if (stats2 && this.prevStats && this.receiver) {
        this._currentBitrate = stats_1.computeBitrate(stats2, this.prevStats);
      }
      this.prevStats = stats2;
      setTimeout(() => {
        this.monitorReceiver();
      }, stats_1.monitorFrequency);
    });
    this.handleVisibilityChanged = (entry) => {
      const { target, isIntersecting } = entry;
      const elementInfo = this.elementInfos.find((info) => info.element === target);
      if (elementInfo) {
        elementInfo.visible = isIntersecting;
        elementInfo.visibilityChangedAt = Date.now();
      }
      this.updateVisibility();
    };
    this.debouncedHandleResize = ts_debounce_1$1.debounce(() => {
      this.updateDimensions();
    }, REACTION_DELAY);
    this.adaptiveStream = adaptiveStream;
  }
  get isAdaptiveStream() {
    var _a2;
    return (_a2 = this.adaptiveStream) !== null && _a2 !== void 0 ? _a2 : false;
  }
  setMuted(muted) {
    super.setMuted(muted);
    this.attachedElements.forEach((element) => {
      if (muted) {
        Track_1$3.detachTrack(this.mediaStreamTrack, element);
      } else {
        Track_1$3.attachToElement(this.mediaStreamTrack, element);
      }
    });
  }
  attach(element) {
    if (!element) {
      element = super.attach();
    } else {
      super.attach(element);
    }
    if (this.adaptiveStream) {
      this.elementInfos.push({ element, visible: true });
      element.handleResize = this.debouncedHandleResize;
      element.handleVisibilityChanged = this.handleVisibilityChanged;
      utils_1$3.getIntersectionObserver().observe(element);
      utils_1$3.getResizeObserver().observe(element);
    }
    return element;
  }
  detach(element) {
    let detachedElements = [];
    if (element) {
      this.stopObservingElement(element);
      return super.detach(element);
    }
    detachedElements = super.detach();
    for (const e2 of detachedElements) {
      this.stopObservingElement(e2);
    }
    return detachedElements;
  }
  getReceiverStats() {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (!this.receiver) {
        return;
      }
      const stats2 = yield this.receiver.getStats();
      let receiverStats;
      stats2.forEach((v2) => {
        if (v2.type === "inbound-rtp") {
          receiverStats = { type: "video", framesDecoded: v2.framesDecoded, framesDropped: v2.framesDropped, framesReceived: v2.framesReceived, packetsReceived: v2.packetsReceived, packetsLost: v2.packetsLost, frameWidth: v2.frameWidth, frameHeight: v2.frameHeight, pliCount: v2.pliCount, firCount: v2.firCount, nackCount: v2.nackCount, jitter: v2.jitter, timestamp: v2.timestamp, bytesReceived: v2.bytesReceived };
        }
      });
      return receiverStats;
    });
  }
  stopObservingElement(element) {
    var _a2, _b;
    (_a2 = utils_1$3.getIntersectionObserver()) === null || _a2 === void 0 ? void 0 : _a2.unobserve(element);
    (_b = utils_1$3.getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(element);
    this.elementInfos = this.elementInfos.filter((info) => info.element !== element);
  }
  updateVisibility() {
    const lastVisibilityChange = this.elementInfos.reduce((prev, info) => Math.max(prev, info.visibilityChangedAt || 0), 0);
    const isVisible = this.elementInfos.some((info) => info.visible);
    if (this.lastVisible === isVisible) {
      return;
    }
    if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {
      setTimeout(() => {
        this.updateVisibility();
      }, Date.now() - lastVisibilityChange);
      return;
    }
    this.lastVisible = isVisible;
    this.emit(events_1$4.TrackEvent.VisibilityChanged, isVisible, this);
  }
  updateDimensions() {
    var _a2, _b;
    let maxWidth = 0;
    let maxHeight = 0;
    for (const info of this.elementInfos) {
      if (info.visible) {
        if (info.element.clientWidth + info.element.clientHeight > maxWidth + maxHeight) {
          maxWidth = info.element.clientWidth;
          maxHeight = info.element.clientHeight;
        }
      }
    }
    if (((_a2 = this.lastDimensions) === null || _a2 === void 0 ? void 0 : _a2.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {
      return;
    }
    this.lastDimensions = { width: maxWidth, height: maxHeight };
    this.emit(events_1$4.TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);
  }
}
RemoteVideoTrack$1.default = RemoteVideoTrack;
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TrackPublication = void 0;
  const events_12 = events.exports;
  const events_2 = events$1;
  const LocalAudioTrack_12 = __importDefault2(LocalAudioTrack$1);
  const LocalVideoTrack_12 = __importDefault2(LocalVideoTrack$1);
  const RemoteAudioTrack_12 = __importDefault2(RemoteAudioTrack$1);
  const RemoteVideoTrack_12 = __importDefault2(RemoteVideoTrack$1);
  const Track_12 = Track;
  class TrackPublication2 extends events_12.EventEmitter {
    constructor(kind, id2, name2) {
      super();
      this.metadataMuted = false;
      this.handleMuted = () => {
        this.emit(events_2.TrackEvent.Muted);
      };
      this.handleUnmuted = () => {
        this.emit(events_2.TrackEvent.Unmuted);
      };
      this.kind = kind;
      this.trackSid = id2;
      this.trackName = name2;
      this.source = Track_12.Track.Source.Unknown;
    }
    setTrack(track) {
      if (this.track) {
        this.track.off(events_2.TrackEvent.Muted, this.handleMuted);
        this.track.off(events_2.TrackEvent.Unmuted, this.handleUnmuted);
      }
      this.track = track;
      if (track) {
        track.on(events_2.TrackEvent.Muted, this.handleMuted);
        track.on(events_2.TrackEvent.Unmuted, this.handleUnmuted);
      }
    }
    get isMuted() {
      return this.metadataMuted;
    }
    get isEnabled() {
      return true;
    }
    get isSubscribed() {
      return this.track !== void 0;
    }
    get audioTrack() {
      if (this.track instanceof LocalAudioTrack_12.default || this.track instanceof RemoteAudioTrack_12.default) {
        return this.track;
      }
    }
    get videoTrack() {
      if (this.track instanceof LocalVideoTrack_12.default || this.track instanceof RemoteVideoTrack_12.default) {
        return this.track;
      }
    }
    updateInfo(info) {
      this.trackSid = info.sid;
      this.trackName = info.name;
      this.source = Track_12.Track.sourceFromProto(info.source);
      this.mimeType = info.mimeType;
      if (this.kind === Track_12.Track.Kind.Video && info.width > 0) {
        this.dimensions = { width: info.width, height: info.height };
        this.simulcasted = info.simulcast;
      }
      this.trackInfo = info;
    }
  }
  exports2.TrackPublication = TrackPublication2;
  (function(TrackPublication3) {
    (function(SubscriptionStatus) {
      SubscriptionStatus["Subscribed"] = "subscribed";
      SubscriptionStatus["NotAllowed"] = "not_allowed";
      SubscriptionStatus["Unsubscribed"] = "unsubscribed";
    })(TrackPublication3.SubscriptionStatus || (TrackPublication3.SubscriptionStatus = {}));
  })(TrackPublication2 = exports2.TrackPublication || (exports2.TrackPublication = {}));
})(TrackPublication);
var __awaiter$5 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(LocalTrackPublication$1, "__esModule", { value: true });
const events_1$3 = events$1;
const TrackPublication_1$1 = TrackPublication;
class LocalTrackPublication extends TrackPublication_1$1.TrackPublication {
  constructor(kind, ti2, track) {
    super(kind, ti2.sid, ti2.name);
    this.handleTrackEnded = (track2) => {
      this.emit(events_1$3.TrackEvent.Ended, track2);
    };
    this.updateInfo(ti2);
    this.setTrack(track);
  }
  setTrack(track) {
    if (this.track) {
      this.track.off(events_1$3.TrackEvent.Ended, this.handleTrackEnded);
    }
    super.setTrack(track);
    if (track) {
      track.on(events_1$3.TrackEvent.Ended, this.handleTrackEnded);
    }
  }
  get isMuted() {
    if (this.track) {
      return this.track.isMuted;
    }
    return super.isMuted;
  }
  get audioTrack() {
    return super.audioTrack;
  }
  get videoTrack() {
    return super.videoTrack;
  }
  mute() {
    var _a2;
    return __awaiter$5(this, void 0, void 0, function* () {
      return (_a2 = this.track) === null || _a2 === void 0 ? void 0 : _a2.mute();
    });
  }
  unmute() {
    var _a2;
    return __awaiter$5(this, void 0, void 0, function* () {
      return (_a2 = this.track) === null || _a2 === void 0 ? void 0 : _a2.unmute();
    });
  }
}
LocalTrackPublication$1.default = LocalTrackPublication;
var options$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ScreenSharePresets = exports2.VideoPresets43 = exports2.VideoPresets = exports2.AudioPresets = exports2.VideoPreset = void 0;
  class VideoPreset {
    constructor(width, height, maxBitrate, maxFramerate) {
      this.width = width;
      this.height = height;
      this.encoding = { maxBitrate, maxFramerate };
    }
    get resolution() {
      return { width: this.width, height: this.height, frameRate: this.encoding.maxFramerate, aspectRatio: this.width / this.height };
    }
  }
  exports2.VideoPreset = VideoPreset;
  (function(AudioPresets) {
    AudioPresets.telephone = { maxBitrate: 12e3 };
    AudioPresets.speech = { maxBitrate: 2e4 };
    AudioPresets.music = { maxBitrate: 32e3 };
  })(exports2.AudioPresets || (exports2.AudioPresets = {}));
  exports2.VideoPresets = { qvga: new VideoPreset(320, 180, 12e4, 10), vga: new VideoPreset(640, 360, 3e5, 20), qhd: new VideoPreset(960, 540, 6e5, 25), hd: new VideoPreset(1280, 720, 2e6, 30), fhd: new VideoPreset(1920, 1080, 3e6, 30) };
  exports2.VideoPresets43 = { qvga: new VideoPreset(240, 180, 9e4, 10), vga: new VideoPreset(480, 360, 225e3, 20), qhd: new VideoPreset(720, 540, 45e4, 25), hd: new VideoPreset(960, 720, 15e5, 30), fhd: new VideoPreset(1440, 1080, 28e5, 30) };
  exports2.ScreenSharePresets = { vga: new VideoPreset(640, 360, 2e5, 3), hd_8: new VideoPreset(1280, 720, 4e5, 5), hd_15: new VideoPreset(1280, 720, 1e6, 15), fhd_15: new VideoPreset(1920, 1080, 15e5, 15), fhd_30: new VideoPreset(1920, 1080, 3e6, 30) };
})(options$1);
var Participant$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ConnectionQuality = void 0;
  const events_12 = events.exports;
  const livekit_models_12 = livekit_models$1;
  const events_2 = events$1;
  const Track_12 = Track;
  var ConnectionQuality;
  (function(ConnectionQuality2) {
    ConnectionQuality2["Excellent"] = "excellent";
    ConnectionQuality2["Good"] = "good";
    ConnectionQuality2["Poor"] = "poor";
    ConnectionQuality2["Unknown"] = "unknown";
  })(ConnectionQuality = exports2.ConnectionQuality || (exports2.ConnectionQuality = {}));
  function qualityFromProto(q2) {
    switch (q2) {
      case livekit_models_12.ConnectionQuality.EXCELLENT:
        return ConnectionQuality.Excellent;
      case livekit_models_12.ConnectionQuality.GOOD:
        return ConnectionQuality.Good;
      case livekit_models_12.ConnectionQuality.POOR:
        return ConnectionQuality.Poor;
      default:
        return ConnectionQuality.Unknown;
    }
  }
  class Participant2 extends events_12.EventEmitter {
    constructor(sid, identity2) {
      super();
      this.audioLevel = 0;
      this.isSpeaking = false;
      this._connectionQuality = ConnectionQuality.Unknown;
      this.sid = sid;
      this.identity = identity2;
      this.audioTracks = /* @__PURE__ */ new Map();
      this.videoTracks = /* @__PURE__ */ new Map();
      this.tracks = /* @__PURE__ */ new Map();
    }
    getTracks() {
      return Array.from(this.tracks.values());
    }
    getTrack(source2) {
      if (source2 === Track_12.Track.Source.Unknown) {
        return;
      }
      for (const [, pub] of this.tracks) {
        if (pub.source === source2) {
          return pub;
        }
        if (pub.source === Track_12.Track.Source.Unknown) {
          if (source2 === Track_12.Track.Source.Microphone && pub.kind === Track_12.Track.Kind.Audio && pub.trackName !== "screen") {
            return pub;
          }
          if (source2 === Track_12.Track.Source.Camera && pub.kind === Track_12.Track.Kind.Video && pub.trackName !== "screen") {
            return pub;
          }
          if (source2 === Track_12.Track.Source.ScreenShare && pub.kind === Track_12.Track.Kind.Video && pub.trackName === "screen") {
            return pub;
          }
          if (source2 === Track_12.Track.Source.ScreenShareAudio && pub.kind === Track_12.Track.Kind.Audio && pub.trackName === "screen") {
            return pub;
          }
        }
      }
    }
    getTrackByName(name2) {
      for (const [, pub] of this.tracks) {
        if (pub.trackName === name2) {
          return pub;
        }
      }
    }
    get connectionQuality() {
      return this._connectionQuality;
    }
    get isCameraEnabled() {
      var _a2;
      const track = this.getTrack(Track_12.Track.Source.Camera);
      return !((_a2 = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a2 !== void 0 ? _a2 : true);
    }
    get isMicrophoneEnabled() {
      var _a2;
      const track = this.getTrack(Track_12.Track.Source.Microphone);
      return !((_a2 = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a2 !== void 0 ? _a2 : true);
    }
    get isScreenShareEnabled() {
      const track = this.getTrack(Track_12.Track.Source.ScreenShare);
      return !!track;
    }
    get joinedAt() {
      if (this.participantInfo) {
        return new Date(this.participantInfo.joinedAt * 1e3);
      }
      return new Date();
    }
    updateInfo(info) {
      this.identity = info.identity;
      this.sid = info.sid;
      this.name = info.name;
      this.setMetadata(info.metadata);
      this.participantInfo = info;
    }
    setMetadata(md2) {
      const changed = !this.participantInfo || this.participantInfo.metadata !== md2;
      const prevMetadata = this.metadata;
      this.metadata = md2;
      if (changed) {
        this.emit(events_2.ParticipantEvent.MetadataChanged, prevMetadata, this);
        this.emit(events_2.ParticipantEvent.ParticipantMetadataChanged, prevMetadata, this);
      }
    }
    setIsSpeaking(speaking) {
      if (speaking === this.isSpeaking) {
        return;
      }
      this.isSpeaking = speaking;
      if (speaking) {
        this.lastSpokeAt = new Date();
      }
      this.emit(events_2.ParticipantEvent.IsSpeakingChanged, speaking);
    }
    setConnectionQuality(q2) {
      const prevQuality = this._connectionQuality;
      this._connectionQuality = qualityFromProto(q2);
      if (prevQuality !== this._connectionQuality) {
        this.emit(events_2.ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);
      }
    }
    addTrackPublication(publication) {
      publication.on(events_2.TrackEvent.Muted, () => {
        this.emit(events_2.ParticipantEvent.TrackMuted, publication);
      });
      publication.on(events_2.TrackEvent.Unmuted, () => {
        this.emit(events_2.ParticipantEvent.TrackUnmuted, publication);
      });
      const pub = publication;
      if (pub.track) {
        pub.track.sid = publication.trackSid;
      }
      this.tracks.set(publication.trackSid, publication);
      switch (publication.kind) {
        case Track_12.Track.Kind.Audio:
          this.audioTracks.set(publication.trackSid, publication);
          break;
        case Track_12.Track.Kind.Video:
          this.videoTracks.set(publication.trackSid, publication);
          break;
      }
    }
  }
  exports2.default = Participant2;
})(Participant$1);
var ParticipantTrackPermission = {};
Object.defineProperty(ParticipantTrackPermission, "__esModule", { value: true });
ParticipantTrackPermission.trackPermissionToProto = void 0;
function trackPermissionToProto(perms) {
  var _a2;
  if (!perms.participantSid) {
    throw new Error("Invalid track permission, missing participantSid");
  }
  return { participantSid: perms.participantSid, allTracks: (_a2 = perms.allowAll) !== null && _a2 !== void 0 ? _a2 : false, trackSids: perms.allowedTrackSids || [] };
}
ParticipantTrackPermission.trackPermissionToProto = trackPermissionToProto;
var publishUtils = {};
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.presetsForResolution = exports2.determineAppropriateEncoding = exports2.computeVideoEncodings = exports2.presetsScreenShare = exports2.presets43 = exports2.presets169 = exports2.mediaTrackToLocalTrack = void 0;
  const logger_12 = __importDefault2(logger);
  const errors_12 = errors;
  const LocalAudioTrack_12 = __importDefault2(LocalAudioTrack$1);
  const LocalVideoTrack_12 = __importDefault2(LocalVideoTrack$1);
  const options_12 = options$1;
  function mediaTrackToLocalTrack(mediaStreamTrack, constraints) {
    switch (mediaStreamTrack.kind) {
      case "audio":
        return new LocalAudioTrack_12.default(mediaStreamTrack, constraints);
      case "video":
        return new LocalVideoTrack_12.default(mediaStreamTrack, constraints);
      default:
        throw new errors_12.TrackInvalidError(`unsupported track type: ${mediaStreamTrack.kind}`);
    }
  }
  exports2.mediaTrackToLocalTrack = mediaTrackToLocalTrack;
  exports2.presets169 = [options_12.VideoPresets.qvga, options_12.VideoPresets.vga, options_12.VideoPresets.qhd, options_12.VideoPresets.hd, options_12.VideoPresets.fhd];
  exports2.presets43 = [options_12.VideoPresets43.qvga, options_12.VideoPresets43.vga, options_12.VideoPresets43.qhd, options_12.VideoPresets43.hd, options_12.VideoPresets43.fhd];
  exports2.presetsScreenShare = [options_12.ScreenSharePresets.vga, options_12.ScreenSharePresets.hd_8, options_12.ScreenSharePresets.hd_15, options_12.ScreenSharePresets.fhd_15, options_12.ScreenSharePresets.fhd_30];
  const videoRids = ["q", "h", "f"];
  function computeVideoEncodings(isScreenShare, width, height, options2) {
    let videoEncoding = options2 === null || options2 === void 0 ? void 0 : options2.videoEncoding;
    if (isScreenShare) {
      videoEncoding = options2 === null || options2 === void 0 ? void 0 : options2.screenShareEncoding;
    }
    const useSimulcast = !isScreenShare && (options2 === null || options2 === void 0 ? void 0 : options2.simulcast);
    if (!videoEncoding && !useSimulcast || !width || !height) {
      return [{}];
    }
    if (!videoEncoding) {
      videoEncoding = determineAppropriateEncoding(isScreenShare, width, height);
      logger_12.default.debug("using video encoding", videoEncoding);
    }
    if (!useSimulcast) {
      return [videoEncoding];
    }
    const presets = presetsForResolution(isScreenShare, width, height);
    let midPreset;
    const lowPreset = presets[0];
    if (presets.length > 1) {
      [, midPreset] = presets;
    }
    const original = new options_12.VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate);
    const size = Math.max(width, height);
    if (size >= 960 && midPreset) {
      return encodingsFromPresets(width, height, [lowPreset, midPreset, original]);
    }
    if (size >= 500) {
      return encodingsFromPresets(width, height, [lowPreset, original]);
    }
    return encodingsFromPresets(width, height, [original]);
  }
  exports2.computeVideoEncodings = computeVideoEncodings;
  function determineAppropriateEncoding(isScreenShare, width, height) {
    const presets = presetsForResolution(isScreenShare, width, height);
    let { encoding } = presets[0];
    const size = Math.max(width, height);
    for (let i2 = 0; i2 < presets.length; i2 += 1) {
      const preset = presets[i2];
      encoding = preset.encoding;
      if (preset.width >= size) {
        break;
      }
    }
    return encoding;
  }
  exports2.determineAppropriateEncoding = determineAppropriateEncoding;
  function presetsForResolution(isScreenShare, width, height) {
    if (isScreenShare) {
      return exports2.presetsScreenShare;
    }
    const aspect = width > height ? width / height : height / width;
    if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
      return exports2.presets169;
    }
    return exports2.presets43;
  }
  exports2.presetsForResolution = presetsForResolution;
  function encodingsFromPresets(width, height, presets) {
    const encodings = [];
    presets.forEach((preset, idx) => {
      if (idx >= videoRids.length) {
        return;
      }
      const size = Math.min(width, height);
      const rid = videoRids[idx];
      encodings.push({ rid, scaleResolutionDownBy: size / Math.min(preset.width, preset.height), maxBitrate: preset.encoding.maxBitrate, maxFramerate: preset.encoding.maxFramerate });
    });
    return encodings;
  }
})(publishUtils);
var RemoteParticipant$1 = {};
var RemoteTrackPublication$1 = {};
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(RemoteTrackPublication$1, "__esModule", { value: true });
const logger_1$4 = __importDefault$6(logger);
const livekit_models_1$1 = livekit_models$1;
const livekit_rtc_1$2 = livekit_rtc;
const events_1$2 = events$1;
const RemoteVideoTrack_1$1 = __importDefault$6(RemoteVideoTrack$1);
const TrackPublication_1 = TrackPublication;
class RemoteTrackPublication extends TrackPublication_1.TrackPublication {
  constructor() {
    super(...arguments);
    this._allowed = true;
    this.disabled = false;
    this.currentVideoQuality = livekit_models_1$1.VideoQuality.HIGH;
    this.handleEnded = (track) => {
      this.emit(events_1$2.TrackEvent.Ended, track);
    };
    this.handleVisibilityChange = (visible) => {
      logger_1$4.default.debug("adaptivestream video visibility", this.trackSid, `visible=${visible}`);
      this.disabled = !visible;
      this.emitTrackUpdate();
    };
    this.handleVideoDimensionsChange = (dimensions) => {
      logger_1$4.default.debug("adaptivestream video dimensions", this.trackSid, `${dimensions.width}x${dimensions.height}`);
      this.videoDimensions = dimensions;
      this.emitTrackUpdate();
    };
  }
  setSubscribed(subscribed) {
    this.subscribed = subscribed;
    const sub = { trackSids: [this.trackSid], subscribe: this.subscribed, participantTracks: [] };
    this.emit(events_1$2.TrackEvent.UpdateSubscription, sub);
  }
  get subscriptionStatus() {
    if (this.subscribed === false || !super.isSubscribed) {
      return TrackPublication_1.TrackPublication.SubscriptionStatus.Unsubscribed;
    }
    if (!this._allowed) {
      return TrackPublication_1.TrackPublication.SubscriptionStatus.NotAllowed;
    }
    return TrackPublication_1.TrackPublication.SubscriptionStatus.Subscribed;
  }
  get isSubscribed() {
    if (this.subscribed === false) {
      return false;
    }
    if (!this._allowed) {
      return false;
    }
    return super.isSubscribed;
  }
  get isEnabled() {
    return !this.disabled;
  }
  setEnabled(enabled) {
    if (!this.isManualOperationAllowed() || this.disabled === !enabled) {
      return;
    }
    this.disabled = !enabled;
    this.emitTrackUpdate();
  }
  setVideoQuality(quality) {
    if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {
      return;
    }
    this.currentVideoQuality = quality;
    this.videoDimensions = void 0;
    this.emitTrackUpdate();
  }
  setVideoDimensions(dimensions) {
    var _a2, _b;
    if (!this.isManualOperationAllowed()) {
      return;
    }
    if (((_a2 = this.videoDimensions) === null || _a2 === void 0 ? void 0 : _a2.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {
      return;
    }
    if (this.track instanceof RemoteVideoTrack_1$1.default) {
      this.videoDimensions = dimensions;
    }
    this.currentVideoQuality = void 0;
    this.emitTrackUpdate();
  }
  get videoQuality() {
    return this.currentVideoQuality;
  }
  setTrack(track) {
    if (this.track) {
      this.track.off(events_1$2.TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
      this.track.off(events_1$2.TrackEvent.VisibilityChanged, this.handleVisibilityChange);
      this.track.off(events_1$2.TrackEvent.Ended, this.handleEnded);
    }
    super.setTrack(track);
    if (track) {
      track.sid = this.trackSid;
      track.on(events_1$2.TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
      track.on(events_1$2.TrackEvent.VisibilityChanged, this.handleVisibilityChange);
      track.on(events_1$2.TrackEvent.Ended, this.handleEnded);
    }
  }
  updateInfo(info) {
    var _a2;
    super.updateInfo(info);
    this.metadataMuted = info.muted;
    (_a2 = this.track) === null || _a2 === void 0 ? void 0 : _a2.setMuted(info.muted);
  }
  isManualOperationAllowed() {
    if (this.isAdaptiveStream) {
      logger_1$4.default.warn("adaptive stream is enabled, cannot change track settings", this.trackSid);
      return false;
    }
    if (!this.isSubscribed) {
      logger_1$4.default.warn("cannot update track settings when not subscribed", this.trackSid);
      return false;
    }
    return true;
  }
  get isAdaptiveStream() {
    return this.track instanceof RemoteVideoTrack_1$1.default && this.track.isAdaptiveStream;
  }
  emitTrackUpdate() {
    const settings = livekit_rtc_1$2.UpdateTrackSettings.fromPartial({ trackSids: [this.trackSid], disabled: this.disabled });
    if (this.videoDimensions) {
      settings.width = this.videoDimensions.width;
      settings.height = this.videoDimensions.height;
    } else if (this.currentVideoQuality !== void 0) {
      settings.quality = this.currentVideoQuality;
    } else {
      settings.quality = livekit_models_1$1.VideoQuality.HIGH;
    }
    this.emit(events_1$2.TrackEvent.UpdateSettings, settings);
  }
}
RemoteTrackPublication$1.default = RemoteTrackPublication;
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(RemoteParticipant$1, "__esModule", { value: true });
const logger_1$3 = __importDefault$5(logger);
const events_1$1 = events$1;
const RemoteAudioTrack_1 = __importDefault$5(RemoteAudioTrack$1);
const RemoteTrackPublication_1 = __importDefault$5(RemoteTrackPublication$1);
const RemoteVideoTrack_1 = __importDefault$5(RemoteVideoTrack$1);
const Track_1$2 = Track;
const Participant_1$1 = __importDefault$5(Participant$1);
class RemoteParticipant extends Participant_1$1.default {
  constructor(signalClient, id2, name2) {
    super(id2, name2 || "");
    this.signalClient = signalClient;
    this.tracks = /* @__PURE__ */ new Map();
    this.audioTracks = /* @__PURE__ */ new Map();
    this.videoTracks = /* @__PURE__ */ new Map();
  }
  static fromParticipantInfo(signalClient, pi2) {
    const rp = new RemoteParticipant(signalClient, pi2.sid, pi2.identity);
    rp.updateInfo(pi2);
    return rp;
  }
  addTrackPublication(publication) {
    super.addTrackPublication(publication);
    publication.on(events_1$1.TrackEvent.UpdateSettings, (settings) => {
      this.signalClient.sendUpdateTrackSettings(settings);
    });
    publication.on(events_1$1.TrackEvent.UpdateSubscription, (sub) => {
      this.signalClient.sendUpdateSubscription(sub);
    });
    publication.on(events_1$1.TrackEvent.Ended, (track) => {
      this.emit(events_1$1.ParticipantEvent.TrackUnsubscribed, track, publication);
    });
  }
  getTrack(source2) {
    const track = super.getTrack(source2);
    if (track) {
      return track;
    }
  }
  getTrackByName(name2) {
    const track = super.getTrackByName(name2);
    if (track) {
      return track;
    }
  }
  addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStream, triesLeft) {
    let publication = this.getTrackPublication(sid);
    if (!publication) {
      if (!sid.startsWith("TR")) {
        this.tracks.forEach((p2) => {
          if (!publication && mediaTrack.kind === p2.kind.toString()) {
            publication = p2;
          }
        });
      }
    }
    if (!publication) {
      if (triesLeft === 0) {
        logger_1$3.default.error("could not find published track", this.sid, sid);
        this.emit(events_1$1.ParticipantEvent.TrackSubscriptionFailed, sid);
        return;
      }
      if (triesLeft === void 0)
        triesLeft = 20;
      setTimeout(() => {
        this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStream, triesLeft - 1);
      }, 150);
      return;
    }
    const isVideo = mediaTrack.kind === "video";
    let track;
    if (isVideo) {
      track = new RemoteVideoTrack_1.default(mediaTrack, sid, receiver, adaptiveStream);
    } else {
      track = new RemoteAudioTrack_1.default(mediaTrack, sid, receiver);
    }
    track.source = publication.source;
    track.isMuted = publication.isMuted;
    track.setMediaStream(mediaStream);
    track.start();
    publication.setTrack(track);
    this.emit(events_1$1.ParticipantEvent.TrackSubscribed, track, publication);
    return publication;
  }
  get hasMetadata() {
    return !!this.participantInfo;
  }
  getTrackPublication(sid) {
    return this.tracks.get(sid);
  }
  updateInfo(info) {
    const alreadyHasMetadata = this.hasMetadata;
    super.updateInfo(info);
    const validTracks = /* @__PURE__ */ new Map();
    const newTracks = /* @__PURE__ */ new Map();
    info.tracks.forEach((ti2) => {
      let publication = this.getTrackPublication(ti2.sid);
      if (!publication) {
        const kind = Track_1$2.Track.kindFromProto(ti2.type);
        if (!kind) {
          return;
        }
        publication = new RemoteTrackPublication_1.default(kind, ti2.sid, ti2.name);
        publication.updateInfo(ti2);
        newTracks.set(ti2.sid, publication);
        this.addTrackPublication(publication);
      } else {
        publication.updateInfo(ti2);
      }
      validTracks.set(ti2.sid, publication);
    });
    if (alreadyHasMetadata) {
      newTracks.forEach((publication) => {
        this.emit(events_1$1.ParticipantEvent.TrackPublished, publication);
      });
    }
    this.tracks.forEach((publication) => {
      if (!validTracks.has(publication.trackSid)) {
        this.unpublishTrack(publication.trackSid, true);
      }
    });
  }
  unpublishTrack(sid, sendUnpublish) {
    const publication = this.tracks.get(sid);
    if (!publication) {
      return;
    }
    this.tracks.delete(sid);
    switch (publication.kind) {
      case Track_1$2.Track.Kind.Audio:
        this.audioTracks.delete(sid);
        break;
      case Track_1$2.Track.Kind.Video:
        this.videoTracks.delete(sid);
        break;
    }
    const { track } = publication;
    if (track) {
      const { isSubscribed } = publication;
      track.stop();
      publication.setTrack(void 0);
      if (isSubscribed) {
        this.emit(events_1$1.ParticipantEvent.TrackUnsubscribed, track, publication);
      }
    }
    if (sendUnpublish) {
      this.emit(events_1$1.ParticipantEvent.TrackUnpublished, publication);
    }
  }
  emit(event2, ...args) {
    logger_1$3.default.trace("participant event", this.sid, event2, ...args);
    return super.emit(event2, ...args);
  }
}
RemoteParticipant$1.default = RemoteParticipant;
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
  if (k2 === void 0)
    k2 = k;
  Object.defineProperty(o2, k2, { enumerable: true, get: function() {
    return m2[k];
  } });
} : function(o2, m2, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o2[k2] = m2[k];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k in mod2)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
        __createBinding(result, mod2, k);
  }
  __setModuleDefault(result, mod2);
  return result;
};
var __awaiter$4 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(LocalParticipant$1, "__esModule", { value: true });
const logger_1$2 = __importDefault$4(logger);
const livekit_rtc_1$1 = livekit_rtc;
const errors_1$2 = errors;
const events_1 = events$1;
const LocalAudioTrack_1$1 = __importDefault$4(LocalAudioTrack$1);
const LocalTrackPublication_1 = __importDefault$4(LocalTrackPublication$1);
const LocalVideoTrack_1$1 = __importStar(LocalVideoTrack$1);
const options_1$2 = options$1;
const Track_1$1 = Track;
const utils_1$2 = utils$e;
const Participant_1 = __importDefault$4(Participant$1);
const ParticipantTrackPermission_1 = ParticipantTrackPermission;
const publishUtils_1$1 = publishUtils;
const RemoteParticipant_1 = __importDefault$4(RemoteParticipant$1);
class LocalParticipant extends Participant_1.default {
  constructor(sid, identity2, engine, options2) {
    super(sid, identity2);
    this.pendingPublishing = /* @__PURE__ */ new Set();
    this.onTrackUnmuted = (track) => {
      this.onTrackMuted(track, false);
    };
    this.onTrackMuted = (track, muted) => {
      if (muted === void 0) {
        muted = true;
      }
      if (!track.sid) {
        logger_1$2.default.error("could not update mute status for unpublished track", track);
        return;
      }
      this.engine.updateMuteStatus(track.sid, muted);
    };
    this.handleSubscribedQualityUpdate = (update) => {
      var _a2, _b;
      if (!((_a2 = this.roomOptions) === null || _a2 === void 0 ? void 0 : _a2.dynacast)) {
        return;
      }
      const pub = this.videoTracks.get(update.trackSid);
      if (!pub) {
        logger_1$2.default.warn("handleSubscribedQualityUpdate", "received subscribed quality update for unknown track", update.trackSid);
        return;
      }
      (_b = pub.videoTrack) === null || _b === void 0 ? void 0 : _b.setPublishingLayers(update.subscribedQualities);
    };
    this.onTrackUnpublish = (track) => {
      this.unpublishTrack(track);
    };
    this.audioTracks = /* @__PURE__ */ new Map();
    this.videoTracks = /* @__PURE__ */ new Map();
    this.tracks = /* @__PURE__ */ new Map();
    this.engine = engine;
    this.roomOptions = options2;
    this.engine.client.onRemoteMuteChanged = (trackSid, muted) => {
      const pub = this.tracks.get(trackSid);
      if (!pub || !pub.track) {
        return;
      }
      if (muted) {
        pub.mute();
      } else {
        pub.unmute();
      }
    };
    this.engine.client.onSubscribedQualityUpdate = this.handleSubscribedQualityUpdate;
  }
  get lastCameraError() {
    return this.cameraError;
  }
  get lastMicrophoneError() {
    return this.microphoneError;
  }
  getTrack(source2) {
    const track = super.getTrack(source2);
    if (track) {
      return track;
    }
  }
  getTrackByName(name2) {
    const track = super.getTrackByName(name2);
    if (track) {
      return track;
    }
  }
  setCameraEnabled(enabled) {
    return this.setTrackEnabled(Track_1$1.Track.Source.Camera, enabled);
  }
  setMicrophoneEnabled(enabled) {
    return this.setTrackEnabled(Track_1$1.Track.Source.Microphone, enabled);
  }
  setScreenShareEnabled(enabled) {
    return this.setTrackEnabled(Track_1$1.Track.Source.ScreenShare, enabled);
  }
  setTrackEnabled(source2, enabled) {
    return __awaiter$4(this, void 0, void 0, function* () {
      logger_1$2.default.debug("setTrackEnabled", source2, enabled);
      const track = this.getTrack(source2);
      if (enabled) {
        if (track) {
          yield track.unmute();
        } else {
          let localTrack;
          if (this.pendingPublishing.has(source2)) {
            logger_1$2.default.info("skipping duplicate published source", source2);
            return;
          }
          this.pendingPublishing.add(source2);
          try {
            switch (source2) {
              case Track_1$1.Track.Source.Camera:
                [localTrack] = yield this.createTracks({ video: true });
                break;
              case Track_1$1.Track.Source.Microphone:
                [localTrack] = yield this.createTracks({ audio: true });
                break;
              case Track_1$1.Track.Source.ScreenShare:
                [localTrack] = yield this.createScreenTracks({ audio: false });
                break;
              default:
                throw new errors_1$2.TrackInvalidError(source2);
            }
            yield this.publishTrack(localTrack);
          } catch (e2) {
            if (e2 instanceof Error && !(e2 instanceof errors_1$2.TrackInvalidError)) {
              this.emit(events_1.ParticipantEvent.MediaDevicesError, e2);
            }
            throw e2;
          } finally {
            this.pendingPublishing.delete(source2);
          }
        }
      } else if (track && track.track) {
        if (source2 === Track_1$1.Track.Source.ScreenShare) {
          this.unpublishTrack(track.track);
        } else {
          yield track.mute();
        }
      }
    });
  }
  enableCameraAndMicrophone() {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (this.pendingPublishing.has(Track_1$1.Track.Source.Camera) || this.pendingPublishing.has(Track_1$1.Track.Source.Microphone)) {
        return;
      }
      this.pendingPublishing.add(Track_1$1.Track.Source.Camera);
      this.pendingPublishing.add(Track_1$1.Track.Source.Microphone);
      try {
        const tracks = yield this.createTracks({ audio: true, video: true });
        yield Promise.all(tracks.map((track) => this.publishTrack(track)));
      } finally {
        this.pendingPublishing.delete(Track_1$1.Track.Source.Camera);
        this.pendingPublishing.delete(Track_1$1.Track.Source.Microphone);
      }
    });
  }
  createTracks(options2) {
    var _a2, _b;
    return __awaiter$4(this, void 0, void 0, function* () {
      const opts = utils_1$2.mergeDefaultOptions(options2, (_a2 = this.roomOptions) === null || _a2 === void 0 ? void 0 : _a2.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);
      const constraints = utils_1$2.constraintsForOptions(opts);
      let stream;
      try {
        stream = yield navigator.mediaDevices.getUserMedia(constraints);
      } catch (err) {
        if (err instanceof Error) {
          if (constraints.audio) {
            this.microphoneError = err;
          }
          if (constraints.video) {
            this.cameraError = err;
          }
        }
        throw err;
      }
      if (constraints.audio) {
        this.microphoneError = void 0;
      }
      if (constraints.video) {
        this.cameraError = void 0;
      }
      return stream.getTracks().map((mediaStreamTrack) => {
        const isAudio = mediaStreamTrack.kind === "audio";
        isAudio ? options2.audio : options2.video;
        let trackConstraints;
        const conOrBool = isAudio ? constraints.audio : constraints.video;
        if (typeof conOrBool !== "boolean") {
          trackConstraints = conOrBool;
        }
        const track = publishUtils_1$1.mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);
        if (track.kind === Track_1$1.Track.Kind.Video) {
          track.source = Track_1$1.Track.Source.Camera;
        } else if (track.kind === Track_1$1.Track.Kind.Audio) {
          track.source = Track_1$1.Track.Source.Microphone;
        }
        return track;
      });
    });
  }
  createScreenTracks(options2) {
    var _a2;
    return __awaiter$4(this, void 0, void 0, function* () {
      if (options2 === void 0) {
        options2 = {};
      }
      if (options2.resolution === void 0) {
        options2.resolution = options_1$2.VideoPresets.fhd.resolution;
      }
      let videoConstraints = true;
      if (options2.resolution) {
        videoConstraints = { width: options2.resolution.width, height: options2.resolution.height, frameRate: options2.resolution.frameRate };
      }
      const stream = yield navigator.mediaDevices.getDisplayMedia({ audio: (_a2 = options2.audio) !== null && _a2 !== void 0 ? _a2 : false, video: videoConstraints });
      const tracks = stream.getVideoTracks();
      if (tracks.length === 0) {
        throw new errors_1$2.TrackInvalidError("no video track found");
      }
      const screenVideo = new LocalVideoTrack_1$1.default(tracks[0]);
      screenVideo.source = Track_1$1.Track.Source.ScreenShare;
      const localTracks = [screenVideo];
      if (stream.getAudioTracks().length > 0) {
        const screenAudio = new LocalAudioTrack_1$1.default(stream.getAudioTracks()[0]);
        screenAudio.source = Track_1$1.Track.Source.ScreenShareAudio;
        localTracks.push(screenAudio);
      }
      return localTracks;
    });
  }
  publishTrack(track, options2) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    return __awaiter$4(this, void 0, void 0, function* () {
      const opts = Object.assign(Object.assign({}, (_a2 = this.roomOptions) === null || _a2 === void 0 ? void 0 : _a2.publishDefaults), options2);
      if (track instanceof MediaStreamTrack) {
        switch (track.kind) {
          case "audio":
            track = new LocalAudioTrack_1$1.default(track);
            break;
          case "video":
            track = new LocalVideoTrack_1$1.default(track);
            break;
          default:
            throw new errors_1$2.TrackInvalidError(`unsupported MediaStreamTrack kind ${track.kind}`);
        }
      }
      let existingPublication;
      this.tracks.forEach((publication2) => {
        if (!publication2.track) {
          return;
        }
        if (publication2.track === track) {
          existingPublication = publication2;
        }
      });
      if (existingPublication)
        return existingPublication;
      if (opts.source) {
        track.source = opts.source;
      }
      if (opts.stopMicTrackOnMute && track instanceof LocalAudioTrack_1$1.default) {
        track.stopOnMute = true;
      }
      track.on(events_1.TrackEvent.Muted, this.onTrackMuted);
      track.on(events_1.TrackEvent.Unmuted, this.onTrackUnmuted);
      track.on(events_1.TrackEvent.Ended, this.onTrackUnpublish);
      const req = livekit_rtc_1$1.AddTrackRequest.fromPartial({ cid: track.mediaStreamTrack.id, name: options2 === null || options2 === void 0 ? void 0 : options2.name, type: Track_1$1.Track.kindToProto(track.kind), muted: track.isMuted, source: Track_1$1.Track.sourceToProto(track.source), disableDtx: !((_b = opts === null || opts === void 0 ? void 0 : opts.dtx) !== null && _b !== void 0 ? _b : true) });
      let encodings;
      if (track.kind === Track_1$1.Track.Kind.Video) {
        const settings = track.mediaStreamTrack.getSettings();
        const width = (_c = settings.width) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.width;
        const height = (_e = settings.height) !== null && _e !== void 0 ? _e : (_f = track.dimensions) === null || _f === void 0 ? void 0 : _f.height;
        req.width = width !== null && width !== void 0 ? width : 0;
        req.height = height !== null && height !== void 0 ? height : 0;
        encodings = publishUtils_1$1.computeVideoEncodings(track.source === Track_1$1.Track.Source.ScreenShare, width, height, opts);
        req.layers = LocalVideoTrack_1$1.videoLayersFromEncodings(req.width, req.height, encodings);
      } else if (track.kind === Track_1$1.Track.Kind.Audio && opts.audioBitrate) {
        encodings = [{ maxBitrate: opts.audioBitrate }];
      }
      const ti2 = yield this.engine.addTrack(req);
      const publication = new LocalTrackPublication_1.default(track.kind, ti2, track);
      track.sid = ti2.sid;
      if (!this.engine.publisher) {
        throw new errors_1$2.UnexpectedConnectionState("publisher is closed");
      }
      logger_1$2.default.debug(`publishing ${track.kind} with encodings`, encodings, ti2);
      const transceiverInit = { direction: "sendonly" };
      if (encodings) {
        transceiverInit.sendEncodings = encodings;
      }
      const transceiver = this.engine.publisher.pc.addTransceiver(track.mediaStreamTrack, transceiverInit);
      this.engine.negotiate();
      track.sender = transceiver.sender;
      if (track instanceof LocalVideoTrack_1$1.default) {
        const disableLayerPause = (_h = (_g = this.roomOptions) === null || _g === void 0 ? void 0 : _g.expDisableLayerPause) !== null && _h !== void 0 ? _h : false;
        track.startMonitor(this.engine.client, disableLayerPause);
      } else if (track instanceof LocalAudioTrack_1$1.default) {
        track.startMonitor();
      }
      if (opts.videoCodec) {
        this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);
      }
      this.addTrackPublication(publication);
      this.emit(events_1.ParticipantEvent.LocalTrackPublished, publication);
      return publication;
    });
  }
  unpublishTrack(track) {
    var _a2, _b;
    const publication = this.getPublicationForTrack(track);
    logger_1$2.default.debug("unpublishTrack", "unpublishing track", track);
    if (!publication || !publication.track) {
      logger_1$2.default.warn("unpublishTrack", "track was not unpublished because no publication was found", track);
      return null;
    }
    track = publication.track;
    track.off(events_1.TrackEvent.Muted, this.onTrackMuted);
    track.off(events_1.TrackEvent.Unmuted, this.onTrackUnmuted);
    track.off(events_1.TrackEvent.Ended, this.onTrackUnpublish);
    if ((_b = (_a2 = this.roomOptions) === null || _a2 === void 0 ? void 0 : _a2.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true) {
      track.stop();
    }
    const { mediaStreamTrack } = track;
    if (this.engine.publisher) {
      const senders = this.engine.publisher.pc.getSenders();
      senders.forEach((sender) => {
        var _a3;
        if (sender.track === mediaStreamTrack) {
          try {
            (_a3 = this.engine.publisher) === null || _a3 === void 0 ? void 0 : _a3.pc.removeTrack(sender);
            this.engine.negotiate();
          } catch (e2) {
            logger_1$2.default.warn("unpublishTrack", "failed to remove track", e2);
          }
        }
      });
    }
    this.tracks.delete(publication.trackSid);
    switch (publication.kind) {
      case Track_1$1.Track.Kind.Audio:
        this.audioTracks.delete(publication.trackSid);
        break;
      case Track_1$1.Track.Kind.Video:
        this.videoTracks.delete(publication.trackSid);
        break;
    }
    publication.setTrack(void 0);
    this.emit(events_1.ParticipantEvent.LocalTrackUnpublished, publication);
    return publication;
  }
  unpublishTracks(tracks) {
    const publications = [];
    tracks.forEach((track) => {
      const pub = this.unpublishTrack(track);
      if (pub) {
        publications.push(pub);
      }
    });
    return publications;
  }
  get publisherMetrics() {
    return null;
  }
  publishData(data2, kind, destination) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const dest = [];
      if (destination !== void 0) {
        destination.forEach((val) => {
          if (val instanceof RemoteParticipant_1.default) {
            dest.push(val.sid);
          } else {
            dest.push(val);
          }
        });
      }
      const packet = { kind, user: { participantSid: this.sid, payload: data2, destinationSids: dest } };
      yield this.engine.sendDataPacket(packet, kind);
    });
  }
  setTrackSubscriptionPermissions(allParticipantsAllowed, participantTrackPermissions = []) {
    this.engine.client.sendUpdateSubscriptionPermissions(allParticipantsAllowed, participantTrackPermissions.map((p2) => ParticipantTrackPermission_1.trackPermissionToProto(p2)));
  }
  getPublicationForTrack(track) {
    let publication;
    this.tracks.forEach((pub) => {
      const localTrack = pub.track;
      if (!localTrack) {
        return;
      }
      if (track instanceof MediaStreamTrack) {
        if (localTrack instanceof LocalAudioTrack_1$1.default || localTrack instanceof LocalVideoTrack_1$1.default) {
          if (localTrack.mediaStreamTrack === track) {
            publication = pub;
          }
        }
      } else if (track === localTrack) {
        publication = pub;
      }
    });
    return publication;
  }
  setPreferredCodec(transceiver, kind, videoCodec) {
    if (!("getCapabilities" in RTCRtpSender)) {
      return;
    }
    const cap = RTCRtpSender.getCapabilities(kind);
    if (!cap)
      return;
    const selected = cap.codecs.find((c) => {
      const codec = c.mimeType.toLowerCase();
      const matchesVideoCodec = codec === `video/${videoCodec}`;
      if (videoCodec === "h264" && c.sdpFmtpLine) {
        return matchesVideoCodec && c.sdpFmtpLine.includes("profile-level-id=42e01f");
      }
      return matchesVideoCodec || codec === "audio/opus";
    });
    if (selected && "setCodecPreferences" in transceiver) {
      transceiver.setCodecPreferences([selected]);
    }
  }
  publishedTracksInfo() {
    const infos = [];
    this.tracks.forEach((track) => {
      if (track.track !== void 0) {
        infos.push({ cid: track.track.mediaStreamTrack.id, track: track.trackInfo });
      }
    });
    return infos;
  }
}
LocalParticipant$1.default = LocalParticipant;
var Room$1 = {};
var SignalClient$1 = {};
let logDisabled_ = true;
let deprecationWarnings_ = true;
function extractVersion(uastring, expr, pos) {
  const match = uastring.match(expr);
  return match && match.length >= pos && parseInt(match[pos], 10);
}
function wrapPeerConnectionEvent(window2, eventNameToWrap, wrapper) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  const proto = window2.RTCPeerConnection.prototype;
  const nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb2) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    const wrappedCallback = (e2) => {
      const modifiedEvent = wrapper(e2);
      if (modifiedEvent) {
        if (cb2.handleEvent) {
          cb2.handleEvent(modifiedEvent);
        } else {
          cb2(modifiedEvent);
        }
      }
    };
    this._eventMap = this._eventMap || {};
    if (!this._eventMap[eventNameToWrap]) {
      this._eventMap[eventNameToWrap] = /* @__PURE__ */ new Map();
    }
    this._eventMap[eventNameToWrap].set(cb2, wrappedCallback);
    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
  };
  const nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb2) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    if (!this._eventMap[eventNameToWrap].has(cb2)) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb2);
    this._eventMap[eventNameToWrap].delete(cb2);
    if (this._eventMap[eventNameToWrap].size === 0) {
      delete this._eventMap[eventNameToWrap];
    }
    if (Object.keys(this._eventMap).length === 0) {
      delete this._eventMap;
    }
    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
  };
  Object.defineProperty(proto, "on" + eventNameToWrap, { get() {
    return this["_on" + eventNameToWrap];
  }, set(cb2) {
    if (this["_on" + eventNameToWrap]) {
      this.removeEventListener(eventNameToWrap, this["_on" + eventNameToWrap]);
      delete this["_on" + eventNameToWrap];
    }
    if (cb2) {
      this.addEventListener(eventNameToWrap, this["_on" + eventNameToWrap] = cb2);
    }
  }, enumerable: true, configurable: true });
}
function disableLog(bool) {
  if (typeof bool !== "boolean") {
    return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
  }
  logDisabled_ = bool;
  return bool ? "adapter.js logging disabled" : "adapter.js logging enabled";
}
function disableWarnings(bool) {
  if (typeof bool !== "boolean") {
    return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
  }
  deprecationWarnings_ = !bool;
  return "adapter.js deprecation warnings " + (bool ? "disabled" : "enabled");
}
function log() {
  if (typeof window === "object") {
    if (logDisabled_) {
      return;
    }
    if (typeof console !== "undefined" && typeof console.log === "function") {
      console.log.apply(console, arguments);
    }
  }
}
function deprecated(oldMethod, newMethod) {
  if (!deprecationWarnings_) {
    return;
  }
  console.warn(oldMethod + " is deprecated, please use " + newMethod + " instead.");
}
function detectBrowser(window2) {
  const result = { browser: null, version: null };
  if (typeof window2 === "undefined" || !window2.navigator) {
    result.browser = "Not a browser.";
    return result;
  }
  const { navigator: navigator2 } = window2;
  if (navigator2.mozGetUserMedia) {
    result.browser = "firefox";
    result.version = extractVersion(navigator2.userAgent, /Firefox\/(\d+)\./, 1);
  } else if (navigator2.webkitGetUserMedia || window2.isSecureContext === false && window2.webkitRTCPeerConnection && !window2.RTCIceGatherer) {
    result.browser = "chrome";
    result.version = extractVersion(navigator2.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
  } else if (window2.RTCPeerConnection && navigator2.userAgent.match(/AppleWebKit\/(\d+)\./)) {
    result.browser = "safari";
    result.version = extractVersion(navigator2.userAgent, /AppleWebKit\/(\d+)\./, 1);
    result.supportsUnifiedPlan = window2.RTCRtpTransceiver && "currentDirection" in window2.RTCRtpTransceiver.prototype;
  } else {
    result.browser = "Not a supported browser.";
    return result;
  }
  return result;
}
function isObject$3(val) {
  return Object.prototype.toString.call(val) === "[object Object]";
}
function compactObject(data2) {
  if (!isObject$3(data2)) {
    return data2;
  }
  return Object.keys(data2).reduce(function(accumulator, key) {
    const isObj = isObject$3(data2[key]);
    const value = isObj ? compactObject(data2[key]) : data2[key];
    const isEmptyObject = isObj && !Object.keys(value).length;
    if (value === void 0 || isEmptyObject) {
      return accumulator;
    }
    return Object.assign(accumulator, { [key]: value });
  }, {});
}
function walkStats(stats2, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach((name2) => {
    if (name2.endsWith("Id")) {
      walkStats(stats2, stats2.get(base[name2]), resultSet);
    } else if (name2.endsWith("Ids")) {
      base[name2].forEach((id2) => {
        walkStats(stats2, stats2.get(id2), resultSet);
      });
    }
  });
}
function filterStats(result, track, outbound) {
  const streamStatsType = outbound ? "outbound-rtp" : "inbound-rtp";
  const filteredResult = /* @__PURE__ */ new Map();
  if (track === null) {
    return filteredResult;
  }
  const trackStats = [];
  result.forEach((value) => {
    if (value.type === "track" && value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach((trackStat) => {
    result.forEach((stats2) => {
      if (stats2.type === streamStatsType && stats2.trackId === trackStat.id) {
        walkStats(result, stats2, filteredResult);
      }
    });
  });
  return filteredResult;
}
const logging = log;
function shimGetUserMedia$2(window2, browserDetails) {
  const navigator2 = window2 && window2.navigator;
  if (!navigator2.mediaDevices) {
    return;
  }
  const constraintsToChrome_ = function(c) {
    if (typeof c !== "object" || c.mandatory || c.optional) {
      return c;
    }
    const cc2 = {};
    Object.keys(c).forEach((key) => {
      if (key === "require" || key === "advanced" || key === "mediaSource") {
        return;
      }
      const r2 = typeof c[key] === "object" ? c[key] : { ideal: c[key] };
      if (r2.exact !== void 0 && typeof r2.exact === "number") {
        r2.min = r2.max = r2.exact;
      }
      const oldname_ = function(prefix, name2) {
        if (prefix) {
          return prefix + name2.charAt(0).toUpperCase() + name2.slice(1);
        }
        return name2 === "deviceId" ? "sourceId" : name2;
      };
      if (r2.ideal !== void 0) {
        cc2.optional = cc2.optional || [];
        let oc2 = {};
        if (typeof r2.ideal === "number") {
          oc2[oldname_("min", key)] = r2.ideal;
          cc2.optional.push(oc2);
          oc2 = {};
          oc2[oldname_("max", key)] = r2.ideal;
          cc2.optional.push(oc2);
        } else {
          oc2[oldname_("", key)] = r2.ideal;
          cc2.optional.push(oc2);
        }
      }
      if (r2.exact !== void 0 && typeof r2.exact !== "number") {
        cc2.mandatory = cc2.mandatory || {};
        cc2.mandatory[oldname_("", key)] = r2.exact;
      } else {
        ["min", "max"].forEach((mix) => {
          if (r2[mix] !== void 0) {
            cc2.mandatory = cc2.mandatory || {};
            cc2.mandatory[oldname_(mix, key)] = r2[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc2.optional = (cc2.optional || []).concat(c.advanced);
    }
    return cc2;
  };
  const shimConstraints_ = function(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === "object") {
      const remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, "autoGainControl", "googAutoGainControl");
      remap(constraints.audio, "noiseSuppression", "googNoiseSuppression");
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === "object") {
      let face = constraints.video.facingMode;
      face = face && (typeof face === "object" ? face : { ideal: face });
      const getSupportedFacingModeLies = browserDetails.version < 66;
      if (face && (face.exact === "user" || face.exact === "environment" || face.ideal === "user" || face.ideal === "environment") && !(navigator2.mediaDevices.getSupportedConstraints && navigator2.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        let matches;
        if (face.exact === "environment" || face.ideal === "environment") {
          matches = ["back", "rear"];
        } else if (face.exact === "user" || face.ideal === "user") {
          matches = ["front"];
        }
        if (matches) {
          return navigator2.mediaDevices.enumerateDevices().then((devices) => {
            devices = devices.filter((d) => d.kind === "videoinput");
            let dev = devices.find((d) => matches.some((match) => d.label.toLowerCase().includes(match)));
            if (!dev && devices.length && matches.includes("back")) {
              dev = devices[devices.length - 1];
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging("chrome: " + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging("chrome: " + JSON.stringify(constraints));
    return func(constraints);
  };
  const shimError_ = function(e2) {
    if (browserDetails.version >= 64) {
      return e2;
    }
    return { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e2.name] || e2.name, message: e2.message, constraint: e2.constraint || e2.constraintName, toString() {
      return this.name + (this.message && ": ") + this.message;
    } };
  };
  const getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, (c) => {
      navigator2.webkitGetUserMedia(c, onSuccess, (e2) => {
        if (onError) {
          onError(shimError_(e2));
        }
      });
    });
  };
  navigator2.getUserMedia = getUserMedia_.bind(navigator2);
  if (navigator2.mediaDevices.getUserMedia) {
    const origGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, (c) => origGetUserMedia(c).then((stream) => {
        if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach((track) => {
            track.stop();
          });
          throw new DOMException("", "NotFoundError");
        }
        return stream;
      }, (e2) => Promise.reject(shimError_(e2))));
    };
  }
}
function shimGetDisplayMedia$1(window2, getSourceId) {
  if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
    return;
  }
  if (!window2.navigator.mediaDevices) {
    return;
  }
  if (typeof getSourceId !== "function") {
    console.error("shimGetDisplayMedia: getSourceId argument is not a function");
    return;
  }
  window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    return getSourceId(constraints).then((sourceId) => {
      const widthSpecified = constraints.video && constraints.video.width;
      const heightSpecified = constraints.video && constraints.video.height;
      const frameRateSpecified = constraints.video && constraints.video.frameRate;
      constraints.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: sourceId, maxFrameRate: frameRateSpecified || 3 } };
      if (widthSpecified) {
        constraints.video.mandatory.maxWidth = widthSpecified;
      }
      if (heightSpecified) {
        constraints.video.mandatory.maxHeight = heightSpecified;
      }
      return window2.navigator.mediaDevices.getUserMedia(constraints);
    });
  };
}
function shimMediaStream(window2) {
  window2.MediaStream = window2.MediaStream || window2.webkitMediaStream;
}
function shimOnTrack$1(window2) {
  if (typeof window2 === "object" && window2.RTCPeerConnection && !("ontrack" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "ontrack", { get() {
      return this._ontrack;
    }, set(f2) {
      if (this._ontrack) {
        this.removeEventListener("track", this._ontrack);
      }
      this.addEventListener("track", this._ontrack = f2);
    }, enumerable: true, configurable: true });
    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      if (!this._ontrackpoly) {
        this._ontrackpoly = (e2) => {
          e2.stream.addEventListener("addtrack", (te2) => {
            let receiver;
            if (window2.RTCPeerConnection.prototype.getReceivers) {
              receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === te2.track.id);
            } else {
              receiver = { track: te2.track };
            }
            const event2 = new Event("track");
            event2.track = te2.track;
            event2.receiver = receiver;
            event2.transceiver = { receiver };
            event2.streams = [e2.stream];
            this.dispatchEvent(event2);
          });
          e2.stream.getTracks().forEach((track) => {
            let receiver;
            if (window2.RTCPeerConnection.prototype.getReceivers) {
              receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === track.id);
            } else {
              receiver = { track };
            }
            const event2 = new Event("track");
            event2.track = track;
            event2.receiver = receiver;
            event2.transceiver = { receiver };
            event2.streams = [e2.stream];
            this.dispatchEvent(event2);
          });
        };
        this.addEventListener("addstream", this._ontrackpoly);
      }
      return origSetRemoteDescription.apply(this, arguments);
    };
  } else {
    wrapPeerConnectionEvent(window2, "track", (e2) => {
      if (!e2.transceiver) {
        Object.defineProperty(e2, "transceiver", { value: { receiver: e2.receiver } });
      }
      return e2;
    });
  }
}
function shimGetSendersWithDtmf(window2) {
  if (typeof window2 === "object" && window2.RTCPeerConnection && !("getSenders" in window2.RTCPeerConnection.prototype) && "createDTMFSender" in window2.RTCPeerConnection.prototype) {
    const shimSenderWithDtmf = function(pc2, track) {
      return { track, get dtmf() {
        if (this._dtmf === void 0) {
          if (track.kind === "audio") {
            this._dtmf = pc2.createDTMFSender(track);
          } else {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }, _pc: pc2 };
    };
    if (!window2.RTCPeerConnection.prototype.getSenders) {
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        this._senders = this._senders || [];
        return this._senders.slice();
      };
      const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
      window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
        let sender = origAddTrack.apply(this, arguments);
        if (!sender) {
          sender = shimSenderWithDtmf(this, track);
          this._senders.push(sender);
        }
        return sender;
      };
      const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
      window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
        origRemoveTrack.apply(this, arguments);
        const idx = this._senders.indexOf(sender);
        if (idx !== -1) {
          this._senders.splice(idx, 1);
        }
      };
    }
    const origAddStream = window2.RTCPeerConnection.prototype.addStream;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._senders = this._senders || [];
      origAddStream.apply(this, [stream]);
      stream.getTracks().forEach((track) => {
        this._senders.push(shimSenderWithDtmf(this, track));
      });
    };
    const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      this._senders = this._senders || [];
      origRemoveStream.apply(this, [stream]);
      stream.getTracks().forEach((track) => {
        const sender = this._senders.find((s) => s.track === track);
        if (sender) {
          this._senders.splice(this._senders.indexOf(sender), 1);
        }
      });
    };
  } else if (typeof window2 === "object" && window2.RTCPeerConnection && "getSenders" in window2.RTCPeerConnection.prototype && "createDTMFSender" in window2.RTCPeerConnection.prototype && window2.RTCRtpSender && !("dtmf" in window2.RTCRtpSender.prototype)) {
    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
    window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach((sender) => sender._pc = this);
      return senders;
    };
    Object.defineProperty(window2.RTCRtpSender.prototype, "dtmf", { get() {
      if (this._dtmf === void 0) {
        if (this.track.kind === "audio") {
          this._dtmf = this._pc.createDTMFSender(this.track);
        } else {
          this._dtmf = null;
        }
      }
      return this._dtmf;
    } });
  }
}
function shimGetStats(window2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  const origGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = function getStats() {
    const [selector, onSucc, onErr] = arguments;
    if (arguments.length > 0 && typeof selector === "function") {
      return origGetStats.apply(this, arguments);
    }
    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== "function")) {
      return origGetStats.apply(this, []);
    }
    const fixChromeStats_ = function(response) {
      const standardReport = {};
      const reports = response.result();
      reports.forEach((report) => {
        const standardStats = { id: report.id, timestamp: report.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[report.type] || report.type };
        report.names().forEach((name2) => {
          standardStats[name2] = report.stat(name2);
        });
        standardReport[standardStats.id] = standardStats;
      });
      return standardReport;
    };
    const makeMapStats = function(stats2) {
      return new Map(Object.keys(stats2).map((key) => [key, stats2[key]]));
    };
    if (arguments.length >= 2) {
      const successCallbackWrapper_ = function(response) {
        onSucc(makeMapStats(fixChromeStats_(response)));
      };
      return origGetStats.apply(this, [successCallbackWrapper_, selector]);
    }
    return new Promise((resolve, reject) => {
      origGetStats.apply(this, [function(response) {
        resolve(makeMapStats(fixChromeStats_(response)));
      }, reject]);
    }).then(onSucc, onErr);
  };
}
function shimSenderReceiverGetStats(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender && window2.RTCRtpReceiver)) {
    return;
  }
  if (!("getStats" in window2.RTCRtpSender.prototype)) {
    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => sender._pc = this);
        return senders;
      };
    }
    const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
        const sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window2.RTCRtpSender.prototype.getStats = function getStats() {
      const sender = this;
      return this._pc.getStats().then((result) => filterStats(result, sender.track, true));
    };
  }
  if (!("getStats" in window2.RTCRtpReceiver.prototype)) {
    const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        const receivers = origGetReceivers.apply(this, []);
        receivers.forEach((receiver) => receiver._pc = this);
        return receivers;
      };
    }
    wrapPeerConnectionEvent(window2, "track", (e2) => {
      e2.receiver._pc = e2.srcElement;
      return e2;
    });
    window2.RTCRtpReceiver.prototype.getStats = function getStats() {
      const receiver = this;
      return this._pc.getStats().then((result) => filterStats(result, receiver.track, false));
    };
  }
  if (!("getStats" in window2.RTCRtpSender.prototype && "getStats" in window2.RTCRtpReceiver.prototype)) {
    return;
  }
  const origGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = function getStats() {
    if (arguments.length > 0 && arguments[0] instanceof window2.MediaStreamTrack) {
      const track = arguments[0];
      let sender;
      let receiver;
      let err;
      this.getSenders().forEach((s) => {
        if (s.track === track) {
          if (sender) {
            err = true;
          } else {
            sender = s;
          }
        }
      });
      this.getReceivers().forEach((r2) => {
        if (r2.track === track) {
          if (receiver) {
            err = true;
          } else {
            receiver = r2;
          }
        }
        return r2.track === track;
      });
      if (err || sender && receiver) {
        return Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError"));
      } else if (sender) {
        return sender.getStats();
      } else if (receiver) {
        return receiver.getStats();
      }
      return Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
    }
    return origGetStats.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrackWithNative(window2) {
  window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    return Object.keys(this._shimmedLocalStreams).map((streamId) => this._shimmedLocalStreams[streamId][0]);
  };
  const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
  window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    if (!stream) {
      return origAddTrack.apply(this, arguments);
    }
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const sender = origAddTrack.apply(this, arguments);
    if (!this._shimmedLocalStreams[stream.id]) {
      this._shimmedLocalStreams[stream.id] = [stream, sender];
    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
      this._shimmedLocalStreams[stream.id].push(sender);
    }
    return sender;
  };
  const origAddStream = window2.RTCPeerConnection.prototype.addStream;
  window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    stream.getTracks().forEach((track) => {
      const alreadyExists = this.getSenders().find((s) => s.track === track);
      if (alreadyExists) {
        throw new DOMException("Track already exists.", "InvalidAccessError");
      }
    });
    const existingSenders = this.getSenders();
    origAddStream.apply(this, arguments);
    const newSenders = this.getSenders().filter((newSender) => existingSenders.indexOf(newSender) === -1);
    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
  };
  const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    delete this._shimmedLocalStreams[stream.id];
    return origRemoveStream.apply(this, arguments);
  };
  const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
  window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    if (sender) {
      Object.keys(this._shimmedLocalStreams).forEach((streamId) => {
        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
        if (idx !== -1) {
          this._shimmedLocalStreams[streamId].splice(idx, 1);
        }
        if (this._shimmedLocalStreams[streamId].length === 1) {
          delete this._shimmedLocalStreams[streamId];
        }
      });
    }
    return origRemoveTrack.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrack(window2, browserDetails) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (window2.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
    return shimAddTrackRemoveTrackWithNative(window2);
  }
  const origGetLocalStreams = window2.RTCPeerConnection.prototype.getLocalStreams;
  window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    const nativeStreams = origGetLocalStreams.apply(this);
    this._reverseStreams = this._reverseStreams || {};
    return nativeStreams.map((stream) => this._reverseStreams[stream.id]);
  };
  const origAddStream = window2.RTCPeerConnection.prototype.addStream;
  window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    stream.getTracks().forEach((track) => {
      const alreadyExists = this.getSenders().find((s) => s.track === track);
      if (alreadyExists) {
        throw new DOMException("Track already exists.", "InvalidAccessError");
      }
    });
    if (!this._reverseStreams[stream.id]) {
      const newStream = new window2.MediaStream(stream.getTracks());
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      stream = newStream;
    }
    origAddStream.apply(this, [stream]);
  };
  const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
    delete this._streams[stream.id];
  };
  window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    if (this.signalingState === "closed") {
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    }
    const streams = [].slice.call(arguments, 1);
    if (streams.length !== 1 || !streams[0].getTracks().find((t2) => t2 === track)) {
      throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
    }
    const alreadyExists = this.getSenders().find((s) => s.track === track);
    if (alreadyExists) {
      throw new DOMException("Track already exists.", "InvalidAccessError");
    }
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    const oldStream = this._streams[stream.id];
    if (oldStream) {
      oldStream.addTrack(track);
      Promise.resolve().then(() => {
        this.dispatchEvent(new Event("negotiationneeded"));
      });
    } else {
      const newStream = new window2.MediaStream([track]);
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      this.addStream(newStream);
    }
    return this.getSenders().find((s) => s.track === track);
  };
  function replaceInternalStreamId(pc2, description2) {
    let sdp2 = description2.sdp;
    Object.keys(pc2._reverseStreams || []).forEach((internalId) => {
      const externalStream = pc2._reverseStreams[internalId];
      const internalStream = pc2._streams[externalStream.id];
      sdp2 = sdp2.replace(new RegExp(internalStream.id, "g"), externalStream.id);
    });
    return new RTCSessionDescription({ type: description2.type, sdp: sdp2 });
  }
  function replaceExternalStreamId(pc2, description2) {
    let sdp2 = description2.sdp;
    Object.keys(pc2._reverseStreams || []).forEach((internalId) => {
      const externalStream = pc2._reverseStreams[internalId];
      const internalStream = pc2._streams[externalStream.id];
      sdp2 = sdp2.replace(new RegExp(externalStream.id, "g"), internalStream.id);
    });
    return new RTCSessionDescription({ type: description2.type, sdp: sdp2 });
  }
  ["createOffer", "createAnswer"].forEach(function(method) {
    const nativeMethod = window2.RTCPeerConnection.prototype[method];
    const methodObj = { [method]() {
      const args = arguments;
      const isLegacyCall = arguments.length && typeof arguments[0] === "function";
      if (isLegacyCall) {
        return nativeMethod.apply(this, [(description2) => {
          const desc = replaceInternalStreamId(this, description2);
          args[0].apply(null, [desc]);
        }, (err) => {
          if (args[1]) {
            args[1].apply(null, err);
          }
        }, arguments[2]]);
      }
      return nativeMethod.apply(this, arguments).then((description2) => replaceInternalStreamId(this, description2));
    } };
    window2.RTCPeerConnection.prototype[method] = methodObj[method];
  });
  const origSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
  window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    if (!arguments.length || !arguments[0].type) {
      return origSetLocalDescription.apply(this, arguments);
    }
    arguments[0] = replaceExternalStreamId(this, arguments[0]);
    return origSetLocalDescription.apply(this, arguments);
  };
  const origLocalDescription = Object.getOwnPropertyDescriptor(window2.RTCPeerConnection.prototype, "localDescription");
  Object.defineProperty(window2.RTCPeerConnection.prototype, "localDescription", { get() {
    const description2 = origLocalDescription.get.apply(this);
    if (description2.type === "") {
      return description2;
    }
    return replaceInternalStreamId(this, description2);
  } });
  window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    if (this.signalingState === "closed") {
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    }
    if (!sender._pc) {
      throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    }
    const isLocal = sender._pc === this;
    if (!isLocal) {
      throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
    }
    this._streams = this._streams || {};
    let stream;
    Object.keys(this._streams).forEach((streamid) => {
      const hasTrack = this._streams[streamid].getTracks().find((track) => sender.track === track);
      if (hasTrack) {
        stream = this._streams[streamid];
      }
    });
    if (stream) {
      if (stream.getTracks().length === 1) {
        this.removeStream(this._reverseStreams[stream.id]);
      } else {
        stream.removeTrack(sender.track);
      }
      this.dispatchEvent(new Event("negotiationneeded"));
    }
  };
}
function shimPeerConnection$1(window2, browserDetails) {
  if (!window2.RTCPeerConnection && window2.webkitRTCPeerConnection) {
    window2.RTCPeerConnection = window2.webkitRTCPeerConnection;
  }
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (browserDetails.version < 53) {
    ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
      const nativeMethod = window2.RTCPeerConnection.prototype[method];
      const methodObj = { [method]() {
        arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      } };
      window2.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }
}
function fixNegotiationNeeded(window2, browserDetails) {
  wrapPeerConnectionEvent(window2, "negotiationneeded", (e2) => {
    const pc2 = e2.target;
    if (browserDetails.version < 72 || pc2.getConfiguration && pc2.getConfiguration().sdpSemantics === "plan-b") {
      if (pc2.signalingState !== "stable") {
        return;
      }
    }
    return e2;
  });
}
var chromeShim = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, shimMediaStream, shimOnTrack: shimOnTrack$1, shimGetSendersWithDtmf, shimGetStats, shimSenderReceiverGetStats, shimAddTrackRemoveTrackWithNative, shimAddTrackRemoveTrack, shimPeerConnection: shimPeerConnection$1, fixNegotiationNeeded, shimGetUserMedia: shimGetUserMedia$2, shimGetDisplayMedia: shimGetDisplayMedia$1 }, Symbol.toStringTag, { value: "Module" }));
function shimGetUserMedia$1(window2, browserDetails) {
  const navigator2 = window2 && window2.navigator;
  const MediaStreamTrack2 = window2 && window2.MediaStreamTrack;
  navigator2.getUserMedia = function(constraints, onSuccess, onError) {
    deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia");
    navigator2.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
  if (!(browserDetails.version > 55 && "autoGainControl" in navigator2.mediaDevices.getSupportedConstraints())) {
    const remap = function(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };
    const nativeGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(c) {
      if (typeof c === "object" && typeof c.audio === "object") {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, "autoGainControl", "mozAutoGainControl");
        remap(c.audio, "noiseSuppression", "mozNoiseSuppression");
      }
      return nativeGetUserMedia(c);
    };
    if (MediaStreamTrack2 && MediaStreamTrack2.prototype.getSettings) {
      const nativeGetSettings = MediaStreamTrack2.prototype.getSettings;
      MediaStreamTrack2.prototype.getSettings = function() {
        const obj = nativeGetSettings.apply(this, arguments);
        remap(obj, "mozAutoGainControl", "autoGainControl");
        remap(obj, "mozNoiseSuppression", "noiseSuppression");
        return obj;
      };
    }
    if (MediaStreamTrack2 && MediaStreamTrack2.prototype.applyConstraints) {
      const nativeApplyConstraints = MediaStreamTrack2.prototype.applyConstraints;
      MediaStreamTrack2.prototype.applyConstraints = function(c) {
        if (this.kind === "audio" && typeof c === "object") {
          c = JSON.parse(JSON.stringify(c));
          remap(c, "autoGainControl", "mozAutoGainControl");
          remap(c, "noiseSuppression", "mozNoiseSuppression");
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
}
function shimGetDisplayMedia(window2, preferredMediaSource) {
  if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
    return;
  }
  if (!window2.navigator.mediaDevices) {
    return;
  }
  window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    if (!(constraints && constraints.video)) {
      const err = new DOMException("getDisplayMedia without video constraints is undefined");
      err.name = "NotFoundError";
      err.code = 8;
      return Promise.reject(err);
    }
    if (constraints.video === true) {
      constraints.video = { mediaSource: preferredMediaSource };
    } else {
      constraints.video.mediaSource = preferredMediaSource;
    }
    return window2.navigator.mediaDevices.getUserMedia(constraints);
  };
}
function shimOnTrack(window2) {
  if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
    Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", { get() {
      return { receiver: this.receiver };
    } });
  }
}
function shimPeerConnection(window2, browserDetails) {
  if (typeof window2 !== "object" || !(window2.RTCPeerConnection || window2.mozRTCPeerConnection)) {
    return;
  }
  if (!window2.RTCPeerConnection && window2.mozRTCPeerConnection) {
    window2.RTCPeerConnection = window2.mozRTCPeerConnection;
  }
  if (browserDetails.version < 53) {
    ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
      const nativeMethod = window2.RTCPeerConnection.prototype[method];
      const methodObj = { [method]() {
        arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      } };
      window2.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }
  const modernStatsTypes = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" };
  const nativeGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = function getStats() {
    const [selector, onSucc, onErr] = arguments;
    return nativeGetStats.apply(this, [selector || null]).then((stats2) => {
      if (browserDetails.version < 53 && !onSucc) {
        try {
          stats2.forEach((stat) => {
            stat.type = modernStatsTypes[stat.type] || stat.type;
          });
        } catch (e2) {
          if (e2.name !== "TypeError") {
            throw e2;
          }
          stats2.forEach((stat, i2) => {
            stats2.set(i2, Object.assign({}, stat, { type: modernStatsTypes[stat.type] || stat.type }));
          });
        }
      }
      return stats2;
    }).then(onSucc, onErr);
  };
}
function shimSenderGetStats(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
    return;
  }
  if (window2.RTCRtpSender && "getStats" in window2.RTCRtpSender.prototype) {
    return;
  }
  const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
  if (origGetSenders) {
    window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach((sender) => sender._pc = this);
      return senders;
    };
  }
  const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
  if (origAddTrack) {
    window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
      const sender = origAddTrack.apply(this, arguments);
      sender._pc = this;
      return sender;
    };
  }
  window2.RTCRtpSender.prototype.getStats = function getStats() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  };
}
function shimReceiverGetStats(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
    return;
  }
  if (window2.RTCRtpSender && "getStats" in window2.RTCRtpReceiver.prototype) {
    return;
  }
  const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
  if (origGetReceivers) {
    window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
      const receivers = origGetReceivers.apply(this, []);
      receivers.forEach((receiver) => receiver._pc = this);
      return receivers;
    };
  }
  wrapPeerConnectionEvent(window2, "track", (e2) => {
    e2.receiver._pc = e2.srcElement;
    return e2;
  });
  window2.RTCRtpReceiver.prototype.getStats = function getStats() {
    return this._pc.getStats(this.track);
  };
}
function shimRemoveStream(window2) {
  if (!window2.RTCPeerConnection || "removeStream" in window2.RTCPeerConnection.prototype) {
    return;
  }
  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    deprecated("removeStream", "removeTrack");
    this.getSenders().forEach((sender) => {
      if (sender.track && stream.getTracks().includes(sender.track)) {
        this.removeTrack(sender);
      }
    });
  };
}
function shimRTCDataChannel(window2) {
  if (window2.DataChannel && !window2.RTCDataChannel) {
    window2.RTCDataChannel = window2.DataChannel;
  }
}
function shimAddTransceiver(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
    return;
  }
  const origAddTransceiver = window2.RTCPeerConnection.prototype.addTransceiver;
  if (origAddTransceiver) {
    window2.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
      this.setParametersPromises = [];
      const initParameters = arguments[1];
      const shouldPerformCheck = initParameters && "sendEncodings" in initParameters;
      if (shouldPerformCheck) {
        initParameters.sendEncodings.forEach((encodingParam) => {
          if ("rid" in encodingParam) {
            const ridRegex = /^[a-z0-9]{0,16}$/i;
            if (!ridRegex.test(encodingParam.rid)) {
              throw new TypeError("Invalid RID value provided.");
            }
          }
          if ("scaleResolutionDownBy" in encodingParam) {
            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1)) {
              throw new RangeError("scale_resolution_down_by must be >= 1.0");
            }
          }
          if ("maxFramerate" in encodingParam) {
            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
              throw new RangeError("max_framerate must be >= 0.0");
            }
          }
        });
      }
      const transceiver = origAddTransceiver.apply(this, arguments);
      if (shouldPerformCheck) {
        const { sender } = transceiver;
        const params = sender.getParameters();
        if (!("encodings" in params) || params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {
          params.encodings = initParameters.sendEncodings;
          sender.sendEncodings = initParameters.sendEncodings;
          this.setParametersPromises.push(sender.setParameters(params).then(() => {
            delete sender.sendEncodings;
          }).catch(() => {
            delete sender.sendEncodings;
          }));
        }
      }
      return transceiver;
    };
  }
}
function shimGetParameters(window2) {
  if (!(typeof window2 === "object" && window2.RTCRtpSender)) {
    return;
  }
  const origGetParameters = window2.RTCRtpSender.prototype.getParameters;
  if (origGetParameters) {
    window2.RTCRtpSender.prototype.getParameters = function getParameters() {
      const params = origGetParameters.apply(this, arguments);
      if (!("encodings" in params)) {
        params.encodings = [].concat(this.sendEncodings || [{}]);
      }
      return params;
    };
  }
}
function shimCreateOffer(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
    return;
  }
  const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
  window2.RTCPeerConnection.prototype.createOffer = function createOffer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(() => {
        return origCreateOffer.apply(this, arguments);
      }).finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateOffer.apply(this, arguments);
  };
}
function shimCreateAnswer(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
    return;
  }
  const origCreateAnswer = window2.RTCPeerConnection.prototype.createAnswer;
  window2.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(() => {
        return origCreateAnswer.apply(this, arguments);
      }).finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateAnswer.apply(this, arguments);
  };
}
var firefoxShim = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, shimOnTrack, shimPeerConnection, shimSenderGetStats, shimReceiverGetStats, shimRemoveStream, shimRTCDataChannel, shimAddTransceiver, shimGetParameters, shimCreateOffer, shimCreateAnswer, shimGetUserMedia: shimGetUserMedia$1, shimGetDisplayMedia }, Symbol.toStringTag, { value: "Module" }));
function shimLocalStreamsAPI(window2) {
  if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  if (!("getLocalStreams" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      return this._localStreams;
    };
  }
  if (!("addStream" in window2.RTCPeerConnection.prototype)) {
    const _addTrack = window2.RTCPeerConnection.prototype.addTrack;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      if (!this._localStreams.includes(stream)) {
        this._localStreams.push(stream);
      }
      stream.getAudioTracks().forEach((track) => _addTrack.call(this, track, stream));
      stream.getVideoTracks().forEach((track) => _addTrack.call(this, track, stream));
    };
    window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, ...streams) {
      if (streams) {
        streams.forEach((stream) => {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (!this._localStreams.includes(stream)) {
            this._localStreams.push(stream);
          }
        });
      }
      return _addTrack.apply(this, arguments);
    };
  }
  if (!("removeStream" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      const index2 = this._localStreams.indexOf(stream);
      if (index2 === -1) {
        return;
      }
      this._localStreams.splice(index2, 1);
      const tracks = stream.getTracks();
      this.getSenders().forEach((sender) => {
        if (tracks.includes(sender.track)) {
          this.removeTrack(sender);
        }
      });
    };
  }
}
function shimRemoteStreamsAPI(window2) {
  if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  if (!("getRemoteStreams" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
      return this._remoteStreams ? this._remoteStreams : [];
    };
  }
  if (!("onaddstream" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "onaddstream", { get() {
      return this._onaddstream;
    }, set(f2) {
      if (this._onaddstream) {
        this.removeEventListener("addstream", this._onaddstream);
        this.removeEventListener("track", this._onaddstreampoly);
      }
      this.addEventListener("addstream", this._onaddstream = f2);
      this.addEventListener("track", this._onaddstreampoly = (e2) => {
        e2.streams.forEach((stream) => {
          if (!this._remoteStreams) {
            this._remoteStreams = [];
          }
          if (this._remoteStreams.includes(stream)) {
            return;
          }
          this._remoteStreams.push(stream);
          const event2 = new Event("addstream");
          event2.stream = stream;
          this.dispatchEvent(event2);
        });
      });
    } });
    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      const pc2 = this;
      if (!this._onaddstreampoly) {
        this.addEventListener("track", this._onaddstreampoly = function(e2) {
          e2.streams.forEach((stream) => {
            if (!pc2._remoteStreams) {
              pc2._remoteStreams = [];
            }
            if (pc2._remoteStreams.indexOf(stream) >= 0) {
              return;
            }
            pc2._remoteStreams.push(stream);
            const event2 = new Event("addstream");
            event2.stream = stream;
            pc2.dispatchEvent(event2);
          });
        });
      }
      return origSetRemoteDescription.apply(pc2, arguments);
    };
  }
}
function shimCallbacksAPI(window2) {
  if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  const prototype = window2.RTCPeerConnection.prototype;
  const origCreateOffer = prototype.createOffer;
  const origCreateAnswer = prototype.createAnswer;
  const setLocalDescription = prototype.setLocalDescription;
  const setRemoteDescription = prototype.setRemoteDescription;
  const addIceCandidate = prototype.addIceCandidate;
  prototype.createOffer = function createOffer(successCallback, failureCallback) {
    const options2 = arguments.length >= 2 ? arguments[2] : arguments[0];
    const promise = origCreateOffer.apply(this, [options2]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
    const options2 = arguments.length >= 2 ? arguments[2] : arguments[0];
    const promise = origCreateAnswer.apply(this, [options2]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  let withCallback = function(description2, successCallback, failureCallback) {
    const promise = setLocalDescription.apply(this, [description2]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setLocalDescription = withCallback;
  withCallback = function(description2, successCallback, failureCallback) {
    const promise = setRemoteDescription.apply(this, [description2]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setRemoteDescription = withCallback;
  withCallback = function(candidate, successCallback, failureCallback) {
    const promise = addIceCandidate.apply(this, [candidate]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.addIceCandidate = withCallback;
}
function shimGetUserMedia(window2) {
  const navigator2 = window2 && window2.navigator;
  if (navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
    const mediaDevices = navigator2.mediaDevices;
    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
    navigator2.mediaDevices.getUserMedia = (constraints) => {
      return _getUserMedia(shimConstraints(constraints));
    };
  }
  if (!navigator2.getUserMedia && navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
    navigator2.getUserMedia = function getUserMedia2(constraints, cb2, errcb) {
      navigator2.mediaDevices.getUserMedia(constraints).then(cb2, errcb);
    }.bind(navigator2);
  }
}
function shimConstraints(constraints) {
  if (constraints && constraints.video !== void 0) {
    return Object.assign({}, constraints, { video: compactObject(constraints.video) });
  }
  return constraints;
}
function shimRTCIceServerUrls(window2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  const OrigPeerConnection = window2.RTCPeerConnection;
  window2.RTCPeerConnection = function RTCPeerConnection2(pcConfig, pcConstraints) {
    if (pcConfig && pcConfig.iceServers) {
      const newIceServers = [];
      for (let i2 = 0; i2 < pcConfig.iceServers.length; i2++) {
        let server = pcConfig.iceServers[i2];
        if (!server.hasOwnProperty("urls") && server.hasOwnProperty("url")) {
          deprecated("RTCIceServer.url", "RTCIceServer.urls");
          server = JSON.parse(JSON.stringify(server));
          server.urls = server.url;
          delete server.url;
          newIceServers.push(server);
        } else {
          newIceServers.push(pcConfig.iceServers[i2]);
        }
      }
      pcConfig.iceServers = newIceServers;
    }
    return new OrigPeerConnection(pcConfig, pcConstraints);
  };
  window2.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
  if ("generateCertificate" in OrigPeerConnection) {
    Object.defineProperty(window2.RTCPeerConnection, "generateCertificate", { get() {
      return OrigPeerConnection.generateCertificate;
    } });
  }
}
function shimTrackEventTransceiver(window2) {
  if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
    Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", { get() {
      return { receiver: this.receiver };
    } });
  }
}
function shimCreateOfferLegacy(window2) {
  const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
  window2.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
    if (offerOptions) {
      if (typeof offerOptions.offerToReceiveAudio !== "undefined") {
        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
      }
      const audioTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "audio");
      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
        if (audioTransceiver.direction === "sendrecv") {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection("sendonly");
          } else {
            audioTransceiver.direction = "sendonly";
          }
        } else if (audioTransceiver.direction === "recvonly") {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection("inactive");
          } else {
            audioTransceiver.direction = "inactive";
          }
        }
      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
        this.addTransceiver("audio", { direction: "recvonly" });
      }
      if (typeof offerOptions.offerToReceiveVideo !== "undefined") {
        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
      }
      const videoTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "video");
      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
        if (videoTransceiver.direction === "sendrecv") {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection("sendonly");
          } else {
            videoTransceiver.direction = "sendonly";
          }
        } else if (videoTransceiver.direction === "recvonly") {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection("inactive");
          } else {
            videoTransceiver.direction = "inactive";
          }
        }
      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
        this.addTransceiver("video", { direction: "recvonly" });
      }
    }
    return origCreateOffer.apply(this, arguments);
  };
}
function shimAudioContext(window2) {
  if (typeof window2 !== "object" || window2.AudioContext) {
    return;
  }
  window2.AudioContext = window2.webkitAudioContext;
}
var safariShim = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, shimLocalStreamsAPI, shimRemoteStreamsAPI, shimCallbacksAPI, shimGetUserMedia, shimConstraints, shimRTCIceServerUrls, shimTrackEventTransceiver, shimCreateOfferLegacy, shimAudioContext }, Symbol.toStringTag, { value: "Module" }));
var sdp$1 = { exports: {} };
(function(module2) {
  const SDPUtils2 = {};
  SDPUtils2.generateIdentifier = function() {
    return Math.random().toString(36).substr(2, 10);
  };
  SDPUtils2.localCName = SDPUtils2.generateIdentifier();
  SDPUtils2.splitLines = function(blob) {
    return blob.trim().split("\n").map((line) => line.trim());
  };
  SDPUtils2.splitSections = function(blob) {
    const parts = blob.split("\nm=");
    return parts.map((part, index2) => (index2 > 0 ? "m=" + part : part).trim() + "\r\n");
  };
  SDPUtils2.getDescription = function(blob) {
    const sections = SDPUtils2.splitSections(blob);
    return sections && sections[0];
  };
  SDPUtils2.getMediaSections = function(blob) {
    const sections = SDPUtils2.splitSections(blob);
    sections.shift();
    return sections;
  };
  SDPUtils2.matchPrefix = function(blob, prefix) {
    return SDPUtils2.splitLines(blob).filter((line) => line.indexOf(prefix) === 0);
  };
  SDPUtils2.parseCandidate = function(line) {
    let parts;
    if (line.indexOf("a=candidate:") === 0) {
      parts = line.substring(12).split(" ");
    } else {
      parts = line.substring(10).split(" ");
    }
    const candidate = { foundation: parts[0], component: { 1: "rtp", 2: "rtcp" }[parts[1]] || parts[1], protocol: parts[2].toLowerCase(), priority: parseInt(parts[3], 10), ip: parts[4], address: parts[4], port: parseInt(parts[5], 10), type: parts[7] };
    for (let i2 = 8; i2 < parts.length; i2 += 2) {
      switch (parts[i2]) {
        case "raddr":
          candidate.relatedAddress = parts[i2 + 1];
          break;
        case "rport":
          candidate.relatedPort = parseInt(parts[i2 + 1], 10);
          break;
        case "tcptype":
          candidate.tcpType = parts[i2 + 1];
          break;
        case "ufrag":
          candidate.ufrag = parts[i2 + 1];
          candidate.usernameFragment = parts[i2 + 1];
          break;
        default:
          if (candidate[parts[i2]] === void 0) {
            candidate[parts[i2]] = parts[i2 + 1];
          }
          break;
      }
    }
    return candidate;
  };
  SDPUtils2.writeCandidate = function(candidate) {
    const sdp2 = [];
    sdp2.push(candidate.foundation);
    const component = candidate.component;
    if (component === "rtp") {
      sdp2.push(1);
    } else if (component === "rtcp") {
      sdp2.push(2);
    } else {
      sdp2.push(component);
    }
    sdp2.push(candidate.protocol.toUpperCase());
    sdp2.push(candidate.priority);
    sdp2.push(candidate.address || candidate.ip);
    sdp2.push(candidate.port);
    const type = candidate.type;
    sdp2.push("typ");
    sdp2.push(type);
    if (type !== "host" && candidate.relatedAddress && candidate.relatedPort) {
      sdp2.push("raddr");
      sdp2.push(candidate.relatedAddress);
      sdp2.push("rport");
      sdp2.push(candidate.relatedPort);
    }
    if (candidate.tcpType && candidate.protocol.toLowerCase() === "tcp") {
      sdp2.push("tcptype");
      sdp2.push(candidate.tcpType);
    }
    if (candidate.usernameFragment || candidate.ufrag) {
      sdp2.push("ufrag");
      sdp2.push(candidate.usernameFragment || candidate.ufrag);
    }
    return "candidate:" + sdp2.join(" ");
  };
  SDPUtils2.parseIceOptions = function(line) {
    return line.substr(14).split(" ");
  };
  SDPUtils2.parseRtpMap = function(line) {
    let parts = line.substr(9).split(" ");
    const parsed2 = { payloadType: parseInt(parts.shift(), 10) };
    parts = parts[0].split("/");
    parsed2.name = parts[0];
    parsed2.clockRate = parseInt(parts[1], 10);
    parsed2.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
    parsed2.numChannels = parsed2.channels;
    return parsed2;
  };
  SDPUtils2.writeRtpMap = function(codec) {
    let pt = codec.payloadType;
    if (codec.preferredPayloadType !== void 0) {
      pt = codec.preferredPayloadType;
    }
    const channels = codec.channels || codec.numChannels || 1;
    return "a=rtpmap:" + pt + " " + codec.name + "/" + codec.clockRate + (channels !== 1 ? "/" + channels : "") + "\r\n";
  };
  SDPUtils2.parseExtmap = function(line) {
    const parts = line.substr(9).split(" ");
    return { id: parseInt(parts[0], 10), direction: parts[0].indexOf("/") > 0 ? parts[0].split("/")[1] : "sendrecv", uri: parts[1] };
  };
  SDPUtils2.writeExtmap = function(headerExtension) {
    return "a=extmap:" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== "sendrecv" ? "/" + headerExtension.direction : "") + " " + headerExtension.uri + "\r\n";
  };
  SDPUtils2.parseFmtp = function(line) {
    const parsed2 = {};
    let kv;
    const parts = line.substr(line.indexOf(" ") + 1).split(";");
    for (let j = 0; j < parts.length; j++) {
      kv = parts[j].trim().split("=");
      parsed2[kv[0].trim()] = kv[1];
    }
    return parsed2;
  };
  SDPUtils2.writeFmtp = function(codec) {
    let line = "";
    let pt = codec.payloadType;
    if (codec.preferredPayloadType !== void 0) {
      pt = codec.preferredPayloadType;
    }
    if (codec.parameters && Object.keys(codec.parameters).length) {
      const params = [];
      Object.keys(codec.parameters).forEach((param) => {
        if (codec.parameters[param] !== void 0) {
          params.push(param + "=" + codec.parameters[param]);
        } else {
          params.push(param);
        }
      });
      line += "a=fmtp:" + pt + " " + params.join(";") + "\r\n";
    }
    return line;
  };
  SDPUtils2.parseRtcpFb = function(line) {
    const parts = line.substr(line.indexOf(" ") + 1).split(" ");
    return { type: parts.shift(), parameter: parts.join(" ") };
  };
  SDPUtils2.writeRtcpFb = function(codec) {
    let lines = "";
    let pt = codec.payloadType;
    if (codec.preferredPayloadType !== void 0) {
      pt = codec.preferredPayloadType;
    }
    if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
      codec.rtcpFeedback.forEach((fb2) => {
        lines += "a=rtcp-fb:" + pt + " " + fb2.type + (fb2.parameter && fb2.parameter.length ? " " + fb2.parameter : "") + "\r\n";
      });
    }
    return lines;
  };
  SDPUtils2.parseSsrcMedia = function(line) {
    const sp = line.indexOf(" ");
    const parts = { ssrc: parseInt(line.substr(7, sp - 7), 10) };
    const colon = line.indexOf(":", sp);
    if (colon > -1) {
      parts.attribute = line.substr(sp + 1, colon - sp - 1);
      parts.value = line.substr(colon + 1);
    } else {
      parts.attribute = line.substr(sp + 1);
    }
    return parts;
  };
  SDPUtils2.parseSsrcGroup = function(line) {
    const parts = line.substr(13).split(" ");
    return { semantics: parts.shift(), ssrcs: parts.map((ssrc) => parseInt(ssrc, 10)) };
  };
  SDPUtils2.getMid = function(mediaSection) {
    const mid = SDPUtils2.matchPrefix(mediaSection, "a=mid:")[0];
    if (mid) {
      return mid.substr(6);
    }
  };
  SDPUtils2.parseFingerprint = function(line) {
    const parts = line.substr(14).split(" ");
    return { algorithm: parts[0].toLowerCase(), value: parts[1].toUpperCase() };
  };
  SDPUtils2.getDtlsParameters = function(mediaSection, sessionpart) {
    const lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=fingerprint:");
    return { role: "auto", fingerprints: lines.map(SDPUtils2.parseFingerprint) };
  };
  SDPUtils2.writeDtlsParameters = function(params, setupType) {
    let sdp2 = "a=setup:" + setupType + "\r\n";
    params.fingerprints.forEach((fp) => {
      sdp2 += "a=fingerprint:" + fp.algorithm + " " + fp.value + "\r\n";
    });
    return sdp2;
  };
  SDPUtils2.parseCryptoLine = function(line) {
    const parts = line.substr(9).split(" ");
    return { tag: parseInt(parts[0], 10), cryptoSuite: parts[1], keyParams: parts[2], sessionParams: parts.slice(3) };
  };
  SDPUtils2.writeCryptoLine = function(parameters) {
    return "a=crypto:" + parameters.tag + " " + parameters.cryptoSuite + " " + (typeof parameters.keyParams === "object" ? SDPUtils2.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? " " + parameters.sessionParams.join(" ") : "") + "\r\n";
  };
  SDPUtils2.parseCryptoKeyParams = function(keyParams) {
    if (keyParams.indexOf("inline:") !== 0) {
      return null;
    }
    const parts = keyParams.substr(7).split("|");
    return { keyMethod: "inline", keySalt: parts[0], lifeTime: parts[1], mkiValue: parts[2] ? parts[2].split(":")[0] : void 0, mkiLength: parts[2] ? parts[2].split(":")[1] : void 0 };
  };
  SDPUtils2.writeCryptoKeyParams = function(keyParams) {
    return keyParams.keyMethod + ":" + keyParams.keySalt + (keyParams.lifeTime ? "|" + keyParams.lifeTime : "") + (keyParams.mkiValue && keyParams.mkiLength ? "|" + keyParams.mkiValue + ":" + keyParams.mkiLength : "");
  };
  SDPUtils2.getCryptoParameters = function(mediaSection, sessionpart) {
    const lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=crypto:");
    return lines.map(SDPUtils2.parseCryptoLine);
  };
  SDPUtils2.getIceParameters = function(mediaSection, sessionpart) {
    const ufrag = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=ice-ufrag:")[0];
    const pwd = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=ice-pwd:")[0];
    if (!(ufrag && pwd)) {
      return null;
    }
    return { usernameFragment: ufrag.substr(12), password: pwd.substr(10) };
  };
  SDPUtils2.writeIceParameters = function(params) {
    let sdp2 = "a=ice-ufrag:" + params.usernameFragment + "\r\na=ice-pwd:" + params.password + "\r\n";
    if (params.iceLite) {
      sdp2 += "a=ice-lite\r\n";
    }
    return sdp2;
  };
  SDPUtils2.parseRtpParameters = function(mediaSection) {
    const description2 = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] };
    const lines = SDPUtils2.splitLines(mediaSection);
    const mline = lines[0].split(" ");
    for (let i2 = 3; i2 < mline.length; i2++) {
      const pt = mline[i2];
      const rtpmapline = SDPUtils2.matchPrefix(mediaSection, "a=rtpmap:" + pt + " ")[0];
      if (rtpmapline) {
        const codec = SDPUtils2.parseRtpMap(rtpmapline);
        const fmtps = SDPUtils2.matchPrefix(mediaSection, "a=fmtp:" + pt + " ");
        codec.parameters = fmtps.length ? SDPUtils2.parseFmtp(fmtps[0]) : {};
        codec.rtcpFeedback = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-fb:" + pt + " ").map(SDPUtils2.parseRtcpFb);
        description2.codecs.push(codec);
        switch (codec.name.toUpperCase()) {
          case "RED":
          case "ULPFEC":
            description2.fecMechanisms.push(codec.name.toUpperCase());
            break;
        }
      }
    }
    SDPUtils2.matchPrefix(mediaSection, "a=extmap:").forEach((line) => {
      description2.headerExtensions.push(SDPUtils2.parseExtmap(line));
    });
    return description2;
  };
  SDPUtils2.writeRtpDescription = function(kind, caps) {
    let sdp2 = "";
    sdp2 += "m=" + kind + " ";
    sdp2 += caps.codecs.length > 0 ? "9" : "0";
    sdp2 += " UDP/TLS/RTP/SAVPF ";
    sdp2 += caps.codecs.map((codec) => {
      if (codec.preferredPayloadType !== void 0) {
        return codec.preferredPayloadType;
      }
      return codec.payloadType;
    }).join(" ") + "\r\n";
    sdp2 += "c=IN IP4 0.0.0.0\r\n";
    sdp2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n";
    caps.codecs.forEach((codec) => {
      sdp2 += SDPUtils2.writeRtpMap(codec);
      sdp2 += SDPUtils2.writeFmtp(codec);
      sdp2 += SDPUtils2.writeRtcpFb(codec);
    });
    let maxptime = 0;
    caps.codecs.forEach((codec) => {
      if (codec.maxptime > maxptime) {
        maxptime = codec.maxptime;
      }
    });
    if (maxptime > 0) {
      sdp2 += "a=maxptime:" + maxptime + "\r\n";
    }
    if (caps.headerExtensions) {
      caps.headerExtensions.forEach((extension) => {
        sdp2 += SDPUtils2.writeExtmap(extension);
      });
    }
    return sdp2;
  };
  SDPUtils2.parseRtpEncodingParameters = function(mediaSection) {
    const encodingParameters = [];
    const description2 = SDPUtils2.parseRtpParameters(mediaSection);
    const hasRed = description2.fecMechanisms.indexOf("RED") !== -1;
    const hasUlpfec = description2.fecMechanisms.indexOf("ULPFEC") !== -1;
    const ssrcs = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((parts) => parts.attribute === "cname");
    const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
    let secondarySsrc;
    const flows = SDPUtils2.matchPrefix(mediaSection, "a=ssrc-group:FID").map((line) => {
      const parts = line.substr(17).split(" ");
      return parts.map((part) => parseInt(part, 10));
    });
    if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
      secondarySsrc = flows[0][1];
    }
    description2.codecs.forEach((codec) => {
      if (codec.name.toUpperCase() === "RTX" && codec.parameters.apt) {
        let encParam = { ssrc: primarySsrc, codecPayloadType: parseInt(codec.parameters.apt, 10) };
        if (primarySsrc && secondarySsrc) {
          encParam.rtx = { ssrc: secondarySsrc };
        }
        encodingParameters.push(encParam);
        if (hasRed) {
          encParam = JSON.parse(JSON.stringify(encParam));
          encParam.fec = { ssrc: primarySsrc, mechanism: hasUlpfec ? "red+ulpfec" : "red" };
          encodingParameters.push(encParam);
        }
      }
    });
    if (encodingParameters.length === 0 && primarySsrc) {
      encodingParameters.push({ ssrc: primarySsrc });
    }
    let bandwidth = SDPUtils2.matchPrefix(mediaSection, "b=");
    if (bandwidth.length) {
      if (bandwidth[0].indexOf("b=TIAS:") === 0) {
        bandwidth = parseInt(bandwidth[0].substr(7), 10);
      } else if (bandwidth[0].indexOf("b=AS:") === 0) {
        bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1e3 * 0.95 - 50 * 40 * 8;
      } else {
        bandwidth = void 0;
      }
      encodingParameters.forEach((params) => {
        params.maxBitrate = bandwidth;
      });
    }
    return encodingParameters;
  };
  SDPUtils2.parseRtcpParameters = function(mediaSection) {
    const rtcpParameters = {};
    const remoteSsrc = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((obj) => obj.attribute === "cname")[0];
    if (remoteSsrc) {
      rtcpParameters.cname = remoteSsrc.value;
      rtcpParameters.ssrc = remoteSsrc.ssrc;
    }
    const rsize = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-rsize");
    rtcpParameters.reducedSize = rsize.length > 0;
    rtcpParameters.compound = rsize.length === 0;
    const mux = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-mux");
    rtcpParameters.mux = mux.length > 0;
    return rtcpParameters;
  };
  SDPUtils2.writeRtcpParameters = function(rtcpParameters) {
    let sdp2 = "";
    if (rtcpParameters.reducedSize) {
      sdp2 += "a=rtcp-rsize\r\n";
    }
    if (rtcpParameters.mux) {
      sdp2 += "a=rtcp-mux\r\n";
    }
    if (rtcpParameters.ssrc !== void 0 && rtcpParameters.cname) {
      sdp2 += "a=ssrc:" + rtcpParameters.ssrc + " cname:" + rtcpParameters.cname + "\r\n";
    }
    return sdp2;
  };
  SDPUtils2.parseMsid = function(mediaSection) {
    let parts;
    const spec = SDPUtils2.matchPrefix(mediaSection, "a=msid:");
    if (spec.length === 1) {
      parts = spec[0].substr(7).split(" ");
      return { stream: parts[0], track: parts[1] };
    }
    const planB = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((msidParts) => msidParts.attribute === "msid");
    if (planB.length > 0) {
      parts = planB[0].value.split(" ");
      return { stream: parts[0], track: parts[1] };
    }
  };
  SDPUtils2.parseSctpDescription = function(mediaSection) {
    const mline = SDPUtils2.parseMLine(mediaSection);
    const maxSizeLine = SDPUtils2.matchPrefix(mediaSection, "a=max-message-size:");
    let maxMessageSize;
    if (maxSizeLine.length > 0) {
      maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
    }
    if (isNaN(maxMessageSize)) {
      maxMessageSize = 65536;
    }
    const sctpPort = SDPUtils2.matchPrefix(mediaSection, "a=sctp-port:");
    if (sctpPort.length > 0) {
      return { port: parseInt(sctpPort[0].substr(12), 10), protocol: mline.fmt, maxMessageSize };
    }
    const sctpMapLines = SDPUtils2.matchPrefix(mediaSection, "a=sctpmap:");
    if (sctpMapLines.length > 0) {
      const parts = sctpMapLines[0].substr(10).split(" ");
      return { port: parseInt(parts[0], 10), protocol: parts[1], maxMessageSize };
    }
  };
  SDPUtils2.writeSctpDescription = function(media, sctp) {
    let output = [];
    if (media.protocol !== "DTLS/SCTP") {
      output = ["m=" + media.kind + " 9 " + media.protocol + " " + sctp.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + sctp.port + "\r\n"];
    } else {
      output = ["m=" + media.kind + " 9 " + media.protocol + " " + sctp.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + sctp.port + " " + sctp.protocol + " 65535\r\n"];
    }
    if (sctp.maxMessageSize !== void 0) {
      output.push("a=max-message-size:" + sctp.maxMessageSize + "\r\n");
    }
    return output.join("");
  };
  SDPUtils2.generateSessionId = function() {
    return Math.random().toString().substr(2, 21);
  };
  SDPUtils2.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
    let sessionId;
    const version2 = sessVer !== void 0 ? sessVer : 2;
    if (sessId) {
      sessionId = sessId;
    } else {
      sessionId = SDPUtils2.generateSessionId();
    }
    const user = sessUser || "thisisadapterortc";
    return "v=0\r\no=" + user + " " + sessionId + " " + version2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
  };
  SDPUtils2.getDirection = function(mediaSection, sessionpart) {
    const lines = SDPUtils2.splitLines(mediaSection);
    for (let i2 = 0; i2 < lines.length; i2++) {
      switch (lines[i2]) {
        case "a=sendrecv":
        case "a=sendonly":
        case "a=recvonly":
        case "a=inactive":
          return lines[i2].substr(2);
      }
    }
    if (sessionpart) {
      return SDPUtils2.getDirection(sessionpart);
    }
    return "sendrecv";
  };
  SDPUtils2.getKind = function(mediaSection) {
    const lines = SDPUtils2.splitLines(mediaSection);
    const mline = lines[0].split(" ");
    return mline[0].substr(2);
  };
  SDPUtils2.isRejected = function(mediaSection) {
    return mediaSection.split(" ", 2)[1] === "0";
  };
  SDPUtils2.parseMLine = function(mediaSection) {
    const lines = SDPUtils2.splitLines(mediaSection);
    const parts = lines[0].substr(2).split(" ");
    return { kind: parts[0], port: parseInt(parts[1], 10), protocol: parts[2], fmt: parts.slice(3).join(" ") };
  };
  SDPUtils2.parseOLine = function(mediaSection) {
    const line = SDPUtils2.matchPrefix(mediaSection, "o=")[0];
    const parts = line.substr(2).split(" ");
    return { username: parts[0], sessionId: parts[1], sessionVersion: parseInt(parts[2], 10), netType: parts[3], addressType: parts[4], address: parts[5] };
  };
  SDPUtils2.isValidSDP = function(blob) {
    if (typeof blob !== "string" || blob.length === 0) {
      return false;
    }
    const lines = SDPUtils2.splitLines(blob);
    for (let i2 = 0; i2 < lines.length; i2++) {
      if (lines[i2].length < 2 || lines[i2].charAt(1) !== "=") {
        return false;
      }
    }
    return true;
  };
  {
    module2.exports = SDPUtils2;
  }
})(sdp$1);
var SDPUtils = sdp$1.exports;
var sdp = /* @__PURE__ */ _mergeNamespaces({ __proto__: null, "default": SDPUtils }, [sdp$1.exports]);
function shimRTCIceCandidate(window2) {
  if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "foundation" in window2.RTCIceCandidate.prototype) {
    return;
  }
  const NativeRTCIceCandidate = window2.RTCIceCandidate;
  window2.RTCIceCandidate = function RTCIceCandidate(args) {
    if (typeof args === "object" && args.candidate && args.candidate.indexOf("a=") === 0) {
      args = JSON.parse(JSON.stringify(args));
      args.candidate = args.candidate.substr(2);
    }
    if (args.candidate && args.candidate.length) {
      const nativeCandidate = new NativeRTCIceCandidate(args);
      const parsedCandidate = SDPUtils.parseCandidate(args.candidate);
      const augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate);
      augmentedCandidate.toJSON = function toJSON() {
        return { candidate: augmentedCandidate.candidate, sdpMid: augmentedCandidate.sdpMid, sdpMLineIndex: augmentedCandidate.sdpMLineIndex, usernameFragment: augmentedCandidate.usernameFragment };
      };
      return augmentedCandidate;
    }
    return new NativeRTCIceCandidate(args);
  };
  window2.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;
  wrapPeerConnectionEvent(window2, "icecandidate", (e2) => {
    if (e2.candidate) {
      Object.defineProperty(e2, "candidate", { value: new window2.RTCIceCandidate(e2.candidate), writable: "false" });
    }
    return e2;
  });
}
function shimMaxMessageSize(window2, browserDetails) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (!("sctp" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "sctp", { get() {
      return typeof this._sctp === "undefined" ? null : this._sctp;
    } });
  }
  const sctpInDescription = function(description2) {
    if (!description2 || !description2.sdp) {
      return false;
    }
    const sections = SDPUtils.splitSections(description2.sdp);
    sections.shift();
    return sections.some((mediaSection) => {
      const mLine = SDPUtils.parseMLine(mediaSection);
      return mLine && mLine.kind === "application" && mLine.protocol.indexOf("SCTP") !== -1;
    });
  };
  const getRemoteFirefoxVersion = function(description2) {
    const match = description2.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (match === null || match.length < 2) {
      return -1;
    }
    const version2 = parseInt(match[1], 10);
    return version2 !== version2 ? -1 : version2;
  };
  const getCanSendMaxMessageSize = function(remoteIsFirefox) {
    let canSendMaxMessageSize = 65536;
    if (browserDetails.browser === "firefox") {
      if (browserDetails.version < 57) {
        if (remoteIsFirefox === -1) {
          canSendMaxMessageSize = 16384;
        } else {
          canSendMaxMessageSize = 2147483637;
        }
      } else if (browserDetails.version < 60) {
        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
      } else {
        canSendMaxMessageSize = 2147483637;
      }
    }
    return canSendMaxMessageSize;
  };
  const getMaxMessageSize = function(description2, remoteIsFirefox) {
    let maxMessageSize = 65536;
    if (browserDetails.browser === "firefox" && browserDetails.version === 57) {
      maxMessageSize = 65535;
    }
    const match = SDPUtils.matchPrefix(description2.sdp, "a=max-message-size:");
    if (match.length > 0) {
      maxMessageSize = parseInt(match[0].substr(19), 10);
    } else if (browserDetails.browser === "firefox" && remoteIsFirefox !== -1) {
      maxMessageSize = 2147483637;
    }
    return maxMessageSize;
  };
  const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
  window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
    this._sctp = null;
    if (browserDetails.browser === "chrome" && browserDetails.version >= 76) {
      const { sdpSemantics } = this.getConfiguration();
      if (sdpSemantics === "plan-b") {
        Object.defineProperty(this, "sctp", { get() {
          return typeof this._sctp === "undefined" ? null : this._sctp;
        }, enumerable: true, configurable: true });
      }
    }
    if (sctpInDescription(arguments[0])) {
      const isFirefox = getRemoteFirefoxVersion(arguments[0]);
      const canSendMMS = getCanSendMaxMessageSize(isFirefox);
      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);
      let maxMessageSize;
      if (canSendMMS === 0 && remoteMMS === 0) {
        maxMessageSize = Number.POSITIVE_INFINITY;
      } else if (canSendMMS === 0 || remoteMMS === 0) {
        maxMessageSize = Math.max(canSendMMS, remoteMMS);
      } else {
        maxMessageSize = Math.min(canSendMMS, remoteMMS);
      }
      const sctp = {};
      Object.defineProperty(sctp, "maxMessageSize", { get() {
        return maxMessageSize;
      } });
      this._sctp = sctp;
    }
    return origSetRemoteDescription.apply(this, arguments);
  };
}
function shimSendThrowTypeError(window2) {
  if (!(window2.RTCPeerConnection && "createDataChannel" in window2.RTCPeerConnection.prototype)) {
    return;
  }
  function wrapDcSend(dc2, pc2) {
    const origDataChannelSend = dc2.send;
    dc2.send = function send() {
      const data2 = arguments[0];
      const length2 = data2.length || data2.size || data2.byteLength;
      if (dc2.readyState === "open" && pc2.sctp && length2 > pc2.sctp.maxMessageSize) {
        throw new TypeError("Message too large (can send a maximum of " + pc2.sctp.maxMessageSize + " bytes)");
      }
      return origDataChannelSend.apply(dc2, arguments);
    };
  }
  const origCreateDataChannel = window2.RTCPeerConnection.prototype.createDataChannel;
  window2.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
    const dataChannel = origCreateDataChannel.apply(this, arguments);
    wrapDcSend(dataChannel, this);
    return dataChannel;
  };
  wrapPeerConnectionEvent(window2, "datachannel", (e2) => {
    wrapDcSend(e2.channel, e2.target);
    return e2;
  });
}
function shimConnectionState(window2) {
  if (!window2.RTCPeerConnection || "connectionState" in window2.RTCPeerConnection.prototype) {
    return;
  }
  const proto = window2.RTCPeerConnection.prototype;
  Object.defineProperty(proto, "connectionState", { get() {
    return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState;
  }, enumerable: true, configurable: true });
  Object.defineProperty(proto, "onconnectionstatechange", { get() {
    return this._onconnectionstatechange || null;
  }, set(cb2) {
    if (this._onconnectionstatechange) {
      this.removeEventListener("connectionstatechange", this._onconnectionstatechange);
      delete this._onconnectionstatechange;
    }
    if (cb2) {
      this.addEventListener("connectionstatechange", this._onconnectionstatechange = cb2);
    }
  }, enumerable: true, configurable: true });
  ["setLocalDescription", "setRemoteDescription"].forEach((method) => {
    const origMethod = proto[method];
    proto[method] = function() {
      if (!this._connectionstatechangepoly) {
        this._connectionstatechangepoly = (e2) => {
          const pc2 = e2.target;
          if (pc2._lastConnectionState !== pc2.connectionState) {
            pc2._lastConnectionState = pc2.connectionState;
            const newEvent = new Event("connectionstatechange", e2);
            pc2.dispatchEvent(newEvent);
          }
          return e2;
        };
        this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly);
      }
      return origMethod.apply(this, arguments);
    };
  });
}
function removeExtmapAllowMixed(window2, browserDetails) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (browserDetails.browser === "chrome" && browserDetails.version >= 71) {
    return;
  }
  if (browserDetails.browser === "safari" && browserDetails.version >= 605) {
    return;
  }
  const nativeSRD = window2.RTCPeerConnection.prototype.setRemoteDescription;
  window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
    if (desc && desc.sdp && desc.sdp.indexOf("\na=extmap-allow-mixed") !== -1) {
      const sdp2 = desc.sdp.split("\n").filter((line) => {
        return line.trim() !== "a=extmap-allow-mixed";
      }).join("\n");
      if (window2.RTCSessionDescription && desc instanceof window2.RTCSessionDescription) {
        arguments[0] = new window2.RTCSessionDescription({ type: desc.type, sdp: sdp2 });
      } else {
        desc.sdp = sdp2;
      }
    }
    return nativeSRD.apply(this, arguments);
  };
}
function shimAddIceCandidateNullOrEmpty(window2, browserDetails) {
  if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeAddIceCandidate = window2.RTCPeerConnection.prototype.addIceCandidate;
  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
    return;
  }
  window2.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
    if (!arguments[0]) {
      if (arguments[1]) {
        arguments[1].apply(null);
      }
      return Promise.resolve();
    }
    if ((browserDetails.browser === "chrome" && browserDetails.version < 78 || browserDetails.browser === "firefox" && browserDetails.version < 68 || browserDetails.browser === "safari") && arguments[0] && arguments[0].candidate === "") {
      return Promise.resolve();
    }
    return nativeAddIceCandidate.apply(this, arguments);
  };
}
function shimParameterlessSetLocalDescription(window2, browserDetails) {
  if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
    return;
  }
  window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    let desc = arguments[0] || {};
    if (typeof desc !== "object" || desc.type && desc.sdp) {
      return nativeSetLocalDescription.apply(this, arguments);
    }
    desc = { type: desc.type, sdp: desc.sdp };
    if (!desc.type) {
      switch (this.signalingState) {
        case "stable":
        case "have-local-offer":
        case "have-remote-pranswer":
          desc.type = "offer";
          break;
        default:
          desc.type = "answer";
          break;
      }
    }
    if (desc.sdp || desc.type !== "offer" && desc.type !== "answer") {
      return nativeSetLocalDescription.apply(this, [desc]);
    }
    const func = desc.type === "offer" ? this.createOffer : this.createAnswer;
    return func.apply(this).then((d) => nativeSetLocalDescription.apply(this, [d]));
  };
}
var commonShim = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, shimRTCIceCandidate, shimMaxMessageSize, shimSendThrowTypeError, shimConnectionState, removeExtmapAllowMixed, shimAddIceCandidateNullOrEmpty, shimParameterlessSetLocalDescription }, Symbol.toStringTag, { value: "Module" }));
function adapterFactory({ window: window2 } = {}, options2 = { shimChrome: true, shimFirefox: true, shimSafari: true }) {
  const logging2 = log;
  const browserDetails = detectBrowser(window2);
  const adapter = { browserDetails, commonShim, extractVersion, disableLog, disableWarnings, sdp };
  switch (browserDetails.browser) {
    case "chrome":
      if (!chromeShim || !shimPeerConnection$1 || !options2.shimChrome) {
        logging2("Chrome shim is not included in this adapter release.");
        return adapter;
      }
      if (browserDetails.version === null) {
        logging2("Chrome shim can not determine version, not shimming.");
        return adapter;
      }
      logging2("adapter.js shimming chrome.");
      adapter.browserShim = chromeShim;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails);
      shimParameterlessSetLocalDescription(window2);
      shimGetUserMedia$2(window2, browserDetails);
      shimMediaStream(window2);
      shimPeerConnection$1(window2, browserDetails);
      shimOnTrack$1(window2);
      shimAddTrackRemoveTrack(window2, browserDetails);
      shimGetSendersWithDtmf(window2);
      shimGetStats(window2);
      shimSenderReceiverGetStats(window2);
      fixNegotiationNeeded(window2, browserDetails);
      shimRTCIceCandidate(window2);
      shimConnectionState(window2);
      shimMaxMessageSize(window2, browserDetails);
      shimSendThrowTypeError(window2);
      removeExtmapAllowMixed(window2, browserDetails);
      break;
    case "firefox":
      if (!firefoxShim || !shimPeerConnection || !options2.shimFirefox) {
        logging2("Firefox shim is not included in this adapter release.");
        return adapter;
      }
      logging2("adapter.js shimming firefox.");
      adapter.browserShim = firefoxShim;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails);
      shimParameterlessSetLocalDescription(window2);
      shimGetUserMedia$1(window2, browserDetails);
      shimPeerConnection(window2, browserDetails);
      shimOnTrack(window2);
      shimRemoveStream(window2);
      shimSenderGetStats(window2);
      shimReceiverGetStats(window2);
      shimRTCDataChannel(window2);
      shimAddTransceiver(window2);
      shimGetParameters(window2);
      shimCreateOffer(window2);
      shimCreateAnswer(window2);
      shimRTCIceCandidate(window2);
      shimConnectionState(window2);
      shimMaxMessageSize(window2, browserDetails);
      shimSendThrowTypeError(window2);
      break;
    case "safari":
      if (!safariShim || !options2.shimSafari) {
        logging2("Safari shim is not included in this adapter release.");
        return adapter;
      }
      logging2("adapter.js shimming safari.");
      adapter.browserShim = safariShim;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails);
      shimParameterlessSetLocalDescription(window2);
      shimRTCIceServerUrls(window2);
      shimCreateOfferLegacy(window2);
      shimCallbacksAPI(window2);
      shimLocalStreamsAPI(window2);
      shimRemoteStreamsAPI(window2);
      shimTrackEventTransceiver(window2);
      shimGetUserMedia(window2);
      shimAudioContext(window2);
      shimRTCIceCandidate(window2);
      shimMaxMessageSize(window2, browserDetails);
      shimSendThrowTypeError(window2);
      removeExtmapAllowMixed(window2, browserDetails);
      break;
    default:
      logging2("Unsupported browser!");
      break;
  }
  return adapter;
}
adapterFactory({ window: typeof window === "undefined" ? void 0 : window });
var __awaiter$3 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(SignalClient$1, "__esModule", { value: true });
SignalClient$1.toProtoSessionDescription = SignalClient$1.SignalClient = void 0;
const logger_1$1 = __importDefault$3(logger);
const livekit_rtc_1 = livekit_rtc;
const errors_1$1 = errors;
const utils_1$1 = utils$f;
class SignalClient {
  constructor(useJSON = false) {
    this.isConnected = false;
    this.useJSON = useJSON;
  }
  join(url2, token, opts) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const res = yield this.connect(url2, token, { autoSubscribe: opts === null || opts === void 0 ? void 0 : opts.autoSubscribe });
      return res;
    });
  }
  reconnect(url2, token) {
    return __awaiter$3(this, void 0, void 0, function* () {
      yield this.connect(url2, token, { reconnect: true });
    });
  }
  connect(url2, token, opts) {
    if (url2.startsWith("http")) {
      url2 = url2.replace("http", "ws");
    }
    url2 = url2.replace(/\/$/, "");
    url2 += "/rtc";
    const clientInfo = utils_1$1.getClientInfo();
    const params = createConnectionParams(token, clientInfo, opts);
    return new Promise((resolve, reject) => {
      logger_1$1.default.debug("connecting to", url2 + params);
      this.ws = void 0;
      const ws2 = new WebSocket(url2 + params);
      ws2.binaryType = "arraybuffer";
      ws2.onerror = (ev) => __awaiter$3(this, void 0, void 0, function* () {
        if (!this.ws) {
          try {
            const resp = yield fetch(`http${url2.substring(2)}/validate${params}`);
            if (!resp.ok) {
              const msg = yield resp.text();
              reject(new errors_1$1.ConnectionError(msg));
            } else {
              reject(new errors_1$1.ConnectionError("Internal error"));
            }
          } catch (e2) {
            reject(new errors_1$1.ConnectionError("server was not reachable"));
          }
          return;
        }
        this.handleWSError(ev);
      });
      ws2.onopen = () => {
        this.ws = ws2;
        if (opts.reconnect) {
          this.isConnected = true;
          resolve();
        }
      };
      ws2.onmessage = (ev) => __awaiter$3(this, void 0, void 0, function* () {
        let msg;
        if (typeof ev.data === "string") {
          const json = JSON.parse(ev.data);
          msg = livekit_rtc_1.SignalResponse.fromJSON(json);
        } else if (ev.data instanceof ArrayBuffer) {
          msg = livekit_rtc_1.SignalResponse.decode(new Uint8Array(ev.data));
        } else {
          logger_1$1.default.error("could not decode websocket message", typeof ev.data);
          return;
        }
        if (!this.isConnected) {
          if (msg.join) {
            this.isConnected = true;
            resolve(msg.join);
          } else {
            reject(new errors_1$1.ConnectionError("did not receive join response"));
          }
          return;
        }
        if (this.signalLatency) {
          yield utils_1$1.sleep(this.signalLatency);
        }
        this.handleSignalResponse(msg);
      });
      ws2.onclose = (ev) => {
        if (!this.isConnected)
          return;
        logger_1$1.default.debug("websocket connection closed", ev.reason);
        this.isConnected = false;
        if (this.onClose)
          this.onClose(ev.reason);
        if (this.ws === ws2) {
          this.ws = void 0;
        }
      };
    });
  }
  close() {
    var _a2;
    this.isConnected = false;
    if (this.ws)
      this.ws.onclose = null;
    (_a2 = this.ws) === null || _a2 === void 0 ? void 0 : _a2.close();
    this.ws = void 0;
  }
  sendOffer(offer) {
    logger_1$1.default.debug("sending offer", offer);
    this.sendRequest({ offer: toProtoSessionDescription(offer) });
  }
  sendAnswer(answer) {
    logger_1$1.default.debug("sending answer");
    this.sendRequest({ answer: toProtoSessionDescription(answer) });
  }
  sendIceCandidate(candidate, target) {
    logger_1$1.default.trace("sending ice candidate", candidate);
    this.sendRequest({ trickle: { candidateInit: JSON.stringify(candidate), target } });
  }
  sendMuteTrack(trackSid, muted) {
    this.sendRequest({ mute: { sid: trackSid, muted } });
  }
  sendAddTrack(req) {
    this.sendRequest({ addTrack: livekit_rtc_1.AddTrackRequest.fromPartial(req) });
  }
  sendUpdateTrackSettings(settings) {
    this.sendRequest({ trackSetting: settings });
  }
  sendUpdateSubscription(sub) {
    this.sendRequest({ subscription: sub });
  }
  sendSyncState(sync) {
    this.sendRequest({ syncState: sync });
  }
  sendUpdateVideoLayers(trackSid, layers) {
    this.sendRequest({ updateLayers: { trackSid, layers } });
  }
  sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {
    this.sendRequest({ subscriptionPermissions: { allParticipants, trackPermissions } });
  }
  sendSimulateScenario(scenario) {
    this.sendRequest({ simulate: scenario });
  }
  sendLeave() {
    this.sendRequest(livekit_rtc_1.SignalRequest.fromPartial({ leave: {} }));
  }
  sendRequest(req) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.signalLatency) {
        yield utils_1$1.sleep(this.signalLatency);
      }
      if (!this.ws) {
        logger_1$1.default.error("cannot send signal request before connected");
        return;
      }
      try {
        if (this.useJSON) {
          this.ws.send(JSON.stringify(livekit_rtc_1.SignalRequest.toJSON(req)));
        } else {
          this.ws.send(livekit_rtc_1.SignalRequest.encode(req).finish());
        }
      } catch (e2) {
        logger_1$1.default.error("error sending signal message", e2);
      }
    });
  }
  handleSignalResponse(msg) {
    if (msg.answer) {
      const sd2 = fromProtoSessionDescription(msg.answer);
      if (this.onAnswer) {
        this.onAnswer(sd2);
      }
    } else if (msg.offer) {
      const sd2 = fromProtoSessionDescription(msg.offer);
      if (this.onOffer) {
        this.onOffer(sd2);
      }
    } else if (msg.trickle) {
      const candidate = JSON.parse(msg.trickle.candidateInit);
      if (this.onTrickle) {
        this.onTrickle(candidate, msg.trickle.target);
      }
    } else if (msg.update) {
      if (this.onParticipantUpdate) {
        this.onParticipantUpdate(msg.update.participants);
      }
    } else if (msg.trackPublished) {
      if (this.onLocalTrackPublished) {
        this.onLocalTrackPublished(msg.trackPublished);
      }
    } else if (msg.speakersChanged) {
      if (this.onSpeakersChanged) {
        this.onSpeakersChanged(msg.speakersChanged.speakers);
      }
    } else if (msg.leave) {
      if (this.onLeave) {
        this.onLeave();
      }
    } else if (msg.mute) {
      if (this.onRemoteMuteChanged) {
        this.onRemoteMuteChanged(msg.mute.sid, msg.mute.muted);
      }
    } else if (msg.roomUpdate) {
      if (this.onRoomUpdate) {
        this.onRoomUpdate(msg.roomUpdate.room);
      }
    } else if (msg.connectionQuality) {
      if (this.onConnectionQuality) {
        this.onConnectionQuality(msg.connectionQuality);
      }
    } else if (msg.streamStateUpdate) {
      if (this.onStreamStateUpdate) {
        this.onStreamStateUpdate(msg.streamStateUpdate);
      }
    } else if (msg.subscribedQualityUpdate) {
      if (this.onSubscribedQualityUpdate) {
        this.onSubscribedQualityUpdate(msg.subscribedQualityUpdate);
      }
    } else if (msg.subscriptionPermissionUpdate) {
      if (this.onSubscriptionPermissionUpdate) {
        this.onSubscriptionPermissionUpdate(msg.subscriptionPermissionUpdate);
      }
    } else {
      logger_1$1.default.debug("unsupported message", msg);
    }
  }
  handleWSError(ev) {
    logger_1$1.default.error("websocket error", ev);
  }
}
SignalClient$1.SignalClient = SignalClient;
function fromProtoSessionDescription(sd2) {
  const rsd = { type: "offer", sdp: sd2.sdp };
  switch (sd2.type) {
    case "answer":
    case "offer":
    case "pranswer":
    case "rollback":
      rsd.type = sd2.type;
      break;
  }
  return rsd;
}
function toProtoSessionDescription(rsd) {
  const sd2 = { sdp: rsd.sdp, type: rsd.type };
  return sd2;
}
SignalClient$1.toProtoSessionDescription = toProtoSessionDescription;
function createConnectionParams(token, info, opts) {
  const params = new URLSearchParams();
  params.set("access_token", token);
  if (opts === null || opts === void 0 ? void 0 : opts.reconnect) {
    params.set("reconnect", "1");
  }
  if ((opts === null || opts === void 0 ? void 0 : opts.autoSubscribe) !== void 0) {
    params.set("auto_subscribe", opts.autoSubscribe ? "1" : "0");
  }
  params.set("sdk", "js");
  params.set("version", info.version);
  params.set("protocol", info.protocol.toString());
  if (info.deviceModel) {
    params.set("device_model", info.deviceModel);
  }
  if (info.os) {
    params.set("os", info.os);
  }
  if (info.osVersion) {
    params.set("os_version", info.osVersion);
  }
  if (info.browser) {
    params.set("browser", info.browser);
  }
  if (info.browserVersion) {
    params.set("browser_version", info.browserVersion);
  }
  return `?${params.toString()}`;
}
var RTCEngine = {};
var PCTransport$1 = {};
var __awaiter$2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(PCTransport$1, "__esModule", { value: true });
const ts_debounce_1 = require$$0$1;
const logger_1 = __importDefault$2(logger);
class PCTransport {
  constructor(config2) {
    this.pendingCandidates = [];
    this.restartingIce = false;
    this.renegotiate = false;
    this.negotiate = ts_debounce_1.debounce(() => {
      this.createAndSendOffer();
    }, 100);
    this.pc = new RTCPeerConnection(config2);
  }
  get isICEConnected() {
    return this.pc.iceConnectionState === "connected" || this.pc.iceConnectionState === "completed";
  }
  addIceCandidate(candidate) {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (this.pc.remoteDescription && !this.restartingIce) {
        return this.pc.addIceCandidate(candidate);
      }
      this.pendingCandidates.push(candidate);
    });
  }
  setRemoteDescription(sd2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.pc.setRemoteDescription(sd2);
      this.pendingCandidates.forEach((candidate) => {
        this.pc.addIceCandidate(candidate);
      });
      this.pendingCandidates = [];
      this.restartingIce = false;
      if (this.renegotiate) {
        this.renegotiate = false;
        this.createAndSendOffer();
      }
    });
  }
  createAndSendOffer(options2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (this.onOffer === void 0) {
        return;
      }
      if (options2 === null || options2 === void 0 ? void 0 : options2.iceRestart) {
        logger_1.default.debug("restarting ICE");
        this.restartingIce = true;
      }
      if (this.pc.signalingState === "have-local-offer") {
        const currentSD = this.pc.remoteDescription;
        if ((options2 === null || options2 === void 0 ? void 0 : options2.iceRestart) && currentSD) {
          yield this.pc.setRemoteDescription(currentSD);
        } else {
          this.renegotiate = true;
          return;
        }
      } else if (this.pc.signalingState === "closed") {
        logger_1.default.warn("could not createOffer with closed peer connection");
        return;
      }
      logger_1.default.debug("starting to negotiate");
      const offer = yield this.pc.createOffer(options2);
      yield this.pc.setLocalDescription(offer);
      this.onOffer(offer);
    });
  }
  close() {
    this.pc.close();
  }
}
PCTransport$1.default = PCTransport;
(function(exports2) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.maxICEConnectTimeout = void 0;
  const events_12 = events.exports;
  const SignalClient_1 = SignalClient$1;
  const logger_12 = __importDefault2(logger);
  const livekit_models_12 = livekit_models$1;
  const livekit_rtc_12 = livekit_rtc;
  const errors_12 = errors;
  const events_2 = events$1;
  const PCTransport_1 = __importDefault2(PCTransport$1);
  const utils_12 = utils$f;
  const lossyDataChannel = "_lossy";
  const reliableDataChannel = "_reliable";
  const maxReconnectRetries = 5;
  exports2.maxICEConnectTimeout = 5 * 1e3;
  class RTCEngine2 extends events_12.EventEmitter {
    constructor() {
      super();
      this.rtcConfig = {};
      this.subscriberPrimary = false;
      this.iceConnected = false;
      this.isClosed = true;
      this.pendingTrackResolvers = {};
      this.hasPublished = false;
      this.reconnectAttempts = 0;
      this.handleDataChannel = ({ channel: channel2 }) => __awaiter2(this, void 0, void 0, function* () {
        if (!channel2) {
          return;
        }
        if (channel2.label === reliableDataChannel) {
          this.reliableDCSub = channel2;
        } else if (channel2.label === lossyDataChannel) {
          this.lossyDCSub = channel2;
        } else {
          return;
        }
        channel2.onmessage = this.handleDataMessage;
      });
      this.handleDataMessage = (message) => __awaiter2(this, void 0, void 0, function* () {
        let buffer2;
        if (message.data instanceof ArrayBuffer) {
          buffer2 = message.data;
        } else if (message.data instanceof Blob) {
          buffer2 = yield message.data.arrayBuffer();
        } else {
          logger_12.default.error("unsupported data type", message.data);
          return;
        }
        const dp = livekit_models_12.DataPacket.decode(new Uint8Array(buffer2));
        if (dp.speaker) {
          this.emit(events_2.EngineEvent.ActiveSpeakersUpdate, dp.speaker.speakers);
        } else if (dp.user) {
          this.emit(events_2.EngineEvent.DataPacketReceived, dp.user, dp.kind);
        }
      });
      this.handleDisconnect = (connection) => {
        if (this.isClosed) {
          return;
        }
        logger_12.default.debug(`${connection} disconnected`);
        if (this.reconnectAttempts >= maxReconnectRetries) {
          logger_12.default.info("could not connect to signal after", maxReconnectRetries, "attempts. giving up");
          this.emit(events_2.EngineEvent.Disconnected);
          this.close();
          return;
        }
        const delay2 = this.reconnectAttempts * this.reconnectAttempts * 300;
        setTimeout(() => {
          this.reconnect().then(() => {
            this.reconnectAttempts = 0;
          }).catch(this.handleDisconnect);
        }, delay2);
      };
      this.client = new SignalClient_1.SignalClient();
    }
    join(url2, token, opts) {
      return __awaiter2(this, void 0, void 0, function* () {
        this.url = url2;
        this.token = token;
        const joinResponse = yield this.client.join(url2, token, opts);
        this.emit(events_2.EngineEvent.SignalConnected);
        this.isClosed = false;
        this.subscriberPrimary = joinResponse.subscriberPrimary;
        if (!this.publisher) {
          this.configure(joinResponse);
        }
        if (!this.subscriberPrimary) {
          this.negotiate();
        }
        return joinResponse;
      });
    }
    close() {
      this.isClosed = true;
      this.removeAllListeners();
      if (this.publisher && this.publisher.pc.signalingState !== "closed") {
        this.publisher.pc.getSenders().forEach((sender) => {
          var _a2;
          try {
            (_a2 = this.publisher) === null || _a2 === void 0 ? void 0 : _a2.pc.removeTrack(sender);
          } catch (e2) {
            logger_12.default.warn("could not removeTrack", e2);
          }
        });
        this.publisher.close();
        this.publisher = void 0;
      }
      if (this.subscriber) {
        this.subscriber.close();
        this.subscriber = void 0;
      }
      this.client.close();
    }
    addTrack(req) {
      if (this.pendingTrackResolvers[req.cid]) {
        throw new errors_12.TrackInvalidError("a track with the same ID has already been published");
      }
      return new Promise((resolve) => {
        this.pendingTrackResolvers[req.cid] = resolve;
        this.client.sendAddTrack(req);
      });
    }
    updateMuteStatus(trackSid, muted) {
      this.client.sendMuteTrack(trackSid, muted);
    }
    get dataSubscriberReadyState() {
      var _a2;
      return (_a2 = this.reliableDCSub) === null || _a2 === void 0 ? void 0 : _a2.readyState;
    }
    get connectedServerAddress() {
      return this.connectedServerAddr;
    }
    configure(joinResponse) {
      if (this.publisher || this.subscriber) {
        return;
      }
      if (joinResponse.iceServers && !this.rtcConfig.iceServers) {
        const rtcIceServers = [];
        joinResponse.iceServers.forEach((iceServer) => {
          const rtcIceServer = { urls: iceServer.urls };
          if (iceServer.username)
            rtcIceServer.username = iceServer.username;
          if (iceServer.credential) {
            rtcIceServer.credential = iceServer.credential;
          }
          rtcIceServers.push(rtcIceServer);
        });
        this.rtcConfig.iceServers = rtcIceServers;
      }
      this.publisher = new PCTransport_1.default(this.rtcConfig);
      this.subscriber = new PCTransport_1.default(this.rtcConfig);
      this.publisher.pc.onicecandidate = (ev) => {
        if (!ev.candidate)
          return;
        logger_12.default.trace("adding ICE candidate for peer", ev.candidate);
        this.client.sendIceCandidate(ev.candidate, livekit_rtc_12.SignalTarget.PUBLISHER);
      };
      this.subscriber.pc.onicecandidate = (ev) => {
        if (!ev.candidate)
          return;
        this.client.sendIceCandidate(ev.candidate, livekit_rtc_12.SignalTarget.SUBSCRIBER);
      };
      this.publisher.onOffer = (offer) => {
        this.client.sendOffer(offer);
      };
      let primaryPC = this.publisher.pc;
      if (joinResponse.subscriberPrimary) {
        primaryPC = this.subscriber.pc;
        this.subscriber.pc.ondatachannel = this.handleDataChannel;
      }
      primaryPC.oniceconnectionstatechange = () => {
        if (primaryPC.iceConnectionState === "connected") {
          logger_12.default.trace("ICE connected");
          if (!this.iceConnected) {
            this.iceConnected = true;
            this.emit(events_2.EngineEvent.Connected);
          }
          getConnectedAddress(primaryPC).then((v2) => {
            this.connectedServerAddr = v2;
          });
        } else if (primaryPC.iceConnectionState === "failed") {
          logger_12.default.trace("ICE disconnected");
          if (this.iceConnected) {
            this.iceConnected = false;
            this.handleDisconnect("peerconnection");
          }
        }
      };
      this.subscriber.pc.ontrack = (ev) => {
        this.emit(events_2.EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);
      };
      this.lossyDC = this.publisher.pc.createDataChannel(lossyDataChannel, { ordered: true, maxRetransmits: 0 });
      this.reliableDC = this.publisher.pc.createDataChannel(reliableDataChannel, { ordered: true });
      this.lossyDC.onmessage = this.handleDataMessage;
      this.reliableDC.onmessage = this.handleDataMessage;
      this.client.onAnswer = (sd2) => __awaiter2(this, void 0, void 0, function* () {
        if (!this.publisher) {
          return;
        }
        logger_12.default.debug("received server answer", sd2.type, this.publisher.pc.signalingState);
        yield this.publisher.setRemoteDescription(sd2);
      });
      this.client.onTrickle = (candidate, target) => {
        if (!this.publisher || !this.subscriber) {
          return;
        }
        logger_12.default.trace("got ICE candidate from peer", candidate, target);
        if (target === livekit_rtc_12.SignalTarget.PUBLISHER) {
          this.publisher.addIceCandidate(candidate);
        } else {
          this.subscriber.addIceCandidate(candidate);
        }
      };
      this.client.onOffer = (sd2) => __awaiter2(this, void 0, void 0, function* () {
        if (!this.subscriber) {
          return;
        }
        logger_12.default.debug("received server offer", sd2.type, this.subscriber.pc.signalingState);
        yield this.subscriber.setRemoteDescription(sd2);
        const answer = yield this.subscriber.pc.createAnswer();
        yield this.subscriber.pc.setLocalDescription(answer);
        this.client.sendAnswer(answer);
      });
      this.client.onLocalTrackPublished = (res) => {
        logger_12.default.debug("received trackPublishedResponse", res);
        const resolve = this.pendingTrackResolvers[res.cid];
        if (!resolve) {
          logger_12.default.error("missing track resolver for ", res.cid);
          return;
        }
        delete this.pendingTrackResolvers[res.cid];
        resolve(res.track);
      };
      this.client.onClose = () => {
        this.handleDisconnect("signal");
      };
      this.client.onLeave = () => {
        this.emit(events_2.EngineEvent.Disconnected);
        this.close();
      };
    }
    reconnect() {
      return __awaiter2(this, void 0, void 0, function* () {
        if (this.isClosed) {
          return;
        }
        if (!this.url || !this.token) {
          throw new errors_12.ConnectionError("could not reconnect, url or token not saved");
        }
        logger_12.default.info("reconnecting to signal connection, attempt", this.reconnectAttempts);
        if (this.reconnectAttempts === 0) {
          this.emit(events_2.EngineEvent.Reconnecting);
        }
        this.reconnectAttempts += 1;
        yield this.client.reconnect(this.url, this.token);
        this.emit(events_2.EngineEvent.SignalConnected);
        if (!this.publisher || !this.subscriber) {
          throw new errors_12.UnexpectedConnectionState("publisher and subscriber connections unset");
        }
        this.subscriber.restartingIce = true;
        if (this.hasPublished) {
          yield this.publisher.createAndSendOffer({ iceRestart: true });
        }
        const startTime = new Date().getTime();
        while (new Date().getTime() - startTime < exports2.maxICEConnectTimeout * 2) {
          if (this.iceConnected) {
            this.emit(events_2.EngineEvent.Reconnected);
            return;
          }
          yield utils_12.sleep(100);
        }
        throw new errors_12.ConnectionError("could not establish ICE connection");
      });
    }
    sendDataPacket(packet, kind) {
      return __awaiter2(this, void 0, void 0, function* () {
        const msg = livekit_models_12.DataPacket.encode(packet).finish();
        yield this.ensurePublisherConnected(kind);
        if (kind === livekit_models_12.DataPacket_Kind.LOSSY && this.lossyDC) {
          this.lossyDC.send(msg);
        } else if (kind === livekit_models_12.DataPacket_Kind.RELIABLE && this.reliableDC) {
          this.reliableDC.send(msg);
        }
      });
    }
    ensurePublisherConnected(kind) {
      var _a2, _b;
      return __awaiter2(this, void 0, void 0, function* () {
        if (!this.subscriberPrimary) {
          return;
        }
        if (!this.publisher) {
          throw new errors_12.ConnectionError("publisher connection not set");
        }
        if (!this.publisher.isICEConnected && this.publisher.pc.iceConnectionState !== "checking") {
          this.negotiate();
        }
        const targetChannel = this.dataChannelForKind(kind);
        if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === "open") {
          return;
        }
        const endTime = new Date().getTime() + exports2.maxICEConnectTimeout;
        while (new Date().getTime() < endTime) {
          if (this.publisher.isICEConnected && ((_a2 = this.dataChannelForKind(kind)) === null || _a2 === void 0 ? void 0 : _a2.readyState) === "open") {
            return;
          }
          yield utils_12.sleep(50);
        }
        throw new errors_12.ConnectionError(`could not establish publisher connection, state ${(_b = this.publisher) === null || _b === void 0 ? void 0 : _b.pc.iceConnectionState}`);
      });
    }
    negotiate() {
      if (!this.publisher) {
        return;
      }
      this.hasPublished = true;
      this.publisher.negotiate();
    }
    dataChannelForKind(kind) {
      if (kind === livekit_models_12.DataPacket_Kind.LOSSY) {
        return this.lossyDC;
      }
      if (kind === livekit_models_12.DataPacket_Kind.RELIABLE) {
        return this.reliableDC;
      }
    }
  }
  exports2.default = RTCEngine2;
  function getConnectedAddress(pc2) {
    var _a2;
    return __awaiter2(this, void 0, void 0, function* () {
      let selectedCandidatePairId = "";
      const candidatePairs = /* @__PURE__ */ new Map();
      const candidates = /* @__PURE__ */ new Map();
      const stats2 = yield pc2.getStats();
      stats2.forEach((v2) => {
        switch (v2.type) {
          case "transport":
            selectedCandidatePairId = v2.selectedCandidatePairId;
            break;
          case "candidate-pair":
            if (selectedCandidatePairId === "" && v2.selected) {
              selectedCandidatePairId = v2.id;
            }
            candidatePairs.set(v2.id, v2);
            break;
          case "remote-candidate":
            candidates.set(v2.id, `${v2.address}:${v2.port}`);
            break;
        }
      });
      if (selectedCandidatePairId === "") {
        return void 0;
      }
      const selectedID = (_a2 = candidatePairs.get(selectedCandidatePairId)) === null || _a2 === void 0 ? void 0 : _a2.remoteCandidateId;
      if (selectedID === void 0) {
        return void 0;
      }
      return candidates.get(selectedID);
    });
  }
})(RTCEngine);
var defaults$4 = {};
Object.defineProperty(defaults$4, "__esModule", { value: true });
defaults$4.videoDefaults = defaults$4.audioDefaults = defaults$4.publishDefaults = void 0;
const options_1$1 = options$1;
defaults$4.publishDefaults = { audioBitrate: options_1$1.AudioPresets.speech.maxBitrate, dtx: true, simulcast: true, screenShareEncoding: options_1$1.ScreenSharePresets.hd_15.encoding, stopMicTrackOnMute: false };
defaults$4.audioDefaults = { autoGainControl: true, channelCount: 1, echoCancellation: true, noiseSuppression: true };
defaults$4.videoDefaults = { resolution: options_1$1.VideoPresets.qhd.resolution };
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m2[k];
    } });
  } : function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.RoomState = void 0;
  const events_12 = events.exports;
  const SignalClient_1 = SignalClient$1;
  const logger_12 = __importDefault2(logger);
  const livekit_models_12 = livekit_models$1;
  const livekit_rtc_12 = livekit_rtc;
  const DeviceManager_12 = __importDefault2(DeviceManager$1);
  const errors_12 = errors;
  const events_2 = events$1;
  const LocalParticipant_1 = __importDefault2(LocalParticipant$1);
  const RemoteParticipant_12 = __importDefault2(RemoteParticipant$1);
  const RTCEngine_1 = __importStar2(RTCEngine);
  const defaults_12 = defaults$4;
  const Track_12 = Track;
  const utils_12 = utils$f;
  var RoomState;
  (function(RoomState2) {
    RoomState2["Disconnected"] = "disconnected";
    RoomState2["Connected"] = "connected";
    RoomState2["Reconnecting"] = "reconnecting";
  })(RoomState = exports2.RoomState || (exports2.RoomState = {}));
  class Room2 extends events_12.EventEmitter {
    constructor(options2) {
      super();
      this.state = RoomState.Disconnected;
      this.activeSpeakers = [];
      this.sid = "";
      this.name = "";
      this.metadata = void 0;
      this.audioEnabled = true;
      this.connect = (url2, token, opts) => __awaiter2(this, void 0, void 0, function* () {
        if (this.state !== RoomState.Disconnected) {
          logger_12.default.warn("already connected to room", this.name);
          return;
        }
        this.createEngine();
        this.acquireAudioContext();
        if (opts === null || opts === void 0 ? void 0 : opts.rtcConfig) {
          this.engine.rtcConfig = opts.rtcConfig;
        }
        this.connOptions = opts;
        try {
          const joinResponse = yield this.engine.join(url2, token, opts);
          logger_12.default.debug("connected to Livekit Server", joinResponse.serverVersion);
          if (!joinResponse.serverVersion) {
            throw new errors_12.UnsupportedServer("unknown server version");
          }
          if (joinResponse.serverVersion === "0.15.1" && this.options.dynacast) {
            logger_12.default.debug("disabling dynacast due to server version");
            this.options.dynacast = false;
          }
          this.state = RoomState.Connected;
          const pi2 = joinResponse.participant;
          this.localParticipant = new LocalParticipant_1.default(pi2.sid, pi2.identity, this.engine, this.options);
          this.localParticipant.updateInfo(pi2);
          this.localParticipant.on(events_2.ParticipantEvent.MetadataChanged, (metadata) => {
            this.emit(events_2.RoomEvent.MetadataChanged, metadata, this.localParticipant);
          }).on(events_2.ParticipantEvent.ParticipantMetadataChanged, (metadata) => {
            this.emit(events_2.RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);
          }).on(events_2.ParticipantEvent.TrackMuted, (pub) => {
            this.emit(events_2.RoomEvent.TrackMuted, pub, this.localParticipant);
          }).on(events_2.ParticipantEvent.TrackUnmuted, (pub) => {
            this.emit(events_2.RoomEvent.TrackUnmuted, pub, this.localParticipant);
          }).on(events_2.ParticipantEvent.LocalTrackPublished, (pub) => {
            this.emit(events_2.RoomEvent.LocalTrackPublished, pub, this.localParticipant);
          }).on(events_2.ParticipantEvent.LocalTrackUnpublished, (pub) => {
            this.emit(events_2.RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);
          }).on(events_2.ParticipantEvent.ConnectionQualityChanged, (quality) => {
            this.emit(events_2.RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);
          }).on(events_2.ParticipantEvent.MediaDevicesError, (e2) => {
            this.emit(events_2.RoomEvent.MediaDevicesError, e2);
          });
          joinResponse.otherParticipants.forEach((info) => {
            this.getOrCreateParticipant(info.sid, info);
          });
          this.name = joinResponse.room.name;
          this.sid = joinResponse.room.sid;
          this.metadata = joinResponse.room.metadata;
        } catch (err) {
          this.engine.close();
          throw err;
        }
        return new Promise((resolve, reject) => {
          const connectTimeout = setTimeout(() => {
            this.engine.close();
            reject(new errors_12.ConnectionError("could not connect after timeout"));
          }, RTCEngine_1.maxICEConnectTimeout);
          this.engine.once(events_2.EngineEvent.Connected, () => {
            clearTimeout(connectTimeout);
            window.addEventListener("beforeunload", this.onBeforeUnload);
            navigator.mediaDevices.addEventListener("devicechange", this.handleDeviceChange);
            resolve(this);
          });
        });
      });
      this.disconnect = (stopTracks = true) => {
        if (this.engine) {
          this.engine.client.sendLeave();
          this.engine.close();
        }
        this.handleDisconnect(stopTracks);
        this.engine = void 0;
      };
      this.onBeforeUnload = () => {
        this.disconnect();
      };
      this.handleParticipantUpdates = (participantInfos) => {
        participantInfos.forEach((info) => {
          if (info.sid === this.localParticipant.sid) {
            this.localParticipant.updateInfo(info);
            return;
          }
          let remoteParticipant = this.participants.get(info.sid);
          const isNewParticipant = !remoteParticipant;
          remoteParticipant = this.getOrCreateParticipant(info.sid, info);
          if (info.state === livekit_models_12.ParticipantInfo_State.DISCONNECTED) {
            this.handleParticipantDisconnected(info.sid, remoteParticipant);
          } else if (isNewParticipant) {
            this.emit(events_2.RoomEvent.ParticipantConnected, remoteParticipant);
          } else {
            remoteParticipant.updateInfo(info);
          }
        });
      };
      this.handleActiveSpeakersUpdate = (speakers) => {
        const activeSpeakers = [];
        const seenSids = {};
        speakers.forEach((speaker) => {
          seenSids[speaker.sid] = true;
          if (speaker.sid === this.localParticipant.sid) {
            this.localParticipant.audioLevel = speaker.level;
            this.localParticipant.setIsSpeaking(true);
            activeSpeakers.push(this.localParticipant);
          } else {
            const p2 = this.participants.get(speaker.sid);
            if (p2) {
              p2.audioLevel = speaker.level;
              p2.setIsSpeaking(true);
              activeSpeakers.push(p2);
            }
          }
        });
        if (!seenSids[this.localParticipant.sid]) {
          this.localParticipant.audioLevel = 0;
          this.localParticipant.setIsSpeaking(false);
        }
        this.participants.forEach((p2) => {
          if (!seenSids[p2.sid]) {
            p2.audioLevel = 0;
            p2.setIsSpeaking(false);
          }
        });
        this.activeSpeakers = activeSpeakers;
        this.emit(events_2.RoomEvent.ActiveSpeakersChanged, activeSpeakers);
      };
      this.handleSpeakersChanged = (speakerUpdates) => {
        const lastSpeakers = /* @__PURE__ */ new Map();
        this.activeSpeakers.forEach((p2) => {
          lastSpeakers.set(p2.sid, p2);
        });
        speakerUpdates.forEach((speaker) => {
          let p2 = this.participants.get(speaker.sid);
          if (speaker.sid === this.localParticipant.sid) {
            p2 = this.localParticipant;
          }
          if (!p2) {
            return;
          }
          p2.audioLevel = speaker.level;
          p2.setIsSpeaking(speaker.active);
          if (speaker.active) {
            lastSpeakers.set(speaker.sid, p2);
          } else {
            lastSpeakers.delete(speaker.sid);
          }
        });
        const activeSpeakers = Array.from(lastSpeakers.values());
        activeSpeakers.sort((a, b) => b.audioLevel - a.audioLevel);
        this.activeSpeakers = activeSpeakers;
        this.emit(events_2.RoomEvent.ActiveSpeakersChanged, activeSpeakers);
      };
      this.handleStreamStateUpdate = (streamStateUpdate) => {
        streamStateUpdate.streamStates.forEach((streamState) => {
          const participant = this.participants.get(streamState.participantSid);
          if (!participant) {
            return;
          }
          const pub = participant.getTrackPublication(streamState.trackSid);
          if (!pub || !pub.track) {
            return;
          }
          pub.track.streamState = Track_12.Track.streamStateFromProto(streamState.state);
          participant.emit(events_2.ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);
          this.emit(events_2.ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);
        });
      };
      this.handleSubscriptionPermissionUpdate = (update) => {
        const participant = this.participants.get(update.participantSid);
        if (!participant) {
          return;
        }
        const pub = participant.getTrackPublication(update.trackSid);
        if (!pub) {
          return;
        }
        pub._allowed = update.allowed;
        participant.emit(events_2.ParticipantEvent.TrackSubscriptionPermissionChanged, pub, pub.subscriptionStatus);
        this.emit(events_2.ParticipantEvent.TrackSubscriptionPermissionChanged, pub, pub.subscriptionStatus, participant);
      };
      this.handleDataPacket = (userPacket, kind) => {
        const participant = this.participants.get(userPacket.participantSid);
        this.emit(events_2.RoomEvent.DataReceived, userPacket.payload, participant, kind);
        participant === null || participant === void 0 ? void 0 : participant.emit(events_2.ParticipantEvent.DataReceived, userPacket.payload, kind);
      };
      this.handleAudioPlaybackStarted = () => {
        if (this.canPlaybackAudio) {
          return;
        }
        this.audioEnabled = true;
        this.emit(events_2.RoomEvent.AudioPlaybackStatusChanged, true);
      };
      this.handleAudioPlaybackFailed = (e2) => {
        logger_12.default.warn("could not playback audio", e2);
        if (!this.canPlaybackAudio) {
          return;
        }
        this.audioEnabled = false;
        this.emit(events_2.RoomEvent.AudioPlaybackStatusChanged, false);
      };
      this.handleDeviceChange = () => __awaiter2(this, void 0, void 0, function* () {
        this.emit(events_2.RoomEvent.MediaDevicesChanged);
      });
      this.handleRoomUpdate = (r2) => {
        this.metadata = r2.metadata;
        this.emit(events_2.RoomEvent.RoomMetadataChanged, r2.metadata);
      };
      this.handleConnectionQualityUpdate = (update) => {
        update.updates.forEach((info) => {
          if (info.participantSid === this.localParticipant.sid) {
            this.localParticipant.setConnectionQuality(info.quality);
            return;
          }
          const participant = this.participants.get(info.participantSid);
          if (participant) {
            participant.setConnectionQuality(info.quality);
          }
        });
      };
      this.participants = /* @__PURE__ */ new Map();
      this.options = options2 || {};
      this.options.audioCaptureDefaults = Object.assign(Object.assign({}, defaults_12.audioDefaults), options2 === null || options2 === void 0 ? void 0 : options2.audioCaptureDefaults);
      this.options.videoCaptureDefaults = Object.assign(Object.assign({}, defaults_12.videoDefaults), options2 === null || options2 === void 0 ? void 0 : options2.videoCaptureDefaults);
      this.options.publishDefaults = Object.assign(Object.assign({}, defaults_12.publishDefaults), options2 === null || options2 === void 0 ? void 0 : options2.publishDefaults);
      this.createEngine();
      this.localParticipant = new LocalParticipant_1.default("", "", this.engine, this.options);
    }
    createEngine() {
      if (this.engine) {
        return;
      }
      this.engine = new RTCEngine_1.default();
      this.engine.client.signalLatency = this.options.expSignalLatency;
      this.engine.on(events_2.EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver) => {
        this.onTrackAdded(mediaTrack, stream, receiver);
      });
      this.engine.on(events_2.EngineEvent.Disconnected, () => {
        this.handleDisconnect();
      });
      this.engine.client.onParticipantUpdate = this.handleParticipantUpdates;
      this.engine.client.onRoomUpdate = this.handleRoomUpdate;
      this.engine.client.onSpeakersChanged = this.handleSpeakersChanged;
      this.engine.client.onStreamStateUpdate = this.handleStreamStateUpdate;
      this.engine.client.onSubscriptionPermissionUpdate = this.handleSubscriptionPermissionUpdate;
      this.engine.on(events_2.EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate);
      this.engine.on(events_2.EngineEvent.DataPacketReceived, this.handleDataPacket);
      this.engine.on(events_2.EngineEvent.Reconnecting, () => {
        this.state = RoomState.Reconnecting;
        this.emit(events_2.RoomEvent.Reconnecting);
      });
      this.engine.on(events_2.EngineEvent.Reconnected, () => {
        this.state = RoomState.Connected;
        this.emit(events_2.RoomEvent.Reconnected);
      });
      this.engine.on(events_2.EngineEvent.SignalConnected, () => {
        if (this.state === RoomState.Reconnecting) {
          this.sendSyncState();
        }
      });
      this.engine.client.onConnectionQuality = this.handleConnectionQualityUpdate;
    }
    static getLocalDevices(kind) {
      return DeviceManager_12.default.getInstance().getDevices(kind);
    }
    getParticipantByIdentity(identity2) {
      for (const [, p2] of this.participants) {
        if (p2.identity === identity2) {
          return p2;
        }
      }
      if (this.localParticipant.identity === identity2) {
        return this.localParticipant;
      }
    }
    simulateScenario(scenario) {
      let req;
      switch (scenario) {
        case "speaker":
          req = livekit_rtc_12.SimulateScenario.fromPartial({ speakerUpdate: 3 });
          break;
        case "node-failure":
          req = livekit_rtc_12.SimulateScenario.fromPartial({ nodeFailure: true });
          break;
        case "server-leave":
          req = livekit_rtc_12.SimulateScenario.fromPartial({ serverLeave: true });
          break;
        case "migration":
          req = livekit_rtc_12.SimulateScenario.fromPartial({ migration: true });
          break;
      }
      if (req) {
        this.engine.client.sendSimulateScenario(req);
      }
    }
    startAudio() {
      return __awaiter2(this, void 0, void 0, function* () {
        this.acquireAudioContext();
        const elements = [];
        this.participants.forEach((p2) => {
          p2.audioTracks.forEach((t2) => {
            if (t2.track) {
              t2.track.attachedElements.forEach((e2) => {
                elements.push(e2);
              });
            }
          });
        });
        try {
          yield Promise.all(elements.map((e2) => e2.play()));
          this.handleAudioPlaybackStarted();
        } catch (err) {
          this.handleAudioPlaybackFailed(err);
          throw err;
        }
      });
    }
    get canPlaybackAudio() {
      return this.audioEnabled;
    }
    switchActiveDevice(kind, deviceId) {
      return __awaiter2(this, void 0, void 0, function* () {
        if (kind === "audioinput") {
          const tracks = Array.from(this.localParticipant.audioTracks.values()).filter((track) => track.source === Track_12.Track.Source.Microphone);
          yield Promise.all(tracks.map((t2) => {
            var _a2;
            return (_a2 = t2.audioTrack) === null || _a2 === void 0 ? void 0 : _a2.setDeviceId(deviceId);
          }));
          this.options.audioCaptureDefaults.deviceId = deviceId;
        } else if (kind === "videoinput") {
          const tracks = Array.from(this.localParticipant.videoTracks.values()).filter((track) => track.source === Track_12.Track.Source.Camera);
          yield Promise.all(tracks.map((t2) => {
            var _a2;
            return (_a2 = t2.videoTrack) === null || _a2 === void 0 ? void 0 : _a2.setDeviceId(deviceId);
          }));
          this.options.videoCaptureDefaults.deviceId = deviceId;
        } else if (kind === "audiooutput") {
          const elements = [];
          this.participants.forEach((p2) => {
            p2.audioTracks.forEach((t2) => {
              if (t2.isSubscribed && t2.track) {
                t2.track.attachedElements.forEach((e2) => {
                  elements.push(e2);
                });
              }
            });
          });
          yield Promise.all(elements.map((e2) => __awaiter2(this, void 0, void 0, function* () {
            if ("setSinkId" in e2) {
              yield e2.setSinkId(deviceId);
            }
          })));
        }
      });
    }
    onTrackAdded(mediaTrack, stream, receiver) {
      const parts = utils_12.unpackStreamId(stream.id);
      const participantId = parts[0];
      let trackId = parts[1];
      if (!trackId || trackId === "")
        trackId = mediaTrack.id;
      const participant = this.getOrCreateParticipant(participantId);
      participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, this.options.adaptiveStream);
    }
    handleDisconnect(shouldStopTracks = true) {
      if (this.state === RoomState.Disconnected) {
        return;
      }
      this.participants.forEach((p2) => {
        p2.tracks.forEach((pub) => {
          p2.unpublishTrack(pub.trackSid);
        });
      });
      this.localParticipant.tracks.forEach((pub) => {
        var _a2, _b;
        if (pub.track) {
          this.localParticipant.unpublishTrack(pub.track);
        }
        if (shouldStopTracks) {
          (_a2 = pub.track) === null || _a2 === void 0 ? void 0 : _a2.detach();
          (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();
        }
      });
      this.participants.clear();
      this.activeSpeakers = [];
      if (this.audioContext) {
        this.audioContext.close();
        this.audioContext = void 0;
      }
      window.removeEventListener("beforeunload", this.onBeforeUnload);
      navigator.mediaDevices.removeEventListener("devicechange", this.handleDeviceChange);
      this.state = RoomState.Disconnected;
      this.emit(events_2.RoomEvent.Disconnected);
    }
    handleParticipantDisconnected(sid, participant) {
      this.participants.delete(sid);
      if (!participant) {
        return;
      }
      participant.tracks.forEach((publication) => {
        participant.unpublishTrack(publication.trackSid);
      });
      this.emit(events_2.RoomEvent.ParticipantDisconnected, participant);
    }
    acquireAudioContext() {
      if (this.audioContext) {
        this.audioContext.close();
      }
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      if (AudioContext) {
        this.audioContext = new AudioContext();
      }
    }
    getOrCreateParticipant(id2, info) {
      let participant = this.participants.get(id2);
      if (!participant) {
        if (info) {
          participant = RemoteParticipant_12.default.fromParticipantInfo(this.engine.client, info);
        } else {
          participant = new RemoteParticipant_12.default(this.engine.client, id2, "");
        }
        this.participants.set(id2, participant);
        participant.on(events_2.ParticipantEvent.TrackPublished, (trackPublication) => {
          this.emit(events_2.RoomEvent.TrackPublished, trackPublication, participant);
        }).on(events_2.ParticipantEvent.TrackSubscribed, (track, publication) => {
          if (track.kind === Track_12.Track.Kind.Audio) {
            track.on(events_2.TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);
            track.on(events_2.TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);
          }
          this.emit(events_2.RoomEvent.TrackSubscribed, track, publication, participant);
        }).on(events_2.ParticipantEvent.TrackUnpublished, (publication) => {
          this.emit(events_2.RoomEvent.TrackUnpublished, publication, participant);
        }).on(events_2.ParticipantEvent.TrackUnsubscribed, (track, publication) => {
          this.emit(events_2.RoomEvent.TrackUnsubscribed, track, publication, participant);
        }).on(events_2.ParticipantEvent.TrackSubscriptionFailed, (sid) => {
          this.emit(events_2.RoomEvent.TrackSubscriptionFailed, sid, participant);
        }).on(events_2.ParticipantEvent.TrackMuted, (pub) => {
          this.emit(events_2.RoomEvent.TrackMuted, pub, participant);
        }).on(events_2.ParticipantEvent.TrackUnmuted, (pub) => {
          this.emit(events_2.RoomEvent.TrackUnmuted, pub, participant);
        }).on(events_2.ParticipantEvent.MetadataChanged, (metadata) => {
          this.emit(events_2.RoomEvent.MetadataChanged, metadata, participant);
        }).on(events_2.ParticipantEvent.ParticipantMetadataChanged, (metadata) => {
          this.emit(events_2.RoomEvent.ParticipantMetadataChanged, metadata, participant);
        }).on(events_2.ParticipantEvent.ConnectionQualityChanged, (quality) => {
          this.emit(events_2.RoomEvent.ConnectionQualityChanged, quality, participant);
        });
      }
      return participant;
    }
    sendSyncState() {
      var _a2;
      if (this.engine.subscriber === void 0 || this.engine.subscriber.pc.localDescription === null) {
        return;
      }
      const previousSdp = this.engine.subscriber.pc.localDescription;
      const sendUnsub = ((_a2 = this.connOptions) === null || _a2 === void 0 ? void 0 : _a2.autoSubscribe) || false;
      const trackSids = new Array();
      this.participants.forEach((participant) => {
        participant.tracks.forEach((track) => {
          if (track.isSubscribed !== sendUnsub) {
            trackSids.push(track.trackSid);
          }
        });
      });
      this.engine.client.sendSyncState({ answer: SignalClient_1.toProtoSessionDescription({ sdp: previousSdp.sdp, type: previousSdp.type }), subscription: { trackSids, subscribe: !sendUnsub, participantTracks: [] }, publishTracks: this.localParticipant.publishedTracksInfo() });
    }
    emit(event2, ...args) {
      logger_12.default.debug("room event", event2, ...args);
      return super.emit(event2, ...args);
    }
  }
  exports2.default = Room2;
})(Room$1);
var connect = {};
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m2[k];
    } });
  } : function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.connect = exports2.version = void 0;
  const logger_12 = __importStar2(logger);
  const errors_12 = errors;
  const events_12 = events$1;
  const Room_1 = __importDefault2(Room$1);
  var version_12 = version$1;
  Object.defineProperty(exports2, "version", { enumerable: true, get: function() {
    return version_12.version;
  } });
  function connect2(url2, token, options2) {
    var _a2, _b, _c, _d;
    return __awaiter2(this, void 0, void 0, function* () {
      options2 !== null && options2 !== void 0 ? options2 : options2 = {};
      if (options2.adaptiveStream === void 0) {
        options2.adaptiveStream = options2.autoManageVideo;
      }
      logger_12.setLogLevel((_a2 = options2.logLevel) !== null && _a2 !== void 0 ? _a2 : logger_12.LogLevel.warn);
      const config2 = (_b = options2.rtcConfig) !== null && _b !== void 0 ? _b : {};
      if (options2.iceServers) {
        config2.iceServers = options2.iceServers;
      }
      const room = new Room_1.default(options2);
      yield room.connect(url2, token, options2);
      const publishAudio = (_c = options2.audio) !== null && _c !== void 0 ? _c : false;
      const publishVideo = (_d = options2.video) !== null && _d !== void 0 ? _d : false;
      if (publishAudio || publishVideo) {
        setTimeout(() => __awaiter2(this, void 0, void 0, function* () {
          let err;
          if (publishAudio && publishVideo) {
            try {
              yield room.localParticipant.enableCameraAndMicrophone();
            } catch (e2) {
              const errKind = errors_12.MediaDeviceFailure.getFailure(e2);
              logger_12.default.warn("received error while creating media", errKind);
              if (e2 instanceof Error) {
                logger_12.default.warn(e2.message);
              }
              if (errKind === errors_12.MediaDeviceFailure.NotFound || errKind === errors_12.MediaDeviceFailure.DeviceInUse) {
                try {
                  yield room.localParticipant.setMicrophoneEnabled(true);
                } catch (audioErr) {
                  err = audioErr;
                }
              } else {
                err = e2;
              }
            }
          } else if (publishAudio) {
            try {
              yield room.localParticipant.setMicrophoneEnabled(true);
            } catch (e2) {
              err = e2;
            }
          } else if (publishVideo) {
            try {
              yield room.localParticipant.setCameraEnabled(true);
            } catch (e2) {
              err = e2;
            }
          }
          if (err) {
            room.emit(events_12.RoomEvent.MediaDevicesError, err);
            logger_12.default.error("could not create media", err);
          }
        }));
      }
      return room;
    });
  }
  exports2.connect = connect2;
})(connect);
var options = {};
Object.defineProperty(options, "__esModule", { value: true });
var create$2 = {};
var __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(create$2, "__esModule", { value: true });
create$2.createLocalScreenTracks = create$2.createLocalAudioTrack = create$2.createLocalVideoTrack = create$2.createLocalTracks = void 0;
const errors_1 = errors;
const publishUtils_1 = publishUtils;
const defaults_1$1 = defaults$4;
const LocalAudioTrack_1 = __importDefault$1(LocalAudioTrack$1);
const LocalVideoTrack_1 = __importDefault$1(LocalVideoTrack$1);
const options_1 = options$1;
const Track_1 = Track;
const utils_1 = utils$e;
function createLocalTracks(options2) {
  var _a2, _b;
  return __awaiter$1(this, void 0, void 0, function* () {
    options2 !== null && options2 !== void 0 ? options2 : options2 = {};
    (_a2 = options2.audio) !== null && _a2 !== void 0 ? _a2 : options2.audio = true;
    (_b = options2.video) !== null && _b !== void 0 ? _b : options2.video = true;
    const opts = utils_1.mergeDefaultOptions(options2, defaults_1$1.audioDefaults, defaults_1$1.videoDefaults);
    const constraints = utils_1.constraintsForOptions(opts);
    const stream = yield navigator.mediaDevices.getUserMedia(constraints);
    return stream.getTracks().map((mediaStreamTrack) => {
      const isAudio = mediaStreamTrack.kind === "audio";
      isAudio ? options2.audio : options2.video;
      let trackConstraints;
      const conOrBool = isAudio ? constraints.audio : constraints.video;
      if (typeof conOrBool !== "boolean") {
        trackConstraints = conOrBool;
      }
      const track = publishUtils_1.mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);
      if (track.kind === Track_1.Track.Kind.Video) {
        track.source = Track_1.Track.Source.Camera;
      } else if (track.kind === Track_1.Track.Kind.Audio) {
        track.source = Track_1.Track.Source.Microphone;
      }
      return track;
    });
  });
}
create$2.createLocalTracks = createLocalTracks;
function createLocalVideoTrack(options2) {
  return __awaiter$1(this, void 0, void 0, function* () {
    const tracks = yield createLocalTracks({ audio: false, video: options2 });
    return tracks[0];
  });
}
create$2.createLocalVideoTrack = createLocalVideoTrack;
function createLocalAudioTrack(options2) {
  return __awaiter$1(this, void 0, void 0, function* () {
    const tracks = yield createLocalTracks({ audio: options2, video: false });
    return tracks[0];
  });
}
create$2.createLocalAudioTrack = createLocalAudioTrack;
function createLocalScreenTracks(options2) {
  var _a2;
  return __awaiter$1(this, void 0, void 0, function* () {
    if (options2 === void 0) {
      options2 = {};
    }
    if (options2.resolution === void 0) {
      options2.resolution = options_1.VideoPresets.fhd.resolution;
    }
    let videoConstraints = true;
    if (options2.resolution) {
      videoConstraints = { width: options2.resolution.width, height: options2.resolution.height };
    }
    const stream = yield navigator.mediaDevices.getDisplayMedia({ audio: (_a2 = options2.audio) !== null && _a2 !== void 0 ? _a2 : false, video: videoConstraints });
    const tracks = stream.getVideoTracks();
    if (tracks.length === 0) {
      throw new errors_1.TrackInvalidError("no video track found");
    }
    const screenVideo = new LocalVideoTrack_1.default(tracks[0]);
    screenVideo.source = Track_1.Track.Source.ScreenShare;
    const localTracks = [screenVideo];
    if (stream.getAudioTracks().length > 0) {
      const screenAudio = new LocalAudioTrack_1.default(stream.getAudioTracks()[0]);
      screenAudio.source = Track_1.Track.Source.ScreenShareAudio;
      localTracks.push(screenAudio);
    }
    return localTracks;
  });
}
create$2.createLocalScreenTracks = createLocalScreenTracks;
var types$1 = {};
Object.defineProperty(types$1, "__esModule", { value: true });
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m2[k];
    } });
  } : function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.VideoQuality = exports2.TrackPublication = exports2.RemoteTrackPublication = exports2.RemoteVideoTrack = exports2.RemoteAudioTrack = exports2.RemoteTrack = exports2.LocalTrackPublication = exports2.LocalTrack = exports2.LocalVideoTrack = exports2.LocalAudioTrack = exports2.LocalParticipant = exports2.RemoteParticipant = exports2.Participant = exports2.ConnectionQuality = exports2.DataPacket_Kind = exports2.RoomState = exports2.Room = exports2.setLogLevel = void 0;
  const logger_12 = logger;
  Object.defineProperty(exports2, "setLogLevel", { enumerable: true, get: function() {
    return logger_12.setLogLevel;
  } });
  const livekit_models_12 = livekit_models$1;
  Object.defineProperty(exports2, "DataPacket_Kind", { enumerable: true, get: function() {
    return livekit_models_12.DataPacket_Kind;
  } });
  Object.defineProperty(exports2, "VideoQuality", { enumerable: true, get: function() {
    return livekit_models_12.VideoQuality;
  } });
  const LocalParticipant_1 = __importDefault2(LocalParticipant$1);
  exports2.LocalParticipant = LocalParticipant_1.default;
  const Participant_12 = __importStar2(Participant$1);
  exports2.Participant = Participant_12.default;
  Object.defineProperty(exports2, "ConnectionQuality", { enumerable: true, get: function() {
    return Participant_12.ConnectionQuality;
  } });
  const RemoteParticipant_12 = __importDefault2(RemoteParticipant$1);
  exports2.RemoteParticipant = RemoteParticipant_12.default;
  const Room_1 = __importStar2(Room$1);
  exports2.Room = Room_1.default;
  Object.defineProperty(exports2, "RoomState", { enumerable: true, get: function() {
    return Room_1.RoomState;
  } });
  const LocalAudioTrack_12 = __importDefault2(LocalAudioTrack$1);
  exports2.LocalAudioTrack = LocalAudioTrack_12.default;
  const LocalTrack_12 = __importDefault2(LocalTrack$1);
  exports2.LocalTrack = LocalTrack_12.default;
  const LocalTrackPublication_12 = __importDefault2(LocalTrackPublication$1);
  exports2.LocalTrackPublication = LocalTrackPublication_12.default;
  const LocalVideoTrack_12 = __importDefault2(LocalVideoTrack$1);
  exports2.LocalVideoTrack = LocalVideoTrack_12.default;
  const RemoteAudioTrack_12 = __importDefault2(RemoteAudioTrack$1);
  exports2.RemoteAudioTrack = RemoteAudioTrack_12.default;
  const RemoteTrack_12 = __importDefault2(RemoteTrack$1);
  exports2.RemoteTrack = RemoteTrack_12.default;
  const RemoteTrackPublication_12 = __importDefault2(RemoteTrackPublication$1);
  exports2.RemoteTrackPublication = RemoteTrackPublication_12.default;
  const RemoteVideoTrack_12 = __importDefault2(RemoteVideoTrack$1);
  exports2.RemoteVideoTrack = RemoteVideoTrack_12.default;
  const TrackPublication_12 = TrackPublication;
  Object.defineProperty(exports2, "TrackPublication", { enumerable: true, get: function() {
    return TrackPublication_12.TrackPublication;
  } });
  __exportStar(connect, exports2);
  __exportStar(options, exports2);
  __exportStar(errors, exports2);
  __exportStar(events$1, exports2);
  __exportStar(create$2, exports2);
  __exportStar(options$1, exports2);
  __exportStar(Track, exports2);
  __exportStar(types$1, exports2);
  __exportStar(version$1, exports2);
})(dist$1);
var dist = {};
var grants = {};
Object.defineProperty(grants, "__esModule", { value: true });
var livekit_models = {};
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ParticipantTracks = exports2.UserPacket = exports2.SpeakerInfo = exports2.ActiveSpeakerUpdate = exports2.DataPacket = exports2.VideoLayer = exports2.TrackInfo = exports2.ParticipantInfo = exports2.Codec = exports2.Room = exports2.dataPacket_KindToJSON = exports2.dataPacket_KindFromJSON = exports2.DataPacket_Kind = exports2.participantInfo_StateToJSON = exports2.participantInfo_StateFromJSON = exports2.ParticipantInfo_State = exports2.connectionQualityToJSON = exports2.connectionQualityFromJSON = exports2.ConnectionQuality = exports2.videoQualityToJSON = exports2.videoQualityFromJSON = exports2.VideoQuality = exports2.trackSourceToJSON = exports2.trackSourceFromJSON = exports2.TrackSource = exports2.trackTypeToJSON = exports2.trackTypeFromJSON = exports2.TrackType = exports2.protobufPackage = void 0;
  const long_12 = __importDefault2(umd.exports);
  const minimal_1 = __importDefault2(minimal);
  exports2.protobufPackage = "livekit";
  var TrackType;
  (function(TrackType2) {
    TrackType2[TrackType2["AUDIO"] = 0] = "AUDIO";
    TrackType2[TrackType2["VIDEO"] = 1] = "VIDEO";
    TrackType2[TrackType2["DATA"] = 2] = "DATA";
    TrackType2[TrackType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(TrackType = exports2.TrackType || (exports2.TrackType = {}));
  function trackTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "AUDIO":
        return TrackType.AUDIO;
      case 1:
      case "VIDEO":
        return TrackType.VIDEO;
      case 2:
      case "DATA":
        return TrackType.DATA;
      case -1:
      case "UNRECOGNIZED":
      default:
        return TrackType.UNRECOGNIZED;
    }
  }
  exports2.trackTypeFromJSON = trackTypeFromJSON;
  function trackTypeToJSON(object) {
    switch (object) {
      case TrackType.AUDIO:
        return "AUDIO";
      case TrackType.VIDEO:
        return "VIDEO";
      case TrackType.DATA:
        return "DATA";
      default:
        return "UNKNOWN";
    }
  }
  exports2.trackTypeToJSON = trackTypeToJSON;
  var TrackSource;
  (function(TrackSource2) {
    TrackSource2[TrackSource2["UNKNOWN"] = 0] = "UNKNOWN";
    TrackSource2[TrackSource2["CAMERA"] = 1] = "CAMERA";
    TrackSource2[TrackSource2["MICROPHONE"] = 2] = "MICROPHONE";
    TrackSource2[TrackSource2["SCREEN_SHARE"] = 3] = "SCREEN_SHARE";
    TrackSource2[TrackSource2["SCREEN_SHARE_AUDIO"] = 4] = "SCREEN_SHARE_AUDIO";
    TrackSource2[TrackSource2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(TrackSource = exports2.TrackSource || (exports2.TrackSource = {}));
  function trackSourceFromJSON(object) {
    switch (object) {
      case 0:
      case "UNKNOWN":
        return TrackSource.UNKNOWN;
      case 1:
      case "CAMERA":
        return TrackSource.CAMERA;
      case 2:
      case "MICROPHONE":
        return TrackSource.MICROPHONE;
      case 3:
      case "SCREEN_SHARE":
        return TrackSource.SCREEN_SHARE;
      case 4:
      case "SCREEN_SHARE_AUDIO":
        return TrackSource.SCREEN_SHARE_AUDIO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return TrackSource.UNRECOGNIZED;
    }
  }
  exports2.trackSourceFromJSON = trackSourceFromJSON;
  function trackSourceToJSON(object) {
    switch (object) {
      case TrackSource.UNKNOWN:
        return "UNKNOWN";
      case TrackSource.CAMERA:
        return "CAMERA";
      case TrackSource.MICROPHONE:
        return "MICROPHONE";
      case TrackSource.SCREEN_SHARE:
        return "SCREEN_SHARE";
      case TrackSource.SCREEN_SHARE_AUDIO:
        return "SCREEN_SHARE_AUDIO";
      default:
        return "UNKNOWN";
    }
  }
  exports2.trackSourceToJSON = trackSourceToJSON;
  var VideoQuality;
  (function(VideoQuality2) {
    VideoQuality2[VideoQuality2["LOW"] = 0] = "LOW";
    VideoQuality2[VideoQuality2["MEDIUM"] = 1] = "MEDIUM";
    VideoQuality2[VideoQuality2["HIGH"] = 2] = "HIGH";
    VideoQuality2[VideoQuality2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(VideoQuality = exports2.VideoQuality || (exports2.VideoQuality = {}));
  function videoQualityFromJSON(object) {
    switch (object) {
      case 0:
      case "LOW":
        return VideoQuality.LOW;
      case 1:
      case "MEDIUM":
        return VideoQuality.MEDIUM;
      case 2:
      case "HIGH":
        return VideoQuality.HIGH;
      case -1:
      case "UNRECOGNIZED":
      default:
        return VideoQuality.UNRECOGNIZED;
    }
  }
  exports2.videoQualityFromJSON = videoQualityFromJSON;
  function videoQualityToJSON(object) {
    switch (object) {
      case VideoQuality.LOW:
        return "LOW";
      case VideoQuality.MEDIUM:
        return "MEDIUM";
      case VideoQuality.HIGH:
        return "HIGH";
      default:
        return "UNKNOWN";
    }
  }
  exports2.videoQualityToJSON = videoQualityToJSON;
  var ConnectionQuality;
  (function(ConnectionQuality2) {
    ConnectionQuality2[ConnectionQuality2["POOR"] = 0] = "POOR";
    ConnectionQuality2[ConnectionQuality2["GOOD"] = 1] = "GOOD";
    ConnectionQuality2[ConnectionQuality2["EXCELLENT"] = 2] = "EXCELLENT";
    ConnectionQuality2[ConnectionQuality2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(ConnectionQuality = exports2.ConnectionQuality || (exports2.ConnectionQuality = {}));
  function connectionQualityFromJSON(object) {
    switch (object) {
      case 0:
      case "POOR":
        return ConnectionQuality.POOR;
      case 1:
      case "GOOD":
        return ConnectionQuality.GOOD;
      case 2:
      case "EXCELLENT":
        return ConnectionQuality.EXCELLENT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ConnectionQuality.UNRECOGNIZED;
    }
  }
  exports2.connectionQualityFromJSON = connectionQualityFromJSON;
  function connectionQualityToJSON(object) {
    switch (object) {
      case ConnectionQuality.POOR:
        return "POOR";
      case ConnectionQuality.GOOD:
        return "GOOD";
      case ConnectionQuality.EXCELLENT:
        return "EXCELLENT";
      default:
        return "UNKNOWN";
    }
  }
  exports2.connectionQualityToJSON = connectionQualityToJSON;
  var ParticipantInfo_State;
  (function(ParticipantInfo_State2) {
    ParticipantInfo_State2[ParticipantInfo_State2["JOINING"] = 0] = "JOINING";
    ParticipantInfo_State2[ParticipantInfo_State2["JOINED"] = 1] = "JOINED";
    ParticipantInfo_State2[ParticipantInfo_State2["ACTIVE"] = 2] = "ACTIVE";
    ParticipantInfo_State2[ParticipantInfo_State2["DISCONNECTED"] = 3] = "DISCONNECTED";
    ParticipantInfo_State2[ParticipantInfo_State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(ParticipantInfo_State = exports2.ParticipantInfo_State || (exports2.ParticipantInfo_State = {}));
  function participantInfo_StateFromJSON(object) {
    switch (object) {
      case 0:
      case "JOINING":
        return ParticipantInfo_State.JOINING;
      case 1:
      case "JOINED":
        return ParticipantInfo_State.JOINED;
      case 2:
      case "ACTIVE":
        return ParticipantInfo_State.ACTIVE;
      case 3:
      case "DISCONNECTED":
        return ParticipantInfo_State.DISCONNECTED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ParticipantInfo_State.UNRECOGNIZED;
    }
  }
  exports2.participantInfo_StateFromJSON = participantInfo_StateFromJSON;
  function participantInfo_StateToJSON(object) {
    switch (object) {
      case ParticipantInfo_State.JOINING:
        return "JOINING";
      case ParticipantInfo_State.JOINED:
        return "JOINED";
      case ParticipantInfo_State.ACTIVE:
        return "ACTIVE";
      case ParticipantInfo_State.DISCONNECTED:
        return "DISCONNECTED";
      default:
        return "UNKNOWN";
    }
  }
  exports2.participantInfo_StateToJSON = participantInfo_StateToJSON;
  var DataPacket_Kind;
  (function(DataPacket_Kind2) {
    DataPacket_Kind2[DataPacket_Kind2["RELIABLE"] = 0] = "RELIABLE";
    DataPacket_Kind2[DataPacket_Kind2["LOSSY"] = 1] = "LOSSY";
    DataPacket_Kind2[DataPacket_Kind2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(DataPacket_Kind = exports2.DataPacket_Kind || (exports2.DataPacket_Kind = {}));
  function dataPacket_KindFromJSON(object) {
    switch (object) {
      case 0:
      case "RELIABLE":
        return DataPacket_Kind.RELIABLE;
      case 1:
      case "LOSSY":
        return DataPacket_Kind.LOSSY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return DataPacket_Kind.UNRECOGNIZED;
    }
  }
  exports2.dataPacket_KindFromJSON = dataPacket_KindFromJSON;
  function dataPacket_KindToJSON(object) {
    switch (object) {
      case DataPacket_Kind.RELIABLE:
        return "RELIABLE";
      case DataPacket_Kind.LOSSY:
        return "LOSSY";
      default:
        return "UNKNOWN";
    }
  }
  exports2.dataPacket_KindToJSON = dataPacket_KindToJSON;
  const baseRoom = { sid: "", name: "", emptyTimeout: 0, maxParticipants: 0, creationTime: 0, turnPassword: "", metadata: "", numParticipants: 0, activeRecording: false };
  exports2.Room = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.sid !== "") {
      writer2.uint32(10).string(message.sid);
    }
    if (message.name !== "") {
      writer2.uint32(18).string(message.name);
    }
    if (message.emptyTimeout !== 0) {
      writer2.uint32(24).uint32(message.emptyTimeout);
    }
    if (message.maxParticipants !== 0) {
      writer2.uint32(32).uint32(message.maxParticipants);
    }
    if (message.creationTime !== 0) {
      writer2.uint32(40).int64(message.creationTime);
    }
    if (message.turnPassword !== "") {
      writer2.uint32(50).string(message.turnPassword);
    }
    for (const v2 of message.enabledCodecs) {
      exports2.Codec.encode(v2, writer2.uint32(58).fork()).ldelim();
    }
    if (message.metadata !== "") {
      writer2.uint32(66).string(message.metadata);
    }
    if (message.numParticipants !== 0) {
      writer2.uint32(72).uint32(message.numParticipants);
    }
    if (message.activeRecording === true) {
      writer2.uint32(80).bool(message.activeRecording);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseRoom);
    message.enabledCodecs = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sid = reader2.string();
          break;
        case 2:
          message.name = reader2.string();
          break;
        case 3:
          message.emptyTimeout = reader2.uint32();
          break;
        case 4:
          message.maxParticipants = reader2.uint32();
          break;
        case 5:
          message.creationTime = longToNumber2(reader2.int64());
          break;
        case 6:
          message.turnPassword = reader2.string();
          break;
        case 7:
          message.enabledCodecs.push(exports2.Codec.decode(reader2, reader2.uint32()));
          break;
        case 8:
          message.metadata = reader2.string();
          break;
        case 9:
          message.numParticipants = reader2.uint32();
          break;
        case 10:
          message.activeRecording = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseRoom);
    message.enabledCodecs = [];
    if (object.sid !== void 0 && object.sid !== null) {
      message.sid = String(object.sid);
    } else {
      message.sid = "";
    }
    if (object.name !== void 0 && object.name !== null) {
      message.name = String(object.name);
    } else {
      message.name = "";
    }
    if (object.emptyTimeout !== void 0 && object.emptyTimeout !== null) {
      message.emptyTimeout = Number(object.emptyTimeout);
    } else {
      message.emptyTimeout = 0;
    }
    if (object.maxParticipants !== void 0 && object.maxParticipants !== null) {
      message.maxParticipants = Number(object.maxParticipants);
    } else {
      message.maxParticipants = 0;
    }
    if (object.creationTime !== void 0 && object.creationTime !== null) {
      message.creationTime = Number(object.creationTime);
    } else {
      message.creationTime = 0;
    }
    if (object.turnPassword !== void 0 && object.turnPassword !== null) {
      message.turnPassword = String(object.turnPassword);
    } else {
      message.turnPassword = "";
    }
    if (object.enabledCodecs !== void 0 && object.enabledCodecs !== null) {
      for (const e2 of object.enabledCodecs) {
        message.enabledCodecs.push(exports2.Codec.fromJSON(e2));
      }
    }
    if (object.metadata !== void 0 && object.metadata !== null) {
      message.metadata = String(object.metadata);
    } else {
      message.metadata = "";
    }
    if (object.numParticipants !== void 0 && object.numParticipants !== null) {
      message.numParticipants = Number(object.numParticipants);
    } else {
      message.numParticipants = 0;
    }
    if (object.activeRecording !== void 0 && object.activeRecording !== null) {
      message.activeRecording = Boolean(object.activeRecording);
    } else {
      message.activeRecording = false;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.sid !== void 0 && (obj.sid = message.sid);
    message.name !== void 0 && (obj.name = message.name);
    message.emptyTimeout !== void 0 && (obj.emptyTimeout = message.emptyTimeout);
    message.maxParticipants !== void 0 && (obj.maxParticipants = message.maxParticipants);
    message.creationTime !== void 0 && (obj.creationTime = message.creationTime);
    message.turnPassword !== void 0 && (obj.turnPassword = message.turnPassword);
    if (message.enabledCodecs) {
      obj.enabledCodecs = message.enabledCodecs.map((e2) => e2 ? exports2.Codec.toJSON(e2) : void 0);
    } else {
      obj.enabledCodecs = [];
    }
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.numParticipants !== void 0 && (obj.numParticipants = message.numParticipants);
    message.activeRecording !== void 0 && (obj.activeRecording = message.activeRecording);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseRoom);
    message.enabledCodecs = [];
    if (object.sid !== void 0 && object.sid !== null) {
      message.sid = object.sid;
    } else {
      message.sid = "";
    }
    if (object.name !== void 0 && object.name !== null) {
      message.name = object.name;
    } else {
      message.name = "";
    }
    if (object.emptyTimeout !== void 0 && object.emptyTimeout !== null) {
      message.emptyTimeout = object.emptyTimeout;
    } else {
      message.emptyTimeout = 0;
    }
    if (object.maxParticipants !== void 0 && object.maxParticipants !== null) {
      message.maxParticipants = object.maxParticipants;
    } else {
      message.maxParticipants = 0;
    }
    if (object.creationTime !== void 0 && object.creationTime !== null) {
      message.creationTime = object.creationTime;
    } else {
      message.creationTime = 0;
    }
    if (object.turnPassword !== void 0 && object.turnPassword !== null) {
      message.turnPassword = object.turnPassword;
    } else {
      message.turnPassword = "";
    }
    if (object.enabledCodecs !== void 0 && object.enabledCodecs !== null) {
      for (const e2 of object.enabledCodecs) {
        message.enabledCodecs.push(exports2.Codec.fromPartial(e2));
      }
    }
    if (object.metadata !== void 0 && object.metadata !== null) {
      message.metadata = object.metadata;
    } else {
      message.metadata = "";
    }
    if (object.numParticipants !== void 0 && object.numParticipants !== null) {
      message.numParticipants = object.numParticipants;
    } else {
      message.numParticipants = 0;
    }
    if (object.activeRecording !== void 0 && object.activeRecording !== null) {
      message.activeRecording = object.activeRecording;
    } else {
      message.activeRecording = false;
    }
    return message;
  } };
  const baseCodec = { mime: "", fmtpLine: "" };
  exports2.Codec = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.mime !== "") {
      writer2.uint32(10).string(message.mime);
    }
    if (message.fmtpLine !== "") {
      writer2.uint32(18).string(message.fmtpLine);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseCodec);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mime = reader2.string();
          break;
        case 2:
          message.fmtpLine = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseCodec);
    if (object.mime !== void 0 && object.mime !== null) {
      message.mime = String(object.mime);
    } else {
      message.mime = "";
    }
    if (object.fmtpLine !== void 0 && object.fmtpLine !== null) {
      message.fmtpLine = String(object.fmtpLine);
    } else {
      message.fmtpLine = "";
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.mime !== void 0 && (obj.mime = message.mime);
    message.fmtpLine !== void 0 && (obj.fmtpLine = message.fmtpLine);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseCodec);
    if (object.mime !== void 0 && object.mime !== null) {
      message.mime = object.mime;
    } else {
      message.mime = "";
    }
    if (object.fmtpLine !== void 0 && object.fmtpLine !== null) {
      message.fmtpLine = object.fmtpLine;
    } else {
      message.fmtpLine = "";
    }
    return message;
  } };
  const baseParticipantInfo = { sid: "", identity: "", state: 0, metadata: "", joinedAt: 0, hidden: false, recorder: false, name: "" };
  exports2.ParticipantInfo = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.sid !== "") {
      writer2.uint32(10).string(message.sid);
    }
    if (message.identity !== "") {
      writer2.uint32(18).string(message.identity);
    }
    if (message.state !== 0) {
      writer2.uint32(24).int32(message.state);
    }
    for (const v2 of message.tracks) {
      exports2.TrackInfo.encode(v2, writer2.uint32(34).fork()).ldelim();
    }
    if (message.metadata !== "") {
      writer2.uint32(42).string(message.metadata);
    }
    if (message.joinedAt !== 0) {
      writer2.uint32(48).int64(message.joinedAt);
    }
    if (message.hidden === true) {
      writer2.uint32(56).bool(message.hidden);
    }
    if (message.recorder === true) {
      writer2.uint32(64).bool(message.recorder);
    }
    if (message.name !== "") {
      writer2.uint32(74).string(message.name);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseParticipantInfo);
    message.tracks = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sid = reader2.string();
          break;
        case 2:
          message.identity = reader2.string();
          break;
        case 3:
          message.state = reader2.int32();
          break;
        case 4:
          message.tracks.push(exports2.TrackInfo.decode(reader2, reader2.uint32()));
          break;
        case 5:
          message.metadata = reader2.string();
          break;
        case 6:
          message.joinedAt = longToNumber2(reader2.int64());
          break;
        case 7:
          message.hidden = reader2.bool();
          break;
        case 8:
          message.recorder = reader2.bool();
          break;
        case 9:
          message.name = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseParticipantInfo);
    message.tracks = [];
    if (object.sid !== void 0 && object.sid !== null) {
      message.sid = String(object.sid);
    } else {
      message.sid = "";
    }
    if (object.identity !== void 0 && object.identity !== null) {
      message.identity = String(object.identity);
    } else {
      message.identity = "";
    }
    if (object.state !== void 0 && object.state !== null) {
      message.state = participantInfo_StateFromJSON(object.state);
    } else {
      message.state = 0;
    }
    if (object.tracks !== void 0 && object.tracks !== null) {
      for (const e2 of object.tracks) {
        message.tracks.push(exports2.TrackInfo.fromJSON(e2));
      }
    }
    if (object.metadata !== void 0 && object.metadata !== null) {
      message.metadata = String(object.metadata);
    } else {
      message.metadata = "";
    }
    if (object.joinedAt !== void 0 && object.joinedAt !== null) {
      message.joinedAt = Number(object.joinedAt);
    } else {
      message.joinedAt = 0;
    }
    if (object.hidden !== void 0 && object.hidden !== null) {
      message.hidden = Boolean(object.hidden);
    } else {
      message.hidden = false;
    }
    if (object.recorder !== void 0 && object.recorder !== null) {
      message.recorder = Boolean(object.recorder);
    } else {
      message.recorder = false;
    }
    if (object.name !== void 0 && object.name !== null) {
      message.name = String(object.name);
    } else {
      message.name = "";
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.sid !== void 0 && (obj.sid = message.sid);
    message.identity !== void 0 && (obj.identity = message.identity);
    message.state !== void 0 && (obj.state = participantInfo_StateToJSON(message.state));
    if (message.tracks) {
      obj.tracks = message.tracks.map((e2) => e2 ? exports2.TrackInfo.toJSON(e2) : void 0);
    } else {
      obj.tracks = [];
    }
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.joinedAt !== void 0 && (obj.joinedAt = message.joinedAt);
    message.hidden !== void 0 && (obj.hidden = message.hidden);
    message.recorder !== void 0 && (obj.recorder = message.recorder);
    message.name !== void 0 && (obj.name = message.name);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseParticipantInfo);
    message.tracks = [];
    if (object.sid !== void 0 && object.sid !== null) {
      message.sid = object.sid;
    } else {
      message.sid = "";
    }
    if (object.identity !== void 0 && object.identity !== null) {
      message.identity = object.identity;
    } else {
      message.identity = "";
    }
    if (object.state !== void 0 && object.state !== null) {
      message.state = object.state;
    } else {
      message.state = 0;
    }
    if (object.tracks !== void 0 && object.tracks !== null) {
      for (const e2 of object.tracks) {
        message.tracks.push(exports2.TrackInfo.fromPartial(e2));
      }
    }
    if (object.metadata !== void 0 && object.metadata !== null) {
      message.metadata = object.metadata;
    } else {
      message.metadata = "";
    }
    if (object.joinedAt !== void 0 && object.joinedAt !== null) {
      message.joinedAt = object.joinedAt;
    } else {
      message.joinedAt = 0;
    }
    if (object.hidden !== void 0 && object.hidden !== null) {
      message.hidden = object.hidden;
    } else {
      message.hidden = false;
    }
    if (object.recorder !== void 0 && object.recorder !== null) {
      message.recorder = object.recorder;
    } else {
      message.recorder = false;
    }
    if (object.name !== void 0 && object.name !== null) {
      message.name = object.name;
    } else {
      message.name = "";
    }
    return message;
  } };
  const baseTrackInfo = { sid: "", type: 0, name: "", muted: false, width: 0, height: 0, simulcast: false, disableDtx: false, source: 0, mimeType: "" };
  exports2.TrackInfo = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.sid !== "") {
      writer2.uint32(10).string(message.sid);
    }
    if (message.type !== 0) {
      writer2.uint32(16).int32(message.type);
    }
    if (message.name !== "") {
      writer2.uint32(26).string(message.name);
    }
    if (message.muted === true) {
      writer2.uint32(32).bool(message.muted);
    }
    if (message.width !== 0) {
      writer2.uint32(40).uint32(message.width);
    }
    if (message.height !== 0) {
      writer2.uint32(48).uint32(message.height);
    }
    if (message.simulcast === true) {
      writer2.uint32(56).bool(message.simulcast);
    }
    if (message.disableDtx === true) {
      writer2.uint32(64).bool(message.disableDtx);
    }
    if (message.source !== 0) {
      writer2.uint32(72).int32(message.source);
    }
    for (const v2 of message.layers) {
      exports2.VideoLayer.encode(v2, writer2.uint32(82).fork()).ldelim();
    }
    if (message.mimeType !== "") {
      writer2.uint32(90).string(message.mimeType);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseTrackInfo);
    message.layers = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sid = reader2.string();
          break;
        case 2:
          message.type = reader2.int32();
          break;
        case 3:
          message.name = reader2.string();
          break;
        case 4:
          message.muted = reader2.bool();
          break;
        case 5:
          message.width = reader2.uint32();
          break;
        case 6:
          message.height = reader2.uint32();
          break;
        case 7:
          message.simulcast = reader2.bool();
          break;
        case 8:
          message.disableDtx = reader2.bool();
          break;
        case 9:
          message.source = reader2.int32();
          break;
        case 10:
          message.layers.push(exports2.VideoLayer.decode(reader2, reader2.uint32()));
          break;
        case 11:
          message.mimeType = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseTrackInfo);
    message.layers = [];
    if (object.sid !== void 0 && object.sid !== null) {
      message.sid = String(object.sid);
    } else {
      message.sid = "";
    }
    if (object.type !== void 0 && object.type !== null) {
      message.type = trackTypeFromJSON(object.type);
    } else {
      message.type = 0;
    }
    if (object.name !== void 0 && object.name !== null) {
      message.name = String(object.name);
    } else {
      message.name = "";
    }
    if (object.muted !== void 0 && object.muted !== null) {
      message.muted = Boolean(object.muted);
    } else {
      message.muted = false;
    }
    if (object.width !== void 0 && object.width !== null) {
      message.width = Number(object.width);
    } else {
      message.width = 0;
    }
    if (object.height !== void 0 && object.height !== null) {
      message.height = Number(object.height);
    } else {
      message.height = 0;
    }
    if (object.simulcast !== void 0 && object.simulcast !== null) {
      message.simulcast = Boolean(object.simulcast);
    } else {
      message.simulcast = false;
    }
    if (object.disableDtx !== void 0 && object.disableDtx !== null) {
      message.disableDtx = Boolean(object.disableDtx);
    } else {
      message.disableDtx = false;
    }
    if (object.source !== void 0 && object.source !== null) {
      message.source = trackSourceFromJSON(object.source);
    } else {
      message.source = 0;
    }
    if (object.layers !== void 0 && object.layers !== null) {
      for (const e2 of object.layers) {
        message.layers.push(exports2.VideoLayer.fromJSON(e2));
      }
    }
    if (object.mimeType !== void 0 && object.mimeType !== null) {
      message.mimeType = String(object.mimeType);
    } else {
      message.mimeType = "";
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.sid !== void 0 && (obj.sid = message.sid);
    message.type !== void 0 && (obj.type = trackTypeToJSON(message.type));
    message.name !== void 0 && (obj.name = message.name);
    message.muted !== void 0 && (obj.muted = message.muted);
    message.width !== void 0 && (obj.width = message.width);
    message.height !== void 0 && (obj.height = message.height);
    message.simulcast !== void 0 && (obj.simulcast = message.simulcast);
    message.disableDtx !== void 0 && (obj.disableDtx = message.disableDtx);
    message.source !== void 0 && (obj.source = trackSourceToJSON(message.source));
    if (message.layers) {
      obj.layers = message.layers.map((e2) => e2 ? exports2.VideoLayer.toJSON(e2) : void 0);
    } else {
      obj.layers = [];
    }
    message.mimeType !== void 0 && (obj.mimeType = message.mimeType);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseTrackInfo);
    message.layers = [];
    if (object.sid !== void 0 && object.sid !== null) {
      message.sid = object.sid;
    } else {
      message.sid = "";
    }
    if (object.type !== void 0 && object.type !== null) {
      message.type = object.type;
    } else {
      message.type = 0;
    }
    if (object.name !== void 0 && object.name !== null) {
      message.name = object.name;
    } else {
      message.name = "";
    }
    if (object.muted !== void 0 && object.muted !== null) {
      message.muted = object.muted;
    } else {
      message.muted = false;
    }
    if (object.width !== void 0 && object.width !== null) {
      message.width = object.width;
    } else {
      message.width = 0;
    }
    if (object.height !== void 0 && object.height !== null) {
      message.height = object.height;
    } else {
      message.height = 0;
    }
    if (object.simulcast !== void 0 && object.simulcast !== null) {
      message.simulcast = object.simulcast;
    } else {
      message.simulcast = false;
    }
    if (object.disableDtx !== void 0 && object.disableDtx !== null) {
      message.disableDtx = object.disableDtx;
    } else {
      message.disableDtx = false;
    }
    if (object.source !== void 0 && object.source !== null) {
      message.source = object.source;
    } else {
      message.source = 0;
    }
    if (object.layers !== void 0 && object.layers !== null) {
      for (const e2 of object.layers) {
        message.layers.push(exports2.VideoLayer.fromPartial(e2));
      }
    }
    if (object.mimeType !== void 0 && object.mimeType !== null) {
      message.mimeType = object.mimeType;
    } else {
      message.mimeType = "";
    }
    return message;
  } };
  const baseVideoLayer = { quality: 0, width: 0, height: 0, bitrate: 0 };
  exports2.VideoLayer = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.quality !== 0) {
      writer2.uint32(8).int32(message.quality);
    }
    if (message.width !== 0) {
      writer2.uint32(16).uint32(message.width);
    }
    if (message.height !== 0) {
      writer2.uint32(24).uint32(message.height);
    }
    if (message.bitrate !== 0) {
      writer2.uint32(32).uint32(message.bitrate);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseVideoLayer);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.quality = reader2.int32();
          break;
        case 2:
          message.width = reader2.uint32();
          break;
        case 3:
          message.height = reader2.uint32();
          break;
        case 4:
          message.bitrate = reader2.uint32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseVideoLayer);
    if (object.quality !== void 0 && object.quality !== null) {
      message.quality = videoQualityFromJSON(object.quality);
    } else {
      message.quality = 0;
    }
    if (object.width !== void 0 && object.width !== null) {
      message.width = Number(object.width);
    } else {
      message.width = 0;
    }
    if (object.height !== void 0 && object.height !== null) {
      message.height = Number(object.height);
    } else {
      message.height = 0;
    }
    if (object.bitrate !== void 0 && object.bitrate !== null) {
      message.bitrate = Number(object.bitrate);
    } else {
      message.bitrate = 0;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.quality !== void 0 && (obj.quality = videoQualityToJSON(message.quality));
    message.width !== void 0 && (obj.width = message.width);
    message.height !== void 0 && (obj.height = message.height);
    message.bitrate !== void 0 && (obj.bitrate = message.bitrate);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseVideoLayer);
    if (object.quality !== void 0 && object.quality !== null) {
      message.quality = object.quality;
    } else {
      message.quality = 0;
    }
    if (object.width !== void 0 && object.width !== null) {
      message.width = object.width;
    } else {
      message.width = 0;
    }
    if (object.height !== void 0 && object.height !== null) {
      message.height = object.height;
    } else {
      message.height = 0;
    }
    if (object.bitrate !== void 0 && object.bitrate !== null) {
      message.bitrate = object.bitrate;
    } else {
      message.bitrate = 0;
    }
    return message;
  } };
  const baseDataPacket = { kind: 0 };
  exports2.DataPacket = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.kind !== 0) {
      writer2.uint32(8).int32(message.kind);
    }
    if (message.user !== void 0) {
      exports2.UserPacket.encode(message.user, writer2.uint32(18).fork()).ldelim();
    }
    if (message.speaker !== void 0) {
      exports2.ActiveSpeakerUpdate.encode(message.speaker, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseDataPacket);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader2.int32();
          break;
        case 2:
          message.user = exports2.UserPacket.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.speaker = exports2.ActiveSpeakerUpdate.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseDataPacket);
    if (object.kind !== void 0 && object.kind !== null) {
      message.kind = dataPacket_KindFromJSON(object.kind);
    } else {
      message.kind = 0;
    }
    if (object.user !== void 0 && object.user !== null) {
      message.user = exports2.UserPacket.fromJSON(object.user);
    } else {
      message.user = void 0;
    }
    if (object.speaker !== void 0 && object.speaker !== null) {
      message.speaker = exports2.ActiveSpeakerUpdate.fromJSON(object.speaker);
    } else {
      message.speaker = void 0;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.kind !== void 0 && (obj.kind = dataPacket_KindToJSON(message.kind));
    message.user !== void 0 && (obj.user = message.user ? exports2.UserPacket.toJSON(message.user) : void 0);
    message.speaker !== void 0 && (obj.speaker = message.speaker ? exports2.ActiveSpeakerUpdate.toJSON(message.speaker) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseDataPacket);
    if (object.kind !== void 0 && object.kind !== null) {
      message.kind = object.kind;
    } else {
      message.kind = 0;
    }
    if (object.user !== void 0 && object.user !== null) {
      message.user = exports2.UserPacket.fromPartial(object.user);
    } else {
      message.user = void 0;
    }
    if (object.speaker !== void 0 && object.speaker !== null) {
      message.speaker = exports2.ActiveSpeakerUpdate.fromPartial(object.speaker);
    } else {
      message.speaker = void 0;
    }
    return message;
  } };
  const baseActiveSpeakerUpdate = {};
  exports2.ActiveSpeakerUpdate = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    for (const v2 of message.speakers) {
      exports2.SpeakerInfo.encode(v2, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseActiveSpeakerUpdate);
    message.speakers = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.speakers.push(exports2.SpeakerInfo.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseActiveSpeakerUpdate);
    message.speakers = [];
    if (object.speakers !== void 0 && object.speakers !== null) {
      for (const e2 of object.speakers) {
        message.speakers.push(exports2.SpeakerInfo.fromJSON(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    if (message.speakers) {
      obj.speakers = message.speakers.map((e2) => e2 ? exports2.SpeakerInfo.toJSON(e2) : void 0);
    } else {
      obj.speakers = [];
    }
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseActiveSpeakerUpdate);
    message.speakers = [];
    if (object.speakers !== void 0 && object.speakers !== null) {
      for (const e2 of object.speakers) {
        message.speakers.push(exports2.SpeakerInfo.fromPartial(e2));
      }
    }
    return message;
  } };
  const baseSpeakerInfo = { sid: "", level: 0, active: false };
  exports2.SpeakerInfo = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.sid !== "") {
      writer2.uint32(10).string(message.sid);
    }
    if (message.level !== 0) {
      writer2.uint32(21).float(message.level);
    }
    if (message.active === true) {
      writer2.uint32(24).bool(message.active);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseSpeakerInfo);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sid = reader2.string();
          break;
        case 2:
          message.level = reader2.float();
          break;
        case 3:
          message.active = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseSpeakerInfo);
    if (object.sid !== void 0 && object.sid !== null) {
      message.sid = String(object.sid);
    } else {
      message.sid = "";
    }
    if (object.level !== void 0 && object.level !== null) {
      message.level = Number(object.level);
    } else {
      message.level = 0;
    }
    if (object.active !== void 0 && object.active !== null) {
      message.active = Boolean(object.active);
    } else {
      message.active = false;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.sid !== void 0 && (obj.sid = message.sid);
    message.level !== void 0 && (obj.level = message.level);
    message.active !== void 0 && (obj.active = message.active);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseSpeakerInfo);
    if (object.sid !== void 0 && object.sid !== null) {
      message.sid = object.sid;
    } else {
      message.sid = "";
    }
    if (object.level !== void 0 && object.level !== null) {
      message.level = object.level;
    } else {
      message.level = 0;
    }
    if (object.active !== void 0 && object.active !== null) {
      message.active = object.active;
    } else {
      message.active = false;
    }
    return message;
  } };
  const baseUserPacket = { participantSid: "", destinationSids: "" };
  exports2.UserPacket = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.participantSid !== "") {
      writer2.uint32(10).string(message.participantSid);
    }
    if (message.payload.length !== 0) {
      writer2.uint32(18).bytes(message.payload);
    }
    for (const v2 of message.destinationSids) {
      writer2.uint32(26).string(v2);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseUserPacket);
    message.destinationSids = [];
    message.payload = new Uint8Array();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participantSid = reader2.string();
          break;
        case 2:
          message.payload = reader2.bytes();
          break;
        case 3:
          message.destinationSids.push(reader2.string());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseUserPacket);
    message.destinationSids = [];
    message.payload = new Uint8Array();
    if (object.participantSid !== void 0 && object.participantSid !== null) {
      message.participantSid = String(object.participantSid);
    } else {
      message.participantSid = "";
    }
    if (object.payload !== void 0 && object.payload !== null) {
      message.payload = bytesFromBase64(object.payload);
    }
    if (object.destinationSids !== void 0 && object.destinationSids !== null) {
      for (const e2 of object.destinationSids) {
        message.destinationSids.push(String(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
    message.payload !== void 0 && (obj.payload = base64FromBytes(message.payload !== void 0 ? message.payload : new Uint8Array()));
    if (message.destinationSids) {
      obj.destinationSids = message.destinationSids.map((e2) => e2);
    } else {
      obj.destinationSids = [];
    }
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseUserPacket);
    message.destinationSids = [];
    if (object.participantSid !== void 0 && object.participantSid !== null) {
      message.participantSid = object.participantSid;
    } else {
      message.participantSid = "";
    }
    if (object.payload !== void 0 && object.payload !== null) {
      message.payload = object.payload;
    } else {
      message.payload = new Uint8Array();
    }
    if (object.destinationSids !== void 0 && object.destinationSids !== null) {
      for (const e2 of object.destinationSids) {
        message.destinationSids.push(e2);
      }
    }
    return message;
  } };
  const baseParticipantTracks = { participantSid: "", trackSids: "" };
  exports2.ParticipantTracks = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.participantSid !== "") {
      writer2.uint32(10).string(message.participantSid);
    }
    for (const v2 of message.trackSids) {
      writer2.uint32(18).string(v2);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseParticipantTracks);
    message.trackSids = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participantSid = reader2.string();
          break;
        case 2:
          message.trackSids.push(reader2.string());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseParticipantTracks);
    message.trackSids = [];
    if (object.participantSid !== void 0 && object.participantSid !== null) {
      message.participantSid = String(object.participantSid);
    } else {
      message.participantSid = "";
    }
    if (object.trackSids !== void 0 && object.trackSids !== null) {
      for (const e2 of object.trackSids) {
        message.trackSids.push(String(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
    if (message.trackSids) {
      obj.trackSids = message.trackSids.map((e2) => e2);
    } else {
      obj.trackSids = [];
    }
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseParticipantTracks);
    message.trackSids = [];
    if (object.participantSid !== void 0 && object.participantSid !== null) {
      message.participantSid = object.participantSid;
    } else {
      message.participantSid = "";
    }
    if (object.trackSids !== void 0 && object.trackSids !== null) {
      for (const e2 of object.trackSids) {
        message.trackSids.push(e2);
      }
    }
    return message;
  } };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal !== "undefined")
      return commonjsGlobal;
    throw "Unable to locate global object";
  })();
  const atob2 = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
  function bytesFromBase64(b64) {
    const bin = atob2(b64);
    const arr = new Uint8Array(bin.length);
    for (let i2 = 0; i2 < bin.length; ++i2) {
      arr[i2] = bin.charCodeAt(i2);
    }
    return arr;
  }
  const btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
  function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
      bin.push(String.fromCharCode(byte));
    }
    return btoa2(bin.join(""));
  }
  function longToNumber2(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
      throw new globalThis2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
  }
  if (minimal_1.default.util.Long !== long_12.default) {
    minimal_1.default.util.Long = long_12.default;
    minimal_1.default.configure();
  }
})(livekit_models);
var RoomServiceClient$1 = {};
var livekit_room = {};
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.UpdateRoomMetadataRequest = exports2.SendDataResponse = exports2.SendDataRequest = exports2.UpdateSubscriptionsResponse = exports2.UpdateSubscriptionsRequest = exports2.UpdateParticipantRequest = exports2.ParticipantPermission = exports2.MuteRoomTrackResponse = exports2.MuteRoomTrackRequest = exports2.RemoveParticipantResponse = exports2.RoomParticipantIdentity = exports2.ListParticipantsResponse = exports2.ListParticipantsRequest = exports2.DeleteRoomResponse = exports2.DeleteRoomRequest = exports2.ListRoomsResponse = exports2.ListRoomsRequest = exports2.CreateRoomRequest = exports2.protobufPackage = void 0;
  const long_12 = __importDefault2(umd.exports);
  const minimal_1 = __importDefault2(minimal);
  const livekit_models_12 = livekit_models;
  exports2.protobufPackage = "livekit";
  const baseCreateRoomRequest = { name: "", emptyTimeout: 0, maxParticipants: 0, nodeId: "", metadata: "" };
  exports2.CreateRoomRequest = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.name !== "") {
      writer2.uint32(10).string(message.name);
    }
    if (message.emptyTimeout !== 0) {
      writer2.uint32(16).uint32(message.emptyTimeout);
    }
    if (message.maxParticipants !== 0) {
      writer2.uint32(24).uint32(message.maxParticipants);
    }
    if (message.nodeId !== "") {
      writer2.uint32(34).string(message.nodeId);
    }
    if (message.metadata !== "") {
      writer2.uint32(42).string(message.metadata);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseCreateRoomRequest);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader2.string();
          break;
        case 2:
          message.emptyTimeout = reader2.uint32();
          break;
        case 3:
          message.maxParticipants = reader2.uint32();
          break;
        case 4:
          message.nodeId = reader2.string();
          break;
        case 5:
          message.metadata = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseCreateRoomRequest);
    if (object.name !== void 0 && object.name !== null) {
      message.name = String(object.name);
    } else {
      message.name = "";
    }
    if (object.emptyTimeout !== void 0 && object.emptyTimeout !== null) {
      message.emptyTimeout = Number(object.emptyTimeout);
    } else {
      message.emptyTimeout = 0;
    }
    if (object.maxParticipants !== void 0 && object.maxParticipants !== null) {
      message.maxParticipants = Number(object.maxParticipants);
    } else {
      message.maxParticipants = 0;
    }
    if (object.nodeId !== void 0 && object.nodeId !== null) {
      message.nodeId = String(object.nodeId);
    } else {
      message.nodeId = "";
    }
    if (object.metadata !== void 0 && object.metadata !== null) {
      message.metadata = String(object.metadata);
    } else {
      message.metadata = "";
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = message.name);
    message.emptyTimeout !== void 0 && (obj.emptyTimeout = message.emptyTimeout);
    message.maxParticipants !== void 0 && (obj.maxParticipants = message.maxParticipants);
    message.nodeId !== void 0 && (obj.nodeId = message.nodeId);
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseCreateRoomRequest);
    if (object.name !== void 0 && object.name !== null) {
      message.name = object.name;
    } else {
      message.name = "";
    }
    if (object.emptyTimeout !== void 0 && object.emptyTimeout !== null) {
      message.emptyTimeout = object.emptyTimeout;
    } else {
      message.emptyTimeout = 0;
    }
    if (object.maxParticipants !== void 0 && object.maxParticipants !== null) {
      message.maxParticipants = object.maxParticipants;
    } else {
      message.maxParticipants = 0;
    }
    if (object.nodeId !== void 0 && object.nodeId !== null) {
      message.nodeId = object.nodeId;
    } else {
      message.nodeId = "";
    }
    if (object.metadata !== void 0 && object.metadata !== null) {
      message.metadata = object.metadata;
    } else {
      message.metadata = "";
    }
    return message;
  } };
  const baseListRoomsRequest = { names: "" };
  exports2.ListRoomsRequest = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    for (const v2 of message.names) {
      writer2.uint32(10).string(v2);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseListRoomsRequest);
    message.names = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.names.push(reader2.string());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseListRoomsRequest);
    message.names = [];
    if (object.names !== void 0 && object.names !== null) {
      for (const e2 of object.names) {
        message.names.push(String(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    if (message.names) {
      obj.names = message.names.map((e2) => e2);
    } else {
      obj.names = [];
    }
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseListRoomsRequest);
    message.names = [];
    if (object.names !== void 0 && object.names !== null) {
      for (const e2 of object.names) {
        message.names.push(e2);
      }
    }
    return message;
  } };
  const baseListRoomsResponse = {};
  exports2.ListRoomsResponse = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    for (const v2 of message.rooms) {
      livekit_models_12.Room.encode(v2, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseListRoomsResponse);
    message.rooms = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rooms.push(livekit_models_12.Room.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseListRoomsResponse);
    message.rooms = [];
    if (object.rooms !== void 0 && object.rooms !== null) {
      for (const e2 of object.rooms) {
        message.rooms.push(livekit_models_12.Room.fromJSON(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    if (message.rooms) {
      obj.rooms = message.rooms.map((e2) => e2 ? livekit_models_12.Room.toJSON(e2) : void 0);
    } else {
      obj.rooms = [];
    }
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseListRoomsResponse);
    message.rooms = [];
    if (object.rooms !== void 0 && object.rooms !== null) {
      for (const e2 of object.rooms) {
        message.rooms.push(livekit_models_12.Room.fromPartial(e2));
      }
    }
    return message;
  } };
  const baseDeleteRoomRequest = { room: "" };
  exports2.DeleteRoomRequest = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.room !== "") {
      writer2.uint32(10).string(message.room);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseDeleteRoomRequest);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.room = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseDeleteRoomRequest);
    if (object.room !== void 0 && object.room !== null) {
      message.room = String(object.room);
    } else {
      message.room = "";
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.room !== void 0 && (obj.room = message.room);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseDeleteRoomRequest);
    if (object.room !== void 0 && object.room !== null) {
      message.room = object.room;
    } else {
      message.room = "";
    }
    return message;
  } };
  const baseDeleteRoomResponse = {};
  exports2.DeleteRoomResponse = { encode(_, writer2 = minimal_1.default.Writer.create()) {
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseDeleteRoomResponse);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(_) {
    const message = Object.assign({}, baseDeleteRoomResponse);
    return message;
  }, toJSON(_) {
    const obj = {};
    return obj;
  }, fromPartial(_) {
    const message = Object.assign({}, baseDeleteRoomResponse);
    return message;
  } };
  const baseListParticipantsRequest = { room: "" };
  exports2.ListParticipantsRequest = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.room !== "") {
      writer2.uint32(10).string(message.room);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseListParticipantsRequest);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.room = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseListParticipantsRequest);
    if (object.room !== void 0 && object.room !== null) {
      message.room = String(object.room);
    } else {
      message.room = "";
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.room !== void 0 && (obj.room = message.room);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseListParticipantsRequest);
    if (object.room !== void 0 && object.room !== null) {
      message.room = object.room;
    } else {
      message.room = "";
    }
    return message;
  } };
  const baseListParticipantsResponse = {};
  exports2.ListParticipantsResponse = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    for (const v2 of message.participants) {
      livekit_models_12.ParticipantInfo.encode(v2, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseListParticipantsResponse);
    message.participants = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participants.push(livekit_models_12.ParticipantInfo.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseListParticipantsResponse);
    message.participants = [];
    if (object.participants !== void 0 && object.participants !== null) {
      for (const e2 of object.participants) {
        message.participants.push(livekit_models_12.ParticipantInfo.fromJSON(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    if (message.participants) {
      obj.participants = message.participants.map((e2) => e2 ? livekit_models_12.ParticipantInfo.toJSON(e2) : void 0);
    } else {
      obj.participants = [];
    }
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseListParticipantsResponse);
    message.participants = [];
    if (object.participants !== void 0 && object.participants !== null) {
      for (const e2 of object.participants) {
        message.participants.push(livekit_models_12.ParticipantInfo.fromPartial(e2));
      }
    }
    return message;
  } };
  const baseRoomParticipantIdentity = { room: "", identity: "" };
  exports2.RoomParticipantIdentity = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.room !== "") {
      writer2.uint32(10).string(message.room);
    }
    if (message.identity !== "") {
      writer2.uint32(18).string(message.identity);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseRoomParticipantIdentity);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.room = reader2.string();
          break;
        case 2:
          message.identity = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseRoomParticipantIdentity);
    if (object.room !== void 0 && object.room !== null) {
      message.room = String(object.room);
    } else {
      message.room = "";
    }
    if (object.identity !== void 0 && object.identity !== null) {
      message.identity = String(object.identity);
    } else {
      message.identity = "";
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.room !== void 0 && (obj.room = message.room);
    message.identity !== void 0 && (obj.identity = message.identity);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseRoomParticipantIdentity);
    if (object.room !== void 0 && object.room !== null) {
      message.room = object.room;
    } else {
      message.room = "";
    }
    if (object.identity !== void 0 && object.identity !== null) {
      message.identity = object.identity;
    } else {
      message.identity = "";
    }
    return message;
  } };
  const baseRemoveParticipantResponse = {};
  exports2.RemoveParticipantResponse = { encode(_, writer2 = minimal_1.default.Writer.create()) {
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseRemoveParticipantResponse);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(_) {
    const message = Object.assign({}, baseRemoveParticipantResponse);
    return message;
  }, toJSON(_) {
    const obj = {};
    return obj;
  }, fromPartial(_) {
    const message = Object.assign({}, baseRemoveParticipantResponse);
    return message;
  } };
  const baseMuteRoomTrackRequest = { room: "", identity: "", trackSid: "", muted: false };
  exports2.MuteRoomTrackRequest = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.room !== "") {
      writer2.uint32(10).string(message.room);
    }
    if (message.identity !== "") {
      writer2.uint32(18).string(message.identity);
    }
    if (message.trackSid !== "") {
      writer2.uint32(26).string(message.trackSid);
    }
    if (message.muted === true) {
      writer2.uint32(32).bool(message.muted);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseMuteRoomTrackRequest);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.room = reader2.string();
          break;
        case 2:
          message.identity = reader2.string();
          break;
        case 3:
          message.trackSid = reader2.string();
          break;
        case 4:
          message.muted = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseMuteRoomTrackRequest);
    if (object.room !== void 0 && object.room !== null) {
      message.room = String(object.room);
    } else {
      message.room = "";
    }
    if (object.identity !== void 0 && object.identity !== null) {
      message.identity = String(object.identity);
    } else {
      message.identity = "";
    }
    if (object.trackSid !== void 0 && object.trackSid !== null) {
      message.trackSid = String(object.trackSid);
    } else {
      message.trackSid = "";
    }
    if (object.muted !== void 0 && object.muted !== null) {
      message.muted = Boolean(object.muted);
    } else {
      message.muted = false;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.room !== void 0 && (obj.room = message.room);
    message.identity !== void 0 && (obj.identity = message.identity);
    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);
    message.muted !== void 0 && (obj.muted = message.muted);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseMuteRoomTrackRequest);
    if (object.room !== void 0 && object.room !== null) {
      message.room = object.room;
    } else {
      message.room = "";
    }
    if (object.identity !== void 0 && object.identity !== null) {
      message.identity = object.identity;
    } else {
      message.identity = "";
    }
    if (object.trackSid !== void 0 && object.trackSid !== null) {
      message.trackSid = object.trackSid;
    } else {
      message.trackSid = "";
    }
    if (object.muted !== void 0 && object.muted !== null) {
      message.muted = object.muted;
    } else {
      message.muted = false;
    }
    return message;
  } };
  const baseMuteRoomTrackResponse = {};
  exports2.MuteRoomTrackResponse = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.track !== void 0) {
      livekit_models_12.TrackInfo.encode(message.track, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseMuteRoomTrackResponse);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.track = livekit_models_12.TrackInfo.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseMuteRoomTrackResponse);
    if (object.track !== void 0 && object.track !== null) {
      message.track = livekit_models_12.TrackInfo.fromJSON(object.track);
    } else {
      message.track = void 0;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.track !== void 0 && (obj.track = message.track ? livekit_models_12.TrackInfo.toJSON(message.track) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseMuteRoomTrackResponse);
    if (object.track !== void 0 && object.track !== null) {
      message.track = livekit_models_12.TrackInfo.fromPartial(object.track);
    } else {
      message.track = void 0;
    }
    return message;
  } };
  const baseParticipantPermission = { canSubscribe: false, canPublish: false, canPublishData: false };
  exports2.ParticipantPermission = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.canSubscribe === true) {
      writer2.uint32(8).bool(message.canSubscribe);
    }
    if (message.canPublish === true) {
      writer2.uint32(16).bool(message.canPublish);
    }
    if (message.canPublishData === true) {
      writer2.uint32(24).bool(message.canPublishData);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseParticipantPermission);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.canSubscribe = reader2.bool();
          break;
        case 2:
          message.canPublish = reader2.bool();
          break;
        case 3:
          message.canPublishData = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseParticipantPermission);
    if (object.canSubscribe !== void 0 && object.canSubscribe !== null) {
      message.canSubscribe = Boolean(object.canSubscribe);
    } else {
      message.canSubscribe = false;
    }
    if (object.canPublish !== void 0 && object.canPublish !== null) {
      message.canPublish = Boolean(object.canPublish);
    } else {
      message.canPublish = false;
    }
    if (object.canPublishData !== void 0 && object.canPublishData !== null) {
      message.canPublishData = Boolean(object.canPublishData);
    } else {
      message.canPublishData = false;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.canSubscribe !== void 0 && (obj.canSubscribe = message.canSubscribe);
    message.canPublish !== void 0 && (obj.canPublish = message.canPublish);
    message.canPublishData !== void 0 && (obj.canPublishData = message.canPublishData);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseParticipantPermission);
    if (object.canSubscribe !== void 0 && object.canSubscribe !== null) {
      message.canSubscribe = object.canSubscribe;
    } else {
      message.canSubscribe = false;
    }
    if (object.canPublish !== void 0 && object.canPublish !== null) {
      message.canPublish = object.canPublish;
    } else {
      message.canPublish = false;
    }
    if (object.canPublishData !== void 0 && object.canPublishData !== null) {
      message.canPublishData = object.canPublishData;
    } else {
      message.canPublishData = false;
    }
    return message;
  } };
  const baseUpdateParticipantRequest = { room: "", identity: "", metadata: "" };
  exports2.UpdateParticipantRequest = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.room !== "") {
      writer2.uint32(10).string(message.room);
    }
    if (message.identity !== "") {
      writer2.uint32(18).string(message.identity);
    }
    if (message.metadata !== "") {
      writer2.uint32(26).string(message.metadata);
    }
    if (message.permission !== void 0) {
      exports2.ParticipantPermission.encode(message.permission, writer2.uint32(34).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseUpdateParticipantRequest);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.room = reader2.string();
          break;
        case 2:
          message.identity = reader2.string();
          break;
        case 3:
          message.metadata = reader2.string();
          break;
        case 4:
          message.permission = exports2.ParticipantPermission.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseUpdateParticipantRequest);
    if (object.room !== void 0 && object.room !== null) {
      message.room = String(object.room);
    } else {
      message.room = "";
    }
    if (object.identity !== void 0 && object.identity !== null) {
      message.identity = String(object.identity);
    } else {
      message.identity = "";
    }
    if (object.metadata !== void 0 && object.metadata !== null) {
      message.metadata = String(object.metadata);
    } else {
      message.metadata = "";
    }
    if (object.permission !== void 0 && object.permission !== null) {
      message.permission = exports2.ParticipantPermission.fromJSON(object.permission);
    } else {
      message.permission = void 0;
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.room !== void 0 && (obj.room = message.room);
    message.identity !== void 0 && (obj.identity = message.identity);
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.permission !== void 0 && (obj.permission = message.permission ? exports2.ParticipantPermission.toJSON(message.permission) : void 0);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseUpdateParticipantRequest);
    if (object.room !== void 0 && object.room !== null) {
      message.room = object.room;
    } else {
      message.room = "";
    }
    if (object.identity !== void 0 && object.identity !== null) {
      message.identity = object.identity;
    } else {
      message.identity = "";
    }
    if (object.metadata !== void 0 && object.metadata !== null) {
      message.metadata = object.metadata;
    } else {
      message.metadata = "";
    }
    if (object.permission !== void 0 && object.permission !== null) {
      message.permission = exports2.ParticipantPermission.fromPartial(object.permission);
    } else {
      message.permission = void 0;
    }
    return message;
  } };
  const baseUpdateSubscriptionsRequest = { room: "", identity: "", trackSids: "", subscribe: false };
  exports2.UpdateSubscriptionsRequest = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.room !== "") {
      writer2.uint32(10).string(message.room);
    }
    if (message.identity !== "") {
      writer2.uint32(18).string(message.identity);
    }
    for (const v2 of message.trackSids) {
      writer2.uint32(26).string(v2);
    }
    if (message.subscribe === true) {
      writer2.uint32(32).bool(message.subscribe);
    }
    for (const v2 of message.participantTracks) {
      livekit_models_12.ParticipantTracks.encode(v2, writer2.uint32(42).fork()).ldelim();
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseUpdateSubscriptionsRequest);
    message.trackSids = [];
    message.participantTracks = [];
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.room = reader2.string();
          break;
        case 2:
          message.identity = reader2.string();
          break;
        case 3:
          message.trackSids.push(reader2.string());
          break;
        case 4:
          message.subscribe = reader2.bool();
          break;
        case 5:
          message.participantTracks.push(livekit_models_12.ParticipantTracks.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseUpdateSubscriptionsRequest);
    message.trackSids = [];
    message.participantTracks = [];
    if (object.room !== void 0 && object.room !== null) {
      message.room = String(object.room);
    } else {
      message.room = "";
    }
    if (object.identity !== void 0 && object.identity !== null) {
      message.identity = String(object.identity);
    } else {
      message.identity = "";
    }
    if (object.trackSids !== void 0 && object.trackSids !== null) {
      for (const e2 of object.trackSids) {
        message.trackSids.push(String(e2));
      }
    }
    if (object.subscribe !== void 0 && object.subscribe !== null) {
      message.subscribe = Boolean(object.subscribe);
    } else {
      message.subscribe = false;
    }
    if (object.participantTracks !== void 0 && object.participantTracks !== null) {
      for (const e2 of object.participantTracks) {
        message.participantTracks.push(livekit_models_12.ParticipantTracks.fromJSON(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.room !== void 0 && (obj.room = message.room);
    message.identity !== void 0 && (obj.identity = message.identity);
    if (message.trackSids) {
      obj.trackSids = message.trackSids.map((e2) => e2);
    } else {
      obj.trackSids = [];
    }
    message.subscribe !== void 0 && (obj.subscribe = message.subscribe);
    if (message.participantTracks) {
      obj.participantTracks = message.participantTracks.map((e2) => e2 ? livekit_models_12.ParticipantTracks.toJSON(e2) : void 0);
    } else {
      obj.participantTracks = [];
    }
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseUpdateSubscriptionsRequest);
    message.trackSids = [];
    message.participantTracks = [];
    if (object.room !== void 0 && object.room !== null) {
      message.room = object.room;
    } else {
      message.room = "";
    }
    if (object.identity !== void 0 && object.identity !== null) {
      message.identity = object.identity;
    } else {
      message.identity = "";
    }
    if (object.trackSids !== void 0 && object.trackSids !== null) {
      for (const e2 of object.trackSids) {
        message.trackSids.push(e2);
      }
    }
    if (object.subscribe !== void 0 && object.subscribe !== null) {
      message.subscribe = object.subscribe;
    } else {
      message.subscribe = false;
    }
    if (object.participantTracks !== void 0 && object.participantTracks !== null) {
      for (const e2 of object.participantTracks) {
        message.participantTracks.push(livekit_models_12.ParticipantTracks.fromPartial(e2));
      }
    }
    return message;
  } };
  const baseUpdateSubscriptionsResponse = {};
  exports2.UpdateSubscriptionsResponse = { encode(_, writer2 = minimal_1.default.Writer.create()) {
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseUpdateSubscriptionsResponse);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(_) {
    const message = Object.assign({}, baseUpdateSubscriptionsResponse);
    return message;
  }, toJSON(_) {
    const obj = {};
    return obj;
  }, fromPartial(_) {
    const message = Object.assign({}, baseUpdateSubscriptionsResponse);
    return message;
  } };
  const baseSendDataRequest = { room: "", kind: 0, destinationSids: "" };
  exports2.SendDataRequest = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.room !== "") {
      writer2.uint32(10).string(message.room);
    }
    if (message.data.length !== 0) {
      writer2.uint32(18).bytes(message.data);
    }
    if (message.kind !== 0) {
      writer2.uint32(24).int32(message.kind);
    }
    for (const v2 of message.destinationSids) {
      writer2.uint32(34).string(v2);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseSendDataRequest);
    message.destinationSids = [];
    message.data = new Uint8Array();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.room = reader2.string();
          break;
        case 2:
          message.data = reader2.bytes();
          break;
        case 3:
          message.kind = reader2.int32();
          break;
        case 4:
          message.destinationSids.push(reader2.string());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseSendDataRequest);
    message.destinationSids = [];
    message.data = new Uint8Array();
    if (object.room !== void 0 && object.room !== null) {
      message.room = String(object.room);
    } else {
      message.room = "";
    }
    if (object.data !== void 0 && object.data !== null) {
      message.data = bytesFromBase64(object.data);
    }
    if (object.kind !== void 0 && object.kind !== null) {
      message.kind = livekit_models_12.dataPacket_KindFromJSON(object.kind);
    } else {
      message.kind = 0;
    }
    if (object.destinationSids !== void 0 && object.destinationSids !== null) {
      for (const e2 of object.destinationSids) {
        message.destinationSids.push(String(e2));
      }
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.room !== void 0 && (obj.room = message.room);
    message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
    message.kind !== void 0 && (obj.kind = livekit_models_12.dataPacket_KindToJSON(message.kind));
    if (message.destinationSids) {
      obj.destinationSids = message.destinationSids.map((e2) => e2);
    } else {
      obj.destinationSids = [];
    }
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseSendDataRequest);
    message.destinationSids = [];
    if (object.room !== void 0 && object.room !== null) {
      message.room = object.room;
    } else {
      message.room = "";
    }
    if (object.data !== void 0 && object.data !== null) {
      message.data = object.data;
    } else {
      message.data = new Uint8Array();
    }
    if (object.kind !== void 0 && object.kind !== null) {
      message.kind = object.kind;
    } else {
      message.kind = 0;
    }
    if (object.destinationSids !== void 0 && object.destinationSids !== null) {
      for (const e2 of object.destinationSids) {
        message.destinationSids.push(e2);
      }
    }
    return message;
  } };
  const baseSendDataResponse = {};
  exports2.SendDataResponse = { encode(_, writer2 = minimal_1.default.Writer.create()) {
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseSendDataResponse);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(_) {
    const message = Object.assign({}, baseSendDataResponse);
    return message;
  }, toJSON(_) {
    const obj = {};
    return obj;
  }, fromPartial(_) {
    const message = Object.assign({}, baseSendDataResponse);
    return message;
  } };
  const baseUpdateRoomMetadataRequest = { room: "", metadata: "" };
  exports2.UpdateRoomMetadataRequest = { encode(message, writer2 = minimal_1.default.Writer.create()) {
    if (message.room !== "") {
      writer2.uint32(10).string(message.room);
    }
    if (message.metadata !== "") {
      writer2.uint32(18).string(message.metadata);
    }
    return writer2;
  }, decode(input, length2) {
    const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = Object.assign({}, baseUpdateRoomMetadataRequest);
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.room = reader2.string();
          break;
        case 2:
          message.metadata = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  }, fromJSON(object) {
    const message = Object.assign({}, baseUpdateRoomMetadataRequest);
    if (object.room !== void 0 && object.room !== null) {
      message.room = String(object.room);
    } else {
      message.room = "";
    }
    if (object.metadata !== void 0 && object.metadata !== null) {
      message.metadata = String(object.metadata);
    } else {
      message.metadata = "";
    }
    return message;
  }, toJSON(message) {
    const obj = {};
    message.room !== void 0 && (obj.room = message.room);
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    return obj;
  }, fromPartial(object) {
    const message = Object.assign({}, baseUpdateRoomMetadataRequest);
    if (object.room !== void 0 && object.room !== null) {
      message.room = object.room;
    } else {
      message.room = "";
    }
    if (object.metadata !== void 0 && object.metadata !== null) {
      message.metadata = object.metadata;
    } else {
      message.metadata = "";
    }
    return message;
  } };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal !== "undefined")
      return commonjsGlobal;
    throw "Unable to locate global object";
  })();
  const atob2 = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
  function bytesFromBase64(b64) {
    const bin = atob2(b64);
    const arr = new Uint8Array(bin.length);
    for (let i2 = 0; i2 < bin.length; ++i2) {
      arr[i2] = bin.charCodeAt(i2);
    }
    return arr;
  }
  const btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
  function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
      bin.push(String.fromCharCode(byte));
    }
    return btoa2(bin.join(""));
  }
  if (minimal_1.default.util.Long !== long_12.default) {
    minimal_1.default.util.Long = long_12.default;
    minimal_1.default.configure();
  }
})(livekit_room);
var TwirpRPC = {};
var axios$2 = { exports: {} };
var bind$2 = function bind2(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    return fn.apply(thisArg, args);
  };
};
var bind$1 = bind$2;
var toString = Object.prototype.toString;
function isArray$1(val) {
  return toString.call(val) === "[object Array]";
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return typeof FormData !== "undefined" && val instanceof FormData;
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}
function isString(val) {
  return typeof val === "string";
}
function isNumber(val) {
  return typeof val === "number";
}
function isObject$2(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (toString.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate(val) {
  return toString.call(val) === "[object Date]";
}
function isFile(val) {
  return toString.call(val) === "[object File]";
}
function isBlob(val) {
  return toString.call(val) === "[object Blob]";
}
function isFunction(val) {
  return toString.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$2(val) && isFunction(val.pipe);
}
function isURLSearchParams(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function trim$1(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj, fn) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$1(obj)) {
    for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
function merge() {
  var result = {};
  function assignValue2(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray$1(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }
  for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    forEach(arguments[i2], assignValue2);
  }
  return result;
}
function extend(a, b, thisArg) {
  forEach(b, function assignValue2(val, key) {
    if (thisArg && typeof val === "function") {
      a[key] = bind$1(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
var utils$d = { isArray: isArray$1, isArrayBuffer, isBuffer, isFormData, isArrayBufferView, isString, isNumber, isObject: isObject$2, isPlainObject, isUndefined, isDate, isFile, isBlob, isFunction, isStream, isURLSearchParams, isStandardBrowserEnv, forEach, merge, extend, trim: trim$1, stripBOM };
var utils$c = utils$d;
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$2 = function buildURL2(url2, params, paramsSerializer) {
  if (!params) {
    return url2;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$c.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$c.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$c.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils$c.forEach(val, function parseValue(v2) {
        if (utils$c.isDate(v2)) {
          v2 = v2.toISOString();
        } else if (utils$c.isObject(v2)) {
          v2 = JSON.stringify(v2);
        }
        parts.push(encode(key) + "=" + encode(v2));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
};
var utils$b = utils$d;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options2) {
  this.handlers.push({ fulfilled, rejected, synchronous: options2 ? options2.synchronous : false, runWhen: options2 ? options2.runWhen : null });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id2) {
  if (this.handlers[id2]) {
    this.handlers[id2] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn) {
  utils$b.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn(h2);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$a = utils$d;
var normalizeHeaderName$1 = function normalizeHeaderName2(headers, normalizedName) {
  utils$a.forEach(headers, function processHeader(value, name2) {
    if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name2];
    }
  });
};
var enhanceError$2 = function enhanceError2(error, config2, code, request3, response) {
  error.config = config2;
  if (code) {
    error.code = code;
  }
  error.request = request3;
  error.response = response;
  error.isAxiosError = true;
  error.toJSON = function toJSON() {
    return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code };
  };
  return error;
};
var enhanceError$1 = enhanceError$2;
var createError$2 = function createError2(message, config2, code, request3, response) {
  var error = new Error(message);
  return enhanceError$1(error, config2, code, request3, response);
};
var createError$1 = createError$2;
var settle$1 = function settle2(resolve, reject, response) {
  var validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(createError$1("Request failed with status code " + response.status, response.config, null, response.request, response));
  }
};
var utils$9 = utils$d;
var cookies$1 = utils$9.isStandardBrowserEnv() ? function standardBrowserEnv() {
  return { write: function write(name2, value, expires, path, domain, secure) {
    var cookie = [];
    cookie.push(name2 + "=" + encodeURIComponent(value));
    if (utils$9.isNumber(expires)) {
      cookie.push("expires=" + new Date(expires).toGMTString());
    }
    if (utils$9.isString(path)) {
      cookie.push("path=" + path);
    }
    if (utils$9.isString(domain)) {
      cookie.push("domain=" + domain);
    }
    if (secure === true) {
      cookie.push("secure");
    }
    document.cookie = cookie.join("; ");
  }, read: function read(name2) {
    var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
    return match ? decodeURIComponent(match[3]) : null;
  }, remove: function remove2(name2) {
    this.write(name2, "", Date.now() - 864e5);
  } };
}() : function nonStandardBrowserEnv() {
  return { write: function write() {
  }, read: function read() {
    return null;
  }, remove: function remove2() {
  } };
}();
var isAbsoluteURL$1 = function isAbsoluteURL2(url2) {
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url2);
};
var combineURLs$1 = function combineURLs2(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL = isAbsoluteURL$1;
var combineURLs = combineURLs$1;
var buildFullPath$1 = function buildFullPath2(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};
var utils$8 = utils$d;
var ignoreDuplicateOf = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
var parseHeaders$1 = function parseHeaders2(headers) {
  var parsed2 = {};
  var key;
  var val;
  var i2;
  if (!headers) {
    return parsed2;
  }
  utils$8.forEach(headers.split("\n"), function parser(line) {
    i2 = line.indexOf(":");
    key = utils$8.trim(line.substr(0, i2)).toLowerCase();
    val = utils$8.trim(line.substr(i2 + 1));
    if (key) {
      if (parsed2[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === "set-cookie") {
        parsed2[key] = (parsed2[key] ? parsed2[key] : []).concat([val]);
      } else {
        parsed2[key] = parsed2[key] ? parsed2[key] + ", " + val : val;
      }
    }
  });
  return parsed2;
};
var utils$7 = utils$d;
var isURLSameOrigin$1 = utils$7.isStandardBrowserEnv() ? function standardBrowserEnv2() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement("a");
  var originURL;
  function resolveURL(url2) {
    var href = url2;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return { href: urlParsingNode.href, protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "", host: urlParsingNode.host, search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "", hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "", hostname: urlParsingNode.hostname, port: urlParsingNode.port, pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    var parsed2 = utils$7.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed2.protocol === originURL.protocol && parsed2.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
var utils$6 = utils$d;
var settle = settle$1;
var cookies = cookies$1;
var buildURL$1 = buildURL$2;
var buildFullPath = buildFullPath$1;
var parseHeaders = parseHeaders$1;
var isURLSameOrigin = isURLSameOrigin$1;
var createError = createError$2;
var xhr = function xhrAdapter(config2) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config2.data;
    var requestHeaders = config2.headers;
    var responseType = config2.responseType;
    if (utils$6.isFormData(requestData)) {
      delete requestHeaders["Content-Type"];
    }
    var request3 = new XMLHttpRequest();
    if (config2.auth) {
      var username = config2.auth.username || "";
      var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
    }
    var fullPath = buildFullPath(config2.baseURL, config2.url);
    request3.open(config2.method.toUpperCase(), buildURL$1(fullPath, config2.params, config2.paramsSerializer), true);
    request3.timeout = config2.timeout;
    function onloadend() {
      if (!request3) {
        return;
      }
      var responseHeaders = "getAllResponseHeaders" in request3 ? parseHeaders(request3.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === "text" || responseType === "json" ? request3.responseText : request3.response;
      var response = { data: responseData, status: request3.status, statusText: request3.statusText, headers: responseHeaders, config: config2, request: request3 };
      settle(resolve, reject, response);
      request3 = null;
    }
    if ("onloadend" in request3) {
      request3.onloadend = onloadend;
    } else {
      request3.onreadystatechange = function handleLoad() {
        if (!request3 || request3.readyState !== 4) {
          return;
        }
        if (request3.status === 0 && !(request3.responseURL && request3.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request3.onabort = function handleAbort() {
      if (!request3) {
        return;
      }
      reject(createError("Request aborted", config2, "ECONNABORTED", request3));
      request3 = null;
    };
    request3.onerror = function handleError() {
      reject(createError("Network Error", config2, null, request3));
      request3 = null;
    };
    request3.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = "timeout of " + config2.timeout + "ms exceeded";
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config2, config2.transitional && config2.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request3));
      request3 = null;
    };
    if (utils$6.isStandardBrowserEnv()) {
      var xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName ? cookies.read(config2.xsrfCookieName) : void 0;
      if (xsrfValue) {
        requestHeaders[config2.xsrfHeaderName] = xsrfValue;
      }
    }
    if ("setRequestHeader" in request3) {
      utils$6.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
          delete requestHeaders[key];
        } else {
          request3.setRequestHeader(key, val);
        }
      });
    }
    if (!utils$6.isUndefined(config2.withCredentials)) {
      request3.withCredentials = !!config2.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request3.responseType = config2.responseType;
    }
    if (typeof config2.onDownloadProgress === "function") {
      request3.addEventListener("progress", config2.onDownloadProgress);
    }
    if (typeof config2.onUploadProgress === "function" && request3.upload) {
      request3.upload.addEventListener("progress", config2.onUploadProgress);
    }
    if (config2.cancelToken) {
      config2.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request3) {
          return;
        }
        request3.abort();
        reject(cancel);
        request3 = null;
      });
    }
    if (!requestData) {
      requestData = null;
    }
    request3.send(requestData);
  });
};
var utils$5 = utils$d;
var normalizeHeaderName = normalizeHeaderName$1;
var enhanceError = enhanceError$2;
var DEFAULT_CONTENT_TYPE = { "Content-Type": "application/x-www-form-urlencoded" };
function setContentTypeIfUnset(headers, value) {
  if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = xhr;
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = xhr;
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder2) {
  if (utils$5.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$5.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder2 || JSON.stringify)(rawValue);
}
var defaults$3 = { transitional: { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, adapter: getDefaultAdapter(), transformRequest: [function transformRequest(data2, headers) {
  normalizeHeaderName(headers, "Accept");
  normalizeHeaderName(headers, "Content-Type");
  if (utils$5.isFormData(data2) || utils$5.isArrayBuffer(data2) || utils$5.isBuffer(data2) || utils$5.isStream(data2) || utils$5.isFile(data2) || utils$5.isBlob(data2)) {
    return data2;
  }
  if (utils$5.isArrayBufferView(data2)) {
    return data2.buffer;
  }
  if (utils$5.isURLSearchParams(data2)) {
    setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
    return data2.toString();
  }
  if (utils$5.isObject(data2) || headers && headers["Content-Type"] === "application/json") {
    setContentTypeIfUnset(headers, "application/json");
    return stringifySafely(data2);
  }
  return data2;
}], transformResponse: [function transformResponse(data2) {
  var transitional2 = this.transitional;
  var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
  var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
  var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
  if (strictJSONParsing || forcedJSONParsing && utils$5.isString(data2) && data2.length) {
    try {
      return JSON.parse(data2);
    } catch (e2) {
      if (strictJSONParsing) {
        if (e2.name === "SyntaxError") {
          throw enhanceError(e2, this, "E_JSON_PARSE");
        }
        throw e2;
      }
    }
  }
  return data2;
}], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, validateStatus: function validateStatus(status) {
  return status >= 200 && status < 300;
} };
defaults$3.headers = { common: { "Accept": "application/json, text/plain, */*" } };
utils$5.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$3.headers[method] = {};
});
utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$3.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3;
var utils$4 = utils$d;
var defaults$2 = defaults_1;
var transformData$1 = function transformData2(data2, headers, fns) {
  var context2 = this || defaults$2;
  utils$4.forEach(fns, function transform(fn) {
    data2 = fn.call(context2, data2, headers);
  });
  return data2;
};
var isCancel$1 = function isCancel2(value) {
  return !!(value && value.__CANCEL__);
};
var utils$3 = utils$d;
var transformData = transformData$1;
var isCancel = isCancel$1;
var defaults$1 = defaults_1;
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
}
var dispatchRequest$1 = function dispatchRequest2(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = config2.headers || {};
  config2.data = transformData.call(config2, config2.data, config2.headers, config2.transformRequest);
  config2.headers = utils$3.merge(config2.headers.common || {}, config2.headers[config2.method] || {}, config2.headers);
  utils$3.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
    delete config2.headers[method];
  });
  var adapter = config2.adapter || defaults$1.adapter;
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(config2, response.data, response.headers, config2.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(config2, reason.response.data, reason.response.headers, config2.transformResponse);
      }
    }
    return Promise.reject(reason);
  });
};
var utils$2 = utils$d;
var mergeConfig$2 = function mergeConfig2(config1, config2) {
  config2 = config2 || {};
  var config3 = {};
  var valueFromConfig2Keys = ["url", "method", "data"];
  var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
  var defaultToConfig2Keys = ["baseURL", "transformRequest", "transformResponse", "paramsSerializer", "timeout", "timeoutMessage", "withCredentials", "adapter", "responseType", "xsrfCookieName", "xsrfHeaderName", "onUploadProgress", "onDownloadProgress", "decompress", "maxContentLength", "maxBodyLength", "maxRedirects", "transport", "httpAgent", "httpsAgent", "cancelToken", "socketPath", "responseEncoding"];
  var directMergeKeys = ["validateStatus"];
  function getMergedValue(target, source2) {
    if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source2)) {
      return utils$2.merge(target, source2);
    } else if (utils$2.isPlainObject(source2)) {
      return utils$2.merge({}, source2);
    } else if (utils$2.isArray(source2)) {
      return source2.slice();
    }
    return source2;
  }
  function mergeDeepProperties(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  }
  utils$2.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(void 0, config2[prop]);
    }
  });
  utils$2.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils$2.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(void 0, config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  utils$2.forEach(directMergeKeys, function merge2(prop) {
    if (prop in config2) {
      config3[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils$2.forEach(otherKeys, mergeDeepProperties);
  return config3;
};
const name = "axios";
const version = "0.21.4";
const description = "Promise based HTTP client for the browser and node.js";
const main = "index.js";
const scripts = { test: "grunt test", start: "node ./sandbox/server.js", build: "NODE_ENV=production grunt build", preversion: "npm test", version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json", postversion: "git push && git push --tags", examples: "node ./examples/server.js", coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js", fix: "eslint --fix lib/**/*.js" };
const repository = { type: "git", url: "https://github.com/axios/axios.git" };
const keywords = ["xhr", "http", "ajax", "promise", "node"];
const author = "Matt Zabriskie";
const license = "MIT";
const bugs = { url: "https://github.com/axios/axios/issues" };
const homepage = "https://axios-http.com";
const devDependencies = { coveralls: "^3.0.0", "es6-promise": "^4.2.4", grunt: "^1.3.0", "grunt-banner": "^0.6.0", "grunt-cli": "^1.2.0", "grunt-contrib-clean": "^1.1.0", "grunt-contrib-watch": "^1.0.0", "grunt-eslint": "^23.0.0", "grunt-karma": "^4.0.0", "grunt-mocha-test": "^0.13.3", "grunt-ts": "^6.0.0-beta.19", "grunt-webpack": "^4.0.2", "istanbul-instrumenter-loader": "^1.0.0", "jasmine-core": "^2.4.1", karma: "^6.3.2", "karma-chrome-launcher": "^3.1.0", "karma-firefox-launcher": "^2.1.0", "karma-jasmine": "^1.1.1", "karma-jasmine-ajax": "^0.1.13", "karma-safari-launcher": "^1.0.0", "karma-sauce-launcher": "^4.3.6", "karma-sinon": "^1.0.5", "karma-sourcemap-loader": "^0.3.8", "karma-webpack": "^4.0.2", "load-grunt-tasks": "^3.5.2", minimist: "^1.2.0", mocha: "^8.2.1", sinon: "^4.5.0", "terser-webpack-plugin": "^4.2.3", typescript: "^4.0.5", "url-search-params": "^0.10.0", webpack: "^4.44.2", "webpack-dev-server": "^3.11.0" };
const browser = { "./lib/adapters/http.js": "./lib/adapters/xhr.js" };
const jsdelivr = "dist/axios.min.js";
const unpkg = "dist/axios.min.js";
const typings = "./index.d.ts";
const dependencies = { "follow-redirects": "^1.14.0" };
const bundlesize = [{ path: "./dist/axios.min.js", threshold: "5kB" }];
var require$$0 = { name, version, description, main, scripts, repository, keywords, author, license, bugs, homepage, devDependencies, browser, jsdelivr, unpkg, typings, dependencies, bundlesize };
var pkg = require$$0;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
var currentVerArr = pkg.version.split(".");
function isOlderVersion(version2, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
  var destVer = version2.split(".");
  for (var i2 = 0; i2 < 3; i2++) {
    if (pkgVersionArr[i2] > destVer[i2]) {
      return true;
    } else if (pkgVersionArr[i2] < destVer[i2]) {
      return false;
    }
  }
  return false;
}
validators$1.transitional = function transitional(validator2, version2, message) {
  var isDeprecated = version2 && isOlderVersion(version2);
  function formatMessage(opt, desc) {
    return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new Error(formatMessage(opt, " has been removed in " + version2));
    }
    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options2, schema, allowUnknown) {
  if (typeof options2 !== "object") {
    throw new TypeError("options must be an object");
  }
  var keys2 = Object.keys(options2);
  var i2 = keys2.length;
  while (i2-- > 0) {
    var opt = keys2[i2];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options2[opt];
      var result = value === void 0 || validator2(value, opt, options2);
      if (result !== true) {
        throw new TypeError("option " + opt + " must be " + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error("Unknown option " + opt);
    }
  }
}
var validator$1 = { isOlderVersion, assertOptions, validators: validators$1 };
var utils$1 = utils$d;
var buildURL = buildURL$2;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager() };
}
Axios$1.prototype.request = function request2(config2) {
  if (typeof config2 === "string") {
    config2 = arguments[1] || {};
    config2.url = arguments[0];
  } else {
    config2 = config2 || {};
  }
  config2 = mergeConfig$1(this.defaults, config2);
  if (config2.method) {
    config2.method = config2.method.toLowerCase();
  } else if (this.defaults.method) {
    config2.method = this.defaults.method.toLowerCase();
  } else {
    config2.method = "get";
  }
  var transitional2 = config2.transitional;
  if (transitional2 !== void 0) {
    validator.assertOptions(transitional2, { silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"), forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"), clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0") }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config2);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config2;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }
  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config2) {
  config2 = mergeConfig$1(this.defaults, config2);
  return buildURL(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
};
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios$1.prototype[method] = function(url2, config2) {
    return this.request(mergeConfig$1(config2 || {}, { method, url: url2, data: (config2 || {}).data }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  Axios$1.prototype[method] = function(url2, data2, config2) {
    return this.request(mergeConfig$1(config2 || {}, { method, url: url2, data: data2 }));
  };
});
var Axios_1 = Axios$1;
function Cancel$1(message) {
  this.message = message;
}
Cancel$1.prototype.toString = function toString2() {
  return "Cancel" + (this.message ? ": " + this.message : "");
};
Cancel$1.prototype.__CANCEL__ = true;
var Cancel_1 = Cancel$1;
var Cancel = Cancel_1;
function CancelToken(executor) {
  if (typeof executor !== "function") {
    throw new TypeError("executor must be a function.");
  }
  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      return;
    }
    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return { token, cancel };
};
var CancelToken_1 = CancelToken;
var spread = function spread2(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};
var isAxiosError = function isAxiosError2(payload) {
  return typeof payload === "object" && payload.isAxiosError === true;
};
var utils = utils$d;
var bind = bind$2;
var Axios = Axios_1;
var mergeConfig = mergeConfig$2;
var defaults = defaults_1;
function createInstance(defaultConfig) {
  var context2 = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context2);
  utils.extend(instance, Axios.prototype, context2);
  utils.extend(instance, context2);
  return instance;
}
var axios$1 = createInstance(defaults);
axios$1.Axios = Axios;
axios$1.create = function create4(instanceConfig) {
  return createInstance(mergeConfig(axios$1.defaults, instanceConfig));
};
axios$1.Cancel = Cancel_1;
axios$1.CancelToken = CancelToken_1;
axios$1.isCancel = isCancel$1;
axios$1.all = function all2(promises) {
  return Promise.all(promises);
};
axios$1.spread = spread;
axios$1.isAxiosError = isAxiosError;
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
var axios = axios$2.exports;
var mapObj$1 = { exports: {} };
const isObject$1 = (value) => typeof value === "object" && value !== null;
const mapObjectSkip = Symbol("skip");
const isObjectCustom = (value) => isObject$1(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
const mapObject = (object, mapper, options2, isSeen = /* @__PURE__ */ new WeakMap()) => {
  options2 = { deep: false, target: {}, ...options2 };
  if (isSeen.has(object)) {
    return isSeen.get(object);
  }
  isSeen.set(object, options2.target);
  const { target } = options2;
  delete options2.target;
  const mapArray = (array) => array.map((element) => isObjectCustom(element) ? mapObject(element, mapper, options2, isSeen) : element);
  if (Array.isArray(object)) {
    return mapArray(object);
  }
  for (const [key, value] of Object.entries(object)) {
    const mapResult = mapper(key, value, object);
    if (mapResult === mapObjectSkip) {
      continue;
    }
    let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
    if (newKey === "__proto__") {
      continue;
    }
    if (options2.deep && shouldRecurse && isObjectCustom(newValue)) {
      newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject(newValue, mapper, options2, isSeen);
    }
    target[newKey] = newValue;
  }
  return target;
};
mapObj$1.exports = (object, mapper, options2) => {
  if (!isObject$1(object)) {
    throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
  }
  return mapObject(object, mapper, options2);
};
mapObj$1.exports.mapObjectSkip = mapObjectSkip;
var camelcase = { exports: {} };
const UPPERCASE = /[\p{Lu}]/u;
const LOWERCASE = /[\p{Ll}]/u;
const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
const SEPARATORS = /[_.\- ]+/;
const LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
const NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
const preserveCamelCase = (string, toLowerCase, toUpperCase) => {
  let isLastCharLower = false;
  let isLastCharUpper = false;
  let isLastLastCharUpper = false;
  for (let i2 = 0; i2 < string.length; i2++) {
    const character = string[i2];
    if (isLastCharLower && UPPERCASE.test(character)) {
      string = string.slice(0, i2) + "-" + string.slice(i2);
      isLastCharLower = false;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = true;
      i2++;
    } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
      string = string.slice(0, i2 - 1) + "-" + string.slice(i2 - 1);
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = false;
      isLastCharLower = true;
    } else {
      isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
    }
  }
  return string;
};
const preserveConsecutiveUppercase = (input, toLowerCase) => {
  LEADING_CAPITAL.lastIndex = 0;
  return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
};
const postProcess = (input, toUpperCase) => {
  SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
  NUMBERS_AND_IDENTIFIER.lastIndex = 0;
  return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m2) => toUpperCase(m2));
};
const camelCase$1 = (input, options2) => {
  if (!(typeof input === "string" || Array.isArray(input))) {
    throw new TypeError("Expected the input to be `string | string[]`");
  }
  options2 = { pascalCase: false, preserveConsecutiveUppercase: false, ...options2 };
  if (Array.isArray(input)) {
    input = input.map((x2) => x2.trim()).filter((x2) => x2.length).join("-");
  } else {
    input = input.trim();
  }
  if (input.length === 0) {
    return "";
  }
  const toLowerCase = options2.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options2.locale);
  const toUpperCase = options2.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options2.locale);
  if (input.length === 1) {
    return options2.pascalCase ? toUpperCase(input) : toLowerCase(input);
  }
  const hasUpperCase = input !== toLowerCase(input);
  if (hasUpperCase) {
    input = preserveCamelCase(input, toLowerCase, toUpperCase);
  }
  input = input.replace(LEADING_SEPARATORS, "");
  if (options2.preserveConsecutiveUppercase) {
    input = preserveConsecutiveUppercase(input, toLowerCase);
  } else {
    input = toLowerCase(input);
  }
  if (options2.pascalCase) {
    input = toUpperCase(input.charAt(0)) + input.slice(1);
  }
  return postProcess(input, toUpperCase);
};
camelcase.exports = camelCase$1;
camelcase.exports.default = camelCase$1;
class QuickLRU {
  constructor(options2 = {}) {
    if (!(options2.maxSize && options2.maxSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    this.maxSize = options2.maxSize;
    this.onEviction = options2.onEviction;
    this.cache = /* @__PURE__ */ new Map();
    this.oldCache = /* @__PURE__ */ new Map();
    this._size = 0;
  }
  _set(key, value) {
    this.cache.set(key, value);
    this._size++;
    if (this._size >= this.maxSize) {
      this._size = 0;
      if (typeof this.onEviction === "function") {
        for (const [key2, value2] of this.oldCache.entries()) {
          this.onEviction(key2, value2);
        }
      }
      this.oldCache = this.cache;
      this.cache = /* @__PURE__ */ new Map();
    }
  }
  get(key) {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    if (this.oldCache.has(key)) {
      const value = this.oldCache.get(key);
      this.oldCache.delete(key);
      this._set(key, value);
      return value;
    }
  }
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.set(key, value);
    } else {
      this._set(key, value);
    }
    return this;
  }
  has(key) {
    return this.cache.has(key) || this.oldCache.has(key);
  }
  peek(key) {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    if (this.oldCache.has(key)) {
      return this.oldCache.get(key);
    }
  }
  delete(key) {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this._size--;
    }
    return this.oldCache.delete(key) || deleted;
  }
  clear() {
    this.cache.clear();
    this.oldCache.clear();
    this._size = 0;
  }
  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }
  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }
  *[Symbol.iterator]() {
    for (const item of this.cache) {
      yield item;
    }
    for (const item of this.oldCache) {
      const [key] = item;
      if (!this.cache.has(key)) {
        yield item;
      }
    }
  }
  get size() {
    let oldCacheSize = 0;
    for (const key of this.oldCache.keys()) {
      if (!this.cache.has(key)) {
        oldCacheSize++;
      }
    }
    return Math.min(this._size + oldCacheSize, this.maxSize);
  }
}
var quickLru = QuickLRU;
const mapObj = mapObj$1.exports;
const camelCase = camelcase.exports;
const QuickLru = quickLru;
const has = (array, key) => array.some((x2) => {
  if (typeof x2 === "string") {
    return x2 === key;
  }
  x2.lastIndex = 0;
  return x2.test(key);
});
const cache$1 = new QuickLru({ maxSize: 1e5 });
const isObject = (value) => typeof value === "object" && value !== null && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
const camelCaseConvert = (input, options2) => {
  if (!isObject(input)) {
    return input;
  }
  options2 = { deep: false, pascalCase: false, ...options2 };
  const { exclude, pascalCase, stopPaths, deep } = options2;
  const stopPathsSet = new Set(stopPaths);
  const makeMapper = (parentPath) => (key, value) => {
    if (deep && isObject(value)) {
      const path = parentPath === void 0 ? key : `${parentPath}.${key}`;
      if (!stopPathsSet.has(path)) {
        value = mapObj(value, makeMapper(path));
      }
    }
    if (!(exclude && has(exclude, key))) {
      const cacheKey = pascalCase ? `${key}_` : key;
      if (cache$1.has(cacheKey)) {
        key = cache$1.get(cacheKey);
      } else {
        const returnValue = camelCase(key, { pascalCase, locale: false });
        if (key.length < 100) {
          cache$1.set(cacheKey, returnValue);
        }
        key = returnValue;
      }
    }
    return [key, value];
  };
  return mapObj(input, makeMapper(void 0));
};
var camelcaseKeys = (input, options2) => {
  if (Array.isArray(input)) {
    return Object.keys(input).map((key) => camelCaseConvert(input[key], options2));
  }
  return camelCaseConvert(input, options2);
};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(TwirpRPC, "__esModule", { value: true });
TwirpRPC.TwirpRpc = TwirpRPC.livekitPackage = void 0;
const axios_1 = __importDefault(axios);
const camelcase_keys_1 = __importDefault(camelcaseKeys);
const defaultPrefix = "/twirp";
TwirpRPC.livekitPackage = "livekit";
class TwirpRpc {
  constructor(host, pkg2, prefix, hostHeader) {
    this.host = host;
    this.pkg = pkg2;
    this.prefix = prefix || defaultPrefix;
    let config2 = { baseURL: host };
    if (hostHeader != void 0)
      config2.headers = { Host: hostHeader };
    this.instance = axios_1.default.create(config2);
  }
  request(service2, method, data2, headers) {
    return new Promise((resolve, reject) => {
      const path = `${this.prefix}/${this.pkg}.${service2}/${method}`;
      this.instance.post(path, data2, { headers }).then((res) => {
        resolve(camelcase_keys_1.default(res.data, { deep: true }));
      }).catch(reject);
    });
  }
}
TwirpRPC.TwirpRpc = TwirpRpc;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(RoomServiceClient$1, "__esModule", { value: true });
RoomServiceClient$1.RoomServiceClient = void 0;
const livekit_models_1 = livekit_models;
const livekit_room_1 = livekit_room;
const TwirpRPC_1 = TwirpRPC;
const svc = "RoomService";
class RoomServiceClient {
  constructor(host, apiKey, secret, jwt, hostHeader) {
    this.rpc = new TwirpRPC_1.TwirpRpc(host, TwirpRPC_1.livekitPackage, void 0, hostHeader);
    this.apiKey = apiKey;
    this.secret = secret;
    this.jwt = jwt;
  }
  createRoom(options2) {
    return __awaiter(this, void 0, void 0, function* () {
      const data2 = yield this.rpc.request(svc, "CreateRoom", livekit_room_1.CreateRoomRequest.toJSON(livekit_room_1.CreateRoomRequest.fromPartial(options2)), this.authHeader({ roomCreate: true }));
      return livekit_models_1.Room.fromJSON(data2);
    });
  }
  listRooms(names) {
    return __awaiter(this, void 0, void 0, function* () {
      const data2 = yield this.rpc.request(svc, "ListRooms", livekit_room_1.ListRoomsRequest.toJSON({ names: names !== null && names !== void 0 ? names : [] }), this.authHeader({ roomList: true }));
      const res = livekit_room_1.ListRoomsResponse.fromJSON(data2);
      return res.rooms;
    });
  }
  deleteRoom(room) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.rpc.request(svc, "DeleteRoom", livekit_room_1.DeleteRoomRequest.toJSON({ room }), this.authHeader({ roomCreate: true }));
    });
  }
  updateRoomMetadata(room, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const data2 = yield this.rpc.request(svc, "UpdateRoomMetadata", livekit_room_1.UpdateRoomMetadataRequest.toJSON({ room, metadata }), this.authHeader({ roomAdmin: true, room }));
      return livekit_models_1.Room.fromJSON(data2);
    });
  }
  listParticipants(room) {
    return __awaiter(this, void 0, void 0, function* () {
      const data2 = yield this.rpc.request(svc, "ListParticipants", livekit_room_1.ListParticipantsRequest.toJSON({ room }), this.authHeader({ roomAdmin: true, room }));
      const res = livekit_room_1.ListParticipantsResponse.fromJSON(data2);
      return res.participants;
    });
  }
  getParticipant(room, identity2) {
    return __awaiter(this, void 0, void 0, function* () {
      const data2 = yield this.rpc.request(svc, "GetParticipant", livekit_room_1.RoomParticipantIdentity.toJSON({ room, identity: identity2 }), this.authHeader({ roomAdmin: true, room }));
      return livekit_models_1.ParticipantInfo.fromJSON(data2);
    });
  }
  removeParticipant(room, identity2) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.rpc.request(svc, "RemoveParticipant", livekit_room_1.RoomParticipantIdentity.toJSON({ room, identity: identity2 }), this.authHeader({ roomAdmin: true, room }));
    });
  }
  mutePublishedTrack(room, identity2, trackSid, muted) {
    return __awaiter(this, void 0, void 0, function* () {
      const req = livekit_room_1.MuteRoomTrackRequest.toJSON({ room, identity: identity2, trackSid, muted });
      const data2 = yield this.rpc.request(svc, "MutePublishedTrack", req, this.authHeader({ roomAdmin: true, room }));
      const res = livekit_room_1.MuteRoomTrackResponse.fromJSON(data2);
      return res.track;
    });
  }
  updateParticipant(room, identity2, metadata, permission) {
    return __awaiter(this, void 0, void 0, function* () {
      const req = { room, identity: identity2, metadata: metadata || "", permission };
      const data2 = yield this.rpc.request(svc, "UpdateParticipant", livekit_room_1.UpdateParticipantRequest.toJSON(req), this.authHeader({ roomAdmin: true, room }));
      return livekit_models_1.ParticipantInfo.fromJSON(data2);
    });
  }
  updateSubscriptions(room, identity2, trackSids, subscribe2) {
    return __awaiter(this, void 0, void 0, function* () {
      const req = livekit_room_1.UpdateSubscriptionsRequest.toJSON({ room, identity: identity2, trackSids, subscribe: subscribe2, participantTracks: [] });
      yield this.rpc.request(svc, "UpdateSubscriptions", req, this.authHeader({ roomAdmin: true, room }));
    });
  }
  sendData(room, data2, kind, destinationSids = []) {
    return __awaiter(this, void 0, void 0, function* () {
      const req = livekit_room_1.SendDataRequest.toJSON({ room, data: data2, kind, destinationSids });
      yield this.rpc.request(svc, "SendData", req, this.authHeader({ roomAdmin: true, room }));
    });
  }
  authHeader(grant) {
    if (this.jwt != void 0) {
      return { Authorization: `Bearer ${this.jwt}` };
    }
  }
}
RoomServiceClient$1.RoomServiceClient = RoomServiceClient;
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m2[k];
    } });
  } : function(o2, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m2[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TrackType = exports2.TrackInfo = exports2.Room = exports2.ParticipantInfo_State = exports2.ParticipantInfo = exports2.DataPacket_Kind = void 0;
  __exportStar(grants, exports2);
  var livekit_models_12 = livekit_models;
  Object.defineProperty(exports2, "DataPacket_Kind", { enumerable: true, get: function() {
    return livekit_models_12.DataPacket_Kind;
  } });
  Object.defineProperty(exports2, "ParticipantInfo", { enumerable: true, get: function() {
    return livekit_models_12.ParticipantInfo;
  } });
  Object.defineProperty(exports2, "ParticipantInfo_State", { enumerable: true, get: function() {
    return livekit_models_12.ParticipantInfo_State;
  } });
  Object.defineProperty(exports2, "Room", { enumerable: true, get: function() {
    return livekit_models_12.Room;
  } });
  Object.defineProperty(exports2, "TrackInfo", { enumerable: true, get: function() {
    return livekit_models_12.TrackInfo;
  } });
  Object.defineProperty(exports2, "TrackType", { enumerable: true, get: function() {
    return livekit_models_12.TrackType;
  } });
  __exportStar(RoomServiceClient$1, exports2);
})(dist);
var SpecialEvent = /* @__PURE__ */ ((SpecialEvent2) => {
  SpecialEvent2["Chat"] = "Chat";
  return SpecialEvent2;
})(SpecialEvent || {});
const decoder$1 = new TextDecoder();
const encoder$1 = new TextEncoder();
class RoomsManager {
  constructor() {
    this.rooms = /* @__PURE__ */ new Map();
    this.addRoom = this.addRoom.bind(this);
    this.ensureRoom = this.ensureRoom.bind(this);
    this.removeRoom = this.removeRoom.bind(this);
  }
  addRoom(baseUrl, roomName, token) {
    const roomContext = new RoomContext(baseUrl, roomName, token, this);
    this.rooms.set(roomName, roomContext);
    return roomContext;
  }
  ensureRoom(baseUrl, roomName, token) {
    if (this.rooms.get(roomName)) {
      this.rooms.get(roomName).token = token;
      return this.rooms.get(roomName);
    } else {
      return this.addRoom(baseUrl, roomName, token);
    }
  }
  async removeRoom(roomName) {
    const room = this.rooms.get(roomName);
    if (!dist$1.Room) {
      throw new Error("room not found!");
    }
    if (room.isConnecting) {
      throw new Error("Cannot remove room: Room is in connecting state");
    }
    if (room.livekitRoom) {
      await room.livekitRoom.disconnect(true);
    }
    this.rooms.delete(roomName);
  }
}
class RoomContext {
  constructor(baseUrl, roomName, token, manager) {
    this._baseUrl = baseUrl;
    this._connectListeners = [];
    this._roomEventListenerRegistry = {};
    this._jwt = token;
    Object.values(dist$1.RoomEvent).forEach((value) => {
      this._roomEventListenerRegistry[value] = /* @__PURE__ */ new Set();
    });
    this._localParticipantEventListenerRegistry = {};
    Object.values(dist$1.ParticipantEvent).forEach((value) => {
      this._localParticipantEventListenerRegistry[value] = /* @__PURE__ */ new Set();
    });
    this._specialEventListenerRegistry = {};
    this._manager = manager;
    this._chatHistory = [];
    this.roomName = roomName;
    this.audioTracks = [];
    this.participants = [];
    this.isConnecting = false;
    this.subscribeToRoomEvent(dist$1.RoomEvent.DataReceived, (payload, participant, kind) => {
      const strData = decoder$1.decode(payload);
      const data2 = JSON.parse(strData);
      switch (data2.type) {
        case "ChatMessage": {
          return this._appendChat(payload, participant, kind);
        }
        default:
          return;
      }
    });
    this.connect = this.connect.bind(this);
    this.subscribeToRoomEvent = this.subscribeToRoomEvent.bind(this);
    this.subscribeToConnect = this.subscribeToConnect.bind(this);
    this.subscribeToLocalParticipantEvent = this.subscribeToLocalParticipantEvent.bind(this);
    this.subscribeToSpecialEvent = this.subscribeToSpecialEvent.bind(this);
    this.unsubscribeFromRoomEvent = this.unsubscribeFromRoomEvent.bind(this);
    this.unsubscribeFromSpecialEvent = this.unsubscribeFromSpecialEvent.bind(this);
    this.unsubscribeFromConnect = this.unsubscribeFromConnect.bind(this);
    this.unsubscribeFromLocalParticipantEvent = this.unsubscribeFromLocalParticipantEvent.bind(this);
    this.sendChatMessage = this.sendChatMessage.bind(this);
    this.kickParticipant = this.kickParticipant.bind(this);
    this.updateParticipant = this.updateParticipant.bind(this);
    this.muteTrackAsAdmin = this.muteTrackAsAdmin.bind(this);
    this._updateParticipants = this._updateParticipants.bind(this);
    this.subscribeToRoomEvent(dist$1.RoomEvent.ParticipantConnected, this._updateParticipants);
    this.subscribeToRoomEvent(dist$1.RoomEvent.ParticipantDisconnected, this._updateParticipants);
    this.subscribeToRoomEvent(dist$1.RoomEvent.TrackSubscribed, this._updateParticipants);
    this.subscribeToRoomEvent(dist$1.RoomEvent.TrackUnsubscribed, this._updateParticipants);
    this.subscribeToRoomEvent(dist$1.RoomEvent.LocalTrackPublished, this._updateParticipants);
    this.subscribeToRoomEvent(dist$1.RoomEvent.LocalTrackUnpublished, this._updateParticipants);
    this.subscribeToRoomEvent(dist$1.RoomEvent.Disconnected, () => {
      this.livekitRoom.removeAllListeners();
      this.livekitRoom = null;
      this._updateParticipants();
    });
  }
  bindApiClient(client) {
    this._apiClient = client;
  }
  get isAdmin() {
    const tokenData = o(this._jwt);
    return tokenData.video.roomAdmin;
  }
  set isAdmin(value) {
    log$1.warn("isAdmin cannot be set");
  }
  get token() {
    return this._jwt;
  }
  set token(value) {
    this._jwt = value;
  }
  get url() {
    return this._baseUrl;
  }
  set url(value) {
  }
  get chatHistory() {
    return this._chatHistory;
  }
  set chatHistory(value) {
    this._chatHistory = value;
  }
  _updateParticipants() {
    if (!this.livekitRoom || this.livekitRoom.state === dist$1.RoomState.Disconnected) {
      this.participants = [];
      return;
    } else {
      const remotes = Array.from(this.livekitRoom.participants.values());
      const parts = [this.livekitRoom.localParticipant];
      parts.push(...remotes);
      this.participants = parts;
    }
  }
  async kickParticipant(identity2) {
    if (this._admin) {
      this._admin.removeParticipant(this.roomName, identity2);
    } else {
      throw new Error("no admin permissions");
    }
  }
  updateParticipant(identity2, metadata) {
    if (this._admin) {
      const data2 = JSON.stringify(metadata);
      this._admin.updateParticipant(this.roomName, identity2, data2);
    } else {
      throw new Error("no admin permissions");
    }
  }
  muteTrackAsAdmin(trackSid, mute = true) {
    if (this._admin) {
      const participant = this.participants.find((p2) => [...p2.audioTracks.values(), ...p2.videoTracks.values()].find((pub) => pub.trackSid === trackSid));
      if (!participant) {
        log$1.warn("Could not find participant for track:", { trackSid });
        return;
      }
      this._admin.mutePublishedTrack(this.roomName, participant == null ? void 0 : participant.identity, trackSid, mute);
    } else {
      throw new Error("no admin permissions");
    }
  }
  _appendChat(payload, participant, kind) {
    const strData = decoder$1.decode(payload);
    const data2 = JSON.parse(strData);
    const sender = participant.identity;
    const displayName = participant.name;
    const fullData = { ...data2, displayName, sender };
    this.chatHistory = [...this.chatHistory, fullData];
    this._triggerSpecialEvents("Chat", fullData);
  }
  subscribeToConnect(listener) {
    this._connectListeners.push(listener);
    return () => this.unsubscribeFromConnect(listener);
  }
  unsubscribeFromConnect(listener) {
    this._connectListeners = this._connectListeners.filter((cb2) => cb2 !== listener);
  }
  subscribeToSpecialEvent(evt, listener) {
    if (!this._specialEventListenerRegistry[evt]) {
      this._specialEventListenerRegistry[evt] = /* @__PURE__ */ new Set();
    }
    this._specialEventListenerRegistry[evt].add(listener);
    return () => {
      this.unsubscribeFromSpecialEvent(evt, listener);
    };
  }
  unsubscribeFromSpecialEvent(evt, listener) {
    if (!this._specialEventListenerRegistry[evt]) {
      this._specialEventListenerRegistry[evt] = /* @__PURE__ */ new Set();
    }
    this._specialEventListenerRegistry[evt].delete(listener);
  }
  _triggerSpecialEvents(evt, ...args) {
    if (!this._specialEventListenerRegistry[evt]) {
      this._specialEventListenerRegistry[evt] = /* @__PURE__ */ new Set();
    }
    this._specialEventListenerRegistry[evt].forEach((listener) => {
      listener(...args);
    });
  }
  async connect(options2 = {}) {
    var _a2, _b;
    try {
      if (this.livekitRoom && this.livekitRoom.state === "connected") {
        return this.livekitRoom;
      }
      if (this.isConnecting)
        return null;
      this.isConnecting = true;
      this.livekitRoom = await dist$1.connect(`wss://${this._baseUrl}`, this._jwt, { logLevel: CoreContext.logLevel, ...options2 });
      this.isConnecting = false;
      Object.values(dist$1.RoomEvent).forEach((eventName) => {
        this.livekitRoom.on(eventName, (...args) => {
          this._roomEventListenerRegistry[eventName].forEach((cb2) => {
            cb2(...args);
          });
        });
      });
      Object.values(dist$1.ParticipantEvent).forEach((eventName) => {
        this.livekitRoom.localParticipant.on(eventName, (...args) => {
          this._localParticipantEventListenerRegistry[eventName].forEach((cb2) => {
            cb2(...args);
          });
        });
      });
      this._updateParticipants();
      this._connectListeners.forEach((cb2) => cb2(this.livekitRoom));
      if (lib$2.LiveKitUtils.isRoomAdmin(this._jwt)) {
        log$1.info("Room: Granting admin permissions");
        log$1.debug("Livekit server: ", (_a2 = this._apiClient) == null ? void 0 : _a2.getLiveKitServer(true));
        this._admin = new dist.RoomServiceClient((_b = this._apiClient) == null ? void 0 : _b.getLiveKitServer(true), void 0, void 0, this._jwt);
      } else {
        log$1.debug("Room: Not an admin");
      }
      return this.livekitRoom;
    } catch (err) {
      this.isConnecting = false;
      log$1.error(err);
    }
  }
  subscribeToLocalParticipantEvent(evt, listener) {
    if (!this._localParticipantEventListenerRegistry[evt]) {
      this._localParticipantEventListenerRegistry[evt] = /* @__PURE__ */ new Set();
    }
    this._localParticipantEventListenerRegistry[evt].add(listener);
    return () => {
      this.unsubscribeFromLocalParticipantEvent(evt, listener);
    };
  }
  unsubscribeFromLocalParticipantEvent(evt, listener) {
    if (!this._localParticipantEventListenerRegistry[evt]) {
      this._localParticipantEventListenerRegistry[evt] = /* @__PURE__ */ new Set();
    }
    this._localParticipantEventListenerRegistry[evt].delete(listener);
  }
  subscribeToRoomEvent(evt, listener) {
    if (!this._roomEventListenerRegistry[evt]) {
      this._roomEventListenerRegistry[evt] = /* @__PURE__ */ new Set();
    }
    this._roomEventListenerRegistry[evt].add(listener);
    return () => {
      this.unsubscribeFromRoomEvent(evt, listener);
    };
  }
  unsubscribeFromRoomEvent(evt, listener) {
    if (!this._roomEventListenerRegistry[evt]) {
      this._roomEventListenerRegistry[evt] = /* @__PURE__ */ new Set();
    }
    this._roomEventListenerRegistry[evt].delete(listener);
  }
  sendChatMessage(data2) {
    const { message, recipients, metadata } = data2;
    if (!this.livekitRoom || this.livekitRoom.state !== "connected") {
      return;
    }
    const messageObject = { type: "ChatMessage", recipients, metadata, content: message, timestamp: Date.now() };
    const strData = JSON.stringify(messageObject);
    const encodedData = encoder$1.encode(strData);
    ({ ...messageObject, sender: this.livekitRoom.localParticipant.identity, displayName: this.livekitRoom.localParticipant.identity });
    if (Boolean(recipients)) {
      const participants = recipients.map(this.livekitRoom.getParticipantByIdentity);
      return this.livekitRoom.localParticipant.publishData(encodedData, dist$1.DataPacket_Kind.RELIABLE, participants).then(() => {
        this._appendChat(encodedData, this.livekitRoom.localParticipant, dist$1.DataPacket_Kind.RELIABLE);
      });
    } else {
      return this.livekitRoom.localParticipant.publishData(encodedData, dist$1.DataPacket_Kind.RELIABLE).then(() => {
        this._appendChat(encodedData, this.livekitRoom.localParticipant, dist$1.DataPacket_Kind.RELIABLE);
      });
    }
  }
}
const webrtcManager = new RoomsManager();
const encoder = new TextEncoder();
const decoder = new TextDecoder();
const simpleRooms = /* @__PURE__ */ new Map();
const getRoom = (id2) => {
  if (!id2)
    return null;
  if (simpleRooms.get(id2))
    return simpleRooms.get(id2);
  const room = webrtcManager.rooms.get(id2);
  if (!room)
    return null;
  const livekit2 = room.livekitRoom;
  const localParticipant = livekit2.localParticipant;
  window.__StudioRoom = livekit2;
  if (!localParticipant)
    log$1.warn("No local participant!");
  const listeners2 = { useTracks: /* @__PURE__ */ new Set(), useTrack: /* @__PURE__ */ new Map(), useParticipants: /* @__PURE__ */ new Set(), useParticipant: /* @__PURE__ */ new Map(), useChatHistory: /* @__PURE__ */ new Set() };
  let latest = { tracks: [], participants: [], result: { participants: [], tracks: [] }, chat: room.chatHistory };
  const update = () => {
    const participants = room.participants;
    const tracks = participants.flatMap((participant) => participant.getTracks().map((pub) => ({ ...pub, participant })));
    const result = { participants: participants.map((x2) => {
      const meta = JSON.parse(x2.metadata);
      return { id: x2.identity, isSelf: x2 === localParticipant, connectionQuality: x2.connectionQuality, displayName: meta.displayName || x2.name, joinedAt: x2.joinedAt, role: meta.participantRole, meta, trackIds: tracks.filter((p2) => p2.participant.sid === x2.sid).map((x22) => x22.trackSid) };
    }), tracks: tracks.map((x2) => {
      var _a2, _b, _c;
      return { mediaStreamTrack: (_a2 = x2.track) == null ? void 0 : _a2.mediaStreamTrack, id: x2.trackSid, participantId: (_b = x2.participant) == null ? void 0 : _b.identity, isMuted: (_c = x2.track) == null ? void 0 : _c.isMuted, type: x2.source };
    }) };
    latest = { tracks, participants, result, chat: room.chatHistory };
    listeners2.useTracks.forEach((cb2) => cb2(result.tracks));
    listeners2.useTrack.forEach((id22, cb2) => {
      cb2(getTrack(id22));
    });
    listeners2.useParticipants.forEach((cb2) => cb2(result.participants));
    listeners2.useParticipant.forEach((id22, cb2) => {
      cb2(getParticipant(id22));
    });
    listeners2.useChatHistory.forEach((cb2) => {
      cb2(latest.chat);
    });
  };
  const updateEvents = [dist$1.RoomEvent.ParticipantConnected, dist$1.RoomEvent.ParticipantDisconnected, dist$1.RoomEvent.ParticipantMetadataChanged, dist$1.RoomEvent.Disconnected, dist$1.RoomEvent.TrackSubscribed, dist$1.RoomEvent.TrackUnsubscribed, dist$1.RoomEvent.LocalTrackPublished, dist$1.RoomEvent.LocalTrackUnpublished, dist$1.RoomEvent.ConnectionQualityChanged, dist$1.RoomEvent.TrackMuted, dist$1.RoomEvent.TrackUnmuted, dist$1.RoomEvent.TrackStreamStateChanged];
  const unsubscribers = updateEvents.map((evt) => room.subscribeToRoomEvent(evt, () => update()));
  unsubscribers.push(room.subscribeToSpecialEvent(SpecialEvent.Chat, update));
  const getTrack = (id22) => {
    return latest.result.tracks.find((x2) => x2.id === id22);
  };
  const getParticipant = (id22) => {
    return latest.result.participants.find((x2) => x2.id === id22);
  };
  const setTrackEnabled = (id22, enabled) => {
    const track = localParticipant.getTracks().find((x2) => {
      return x2.trackSid === id22;
    });
    if (track) {
      if (enabled) {
        track.mute();
      } else {
        track.unmute();
      }
    }
  };
  let settingCamera;
  let settingMic;
  const simpleRoom = { id: room.roomName, participantId: localParticipant.identity, setTrackEnabled, setCameraEnabled: (enabled = true) => {
    return localParticipant.setCameraEnabled(enabled);
  }, setMicrophoneEnabled: (enabled = true) => {
    return localParticipant.setMicrophoneEnabled(enabled);
  }, setCamera: async (options2 = {}) => {
    var _a2;
    if (settingCamera) {
      log$1.warn("Cannot set camera until previous has resolved");
      return;
    }
    settingCamera = true;
    let published;
    try {
      const existing = localParticipant.getTracks().find((x2) => {
        return x2.source === dist$1.Track.Source.Camera;
      });
      const tracks = await localParticipant.createTracks({ video: { deviceId: options2.deviceId, resolution: options2.resolution || { width: 1280, height: 720, frameRate: 30, aspectRatio: 16 / 9 } } });
      if (existing == null ? void 0 : existing.isMuted) {
        tracks.forEach((x2) => {
          x2.mute();
        });
      }
      published = await Promise.all(tracks.map((x2) => localParticipant.publishTrack(x2)));
      if (existing) {
        localParticipant.unpublishTrack(existing.track);
      }
    } catch (e2) {
      throw e2;
    } finally {
      settingCamera = false;
      return getTrack((_a2 = published[0]) == null ? void 0 : _a2.trackSid);
    }
  }, setMicrophone: async (options2) => {
    var _a2, _b;
    if (settingMic) {
      log$1.warn("Cannot set microphone until previous has resolved");
      return;
    }
    settingMic = true;
    let published;
    try {
      const existing = localParticipant.getTracks().find((x2) => {
        return x2.source === dist$1.Track.Source.Microphone;
      });
      const tracks = await localParticipant.createTracks({ audio: options2 || true });
      if (existing == null ? void 0 : existing.isMuted) {
        tracks.forEach((x2) => {
          x2.mute();
        });
      }
      published = await Promise.all(tracks.map((x2) => localParticipant.publishTrack(x2)));
      if (existing) {
        localParticipant.unpublishTrack(existing.track);
      }
      return getTrack((_a2 = published[0]) == null ? void 0 : _a2.trackSid);
    } catch (e2) {
      throw e2;
    } finally {
      settingMic = false;
      return getTrack((_b = published[0]) == null ? void 0 : _b.trackSid);
    }
  }, addCamera: async (options2 = {}) => {
    var _a2;
    const tracks = await localParticipant.createTracks({ video: { deviceId: options2.deviceId, resolution: options2.resolution || { width: 1280, height: 720, frameRate: 30, aspectRatio: 16 / 9 } } });
    const published = await Promise.all(tracks.map((x2) => localParticipant.publishTrack(x2)));
    settingMic = false;
    return getTrack((_a2 = published[0]) == null ? void 0 : _a2.trackSid);
  }, addScreen: async (options2 = { audio: false }) => {
    const tracks = await localParticipant.createScreenTracks(options2);
    const published = await Promise.all(tracks.map((x2) => localParticipant.publishTrack(x2)));
    const screen = published.find((x2) => x2.kind === "video");
    const audio = published.find((x2) => x2.kind === "audio");
    return { screen: getTrack(screen == null ? void 0 : screen.trackSid), audio: getTrack(audio == null ? void 0 : audio.trackSid) };
  }, removeTrack: async (id22) => {
    const track = latest.tracks.find((x2) => x2.trackSid === id22);
    localParticipant.unpublishTrack(track.track);
  }, setParticipantMetadata: (id22, meta) => {
    return room.updateParticipant(id22, meta);
  }, kickParticipant: room.kickParticipant, muteTrackAsAdmin: room.muteTrackAsAdmin, sendChatMessage: room.sendChatMessage, getTracks: () => latest.result.tracks, useTracks: (cb2) => {
    listeners2.useTracks.add(cb2);
    cb2(latest.result.tracks);
    return () => {
      listeners2.useTracks.delete(cb2);
    };
  }, getTrack, useTrack: (id22, cb2) => {
    listeners2.useTrack.set(cb2, id22);
    cb2(getTrack(id22));
    return () => {
      listeners2.useTrack.delete(cb2);
    };
  }, getParticipant, getParticipants: () => latest.result.participants, useParticipants: (cb2) => {
    listeners2.useParticipants.add(cb2);
    cb2(latest.result.participants);
    return () => {
      listeners2.useTracks.delete(cb2);
    };
  }, useParticipant: (id22, cb2) => {
    listeners2.useParticipant.set(cb2, id22);
    cb2(getParticipant(id22));
    return () => {
      listeners2.useTrack.delete(cb2);
    };
  }, useChatHistory: (cb2) => {
    listeners2.useChatHistory.add(cb2);
    cb2(latest.chat);
    return () => {
      listeners2.useChatHistory.delete(cb2);
    };
  }, useActiveSpeakers: (cb2) => {
    const fn = (activeSpeakers) => {
      cb2(activeSpeakers.map((x2) => x2.identity));
    };
    room.livekitRoom.on(dist$1.RoomEvent.ActiveSpeakersChanged, fn);
    fn(room.livekitRoom.activeSpeakers);
    return () => {
      var _a2;
      (_a2 = room.livekitRoom) == null ? void 0 : _a2.off(dist$1.RoomEvent.ActiveSpeakersChanged, fn);
    };
  }, sendData: (data2, recipientIds) => {
    const encoded = encoder.encode(JSON.stringify(data2));
    const participants = recipientIds == null ? void 0 : recipientIds.map((x2) => room.livekitRoom.getParticipantByIdentity(x2).sid);
    return localParticipant.publishData(encoded, dist$1.DataPacket_Kind.RELIABLE, participants);
  }, onData: (cb2) => {
    const fn = (encoded, participant) => {
      const data2 = JSON.parse(decoder.decode(encoded));
      cb2(data2, participant == null ? void 0 : participant.identity);
    };
    room.livekitRoom.on(dist$1.RoomEvent.DataReceived, fn);
    return () => {
      var _a2;
      (_a2 = room.livekitRoom) == null ? void 0 : _a2.off(dist$1.RoomEvent.DataReceived, fn);
    };
  }, connect: () => {
    return room.connect();
  }, disconnect: () => {
    return room.livekitRoom.disconnect();
  }, onDisconnected: (cb2) => {
    room.livekitRoom.on(dist$1.RoomEvent.Disconnected, cb2);
    return () => {
      var _a2;
      (_a2 = room.livekitRoom) == null ? void 0 : _a2.off(dist$1.RoomEvent.DataReceived, cb2);
    };
  }, setAudioOutput: (deviceId) => {
    return room.livekitRoom.switchActiveDevice("audiooutput", deviceId);
  } };
  update();
  simpleRooms.set(id2, simpleRoom);
  return simpleRoom;
};
lib$2.LiveApiModel.Rendering;
lib$2.LiveApiModel.VideoRendering;
lib$2.LiveApiModel.AudioRendering;
lib$2.LiveApiModel.RenderingQuality;
lib$2.LiveApiModel.Encoding;
lib$2.LiveApiModel.VideoEncoding;
lib$2.LiveApiModel.AudioEncoding;
const ProjectBroadcastPhase = lib$2.LiveApiModel.ProjectBroadcastPhase;
lib$2.LiveApiModel.Role;
lib$2.LiveApiModel.DestinationAddress;
lib$2.LiveApiModel.VideoCodec;
lib$2.LiveApiModel.AudioCodec;
lib$2.LiveApiModel.VideoCodecRateControl;
lib$2.LiveApiModel.VideoCodecProfile;
const { state: state$2 } = CoreContext;
const getAccessTokenData = () => {
  var _a2;
  return ((_a2 = CoreContext.clients.accessTokenClaims) == null ? void 0 : _a2.user) || {};
};
const getBaseUser = () => {
  if (!state$2.user)
    return null;
  return { id: state$2.user.id, props: state$2.user.props, name: state$2.user.name, projects: state$2.projects.map(toBaseProject), sources: state$2.sources.map(toBaseSource) };
};
const toBaseProject = (project) => {
  const { compositor: compositor2, videoApi, props = {}, role } = project;
  const { destinations, encoding, rendering, sources: sources2 } = videoApi.project;
  const scene = { get: compositor2.get, getRoot: compositor2.getRoot, getParent: compositor2.getParent };
  Object.defineProperty(scene, "nodes", { get() {
    return compositor2.nodes.filter((x2) => !x2._deleted);
  } });
  const broadcastPhase = project.videoApi.phase;
  const broadcastId = project.videoApi.broadcastId || null;
  return { broadcastPhase, role, broadcastId, isLive: [ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING, ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STOPPING].includes(broadcastPhase), scene, joinRoom: async (settings = {}) => {
    return CoreContext.Command.joinRoom({ projectId: project.id, ...settings });
  }, subscribe: (cb2) => CoreContext.subscribe((event2, payload) => {
    if (payload.projectId && (payload == null ? void 0 : payload.projectId) === project.id) {
      cb2(event2, payload);
    }
  }), ...{ destinations: destinations.map(toBaseDestination), sources: sources2.map(toBaseSource), encoding, rendering }, id: project.id, hostDisplayName: project.props.hostDisplayName, props };
};
const toBaseDestination = (destination) => {
  var _a2;
  return { id: destination.destinationId, enabled: destination.enabled, address: destination.address, props: ((_a2 = destination.metadata) == null ? void 0 : _a2.props) || (destination == null ? void 0 : destination.metadata) || {} };
};
const toBaseSource = (source2) => {
  var _a2;
  return { id: source2.sourceId, address: source2.address, props: ((_a2 = source2.metadata) == null ? void 0 : _a2.props) || {} };
};
const hydrateProject = async (project, role, size) => {
  const metadata = project.metadata || {};
  if (size) {
    await CoreContext.clients.LiveApi().project.updateProject({ collectionId: project.collectionId, projectId: project.projectId, rendering: { video: { width: size.x, height: size.y, framerate: 30 } }, updateMask: ["rendering"] });
  }
  const compositorProject = await layoutToProject(metadata.layoutId, size);
  return { id: project.projectId, compositor: compositorProject, role, videoApi: { project, phase: ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_UNSPECIFIED }, layoutApi: { layoutId: metadata.layoutId }, props: (metadata == null ? void 0 : metadata.props) || metadata };
};
const sceneNodeToLayer = (node) => {
  const { id: id2, props = {}, children = [] } = node;
  return { ...id2 ? { id: id2 } : {}, type: props.type, data: { ...props }, children: children.map((x2) => x2.id) };
};
const nodeToLayer = (node) => {
  return { id: node.id, type: node.props.type, data: { ...node.props }, children: node.childIds.map((x2) => x2) };
};
const layerToNode = (layer) => {
  return { id: String(layer.id), props: { type: layer.type, ...layer.data }, childIds: layer.children.map((x2) => String(x2)) };
};
const layoutToProject = async (layoutId, size) => {
  const { layers } = await CoreContext.clients.LayoutApi().layer.listLayers({ layoutId });
  if (size && layers) {
    const { x: x2, y: y2 } = size;
    const rootLayer = layers == null ? void 0 : layers.reduce((acc, x22) => {
      if (!acc)
        return x22;
      if (acc.data.isRoot)
        return acc;
      if (x22.data.isRoot)
        return x22;
      if (!layers.some((y22) => y22.children.includes(x22.id)))
        return x22;
      return acc;
    }, null);
    if (rootLayer) {
      const layer = await CoreContext.clients.LayoutApi().layer.updateLayer({ layoutId: rootLayer.layoutId, layerId: rootLayer.id, layer: { x: x2, y: y2, data: { ...rootLayer.data, size: { x: x2, y: y2 } } } });
      const layerIndex = layers.findIndex((l2) => l2.id === layer.id);
      layers[layerIndex] = layer;
    }
  }
  const dataNodes = layers.map(layerToNode);
  const rootNode = dataNodes.reduce((acc, x2) => {
    if (!acc)
      return x2;
    if (acc.props.isRoot)
      return acc;
    if (x2.props.isRoot)
      return x2;
    if (!dataNodes.some((y2) => y2.childIds.includes(x2.id)))
      return x2;
    return acc;
  }, null);
  const tree = rootNode ? toSceneTree(dataNodes, rootNode.id) : null;
  return CoreContext.compositor.loadProject(tree, layoutId);
};
const getUser = () => {
  const user = state$2.user;
  if (!user) {
    throw new Error("User not loaded");
  }
  return user;
};
const getProject = (id2) => {
  return state$2.projects.find((x2) => x2.id === id2);
};
const getProjectByLayoutId = (id2) => {
  return state$2.projects.find((x2) => x2.compositor.id === id2);
};
const getProjectRoom = (id2) => {
  var _a2;
  return getRoom((_a2 = getProject(id2)) == null ? void 0 : _a2.roomId);
};
const { connectionId } = CoreContext;
const latestUpdateVersion = {};
const getNextNodeVersion = (id2) => {
  if (!latestUpdateVersion[id2])
    latestUpdateVersion[id2] = 0;
  return ++latestUpdateVersion[id2];
};
const request = (layoutId, actions) => {
  const layers = actions.map((action) => {
    const [type, layer] = action;
    return { [type]: layer };
  });
  log$1.debug("Batch request", layers);
  return CoreContext.clients.LayoutApi().layer.batch({ layoutId, layers, requestMetadata: { connectionId, layoutId, updateVersions: actions.filter(([type]) => type === "update").map(([_, layer]) => ({ [layer.id]: getNextNodeVersion(layer.id) })).reduce((x2, acc) => ({ ...acc, ...x2 }), {}) } });
};
const compositorAdapter = (layoutId, methods) => ({ async insert(props = {}, parentId, index2) {
  const layer = nodeToLayer({ id: null, props, childIds: [] });
  if (!parentId) {
    layer.type = "root";
  } else {
    layer.type = "child";
  }
  log$1.debug("Insert layer", layer);
  const result = await CoreContext.clients.LayoutApi().layer.createLayer({ layoutId, layer: { ...layer, requestMetadata: { connectionId, layoutId } } });
  if (result.code)
    throw new Error(result.message);
  const parentNode = await methods.get(parentId);
  if (parentId && !parentNode)
    throw Error("Parent not found with ID");
  if (parentNode) {
    const parent2 = nodeToLayer(parentNode);
    const children = insertAt$1(index2, result.id, parent2.children);
    const update = { layoutId, layerId: parent2.id, layer: { children, requestMetadata: { connectionId, layoutId, updateVersion: { [layer.id]: getNextNodeVersion(layer.id) } } } };
    await CoreContext.clients.LayoutApi().layer.updateLayer(update);
  }
  return String(result.id);
}, async update(id2, props = {}) {
  const node = methods.get(id2);
  const layer = nodeToLayer({ ...node, props: { ...node.props, ...props } });
  const update = { layoutId, layerId: layer.id, layer: { ...layer, requestMetadata: { connectionId, layoutId, updateVersions: { [layer.id]: getNextNodeVersion(layer.id) } } } };
  log$1.debug("Update layer", update);
  await CoreContext.clients.LayoutApi().layer.updateLayer(update);
}, async remove(id2) {
  const parentNode = await methods.getParent(id2);
  if (parentNode) {
    const parent2 = nodeToLayer(parentNode);
    const children = parent2.children.filter((x2) => x2 !== id2);
    const update = { layoutId, layerId: parent2.id, layer: { children, requestMetadata: { connectionId, layoutId, updateVersions: { [parent2.id]: getNextNodeVersion(parent2.id) } } } };
    await CoreContext.clients.LayoutApi().layer.updateLayer(update);
  }
  await CoreContext.clients.LayoutApi().layer.deleteLayer({ layoutId, layerId: id2, payload: { requestMetadata: { connectionId, layoutId } } });
}, async reorder(id2, childIds) {
  const node = methods.get(id2);
  const layer = nodeToLayer({ ...node, childIds });
  log$1.debug("Reorder layer children", layer);
  await CoreContext.clients.LayoutApi().layer.updateLayer({ layoutId, layerId: layer.id, layer: { children: layer.children, requestMetadata: { connectionId, layoutId, updateVersions: { [layer.id]: getNextNodeVersion(layer.id) } } } });
}, async move(id2, newParentId, index2) {
  const node = methods.get(id2);
  const prevParentNode = methods.get(methods.getParent(id2).id);
  const prevParentLayer = nodeToLayer({ ...prevParentNode, childIds: pull$2(prevParentNode.childIds, node.id) });
  const newParentNode = methods.get(newParentId);
  const newParentLayer = nodeToLayer({ ...newParentNode, childIds: insertAt$1(index2, node.id, newParentNode.childIds) });
  log$1.debug("Move layers");
  await Promise.all([CoreContext.clients.LayoutApi().layer.updateLayer({ layoutId, layerId: prevParentLayer.id, layer: { children: prevParentLayer.children, requestMetadata: { connectionId, layoutId, updateVersions: { [prevParentLayer.id]: getNextNodeVersion(prevParentLayer.id) } } } }), CoreContext.clients.LayoutApi().layer.updateLayer({ layoutId, layerId: newParentLayer.id, layer: { children: newParentLayer.children, requestMetadata: { connectionId, layoutId, updateVersions: { [newParentLayer.id]: getNextNodeVersion(newParentLayer.id) } } } })]);
}, async batch(batch) {
  const layerBatch = batch.map(([type, node]) => [type, sceneNodeToLayer(node)]);
  const response = await request(layoutId, layerBatch);
  log$1.debug("Batch response", response);
  return response;
} });
var config$1 = (env) => ({ defaults: { previewTokenDuration: 1e3 * 60 * 60, guestTokenDuration: 1e3 * 60 * 60 * 12, transforms: { RoomParticipant: "LS-Room-Participant", Image: "LS-Image", Banner: "LS-Banner", Text: "LS-Text" } } });
const RoomParticipant$1 = { name: "LS-Room-Participant", sourceType: "RoomParticipant", props: { isMuted: { type: Boolean, required: false, default: false }, volume: { type: Number, required: false, default: 1 } }, useSource(sources2, props) {
  return sources2.find((x2) => isMatch(x2.props, props.sourceProps));
}, create({ onUpdate, onNewSource }, initialProps) {
  const root2 = document.createElement("div");
  Object.assign(root2.style, { position: "relative" });
  let source2;
  let props = initialProps;
  const getSize = (width, canvas) => {
    const widthAsPercentage = width / canvas.width;
    if (widthAsPercentage >= 0.5) {
      return 3;
    } else if (widthAsPercentage > 0.25) {
      return 2;
    } else if (widthAsPercentage > 0.15) {
      return 1;
    }
    return 0;
  };
  const Participant2 = ({ props: props2, source: source22 }) => {
    const { volume = 1, isHidden = false } = props2;
    const [labelSize, setLabelSize] = react$1.exports.useState(0);
    const ref2 = react$1.exports.useRef();
    const project = getProject(CoreContext.state.activeProjectId);
    const room = getRoom(CoreContext.state.activeProjectId);
    const isSelf = (source22 == null ? void 0 : source22.id) === (room == null ? void 0 : room.participantId);
    const muteAudio = isSelf || props2.isMuted;
    const hasVideo = !props2.isHidden && (source22 == null ? void 0 : source22.props.videoEnabled);
    react$1.exports.useEffect(() => {
      if (!ref2.current)
        return;
      ref2.current.play().catch((e2) => {
        document.addEventListener("click", () => {
          var _a2;
          return (_a2 = ref2.current) == null ? void 0 : _a2.play();
        }, { once: true });
      });
      if ((source22 == null ? void 0 : source22.value) && (source22 == null ? void 0 : source22.value) !== ref2.current.srcObject) {
        ref2.current.srcObject = source22.value;
      } else if (!(source22 == null ? void 0 : source22.value)) {
        ref2.current.srcObject = null;
      }
    }, [ref2.current, source22 == null ? void 0 : source22.value]);
    react$1.exports.useLayoutEffect(() => {
      if (!ref2.current)
        return;
      const calculate = () => {
        const rect = ref2.current;
        setLabelSize(getSize(rect.clientWidth, { width: project.compositor.getRoot().props.size.x, height: project.compositor.getRoot().props.size.y }));
      };
      const resizeObserver2 = new ResizeObserver((entries) => {
        calculate();
      });
      calculate();
      resizeObserver2.observe(ref2.current);
      return () => {
        resizeObserver2.unobserve(ref2.current);
      };
    }, [ref2.current, project]);
    react$1.exports.useEffect(() => {
      if (!ref2.current)
        return;
      ref2.current.volume = volume;
    }, [ref2.current, volume]);
    return /* @__PURE__ */ jsxs("div", { style: { position: "relative", display: "flex", height: "100%", width: "100%" }, children: [/* @__PURE__ */ jsx("div", { style: { background: "#222", position: "absolute", height: "100%", width: "100%", fontSize: "43px", color: "rgba(255,255,255,0.6)", display: "flex", alignItems: "center", justifyContent: "center", opacity: hasVideo ? "0" : "1" }, children: (source22 == null ? void 0 : source22.props.displayName) && /* @__PURE__ */ jsx("div", { style: { borderRadius: "50%", background: "#555", width: "70px", height: "70px", textTransform: "uppercase", display: "flex", alignItems: "center", justifyContent: "center", lineHeight: "1em" }, children: (source22 == null ? void 0 : source22.props.displayName.slice(0, 1)) || "" }) }), /* @__PURE__ */ jsx("video", { ref: ref2, autoPlay: true, muted: muteAudio, disablePictureInPicture: true, playsInline: true, style: { left: "50%", top: "50%", position: "relative", transform: "translate3d(-50%, -50%, 0)", height: "100%", opacity: hasVideo ? "1" : "0", objectFit: (source22 == null ? void 0 : source22.props.type) === "screen" ? "contain" : "cover", background: "rgba(0,0,0,0.6)" } }), (source22 == null ? void 0 : source22.props.displayName) && /* @__PURE__ */ jsx("div", { className: "NameBannerContainer", style: { width: "100%", height: "100%", position: "absolute" }, children: /* @__PURE__ */ jsx("div", { className: "NameBanner", "data-size": labelSize, style: { padding: "12px 30px", width: "fit-content", height: "fit-content", top: "100%", transform: "translateY(-100%)", left: 0 }, children: /* @__PURE__ */ jsx("div", { className: "NameBanner-body", children: source22.props.displayName }) }) })] });
  };
  const render2 = () => ReactDOM.render(/* @__PURE__ */ jsx(Participant2, { source: source2, props }), root2);
  onUpdate((_props) => {
    props = _props;
    render2();
  });
  onNewSource((_source) => {
    source2 = _source;
    render2();
  });
  return { root: root2 };
} };
const Square = { name: "LS-Square", props: { color: { default: "green" } }, create({ onUpdate }) {
  const el = document.createElement("div");
  onUpdate(({ color: color2 }) => {
    Object.assign(el.style, { width: "100%", height: "100%", background: color2 || "red" });
  });
  return { root: el };
} };
const Image$2 = { name: "LS-Image", props: { src: {}, fit: {} }, create({ onUpdate }) {
  const el = document.createElement("img");
  onUpdate(({ src, fit }) => {
    el.setAttribute("src", src);
    Object.assign(el.style, { width: "100%", height: "100%", objectFit: fit });
  });
  return { root: el };
} };
function _objectWithoutPropertiesLoose(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source2);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source2[key];
  }
  return target;
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p22) {
    o3.__proto__ = p22;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function hasClass(element, className) {
  if (element.classList)
    return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
function addClass(element, className) {
  if (element.classList)
    element.classList.add(className);
  else if (!hasClass(element, className))
    if (typeof element.className === "string")
      element.className = element.className + " " + className;
    else
      element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}
var config$3 = { disabled: false };
var TransitionGroupContext = React.createContext(null);
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context2) {
    var _this;
    _this = _React$Component.call(this, props, context2) || this;
    var parentGroup = context2;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = { status: initialStatus };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return { status: EXITED };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return { exit, enter, appear };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({ status: UNMOUNTED });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config$3.disabled) {
      this.safeSetState({ status: ENTERED }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({ status: ENTERING }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({ status: ENTERED }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config$3.disabled) {
      this.safeSetState({ status: EXITED }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({ status: EXITING }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({ status: EXITED }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event2) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event2);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render2() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return /* @__PURE__ */ jsx(TransitionGroupContext.Provider, { value: null, children: typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps) });
  };
  return Transition2;
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop() {
}
Transition.defaultProps = { in: false, mountOnEnter: false, unmountOnExit: false, appear: false, enter: true, exit: true, onEnter: noop, onEntering: noop, onEntered: noop, onExit: noop, onExiting: noop, onExited: noop };
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition$1 = Transition;
var _addClass = function addClass$1(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return addClass(node, c);
  });
};
var removeClass = function removeClass2(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return removeClass$1(node, c);
  });
};
var CSSTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = { appear: {}, enter: {}, exit: {} };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node, "exit");
      _this.addClass(node, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node, type);
      _this.addClass(node, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
      _this.removeClasses(node, "appear");
      _this.removeClasses(node, "enter");
      _this.addClass(node, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
      _this.addClass(node, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
      _this.removeClasses(node, "exit");
      _this.addClass(node, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === "string";
      var prefix = isStringClassNames && classNames ? classNames + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return { baseClassName, activeClassName, doneClassName };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass2(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      node && node.scrollTop;
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node, className);
    }
  };
  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass(node, baseClassName);
    }
    if (activeClassName) {
      removeClass(node, activeClassName);
    }
    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };
  _proto.render = function render2() {
    var _this$props = this.props;
    _this$props.classNames;
    var props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
    return /* @__PURE__ */ jsx(Transition$1, { ...props, onEnter: this.onEnter, onEntered: this.onEntered, onEntering: this.onEntering, onExit: this.onExit, onExiting: this.onExiting, onExited: this.onExited });
  };
  return CSSTransition2;
}(React.Component);
CSSTransition.defaultProps = { classNames: "" };
CSSTransition.propTypes = {};
var CSSTransition$1 = CSSTransition;
var _leaveRenders, _enterRenders;
function areChildrenDifferent(oldChildren, newChildren) {
  if (oldChildren === newChildren)
    return false;
  if (React.isValidElement(oldChildren) && React.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
    return false;
  }
  return true;
}
var modes = { out: "out-in", in: "in-out" };
var callHook = function callHook2(element, name2, cb2) {
  return function() {
    var _element$props;
    element.props[name2] && (_element$props = element.props)[name2].apply(_element$props, arguments);
    cb2();
  };
};
var leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(_ref) {
  var current = _ref.current, changeState = _ref.changeState;
  return React.cloneElement(current, { in: false, onExited: callHook(current, "onExited", function() {
    changeState(ENTERING, null);
  }) });
}, _leaveRenders[modes.in] = function(_ref2) {
  var current = _ref2.current, changeState = _ref2.changeState, children = _ref2.children;
  return [current, React.cloneElement(children, { in: true, onEntered: callHook(children, "onEntered", function() {
    changeState(ENTERING);
  }) })];
}, _leaveRenders);
var enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(_ref3) {
  var children = _ref3.children, changeState = _ref3.changeState;
  return React.cloneElement(children, { in: true, onEntered: callHook(children, "onEntered", function() {
    changeState(ENTERED, React.cloneElement(children, { in: true }));
  }) });
}, _enterRenders[modes.in] = function(_ref4) {
  var current = _ref4.current, children = _ref4.children, changeState = _ref4.changeState;
  return [React.cloneElement(current, { in: false, onExited: callHook(current, "onExited", function() {
    changeState(ENTERED, React.cloneElement(children, { in: true }));
  }) }), React.cloneElement(children, { in: true })];
}, _enterRenders);
var SwitchTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(SwitchTransition2, _React$Component);
  function SwitchTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = { status: ENTERED, current: null };
    _this.appeared = false;
    _this.changeState = function(status, current) {
      if (current === void 0) {
        current = _this.state.current;
      }
      _this.setState({ status, current });
    };
    return _this;
  }
  var _proto = SwitchTransition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
  };
  SwitchTransition2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state2) {
    if (props.children == null) {
      return { current: null };
    }
    if (state2.status === ENTERING && props.mode === modes.in) {
      return { status: ENTERING };
    }
    if (state2.current && areChildrenDifferent(state2.current, props.children)) {
      return { status: EXITING };
    }
    return { current: React.cloneElement(props.children, { in: true }) };
  };
  _proto.render = function render2() {
    var _this$props = this.props, children = _this$props.children, mode = _this$props.mode, _this$state = this.state, status = _this$state.status, current = _this$state.current;
    var data2 = { children, current, changeState: this.changeState, status };
    var component;
    switch (status) {
      case ENTERING:
        component = enterRenders[mode](data2);
        break;
      case EXITING:
        component = leaveRenders[mode](data2);
        break;
      case ENTERED:
        component = current;
    }
    return /* @__PURE__ */ jsx(TransitionGroupContext.Provider, { value: { isMounting: !this.appeared }, children: component });
  };
  return SwitchTransition2;
}(React.Component);
SwitchTransition.propTypes = {};
SwitchTransition.defaultProps = { mode: modes.out };
var SwitchTransition$1 = SwitchTransition;
const Animations = { "fade-in": ".fade-in{-webkit-animation:fade-in;animation:fade-in}@-webkit-keyframes fade-in{0%{opacity:0}100%{opacity:1}}@keyframes fade-in{0%{opacity:0}100%{opacity:1}}", "fade-out": ".fade-out{-webkit-animation:fade-out;animation:fade-out}@-webkit-keyframes fade-out{0%{opacity:1}100%{opacity:0}}@keyframes fade-out{0%{opacity:1}100%{opacity:0}}", "slide-in-blurred-top": ".slide-in-blurred-top{-webkit-animation:slide-in-blurred-top .6s cubic-bezier(.23,1.000,.32,1.000) both;animation:slide-in-blurred-top .6s cubic-bezier(.23,1.000,.32,1.000) both}@-webkit-keyframes slide-in-blurred-top{0%{-webkit-transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform:translateY(-1000px) scaleY(2.5) scaleX(.2);-webkit-transform-origin:50% 0;transform-origin:50% 0;-webkit-filter:blur(40px);filter:blur(40px);opacity:0}100%{-webkit-transform:translateY(0) scaleY(1) scaleX(1);transform:translateY(0) scaleY(1) scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-filter:blur(0);filter:blur(0);opacity:1}}@keyframes slide-in-blurred-top{0%{-webkit-transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform:translateY(-1000px) scaleY(2.5) scaleX(.2);-webkit-transform-origin:50% 0;transform-origin:50% 0;-webkit-filter:blur(40px);filter:blur(40px);opacity:0}100%{-webkit-transform:translateY(0) scaleY(1) scaleX(1);transform:translateY(0) scaleY(1) scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-filter:blur(0);filter:blur(0);opacity:1}}" };
const APIKitAnimation = (props) => {
  const { enter, exit, children, tag = "div", direction = "normal", duration = 500, id: id2, type } = props;
  const keyId = id2 ? `${type}-${id2}` : `${type}-api-kit-animation`;
  return /* @__PURE__ */ jsxs("div", { style: { height: "100%", width: "100%" }, children: [/* @__PURE__ */ jsx("style", { dangerouslySetInnerHTML: { __html: renderStyle(type, enter, exit, duration, direction) } }), /* @__PURE__ */ jsx(SwitchTransition$1, { mode: "out-in", children: /* @__PURE__ */ jsx(CSSTransition$1, { addEndListener: (node, done) => {
    node.addEventListener("transitionend", done, false);
  }, classNames: { enter: `${type}-default-enter`, enterActive: enter, exit: `${type}-default-leave`, exitActive: exit }, timeout: duration, children: /* @__PURE__ */ jsx("div", { style: { height: "100%", width: "100%" }, children }) }, keyId) })] });
};
const renderStyle = (type, enter, exit, duration, direction) => {
  return `
        body {
          margin: 0;
          padding: 0;
        }
        
        ${Animations[enter]}
        
        ${Animations[exit]}

        .${type}-transition {
          transition: opacity ${duration}ms ease-out};
        }

        .${type}-default-enter {
          opacity: 0;
        }

        .${type}-default-enter.${enter} {
          animation-direction: ${direction};
          animation-duration: ${duration / 1e3}s;
          animation-fill-mode: both;
          animation-timing-function: ease-out;
        }

        .${type}-default-leave {
          opacity: 1;
        }

        .${type}-default-leave.${exit} {
          animation-direction: ${direction};
          animation-duration: ${duration / 1e3}s;
          animation-timing-function: ease-out;
          animation-fill-mode: both;
        }
        `;
};
var APIKitAnimationTypes = /* @__PURE__ */ ((APIKitAnimationTypes2) => {
  APIKitAnimationTypes2["FADE_IN"] = "fade-in";
  APIKitAnimationTypes2["FADE_OUT"] = "fade-out";
  APIKitAnimationTypes2["SLIDE_IN_BLURRED_TOP"] = "slide-in-blurred-top";
  return APIKitAnimationTypes2;
})(APIKitAnimationTypes || {});
const SourceTriggerMap = [{ sourceType: "Overlay", trigger: "OverlayMetadataUpdate" }, { sourceType: "Background", trigger: "BackgroundMetadataUpdate" }];
const Video2 = { name: "LS-Video-2", sourceType: "Video2", props: { id: { type: String, required: true } }, useSource(sources2, props) {
  return sources2.find((x2) => x2.props.type === props.id);
}, create({ onUpdate, onNewSource, onRemove }, initialProps) {
  onRemove(() => {
    clearInterval(interval);
  });
  const root2 = document.createElement("div");
  const room = getProjectRoom(CoreContext.state.activeProjectId);
  const role = getProject(CoreContext.state.activeProjectId).role;
  let source2;
  let interval;
  const Video3 = ({ source: source22 }) => {
    const SourceTrigger = SourceTriggerMap.find((x2) => x2.sourceType === initialProps.proxySource);
    const { src, type, meta, loop } = (source22 == null ? void 0 : source22.value) || {};
    const { id: id2 } = source22 || {};
    const [refId, setRefId] = React.useState(null);
    const videoRef = React.useRef(null);
    const onLoadedData = React.useCallback(() => {
      if (videoRef == null ? void 0 : videoRef.current) {
        videoRef.current.play().catch(() => {
          var _a2;
          videoRef.current.muted = true;
          (_a2 = videoRef.current) == null ? void 0 : _a2.play();
        });
      }
    }, [src, videoRef]);
    const onEnded = React.useCallback(() => {
      if (interval) {
        clearInterval(interval);
      }
      trigger$1("VideoEnded", { id: id2, category: type });
    }, [src]);
    React.useEffect(() => {
      if (meta) {
        if ((room == null ? void 0 : room.participantId) !== (meta == null ? void 0 : meta.owner) && (videoRef == null ? void 0 : videoRef.current)) {
          videoRef.current.currentTime = (meta == null ? void 0 : meta.time) || 0;
        }
      }
    }, [meta, videoRef]);
    React.useEffect(() => {
      return room == null ? void 0 : room.onData((event2, senderId) => {
        var _a2, _b;
        if ((_a2 = videoRef == null ? void 0 : videoRef.current) == null ? void 0 : _a2.currentTime) {
          if (event2.type === "UserJoined" && senderId !== (room == null ? void 0 : room.participantId)) {
            triggerInternal$1(SourceTrigger.trigger, { projectId: CoreContext.state.activeProjectId, role, sourceId: id2, doTrigger: true, metadata: { time: Math.floor((_b = videoRef == null ? void 0 : videoRef.current) == null ? void 0 : _b.currentTime) || 0, owner: room == null ? void 0 : room.participantId } });
          }
        }
      });
    }, [videoRef]);
    const handleRect = React.useCallback((node) => {
      videoRef.current = node;
      setRefId(node ? node.id : null);
    }, []);
    React.useEffect(() => {
      return () => {
        if (interval) {
          clearInterval(interval);
        }
      };
    }, [id2]);
    React.useEffect(() => {
      var _a2;
      if (!refId) {
        if (interval) {
          clearInterval(interval);
        }
      } else {
        if (videoRef.current) {
          videoRef.current.src = src;
          if (loop) {
            videoRef.current.loop = Boolean(loop);
          }
          videoRef.current.play().catch(() => {
            videoRef.current.muted = true;
            videoRef.current.play();
          });
          interval = setInterval(() => {
            if (videoRef.current.duration) {
              const timePending = videoRef.current.duration - videoRef.current.currentTime;
              trigger$1("VideoTimeUpdate", { category: type, id: id2, time: Math.floor(timePending) });
            }
          }, 1e3);
          triggerInternal$1(SourceTrigger.trigger, { projectId: CoreContext.state.activeProjectId, role, sourceId: id2, doTrigger: true, metadata: { time: Math.floor((_a2 = videoRef == null ? void 0 : videoRef.current) == null ? void 0 : _a2.currentTime) || 0, owner: room == null ? void 0 : room.participantId } });
        }
      }
    }, [refId]);
    return /* @__PURE__ */ jsx(APIKitAnimation, { id: id2, type: "video", enter: APIKitAnimationTypes.FADE_IN, exit: APIKitAnimationTypes.FADE_OUT, duration: 400, children: src && /* @__PURE__ */ jsx("video", { id: id2, ref: handleRect, style: initialProps.style, ...initialProps.props, onLoadedData, onEnded }) });
  };
  const render2 = () => ReactDOM.render(/* @__PURE__ */ jsx(Video3, { source: source2 }), root2);
  onUpdate(() => {
    render2();
  });
  onNewSource((_source) => {
    source2 = _source;
    render2();
  });
  return { root: root2 };
} };
const Image2 = { name: "LS-Image-2", sourceType: "Image2", props: { id: { type: String, required: true } }, useSource(sources2, props) {
  return sources2.find((x2) => x2.props.type === props.id);
}, create({ onUpdate, onNewSource }, initialProps) {
  const root2 = document.createElement("div");
  let source2;
  const Image3 = ({ source: source22 }) => {
    const { src, meta } = (source22 == null ? void 0 : source22.value) || {};
    const { id: id2 } = source22 || {};
    return /* @__PURE__ */ jsx(APIKitAnimation, { id: id2, type: "image", enter: APIKitAnimationTypes.FADE_IN, exit: APIKitAnimationTypes.FADE_OUT, duration: 400, children: src && /* @__PURE__ */ jsx("img", { style: { ...initialProps == null ? void 0 : initialProps.style, ...meta == null ? void 0 : meta.style }, className: "image-transition", src }) });
  };
  const render2 = () => ReactDOM.render(/* @__PURE__ */ jsx(Image3, { source: source2 }), root2);
  onUpdate(() => {
    render2();
  });
  onNewSource((_source) => {
    source2 = _source;
    render2();
  });
  return { root: root2 };
} };
const Element = { name: "Element", sourceType: "Element", create({ onUpdate }, { tagName: tagName2 }) {
  const el = document.createElement(tagName2);
  onUpdate(({ tagName: tagName22, attributes = {}, fields = {} }) => {
    if (tagName22 === "img") {
      if ((el == null ? void 0 : el.src) !== attributes["src"]) {
        Object.keys(attributes).forEach((attr) => {
          el.setAttribute(attr, attributes[attr]);
        });
      }
    } else {
      Object.keys(attributes).forEach((attr) => {
        el.setAttribute(attr, attributes[attr]);
      });
    }
    Object.keys(fields).forEach((field) => {
      Object.assign(el[field], fields[field]);
    });
  });
  return { root: el };
} };
const Video = { name: "LS-Video", sourceType: "LS-Video", create({ onUpdate, onEvent, onRemove }) {
  onRemove(() => {
    clearInterval(interval);
  });
  const el = document.createElement("video");
  let interval;
  onUpdate(({ attributes = {}, fields = {}, sourceProps = {}, id: id2 }) => {
    if (el.src !== attributes["src"] || el.id !== attributes["id"] && attributes["id"]) {
      if (interval) {
        clearInterval(interval);
      }
      Object.keys(attributes).forEach((attr) => {
        el.setAttribute(attr, attributes[attr]);
      });
      el.onloadedmetadata = () => {
        if (attributes["muted"]) {
          el.muted = true;
          el.play();
        } else {
          el.muted = false;
        }
      };
      interval = setInterval(() => {
        if (el.duration) {
          const timePending = el.duration - el.currentTime;
          trigger$1("VideoTimeUpdate", { category: id2, id: sourceProps == null ? void 0 : sourceProps.id, time: Math.floor(timePending) });
        }
      }, 1e3);
      el.loop = Boolean(attributes["loop"]);
      el.onended = () => {
        if (interval) {
          clearInterval(interval);
        }
        trigger$1("VideoEnded", { id: sourceProps == null ? void 0 : sourceProps.id, category: id2 });
      };
      Object.keys(fields).forEach((field) => {
        Object.assign(el[field], fields[field]);
      });
    }
  });
  return { root: el };
} };
const Banner$1 = { name: "LS-Banner", sourceType: "Banner", props: { bannerId: { type: String, required: true } }, useSource(sources2, props) {
  return sources2.find((x2) => x2.id === props.bannerId);
}, create({ onUpdate, onNewSource }, initialProps) {
  const root2 = document.createElement("div");
  let source2;
  let latestSource;
  let previousSource;
  const Banner2 = ({ currentSource, latestSource: latestSource2 }) => {
    const [rendered, setRendered] = react$1.exports.useState(false);
    const { headerText, bodyText } = (latestSource2 == null ? void 0 : latestSource2.value) || {};
    react$1.exports.useEffect(() => {
      window.setTimeout(() => {
        setRendered(Boolean(currentSource));
      });
      if (!currentSource)
        setRendered(false);
    }, [currentSource]);
    return /* @__PURE__ */ jsx("div", { className: "BannerContainer", style: { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", display: "flex", flexDirection: "row", justifyContent: "flex-start", alignItems: "flex-end", transition: "200ms ease all", ...!rendered ? { zIndex: 1, opacity: 0, transform: "translateX(-200px)" } : { zIndex: 2, opacity: 1, transform: "translateX(0)" } }, children: /* @__PURE__ */ jsxs("div", { className: "Banner", style: { padding: 10, background: "orange", width: "fit-content", height: "fit-content", maxWidth: "84%", position: "relative" }, children: [headerText && /* @__PURE__ */ jsx("div", { className: "Banner-header", style: { marginBottom: 6 }, children: headerText }), bodyText && /* @__PURE__ */ jsx("div", { className: "Banner-body", children: bodyText })] }) });
  };
  const render2 = () => ReactDOM.render(/* @__PURE__ */ jsxs(Fragment, { children: [previousSource && previousSource.id !== latestSource.id && /* @__PURE__ */ jsx(Banner2, { currentSource: null, latestSource: previousSource }, previousSource == null ? void 0 : previousSource.id), /* @__PURE__ */ jsx(Banner2, { currentSource: source2, latestSource }, latestSource == null ? void 0 : latestSource.id)] }), root2);
  onUpdate(() => {
    render2();
  });
  onNewSource((_source) => {
    previousSource = source2;
    source2 = _source;
    if (source2) {
      latestSource = source2;
    }
    render2();
  });
  return { root: root2 };
} };
const Logo$1 = { name: "LS-Logo", sourceType: "Logo", props: { id: { type: String, required: true } }, useSource(sources2, props) {
  return sources2.find((x2) => x2.props.type === props.id);
}, create({ onUpdate, onNewSource }, initialProps) {
  const root2 = document.createElement("div");
  let source2;
  const Logo2 = ({ source: source22 }) => {
    const { src, meta, logoPosition } = (source22 == null ? void 0 : source22.value) || {};
    const { id: id2 } = source22 || {};
    return /* @__PURE__ */ jsx(APIKitAnimation, { type: "logo", id: id2, enter: APIKitAnimationTypes.FADE_IN, exit: APIKitAnimationTypes.FADE_OUT, duration: 400, children: src && /* @__PURE__ */ jsx("div", { className: "logo wrapper", children: /* @__PURE__ */ jsx("img", { style: { ...initialProps == null ? void 0 : initialProps.style, ...meta == null ? void 0 : meta.style }, src }) }) });
  };
  const render2 = () => ReactDOM.render(/* @__PURE__ */ jsx(Logo2, { source: source2 }), root2);
  onUpdate(() => {
    render2();
  });
  onNewSource((_source) => {
    source2 = _source;
    render2();
  });
  return { root: root2 };
} };
const Iframe = ({ url: url2, allowFullScreen, position, display, height, width, overflow, styles, onLoad, id: id2, frameBorder, className, name: name2, target, iframeRef, children, src }) => {
  const defaultProps = Object.assign({ src: src || url2, target: target || null, style: { position: position || null, display: display || "block", overflow: overflow || null, ...styles }, name: name2 || null, className: className || null, id: id2 || null, onLoad: onLoad || null, height: height || "100%", width: width || "100%", allow: "autoplay" });
  let props = /* @__PURE__ */ Object.create(null);
  for (let prop of Object.keys(defaultProps)) {
    if (defaultProps[prop] != null) {
      props[prop] = defaultProps[prop];
    }
  }
  for (let i2 of Object.keys(props.style)) {
    if (props.style[i2] == null) {
      delete props.style[i2];
    }
  }
  if (allowFullScreen) {
    if ("allow" in props) {
      const currentAllow = props.allow.replace("fullscreen", "");
      props.allow = `fullscreen ${currentAllow.trim()}`.trim();
    } else {
      props.allow = "fullscreen";
    }
  }
  if (frameBorder >= 0) {
    if (!props.style.hasOwnProperty("border")) {
      props.style.border = frameBorder;
    }
  }
  return /* @__PURE__ */ jsx(APIKitAnimation, { id: id2, type: "image", enter: APIKitAnimationTypes.FADE_IN, exit: APIKitAnimationTypes.FADE_OUT, duration: 400, children: children ? /* @__PURE__ */ jsx("iframe", { ref: iframeRef, ...props, children }) : /* @__PURE__ */ jsx("iframe", { ref: iframeRef, ...props }) });
};
const Image$1 = ({ source: source2, initialProps }) => {
  const { src, meta } = (source2 == null ? void 0 : source2.value) || {};
  const { id: id2 } = source2 || {};
  return /* @__PURE__ */ jsx(APIKitAnimation, { id: id2, type: "image", enter: APIKitAnimationTypes.FADE_IN, exit: APIKitAnimationTypes.FADE_OUT, duration: 400, children: src && /* @__PURE__ */ jsx("img", { style: { ...initialProps == null ? void 0 : initialProps.style, ...meta == null ? void 0 : meta.style }, className: "image-transition", src }) });
};
const Overlay = { name: "LS-Overlay", sourceType: "Overlay", props: { id: { type: String, required: true } }, useSource(sources2, props) {
  return sources2.find((x2) => x2.props.type === props.id);
}, create({ onUpdate, onNewSource }, initialProps) {
  const root2 = document.createElement("div");
  let source2;
  const IFrame = ({ source: source22 }) => {
    const { src, meta, height, width } = (source22 == null ? void 0 : source22.value) || {};
    const iframeRef = React.useRef(null);
    react$1.exports.useEffect(() => {
      if (iframeRef.current) {
        iframeRef.current.style.removeProperty("transformOrigin");
        iframeRef.current.style.removeProperty("transform");
        iframeRef.current.style.opacity = "0";
      }
    }, [src]);
    const resizeIframe = () => {
      if (iframeRef.current) {
        const project = getProject(CoreContext.state.activeProjectId);
        const root22 = project.compositor.getRoot();
        const { x: rootWidth, y: rootHeight } = root22.props.size;
        let iframeWidth = iframeRef.current.clientWidth;
        let iframeHeight = iframeRef.current.clientHeight;
        let scale;
        if (iframeWidth && iframeHeight) {
          scale = Math.min(rootWidth / iframeWidth, rootHeight / iframeHeight);
        } else {
          scale = 1;
        }
        iframeRef.current.style.willChange = `transform`;
        iframeRef.current.style.transformOrigin = "0 0";
        iframeRef.current.style.transform = `scale(${scale}) translateZ(0)`;
        iframeRef.current.style.opacity = "1";
      }
    };
    return /* @__PURE__ */ jsxs(Fragment, { children: [(meta == null ? void 0 : meta.type) === "html-overlay" && /* @__PURE__ */ jsx(Iframe, { url: src, frameBorder: 0, iframeRef, height, width, onLoad: resizeIframe, styles: { ...meta == null ? void 0 : meta.style, opacity: 0 } }), (meta == null ? void 0 : meta.type) === "image-overlay" && /* @__PURE__ */ jsx(Image$1, { source: source22, initialProps })] });
  };
  const render2 = () => ReactDOM.render(/* @__PURE__ */ jsx(IFrame, { source: source2 }), root2);
  onUpdate(() => {
    render2();
  });
  onNewSource((_source) => {
    source2 = _source;
    render2();
  });
  return { root: root2 };
} };
var Transforms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, RoomParticipant: RoomParticipant$1, Square, Image: Image$2, Video2, Image2, Element, Video, Banner: Banner$1, Logo: Logo$1, Overlay }, Symbol.toStringTag, { value: "Module" }));
/*! (c) Andrea Giammarchi - ISC */
var self$1 = {};
try {
  self$1.WeakMap = WeakMap;
} catch (WeakMap2) {
  self$1.WeakMap = function(id2, Object2) {
    var dP = Object2.defineProperty;
    var hOP = Object2.hasOwnProperty;
    var proto = WeakMap3.prototype;
    proto.delete = function(key) {
      return this.has(key) && delete key[this._];
    };
    proto.get = function(key) {
      return this.has(key) ? key[this._] : void 0;
    };
    proto.has = function(key) {
      return hOP.call(key, this._);
    };
    proto.set = function(key, value) {
      dP(key, this._, { configurable: true, value });
      return this;
    };
    return WeakMap3;
    function WeakMap3(iterable) {
      dP(this, "_", { value: "_@ungap/weakmap" + id2++ });
      if (iterable)
        iterable.forEach(add, this);
    }
    function add(pair) {
      this.set(pair[0], pair[1]);
    }
  }(Math.random(), Object);
}
var WeakMap$1 = self$1.WeakMap;
/*! (c) Andrea Giammarchi - ISC */
var UID = "-" + Math.random().toFixed(6) + "%";
var UID_IE = false;
try {
  if (!function(template, content, tabindex) {
    return content in template && (template.innerHTML = "<p " + tabindex + '="' + UID + '"></p>', template[content].childNodes[0].getAttribute(tabindex) == UID);
  }(document.createElement("template"), "content", "tabindex")) {
    UID = "_dt: " + UID.slice(1, -1) + ";";
    UID_IE = true;
  }
} catch (meh) {
}
var UIDC = "<!--" + UID + "-->";
var COMMENT_NODE = 8;
var ELEMENT_NODE$1 = 1;
var TEXT_NODE = 3;
var SHOULD_USE_TEXT_CONTENT = /^(?:plaintext|script|style|textarea|title|xmp)$/i;
var VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;
/*! (c) Andrea Giammarchi - ISC */
function domsanitizer(template) {
  return template.join(UIDC).replace(selfClosing, fullClosing).replace(attrSeeker, attrReplacer);
}
var spaces = " \\f\\n\\r\\t";
var almostEverything = "[^" + spaces + `\\/>"'=]+`;
var attrName = "[" + spaces + "]+" + almostEverything;
var tagName = "<([A-Za-z]+[A-Za-z0-9:._-]*)((?:";
var attrPartials = `(?:\\s*=\\s*(?:'[^']*?'|"[^"]*?"|<[^>]*?>|` + almostEverything.replace("\\/", "") + "))?)";
var attrSeeker = new RegExp(tagName + attrName + attrPartials + "+)([" + spaces + "]*/?>)", "g");
var selfClosing = new RegExp(tagName + attrName + attrPartials + "*)([" + spaces + "]*/>)", "g");
var findAttributes = new RegExp("(" + attrName + `\\s*=\\s*)(['"]?)` + UIDC + "\\2", "gi");
function attrReplacer($0, $1, $2, $3) {
  return "<" + $1 + $2.replace(findAttributes, replaceAttributes) + $3;
}
function replaceAttributes($0, $1, $2) {
  return $1 + ($2 || '"') + UID + ($2 || '"');
}
function fullClosing($0, $1, $2) {
  return VOID_ELEMENTS.test($1) ? $0 : "<" + $1 + $2 + "></" + $1 + ">";
}
const { isArray } = Array;
const { indexOf, slice } = [];
var umap = (_) => ({ get: (key) => _.get(key), set: (key, value) => (_.set(key, value), value) });
const ELEMENT_NODE = 1;
const nodeType = 111;
const remove = ({ firstChild, lastChild }) => {
  const range = document.createRange();
  range.setStartAfter(firstChild);
  range.setEndAfter(lastChild);
  range.deleteContents();
  return firstChild;
};
const diffable = (node, operation) => node.nodeType === nodeType ? 1 / operation < 0 ? operation ? remove(node) : node.lastChild : operation ? node.valueOf() : node.firstChild : node;
const persistent = (fragment) => {
  const { childNodes } = fragment;
  const { length: length2 } = childNodes;
  if (length2 < 2)
    return length2 ? childNodes[0] : fragment;
  const nodes = slice.call(childNodes, 0);
  const firstChild = nodes[0];
  const lastChild = nodes[length2 - 1];
  return { ELEMENT_NODE, nodeType, firstChild, lastChild, valueOf() {
    if (childNodes.length !== length2) {
      let i2 = 0;
      while (i2 < length2)
        fragment.appendChild(nodes[i2++]);
    }
    return fragment;
  } };
};
/*! (c) Andrea Giammarchi - ISC */
var createContent = function(document2) {
  var FRAGMENT = "fragment";
  var TEMPLATE = "template";
  var HAS_CONTENT = "content" in create5(TEMPLATE);
  var createHTML = HAS_CONTENT ? function(html2) {
    var template = create5(TEMPLATE);
    template.innerHTML = html2;
    return template.content;
  } : function(html2) {
    var content = create5(FRAGMENT);
    var template = create5(TEMPLATE);
    var childNodes = null;
    if (/^[^\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html2)) {
      var selector = RegExp.$1;
      template.innerHTML = "<table>" + html2 + "</table>";
      childNodes = template.querySelectorAll(selector);
    } else {
      template.innerHTML = html2;
      childNodes = template.childNodes;
    }
    append(content, childNodes);
    return content;
  };
  return function createContent2(markup, type) {
    return (type === "svg" ? createSVG : createHTML)(markup);
  };
  function append(root2, childNodes) {
    var length2 = childNodes.length;
    while (length2--)
      root2.appendChild(childNodes[0]);
  }
  function create5(element) {
    return element === FRAGMENT ? document2.createDocumentFragment() : document2.createElementNS("http://www.w3.org/1999/xhtml", element);
  }
  function createSVG(svg2) {
    var content = create5(FRAGMENT);
    var template = create5("div");
    template.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg">' + svg2 + "</svg>";
    append(content, template.firstChild.childNodes);
    return content;
  }
}(document);
var udomdiff = (parentNode, a, b, get2, before) => {
  const bLength = b.length;
  let aEnd = a.length;
  let bEnd = bLength;
  let aStart = 0;
  let bStart = 0;
  let map2 = null;
  while (aStart < aEnd || bStart < bEnd) {
    if (aEnd === aStart) {
      const node = bEnd < bLength ? bStart ? get2(b[bStart - 1], -0).nextSibling : get2(b[bEnd - bStart], 0) : before;
      while (bStart < bEnd)
        parentNode.insertBefore(get2(b[bStart++], 1), node);
    } else if (bEnd === bStart) {
      while (aStart < aEnd) {
        if (!map2 || !map2.has(a[aStart]))
          parentNode.removeChild(get2(a[aStart], -1));
        aStart++;
      }
    } else if (a[aStart] === b[bStart]) {
      aStart++;
      bStart++;
    } else if (a[aEnd - 1] === b[bEnd - 1]) {
      aEnd--;
      bEnd--;
    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
      const node = get2(a[--aEnd], -1).nextSibling;
      parentNode.insertBefore(get2(b[bStart++], 1), get2(a[aStart++], -1).nextSibling);
      parentNode.insertBefore(get2(b[--bEnd], 1), node);
      a[aEnd] = b[bEnd];
    } else {
      if (!map2) {
        map2 = /* @__PURE__ */ new Map();
        let i2 = bStart;
        while (i2 < bEnd)
          map2.set(b[i2], i2++);
      }
      if (map2.has(a[aStart])) {
        const index2 = map2.get(a[aStart]);
        if (bStart < index2 && index2 < bEnd) {
          let i2 = aStart;
          let sequence = 1;
          while (++i2 < aEnd && i2 < bEnd && map2.get(a[i2]) === index2 + sequence)
            sequence++;
          if (sequence > index2 - bStart) {
            const node = get2(a[aStart], 0);
            while (bStart < index2)
              parentNode.insertBefore(get2(b[bStart++], 1), node);
          } else {
            parentNode.replaceChild(get2(b[bStart++], 1), get2(a[aStart++], -1));
          }
        } else
          aStart++;
      } else
        parentNode.removeChild(get2(a[aStart++], -1));
    }
  }
  return b;
};
/*! (c) Andrea Giammarchi - ISC */
var importNode = function(document2, appendChild, cloneNode, createTextNode, importNode2) {
  var native = importNode2 in document2;
  var fragment = document2.createDocumentFragment();
  fragment[appendChild](document2[createTextNode]("g"));
  fragment[appendChild](document2[createTextNode](""));
  var content = native ? document2[importNode2](fragment, true) : fragment[cloneNode](true);
  return content.childNodes.length < 2 ? function importNode3(node, deep) {
    var clone = node[cloneNode]();
    for (var childNodes = node.childNodes || [], length2 = childNodes.length, i2 = 0; deep && i2 < length2; i2++) {
      clone[appendChild](importNode3(childNodes[i2], deep));
    }
    return clone;
  } : native ? document2[importNode2] : function(node, deep) {
    return node[cloneNode](!!deep);
  };
}(document, "appendChild", "cloneNode", "createTextNode", "importNode");
var trim = "".trim || function() {
  return String(this).replace(/^\s+|\s+/g, "");
};
var normalizeAttributes = UID_IE ? function(attributes, parts) {
  var html2 = parts.join(" ");
  return parts.slice.call(attributes, 0).sort(function(left, right) {
    return html2.indexOf(left.name) <= html2.indexOf(right.name) ? -1 : 1;
  });
} : function(attributes, parts) {
  return parts.slice.call(attributes, 0);
};
function find(node, path) {
  var length2 = path.length;
  var i2 = 0;
  while (i2 < length2)
    node = node.childNodes[path[i2++]];
  return node;
}
function parse(node, holes, parts, path) {
  var childNodes = node.childNodes;
  var length2 = childNodes.length;
  var i2 = 0;
  while (i2 < length2) {
    var child = childNodes[i2];
    switch (child.nodeType) {
      case ELEMENT_NODE$1:
        var childPath = path.concat(i2);
        parseAttributes(child, holes, parts, childPath);
        parse(child, holes, parts, childPath);
        break;
      case COMMENT_NODE:
        var textContent = child.textContent;
        if (textContent === UID) {
          parts.shift();
          holes.push(SHOULD_USE_TEXT_CONTENT.test(node.nodeName) ? Text(node, path) : Any(child, path.concat(i2)));
        } else {
          switch (textContent.slice(0, 2)) {
            case "/*":
              if (textContent.slice(-2) !== "*/")
                break;
            case "\u{1F47B}":
              node.removeChild(child);
              i2--;
              length2--;
          }
        }
        break;
      case TEXT_NODE:
        if (SHOULD_USE_TEXT_CONTENT.test(node.nodeName) && trim.call(child.textContent) === UIDC) {
          parts.shift();
          holes.push(Text(node, path));
        }
        break;
    }
    i2++;
  }
}
function parseAttributes(node, holes, parts, path) {
  var attributes = node.attributes;
  var cache2 = [];
  var remove2 = [];
  var array = normalizeAttributes(attributes, parts);
  var length2 = array.length;
  var i2 = 0;
  while (i2 < length2) {
    var attribute2 = array[i2++];
    var direct = attribute2.value === UID;
    var sparse;
    if (direct || 1 < (sparse = attribute2.value.split(UIDC)).length) {
      var name2 = attribute2.name;
      if (cache2.indexOf(name2) < 0) {
        cache2.push(name2);
        var realName = parts.shift().replace(direct ? /^(?:|[\S\s]*?\s)(\S+?)\s*=\s*('|")?$/ : new RegExp("^(?:|[\\S\\s]*?\\s)(" + name2 + `)\\s*=\\s*('|")[\\S\\s]*`, "i"), "$1");
        var value = attributes[realName] || attributes[realName.toLowerCase()];
        if (direct)
          holes.push(Attr(value, path, realName, null));
        else {
          var skip3 = sparse.length - 2;
          while (skip3--)
            parts.shift();
          holes.push(Attr(value, path, realName, sparse));
        }
      }
      remove2.push(attribute2);
    }
  }
  length2 = remove2.length;
  i2 = 0;
  var cleanValue = 0 < length2 && UID_IE && !("ownerSVGElement" in node);
  while (i2 < length2) {
    var attr = remove2[i2++];
    if (cleanValue)
      attr.value = "";
    node.removeAttribute(attr.name);
  }
  var nodeName = node.nodeName;
  if (/^script$/i.test(nodeName)) {
    var script = document.createElement(nodeName);
    length2 = attributes.length;
    i2 = 0;
    while (i2 < length2)
      script.setAttributeNode(attributes[i2++].cloneNode(true));
    script.textContent = node.textContent;
    node.parentNode.replaceChild(script, node);
  }
}
function Any(node, path) {
  return { type: "any", node, path };
}
function Attr(node, path, name2, sparse) {
  return { type: "attr", node, path, name: name2, sparse };
}
function Text(node, path) {
  return { type: "text", node, path };
}
var parsed = umap(new WeakMap$1());
function createInfo(options2, template) {
  var markup = (options2.convert || domsanitizer)(template);
  var transform = options2.transform;
  if (transform)
    markup = transform(markup);
  var content = createContent(markup, options2.type);
  cleanContent(content);
  var holes = [];
  parse(content, holes, template.slice(0), []);
  return { content, updates: function(content2) {
    var updates = [];
    var len = holes.length;
    var i2 = 0;
    var off2 = 0;
    while (i2 < len) {
      var info = holes[i2++];
      var node = find(content2, info.path);
      switch (info.type) {
        case "any":
          updates.push({ fn: options2.any(node, []), sparse: false });
          break;
        case "attr":
          var sparse = info.sparse;
          var fn = options2.attribute(node, info.name, info.node);
          if (sparse === null)
            updates.push({ fn, sparse: false });
          else {
            off2 += sparse.length - 2;
            updates.push({ fn, sparse: true, values: sparse });
          }
          break;
        case "text":
          updates.push({ fn: options2.text(node), sparse: false });
          node.textContent = "";
          break;
      }
    }
    len += off2;
    return function() {
      var length2 = arguments.length;
      if (len !== length2 - 1) {
        throw new Error(length2 - 1 + " values instead of " + len + "\n" + template.join("${value}"));
      }
      var i3 = 1;
      var off3 = 1;
      while (i3 < length2) {
        var update = updates[i3 - off3];
        if (update.sparse) {
          var values2 = update.values;
          var value = values2[0];
          var j = 1;
          var l2 = values2.length;
          off3 += l2 - 2;
          while (j < l2)
            value += arguments[i3++] + values2[j++];
          update.fn(value);
        } else
          update.fn(arguments[i3++]);
      }
      return content2;
    };
  } };
}
function createDetails(options2, template) {
  var info = parsed.get(template) || parsed.set(template, createInfo(options2, template));
  return info.updates(importNode.call(document, info.content, true));
}
var empty = [];
function domtagger(options2) {
  var previous = empty;
  var updates = cleanContent;
  return function(template) {
    if (previous !== template)
      updates = createDetails(options2, previous = template);
    return updates.apply(null, arguments);
  };
}
function cleanContent(fragment) {
  var childNodes = fragment.childNodes;
  var i2 = childNodes.length;
  while (i2--) {
    var child = childNodes[i2];
    if (child.nodeType !== 1 && trim.call(child.textContent).length === 0) {
      fragment.removeChild(child);
    }
  }
}
/*! (c) Andrea Giammarchi - ISC */
var hyperStyle = function() {
  var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
  var hyphen = /([^A-Z])([A-Z]+)/g;
  return function hyperStyle2(node, original) {
    return "ownerSVGElement" in node ? svg2(node, original) : update(node.style, false);
  };
  function ized($0, $1, $2) {
    return $1 + "-" + $2.toLowerCase();
  }
  function svg2(node, original) {
    var style;
    if (original)
      style = original.cloneNode(true);
    else {
      node.setAttribute("style", "--hyper:style;");
      style = node.getAttributeNode("style");
    }
    style.value = "";
    node.setAttributeNode(style);
    return update(style, true);
  }
  function toStyle(object) {
    var key, css = [];
    for (key in object)
      css.push(key.replace(hyphen, ized), ":", object[key], ";");
    return css.join("");
  }
  function update(style, isSVG) {
    var oldType, oldValue;
    return function(newValue) {
      var info, key, styleValue, value;
      switch (typeof newValue) {
        case "object":
          if (newValue) {
            if (oldType === "object") {
              if (!isSVG) {
                if (oldValue !== newValue) {
                  for (key in oldValue) {
                    if (!(key in newValue)) {
                      style[key] = "";
                    }
                  }
                }
              }
            } else {
              if (isSVG)
                style.value = "";
              else
                style.cssText = "";
            }
            info = isSVG ? {} : style;
            for (key in newValue) {
              value = newValue[key];
              styleValue = typeof value === "number" && !IS_NON_DIMENSIONAL.test(key) ? value + "px" : value;
              if (!isSVG && /^--/.test(key))
                info.setProperty(key, styleValue);
              else
                info[key] = styleValue;
            }
            oldType = "object";
            if (isSVG)
              style.value = toStyle(oldValue = info);
            else
              oldValue = newValue;
            break;
          }
        default:
          if (oldValue != newValue) {
            oldType = "string";
            oldValue = newValue;
            if (isSVG)
              style.value = newValue || "";
            else
              style.cssText = newValue || "";
          }
          break;
      }
    };
  }
}();
const aria = (node) => (values2) => {
  for (const key in values2) {
    const name2 = key === "role" ? key : `aria-${key}`;
    const value = values2[key];
    if (value == null)
      node.removeAttribute(name2);
    else
      node.setAttribute(name2, value);
  }
};
const attribute = (node, name2) => {
  let oldValue, orphan = true;
  const attributeNode = document.createAttributeNS(null, name2);
  return (newValue) => {
    if (oldValue !== newValue) {
      oldValue = newValue;
      if (oldValue == null) {
        if (!orphan) {
          node.removeAttributeNode(attributeNode);
          orphan = true;
        }
      } else {
        attributeNode.value = newValue;
        if (orphan) {
          node.setAttributeNodeNS(attributeNode);
          orphan = false;
        }
      }
    }
  };
};
const boolean = (node, key, oldValue) => (newValue) => {
  if (oldValue !== !!newValue) {
    if (oldValue = !!newValue)
      node.setAttribute(key, "");
    else
      node.removeAttribute(key);
  }
};
const data = ({ dataset }) => (values2) => {
  for (const key in values2) {
    const value = values2[key];
    if (value == null)
      delete dataset[key];
    else
      dataset[key] = value;
  }
};
const event = (node, name2) => {
  let oldValue, type = name2.slice(2);
  if (!(name2 in node) && name2.toLowerCase() in node)
    type = type.toLowerCase();
  return (newValue) => {
    const info = isArray(newValue) ? newValue : [newValue, false];
    if (oldValue !== info[0]) {
      if (oldValue)
        node.removeEventListener(type, oldValue, info[1]);
      if (oldValue = info[0])
        node.addEventListener(type, oldValue, info[1]);
    }
  };
};
const ref = (node) => (value) => {
  if (typeof value === "function")
    value(node);
  else
    value.current = node;
};
const setter = (node, key) => key === "dataset" ? data(node) : (value) => {
  node[key] = value;
};
const hyperProperty = (node, name2) => {
  let oldValue;
  return (newValue) => {
    if (oldValue !== newValue) {
      oldValue = newValue;
      if (node[name2] !== newValue) {
        if (newValue == null) {
          node[name2] = "";
          node.removeAttribute(name2);
        } else
          node[name2] = newValue;
      }
    }
  };
};
const readOnly = /^(?:form|list)$/i;
const text = (node, text2) => node.ownerDocument.createTextNode(text2);
function Tagger(type) {
  this.type = type;
  return domtagger(this);
}
Tagger.prototype = { attribute(node, name2, original) {
  const isSVG = this.type === "svg";
  switch (name2) {
    case "class":
      if (isSVG)
        return attribute(node, name2);
      name2 = "className";
    case "props":
      return setter(node, name2);
    case "aria":
      return aria(node);
    case "style":
      return hyperStyle(node, original, isSVG);
    case "ref":
      return ref(node);
    case ".dataset":
      return data(node);
    default:
      if (name2.slice(0, 1) === ".")
        return setter(node, name2.slice(1));
      if (name2.slice(0, 1) === "?")
        return boolean(node, name2.slice(1));
      if (name2.slice(0, 2) === "on")
        return event(node, name2);
      if (name2 in node && !(isSVG || readOnly.test(name2)))
        return hyperProperty(node, name2);
      return attribute(node, name2);
  }
}, any(node, childNodes) {
  const { type } = this;
  let fastPath = false;
  let oldValue;
  const anyContent = (value) => {
    switch (typeof value) {
      case "string":
      case "number":
      case "boolean":
        if (fastPath) {
          if (oldValue !== value) {
            oldValue = value;
            childNodes[0].textContent = value;
          }
        } else {
          fastPath = true;
          oldValue = value;
          childNodes = udomdiff(node.parentNode, childNodes, [text(node, value)], diffable, node);
        }
        break;
      case "function":
        anyContent(value(node));
        break;
      case "object":
      case "undefined":
        if (value == null) {
          fastPath = false;
          childNodes = udomdiff(node.parentNode, childNodes, [], diffable, node);
          break;
        }
      default:
        fastPath = false;
        oldValue = value;
        if (isArray(value)) {
          if (value.length === 0) {
            if (childNodes.length) {
              childNodes = udomdiff(node.parentNode, childNodes, [], diffable, node);
            }
          } else {
            switch (typeof value[0]) {
              case "string":
              case "number":
              case "boolean":
                anyContent(String(value));
                break;
              case "function":
                anyContent(value.map(invoke, node));
                break;
              case "object":
                if (isArray(value[0])) {
                  value = value.concat.apply([], value);
                }
              default:
                childNodes = udomdiff(node.parentNode, childNodes, value, diffable, node);
                break;
            }
          }
        } else if ("ELEMENT_NODE" in value) {
          childNodes = udomdiff(node.parentNode, childNodes, value.nodeType === 11 ? slice.call(value.childNodes) : [value], diffable, node);
        } else if ("text" in value) {
          anyContent(String(value.text));
        } else if ("any" in value) {
          anyContent(value.any);
        } else if ("html" in value) {
          childNodes = udomdiff(node.parentNode, childNodes, slice.call(createContent([].concat(value.html).join(""), type).childNodes), diffable, node);
        } else if ("length" in value) {
          anyContent(slice.call(value));
        }
        break;
    }
  };
  return anyContent;
}, text(node) {
  let oldValue;
  const textContent = (value) => {
    if (oldValue !== value) {
      oldValue = value;
      const type = typeof value;
      if (type === "object" && value) {
        if ("text" in value) {
          textContent(String(value.text));
        } else if ("any" in value) {
          textContent(value.any);
        } else if ("html" in value) {
          textContent([].concat(value.html).join(""));
        } else if ("length" in value) {
          textContent(slice.call(value).join(""));
        }
      } else if (type === "function") {
        textContent(value(node));
      } else {
        node.textContent = value == null ? "" : value;
      }
    }
  };
  return textContent;
} };
function invoke(callback) {
  return callback(this);
}
const { create: create$1, freeze, keys } = Object;
Tagger.prototype;
const cache = umap(new WeakMap$1());
const createRender = (Tagger2) => ({ html: outer("html", Tagger2), svg: outer("svg", Tagger2), render(where, what) {
  const hole = typeof what === "function" ? what() : what;
  const info = cache.get(where) || cache.set(where, createCache());
  const wire = hole instanceof LighterHole ? unroll(Tagger2, info, hole) : hole;
  if (wire !== info.wire) {
    info.wire = wire;
    where.textContent = "";
    where.appendChild(wire.valueOf());
  }
  return where;
} });
const createCache = () => ({ stack: [], entry: null, wire: null });
const outer = (type, Tagger2) => {
  const cache2 = umap(new WeakMap$1());
  const fixed = (info) => function() {
    return unroll(Tagger2, info, hole.apply(null, arguments));
  };
  hole.for = (ref2, id2) => {
    const memo = cache2.get(ref2) || cache2.set(ref2, create$1(null));
    return memo[id2] || (memo[id2] = fixed(createCache()));
  };
  hole.node = function() {
    return unroll(Tagger2, createCache(), hole.apply(null, arguments)).valueOf();
  };
  return hole;
  function hole() {
    return new LighterHole(type, tta.apply(null, arguments));
  }
};
const unroll = (Tagger2, info, { type, template, values: values2 }) => {
  const { length: length2 } = values2;
  unrollValues(Tagger2, info, values2, length2);
  let { entry } = info;
  if (!entry || entry.template !== template || entry.type !== type) {
    const tag = new Tagger2(type);
    info.entry = entry = { type, template, tag, wire: persistent(tag(template, ...values2)) };
  } else
    entry.tag(template, ...values2);
  return entry.wire;
};
const unrollValues = (Tagger2, { stack }, values2, length2) => {
  for (let i2 = 0; i2 < length2; i2++) {
    const hole = values2[i2];
    if (hole instanceof Hole)
      values2[i2] = unroll(Tagger2, stack[i2] || (stack[i2] = createCache()), hole);
    else if (isArray(hole))
      unrollValues(Tagger2, stack[i2] || (stack[i2] = createCache()), hole, hole.length);
    else
      stack[i2] = null;
  }
  if (length2 < stack.length)
    stack.splice(length2);
};
freeze(LighterHole);
function LighterHole(type, args) {
  this.type = type;
  this.template = args.shift();
  this.values = args;
}
const Hole = LighterHole;
const { render: render$1, html, svg } = createRender(Tagger);
function tta() {
  let out = [], i2 = 0, { length: length2 } = arguments;
  while (i2 < length2)
    out.push(arguments[i2++]);
  return out;
}
const Free = { name: "Free", layout: ({ props, children, size }) => {
  return children.reduce((acc, x2) => {
    const { size: size2 = { x: "100%", y: "100%" }, position = { x: 0, y: 0 }, opacity = 1 } = x2.props;
    return { ...acc, [x2.id]: { position: { x: position.x, y: position.y }, size: { x: size2.x, y: size2.y }, opacity } };
  }, {});
} };
const Column = { name: "Column", layout: ({ props = {}, children, size }) => {
  let { justify = "center", align = "center", cover = false, margin = {}, dimensions = 16 / 9, reverse = false } = props;
  const defaultMargin = cover ? 0 : Math.min(size.y / 6, 12);
  margin = { left: defaultMargin, right: defaultMargin, top: defaultMargin, bottom: defaultMargin, between: defaultMargin, ...margin };
  const innerHeight = size.y - margin.top - margin.bottom;
  const innerWidth = size.x - margin.left - margin.right;
  const totalMarginBetween = margin.between * ((children.length || 1) - 1);
  const itemWidth = Math.min(innerWidth, (innerHeight - totalMarginBetween) / (children.length || 1) * dimensions);
  const itemHeight = itemWidth / dimensions;
  return html.node`
      <div style=${{ height: "100%", width: cover ? size.x + "px" : "auto", display: "flex", flexDirection: reverse ? "column-reverse" : "column", justifyContent: justify, alignItems: align, paddingLeft: margin.left + "px", paddingTop: margin.top + "px", paddingBottom: margin.bottom + "px", paddingRight: margin.right + "px" }}>
      ${children.map((x2, i2) => html.node`<div data-node-id=${x2.id} .data=${{ entryTransition: { delay: 400 + i2 * 100, offset: { x: 0, y: "100%" }, scale: { x: 0.8, y: 0.8 }, opacity: 0 }, exitTransition: { offset: { x: 0, y: 1e3 }, scale: { x: 0.8, y: 0.8 }, opacity: 0 }, borderRadius: cover ? 0 : 5 }} style=${{ display: "flex", width: cover ? "100%" : itemWidth + "px", height: cover ? itemHeight + "px" : "auto", aspectRatio: dimensions, marginBottom: i2 === children.length - 1 ? 0 : margin.between + "px", flexGrow: 0, flexShrink: 1, flexBasis: itemHeight + "px" }}></div>`)}
      </div>
    `;
} };
const Row = { name: "Row", layout: ({ props = {}, children, size }) => {
  let { justify = "center", align = "center", cover = false, margin = {}, dimensions = 16 / 9, maxWidth = 1, reverse = false } = props;
  const defaultMargin = cover ? 0 : Math.min(size.y / 6, 12);
  margin = { left: defaultMargin, right: defaultMargin, top: defaultMargin, bottom: defaultMargin, between: defaultMargin, ...margin };
  const innerHeight = size.y - margin.top - margin.bottom;
  const innerWidth = size.x - margin.left - margin.right;
  const totalMarginBetween = margin.between * ((children.length || 1) - 1);
  const itemWidth = Math.min((innerWidth - totalMarginBetween) / (children.length || 1), innerHeight * dimensions, maxWidth * size.x);
  const itemHeight = itemWidth / dimensions;
  return html.node`
      <div style=${{ height: cover ? size.y + "px" : "auto", width: "100%", display: "flex", flexDirection: reverse ? "row-reverse" : "row", justifyContent: justify, alignItems: align, paddingLeft: margin.left + "px", paddingTop: margin.top + "px", paddingBottom: margin.bottom + "px", paddingRight: margin.right + "px" }}>
          ${children.map((x2, i2) => html.node`<div data-node-id=${x2.id} .data=${{ entryTransition: { delay: 400 + i2 * 100, offset: { x: 0, y: "100%" }, scale: { x: 0.8, y: 0.8 }, opacity: 0 }, exitTransition: { offset: { x: 0, y: 1e3 }, scale: { x: 0.8, y: 0.8 }, opacity: 0 }, borderRadius: cover ? 0 : 5 }} style=${{ display: "flex", height: cover ? "100%" : itemHeight + "px", width: itemWidth + "px", aspectRatio: dimensions, marginRight: i2 === children.length - 1 ? 0 : margin.between + "px", flexGrow: 0, flexShrink: 1, flexBasis: itemWidth + "px" }}></div>`)}
      </div>
    `;
} };
const toMatrix = (arr, width) => {
  return arr.reduce((rows, key, index2) => (index2 % width == 0 ? rows.push([index2]) : rows[rows.length - 1].push(index2)) && rows, []);
};
const Grid = { name: "Grid", layout: ({ props = {}, children, size }) => {
  let { dimensions = 16 / 9, numPerRow, margin, cover = false, maxWidth } = props;
  const defaultMargin = children.length === 0 || cover ? 0 : Math.min(size.y / children.length / 10, 30);
  margin = margin != null ? margin : defaultMargin;
  const isTall = size.x < size.y;
  let rows = [];
  if (numPerRow) {
    rows = toMatrix(children, numPerRow);
  } else {
    rows = isTall ? getTallGrid(children.length) : getWideGrid(children.length);
  }
  const rowHeight = (size.y - margin) / rows.length;
  const rowWidth = size.x - margin;
  return html.node`
    <div style=${{ display: "flex", width: "100%", height: "100%", flexDirection: "column", justifyContent: "center", paddingLeft: margin + "px", paddingBottom: margin + "px", flexGrow: 0 }}>${rows.map((row2, i2) => Row.layout({ props: { justify: "center", dimensions, cover, maxWidth: maxWidth || 1 / (rows[0].length || 1), margin: { top: margin, right: margin, left: 0, bottom: 0, between: margin } }, children: row2.map((index2) => children[index2]), size: { y: rowHeight, x: rowWidth } }))}</div>`;
} };
const Presentation = { name: "Presentation", layout: ({ props = {}, children, size }) => {
  let { margin, cover = false, barWidth = 0.2, barPosition = "side", presentationDimensions = 16 / 9, viewerDimensions = 16 / 9, justifyViewers = "center", useGrid = false, reverse = false } = props;
  const barWidthPx = barPosition === "side" ? size.x * barWidth : size.y * barWidth;
  const presentation = children[0];
  const viewers = children.filter((x2) => x2 !== presentation);
  const defaultMargin = children.length <= 1 ? 0 : Math.min(size.x / 80, 30);
  margin = margin != null ? margin : defaultMargin;
  if (!presentation)
    return Grid.layout({ props, children, size });
  const hasSidebar = children[1];
  const mainSize = { ...size };
  if (hasSidebar) {
    if (barPosition === "side") {
      mainSize.x = size.x - barWidthPx;
      mainSize.y = mainSize.x / presentationDimensions;
    } else {
      mainSize.y = size.y - barWidthPx;
      mainSize.x = mainSize.y * presentationDimensions;
    }
  }
  let Bar, barProps = {};
  if (useGrid) {
    Bar = Grid.layout;
    barProps = { cover, ...cover ? { maxWidth: 1 } : { margin } };
  } else {
    Bar = barPosition === "side" ? Column.layout : Row.layout;
    barProps = { margin: { top: margin, left: margin, bottom: margin, right: margin, between: margin }, dimensions: viewerDimensions, justify: justifyViewers, align: "flex-end" };
  }
  const barDirection = barPosition === "side" ? reverse ? "left" : "right" : reverse ? "top" : "bottom";
  return html.node`
      <div style=${{ display: "flex", flexDirection: (barPosition === "side" ? "row" : "column") + (reverse ? "-reverse" : ""), justifyContent: "space-around", alignItems: "center", position: "relative", padding: cover ? 0 : margin, [`padding-${barDirection}`]: 0 }}>
        ${children[0] && html.node`<div style=${{ width: mainSize.x, height: mainSize.y, display: "flex", flexGrow: 1 }}>
            <div data-node-id=${presentation.id} .data=${{ dimensions: presentationDimensions, borderRadius: cover ? 0 : 5, entryTransition: { delay: 0, offset: { x: 0, y: 1e3 }, scale: { x: 0.5, y: 0.5 }, opacity: 0 }, exitTransition: { offset: { x: 0, y: 1e3 }, scale: { x: 2, y: 2 }, opacity: 0 } }} style=${{ width: "100%", height: "100%", ...cover ? { position: "absolute", top: 0, left: 0, width: useGrid && hasSidebar ? 100 - barWidth * 100 + "%" : "100%", height: "100%" } : {} }} />
          </div>`}
        ${html.node`<div style=${{ ...barPosition === "side" ? { maxWidth: barWidth * 100 + "%", height: "100%" } : { maxHeight: barWidth * 100 + "%", width: "100%" } }}>${hasSidebar && Bar({ props: barProps, children: viewers, size: barPosition === "side" ? { x: barWidthPx, y: size.y } : { x: size.x, y: barWidthPx } })}</div>`}
      </div>
    `;
} };
const Layered = { name: "Layered", layout: ({ props = {}, children, size }) => {
  return html.node`<div style=${{ width: "100%", height: "100%", position: "relative" }}>
      ${children.map((x2, i2) => html.node`<div data-node-id=${x2.id} .data=${{ zIndex: i2 + 1 }} style=${{ position: "absolute", inset: `0px` }}></div>`)}
    </div>`;
} };
const getWideGrid = (numChildren = 0) => {
  switch (numChildren) {
    case 0: {
      return [[]];
    }
    case 1: {
      return [[0]];
    }
    case 2: {
      return [[0, 1]];
    }
    case 3: {
      return [[0, 1], [2]];
    }
    case 4: {
      return [[0, 1], [2, 3]];
    }
    case 5: {
      return [[0, 1, 2], [3, 4]];
    }
    case 6: {
      return [[0, 1, 2], [3, 4, 5]];
    }
    case 7: {
      return [[0, 1, 2], [3, 4], [5, 6]];
    }
    case 8: {
      return [[0, 1, 2], [3, 4, 5], [6, 7]];
    }
  }
  const arr = Array(numChildren).fill(null).map((x2, i2) => i2);
  return toMatrix(arr, Math.round(Math.sqrt(numChildren)));
};
const getTallGrid = (numChildren = 0) => {
  switch (numChildren) {
    case 0: {
      return [[]];
    }
    case 1: {
      return [[0]];
    }
    case 2: {
      return [[0], [1]];
    }
    case 3: {
      return [[0, 1], [2]];
    }
    case 4: {
      return [[0, 1], [2, 3]];
    }
    case 5: {
      return [[0, 1], [2, 3], [4]];
    }
    case 6: {
      return [[0, 1], [2, 3], [4, 5]];
    }
    case 7: {
      return [[0, 1], [2, 3], [4, 5], [6]];
    }
    case 8: {
      return [[0, 1], [2, 3], [4, 5], [6, 7]];
    }
  }
  const arr = Array(numChildren).fill(null).map((x2, i2) => i2);
  return toMatrix(arr, Math.ceil(Math.sqrt(arr.length)) - 1);
};
var Layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, Free, Column, Row, Grid, Presentation, Layered }, Symbol.toStringTag, { value: "Module" }));
const deviceWatchers = /* @__PURE__ */ new Set();
const updateMediaStreamTracks = (srcObject, tracks) => {
  const existing = { audio: srcObject.getAudioTracks()[0], video: srcObject.getVideoTracks()[0] };
  if (existing.audio !== tracks.audio) {
    if (existing.audio) {
      srcObject.removeTrack(existing.audio);
    }
    if (tracks.audio) {
      srcObject.addTrack(tracks.audio);
    }
  }
  if (existing.video !== tracks.video) {
    if (existing.video) {
      srcObject.removeTrack(existing.video);
    }
    if (tracks.video) {
      srcObject.addTrack(tracks.video);
    }
  }
};
const getDevicePermissions = async () => {
  const permissions = { audio: true, video: true };
  return Promise.all([navigator.mediaDevices.getUserMedia({ video: true }).then((src) => {
    src.getTracks().forEach((x2) => x2.stop());
  }).catch((e2) => {
    if (e2.name === "NotAllowedError") {
      permissions.video = false;
    }
  }), navigator.mediaDevices.getUserMedia({ audio: true }).then((src) => {
    src.getTracks().forEach((x2) => x2.stop());
  }).catch((e2) => {
    if (e2.name === "NotAllowedError") {
      permissions.audio = false;
    }
  })]).then(() => permissions);
};
const ensureDevicePermissions = async () => {
  return getDevicePermissions();
};
const watchDevices = (cb2) => {
  if (deviceWatchers.size === 0) {
    navigator.mediaDevices.addEventListener("devicechange", reportDevices);
  }
  deviceWatchers.add(cb2);
  reportDevices().catch(() => {
  });
  return () => {
    deviceWatchers.delete(cb2);
    if (deviceWatchers.size === 0) {
      navigator.mediaDevices.removeEventListener("devicechange", reportDevices);
    }
  };
};
const getUserMedia = async (...args) => {
  const media = await navigator.mediaDevices.getUserMedia(...args);
  reportDevices();
  return media;
};
const deviceWithDefaultLabel = (x2, label) => ({ deviceId: x2.deviceId, groupId: x2.groupId, kind: x2.kind, label: x2.label || label });
const reportDevices = async () => {
  const devices = await navigator.mediaDevices.enumerateDevices();
  const webcams = devices.filter((x2) => x2.kind === "videoinput").map((x2, i2) => deviceWithDefaultLabel(x2, "Camera " + (i2 + 1)));
  const microphones = devices.filter((x2) => x2.kind === "audioinput").map((x2, i2) => deviceWithDefaultLabel(x2, "Microphone " + (i2 + 1)));
  const speakers = devices.filter((x2) => x2.kind === "audiooutput").map((x2, i2) => deviceWithDefaultLabel(x2, "Speaker " + (i2 + 1)));
  deviceWatchers.forEach((cb2) => cb2({ webcams, microphones, speakers }));
};
var webrtc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, updateMediaStreamTracks, getDevicePermissions, ensureDevicePermissions, watchDevices, getUserMedia }, Symbol.toStringTag, { value: "Module" }));
const RoomParticipant = { type: "RoomParticipant", valueType: MediaStream, props: { id: {}, type: {}, videoEnabled: {}, audioEnabled: {} }, init({ addSource, removeSource, updateSource }) {
  CoreContext.on("RoomJoined", ({ room }) => {
    let listeners2 = {};
    let previousTracks = [];
    let previousParticipants = [];
    let participantStreams = {};
    const updateParticipants = () => {
      previousParticipants.forEach((x2) => {
        const srcObject = participantStreams[x2.id];
        const srcObjectScreenshare = participantStreams[x2.id + "-screen"];
        const webcamId = x2.trackIds.find((x22) => {
          const track = room.getTrack(x22);
          return (track == null ? void 0 : track.type) === "camera";
        });
        const microphoneId = x2.trackIds.find((x22) => {
          const track = room.getTrack(x22);
          return (track == null ? void 0 : track.type) === "microphone";
        });
        const screenshareId = x2.trackIds.find((x22) => {
          const track = room.getTrack(x22);
          return (track == null ? void 0 : track.type) === "screen_share";
        });
        const webcamTrack = room.getTrack(webcamId);
        const microphoneTrack = room.getTrack(microphoneId);
        const screenshareTrack = room.getTrack(screenshareId);
        updateMediaStreamTracks(srcObject, { video: webcamTrack == null ? void 0 : webcamTrack.mediaStreamTrack, audio: microphoneTrack == null ? void 0 : microphoneTrack.mediaStreamTrack });
        updateMediaStreamTracks(srcObjectScreenshare, { video: screenshareTrack == null ? void 0 : screenshareTrack.mediaStreamTrack });
        updateSource(x2.id, { videoEnabled: Boolean(webcamTrack && !webcamTrack.isMuted), audioEnabled: Boolean(microphoneTrack && !microphoneTrack.isMuted), displayName: x2.displayName });
        updateSource(x2.id + "-screen", { videoEnabled: Boolean(screenshareTrack && !screenshareTrack.isMuted), displayName: x2.meta.screenDisplayName || `${x2.displayName}'s Screen` });
      });
    };
    room.useTracks((tracks) => {
      const newTracks = tracks.filter((track) => !previousTracks.some((x2) => x2.id === track.id));
      const removedTracks = previousTracks.filter((track) => !tracks.some((x2) => x2.id === track.id));
      previousTracks = tracks;
      updateParticipants();
      newTracks.forEach((x2) => {
        const { mediaStreamTrack, id: id2, participantId, type } = room.getTrack(x2.id);
        const source2 = { id: id2, isActive: true, value: mediaStreamTrack, props: { trackId: id2, participantId, isMuted: x2.isMuted, type } };
        if (mediaStreamTrack) {
          if (mediaStreamTrack.kind === "video") {
            addSource(source2);
          } else {
            addSource(source2);
          }
        }
      });
      removedTracks.forEach((x2) => {
        var _a2;
        removeSource(x2.id);
        (_a2 = listeners2[x2.id]) == null ? void 0 : _a2.call(listeners2);
      });
    });
    room.useParticipants((participants) => {
      const newParticipants = participants.filter((participant) => !previousParticipants.some((x2) => x2.id === participant.id));
      const removedParticipants = previousParticipants.filter((participant) => !participants.some((x2) => x2.id === participant.id));
      previousParticipants = participants;
      newParticipants.forEach((x2) => {
        const { id: id2 } = x2;
        const srcObject = new MediaStream([]);
        const screenSrcObject = new MediaStream([]);
        participantStreams[id2] = srcObject;
        participantStreams[id2 + "-screen"] = screenSrcObject;
        addSource({ id: id2, isActive: true, value: srcObject, props: { id: id2, type: "camera", displayName: x2.displayName || x2.id, audioEnabled: false, videoEnabled: false } });
        addSource({ id: id2 + "-screen", isActive: true, value: screenSrcObject, props: { id: id2, type: "screen", displayName: x2.displayName || x2.id, audioEnabled: false, videoEnabled: false } });
      });
      updateParticipants();
      removedParticipants.forEach((x2) => {
        var _a2;
        removeSource(x2.id);
        (_a2 = listeners2[x2.id]) == null ? void 0 : _a2.call(listeners2);
      });
    });
  });
} };
const Overlays = { type: "Overlay", valueType: Object, props: {}, init({ addSource, removeSource, updateSource, getSource, modifySourceValue }) {
  let previousOverlays = [];
  const update = (overlays = []) => {
    const newOverlays = overlays.filter((overlay) => !previousOverlays.some((x2) => x2.id === overlay.id));
    const removedOverlays = previousOverlays.filter((overlay) => !overlays.some((x2) => x2.id === overlay.id));
    const changedOverlays = overlays.filter((overlay) => {
      const existing = previousOverlays.find((x2) => x2.id === overlay.id);
      return !fastDeepEqual(overlay, existing);
    });
    newOverlays.forEach((x2) => addSource({ id: x2.id, value: { ...x2.props }, props: x2.props }));
    removedOverlays.forEach((x2) => removeSource(x2.id));
    changedOverlays.forEach((x2) => {
      updateSource(x2.id, x2.props);
      modifySourceValue(x2.id, (value) => {
        Object.keys(x2.props).forEach((key) => {
          value[key] = x2.props[key];
        });
      });
    });
    previousOverlays = JSON.parse(JSON.stringify(overlays));
  };
  CoreContext.on("ActiveProjectChanged", ({ projectId }) => {
    previousOverlays = [];
    if (!projectId)
      return;
    const project = getProject(projectId);
    update(project.props.overlays);
  });
  CoreContext.on("ProjectChanged", ({ project }) => {
    update(project.props.overlays);
  });
} };
const Banner = { type: "Banner", valueType: Object, props: {}, init({ addSource, removeSource, updateSource, getSource, modifySourceValue }) {
  let previousBanners = [];
  const update = (banners = []) => {
    const newBanners = banners.filter((banner) => !previousBanners.some((x2) => x2.id === banner.id));
    const removedBanners = previousBanners.filter((banner) => !banners.some((x2) => x2.id === banner.id));
    const changedBanners = banners.filter((banner) => {
      const existing = previousBanners.find((x2) => x2.id === banner.id);
      return !fastDeepEqual(banner, existing);
    });
    newBanners.forEach((x2) => addSource({ id: x2.id, value: { headerText: x2.props.headerText, bodyText: x2.props.bodyText }, props: x2.props }));
    removedBanners.forEach((x2) => removeSource(x2.id));
    changedBanners.forEach((x2) => {
      updateSource(x2.id, x2.props);
      modifySourceValue(x2.id, (value) => {
        value.headerText = x2.props.headerText;
        value.bodyText = x2.props.bodyText;
      });
    });
    previousBanners = banners;
  };
  CoreContext.on("ActiveProjectChanged", ({ projectId }) => {
    var _a2, _b;
    previousBanners = [];
    if (!projectId)
      return;
    const project = getProject(projectId);
    update((_b = (_a2 = project.props) == null ? void 0 : _a2.banners) != null ? _b : []);
  });
  CoreContext.on("ProjectChanged", ({ project }) => {
    var _a2, _b;
    update((_b = (_a2 = project.props) == null ? void 0 : _a2.banners) != null ? _b : []);
  });
} };
const Background = { type: "Background", valueType: Object, props: {}, init({ addSource, removeSource, updateSource, getSource, modifySourceValue }) {
  let previousBackground;
  const update = (background) => {
    if (!background)
      return;
    const newBackground = (previousBackground == null ? void 0 : previousBackground.id) !== (background == null ? void 0 : background.id) ? background : null;
    const changedBackground = !fastDeepEqual(background, previousBackground) ? background : null;
    if (newBackground) {
      addSource({ id: newBackground == null ? void 0 : newBackground.id, value: { ...newBackground == null ? void 0 : newBackground.props }, props: newBackground == null ? void 0 : newBackground.props });
      removeSource(previousBackground == null ? void 0 : previousBackground.id);
    }
    if (changedBackground) {
      updateSource(changedBackground == null ? void 0 : changedBackground.id, changedBackground == null ? void 0 : changedBackground.props);
      modifySourceValue(changedBackground == null ? void 0 : changedBackground.id, (value) => {
        Object.keys(changedBackground == null ? void 0 : changedBackground.props).forEach((key) => {
          value[key] = changedBackground == null ? void 0 : changedBackground.props[key];
        });
      });
    }
    previousBackground = JSON.parse(JSON.stringify(background));
  };
  CoreContext.on("ActiveProjectChanged", ({ projectId }) => {
    previousBackground = null;
    if (!projectId)
      return;
    const project = getProject(projectId);
    update(project.props.background);
  });
  CoreContext.on("ProjectChanged", ({ project }) => {
    update(project.props.background);
  });
} };
const Logo = { type: "Logo", valueType: Object, props: {}, init({ addSource, removeSource, updateSource, getSource, modifySourceValue }) {
  let previousLogo;
  const update = (logo) => {
    if (!logo) {
      if (previousLogo) {
        removeSource(previousLogo == null ? void 0 : previousLogo.id);
        previousLogo = null;
      }
      return;
    }
    const newLogo = (previousLogo == null ? void 0 : previousLogo.id) !== (logo == null ? void 0 : logo.id) ? logo : null;
    const changedLogo = !fastDeepEqual(logo, previousLogo) ? logo : null;
    if (newLogo) {
      addSource({ id: newLogo == null ? void 0 : newLogo.id, value: { ...newLogo == null ? void 0 : newLogo.props }, props: newLogo == null ? void 0 : newLogo.props });
      removeSource(previousLogo == null ? void 0 : previousLogo.id);
    }
    if (changedLogo) {
      updateSource(changedLogo == null ? void 0 : changedLogo.id, changedLogo == null ? void 0 : changedLogo.props);
      modifySourceValue(changedLogo == null ? void 0 : changedLogo.id, (value) => {
        Object.keys(changedLogo == null ? void 0 : changedLogo.props).forEach((key) => {
          value[key] = changedLogo == null ? void 0 : changedLogo.props[key];
        });
      });
    }
    previousLogo = JSON.parse(JSON.stringify(logo));
  };
  CoreContext.on("ActiveProjectChanged", ({ projectId }) => {
    previousLogo = null;
    if (!projectId)
      return;
    const project = getProject(projectId);
    update(project.props.logo);
  });
  CoreContext.on("ProjectChanged", ({ project }) => {
    update(project.props.logo);
  });
} };
var Sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, RoomParticipant, Overlays, Banner, Background, Logo }, Symbol.toStringTag, { value: "Module" }));
const { state: state$1 } = CoreContext;
subscribeInternal(async (event2, payload) => {
  var _a2, _b, _c, _d;
  switch (event2) {
    case "UserChanged": {
      const { metadata } = payload;
      state$1.user.metadata = metadata || {};
      state$1.user.props = (metadata == null ? void 0 : metadata.props) || {};
      trigger$1("UserChanged", { user: getBaseUser() });
      return;
    }
    case "ActiveProjectChanged": {
      const { projectId } = payload;
      state$1.activeProjectId = projectId;
      trigger$1("ActiveProjectChanged", { projectId });
      return;
    }
    case "ProjectAdded": {
      const project = payload;
      const internalProject = await hydrateProject(project, "ROLE_HOST");
      const baseProject = toBaseProject(internalProject);
      state$1.projects = [...state$1.projects, internalProject];
      trigger$1("ProjectAdded", { project: baseProject });
      return;
    }
    case "ProjectRemoved": {
      const { projectId } = payload;
      state$1.projects = state$1.projects.filter((x2) => x2.id !== projectId);
      trigger$1("ProjectRemoved", { projectId });
      return;
    }
    case "ProjectChanged": {
      const { project, phase, broadcastId } = payload;
      const internalProject = getProject(project.projectId);
      if (!internalProject)
        return;
      if (phase) {
        internalProject.videoApi.phase = phase;
      }
      if (typeof broadcastId !== "undefined") {
        internalProject.videoApi.broadcastId = broadcastId;
      }
      internalProject.videoApi.project = project;
      internalProject.props = (_b = (_a2 = project.metadata) == null ? void 0 : _a2.props) != null ? _b : {};
      trigger$1("ProjectChanged", { project: toBaseProject(internalProject) });
      return;
    }
    case "DestinationAdded": {
      const { projectId } = payload;
      const internalProject = getProject(projectId);
      if (!internalProject)
        return;
      internalProject.videoApi.project.destinations.push(payload);
      trigger$1("DestinationAdded", { projectId, destination: toBaseDestination(payload) });
      return;
    }
    case "DestinationRemoved": {
      const { projectId, destinationId } = payload;
      const internalProject = getProject(projectId);
      if (!internalProject)
        return;
      internalProject.videoApi.project.destinations = internalProject.videoApi.project.destinations.filter((x2) => x2.destinationId !== destinationId);
      trigger$1("DestinationRemoved", { projectId, destinationId });
      return;
    }
    case "DestinationChanged": {
      const destination = payload;
      const { projectId, destinationId } = destination;
      const internalProject = getProject(projectId);
      if (!internalProject)
        return;
      const internalDestination = internalProject.videoApi.project.destinations.find((x2) => x2.destinationId === destinationId);
      if (!internalDestination)
        return;
      Object.assign(internalDestination, destination);
      trigger$1("DestinationChanged", { projectId, destination: toBaseDestination(internalDestination) });
      return;
    }
    case "SourceAdded": {
      return;
    }
    case "SourceRemoved": {
      return;
    }
    case "SourceUpdated": {
      return;
    }
    case "NodeAdded": {
      return;
    }
    case "NodeRemoved": {
      return;
    }
    case "NodeUpdated": {
      return;
    }
    case "BackgroundMetadataUpdate": {
      const { Command } = CoreContext;
      const { projectId, metadata, sourceId, doTrigger, role } = payload;
      if (role === "ROLE_HOST" || role === "ROLE_COHOST") {
        const internalProject = getProject(projectId);
        if (!internalProject)
          return;
        if (internalProject.props.background.id !== sourceId) {
          return;
        }
        let source2 = (_c = internalProject == null ? void 0 : internalProject.props) == null ? void 0 : _c.background;
        if (source2) {
          source2 = { ...source2, props: { ...source2.props, meta: { ...source2.props.meta, ...metadata } } };
          if (doTrigger) {
            Command.updateProjectProps({ projectId, props: { background: source2 } });
          } else {
            Command.updateProjectPropsWithoutTrigger({ projectId, props: { background: source2 } });
          }
        }
      }
      return;
    }
    case "OverlayMetadataUpdate": {
      const { Command } = CoreContext;
      const { projectId, metadata, sourceId, doTrigger, role } = payload;
      if (role === "ROLE_HOST" || role === "ROLE_COHOST") {
        const internalProject = getProject(projectId);
        if (!internalProject)
          return;
        let source2 = internalProject.props.overlays.find((x2) => x2.id === sourceId);
        if (source2) {
          source2 = { ...source2, props: { ...source2.props, meta: { ...source2.props.meta, ...metadata } } };
          const overlayIndex = internalProject.props.overlays.findIndex((x2) => x2.id === sourceId);
          if (overlayIndex > -1) {
            const shallowOverlays = JSON.parse(JSON.stringify((_d = internalProject == null ? void 0 : internalProject.props) == null ? void 0 : _d.overlays));
            shallowOverlays.splice(overlayIndex, 1, source2);
            if (doTrigger) {
              Command.updateProjectProps({ projectId, props: { overlays: shallowOverlays } });
            } else {
              Command.updateProjectPropsWithoutTrigger({ projectId, props: { overlays: shallowOverlays } });
            }
          }
        }
      }
      return;
    }
  }
});
subscribeInternal(() => log$1.debug({ nextState: { ...state$1 } }));
var functionExpression = /[\s]*([a-z-]+)[\s]*\([\s]*([^\)]+)[\s]*\)[\s]*/i;
var floatExpression = /^(\-?\d+\.?\d{0,5})/;
var toFloat = parseFloat;
function ensurePercent(value) {
  return typeof value === "number" ? value : toFloat(value) * 0.01;
}
function formatPercent(value) {
  return formatFloat(value * 100) + "%";
}
function formatFloat(n2) {
  return floatExpression.exec(n2.toString())[1];
}
function parseCSSFunction(stringValue) {
  var matches = functionExpression.exec(stringValue);
  if (!matches || !matches.length) {
    return void 0;
  }
  return [matches[1]].concat(matches[2].split(","));
}
function cssFunction(functionName, params) {
  var parts = Array.prototype.join.call(params, ", ");
  return functionName + "(" + parts + ")";
}
var math = Math;
var round = math.round;
function roundFloat(n2, factor) {
  return round(n2 * factor) / factor;
}
var _a;
var RGB = "rgb", HSL = "hsl";
var converters = (_a = {}, _a[RGB + HSL] = RGBtoHSL, _a[HSL + RGB] = HSLtoRGB, _a);
var maxChannelValues = { r: 255, g: 255, b: 255, h: 360, s: 1, l: 1, a: 1 };
function color(value) {
  return parseHexCode(value) || parseColorFunction(value) || rgb(255, 0, 0);
}
function rgb(red, blue, green, alpha) {
  return new ColorHelper(RGB, red, blue, green, alpha === void 0 ? 1 : ensurePercent(alpha), alpha !== void 0);
}
function convertHelper(toFormat, helper, forceAlpha) {
  var fromFormat = helper.f, r2 = helper.r, g2 = helper.g, b = helper.b, a = helper.a;
  var newAlpha = forceAlpha === void 0 ? helper.o : forceAlpha;
  if (fromFormat !== toFormat) {
    return converters[fromFormat + toFormat](r2, g2, b, a, newAlpha);
  }
  return forceAlpha === void 0 ? helper : new ColorHelper(fromFormat, r2, g2, b, a, newAlpha);
}
var ColorHelper = function() {
  function ColorHelper2(format, r2, g2, b, a, hasAlpha) {
    var self2 = this;
    self2.f = format;
    self2.o = hasAlpha;
    var isHSL = format === HSL;
    self2.r = clampColor(isHSL ? "h" : "r", r2);
    self2.g = clampColor(isHSL ? "s" : "g", g2);
    self2.b = clampColor(isHSL ? "l" : "b", b);
    self2.a = clampColor("a", a);
  }
  ColorHelper2.prototype.toString = function() {
    var _a2 = this, hasAlpha = _a2.o, format = _a2.f, r2 = _a2.r, g2 = _a2.g, b = _a2.b, a = _a2.a;
    var fnName;
    var params;
    if (format === RGB) {
      fnName = hasAlpha ? "rgba" : RGB;
      params = [round(r2), round(g2), round(b)];
    } else if (format === HSL) {
      fnName = hasAlpha ? "hsla" : HSL;
      params = [round(r2), formatPercent(roundFloat(g2, 100)), formatPercent(roundFloat(b, 100))];
    } else {
      throw new Error("Invalid color format");
    }
    if (hasAlpha) {
      params.push(formatFloat(roundFloat(a, 1e5)));
    }
    return cssFunction(fnName, params);
  };
  ColorHelper2.prototype.toHexString = function() {
    var color2 = convertHelper(RGB, this);
    return "#" + (toHex(color2.r) + toHex(color2.g) + toHex(color2.b)).toUpperCase();
  };
  ColorHelper2.prototype.toHSL = function() {
    return convertHelper(HSL, this, false);
  };
  ColorHelper2.prototype.toHSLA = function() {
    return convertHelper(HSL, this, true);
  };
  ColorHelper2.prototype.toRGB = function() {
    return convertHelper(RGB, this, false);
  };
  ColorHelper2.prototype.toRGBA = function() {
    return convertHelper(RGB, this, true);
  };
  ColorHelper2.prototype.red = function() {
    var _ = this;
    return (_.f === RGB ? _ : _.toRGB()).r;
  };
  ColorHelper2.prototype.green = function() {
    var _ = this;
    return (_.f === RGB ? _ : _.toRGB()).g;
  };
  ColorHelper2.prototype.blue = function() {
    var _ = this;
    return (_.f === RGB ? _ : _.toRGB()).b;
  };
  ColorHelper2.prototype.hue = function() {
    var _ = this;
    return (_.f === HSL ? _ : _.toHSL()).r;
  };
  ColorHelper2.prototype.saturation = function() {
    var _ = this;
    return (_.f === HSL ? _ : _.toHSL()).g;
  };
  ColorHelper2.prototype.lightness = function() {
    var _ = this;
    return (_.f === HSL ? _ : _.toHSL()).b;
  };
  ColorHelper2.prototype.alpha = function() {
    return this.a;
  };
  ColorHelper2.prototype.opacity = function() {
    return this.a;
  };
  ColorHelper2.prototype.invert = function() {
    var _ = this;
    var color2 = convertHelper(RGB, _);
    return convertHelper(_.f, new ColorHelper2(RGB, 255 - color2.r, 255 - color2.g, 255 - color2.b, _.a, _.o));
  };
  ColorHelper2.prototype.lighten = function(percent, relative) {
    var _ = this;
    var color2 = convertHelper(HSL, _);
    var max2 = maxChannelValues.l;
    var l2 = color2.b + (relative ? max2 - color2.b : max2) * ensurePercent(percent);
    return convertHelper(_.f, new ColorHelper2(HSL, color2.r, color2.g, l2, _.a, _.o));
  };
  ColorHelper2.prototype.darken = function(percent, relative) {
    var _ = this;
    var color2 = convertHelper(HSL, _);
    var l2 = color2.b - (relative ? color2.b : maxChannelValues.l) * ensurePercent(percent);
    return convertHelper(_.f, new ColorHelper2(HSL, color2.r, color2.g, l2, _.a, _.o));
  };
  ColorHelper2.prototype.saturate = function(percent, relative) {
    var _ = this;
    var color2 = convertHelper(HSL, _);
    var max2 = maxChannelValues.s;
    var s = color2.g + (relative ? max2 - color2.g : max2) * ensurePercent(percent);
    return convertHelper(_.f, new ColorHelper2(HSL, color2.r, s, color2.b, _.a, _.o));
  };
  ColorHelper2.prototype.desaturate = function(percent, relative) {
    var _ = this;
    var color2 = convertHelper(HSL, _);
    var max2 = maxChannelValues.s;
    var s = color2.g - (relative ? color2.g : max2) * ensurePercent(percent);
    return convertHelper(_.f, new ColorHelper2(HSL, color2.r, s, color2.b, _.a, _.o));
  };
  ColorHelper2.prototype.grayscale = function() {
    return this.desaturate(1);
  };
  ColorHelper2.prototype.fade = function(percent) {
    var _ = this;
    var a = clampColor("a", ensurePercent(percent));
    return convertHelper(_.f, new ColorHelper2(_.f, _.r, _.g, _.b, a, true));
  };
  ColorHelper2.prototype.fadeOut = function(percent, relative) {
    var _ = this;
    var max2 = 1;
    var a = clampColor("a", _.a - (relative ? _.a : max2) * ensurePercent(percent));
    return convertHelper(_.f, new ColorHelper2(_.f, _.r, _.g, _.b, a, true));
  };
  ColorHelper2.prototype.fadeIn = function(percent, relative) {
    var _ = this;
    var max2 = 1;
    var a = clampColor("a", _.a + (relative ? _.a : max2) * ensurePercent(percent));
    return convertHelper(_.f, new ColorHelper2(_.f, _.r, _.g, _.b, a, true));
  };
  ColorHelper2.prototype.mix = function(mixin, weight) {
    var _ = this;
    var color2 = ensureColor(mixin);
    var g2 = convertHelper(RGB, _);
    var b = convertHelper(RGB, color2);
    var p2 = weight === void 0 ? 0.5 : weight;
    var w2 = 2 * p2 - 1;
    var a = Math.abs(g2.a - b.a);
    var w1 = ((w2 * a === -1 ? w2 : (w2 + a) / (1 + w2 * a)) + 1) / 2;
    var w22 = 1 - w1;
    var helper = new ColorHelper2(RGB, round(g2.r * w1 + b.r * w22), round(g2.g * w1 + b.g * w22), round(g2.b * w1 + b.b * w22), g2.a * p2 + b.a * (1 - p2), _.o || color2.o);
    return convertHelper(this.f, helper);
  };
  ColorHelper2.prototype.tint = function(weight) {
    return rgb(255, 255, 255).mix(this, weight);
  };
  ColorHelper2.prototype.shade = function(weight) {
    return rgb(0, 0, 0).mix(this, weight);
  };
  ColorHelper2.prototype.spin = function(degrees) {
    var _ = this;
    var color2 = convertHelper(HSL, _);
    return convertHelper(_.f, new ColorHelper2(HSL, modDegrees(color2.r + degrees), color2.g, color2.b, _.a, _.o));
  };
  return ColorHelper2;
}();
function toHex(n2) {
  var i2 = round(n2);
  return (i2 < 16 ? "0" : "") + i2.toString(16);
}
function modDegrees(n2) {
  return ((n2 < 0 ? 360 : 0) + n2 % 360) % 360;
}
function RGBtoHSL(r2, g2, b, a, hasAlpha) {
  var newR = r2 / 255;
  var newG = g2 / 255;
  var newB = b / 255;
  var min2 = Math.min(newR, newG, newB);
  var max2 = Math.max(newR, newG, newB);
  var l2 = (min2 + max2) / 2;
  var delta = max2 - min2;
  var h2;
  if (max2 === min2) {
    h2 = 0;
  } else if (newR === max2) {
    h2 = (newG - newB) / delta;
  } else if (newG === max2) {
    h2 = 2 + (newB - newR) / delta;
  } else if (newB === max2) {
    h2 = 4 + (newR - newG) / delta;
  } else {
    h2 = 0;
  }
  h2 = Math.min(h2 * 60, 360);
  if (h2 < 0) {
    h2 += 360;
  }
  var s;
  if (max2 === min2) {
    s = 0;
  } else if (l2 <= 0.5) {
    s = delta / (max2 + min2);
  } else {
    s = delta / (2 - max2 - min2);
  }
  return new ColorHelper(HSL, h2, s, l2, a, hasAlpha);
}
function HSLtoRGB(r2, g2, b, a, hasAlpha) {
  var newH = r2 / 360;
  var newS = g2;
  var newL = b;
  if (newS === 0) {
    var val = newL * 255;
    return new ColorHelper(RGB, val, val, val, a, hasAlpha);
  }
  var t2 = newL < 0.5 ? newL * (1 + newS) : newL + newS - newL * newS;
  var t1 = 2 * newL - t2;
  var newR = 0, newG = 0, newB = 0;
  for (var i2 = 0; i2 < 3; i2++) {
    var t3 = newH + 1 / 3 * -(i2 - 1);
    if (t3 < 0) {
      t3++;
    }
    if (t3 > 1) {
      t3--;
    }
    var val = void 0;
    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }
    val *= 255;
    if (i2 === 0) {
      newR = val;
    } else if (i2 === 1) {
      newG = val;
    } else {
      newB = val;
    }
  }
  return new ColorHelper(RGB, newR, newG, newB, a, hasAlpha);
}
function clampColor(channel2, value) {
  var min2 = 0;
  var max2 = maxChannelValues[channel2];
  return value < min2 ? min2 : value > max2 ? max2 : value;
}
function ensureColor(c) {
  return c instanceof ColorHelper ? c : color(c);
}
function parseHexCode(stringValue) {
  var match = stringValue.match(/#(([a-f0-9]{6})|([a-f0-9]{3}))$/i);
  if (!match) {
    return void 0;
  }
  var hex = match[1];
  var hexColor = parseInt(hex.length === 3 ? hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] : hex, 16);
  var r2 = hexColor >> 16 & 255;
  var b = hexColor >> 8 & 255;
  var g2 = hexColor & 255;
  return new ColorHelper(RGB, r2, b, g2, 1, false);
}
function parseColorFunction(colorString) {
  var cssParts = parseCSSFunction(colorString);
  if (!cssParts || !(cssParts.length === 4 || cssParts.length === 5)) {
    return void 0;
  }
  var fn = cssParts[0];
  var isRGBA = fn === "rgba";
  var isHSLA = fn === "hsla";
  var isRGB = fn === RGB;
  var isHSL = fn === HSL;
  var hasAlpha = isHSLA || isRGBA;
  var type;
  if (isRGB || isRGBA) {
    type = RGB;
  } else if (isHSL || isHSLA) {
    type = HSL;
  } else {
    throw new Error("unsupported color string");
  }
  var r2 = toFloat(cssParts[1]);
  var g2 = isRGB || isRGBA ? toFloat(cssParts[2]) : ensurePercent(cssParts[2]);
  var b = isRGB || isRGBA ? toFloat(cssParts[3]) : ensurePercent(cssParts[3]);
  var a = hasAlpha ? toFloat(cssParts[4]) : 1;
  return new ColorHelper(type, r2, g2, b, a, hasAlpha);
}
const dragImageSvg = `
  <svg height="75" width="120" viewBox="0 0 120 75" xmlns="http://www.w3.org/2000/svg" style="">
    <rect width="120" height="75" rx="3" style="
      opacity: 0.4;
      stroke: white;
      stroke-width: 3px;
      stroke-opacity: 0.7;
    "/>
  </svg>`;
let dragImage;
const loadDragImage = () => {
  if (dragImage)
    return dragImage;
  dragImage = new Image();
  dragImage.src = URL.createObjectURL(new Blob([dragImageSvg], { type: "image/svg+xml" }));
  return dragImage;
};
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { error: null };
  }
  componentDidCatch(error, info) {
    log$1.warn(error, info);
  }
  static getDerivedStateFromError() {
    return { error: true };
  }
  render() {
    if (this.state.error)
      return null;
    return this.props.children;
  }
}
const onDrop = async (data2, e2) => {
  e2.preventDefault();
  e2.stopPropagation();
  const { dropNodeId, dropType, project } = data2;
  const dragNodeId = e2.dataTransfer.getData("text/plain");
  log$1.debug("Compositor: Dropping", { dropType, dragNodeId, dropNodeId });
  if (dropNodeId === dragNodeId)
    return;
  const [dragNode, dropNode, dragParent, dropParent] = await Promise.all([project.compositor.get(dragNodeId), project.compositor.get(dropNodeId), project.compositor.getParent(dragNodeId), project.compositor.getParent(dropNodeId)]);
  if (dropType === "layout") {
    if (dragParent.id === dropNodeId)
      return;
    return CoreContext.Command.moveNode({ projectId: project.id, nodeId: dragNode.id, parentId: dropNode.id });
  } else {
    if (dragParent.id !== (dropParent == null ? void 0 : dropParent.id)) {
      return CoreContext.Command.swapNodes({ projectId: project.id, nodeAId: dragNode.id, nodeBId: dropNode.id });
    }
  }
  const childIds = dragParent.children.map((x2) => x2.id);
  return CoreContext.Command.reorderNodes({ projectId: project.id, parentId: dragParent.id, childIds: swapItems(dragNode.id, dropNode.id, childIds) });
};
let foundDropTarget = false;
const ElementTree = (props) => {
  var _a2, _b, _c;
  const isDragging = react$1.exports.useRef(false);
  const interactiveRef = react$1.exports.useRef();
  const transformRef = react$1.exports.useRef();
  const rootRef = react$1.exports.useRef();
  const { project, interactive = true, onElementDoubleClick, checkIsDragTarget, checkIsDropTarget } = react$1.exports.useContext(CompositorContext);
  const { nodeId } = props;
  const node = project.compositor.get(nodeId);
  if (!node)
    return null;
  const element = CoreContext.compositor.getElement(node);
  const layout = node.props.layout || "Row";
  const isDragTarget = interactive && checkIsDragTarget(node);
  const isDropTarget = interactive && checkIsDropTarget(node);
  let layoutDragHandlers = isDropTarget ? { onDrop: (e2) => {
    foundDropTarget = true;
    return onDrop({ dropType: "layout", dropNodeId: node.id, project }, e2);
  }, onDragOver: (e2) => {
    var _a3;
    e2.preventDefault();
    e2.stopPropagation();
    (_a3 = rootRef.current) == null ? void 0 : _a3.toggleAttribute("data-layout-drop-target-active", true);
  }, onDragLeave: (e2) => {
    var _a3;
    e2.preventDefault();
    e2.stopPropagation();
    (_a3 = rootRef.current) == null ? void 0 : _a3.toggleAttribute("data-layout-drop-target-active", false);
  } } : {};
  let transformDragHandlers = isDragTarget ? { draggable: true, ondrop: (e2) => {
    foundDropTarget = true;
    return onDrop({ dropType: "transform", dropNodeId: node.id, project }, e2);
  }, ondragstart: (e2) => {
    var _a3;
    isDragging.current = true;
    wrapperEl.toggleAttribute("data-dragging", true);
    log$1.debug("Compositor: Dragging", node.id);
    foundDropTarget = false;
    e2.dataTransfer.setData("text/plain", node.id);
    e2.dataTransfer.dropEffect = "move";
    e2.dataTransfer.setDragImage(dragImage, 10, 10);
    (_a3 = rootRef.current) == null ? void 0 : _a3.toggleAttribute("data-drag-target-active", true);
    window.__dragging = true;
  }, ondragend: (e2) => {
    var _a3;
    isDragging.current = false;
    if (!foundDropTarget) {
      log$1.info("Compositor: No drop target - deleting node", node);
      CoreContext.Command.deleteNode({ nodeId: node.id });
    }
    wrapperEl.toggleAttribute("data-dragging", true);
    log$1.debug("Compositor: DragEnd", e2);
    (_a3 = rootRef.current) == null ? void 0 : _a3.toggleAttribute("data-drag-target-active", false);
    wrapperEl.querySelectorAll("[data-item]").forEach((x2) => {
      x2.toggleAttribute("data-drag-target-active", false);
      x2.toggleAttribute("data-layout-drop-target-active", false);
      x2.toggleAttribute("data-transform-drop-target-active", false);
    });
    window.__dragging = false;
  }, ondragover: (e2) => {
    var _a3;
    e2.preventDefault();
    e2.stopPropagation();
    if (isDragging.current)
      return;
    (_a3 = rootRef.current) == null ? void 0 : _a3.toggleAttribute("data-transform-drop-target-active", true);
  }, ondragleave: (e2) => {
    var _a3;
    e2.preventDefault();
    e2.stopPropagation();
    (_a3 = rootRef.current) == null ? void 0 : _a3.toggleAttribute("data-transform-drop-target-active", false);
  } } : {};
  react$1.exports.useEffect(() => {
    if (transformRef.current && element) {
      transformRef.current.appendChild(element.root);
      Object.assign(transformRef.current.style, { width: "100%", height: "100%", position: "relative", overflow: "hidden" });
      Object.assign(element.root.style, { pointerEvents: isDragTarget ? "all" : "none", width: "100%", height: "100%", position: "relative", ...node.props.style || {} });
    }
  }, [transformRef.current, element]);
  react$1.exports.useEffect(() => {
    const onDoubleClick = isDragTarget ? () => onElementDoubleClick(node) : () => {
    };
    if (interactiveRef.current) {
      Object.assign(interactiveRef.current, transformDragHandlers);
      Object.assign(interactiveRef.current.style, { pointerEvents: isDragTarget ? "all" : "none" });
      interactiveRef.current.addEventListener("dblclick", onDoubleClick);
    }
    return () => {
      var _a3;
      (_a3 = interactiveRef.current) == null ? void 0 : _a3.removeEventListener("dblclick", onDoubleClick);
    };
  }, [interactiveRef.current]);
  const layoutProps = { layout, ...(_a2 = node.props.layoutProps) != null ? _a2 : {} };
  return /* @__PURE__ */ jsxs("div", { ref: rootRef, "data-id": node.id + "-x", "data-item": true, ...isDragTarget && { "data-drag-target": true }, ...isDropTarget && { "data-drop-target": true }, ...layoutDragHandlers, style: { position: "relative", width: ((_b = node.props.size) == null ? void 0 : _b.x) || "100%", height: ((_c = node.props.size) == null ? void 0 : _c.y) || "100%", pointerEvents: "none" }, children: [/* @__PURE__ */ jsx("div", { className: "interactive-overlay", ref: interactiveRef, style: { height: "100%", width: "100%", position: "absolute", zIndex: 2 } }), /* @__PURE__ */ jsxs("div", { className: "item-element", style: { display: "flex", flex: "0 0 auto", justifyContent: "center", width: "100%", height: "100%" }, children: [/* @__PURE__ */ jsx("div", { ref: transformRef }), /* @__PURE__ */ jsx(ErrorBoundary, { children: /* @__PURE__ */ jsx("ls-layout", { "data-id": node.id + "-x", props: JSON.stringify(layoutProps), layout, children: node.children.map((x2) => /* @__PURE__ */ jsx(ElementTree, { nodeId: x2.id }, x2.id)) }) })] })] });
};
const Root = (props) => {
  const { project } = react$1.exports.useContext(CompositorContext);
  const [tree, setTree] = react$1.exports.useState(null);
  react$1.exports.useEffect(() => {
    setTree(project.compositor.renderTree());
    return CoreContext.onInternal("NodeChanged", () => {
      setTree(project.compositor.renderTree());
    });
  }, []);
  react$1.exports.useEffect(() => {
    const root2 = project.compositor.getRoot();
    const { x: rootWidth } = root2.props.size;
    const updateCSS = () => {
      var _a2, _b, _c, _d, _e, _f;
      const { bannerStyle = BannerStyle.DEFAULT, primaryColor = "#ABABAB", showNameBanners } = (_a2 = project.props) != null ? _a2 : {};
      const logoPosition = (_f = (_e = (_b = project.props) == null ? void 0 : _b.logoPosition) != null ? _e : (_d = (_c = project.props) == null ? void 0 : _c.logo) == null ? void 0 : _d.logoPosition) != null ? _f : LogoPosition.TopRight;
      if (!bannerStyle || !primaryColor || !logoPosition)
        return;
      const CSS = themes[bannerStyle](primaryColor, showNameBanners, rootWidth / 1920);
      const logoCSS = themes[logoPosition](rootWidth / 1920);
      props.setStyle(`${CSS} ${logoCSS}` || "");
    };
    updateCSS();
    return CoreContext.onInternal("ProjectChanged", updateCSS);
  }, [project]);
  if (!tree)
    return null;
  return /* @__PURE__ */ jsx("div", { onDrop: (e2) => {
    foundDropTarget = true;
    e2.preventDefault();
  }, onDragOver: (e2) => {
    e2.preventDefault();
  }, onDragLeave: (e2) => {
    e2.preventDefault();
  }, style: { userSelect: "none", width: `${tree.props.size.x + PADDING * 2}px`, height: `${tree.props.size.y + PADDING * 2}px`, margin: PADDING + "px" }, children: /* @__PURE__ */ jsx("div", { style: { width: "100%", height: "100%", overflow: "hidden" }, children: /* @__PURE__ */ jsx(ElementTree, { nodeId: tree.id }) }) });
};
let wrapperEl;
let customStyleEl;
const PADDING = 0;
const render = (settings) => {
  const { containerEl, projectId, dragAndDrop = false, dblClickShowcase = dragAndDrop, checkDragTarget = scenelessProjectDragCheck, checkDropTarget = scenelessProjectDropCheck } = settings;
  const project = getProject(projectId);
  CoreContext.clients.LayoutApi().subscribeToLayout(project.layoutApi.layoutId);
  loadDragImage();
  const onElementDoubleClick = settings.onElementDoubleClick || dblClickShowcase && scenelessProjectDoubleClick(project);
  if (!containerEl || !project)
    return;
  if (!containerEl.shadowRoot) {
    containerEl.attachShadow({ mode: "open" });
    customStyleEl = document.createElement("style");
    const baseStyleEl = document.createElement("style");
    baseStyleEl.textContent = getStyle();
    wrapperEl = document.createElement("div");
    wrapperEl.id = "compositor-root";
    Object.assign(wrapperEl.style, { width: "100%", height: "100%", display: "flex", alignItems: "center", justifyContent: "center", transformOrigin: "center" });
    containerEl.shadowRoot.appendChild(baseStyleEl);
    containerEl.shadowRoot.appendChild(customStyleEl);
    containerEl.shadowRoot.appendChild(wrapperEl);
    const resizeObserver2 = new ResizeObserver((entries) => {
      setScale();
    });
    resizeObserver2.observe(containerEl);
  }
  const root2 = project.compositor.getRoot();
  const { x: rootWidth, y: rootHeight } = root2.props.size;
  const setScale = () => {
    let { width, height } = containerEl.getBoundingClientRect();
    const containerRatio = width / height;
    const compositorRatio = rootWidth / rootHeight;
    let scale;
    if (width && height) {
      if (compositorRatio > containerRatio) {
        scale = width / (rootWidth + PADDING * 2);
      } else {
        scale = height / (rootHeight + PADDING * 2);
      }
    } else {
      scale = 1;
    }
    wrapperEl.style.willChange = `transform`;
    wrapperEl.style.transform = `scale(${scale}) translateZ(0)`;
    window.__scale = scale;
    render2();
  };
  const render2 = () => {
    ReactDOM.render(/* @__PURE__ */ jsx(CompositorProvider, { project, interactive: dragAndDrop, onElementDoubleClick, checkIsDropTarget: checkDropTarget, checkIsDragTarget: checkDragTarget, children: /* @__PURE__ */ jsx(Root, { setStyle: (CSS) => {
      customStyleEl.textContent = CSS;
    } }) }), wrapperEl);
  };
  setScale();
};
const scenelessProjectDragCheck = (node) => {
  return node.props.name === "Participant" || node.props.sourceType === "RoomParticipant";
};
const scenelessProjectDropCheck = (node) => {
  return node.props.name === "Content";
};
const scenelessProjectDoubleClick = (project) => (node) => {
  var _a2;
  const content = project.compositor.nodes.find((x2) => x2.props.name === "Content");
  if (content) {
    const showcase = (_a2 = content.props.layoutProps) == null ? void 0 : _a2.showcase;
    CoreContext.Command.updateNode({ nodeId: content.id, props: { layoutProps: { ...content.props.layoutProps, showcase: showcase === node.id ? null : node.id } } });
  }
};
const CompositorContext = React.createContext({ interactive: false, project: null, checkIsDragTarget: () => false, checkIsDropTarget: () => false, onElementDoubleClick: () => {
} });
const CompositorProvider = ({ children, ...props }) => {
  return /* @__PURE__ */ jsx(CompositorContext.Provider, { value: { ...props }, children });
};
const getStyle = () => `
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Arial';
}

video {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.NameBanner {
  top: 100%;
  transform: translateY(-100%);
  left: 0;
  height: 30px;
  background: linear-gradient(90deg, rgba(0, 0, 0, 0.5) 50%, rgba(0, 0, 0, 0) 100%);
  padding: 0px 0px 0px 10px;
  color: rgba(255, 255, 255, 0.9);
  font-weight: bold;
  line-height: 30px;
  width: 100%;
  font-size: 28px;
  position: absolute;
}

ls-layout[layout="Presentation"][props*="\\"cover\\"\\:true"] > :first-child .NameBanner {
  top: 0% !important;
  transform: translateY(0%) !important;
}

[layout="Layered"] > [data-item] {
  transform: scale(1.003) !important;
}
[layout="Layered"] > [data-item]:nth-child(2) {
  transform: scale(1.0015) !important;
}
[layout="Layered"] > [data-item]:nth-child(1) {
  transform: scale(1) !important;
}

.logo {
  position: absolute !important;
}

#compositor-root[data-dragging] {}

[data-drag-target] {}
[data-drag-target]:hover > .interactive-overlay {
  box-shadow: 0 0 0 3px inset rgba(255, 255, 255, 0.5);
  cursor: grab;
}
[data-drop-target] {}
[data-drop-target]:hover {}
[data-drag-target][data-drag-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset rgba(255, 255, 255, 0.2);
}
[data-drag-target][data-drag-target-active] > .item-element {
  opacity: 0.8;
}
[data-layout-drop-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset yellow;
}
[data-transform-drop-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset white;
}
`;
var LogoPosition = /* @__PURE__ */ ((LogoPosition2) => {
  LogoPosition2["TopLeft"] = "top-left";
  LogoPosition2["TopRight"] = "top-right";
  LogoPosition2["BottomLeft"] = "bottom-left";
  LogoPosition2["BottomRight"] = "bottom-right";
  return LogoPosition2;
})(LogoPosition || {});
var BannerStyle = /* @__PURE__ */ ((BannerStyle2) => {
  BannerStyle2["DEFAULT"] = "default";
  BannerStyle2["MINIMAL"] = "minimal";
  BannerStyle2["BUBBLE"] = "bubble";
  return BannerStyle2;
})(BannerStyle || {});
const themes = { ["top-left"]: (scalar = 1280 / 1920) => {
  const scale = (px) => px * scalar + "px";
  return `
      .wrapper {
       height: ${scale(135)};
       width: ${scale(240)};
       margin-top:${scale(40)} !important;
       margin-left:${scale(40)} !important;
       top:0;
       left:0;
    }`;
}, ["top-right"]: (scalar = 1280 / 1920) => {
  const scale = (px) => px * scalar + "px";
  return `
      .wrapper {
       height: ${scale(135)};
       width: ${scale(240)};
       margin-top:${scale(40)} !important;
       margin-right:${scale(40)} !important;
       top:0;
       right:0;
    }`;
}, ["bottom-left"]: (scalar = 1280 / 1920) => {
  const scale = (px) => px * scalar + "px";
  return `
      .wrapper {
       height: ${scale(135)};
       width: ${scale(240)};
       margin-bottom:${scale(40)} !important;
       margin-left:${scale(40)} !important;
       bottom:0;
       left:0;
    }`;
}, ["bottom-right"]: (scalar = 1280 / 1920) => {
  const scale = (px) => px * scalar + "px";
  return `
      .wrapper {
       height: ${scale(135)};
       width: ${scale(240)};
       margin-bottom:${scale(40)} !important;
       margin-right:${scale(40)} !important;
       bottom:0;
       right:0;
    }`;
}, ["default"]: (primaryColor = "#ABABAB", showNameBanners = true, scalar = 1280 / 1920) => {
  const textColor = color(primaryColor).lightness() < 0.6 ? "#FFF" : "#000";
  const scale = (px) => px * scalar + "px";
  return `
      .Banner, .NameBanner {
        background: ${primaryColor} !important;
        margin-bottom: ${scale(40)} !important;
        transition: 300ms ease all;
        left: 0;

        /* Default Size 4 */
        font-size: ${scale(44)} !important;
        padding: ${scale(40)} ${scale(100)} !important;
        border-top-right-radius: ${scale(20)} !important;
        border-bottom-right-radius: ${scale(20)} !important;
      }
      .Banner-body, .NameBanner-body {
        color: ${textColor} !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
        font-size: ${scale(36)}
      }
      .NameBanner {
        transform-origin: 0 100%;
        margin: 0 !important;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${showNameBanners && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      .NameBanner[data-size="4"] {
        padding: ${scale(40)} ${scale(100)} !important;
        font-size: ${scale(44)} !important;
        border-top-right-radius: ${scale(20)} !important;
        border-bottom-right-radius: ${scale(20)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${scale(12)} ${scale(30)} !important;
        font-size: ${scale(44)} !important;
        border-top-right-radius: ${scale(20)} !important;
        border-bottom-right-radius: ${scale(20)} !important;
      }
      .NameBanner[data-size="2"] {
        padding: ${scale(12)} ${scale(20)} !important;
        font-size: ${scale(28)} !important;
        border-top-right-radius: ${scale(16)} !important;
        border-bottom-right-radius: ${scale(16)} !important;
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${scale(8)} ${scale(8)} !important;
        font-size: ${scale(20)} !important;
        border-top-right-radius: ${scale(8)} !important;
        border-bottom-right-radius: ${scale(8)} !important;
      }
      .NameBanner[data-size="0"] {
        opacity: 0;
        transform: translateX(-100%);
      }
    `;
}, ["minimal"]: (primaryColor = "#ABABAB", showNameBanners = true, scalar = 1280 / 1920) => {
  const textColor = "white";
  const scale = (px) => px * scalar + "px";
  return `
    .Banner, .NameBanner {
        background: ${color(primaryColor).fade(color(primaryColor).alpha() * 0.7).toString()} !important;
        padding: ${scale(40)} ${scale(40)} ${scale(40)} ${scale(60)} !important;
        position: relative !important;
        margin-bottom: ${scale(40)} !important;
        transition: 300ms ease all;
        font-size: ${scale(34)} !important;
        left: 0;
      }
      .Banner:before, .NameBanner:before {
        z-index: 1;
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.6);
        transition: 300ms ease all;
        opacity: ${color(primaryColor).alpha()};
      }
      .Banner:after, .NameBanner:after {
        z-index: 1;
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        transition: 300ms ease all;
        width: ${scale(20)};
        background: ${color(primaryColor)};
        opacity: ${color(primaryColor).alpha()};
      }
      .Banner-body, .NameBanner-body {
        color: ${textColor} !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
        font-size: ${scale(36)}
        position: relative;
        z-index: 2;
      }
      .Banner-header {
        font-size: ${scale(90)}
        position: relative;
        z-index: 2;
      }
      .NameBanner {
        transform-origin: 0 100%;
        margin: 0 !important;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${showNameBanners && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      .NameBanner[data-size="4"] {
        padding: ${scale(40)} ${scale(40)} ${scale(40)} ${scale(40 + 20)} !important;
        font-size: ${scale(34)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${scale(16)} ${scale(40)} ${scale(16)} ${scale(40 + 20)} !important;
        font-size: ${scale(34)} !important;
      }
      .NameBanner[data-size="2"] {
        padding: ${scale(12)} ${scale(24)} ${scale(12)} ${scale(24 + 20)} !important;
        font-size: ${scale(24)} !important;
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${scale(12)} ${scale(16)} ${scale(12)} ${scale(16 + 20)} !important;
        font-size: ${scale(18)} !important;
      }
      .NameBanner[data-size="0"] {
        opacity: 0 !important;
        transform: translateX(-100%);
      }
    `;
}, ["bubble"]: (primaryColor = "#ABABAB", showNameBanners = true, scalar = 1280 / 1920) => {
  const textColor = color(primaryColor).lightness() < 0.6 ? "#FFF" : "#000";
  const scale = (px) => px * scalar + "px";
  return `
      .Banner {
        transform: translateX(-50%);
        left: 50%;
        margin-bottom: ${scale(40)} !important;
      }

      .Banner, .NameBanner {
        background: ${color(primaryColor)} !important;
        color: ${textColor} !important;
        border-radius: 500px !important;
        transition: 300ms ease all;

        /* Default Style */
        border: 4px solid ${textColor} !important;
        padding: ${scale(40)} ${scale(80)} !important;
        font-size: ${scale(40)} !important;
      }
      .Banner-body, .NameBanner-body {
        color: ${textColor} !important;
        text-align: center !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
        font-size: ${scale(36)}
      }
      .NameBanner {
        transform-origin: 0% 100%;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${showNameBanners && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      .NameBanner[data-size="4"] {
        padding: ${scale(40)} ${scale(80)} ${scale(40)} ${scale(80)} !important;
        font-size: ${scale(40)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${scale(12)} ${scale(30)} ${scale(12)} ${scale(30)} !important;
        font-size: ${scale(40)} !important;
        margin: -${scale(20)} ${scale(20)};
      }
      .NameBanner[data-size="2"] {
        padding: ${scale(12)} ${scale(30)} ${scale(12)} ${scale(30)} !important;
        font-size: ${scale(26)} !important;
        margin: -${scale(8)} ${scale(8)};
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${scale(8)} ${scale(16)} ${scale(8)} ${scale(16)} !important;
        font-size: ${scale(18)} !important;
        border-width: ${scale(2)} !important;
        margin: -${scale(16)} ${scale(8)};
      }
      .NameBanner[data-size="0"] {
        opacity: 0 !important;
        transform: translateX(-100%);
      }
    `;
} };
var compositor$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, render, CompositorContext, LogoPosition, BannerStyle }, Symbol.toStringTag, { value: "Module" }));
const { state } = CoreContext;
const updateUserProps = async (payload) => {
  const collection = getUser();
  if (!collection)
    return;
  const props = { ...collection.props, ...payload.props };
  const response = await CoreContext.clients.LiveApi().collection.updateCollection({ collectionId: collection.id, updateMask: ["metadata"], metadata: { ...collection.metadata, props } });
  await triggerInternal$1("UserChanged", response.collection);
  return;
};
const createProject$1 = async (payload = {}) => {
  const { props = {}, size, settings = {} } = payload;
  const response = await CoreContext.Request.createProject({ settings, props, size });
  await triggerInternal$1("ProjectAdded", response.project);
  const internalProject = await hydrateProject(response.project, "ROLE_HOST");
  return toBaseProject(internalProject);
};
const deleteProject$1 = async (payload) => {
  const { projectId } = payload;
  await CoreContext.Request.deleteProject({ projectId });
  await triggerInternal$1("ProjectRemoved", { projectId });
  return;
};
const updateProjectProps = async (payload) => {
  const { projectId } = payload;
  const collectionId = getUser().id;
  const project = getProject(projectId);
  const props = { ...project.props, ...payload.props };
  const response = await CoreContext.clients.LiveApi().project.updateProject({ collectionId, projectId, updateMask: ["metadata"], metadata: { ...project.videoApi.project.metadata, props } });
  await triggerInternal$1("ProjectChanged", { project: response.project });
  return;
};
const updateProjectMeta = (payload) => updateProjectProps({ projectId: payload.projectId, props: payload.meta });
const updateProjectPropsWithoutTrigger = async (payload) => {
  const { projectId } = payload;
  const collectionId = getUser().id;
  const project = getProject(projectId);
  const props = { ...project.props, ...payload.props };
  await CoreContext.clients.LiveApi().project.updateProject({ collectionId, projectId, updateMask: ["metadata"], metadata: { ...project.videoApi.project.metadata, props } });
  return;
};
const setActiveProject = async (payload) => {
  const project = state.projects.find((x2) => x2.id === payload.projectId);
  if (!project) {
    state.activeProjectId = null;
    triggerInternal$1("ActiveProjectChanged", { projectId: null });
    return;
  }
  const currentProject = state.projects.find((x2) => x2.id === state.activeProjectId);
  if (project === currentProject)
    return;
  if (currentProject) {
    Array.from(webrtcManager.rooms.keys()).map(webrtcManager.removeRoom);
    await CoreContext.clients.LayoutApi().unsubscribeFromLayout(currentProject.layoutApi.layoutId);
    await CoreContext.clients.LiveApi().unsubscribeFromProject(currentProject.videoApi.project.collectionId, currentProject.videoApi.project.projectId);
  }
  await CoreContext.clients.LayoutApi().subscribeToLayout(project.layoutApi.layoutId);
  await CoreContext.clients.LiveApi().subscribeToProject(project.videoApi.project.collectionId, project.videoApi.project.projectId);
  CoreContext.clients.LiveApi().project.getProject({ collectionId: project.videoApi.project.collectionId, projectId: project.videoApi.project.projectId, status: true }).then((response) => {
    var _a2, _b;
    triggerInternal$1("ProjectChanged", { project: response.project, phase: (_a2 = response.status) == null ? void 0 : _a2.phase, broadcastId: (_b = response.status) == null ? void 0 : _b.broadcastId });
  });
  triggerInternal$1("ActiveProjectChanged", { projectId: project.id });
  return toBaseProject(project);
};
const joinRoom = async (payload) => {
  const { projectId, displayName = "Guest" } = payload;
  const project = state.projects.find((x2) => x2.id === projectId);
  let token = project.sfuToken;
  if (!token) {
    let { webrtcAccess } = await CoreContext.clients.LiveApi().authentication.createWebRtcAccessToken({ collectionId: project.videoApi.project.collectionId, projectId: project.videoApi.project.projectId, displayName });
    token = webrtcAccess.accessToken;
  }
  const tokenData = o(token);
  const roomName = tokenData.video.room;
  const url2 = new URL(CoreContext.clients.getLiveKitServer());
  const baseUrl = url2.host + url2.pathname;
  const roomContext = webrtcManager.ensureRoom(baseUrl, roomName, token);
  roomContext.bindApiClient(CoreContext.clients);
  await roomContext.connect();
  project.sfuToken = token;
  project.roomId = roomName;
  const room = getRoom(roomName);
  trigger$1("RoomJoined", { projectId: project.id, room });
  return room;
};
const createNode = async (payload) => {
  let { props = {}, parentId, index: index2, projectId = state.activeProjectId } = payload;
  const project = getProject(projectId);
  props = { ...props, layoutId: project.layoutApi.layoutId, type: "child" };
  const nodeId = await project.compositor.insert(props, parentId, index2);
  triggerInternal$1("NodeAdded", { projectId, nodeId });
  triggerInternal$1("NodeChanged", { projectId, nodeId: parentId });
  return project.compositor.get(nodeId);
};
const deleteNode = async (payload) => {
  var _a2;
  let { nodeId, projectId = state.activeProjectId } = payload;
  const project = getProject(projectId);
  const parentId = (_a2 = project.compositor.getParent(nodeId)) == null ? void 0 : _a2.id;
  project.compositor.remove(nodeId);
  triggerInternal$1("NodeRemoved", { projectId, nodeId });
  triggerInternal$1("NodeChanged", { projectId, nodeId: parentId });
};
const updateNode = async (payload) => {
  let { nodeId, props = {}, projectId = state.activeProjectId } = payload;
  const project = getProject(projectId);
  delete props.type;
  delete props.sourceType;
  project.compositor.update(nodeId, props);
  triggerInternal$1("NodeChanged", { projectId, nodeId });
  return project.compositor.get(nodeId);
};
const setNodeLayout = async (payload) => {
  let { nodeId, layout, projectId = state.activeProjectId, layoutProps = {} } = payload;
  const project = getProject(projectId);
  project.compositor.update(nodeId, { layout, layoutProps });
  triggerInternal$1("NodeChanged", { projectId, nodeId });
};
const moveNode = async (payload) => {
  const { nodeId, parentId, projectId = state.activeProjectId, index: index2 } = payload;
  const project = getProject(projectId);
  project.compositor.move(nodeId, parentId, index2);
  triggerInternal$1("NodeChanged", { projectId, nodeId });
};
const swapNodes = async (payload) => {
  var _a2, _b;
  const { nodeAId, nodeBId, projectId = state.activeProjectId } = payload;
  const project = getProject(projectId);
  const parentAId = (_a2 = project.compositor.getParent(nodeAId)) == null ? void 0 : _a2.id;
  const parentBId = (_b = project.compositor.getParent(nodeBId)) == null ? void 0 : _b.id;
  project.compositor.swap(nodeAId, nodeBId);
  triggerInternal$1("NodeChanged", { projectId, nodeId: parentAId });
  triggerInternal$1("NodeChanged", { projectId, nodeId: parentBId });
};
const reorderNodes = async (payload) => {
  const { parentId, childIds, projectId = state.activeProjectId } = payload;
  const project = getProject(projectId);
  project.compositor.reorder(parentId, childIds);
  triggerInternal$1("NodeChanged", { projectId, nodeId: parentId });
};
const startBroadcast = async (payload) => {
  const { projectId = state.activeProjectId } = payload;
  const project = getProject(projectId);
  await CoreContext.clients.LiveApi().project.startProjectBroadcast({ collectionId: project.videoApi.project.collectionId, projectId: project.videoApi.project.projectId });
};
const stopBroadcast = async (payload) => {
  const { projectId = state.activeProjectId } = payload;
  const project = getProject(projectId);
  await CoreContext.clients.LiveApi().project.stopProjectBroadcast({ collectionId: project.videoApi.project.collectionId, projectId: project.videoApi.project.projectId });
};
const addDestination = async (payload) => {
  var _a2;
  const { rtmpUrl, rtmpKey, enabled, projectId = state.activeProjectId, metadata = {}, props = {} } = payload;
  const project = getProject(projectId);
  const address = { rtmpPush: { key: rtmpKey, url: rtmpUrl } };
  const response = await ((_a2 = CoreContext.clients.LiveApi().destination) == null ? void 0 : _a2.createDestination({ collectionId: project.videoApi.project.collectionId, projectId: project.videoApi.project.projectId, address, enabled, metadata: { props: { ...metadata, ...props } } }));
  await triggerInternal$1("DestinationAdded", response.destination);
  return toBaseDestination(response.destination);
};
const removeDestination = async (payload) => {
  var _a2;
  const { destinationId, projectId = state.activeProjectId } = payload;
  const project = getProject(projectId);
  await ((_a2 = CoreContext.clients.LiveApi().destination) == null ? void 0 : _a2.deleteDestination({ collectionId: project.videoApi.project.collectionId, projectId: project.videoApi.project.projectId, destinationId }));
  await triggerInternal$1("DestinationRemoved", { projectId, destinationId });
  return;
};
const updateDestination = async (payload) => {
  var _a2;
  const { rtmpUrl, rtmpKey, destinationId, projectId = state.activeProjectId } = payload;
  const project = getProject(projectId);
  const rtmpPush = { key: rtmpKey, url: rtmpUrl };
  const response = await ((_a2 = CoreContext.clients.LiveApi().destination) == null ? void 0 : _a2.updateDestination({ collectionId: project.videoApi.project.collectionId, projectId: project.videoApi.project.projectId, destinationId, updateMask: ["address.rtmpPush"], address: { rtmpPush } }));
  await triggerInternal$1("DestinationChanged", response.destination);
  return;
};
const updateDestinationProps = async (payload) => {
  var _a2, _b;
  const { projectId = state.activeProjectId, destinationId, props = {} } = payload;
  const project = getProject(projectId);
  const destination = project.videoApi.project.destinations.find((x2) => x2.destinationId === destinationId);
  if (!destination)
    return;
  const response = await ((_b = CoreContext.clients.LiveApi().destination) == null ? void 0 : _b.updateDestination({ collectionId: project.videoApi.project.collectionId, projectId: project.videoApi.project.projectId, destinationId, updateMask: ["metadata"], metadata: { ...destination.metadata || {}, props: { ...((_a2 = destination.metadata) == null ? void 0 : _a2.props) || {}, ...props } } }));
  await triggerInternal$1("DestinationChanged", response.destination);
  return;
};
const updateDestinationMeta = (payload) => updateDestinationProps({ projectId: payload.projectId, destinationId: payload.destinationId, props: payload.metadata });
const setDestinationEnabled = async (payload) => {
  var _a2;
  const { enabled, destinationId, projectId = state.activeProjectId } = payload;
  const project = getProject(projectId);
  const destination = project.videoApi.project.destinations.find((x2) => destinationId === x2.destinationId);
  if (destination.enabled === enabled)
    return;
  const response = await ((_a2 = CoreContext.clients.LiveApi().destination) == null ? void 0 : _a2.updateDestination({ collectionId: project.videoApi.project.collectionId, projectId: project.videoApi.project.projectId, destinationId, updateMask: ["enabled"], enabled }));
  await triggerInternal$1("DestinationChanged", response.destination);
  const event2 = enabled ? "DestinationEnabled" : "DestinationDisabled";
  trigger$1(event2, { projectId, destinationId });
  return;
};
const setDestination = async (payload) => {
  var _a2, _b;
  const { rtmpUrl, rtmpKey, projectId = state.activeProjectId } = payload;
  const project = getProject(projectId);
  const rtmpPush = { key: rtmpKey, url: rtmpUrl };
  const enabled = true;
  if (project.videoApi.project.destinations.length > 0) {
    const response = await ((_a2 = CoreContext.clients.LiveApi().destination) == null ? void 0 : _a2.updateDestination({ collectionId: project.videoApi.project.collectionId, projectId: project.videoApi.project.projectId, destinationId: project.videoApi.project.destinations[0].destinationId, updateMask: ["address.rtmpPush"], address: { rtmpPush } }));
    await triggerInternal$1("DestinationChanged", response.destination);
  } else {
    const response = await ((_b = CoreContext.clients.LiveApi().destination) == null ? void 0 : _b.createDestination({ collectionId: project.videoApi.project.collectionId, projectId: project.videoApi.project.projectId, address: { rtmpPush }, enabled }));
    await triggerInternal$1("DestinationAdded", response.destination);
  }
  trigger$1("DestinationSet", { projectId, rtmpUrl, rtmpKey });
  return;
};
var commands$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, updateUserProps, createProject: createProject$1, deleteProject: deleteProject$1, updateProjectProps, updateProjectMeta, updateProjectPropsWithoutTrigger, setActiveProject, joinRoom, createNode, deleteNode, updateNode, setNodeLayout, moveNode, swapNodes, reorderNodes, startBroadcast, stopBroadcast, addDestination, removeDestination, updateDestination, updateDestinationProps, updateDestinationMeta, setDestinationEnabled, setDestination }, Symbol.toStringTag, { value: "Module" }));
const useActiveProjectRoom$1 = () => {
  const [room, setRoom] = react$1.exports.useState(null);
  react$1.exports.useEffect(() => useActiveProjectRoom(setRoom), []);
  return room;
};
const useDevices$1 = () => {
  const [devices, setDevices] = react$1.exports.useState({ webcams: [], microphones: [], speakers: [] });
  react$1.exports.useEffect(() => {
    return watchDevices(setDevices);
  }, []);
  return devices;
};
const StudioContext$1 = React.createContext({ studio: null, project: null, room: null, webcamId: null, microphoneId: null, setStudio: () => {
}, setProject: () => {
}, setRoom: () => {
}, setWebcamId: () => {
}, setMicrophoneId: () => {
}, projectCommands: {} });
const useStudio$2 = () => react$1.exports.useContext(StudioContext$1);
let stored = { webcamId: null, microphoneId: null };
try {
  stored.webcamId = localStorage == null ? void 0 : localStorage.getItem("__LS_webcam");
  stored.microphoneId = localStorage == null ? void 0 : localStorage.getItem("__LS_microphone");
} catch {
}
const StudioProvider = ({ children }) => {
  const [room, setRoom] = react$1.exports.useState();
  const [project, setProject] = react$1.exports.useState();
  const [studio, setStudio] = react$1.exports.useState();
  const [webcamId, setWebcamId] = react$1.exports.useState(stored.webcamId);
  const [microphoneId, setMicrophoneId] = react$1.exports.useState(stored.microphoneId);
  const projectCommands = react$1.exports.useMemo(() => project ? commands(project) : null, [project]);
  react$1.exports.useEffect(() => {
    if (!project)
      return;
  }, [project]);
  react$1.exports.useEffect(() => {
    if (!room)
      return;
    if (webcamId) {
      room.setCamera({ deviceId: webcamId }).catch((e2) => {
        console.warn(e2);
      });
    }
    if (microphoneId) {
      room.setMicrophone({ deviceId: microphoneId }).catch((e2) => {
        console.warn(e2);
      });
    }
  }, [room, webcamId, microphoneId]);
  return /* @__PURE__ */ jsx(StudioContext$1.Provider, { value: { studio, project, room, webcamId, microphoneId, setStudio, setProject, setRoom, setWebcamId: (id2) => {
    try {
      localStorage == null ? void 0 : localStorage.setItem("__LS_webcam", id2);
    } catch (e2) {
    }
    setWebcamId(id2);
  }, setMicrophoneId: (id2) => {
    try {
      localStorage == null ? void 0 : localStorage.setItem("__LS_microphone", id2);
    } catch (e2) {
    }
    setMicrophoneId(id2);
  }, projectCommands }, children });
};
var react = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, useActiveProjectRoom: useActiveProjectRoom$1, useDevices: useDevices$1, StudioContext: StudioContext$1, useStudio: useStudio$2, StudioProvider }, Symbol.toStringTag, { value: "Module" }));
const addingCache = { camera: /* @__PURE__ */ new Set(), screen: /* @__PURE__ */ new Set() };
const commands = (_project) => {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const projectId = _project.id;
  const root2 = _project.scene.getRoot();
  const { Command } = CoreContext;
  const background = root2.children.find((x2) => x2.props.id === "bg");
  const content = root2.children.find((x2) => x2.props.id === "content");
  const foreground = root2.children.find((x2) => x2.props.id === "foreground");
  let backgroundVideoContainer = (_a2 = background == null ? void 0 : background.children) == null ? void 0 : _a2.find((x2) => x2.props.id === "video-background");
  let backgroundContainer = (_b = background == null ? void 0 : background.children) == null ? void 0 : _b.find((x2) => x2.props.id === "bg-image");
  let backgroundImageContainer = (_c = background == null ? void 0 : background.children) == null ? void 0 : _c.find((x2) => x2.props.id === "image-background");
  let foregroundImageContainer = (_d = foreground == null ? void 0 : foreground.children) == null ? void 0 : _d.find((x2) => x2.props.id === "fg-image");
  (_e = foreground == null ? void 0 : foreground.children) == null ? void 0 : _e.find((x2) => x2.props.id === "image-overlay");
  let foregroundOverlayContainer = (_f = foreground == null ? void 0 : foreground.children) == null ? void 0 : _f.find((x2) => x2.props.id === "iframe-overlay");
  let foregroundVideoContainer2 = (_g = foreground == null ? void 0 : foreground.children) == null ? void 0 : _g.find((x2) => x2.props.id === "video-overlay");
  let foregroundLogoContainer = (_h = foreground == null ? void 0 : foreground.children) == null ? void 0 : _h.find((x2) => x2.props.id === "logo");
  let foregroundVideoContainer = (_i = foreground == null ? void 0 : foreground.children) == null ? void 0 : _i.find((x2) => x2.props.id === "fg-video");
  const coreProject = getProject(_project.id);
  let bannerContainer = (_j = foreground == null ? void 0 : foreground.children) == null ? void 0 : _j.find((x2) => x2.props.id === "fg-banners");
  const ensureForegroundContainers = async () => {
    const ensureBannerContainer = async () => {
      var _a3;
      if (!bannerContainer) {
        const nodeId = await coreProject.compositor.insert({ name: "BannerContainer", id: "fg-banners", layout: "Column", layoutProps: { cover: true } }, foreground.id);
        bannerContainer = (_a3 = foreground == null ? void 0 : foreground.children) == null ? void 0 : _a3.find((x2) => x2.props.id === nodeId);
        return nodeId;
      } else {
        return bannerContainer.id;
      }
    };
    const ensureForegroundImageContainer = async () => {
      var _a3;
      if (!foregroundImageContainer) {
        const nodeId = await coreProject.compositor.insert({ name: "ImageOverlay", id: "fg-image", layout: "Free" }, foreground.id);
        foregroundImageContainer = (_a3 = foreground == null ? void 0 : foreground.children) == null ? void 0 : _a3.find((x2) => x2.props.id === nodeId);
        return nodeId;
      } else {
        return foregroundImageContainer.id;
      }
    };
    const ensureForegroundImageContainer2 = async () => {
      var _a3;
      if (!foregroundOverlayContainer) {
        const nodeId = await coreProject.compositor.insert({ name: "Overlay", sourceType: "Overlay", id: "overlay", layout: "Free", style: { width: "100%", height: "100%", objectFit: "cover" } }, foreground.id);
        foregroundOverlayContainer = (_a3 = foreground == null ? void 0 : foreground.children) == null ? void 0 : _a3.find((x2) => x2.props.id === nodeId);
        return nodeId;
      } else {
        return foregroundOverlayContainer.id;
      }
    };
    const ensureForegroundVideoContainer2 = async () => {
      var _a3;
      if (!foregroundVideoContainer2) {
        const nodeId = await coreProject.compositor.insert({ name: "VideoOverlay2", sourceType: "Video2", proxySource: "Overlay", id: "video-overlay", layout: "Free", style: { width: "100%", height: "100%", objectFit: "cover" } }, foreground.id);
        foregroundVideoContainer2 = (_a3 = foreground == null ? void 0 : foreground.children) == null ? void 0 : _a3.find((x2) => x2.props.id === nodeId);
        return nodeId;
      } else {
        return foregroundVideoContainer2.id;
      }
    };
    const ensureForegroundVideoContainer = async () => {
      var _a3;
      if (!foregroundVideoContainer) {
        const nodeId = await coreProject.compositor.insert({ name: "VideoOverlay", id: "fg-video", layout: "Free" }, foreground.id);
        foregroundVideoContainer = (_a3 = foreground == null ? void 0 : foreground.children) == null ? void 0 : _a3.find((x2) => x2.props.id === nodeId);
        return nodeId;
      } else {
        return foregroundVideoContainer.id;
      }
    };
    const ensureForegroundLogoContainer = async () => {
      var _a3;
      if (!foregroundLogoContainer) {
        const nodeId = await coreProject.compositor.insert({ name: "Logo", layout: "Free", sourceType: "Logo", id: "logo", style: { width: "100%", height: "100%", objectFit: "contain", position: "unset" } }, foreground.id);
        foregroundLogoContainer = (_a3 = foreground == null ? void 0 : foreground.children) == null ? void 0 : _a3.find((x2) => x2.props.id === nodeId);
        return nodeId;
      } else {
        return foregroundLogoContainer.id;
      }
    };
    const ensureBackgroundContainer = async () => {
      var _a3;
      if (!backgroundContainer) {
        const nodeId = await coreProject.compositor.insert({ name: "ImageBackground", id: "bg-image", tagName: "img", sourceType: "Element", attributes: { src: "" }, fields: { style: { width: "100%", height: "100%", objectFit: "cover" } } }, background.id);
        backgroundContainer = (_a3 = background == null ? void 0 : background.children) == null ? void 0 : _a3.find((x2) => x2.props.id === nodeId);
        return nodeId;
      } else {
        return backgroundContainer.id;
      }
    };
    const ensureBackgroundImageContainer = async () => {
      var _a3;
      if (!backgroundImageContainer) {
        const nodeId = await coreProject.compositor.insert({ name: "ImageBackground2", sourceType: "Image2", proxySource: "Background", id: "image-background", layout: "Free", src: "", style: { width: "100%", height: "100%", objectFit: "cover" } }, background.id);
        backgroundImageContainer = (_a3 = background == null ? void 0 : background.children) == null ? void 0 : _a3.find((x2) => x2.props.id === nodeId);
        return nodeId;
      } else {
        return backgroundImageContainer.id;
      }
    };
    const ensureBackgroundVideoContainer = async () => {
      var _a3;
      if (!backgroundVideoContainer) {
        const nodeId = await coreProject.compositor.insert({ name: "VideoBackground", sourceType: "Video2", proxySource: "Background", id: "video-background", layout: "Free", style: { width: "100%", height: "100%", position: "absolute", objectFit: "cover" } }, background.id);
        backgroundVideoContainer = (_a3 = background == null ? void 0 : background.children) == null ? void 0 : _a3.find((x2) => x2.props.id === nodeId);
        return nodeId;
      } else {
        return backgroundVideoContainer.id;
      }
    };
    try {
      const baseForegroundLayers = await Promise.all([ensureBannerContainer(), ensureForegroundImageContainer(), ensureForegroundImageContainer2(), ensureForegroundVideoContainer(), ensureForegroundVideoContainer2(), ensureForegroundLogoContainer()]);
      await coreProject.compositor.reorder(foreground.id, baseForegroundLayers);
      const baseBackgroundLayers = await Promise.all([ensureBackgroundContainer(), ensureBackgroundImageContainer(), ensureBackgroundVideoContainer()]);
      await coreProject.compositor.reorder(background.id, baseBackgroundLayers);
    } catch (e2) {
    }
  };
  const commands2 = { getBackground() {
    return background;
  }, getContent() {
    return content;
  }, getForeground() {
    return foreground;
  }, getLayout() {
    return content.props.layout;
  }, getBanners() {
    var _a3;
    return ((_a3 = getProject(_project.id).props) == null ? void 0 : _a3.banners) || [];
  }, getOverlays() {
    return getProject(_project.id).props.overlays || [];
  }, getParticipants() {
    return content.children.filter((node) => {
      if (node.props.sourceType !== "RoomParticipant")
        return false;
      return true;
    });
  }, getLogo() {
    var _a3;
    return (_a3 = commands2.getProp("logo")) == null ? void 0 : _a3.id;
  }, removeLogo() {
    return commands2.setProp("logo", null);
  }, getImageOverlay() {
    var _a3, _b2;
    const foregroundImageIds = (_b2 = (_a3 = foregroundImageContainer == null ? void 0 : foregroundImageContainer.children) == null ? void 0 : _a3.map((x2) => {
      var _a4, _b3;
      return (_b3 = (_a4 = x2 == null ? void 0 : x2.props) == null ? void 0 : _a4.sourceProps) == null ? void 0 : _b3.id;
    })) != null ? _b2 : [];
    return foregroundImageIds.length > 1 ? foregroundImageIds : foregroundImageIds[0];
  }, getVideoOverlay() {
    var _a3, _b2;
    const foregroundVideoIds = (_b2 = (_a3 = foregroundVideoContainer == null ? void 0 : foregroundVideoContainer.children) == null ? void 0 : _a3.map((x2) => {
      var _a4, _b3;
      return (_b3 = (_a4 = x2 == null ? void 0 : x2.props) == null ? void 0 : _a4.sourceProps) == null ? void 0 : _b3.id;
    })) != null ? _b2 : [];
    return foregroundVideoIds.length > 1 ? foregroundVideoIds : foregroundVideoIds[0];
  }, autoPlayBackgroundVideo(attributes = { muted: true, autoplay: true }) {
    const backgroundVideo = background.children.find((x2) => x2.props.id === "bg-video");
    if (!backgroundVideo) {
      return;
    }
    CoreContext.Command.updateNode({ nodeId: backgroundVideo.id, props: { ...backgroundVideo.props, attributes: { ...backgroundVideo.props.attributes, ...attributes } } });
  }, autoPlayVideoOverlay(overlayId, attributes = { muted: true, autoplay: true }) {
    var _a3;
    const overlay = (_a3 = foregroundVideoContainer == null ? void 0 : foregroundVideoContainer.children) == null ? void 0 : _a3.find((x2) => {
      var _a4, _b2;
      return ((_b2 = (_a4 = x2.props) == null ? void 0 : _a4.sourceProps) == null ? void 0 : _b2.id) === overlayId;
    });
    if (!overlay) {
      return;
    }
    if (overlay.props.sourceProps.type === "video") {
      CoreContext.Command.updateNode({ nodeId: overlay.id, props: { ...overlay.props, attributes: { ...overlay.props.attributes, ...attributes } } });
    }
  }, async removeImageOverlay(overlayId) {
    const overlay = foregroundImageContainer.children.find((x2) => {
      var _a3, _b2;
      return ((_b2 = (_a3 = x2.props) == null ? void 0 : _a3.sourceProps) == null ? void 0 : _b2.id) === overlayId;
    });
    if (overlay) {
      CoreContext.Command.deleteNode({ nodeId: overlay.id });
    }
  }, async removeVideoOverlay(overlayId) {
    var _a3;
    const overlay = (_a3 = foregroundVideoContainer == null ? void 0 : foregroundVideoContainer.children) == null ? void 0 : _a3.find((x2) => {
      var _a4, _b2;
      return ((_b2 = (_a4 = x2.props) == null ? void 0 : _a4.sourceProps) == null ? void 0 : _b2.id) === overlayId;
    });
    if (overlay) {
      CoreContext.Command.deleteNode({ nodeId: overlay.id });
    }
    const allForegroundChildrens = foreground.children.filter((f2) => f2.props.id !== "fg-video");
    allForegroundChildrens.forEach((nodes) => {
      nodes.children.forEach((node) => {
        var _a4, _b2, _c2;
        if (((_c2 = (_b2 = (_a4 = node.props) == null ? void 0 : _a4.fields) == null ? void 0 : _b2.style) == null ? void 0 : _c2.opacity) === 0) {
          node.props.fields.style.opacity = 1;
          CoreContext.Command.updateNode({ nodeId: node.id, props: { ...node.props } });
        }
      });
    });
  }, async addImageOverlay(overlayId, src) {
    var _a3, _b2, _c2;
    const imageOverlay = foregroundImageContainer.children.find((x2) => x2.props.id === "img-overlay");
    if (imageOverlay && ((_b2 = (_a3 = imageOverlay == null ? void 0 : imageOverlay.props) == null ? void 0 : _a3.sourceProps) == null ? void 0 : _b2.id) === overlayId) {
      return;
    }
    let imageProps = { id: "img-overlay", sourceType: "Element", sourceProps: { type: "image", id: overlayId }, tagName: "img", attributes: { src }, fields: { style: { transition: "opacity 300ms ease 0ms, transform, width, height", "-webkit-transition": "opacity 300ms ease 0ms, transform, width, height", opacity: 1, objectFit: "cover" } } };
    const vidOverlay = (_c2 = foregroundVideoContainer == null ? void 0 : foregroundVideoContainer.children) == null ? void 0 : _c2.find((x2) => x2.props.id === "vid-overlay");
    if (vidOverlay) {
      imageProps.fields.style.opacity = 0;
    }
    if (!imageOverlay) {
      await CoreContext.Command.createNode({ props: imageProps, parentId: foregroundImageContainer.id, index: foregroundImageContainer.children.length });
    } else {
      CoreContext.Command.updateNode({ nodeId: imageOverlay.id, props: { ...imageOverlay.props, ...imageProps } });
    }
  }, async addVideoOverlay(overlayId, src, attributes = { playsinline: true, disablepictureinpicture: true, autoplay: true }) {
    var _a3, _b2, _c2;
    const videoOverlay = (_a3 = foregroundVideoContainer == null ? void 0 : foregroundVideoContainer.children) == null ? void 0 : _a3.find((x2) => x2.props.id === "vid-overlay");
    if (videoOverlay && ((_c2 = (_b2 = videoOverlay == null ? void 0 : videoOverlay.props) == null ? void 0 : _b2.sourceProps) == null ? void 0 : _c2.id) === overlayId) {
      return;
    }
    let videoProps = { id: "vid-overlay", sourceType: "LS-Video", sourceProps: { type: "video", id: overlayId }, tagName: "video", attributes: { ...attributes, src, id: overlayId } };
    const allForegroundChildrens = foreground.children.filter((f2) => f2.props.id !== "fg-video");
    allForegroundChildrens.forEach((nodes) => {
      nodes.children.forEach((node) => {
        var _a4, _b3, _c3;
        if (((_c3 = (_b3 = (_a4 = node.props) == null ? void 0 : _a4.fields) == null ? void 0 : _b3.style) == null ? void 0 : _c3.opacity) === 1) {
          node.props.fields.style.opacity = 0;
          CoreContext.Command.updateNode({ nodeId: node.id, props: { ...node.props } });
        }
      });
    });
    if (!videoOverlay) {
      await CoreContext.Command.createNode({ props: videoProps, parentId: foregroundVideoContainer.id, index: foregroundVideoContainer.children.length });
    } else {
      CoreContext.Command.updateNode({ nodeId: videoOverlay.id, props: { ...videoOverlay.props, ...videoProps } });
    }
  }, getBackgroundMedia() {
    var _a3, _b2, _c2;
    const backgroundChild = background.children.filter((x2) => x2);
    return (_c2 = (_b2 = (_a3 = backgroundChild[0]) == null ? void 0 : _a3.props) == null ? void 0 : _b2.attributes) == null ? void 0 : _c2.src;
  }, getBackgroundImage() {
    var _a3, _b2, _c2;
    const backgroundChild = background.children.filter((x2) => x2.props.id === "bg-image");
    return (_c2 = (_b2 = (_a3 = backgroundChild[0]) == null ? void 0 : _a3.props) == null ? void 0 : _b2.attributes) == null ? void 0 : _c2.src;
  }, getBackgroundVideo() {
    var _a3, _b2, _c2;
    const backgroundChild = background.children.filter((x2) => x2.props.id === "bg-video");
    return (_c2 = (_b2 = (_a3 = backgroundChild[0]) == null ? void 0 : _a3.props) == null ? void 0 : _b2.attributes) == null ? void 0 : _c2.src;
  }, async setBackgroundImage(src) {
    var _a3, _b2;
    const backgroundImage = background.children.find((x2) => x2.props.id === "bg-image");
    if (backgroundImage && ((_b2 = (_a3 = backgroundImage == null ? void 0 : backgroundImage.props) == null ? void 0 : _a3.attributes) == null ? void 0 : _b2.src) === src) {
      return;
    }
    const backgroundVideo = background.children.find((x2) => x2.props.id === "bg-video");
    if (backgroundVideo) {
      CoreContext.Command.deleteNode({ nodeId: backgroundVideo.id });
    }
    if (!backgroundImage) {
      await CoreContext.Command.createNode({ props: { name: "ImageBackground", id: "bg-image", tagName: "img", sourceType: "Element", attributes: { src }, fields: { style: { width: "100%", height: "100%", objectFit: "cover" } } }, parentId: background.id, index: background.children.length });
    } else {
      CoreContext.Command.updateNode({ nodeId: backgroundImage.id, props: { attributes: { ...backgroundImage.props.attributes, src } } });
    }
  }, async setBackgroundVideo(src, attributes = { loop: true, autoplay: true }) {
    var _a3, _b2;
    const backgroundVideo = background.children.find((x2) => x2.props.id === "bg-video");
    if (backgroundVideo && ((_b2 = (_a3 = backgroundVideo == null ? void 0 : backgroundVideo.props) == null ? void 0 : _a3.attributes) == null ? void 0 : _b2.src) === src) {
      return;
    }
    const backgroundImage = background.children.find((x2) => x2.props.id === "bg-image");
    if (backgroundImage) {
      CoreContext.Command.deleteNode({ nodeId: backgroundImage.id });
    }
    if (!backgroundVideo) {
      await CoreContext.Command.createNode({ props: { name: "VideoBackground", id: "bg-video", sourceType: "LS-Video", attributes: { ...attributes, src }, fields: { style: { width: "100%", height: "100%", objectFit: "cover" } } }, parentId: background.id, index: background.children.length });
    } else {
      CoreContext.Command.updateNode({ nodeId: backgroundVideo.id, props: { attributes: { ...backgroundVideo.props.attributes, ...attributes, src } } });
    }
  }, addLogo(logoId, props) {
    const exisitingLogo = getProject(_project.id).props.logo || null;
    if (exisitingLogo) {
      if (exisitingLogo.id === logoId) {
        return Command.updateProjectProps({ projectId, props: { logo: exisitingLogo } });
      }
    }
    const meta = props.meta || { style: { height: "100%", width: "100%" } };
    const newLogo = { id: logoId, props: { ...props, type: "logo", meta } };
    Command.updateProjectProps({ projectId, props: { logo: newLogo } });
  }, addBanner(props = {}) {
    var _a3;
    const meta = props.meta || {};
    const banner = { id: generateId(), props: { ...props, meta } };
    const existingBanners = ((_a3 = getProject(projectId).props) == null ? void 0 : _a3.banners) || [];
    return Command.updateProjectProps({ projectId, props: { banners: [...existingBanners, banner] } });
  }, editBanner(id2, props = {}) {
    const existingBanners = commands2.getBanners();
    const banners = existingBanners.map((x2) => {
      if (x2.id !== id2)
        return x2;
      return { ...x2, props };
    });
    return Command.updateProjectProps({ projectId, props: { banners } });
  }, removeBanner(id2) {
    var _a3;
    const existingBanners = commands2.getBanners();
    (_a3 = bannerContainer == null ? void 0 : bannerContainer.children) == null ? void 0 : _a3.forEach((x2) => {
      if (x2.props.bannerId !== id2)
        return;
      CoreContext.Command.deleteNode({ nodeId: x2.id });
    });
    return Command.updateProjectProps({ projectId, props: { banners: existingBanners.filter((x2) => x2.id !== id2) } });
  }, setActiveBanner(id2) {
    commands2.getBanners();
    const [existingBannerNode, ...excessBannerNodes] = (bannerContainer == null ? void 0 : bannerContainer.children) || [];
    excessBannerNodes.forEach((x2) => {
      CoreContext.Command.deleteNode({ nodeId: x2.id });
    });
    if (!existingBannerNode) {
      return CoreContext.Command.createNode({ parentId: bannerContainer == null ? void 0 : bannerContainer.id, props: { sourceType: "Banner", bannerId: id2 } });
    } else {
      CoreContext.Command.updateNode({ nodeId: existingBannerNode.id, props: { bannerId: id2 } });
    }
  }, getActiveBanner() {
    var _a3, _b2, _c2, _d2;
    return (_d2 = (_c2 = (_b2 = (_a3 = bannerContainer.children) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.props) == null ? void 0 : _c2.bannerId) != null ? _d2 : null;
  }, getImageOverlay2() {
    const existingImageOverlays = CoreContext.compositor.getSources("Overlay").filter((x2) => {
      var _a3, _b2;
      return ((_b2 = (_a3 = x2.props) == null ? void 0 : _a3.meta) == null ? void 0 : _b2.type) === "image-overlay";
    });
    const foregroundImageIds = existingImageOverlays.map((f2) => f2 == null ? void 0 : f2.id);
    return foregroundImageIds.length > 1 ? foregroundImageIds : foregroundImageIds[0];
  }, getVideoOverlay2() {
    const existingVideoOverlays = CoreContext.compositor.getSources("Overlay").filter((x2) => x2.props.type === "video-overlay");
    const foregroundVideoIds = existingVideoOverlays.map((f2) => f2 == null ? void 0 : f2.id);
    return foregroundVideoIds.length > 1 ? foregroundVideoIds : foregroundVideoIds[0];
  }, getCustomOverlay() {
    const existingCustomOverlays = CoreContext.compositor.getSources("Overlay").filter((x2) => {
      var _a3, _b2;
      return ((_b2 = (_a3 = x2.props) == null ? void 0 : _a3.meta) == null ? void 0 : _b2.type) === "html-overlay";
    });
    const foregroundCustomOverlayIds = existingCustomOverlays.map((f2) => f2 == null ? void 0 : f2.id);
    return foregroundCustomOverlayIds.length > 1 ? foregroundCustomOverlayIds : foregroundCustomOverlayIds[0];
  }, async removeCustomOverlay(overlayId) {
    const existingOverlays = commands2.getOverlays();
    return Command.updateProjectProps({ projectId, props: { overlays: existingOverlays.filter((x2) => x2.id !== overlayId) } });
  }, async removeImageOverlay2(overlayId) {
    const existingOverlays = commands2.getOverlays();
    return Command.updateProjectProps({ projectId, props: { overlays: existingOverlays.filter((x2) => x2.id !== overlayId) } });
  }, async removeVideoOverlay2(overlayId) {
    const existingOverlays = commands2.getOverlays();
    const reamningOverlays = existingOverlays.filter((x2) => x2.id !== overlayId);
    const allForegroundOverlays = reamningOverlays.filter((f2) => f2.props.type !== "video-overlay");
    const newForegroundLayers = allForegroundOverlays.map((overlay) => {
      return { ...overlay, props: { ...overlay.props, meta: { ...overlay.props.meta, style: { opacity: 1 } } } };
    });
    Command.updateProjectProps({ projectId, props: { overlays: newForegroundLayers } });
  }, async addCustomOverlay(overlayId, props = {}) {
    const existingOverlays = commands2.getOverlays();
    const overlay = existingOverlays.find((x2) => x2.id === overlayId);
    if (overlay) {
      const overlayIndex = existingOverlays.findIndex((x2) => x2.id === overlayId);
      if (overlayIndex > -1) {
        const shallowOverlays = JSON.parse(JSON.stringify(existingOverlays));
        shallowOverlays.splice(overlayIndex, 1, overlay);
        return Command.updateProjectProps({ projectId, props: { overlays: shallowOverlays } });
      }
    }
    const vidOverlay = existingOverlays.find((x2) => x2.props.type === "video-overlay");
    const meta = props.meta || { type: "html-overlay" };
    const newOverlay = { id: overlayId, props: { ...props, type: "overlay", meta: { ...meta, ...{ ...vidOverlay && { style: { opacity: 0 } } } } } };
    const nonHTMLOverlays = existingOverlays.filter((x2) => x2.props.type !== "overlay");
    Command.updateProjectProps({ projectId, props: { overlays: [...nonHTMLOverlays, newOverlay] } });
  }, async addImageOverlay2(overlayId, props = {}) {
    const existingOverlays = commands2.getOverlays();
    const overlay = existingOverlays.find((x2) => x2.id === overlayId);
    if (overlay) {
      const overlayIndex = existingOverlays.findIndex((x2) => x2.id === overlayId);
      if (overlayIndex > -1) {
        const shallowOverlays = JSON.parse(JSON.stringify(existingOverlays));
        shallowOverlays.splice(overlayIndex, 1, overlay);
        return Command.updateProjectProps({ projectId, props: { overlays: shallowOverlays } });
      }
    }
    const vidOverlay = existingOverlays.find((x2) => x2.props.type === "video-overlay");
    const meta = props.meta || { type: "image-overlay" };
    const newOverlay = { id: overlayId, props: { ...props, type: "overlay", meta: { ...meta, ...{ ...vidOverlay && { style: { opacity: 0 } } } } } };
    const nonImageOverlays = existingOverlays.filter((x2) => x2.props.type !== "overlay");
    Command.updateProjectProps({ projectId, props: { overlays: [...nonImageOverlays, newOverlay] } });
  }, async addVideoOverlay2(overlayId, props = {}) {
    const existingOverlays = commands2.getOverlays();
    const overlay = existingOverlays.find((x2) => x2.id === overlayId);
    if (overlay) {
      const overlayIndex = existingOverlays.findIndex((x2) => x2.id === overlayId);
      if (overlayIndex > -1) {
        const shallowOverlays = JSON.parse(JSON.stringify(existingOverlays));
        shallowOverlays.splice(overlayIndex, 1, overlay);
        return Command.updateProjectProps({ projectId, props: { overlays: shallowOverlays } });
      }
    }
    const allForegroundOverlays = existingOverlays == null ? void 0 : existingOverlays.filter((f2) => f2.props.type !== "video-overlay");
    const newForegroundLayers = allForegroundOverlays == null ? void 0 : allForegroundOverlays.map((overlay2) => {
      return { ...overlay2, props: { ...overlay2.props, meta: { ...overlay2.props.meta, style: { opacity: 0 } } } };
    });
    const meta = props.meta || {};
    const newOverlay = { id: overlayId, props: { ...props, type: "video-overlay", meta } };
    Command.updateProjectProps({ projectId, props: { overlays: [...newForegroundLayers, newOverlay] } });
  }, setLayout(layout, layoutProps = {}) {
    const showcase = content.props.layoutProps.showcase;
    Command.setNodeLayout({ nodeId: content.id, layout, layoutProps: { showcase, ...layoutProps } });
  }, getBackgroundMedia2(type) {
    const backgroundMedia = CoreContext.compositor.getSources("Background");
    const backgroundMediaIds = type ? backgroundMedia.filter((x2) => x2.props.type === type).map((x2) => x2.id) : backgroundMedia.map((x2) => x2.id);
    return backgroundMediaIds[0];
  }, getBackgroundImage2() {
    return commands2.getBackgroundMedia2("image-background");
  }, getBackgroundVideo2() {
    return commands2.getBackgroundMedia2("video-background");
  }, async setBackgroundImage2(backgroundId, props = {}) {
    const exisitingBackground = getProject(_project.id).props.background || null;
    if (exisitingBackground) {
      if (exisitingBackground.id === backgroundId) {
        return Command.updateProjectProps({ projectId, props: { background: exisitingBackground } });
      }
    }
    const meta = props.meta || {};
    const newBackground = { id: backgroundId, props: { ...props, type: "image-background", meta } };
    Command.updateProjectProps({ projectId, props: { background: newBackground } });
  }, async setBackgroundVideo2(backgroundId, props = {}) {
    const exisitingBackground = getProject(_project.id).props.background || null;
    if (exisitingBackground) {
      if (exisitingBackground.id === backgroundId) {
        return Command.updateProjectProps({ projectId, props: { background: exisitingBackground } });
      }
    }
    const meta = props.meta || {};
    const newBackground = { id: backgroundId, props: { ...props, type: "video-background", meta } };
    Command.updateProjectProps({ projectId, props: { background: newBackground } });
  }, setShowcase(participantId, type = "camera") {
    var _a3;
    const node = commands2.getParticipantNode(participantId, type);
    return CoreContext.Command.updateNode({ nodeId: content.id, props: { layoutProps: { ...content.props.layoutProps, showcase: (_a3 = node == null ? void 0 : node.id) != null ? _a3 : null } } });
  }, useShowcase(cb2) {
    const sendState = () => {
      const nodeId = content.props.layoutProps.showcase;
      const node = content.children.find((x2) => x2.id === nodeId);
      if (!node)
        return cb2({ participantId: null, type: null });
      const { sourceProps } = node.props;
      return cb2({ participantId: sourceProps.id, type: sourceProps.type });
    };
    sendState();
    return CoreContext.onInternal("NodeChanged", (payload) => {
      if (payload.nodeId !== content.id)
        return;
      sendState();
    });
  }, async addParticipant(participantId, props = {}, type = "camera") {
    if (addingCache[type].has(participantId))
      return;
    const { isMuted = false, isHidden = false, volume = 1 } = props;
    const existing = content.children.find((x2) => {
      var _a3, _b2;
      return ((_a3 = x2.props.sourceProps) == null ? void 0 : _a3.id) === participantId && ((_b2 = x2.props.sourceProps) == null ? void 0 : _b2.type) === type;
    });
    if (existing)
      return;
    addingCache[type].add(participantId);
    const currentFirst = content.children[0];
    let index2 = content.children.length;
    if (type === "screen" && (currentFirst == null ? void 0 : currentFirst.props.sourceProps.type) !== "screen") {
      index2 = 0;
    }
    await CoreContext.Command.createNode({ props: { name: "Participant", sourceType: "RoomParticipant", sourceProps: { type, id: participantId }, volume, isMuted, isHidden }, parentId: content.id, index: index2 }).finally(() => {
      addingCache[type].delete(participantId);
    });
  }, addParticipantScreenshare(participantId, props = {}) {
    return commands2.addParticipant(participantId, props, "screen");
  }, removeParticipant(participantId, type = "camera") {
    content.children.filter((x2) => {
      var _a3, _b2;
      return ((_a3 = x2.props.sourceProps) == null ? void 0 : _a3.id) === participantId && ((_b2 = x2.props.sourceProps) == null ? void 0 : _b2.type) === type && x2.props.sourceType === "RoomParticipant";
    }).forEach((x2) => {
      CoreContext.Command.deleteNode({ nodeId: x2.id });
    });
  }, removeParticipantScreenshare(participantId) {
    return commands2.removeParticipant(participantId, "screen");
  }, getParticipantNode(id2, type = "camera") {
    return content.children.find((x2) => {
      var _a3, _b2;
      return ((_a3 = x2.props.sourceProps) == null ? void 0 : _a3.id) === id2 && ((_b2 = x2.props.sourceProps) == null ? void 0 : _b2.type) === type;
    });
  }, getParticipantState(participantId, type = "camera") {
    var _a3;
    return (_a3 = commands2.getParticipantNode(participantId, type)) == null ? void 0 : _a3.props;
  }, useParticipantState(participantId, cb2, type = "camera") {
    let participantNode = commands2.getParticipantNode(participantId, type);
    const sendState = () => {
      cb2(participantNode == null ? void 0 : participantNode.props);
    };
    const childListener = CoreContext.onInternal("NodeChanged", (payload) => {
      if (payload.nodeId !== content.id)
        return;
      const previous = participantNode;
      participantNode = commands2.getParticipantNode(participantId, type);
      if (previous !== participantNode) {
        sendState();
      }
    });
    const participantListener = CoreContext.onInternal("NodeChanged", (payload) => {
      if (!participantNode || payload.nodeId !== participantNode.id)
        return;
      sendState();
    });
    sendState();
    return () => {
      childListener();
      participantListener();
    };
  }, setParticipantVolume(participantId, volume) {
    const node = commands2.getParticipantNode(participantId);
    if (!node)
      return;
    CoreContext.Command.updateNode({ nodeId: node.id, props: { volume } });
  }, setParticipantMuted(participantId, isMuted) {
    const node = commands2.getParticipantNode(participantId);
    if (!node)
      return;
    CoreContext.Command.updateNode({ nodeId: node.id, props: { isMuted } });
  }, setParticipantHidden(participantId, isHidden) {
    const node = commands2.getParticipantNode(participantId);
    if (!node)
      return;
    CoreContext.Command.updateNode({ nodeId: node.id, props: { isHidden } });
  }, pruneParticipants() {
    const room = getProjectRoom(projectId);
    if (!room)
      return;
    content.children.filter((node) => {
      var _a3, _b2;
      if (node.props.sourceType !== "RoomParticipant")
        return false;
      const nodeSourceType = (_a3 = node.props.sourceProps) == null ? void 0 : _a3.type;
      const nodeParticipant = room.getParticipant((_b2 = node.props.sourceProps) == null ? void 0 : _b2.id);
      if (!nodeParticipant)
        return true;
      if (nodeSourceType === "camera")
        return false;
      const participantTracks = nodeParticipant.trackIds.map((x2) => room.getTrack(x2)).filter(Boolean);
      const hasAvailableTrack = participantTracks.some((track) => {
        const sourceType = track.type === dist$1.Track.Source.Camera || track.type === dist$1.Track.Source.Microphone ? "camera" : "screen";
        return sourceType === nodeSourceType;
      });
      return !hasAvailableTrack;
    }).forEach((x2) => {
      CoreContext.Command.deleteNode({ nodeId: x2.id });
    });
  }, getProp(prop) {
    return getProject(_project.id).props[prop];
  }, setProp(prop, val) {
    return Command.updateProjectProps({ projectId, props: { [prop]: val } });
  }, useProp(prop, cb2) {
    return CoreContext.on("ProjectChanged", (payload) => {
      if (projectId === payload.project.id) {
        cb2(payload.project.props[prop]);
      }
    });
  } };
  const ensureValid = async () => {
    await ensureForegroundContainers();
    beforeInit(commands2);
  };
  ensureValid();
  return commands2;
};
const create = async (settings = {}, props = {}, size) => {
  return CoreContext.Command.createProject({ settings, props, size });
};
const beforeInit = (commands2) => {
  const videoOverLay = commands2.getVideoOverlay();
  if (videoOverLay) {
    commands2.autoPlayVideoOverlay(videoOverLay, { muted: true, autoplay: true });
  }
  const backgroundVideo = commands2.getBackgroundVideo();
  if (backgroundVideo) {
    commands2.autoPlayBackgroundVideo({ muted: true, autoplay: true });
  }
};
const createCompositor = async (layoutId, size, settings) => {
  const { backgroundImage, layout, layoutProps = {} } = settings;
  const project = await CoreContext.compositor.createProject({ props: { name: "Root", type: "sceneless-project", sourceType: "Element", layout: "Layered", size, isRoot: true, tagName: "div", fields: { style: { background: "black" } } } }, layoutId);
  const root2 = project.getRoot();
  const baseLayers = await Promise.all([project.insert({ name: "Background", id: "bg", layout: "Free" }, root2.id), project.insert({ id: "content", name: "Content", layout, layoutProps }, root2.id), project.insert({ id: "foreground", name: "Overlays", layout: "Free" }, root2.id)]);
  await project.reorder(root2.id, baseLayers);
  const foreground = root2.children.find((x2) => x2.props.id === "foreground");
  const baseForegroundLayers = await Promise.all([project.insert({ name: "ImageOverlay", id: "fg-image", layout: "Free" }, foreground.id), project.insert({ name: "Overlay", sourceType: "Overlay", id: "overlay", layout: "Free", style: { width: "100%", height: "100%", objectFit: "cover" } }, foreground.id), project.insert({ name: "BannerContainer", id: "fg-banners", layout: "Column", layoutProps: { cover: true } }, foreground.id), project.insert({ name: "VideoOverlay", id: "fg-video", layout: "Free" }, foreground.id), project.insert({ name: "VideoOverlay2", layout: "Free", sourceType: "Video2", proxySource: "Overlay", id: "video-overlay", style: { width: "100%", height: "100%", objectFit: "cover" } }, foreground.id), project.insert({ name: "Logo", layout: "Free", sourceType: "Logo", id: "logo", style: { width: "100%", height: "100%", objectFit: "contain", position: "unset" } }, foreground.id)]);
  await project.reorder(foreground.id, baseForegroundLayers);
  const background = root2.children.find((x2) => x2.props.id === "bg");
  const baseBackgroundLayers = await Promise.all([project.insert({ name: "ImageBackground", id: "bg-image", tagName: "img", sourceType: "Element", attributes: { src: backgroundImage }, fields: { style: { width: "100%", height: "100%", objectFit: "cover" } } }, background.id), project.insert({ name: "ImageBackground2", sourceType: "Image2", proxySource: "Background", id: "image-background", layout: "Free", src: backgroundImage, style: { width: "100%", height: "100%", objectFit: "cover" } }, background.id), project.insert({ name: "VideoBackground", sourceType: "Video2", proxySource: "Background", id: "video-background", layout: "Free", style: { width: "100%", height: "100%", objectFit: "cover" } }, background.id)]);
  await project.reorder(background.id, baseBackgroundLayers);
  return project;
};
var scenelessProject = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, commands, create, beforeInit, createCompositor }, Symbol.toStringTag, { value: "Module" }));
const useActiveProjectRoom = (cb2) => {
  const project = getProject(CoreContext.state.activeProjectId);
  cb2(project ? getRoom(project.roomId) : null);
  return CoreContext.on("RoomJoined", () => {
    const project2 = getProject(CoreContext.state.activeProjectId);
    cb2(project2 ? getRoom(project2.roomId) : null);
  });
};
var callbacks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, useActiveProjectRoom }, Symbol.toStringTag, { value: "Module" }));
var index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, React: react, ScenelessProject: scenelessProject, Callback: callbacks, Room: webrtc, Compositor: compositor$1 }, Symbol.toStringTag, { value: "Module" }));
const runFilters = (node, filters = []) => {
  return filters.reduce((node2, filter2) => filter2(node2), node);
};
const createDefault = () => {
  return { root: document.createElement("div") };
};
const init$2 = (settings = {}, compositor2, sourceManager) => {
  const transforms2 = {};
  const defaultTransforms = settings.defaultTransforms || {};
  const registerTransform = (declaration) => {
    asArray(declaration).forEach((x2) => {
      transforms2[x2.name] = x2;
    });
  };
  const nodeElementIndex = {};
  const elementSourceIndex = {};
  const elementSourceTypeIndex = {};
  const getElementsBySourceType = (type) => {
    return elementSourceTypeIndex[type] || [];
  };
  const getElementsBySource = (sourceId) => {
    return elementSourceIndex[sourceId] || [];
  };
  const getElementByNodeId = (name2) => {
    return nodeElementIndex[name2];
  };
  const getTransformByName = (name2) => {
    return transforms2[name2];
  };
  compositor2.on("SourceChanged", (source2) => {
    const elements = getElementsBySource(source2.id);
    elements.forEach((element) => {
      const node = compositor2.getNode(element.nodeId);
      element._onUpdateHandlers.forEach((x2) => x2(node.props || {}));
    });
  });
  compositor2.on("AvailableSourcesChanged", ({ type, sources: sources2 }) => {
    const elements = getElementsBySourceType(type);
    elements.forEach((x2) => {
      updateSourceForNode(x2.nodeId);
    });
  });
  const updateSourceForNode = (nodeId) => {
    var _a2, _b, _c;
    const element = getElementByNodeId(nodeId);
    if (!element)
      return;
    const transform = getTransformByName(element.transformName);
    if (!transform.useSource)
      return;
    const node = compositor2.getNode(nodeId);
    const elementSourceType = element.proxySource ? element.proxySource : element.sourceType;
    const sources2 = sourceManager.getSources(elementSourceType);
    const source2 = transform.useSource(sources2, node.props);
    const previousValue = element.sourceValue;
    const newValue = source2 == null ? void 0 : source2.value;
    if (element.source !== source2) {
      if (elementSourceIndex[(_a2 = element.source) == null ? void 0 : _a2.id]) {
        elementSourceIndex[(_b = element.source) == null ? void 0 : _b.id] = elementSourceIndex[(_c = element.source) == null ? void 0 : _c.id].filter((x2) => x2.nodeId !== nodeId);
      }
      elementSourceIndex[source2 == null ? void 0 : source2.id] = [...elementSourceIndex[source2 == null ? void 0 : source2.id] || [], element];
    }
    element.source = source2;
    element.sourceValue = newValue;
    if (!Object.is(previousValue, newValue)) {
      element._onNewSourceHandlers.forEach((x2) => x2(source2));
    }
  };
  const renderTree = (node) => {
    const element = getElement(node);
    const filters = [];
    const result = runFilters(node, filters);
    updateSourceForNode(node.id);
    element == null ? void 0 : element._onUpdateHandlers.forEach((x2) => x2(node.props || {}));
    return { ...result, children: result.children.map(renderTree) };
  };
  const getElement = (node) => {
    if (nodeElementIndex[node.id])
      return nodeElementIndex[node.id];
    const { props = {} } = node;
    const { sourceType, proxySource } = props;
    if (!sourceType)
      return null;
    let transformName = defaultTransforms[sourceType];
    let transform;
    if (transformName) {
      transform = transforms2[transformName];
    } else {
      transform = Object.values(transforms2).find((x2) => x2.sourceType === sourceType);
    }
    if (!transform) {
      throw new Error("Could not find matching transform for sourceType: " + sourceType);
    }
    const _onNewSourceHandlers = [];
    const _onUpdateHandlers = [];
    const _onRemoveHandlers = [];
    const _disposables = [];
    const create5 = transform.create || createDefault;
    const result = { ...create5({ onEvent: (event2, cb2, ...args) => {
      const dispose = compositor2.on(event2, cb2, ...args);
      _disposables.push(dispose);
      return dispose;
    }, onNewSource: (cb2) => _onNewSourceHandlers.push(cb2), onUpdate: (cb2) => _onUpdateHandlers.push(cb2), onRemove: (cb2) => _onRemoveHandlers.push(cb2) }, node.props), proxySource, sourceType, nodeId: node.id, transformName: transform.name, _onNewSourceHandlers, _onUpdateHandlers, _disposables };
    nodeElementIndex[node.id] = result;
    const elementSourceType = proxySource ? proxySource : sourceType;
    elementSourceTypeIndex[elementSourceType] = [...elementSourceTypeIndex[elementSourceType] || [], result];
    if (transform.useSource) {
      updateSourceForNode(node.id);
    }
    const listeners2 = [compositor2.on("NodeRemoved", ({ nodeId }) => {
      if (nodeId === node.id) {
        const node2 = compositor2.getNode(nodeId);
        const { sourceType: sourceType2 = "Element" } = node2.props;
        listeners2.forEach((x2) => x2 == null ? void 0 : x2());
        _disposables.forEach((x2) => x2 == null ? void 0 : x2());
        _onRemoveHandlers.forEach((x2) => x2 == null ? void 0 : x2());
        delete nodeElementIndex[node2.id];
        const elementSourceType2 = proxySource ? proxySource : sourceType2;
        elementSourceTypeIndex[elementSourceType2] = elementSourceTypeIndex[elementSourceType2].filter((x2) => x2 !== nodeElementIndex[node2.id]);
      }
    })];
    return result;
  };
  return { transforms: transforms2, nodeElementIndex, elementSourceTypeIndex, registerTransform, getElementsBySourceType, getElementByNodeId, getTransformByName, updateSourceForNode, renderTree, getElement };
};
const TRANSITION_DURATION = 300;
const findLayoutUp = (start2, comparator, failedAttempts = 0) => {
  const MAX_FAILED_TRAVERSAL_DEPTH = 4;
  const parent2 = start2.parentElement;
  if (parent2 instanceof Layout) {
    failedAttempts = 0;
    if (!comparator)
      return parent2;
    if (comparator(parent2))
      return parent2;
  }
  if (parent2) {
    if (failedAttempts > MAX_FAILED_TRAVERSAL_DEPTH)
      return null;
    return findLayoutUp(parent2, comparator, failedAttempts + 1);
  }
  return null;
};
const TRANSITION_FIELDS = "opacity, transform, width, height, left, right, top, bottom, inset";
const layoutIndex = {};
const parentIdIndex = {};
const childIndex = {};
let rootLayout;
let _cid = 1;
const ignoredAttributes = ["style", "id", "className"];
let tickOps = {};
const tick = () => {
  nextTick = null;
  if (window.__dragging) {
    nextTick = nextTick || requestAnimationFrame(tick);
    return;
  }
  const inserted = /* @__PURE__ */ new Set();
  const removed = /* @__PURE__ */ new Set();
  const removeFinished = /* @__PURE__ */ new Set();
  Object.entries(tickOps).forEach(([layoutId, ops]) => {
    ops.forEach(([type, layoutId2, childId]) => {
      switch (type) {
        case "childInserted": {
          if (removed.has(childId)) {
            removed.delete(childId);
          } else {
            inserted.add(childId);
          }
          break;
        }
        case "childRemoved": {
          if (inserted.has(childId)) {
            inserted.delete(childId);
          } else {
            removed.add(childId);
          }
          break;
        }
        case "childRemoveFinished": {
          removeFinished.add(childId);
          break;
        }
      }
    });
  });
  try {
    removed.forEach((x2) => {
      var _a2, _b, _c;
      const el = childIndex[x2];
      const childList = Array.from(((_a2 = el.parentEl) == null ? void 0 : _a2.children) || []);
      if (el.nextSiblingEl && childList.includes(el.nextSiblingEl)) {
        (_b = el.parentEl) == null ? void 0 : _b.insertBefore(el, el.nextSiblingEl);
      } else {
        el.nextSiblingEl = null;
        (_c = el.parentEl) == null ? void 0 : _c.append(el);
      }
      el.runRemove();
    });
    removeFinished.forEach((x2) => {
      const el = childIndex[x2];
      if (el.removed) {
        if (el.previousSiblingEl) {
          el.previousSiblingEl.nextSiblingEl = el.nextSiblingEl;
        }
        if (el.nextSiblingEl) {
          el.nextSiblingEl.previousSiblingEl = el.previousSiblingEl;
        }
        return;
      }
    });
    const scale = window.__scale;
    Object.entries(tickOps).forEach(([layoutId, ops]) => {
      const layoutEl = layoutIndex[layoutId];
      const rect = layoutEl.getBoundingClientRect();
      const size = { x: rect.width / scale, y: rect.height / scale };
      layoutEl.updatePositions({ size, inserted, removed });
    });
  } catch (e2) {
    log$1.warn("Failed to run Layout ops", e2);
  }
  tickOps = {};
};
let nextTick;
const queueOp = (op) => {
  const [_, nodeId] = op;
  const nodeOps = tickOps[nodeId] || [];
  tickOps[nodeId] = [...nodeOps, op];
  nextTick = nextTick || requestAnimationFrame(tick);
};
class Layout extends HTMLElement {
  constructor() {
    super();
    this.isFirst = true;
    this.isUpdating = false;
    this.cid = ++_cid;
  }
  log(...args) {
    var _a2;
    log$1.debug(...args, { id: this.dataset.id, parent: (_a2 = this.parentLayout) == null ? void 0 : _a2.dataset.id }, this);
  }
  connectedCallback() {
    var _a2;
    this.parentEl = this.parentElement;
    this.parentLayout = findLayoutUp(this);
    this.slotEl = this.closest(`[data-layout-child]`);
    Array.from(this.children).forEach((x2) => this.initializeChild(x2));
    if (!rootLayout)
      rootLayout = this;
    layoutIndex[this.dataset.id] = this;
    parentIdIndex[this.dataset.id] = (_a2 = this.parentLayout) == null ? void 0 : _a2.id;
    Object.assign(this.style, { width: "100%", height: "100%", position: "absolute", top: "0px", left: "0px", pointerEvents: "none", boxSizing: "border-box" });
    if (this.mutationObserver)
      this.mutationObserver.disconnect();
    this.mutationObserver = new MutationObserver((mutations) => {
      if (!this.isConnected)
        return;
      mutations.forEach((x2) => {
        if (x2.type === "attributes" && !ignoredAttributes.includes(x2.attributeName)) {
          queueOp(["attributesChanged", this.dataset.id]);
        } else if (x2.type === "childList") {
          x2.addedNodes.forEach((child) => {
            const inMemory = childIndex[child.dataset.id];
            if (child.removed)
              return;
            if (!inMemory) {
              this.initializeChild(child);
            } else if (inMemory !== child) {
              this.initializeChild(child);
              child.setAttribute("style", inMemory.getAttribute("style"));
              child.data = inMemory.data;
            }
            queueOp(["childInserted", this.dataset.id, child.dataset.id]);
          });
          x2.removedNodes.forEach((child) => {
            if (child.removed)
              return;
            queueOp(["childRemoved", this.dataset.id, child.dataset.id]);
          });
        }
      });
    });
    this.mutationObserver.observe(this, { childList: true, attributes: true });
    if (!this.latestSize) {
      queueOp(["attributesChanged", this.dataset.id]);
    }
  }
  disconnectedCallback() {
  }
  adoptedCallback() {
  }
  updatePositions(options2) {
    if (this.isUpdating)
      return;
    this.isUpdating = true;
    const { size, inserted = /* @__PURE__ */ new Set(), removed = /* @__PURE__ */ new Set() } = options2;
    this.nodes = Array.from(this.children || []).filter((x2) => !x2.removed).map((x2, i2) => {
      const props2 = getElementAttributes(x2);
      return { id: x2.dataset.id, props: props2, children: [] };
    });
    const props = JSON.parse(this.getAttribute("props") || "{}");
    this.latestSize = size;
    const layoutArgs = { id: this.dataset.id, props, children: this.nodes, size };
    let positions = layoutChildren(layoutArgs);
    Promise.all(Object.entries(positions).map(async ([id2, childPosition]) => {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      let childEl = childIndex[id2] || this.querySelector(`[data-layout-child][data-id="${id2}"]`);
      const data2 = { ...childEl.data, ...childPosition };
      childEl.data = data2;
      const { size: size2, position, zIndex = 1, opacity = 1, borderRadius = 0, entryTransition = {}, exitTransition = {} } = data2;
      if (childEl) {
        if (childEl.removed)
          return;
        if (exitTransition)
          childEl.data.exitTransition = exitTransition;
        if (entryTransition)
          childEl.data.entryTransition = entryTransition;
        childEl.data.size = size2;
        childEl.data.position = position;
        const scale = window.__scale;
        const parentPosition = this.getBoundingClientRect();
        const parentWidth = parentPosition.width / scale;
        const childRight = parentWidth - sizeToNum(position.x, parentWidth) - sizeToNum(size2.x, parentWidth);
        const parentHeight = parentPosition.height / scale;
        const childBottom = parentHeight - sizeToNum(position.y, parentHeight) - sizeToNum(size2.y, parentHeight);
        Object.assign(childEl.style, { position: "absolute", transformOrigin: "50% 50%", transitionDuration: "0ms", transitionDelay: "0ms", transform: `translate3d(0, 0, 0) scaleX(1) scaleY(1)`, visibility: "visible", boxSizing: "border-box", overflow: "hidden", borderRadius: borderRadius + "px", width: "auto", height: "auto" });
        let delay2 = "0ms";
        let duration = this.isFirst ? asDuration(0) : asDuration(TRANSITION_DURATION);
        const withEntry = inserted.has(id2);
        if (withEntry) {
          Object.assign(childEl.style, { transitionProperty: TRANSITION_FIELDS, transitionDuration: "0ms", transitionTimingFunction: (_a2 = entryTransition.timingFn) != null ? _a2 : "ease", transform: `translate3d(calc(${asSize((_c = (_b = entryTransition.offset) == null ? void 0 : _b.x) != null ? _c : 0)}), calc(${asSize((_e = (_d = entryTransition.offset) == null ? void 0 : _d.y) != null ? _e : 0)}), 0) scaleX(${(_g = (_f = entryTransition.scale) == null ? void 0 : _f.x) != null ? _g : 1}) scaleY(${(_i = (_h = entryTransition.scale) == null ? void 0 : _h.y) != null ? _i : 1})`, opacity: (_j = entryTransition.opacity) != null ? _j : opacity, left: asSize(position.x) || 0, right: asSize(childRight) || 0, top: asSize(position.y) || 0, bottom: asSize(childBottom) || 0 });
          delay2 = asDuration((_k = entryTransition.delay) != null ? _k : 0);
        } else if (childEl.data.rootOffset) {
          const rootPosition = rootLayout.getBoundingClientRect();
          const parentPosition2 = this.getBoundingClientRect();
          const parentOffset = { x: parentPosition2.x / scale - rootPosition.x / scale, y: parentPosition2.y / scale - rootPosition.y / scale };
          const parentRight = parentOffset.x + parentPosition2.width / scale;
          const childRight2 = childEl.data.rootOffset.x + Number(childEl.data.size.x);
          const parentBottom = parentOffset.y + parentPosition2.height / scale;
          const childBottom2 = childEl.data.rootOffset.y + Number(childEl.data.size.y);
          ({ x: childEl.data.rootOffset.x - parentOffset.x, y: childEl.data.rootOffset.y - parentOffset.y, right: parentRight - childRight2, bottom: parentBottom - childBottom2 });
        }
        childEl.addEventListener("transitionstart", () => {
          childEl.style.zIndex = String(zIndex + 1);
        });
        await new Promise((resolve) => window.setTimeout(resolve));
        Object.assign(childEl.style, { transitionProperty: TRANSITION_FIELDS, transitionDuration: duration, transitionDelay: delay2, transform: `translate3d(0, 0, 0) scaleX(1) scaleY(1)`, opacity, left: asSize(position.x) || 0, top: asSize(position.y) || 0, width: parentWidth ? "auto" : size2.x, right: parentWidth ? asSize(childRight) || 0 : "auto", height: parentHeight ? "auto" : size2.y, bottom: parentHeight ? asSize(childBottom) || 0 : "auto", zIndex });
        const updateRootOffset = () => {
          const rootPosition = rootLayout.getBoundingClientRect();
          const globalPosition = childEl.getBoundingClientRect();
          childEl.data.rootOffset = { x: globalPosition.x / scale - rootPosition.x / scale, y: globalPosition.y / scale - rootPosition.y / scale };
        };
        updateRootOffset();
        childEl.addEventListener("transitionend", () => {
          childEl.style.zIndex = String(zIndex);
          updateRootOffset();
        });
      }
    })).then(() => {
      this.isUpdating = false;
    });
    this.isFirst = false;
    Array.from(this.querySelectorAll("ls-layout")).forEach((x2) => {
      if (!positions[x2.dataset.id])
        return;
      const childSize = positions[x2.dataset.id].size;
      x2.updatePositions({ size: { x: sizeToNum(childSize.x, size.x), y: sizeToNum(childSize.y, size.y) } });
    });
  }
  initializeChild(childEl) {
    var _a2;
    if (!((_a2 = childEl.dataset) == null ? void 0 : _a2.id))
      return log$1.warn("Layout: Child requires `data-id` at the time it is added to a Layout");
    childEl._remove = childEl.remove;
    childEl.remove = () => {
      this.removeChild(childEl);
    };
    if (!childEl.mutationObserver) {
      childEl.mutationObserver = new MutationObserver((mutations) => {
        mutations.forEach((x2) => {
          if (x2.type === "attributes") {
            if (x2.attributeName === "style")
              return;
            queueOp(["childAttributesChanged", this.dataset.id, childEl.dataset.id]);
          }
        });
      });
      childEl.mutationObserver.observe(childEl, { childList: true, attributes: true });
    }
    const data2 = { entryTransition: { delay: 0, opacity: 0, scale: { x: 1, y: 1 }, offset: { x: 0, y: 0 } }, exitTransition: { delay: 0, opacity: 0, scale: { x: 1, y: 1 }, offset: { x: 0, y: 0 } }, position: { x: 0, y: 0 }, size: { x: 0, y: 0 }, opacity: 0, fit: "cover", borderRadius: 0, zIndex: 1 };
    childEl.data = data2;
    childEl.parentEl = childEl.parentElement;
    childEl.nextSiblingEl = childEl.nextSibling;
    childEl.previousSiblingEl = childEl.previousSibling;
    if (childEl.previousSiblingEl) {
      childEl.previousSiblingEl.nextSiblingEl = childEl;
    }
    childEl.toggleAttribute("data-layout-child", true);
    childIndex[childEl.dataset.id] = childEl;
    childEl.runRemove = async () => {
      var _a3, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      childEl.removed = true;
      const duration = TRANSITION_DURATION;
      await new Promise((resolve) => window.setTimeout(resolve));
      Object.assign(childEl.style, { zIndex: 0, transitionDelay: asDuration(0), transitionDuration: asDuration(duration), transitionProperty: TRANSITION_FIELDS, transitionTimingFunction: (_a3 = data2.exitTransition.timingFn) != null ? _a3 : "ease", transform: `translate3d(calc(${asSize((_c = (_b = data2.exitTransition.offset) == null ? void 0 : _b.x) != null ? _c : 0)}), calc( ${asSize((_e = (_d = data2.exitTransition.offset) == null ? void 0 : _d.y) != null ? _e : 0)}), 0) scaleX(${(_g = (_f = data2.exitTransition.scale) == null ? void 0 : _f.x) != null ? _g : 1}) scaleY(${(_i = (_h = data2.exitTransition.scale) == null ? void 0 : _h.y) != null ? _i : 1})`, opacity: (_j = data2.exitTransition.opacity) != null ? _j : 0 });
      childEl.removed = true;
      childEl.transition = new Promise((resolve) => {
        const onFinished = () => {
          childEl.transition = null;
          childEl._remove();
          queueOp(["childRemoveFinished", this.dataset.id, childEl.dataset.id]);
          clearTimeout(timeout2);
          resolve();
        };
        const timeout2 = window.setTimeout(onFinished, parseInt(String(duration)) + 600);
        childEl.addEventListener("transitionend", onFinished, { once: true });
      });
      return childEl.transition;
    };
  }
}
const ensureLayoutContainer = (size) => {
  const existing = document.getElementById("__ls-layout-container");
  if (existing) {
    Object.assign(existing.style, { width: size.x + "px", height: size.y + "px" });
    return existing;
  }
  const container = document.createElement("div");
  container.id = "__ls-layout-container";
  Object.assign(container.style, { position: "fixed", visibility: "hidden", top: 0 + "px", left: 0 + "px", zIndex: -1, width: size.x + "px", height: size.y + "px" });
  document.body.append(container);
  return container;
};
const layoutChildren = ({ id: id2, props = {}, children, size }) => {
  const layoutArgs = { props, children, size };
  const result = htmlLayouts[props.layout] ? htmlLayouts[props.layout].layout(layoutArgs) : htmlLayouts.Free.layout(layoutArgs);
  if (!(result instanceof HTMLElement)) {
    return result;
  }
  const domChildren = Array.from(result.querySelectorAll("[data-node-id]"));
  const wrapper = document.createElement("div");
  wrapper.style.height = result.style.height = size.y + "px";
  wrapper.style.width = result.style.width = size.x + "px";
  wrapper.style.position = "absolute";
  wrapper.style.top = "0px";
  wrapper.style.left = "0px";
  wrapper.style.boxSizing = "border-box";
  wrapper.setAttribute("data-wrapper-id", id2);
  wrapper.append(result);
  const layoutContainer = ensureLayoutContainer(size);
  const previousDom = layoutContainer.querySelector(`[data-wrapper-id="${id2}"]`);
  if (previousDom) {
    previousDom.replaceWith(wrapper);
  } else {
    layoutContainer.append(wrapper);
  }
  const parentRect = result.getBoundingClientRect();
  const positions = {};
  domChildren.forEach((el) => {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    const id22 = el.dataset.nodeId;
    if (!id22)
      return;
    const opacity = Number((_a2 = el.dataset.opacity) != null ? _a2 : el.style.opacity || 1);
    const rect = el.getBoundingClientRect();
    let newPosition = { position: { x: rect.x - parentRect.x + "px", y: rect.y - parentRect.y + "px" }, size: { x: rect.width + "px", y: rect.height + "px" }, opacity, zIndex: (_b = el.data) == null ? void 0 : _b.zIndex, entryTransition: (_d = (_c = el.data) == null ? void 0 : _c.entryTransition) != null ? _d : {}, exitTransition: (_f = (_e = el.data) == null ? void 0 : _e.exitTransition) != null ? _f : {}, borderRadius: (_h = (_g = el.data) == null ? void 0 : _g.borderRadius) != null ? _h : 0 };
    if (`${props.showcase}-x` === id22) {
      newPosition.position = { x: parentRect.x + "px", y: parentRect.y + "px" };
      newPosition.size = { x: parentRect.width + "px", y: parentRect.height + "px" };
      newPosition.zIndex = 10;
    }
    positions[id22] = newPosition;
    positionIndex[el.dataset.nodeId] = newPosition;
  });
  return positions;
};
const positionIndex = {};
const htmlLayouts = {};
const registerLayout = (declaration) => {
  asArray(declaration).forEach((x2) => {
    htmlLayouts[x2.name] = x2;
  });
};
const sourceTypes = {};
const init$1 = (settings = {}, compositor2) => {
  const sourceIndex = {};
  const sourceTypeIndex = {};
  const handleSourceChanged = (source2) => {
    compositor2.triggerEvent("SourceChanged", source2);
  };
  const handleSourcesChanged = (type) => {
    compositor2.triggerEvent("AvailableSourcesChanged", { type, sources: sourceTypeIndex[type] });
  };
  const registerSource = (declaration) => {
    asArray(declaration).forEach((x2) => {
      var _a2;
      const _ensureEditPermission = (sourceId) => {
        const source2 = sourceIndex[sourceId];
        if (!source2)
          return;
        if (source2.type === x2.type)
          return;
        throw new Error(`Attempted to modify source of type ${source2.type} from ${x2.type}`);
      };
      (_a2 = x2.init) == null ? void 0 : _a2.call(x2, { getSource: (id2) => sourceManager.getSource(id2), removeSource: (id2) => {
        _ensureEditPermission(id2);
        return sourceManager.removeSource(id2);
      }, setSourceActive: (id2, isActive) => {
        _ensureEditPermission(id2);
        return sourceManager.setSourceActive(id2, isActive);
      }, updateSource: (id2, props) => {
        _ensureEditPermission(id2);
        return sourceManager.updateSource(id2, props);
      }, modifySourceValue(id2, cb2) {
        _ensureEditPermission(id2);
        return sourceManager.modifySourceValue(id2, cb2);
      }, addSource: (source2) => sourceManager.addSource(x2.type, source2) });
      sourceTypes[x2.type] = x2;
    });
  };
  const sourceManager = { sourceIndex, sourceTypeIndex, registerSource, getSource: (id2) => {
    return sourceIndex[id2];
  }, getSources: (type) => {
    return sourceTypeIndex[type] || [];
  }, useSource: (id2, cb2) => {
    cb2(sourceIndex[id2]);
    return compositor2.on("SourceChanged", (payload) => {
      if (payload.id !== id2)
        return;
      cb2(payload);
    });
  }, useSources: (type, cb2) => {
    cb2(sourceTypeIndex[type] || []);
    return compositor2.on("AvailableSourcesChanged", (payload) => {
      if (payload.type !== type)
        return;
      cb2(payload.sources);
    });
  }, addSource: (type, source2) => {
    if (!source2.id)
      throw new Error('Cannot add source without field "id"');
    if (sourceIndex[source2.id])
      return;
    if (!source2.value)
      throw new Error('Cannot add source with an empty field "value"');
    const sourceDeclaration = sourceTypes[type];
    if (!sourceDeclaration)
      throw new Error("Could not find definition for source type: " + type);
    const { id: id2, value = null, props = {}, isActive = true } = source2;
    sourceIndex[id2] = { id: id2, type, props, value, isActive };
    sourceTypeIndex[type] = [...sourceTypeIndex[type] || [], sourceIndex[id2]];
    handleSourceChanged(sourceIndex[id2]);
    handleSourcesChanged(type);
  }, removeSource: (id2) => {
    const source2 = sourceIndex[id2];
    if (!source2)
      return;
    delete sourceIndex[id2];
    sourceTypeIndex[source2.type] = sourceTypeIndex[source2.type].filter((x2) => x2.id !== id2);
    handleSourcesChanged(source2.type);
  }, updateSource: (id2, props) => {
    const source2 = sourceIndex[id2];
    source2.props = { ...source2.props, ...props };
    handleSourceChanged(source2);
    handleSourcesChanged(source2.type);
  }, modifySourceValue: async (id2, cb2) => {
    const source2 = sourceIndex[id2];
    await cb2(source2.value);
    handleSourceChanged(source2);
  }, setSourceActive: (id2, isActive = true) => {
    const source2 = sourceIndex[id2];
    source2.isActive = isActive;
    handleSourcesChanged(source2.type);
  } };
  return sourceManager;
};
const { forEachDown, insertAt, toDataNode, pull, replaceItem } = Logic;
let compositor;
const start = (settings) => {
  if (compositor)
    return;
  const { dbAdapter, transformSettings = {}, sourceSettings = {} } = settings;
  const projectDbMap = {};
  const projectIndex = {};
  try {
    customElements.define("ls-layout", Layout);
  } catch (e2) {
    log$1.warn(e2);
  }
  const projectIdIndex = {};
  const parentIdIndex2 = {};
  const nodeIndex = {};
  let currentSubId2 = 0;
  const subscribers2 = /* @__PURE__ */ new Map();
  const subscribe2 = (cb2, nodeId) => {
    if (typeof cb2 !== "function")
      return;
    const id2 = ++currentSubId2;
    subscribers2.set(id2, cb2);
    cb2.nodeId = nodeId;
    return () => {
      subscribers2.delete(id2);
    };
  };
  const on3 = (event2, cb2, nodeId) => {
    return subscribe2((_event, payload) => {
      if (_event !== event2)
        return;
      cb2(payload);
    }, nodeId);
  };
  const triggerEvent = (event2, payload) => {
    subscribers2.forEach((handler) => {
      if (handler.nodeId) {
        if ((payload == null ? void 0 : payload.nodeId) && (payload == null ? void 0 : payload.nodeId) === handler.nodeId) {
          handler(event2, payload);
        }
      } else {
        handler(event2, payload);
      }
    });
  };
  const compositorBase = { projects: projectIndex, subscribe: subscribe2, on: on3, triggerEvent, getProject: (id2) => projectIndex[id2], getNodeProject: (id2) => projectIndex[projectIdIndex[id2]], getNodeParent: (id2) => nodeIndex[parentIdIndex2[id2]], getNode: (id2) => nodeIndex[id2], createProject: async (root2 = {}, projectId) => {
    const { id: id2, props = {}, children = [] } = root2;
    const nodeId = await dbAdapter(projectId, { get: () => null, getParent: () => null }).insert(props);
    const node = { id: nodeId, props, children };
    forEachDown(root2, (node2) => {
    });
    nodeIndex[nodeId] = node;
    return compositor.loadProject(node, projectId);
  }, loadProject: (root2, id2) => {
    if (!root2)
      return;
    id2 = id2 || root2.id;
    if (projectIndex[id2])
      return projectIndex[id2];
    forEachDown(root2, (node, parent2) => {
      nodeIndex[node.id] = node;
      parentIdIndex2[node.id] = parent2 == null ? void 0 : parent2.id;
      projectIdIndex[node.id] = id2;
    });
    const dbApi = { insert: async (node, parentId, index2 = 0) => {
      if (node.id && nodeIndex[node.id])
        return nodeIndex[node.id];
      if (!node.children) {
        node.children = [];
      }
      if (!node.props) {
        node.props = {};
      }
      if (parentId) {
        const parent2 = nodeIndex[parentId];
        if (!parent2) {
          throw "Parent node not found with ID";
        }
        parent2.children = insertAt(index2, node, parent2.children || []);
        parentIdIndex2[node.id] = parentId;
      }
      nodeIndex[node.id] = node;
      projectIdIndex[node.id] = id2;
      return node.id;
    }, update: async (id22, props = {}, childIds) => {
      const current = nodeIndex[id22];
      if (childIds) {
        const children = childIds.map((x2) => {
          const node = nodeIndex[x2];
          parentIdIndex2[node.id] = id22;
          return node;
        });
        current.children = children;
      }
      current.props = { ...current.props, ...props };
    }, remove: async (id22) => {
      const parent2 = nodeIndex[parentIdIndex2[id22]];
      if (parent2) {
        parent2.children = parent2.children.filter((x2) => x2.id !== id22);
      }
      const self2 = nodeIndex[id22];
      forEachDown(self2, (node) => {
        if (nodeIndex[node.id]) {
          nodeIndex[node.id]._deleted = true;
        }
        triggerEvent("NodeRemoved", { projectId: project.id, nodeId: node.id });
      });
    } };
    const project = { id: id2, getRoot: () => root2, get(id22) {
      return nodeIndex[id22];
    }, getParent(id22) {
      return nodeIndex[parentIdIndex2[id22]];
    }, renderTree() {
      return transformManager.renderTree(root2);
    }, local: dbApi, insert: async (props = {}, parentId, index2 = 0) => {
      const id22 = await projectDb.insert(props, parentId, index2);
      const node = { id: id22, props, children: [] };
      return dbApi.insert(node, parentId, index2);
    }, update: async (id22, props) => {
      await dbApi.update(id22, props);
      return projectDb.update(id22, props);
    }, remove: async (id22) => {
      await dbApi.remove(id22);
      const parent2 = nodeIndex[parentIdIndex2[id22]];
      const children = parent2.children.filter((x2) => x2.id !== id22);
      return projectDb.batch([["delete", { id: id22 }], ["update", { ...parent2, children }]]);
    }, reorder: async (parentId, childIds) => {
      const parent2 = nodeIndex[parentId];
      parent2.children = childIds.map((x2) => parent2.children.find((y2) => y2.id === x2));
      return projectDb.batch([["update", parent2]]);
    }, move: async (id22, newParentId, index2 = 0) => {
      const node = nodeIndex[id22];
      const prevParent = nodeIndex[parentIdIndex2[id22]];
      const newParent = nodeIndex[newParentId];
      prevParent.children = pull(prevParent.children, node);
      newParent.children = insertAt(index2, node, newParent.children);
      projectDb.batch([["update", newParent], ["update", prevParent]]);
      parentIdIndex2[id22] = newParentId;
      return;
    }, swap: async (idA, idB) => {
      const nodeA = nodeIndex[idA];
      const nodeB = nodeIndex[idB];
      const parentA = nodeIndex[parentIdIndex2[idA]];
      const parentB = nodeIndex[parentIdIndex2[idB]];
      parentA.children = replaceItem((node) => node.id === idA, nodeB, parentA.children);
      parentB.children = replaceItem((node) => node.id === idB, nodeA, parentB.children);
      parentIdIndex2[idA] = parentB.id;
      parentIdIndex2[idB] = parentA.id;
      projectDb.batch([["update", parentA], ["update", parentB]]);
      return;
    } };
    Object.defineProperty(project, "nodes", { get() {
      return Object.values(nodeIndex).filter((x2) => projectIdIndex[x2.id] === project.id);
    } });
    const projectDb = projectDbMap[id2] || dbAdapter(id2, { get: (id22) => toDataNode(project.get(id22)), getParent: (id22) => toDataNode(project.getParent(id22)) });
    projectDbMap[id2] = projectDb;
    projectIndex[id2] = project;
    return project;
  } };
  const sourceManager = init$1(sourceSettings, compositorBase);
  const transformManager = init$2(transformSettings, compositorBase, sourceManager);
  compositor = { registerLayout, registerTransform: transformManager.registerTransform, registerSource: sourceManager.registerSource, getElement: transformManager.getElement, getSource: sourceManager.getSource, getSources: sourceManager.getSources, useSource: sourceManager.useSource, useSources: sourceManager.useSources, ...compositorBase };
  return compositor;
};
const createProject = async (request3) => {
  const collectionId = getUser().id;
  const type = request3.type || "sceneless";
  const size = request3.size || { x: 1280, y: 720 };
  const settings = request3.settings || {};
  let createProjectResponse = await CoreContext.clients.LiveApi().project.createProject({ collectionId, rendering: { video: { width: size.x, height: size.y, framerate: 30 } }, composition: { studioSdk: {} }, metadata: {}, webrtc: { hosted: {} } });
  const layout = await CoreContext.clients.LayoutApi().layout.createLayout({ layout: { projectId: createProjectResponse.project.projectId, collectionId: createProjectResponse.project.collectionId } });
  const { displayName } = getAccessTokenData();
  const metadata = { type, layoutId: layout.id, hostDisplayName: displayName, props: request3.props || {} };
  let projectResponse = await CoreContext.clients.LiveApi().project.updateProject({ collectionId, projectId: createProjectResponse.project.projectId, updateMask: ["metadata"], metadata });
  createProjectResponse.project = projectResponse.project;
  createProjectResponse.project.metadata = metadata;
  if (type === "sceneless") {
    await createCompositor(layout.id, size, settings);
  } else {
    await CoreContext.compositor.createProject({ props: { name: "Root", layout: "Free", ...settings, isRoot: true, size } }, layout.id);
  }
  return createProjectResponse;
};
const deleteProject = async (request3) => {
  const { projectId } = request3;
  const project = getProject(projectId);
  const collectionId = getUser().id;
  await Promise.all([CoreContext.clients.LiveApi().project.deleteProject({ collectionId, projectId }), CoreContext.clients.LayoutApi().layout.deleteLayout({ layoutId: project.layoutApi.layoutId })]);
};
const loadUser = async (size) => {
  var _a2;
  const collections = await loadCollections();
  let collection;
  const { displayName, serviceUserId } = getAccessTokenData();
  if (collections.length === 0) {
    const response = await CoreContext.clients.LiveApi().collection.createCollection({ metadata: { serviceUserId, displayName, props: {} } });
    collection = response.collection;
  } else {
    collection = collections[0];
  }
  await CoreContext.clients.LiveApi().subscribeToCollection(collection.collectionId);
  const projects = await Promise.all(collection.projects.map((project) => hydrateProject(project, "ROLE_HOST", size)));
  return { user: { id: collection.collectionId, metadata: collection.metadata, props: ((_a2 = collection.metadata) == null ? void 0 : _a2.props) || {}, name: displayName }, projects, sources: collection.sources };
};
const loadCollections = async () => {
  let result = await CoreContext.clients.LiveApi().collection.getCollections({});
  return result.collections;
};
var requests = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, createProject, deleteProject, loadUser, loadCollections }, Symbol.toStringTag, { value: "Module" }));
const BroadcastPhase = lib$2.LiveApiModel.ProjectBroadcastPhase;
const { trigger, triggerInternal } = CoreContext;
const EventType = lib$2.LiveApiModel.EventType;
const EventSubType = lib$2.LiveApiModel.EventSubType;
const init = async (settings = {}) => {
  const env = settings.env || "prod";
  const logLevel = settings.logLevel || "Warn";
  const livekitLogger = log$1.getLogger("livekit");
  livekitLogger.setLevel(logLevel);
  log$1.setLevel(logLevel);
  log$1.info("Initializing Studio SDK...");
  const { layouts: layouts2 = [], transforms: transforms2 = [], sources: sources2 = [], defaultTransforms = {}, guestToken } = settings;
  const client = new lib$2.ApiStream({ sdkVersion: CoreContext.version, env, logLevel });
  const conf = config$1();
  const compositor2 = start({ dbAdapter: compositorAdapter, transformSettings: { defaultTransforms: { ...defaultTransforms, ...conf.defaults.transforms } } });
  CoreContext.config = conf;
  CoreContext.clients = client;
  CoreContext.compositor = compositor2;
  CoreContext.logLevel = logLevel;
  CoreContext.Request = await Promise.resolve().then(function() {
    return requests;
  });
  CoreContext.Command = await Promise.resolve().then(function() {
    return commands$1;
  });
  window.__StudioKit = { ...CoreContext };
  compositor2.registerSource([...Object.values(Sources), ...sources2]);
  compositor2.registerTransform([...Object.values(Transforms), ...transforms2]);
  compositor2.registerLayout([...Object.values(Layouts), ...layouts2]);
  const guestProject = await client.load(guestToken);
  let initialProject;
  if (guestProject) {
    await client.LiveApi().project.getProject({ ...guestProject }).then((resp) => hydrateProject(resp.project, guestProject.role)).then(async (project) => {
      setAppState({ user: { id: guestProject.collectionId, props: {}, name: null, metadata: {} }, sources: [], projects: [project], activeProjectId: null });
      project.isInitial = true;
      initialProject = await CoreContext.Command.setActiveProject({ projectId: project.id });
    });
  }
  client.LiveApi().on(EventType.EVENT_TYPE_COLLECTION, (event2, type) => {
    log$1.info("Received: Collection event", type, event2);
    switch (type) {
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        triggerInternal("UserChanged", event2.update.collection);
        return;
      }
    }
  });
  client.LiveApi().on(EventType.EVENT_TYPE_DESTINATION, (event2, type) => {
    log$1.info("Received: Destination event", type, event2);
    switch (type) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        const { destination } = event2.create;
        triggerInternal("DestinationAdded", destination);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        const { destination } = event2.update;
        triggerInternal("DestinationChanged", destination);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("DestinationRemoved", event2.delete);
        return;
      }
    }
  });
  client.LiveApi().on(EventType.EVENT_TYPE_SOURCE, (event2, type) => {
    log$1.info("Received: Source event", type, event2);
    switch (type) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        triggerInternal("SourceAdded", event2.create.source);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        triggerInternal("SourceChanged", event2.update.source);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("SourceRemoved", event2.delete.sourceId);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_ADD: {
        triggerInternal("ProjectSourceAdded", { projectId: event2.add.projectId, source: event2.add.source });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_REMOVE: {
        triggerInternal("ProjectSourceRemoved", { projectId: event2.add.projectId, sourceId: event2.add.sourceId });
        return;
      }
    }
  });
  client.LiveApi().on(EventType.EVENT_TYPE_PROJECT, (event2, type) => {
    var _a2;
    log$1.info("Received: Project event", type, event2);
    switch (type) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        const project = event2.create.project;
        if (getProject(project.projectId))
          return;
        triggerInternal("ProjectAdded", project);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        const { projectId, updateMask, project } = event2.update;
        const existingProject = getProject(project.projectId);
        if (!existingProject)
          return;
        if (updateMask.includes("metadata")) {
          trigger("ProjectMetaUpdated", { projectId, meta: project.metadata });
        }
        triggerInternal("ProjectChanged", { project, phase: existingProject.videoApi.phase });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("ProjectRemoved", { projectId: event2.delete.projectId });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_STATE: {
        const project = getProject((_a2 = event2.state) == null ? void 0 : _a2.projectId);
        if (!project)
          return;
        let broadcastId = event2.state.broadcastId;
        if (event2.state.error) {
          trigger("BroadcastError", { projectId: project.id, broadcastId: event2.state.broadcastId, error: event2.state.error });
        }
        if (event2.state.phase) {
          const phase = event2.state.phase;
          if (phase === BroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING) {
            trigger("BroadcastStarted", { projectId: project.id, broadcastId: event2.state.broadcastId });
          } else if (phase === BroadcastPhase.PROJECT_BROADCAST_PHASE_STOPPED) {
            broadcastId = null;
            trigger("BroadcastStopped", { projectId: project.id, broadcastId: event2.state.broadcastId });
          }
        }
        triggerInternal("ProjectChanged", { project: project.videoApi.project, phase: event2.state.phase, broadcastId });
        return;
      }
    }
  });
  client.LayoutApi().on(lib$2.LayoutApiModel.EventType.EVENT_TYPE_LAYER, (layer, type) => {
    if (type === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_CREATE) {
      log$1.debug("Received: Node Insert", layer.create);
      const { connectionId: connectionId2, layoutId } = layer.create.requestMetadata;
      if (CoreContext.connectionId === connectionId2)
        return;
      const node = layerToNode(layer.create);
      const project = getProjectByLayoutId(layoutId);
      const nodes = [node, ...project.compositor.nodes.map(toDataNode$1)];
      const tree = toSceneTree(nodes, node.id);
      project.compositor.local.insert(tree);
      triggerInternal("NodeAdded", { projectId: project.id, nodeId: node.id });
    } else if (type === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_UPDATE) {
      log$1.debug("Received: Node Update", layer.update);
      const { connectionId: connectionId2, layoutId, updateVersions = {} } = layer.update.requestMetadata;
      if (CoreContext.connectionId === connectionId2)
        return;
      const node = layerToNode(layer.update);
      const latestUpdateId = latestUpdateVersion[node.id] || 0;
      if (latestUpdateId > updateVersions[node.id]) {
        return log$1.info("Ignoring node update - updateID is less than latest.");
      }
      latestUpdateVersion[node.id] = updateVersions[node.id];
      const project = getProjectByLayoutId(layoutId);
      project.compositor.local.update(layer.update.id, node.props, node.childIds);
      triggerInternal("NodeChanged", { projectId: project.id, nodeId: node.id });
    } else if (type === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_DELETE) {
      log$1.debug("Received: Node Delete", layer.delete);
      const { connectionId: connectionId2, layoutId } = layer.delete.requestMetadata;
      if (CoreContext.connectionId === connectionId2)
        return;
      const project = getProjectByLayoutId(layoutId);
      project.compositor.local.remove(layer.delete.id);
      triggerInternal("NodeRemoved", { projectId: project.id, nodeId: layer.delete.id });
    } else if (type === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_BATCH) {
      log$1.debug("Received: Node Batch Update", layer.batch);
      const { connectionId: connectionId2, layoutId, updateVersions = {} } = layer.batch.requestMetadata;
      if (CoreContext.connectionId === connectionId2)
        return;
      const project = getProjectByLayoutId(layoutId);
      layer.batch.layers.forEach((batch) => {
        try {
          const [type2, args] = Object.entries(batch)[0];
          if (type2 === "create") {
            const node = layerToNode(args);
            project.compositor.local.insert(node);
            triggerInternal("NodeAdded", { projectId: project.id, nodeId: node.id });
          } else if (type2 === "update") {
            const node = layerToNode(args);
            const latestUpdateId = latestUpdateVersion[node.id] || 0;
            if (latestUpdateId > updateVersions[node.id]) {
              return log$1.info("Ignoring node update - updateID is less than latest.");
            }
            latestUpdateVersion[node.id] = updateVersions[node.id];
            project.compositor.local.update(node.id, node.props, node.childIds);
            triggerInternal("NodeChanged", { projectId: project.id, nodeId: node.id });
          } else if (type2 === "delete") {
            project.compositor.local.remove(args.id);
            triggerInternal("NodeRemoved", { projectId: project.id, nodeId: args.id });
          }
        } catch (e2) {
          log$1.warn("Error handling batch item", e2, { item: batch });
        }
      });
      if (project)
        triggerInternal("NodeChanged", { projectId: project.id, nodeId: project.compositor.getRoot().id });
    }
  });
  const createGuestToken = (options2 = {}, url2) => {
    const { displayName, role, maxDuration = CoreContext.config.defaults.guestTokenDuration, projectId = CoreContext.state.activeProjectId } = options2;
    const project = getProject(projectId);
    const token = displayName ? { direct: { displayName } } : { exchange: { maxDuration } };
    return client.LiveApi().authentication.createGuestAccessToken({ projectId, token, url: url2, collectionId: project.videoApi.project.collectionId, maxDuration, role: role || lib$2.LiveApiModel.Role.ROLE_GUEST });
  };
  return { ...omit$1(CoreContext, ["clients", "config", "connectionId", "Request", "state", "trigger"]), createDemoToken: async () => {
    console.warn("createDemoToken() is currently unavailable.");
    return "";
  }, createPreviewLink: async (request3 = {}) => {
    const { maxDuration, projectId = CoreContext.state.activeProjectId } = request3;
    const project = getProject(projectId);
    const url2 = project.videoApi.project.composition.studioSdk.rendererUrl;
    let response = await client.LiveApi().authentication.createGuestAccessToken({ projectId, token: { direct: { displayName: "Preview" } }, url: url2, collectionId: project.videoApi.project.collectionId, maxDuration: maxDuration || CoreContext.config.defaults.previewTokenDuration, role: lib$2.LiveApiModel.Role.ROLE_VIEWER });
    return response.url;
  }, createGuestLink: async (baseUrl, options2 = {}) => {
    const response = await createGuestToken(options2, baseUrl);
    return response.url;
  }, createGuestToken: async (options2 = {}) => {
    const response = await createGuestToken(options2);
    return response.accessToken;
  }, initialProject, load, render };
};
const load = async (accessToken, size) => {
  let user = getBaseUser();
  if (user) {
    log$1.info("Attempted to load user again - returning existing user");
    return user;
  }
  if (!accessToken) {
    log$1.warn("Access token required for load()");
    return;
  }
  log$1.info("Loading user...");
  const client = CoreContext.clients;
  await client.load(accessToken);
  const result = await CoreContext.Request.loadUser(size);
  setAppState({ user: result.user, sources: result.sources, projects: result.projects, activeProjectId: null });
  user = getBaseUser();
  trigger("UserLoaded", user);
  return user;
};
const AppContext = React.createContext({
  isHost: false
});
const AppProvider = ({
  isHost,
  children
}) => {
  return /* @__PURE__ */ jsx(AppContext.Provider, {
    value: {
      isHost
    },
    children
  });
};
const column = "_column_xzlw3_5";
const row = "_row_xzlw3_11";
var Style$1 = {
  column,
  row
};
const {
  Room
} = index$1;
const {
  useStudio: useStudio$1
} = index$1.React;
const Participants = () => {
  const {
    room,
    projectCommands,
    studio
  } = useStudio$1();
  const {
    isHost
  } = react$1.exports.useContext(AppContext);
  const [participants, setParticipants] = react$1.exports.useState([]);
  react$1.exports.useEffect(() => {
    if (!room)
      return;
    return room.useParticipants((participants2) => {
      setParticipants(participants2);
      if (isHost)
        projectCommands.pruneParticipants();
    });
  }, [room]);
  return /* @__PURE__ */ jsx("div", {
    className: Style$1.column,
    children: participants.map((x2) => /* @__PURE__ */ jsx("div", {
      style: {
        marginBottom: 10
      },
      children: /* @__PURE__ */ jsx(Participant, {
        participant: x2
      })
    }, x2.id))
  });
};
const ParticipantCamera = ({
  participant,
  webcam,
  microphone
}) => {
  const {
    isHost
  } = react$1.exports.useContext(AppContext);
  const {
    id: id2,
    displayName
  } = participant;
  const ref2 = react$1.exports.useRef();
  const [srcObject] = react$1.exports.useState(new MediaStream([]));
  const isEnabled = (webcam == null ? void 0 : webcam.mediaStreamTrack) && !(webcam == null ? void 0 : webcam.isMuted);
  react$1.exports.useEffect(() => {
    Room.updateMediaStreamTracks(srcObject, {
      video: webcam == null ? void 0 : webcam.mediaStreamTrack,
      audio: microphone == null ? void 0 : microphone.mediaStreamTrack
    });
  }, [webcam == null ? void 0 : webcam.mediaStreamTrack, microphone == null ? void 0 : microphone.mediaStreamTrack]);
  react$1.exports.useEffect(() => {
    if (ref2.current) {
      ref2.current.srcObject = srcObject;
    }
  }, [ref2 == null ? void 0 : ref2.current, srcObject, isEnabled]);
  return /* @__PURE__ */ jsxs("div", {
    className: Style$1.column,
    style: {
      padding: 6,
      borderRadius: 3,
      background: "#000000cc",
      border: "1px solid rgba(255, 255, 255, 0.2)"
    },
    children: [/* @__PURE__ */ jsx("div", {
      children: displayName
    }), /* @__PURE__ */ jsxs("div", {
      style: {
        height: 160,
        width: 160 * 16 / 9,
        position: "relative"
      },
      children: [/* @__PURE__ */ jsx("div", {
        style: {
          background: "#222",
          height: "100%",
          width: "100%",
          position: "absolute",
          zIndex: -1
        }
      }), isEnabled && /* @__PURE__ */ jsx("video", {
        muted: true,
        autoPlay: true,
        ref: ref2,
        style: {
          background: "transparent",
          objectFit: "cover",
          height: "100%",
          width: "100%"
        }
      })]
    }), isHost && /* @__PURE__ */ jsx(HostControls, {
      participant,
      type: "camera"
    })]
  });
};
const ParticipantScreenshare = ({
  participant,
  screenshare
}) => {
  const {
    isHost
  } = react$1.exports.useContext(AppContext);
  useStudio$1();
  const {
    id: id2,
    displayName
  } = participant;
  const ref2 = react$1.exports.useRef();
  const [srcObject] = react$1.exports.useState(new MediaStream([]));
  react$1.exports.useEffect(() => {
    Room.updateMediaStreamTracks(srcObject, {
      video: screenshare == null ? void 0 : screenshare.mediaStreamTrack
    });
  }, [screenshare == null ? void 0 : screenshare.mediaStreamTrack]);
  react$1.exports.useEffect(() => {
    if (ref2.current) {
      ref2.current.srcObject = srcObject;
    }
  }, [ref2 == null ? void 0 : ref2.current, srcObject]);
  return /* @__PURE__ */ jsxs("div", {
    className: Style$1.column,
    style: {
      padding: 6,
      borderRadius: 3,
      background: "#000000cc",
      border: "1px solid rgba(255, 255, 255, 0.2)"
    },
    children: [/* @__PURE__ */ jsxs("div", {
      children: [displayName, " (Screen)"]
    }), /* @__PURE__ */ jsx("div", {
      style: {
        height: 160,
        width: 160 * 16 / 9,
        position: "relative"
      },
      children: /* @__PURE__ */ jsx("video", {
        muted: true,
        autoPlay: true,
        ref: ref2,
        style: {
          background: "transparent",
          objectFit: "cover",
          height: "100%",
          width: "100%"
        }
      })
    }), isHost && /* @__PURE__ */ jsx(HostControls, {
      participant,
      type: "screen"
    })]
  });
};
const Participant = ({
  participant
}) => {
  const {
    room
  } = useStudio$1();
  const [tracks, setTracks] = react$1.exports.useState([]);
  const screenshare = tracks.find((x2) => x2.type === "screen_share");
  const webcam = tracks.find((x2) => x2.type === "camera");
  const microphone = tracks.find((x2) => x2.type === "microphone");
  react$1.exports.useEffect(() => {
    if (!room)
      return;
    setTracks(participant.trackIds.map(room.getTrack).filter(Boolean));
  }, [participant == null ? void 0 : participant.trackIds, room]);
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx(ParticipantCamera, {
      participant,
      webcam,
      microphone
    }), screenshare && /* @__PURE__ */ jsx("div", {
      style: {
        marginTop: 10
      },
      children: /* @__PURE__ */ jsx(ParticipantScreenshare, {
        participant,
        screenshare
      })
    })]
  });
};
const HostControls = ({
  participant,
  type
}) => {
  var _a2, _b;
  const {
    id: id2
  } = participant;
  const {
    projectCommands,
    studio
  } = useStudio$1();
  const projectParticipant = react$1.exports.useMemo(() => projectCommands.getParticipantState(id2, type), []);
  const [onStream, setOnStream] = react$1.exports.useState(Boolean(projectParticipant));
  const [isMuted, setIsMuted] = react$1.exports.useState((_a2 = projectParticipant == null ? void 0 : projectParticipant.isMuted) != null ? _a2 : false);
  const [volume, setVolume] = react$1.exports.useState((_b = projectParticipant == null ? void 0 : projectParticipant.volume) != null ? _b : 1);
  const [isShowcase, setIsShowcase] = react$1.exports.useState(false);
  react$1.exports.useEffect(() => {
    return projectCommands.useParticipantState(id2, (x2) => {
      setOnStream(Boolean(x2));
    }, type);
  }, []);
  react$1.exports.useEffect(() => projectCommands.useShowcase((showcase) => {
    setIsShowcase(showcase.participantId === id2 && showcase.type === type);
  }), []);
  return /* @__PURE__ */ jsxs("div", {
    style: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      width: "100%",
      marginTop: 4
    },
    children: [/* @__PURE__ */ jsxs("div", {
      style: {
        display: "flex",
        flexDirection: "column"
      },
      children: [/* @__PURE__ */ jsxs("label", {
        children: [/* @__PURE__ */ jsx("input", {
          type: "checkbox",
          checked: onStream,
          style: {
            marginTop: 0,
            marginBottom: 0
          },
          onChange: (e2) => {
            const checked = e2.target.checked;
            if (checked) {
              projectCommands.addParticipant(id2, {
                isMuted,
                volume
              }, type);
            } else {
              projectCommands.removeParticipant(id2, type);
            }
            setOnStream(checked);
          }
        }), "On stream"]
      }), /* @__PURE__ */ jsxs("label", {
        style: {
          opacity: onStream ? 1 : 0.5
        },
        children: [/* @__PURE__ */ jsx("input", {
          type: "checkbox",
          style: {
            marginTop: 0,
            marginBottom: 0
          },
          disabled: !onStream,
          checked: isShowcase,
          onChange: () => {
            if (isShowcase) {
              projectCommands.setShowcase(null);
            } else {
              projectCommands.setShowcase(id2, type);
            }
          }
        }), "Showcase"]
      })]
    }), /* @__PURE__ */ jsx("span", {
      children: type === "camera" && /* @__PURE__ */ jsxs(Fragment, {
        children: [/* @__PURE__ */ jsx("input", {
          type: "range",
          min: 0,
          max: 1,
          step: 0.01,
          value: volume,
          style: {
            opacity: isMuted ? 0.4 : 1
          },
          onChange: (e2) => {
            const value = Number(e2.target.value);
            projectCommands.setParticipantVolume(id2, value);
            setVolume(value);
            if (isMuted) {
              projectCommands.setParticipantMuted(id2, false);
              setIsMuted(false);
            }
          }
        }), /* @__PURE__ */ jsx("input", {
          type: "checkbox",
          checked: !isMuted,
          onChange: (e2) => {
            const checked = e2.target.checked;
            projectCommands.setParticipantMuted(id2, !checked);
            setIsMuted(!checked);
          }
        })]
      })
    })]
  });
};
const {
  useStudio,
  useDevices
} = index$1.React;
const DeviceSelection = () => {
  const {
    webcamId,
    microphoneId,
    setWebcamId,
    setMicrophoneId
  } = useStudio();
  const devices = useDevices();
  react$1.exports.useEffect(() => {
    var _a2;
    if (!webcamId)
      setWebcamId((_a2 = devices.webcams[0]) == null ? void 0 : _a2.deviceId);
  }, [webcamId, devices]);
  react$1.exports.useEffect(() => {
    var _a2;
    if (!microphoneId)
      setMicrophoneId((_a2 = devices.microphones[0]) == null ? void 0 : _a2.deviceId);
  }, [microphoneId, devices]);
  return /* @__PURE__ */ jsxs("div", {
    children: [/* @__PURE__ */ jsxs("div", {
      className: Style$1.column,
      children: [/* @__PURE__ */ jsx("label", {
        children: "Webcam"
      }), /* @__PURE__ */ jsx("select", {
        value: webcamId,
        onChange: (e2) => {
          setWebcamId(e2.target.value);
        },
        children: devices.webcams.map((x2) => /* @__PURE__ */ jsx("option", {
          value: x2.deviceId,
          children: x2.label
        }, x2.deviceId))
      })]
    }), /* @__PURE__ */ jsxs("div", {
      className: Style$1.column,
      children: [/* @__PURE__ */ jsx("label", {
        children: "Microphone"
      }), /* @__PURE__ */ jsx("select", {
        value: microphoneId,
        onChange: (e2) => {
          setMicrophoneId(e2.target.value);
        },
        children: devices.microphones.map((x2) => /* @__PURE__ */ jsx("option", {
          value: x2.deviceId,
          children: x2.label
        }, x2.deviceId))
      })]
    })]
  });
};
const ControlPanel = () => {
  const {
    room,
    projectCommands
  } = useStudio();
  const [isSharingScreen, setIsSharingScreen] = react$1.exports.useState(false);
  const [participant, setParticipant] = react$1.exports.useState();
  react$1.exports.useEffect(() => {
    if (!room)
      return;
    return room.useParticipant(room.participantId, setParticipant);
  }, [room]);
  react$1.exports.useEffect(() => {
    if (!participant)
      return;
    const screenshare = participant.trackIds.find((x2) => {
      var _a2;
      return ((_a2 = room.getTrack(x2)) == null ? void 0 : _a2.type) === "screen_share";
    });
    if (!screenshare) {
      projectCommands.removeParticipant(room.participantId, "screen");
    }
    setIsSharingScreen(Boolean(screenshare));
  }, [participant == null ? void 0 : participant.trackIds]);
  return /* @__PURE__ */ jsxs("div", {
    children: [/* @__PURE__ */ jsxs("label", {
      children: [/* @__PURE__ */ jsx("input", {
        type: "checkbox",
        onChange: (e2) => {
          const muted = e2.target.checked;
          room.setMicrophoneEnabled(!muted);
        }
      }), "Mute microphone"]
    }), /* @__PURE__ */ jsxs("label", {
      children: [/* @__PURE__ */ jsx("input", {
        type: "checkbox",
        onChange: (e2) => {
          const hidden = e2.target.checked;
          room.setCameraEnabled(!hidden);
        }
      }), "Hide webcam"]
    }), /* @__PURE__ */ jsxs("label", {
      children: [/* @__PURE__ */ jsx("input", {
        type: "checkbox",
        checked: isSharingScreen,
        onChange: (e2) => {
          const enabled = e2.target.checked;
          if (enabled) {
            room.addScreen();
          } else {
            room.getParticipant(room.participantId).trackIds.forEach((x2) => {
              if (room.getTrack(x2).type === "screen_share") {
                room.removeTrack(x2);
              }
            });
          }
        }
      }), "Screenshare"]
    })]
  });
};
const chatUsernameCell = "_chatUsernameCell_ooyxe_5";
const chatTimeCell = "_chatTimeCell_ooyxe_10";
const chatItem = "_chatItem_ooyxe_16";
const chatTop = "_chatTop_ooyxe_20";
const scrollbox = "_scrollbox_ooyxe_25";
const textarea = "_textarea_ooyxe_35";
const chatbox = "_chatbox_ooyxe_45";
const emptyMessage = "_emptyMessage_ooyxe_54";
var Style = {
  chatUsernameCell,
  chatTimeCell,
  chatItem,
  chatTop,
  scrollbox,
  textarea,
  chatbox,
  emptyMessage
};
const {
  StudioContext
} = index$1.React;
const displayTimeComponent = (component) => component < 10 ? `0${component}` : String(component);
const displayTime = (time) => `${time.getHours()}:${displayTimeComponent(time.getMinutes())}:${displayTimeComponent(time.getSeconds())}`;
const ChatMessage = ({
  message
}) => {
  const sent = new Date(message.timestamp);
  return /* @__PURE__ */ jsxs("div", {
    className: Style.chatItem,
    children: [/* @__PURE__ */ jsxs("div", {
      className: Style.chatTop,
      children: [/* @__PURE__ */ jsx("span", {
        className: Style.chatUsernameCell,
        children: message.displayName
      }), /* @__PURE__ */ jsx("span", {
        className: Style.chatTimeCell,
        children: displayTime(sent)
      })]
    }), /* @__PURE__ */ jsx("div", {
      className: Style.chatMessageContent,
      children: message.content
    })]
  });
};
const Chat = () => {
  const {
    room
  } = react$1.exports.useContext(StudioContext);
  const [chatHistory, setChatHistory] = react$1.exports.useState([]);
  const [draft, setDraft] = react$1.exports.useState("");
  const scrollbox2 = react$1.exports.useRef(null);
  const onSendMessage = () => {
    if (!draft.trim()) {
      return;
    }
    room.sendChatMessage({
      message: draft.trim()
    });
    setDraft("");
  };
  react$1.exports.useEffect(() => {
    if (!room)
      return;
    return room.useChatHistory((history) => {
      const scrollY = scrollbox2.current.scrollHeight - scrollbox2.current.clientHeight;
      setChatHistory(history);
      if (scrollbox2.current.scrollTop === scrollY) {
        scrollbox2.current.scrollTo({
          top: scrollbox2.current.scrollHeight - scrollbox2.current.clientHeight
        });
      }
    });
  }, [room]);
  return /* @__PURE__ */ jsxs("div", {
    className: Style.chatbox,
    children: [/* @__PURE__ */ jsxs("div", {
      ref: scrollbox2,
      className: Style.scrollbox,
      children: [chatHistory.length === 0 && /* @__PURE__ */ jsx("div", {
        className: Style.emptyMessage,
        children: "Private chat between host and guests."
      }), chatHistory.map((chat, i2) => {
        return /* @__PURE__ */ jsx(ChatMessage, {
          message: chat
        }, i2);
      })]
    }), /* @__PURE__ */ jsx("textarea", {
      placeholder: "Write a message...",
      className: Style.textarea,
      value: draft,
      onChange: (e2) => {
        setDraft(e2.target.value);
      }
    }), /* @__PURE__ */ jsx("button", {
      onClick: onSendMessage,
      children: "Send Message"
    })]
  });
};
const LOCAL_ENV = "stage";
var config = {
  env: location.hostname === "live.api.stream" ? "prod" : LOCAL_ENV,
  logLevel: "Debug",
  recaptchaKey: "6Lc0HIUfAAAAAIdsyq7vB_3c3skiVvltzdUTCUSx"
};
var url = "/studiokit/example/assets/logo.eb248bd6.png";
var index = "";
export { AppProvider as A, ControlPanel as C, DeviceSelection as D, Participants as P, React as R, Style$1 as S, init as a, jsxs as b, config as c, Chat as d, ReactDOM as e, Participant as f, index$1 as i, jsx as j, react$1 as r, url as u };
//# sourceMappingURL=index.aeb7c968.js.map
