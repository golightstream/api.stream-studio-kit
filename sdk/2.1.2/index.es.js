import ReactDOM from "react-dom";
import React, { useRef, useState, useEffect, useLayoutEffect, useContext, useMemo } from "react";
let currentSubId = 0;
const subscribers = /* @__PURE__ */ new Map();
const subscribersInternal = /* @__PURE__ */ new Map();
function createSubscribe(options = {}) {
  return function(cb) {
    if (typeof cb !== "function")
      return;
    const watchers = options.internal ? subscribersInternal : subscribers;
    const id = ++currentSubId;
    watchers.set(id, cb);
    return () => {
      watchers.delete(id);
    };
  };
}
function createOn(options = {}) {
  return function(name2, cb) {
    const _subscribe = options.internal ? subscribeInternal : subscribe;
    return _subscribe((e2, payload) => {
      if (name2 === e2)
        return cb(payload);
    });
  };
}
function createTrigger(options = {}) {
  const watchers = options.internal ? subscribersInternal : subscribers;
  return async function(name2, ...args) {
    let action = {
      type: name2,
      payload: args[0]
    };
    const eventType = Boolean(options.internal) ? "Internal" : "External";
    log$1.info(`${eventType} Event:`, action);
    await Promise.all(Array.from(watchers.values()).map((x) => x(action.type, action.payload)));
  };
}
const trigger$1 = createTrigger();
const subscribe = createSubscribe();
const on = createOn();
const triggerInternal$1 = createTrigger({
  internal: true
});
const subscribeInternal = createSubscribe({
  internal: true
});
const onInternal = createOn({
  internal: true
});
var events$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  trigger: trigger$1,
  subscribe,
  on,
  triggerInternal: triggerInternal$1,
  subscribeInternal,
  onInternal
}, Symbol.toStringTag, { value: "Module" }));
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a;
}
var loglevel$1 = { exports: {} };
(function(module2) {
  (function(root2, definition) {
    if (module2.exports) {
      module2.exports = definition();
    } else {
      root2.log = definition();
    }
  })(commonjsGlobal$1, function() {
    var noop2 = function() {
    };
    var undefinedType = "undefined";
    var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
    var logMethods = [
      "trace",
      "debug",
      "info",
      "warn",
      "error"
    ];
    function bindMethod(obj, methodName) {
      var method = obj[methodName];
      if (typeof method.bind === "function") {
        return method.bind(obj);
      } else {
        try {
          return Function.prototype.bind.call(method, obj);
        } catch (e2) {
          return function() {
            return Function.prototype.apply.apply(method, [obj, arguments]);
          };
        }
      }
    }
    function traceForIE() {
      if (console.log) {
        if (console.log.apply) {
          console.log.apply(console, arguments);
        } else {
          Function.prototype.apply.apply(console.log, [console, arguments]);
        }
      }
      if (console.trace)
        console.trace();
    }
    function realMethod(methodName) {
      if (methodName === "debug") {
        methodName = "log";
      }
      if (typeof console === undefinedType) {
        return false;
      } else if (methodName === "trace" && isIE) {
        return traceForIE;
      } else if (console[methodName] !== void 0) {
        return bindMethod(console, methodName);
      } else if (console.log !== void 0) {
        return bindMethod(console, "log");
      } else {
        return noop2;
      }
    }
    function replaceLoggingMethods(level, loggerName) {
      for (var i2 = 0; i2 < logMethods.length; i2++) {
        var methodName = logMethods[i2];
        this[methodName] = i2 < level ? noop2 : this.methodFactory(methodName, level, loggerName);
      }
      this.log = this.debug;
    }
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
      return function() {
        if (typeof console !== undefinedType) {
          replaceLoggingMethods.call(this, level, loggerName);
          this[methodName].apply(this, arguments);
        }
      };
    }
    function defaultMethodFactory(methodName, level, loggerName) {
      return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
    }
    function Logger(name2, defaultLevel, factory2) {
      var self2 = this;
      var currentLevel;
      defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;
      var storageKey = "loglevel";
      if (typeof name2 === "string") {
        storageKey += ":" + name2;
      } else if (typeof name2 === "symbol") {
        storageKey = void 0;
      }
      function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || "silent").toUpperCase();
        if (typeof window === undefinedType || !storageKey)
          return;
        try {
          window.localStorage[storageKey] = levelName;
          return;
        } catch (ignore) {
        }
        try {
          window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
        } catch (ignore) {
        }
      }
      function getPersistedLevel() {
        var storedLevel;
        if (typeof window === undefinedType || !storageKey)
          return;
        try {
          storedLevel = window.localStorage[storageKey];
        } catch (ignore) {
        }
        if (typeof storedLevel === undefinedType) {
          try {
            var cookie = window.document.cookie;
            var location = cookie.indexOf(encodeURIComponent(storageKey) + "=");
            if (location !== -1) {
              storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
            }
          } catch (ignore) {
          }
        }
        if (self2.levels[storedLevel] === void 0) {
          storedLevel = void 0;
        }
        return storedLevel;
      }
      function clearPersistedLevel() {
        if (typeof window === undefinedType || !storageKey)
          return;
        try {
          window.localStorage.removeItem(storageKey);
          return;
        } catch (ignore) {
        }
        try {
          window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
        } catch (ignore) {
        }
      }
      self2.name = name2;
      self2.levels = {
        "TRACE": 0,
        "DEBUG": 1,
        "INFO": 2,
        "WARN": 3,
        "ERROR": 4,
        "SILENT": 5
      };
      self2.methodFactory = factory2 || defaultMethodFactory;
      self2.getLevel = function() {
        return currentLevel;
      };
      self2.setLevel = function(level, persist) {
        if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
          level = self2.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
          currentLevel = level;
          if (persist !== false) {
            persistLevelIfPossible(level);
          }
          replaceLoggingMethods.call(self2, level, name2);
          if (typeof console === undefinedType && level < self2.levels.SILENT) {
            return "No console available for logging";
          }
        } else {
          throw "log.setLevel() called with invalid level: " + level;
        }
      };
      self2.setDefaultLevel = function(level) {
        defaultLevel = level;
        if (!getPersistedLevel()) {
          self2.setLevel(level, false);
        }
      };
      self2.resetLevel = function() {
        self2.setLevel(defaultLevel, false);
        clearPersistedLevel();
      };
      self2.enableAll = function(persist) {
        self2.setLevel(self2.levels.TRACE, persist);
      };
      self2.disableAll = function(persist) {
        self2.setLevel(self2.levels.SILENT, persist);
      };
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
        initialLevel = defaultLevel;
      }
      self2.setLevel(initialLevel, false);
    }
    var defaultLogger = new Logger();
    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name2) {
      if (typeof name2 !== "symbol" && typeof name2 !== "string" || name2 === "") {
        throw new TypeError("You must supply a name when creating a logger.");
      }
      var logger2 = _loggersByName[name2];
      if (!logger2) {
        logger2 = _loggersByName[name2] = new Logger(name2, defaultLogger.getLevel(), defaultLogger.methodFactory);
      }
      return logger2;
    };
    var _log = typeof window !== undefinedType ? window.log : void 0;
    defaultLogger.noConflict = function() {
      if (typeof window !== undefinedType && window.log === defaultLogger) {
        window.log = _log;
      }
      return defaultLogger;
    };
    defaultLogger.getLoggers = function getLoggers() {
      return _loggersByName;
    };
    defaultLogger["default"] = defaultLogger;
    return defaultLogger;
  });
})(loglevel$1);
var log$1 = loglevel$1.exports;
const connectionId$1 = (Math.random() * 1e20).toString(36);
const version$5 = "2.1.2";
const CoreContext = {
  config: null,
  clients: null,
  Request: {},
  Command: {},
  on,
  subscribe,
  onInternal,
  subscribeInternal,
  trigger: trigger$1,
  triggerInternal: triggerInternal$1,
  state: {},
  compositor: {},
  connectionId: connectionId$1,
  version: version$5,
  rendererVersion: version$5,
  log: log$1,
  logLevel: null
};
const setAppState = (state2) => {
  Object.keys(state2).forEach((name2) => {
    CoreContext.state[name2] = state2[name2];
  });
};
var context = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoreContext,
  log: log$1,
  setAppState,
  "default": CoreContext
}, Symbol.toStringTag, { value: "Module" }));
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
var root$1 = root;
var Symbol$1 = root$1.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$f = Object.prototype;
var hasOwnProperty$d = objectProto$f.hasOwnProperty;
var nativeObjectToString$1 = objectProto$f.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$d.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$e = Object.prototype;
var nativeObjectToString = objectProto$e.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var symbolTag$3 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
}
function arrayMap(array, iteratee2) {
  var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
  while (++index2 < length2) {
    result[index2] = iteratee2(array[index2], index2, array);
  }
  return result;
}
var isArray$3 = Array.isArray;
var isArray$4 = isArray$3;
var INFINITY$1 = 1 / 0;
var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$4(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
function isObject$5(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$5(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$5(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
function identity$1(value) {
  return value;
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$5(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$d = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$c = objectProto$d.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$c).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject$5(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$3(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var WeakMap$2 = getNative(root$1, "WeakMap");
var WeakMap$3 = WeakMap$2;
var objectCreate$1 = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$5(proto)) {
      return {};
    }
    if (objectCreate$1) {
      return objectCreate$1(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate$1 = baseCreate;
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function copyArray(source2, array) {
  var index2 = -1, length2 = source2.length;
  array || (array = Array(length2));
  while (++index2 < length2) {
    array[index2] = source2[index2];
  }
  return array;
}
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
function constant(value) {
  return function() {
    return value;
  };
}
var defineProperty$1 = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var defineProperty$2 = defineProperty$1;
var baseSetToString = !defineProperty$2 ? identity$1 : function(func, string) {
  return defineProperty$2(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var baseSetToString$1 = baseSetToString;
var setToString = shortOut(baseSetToString$1);
var setToString$1 = setToString;
function arrayEach(array, iteratee2) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (iteratee2(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length2 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
function baseIsNaN(value) {
  return value !== value;
}
function strictIndexOf(array, value, fromIndex) {
  var index2 = fromIndex - 1, length2 = array.length;
  while (++index2 < length2) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return -1;
}
function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length2) {
  var type = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty$2) {
    defineProperty$2(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var objectProto$c = Object.prototype;
var hasOwnProperty$b = objectProto$c.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$b.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function copyObject(source2, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length2 = props.length;
  while (++index2 < length2) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : void 0;
    if (newValue === void 0) {
      newValue = source2[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
var nativeMax$1 = Math.max;
function overRest(func, start2, transform) {
  start2 = nativeMax$1(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length2 = nativeMax$1(args.length - start2, 0), array = Array(length2);
    while (++index2 < length2) {
      array[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform(array);
    return apply(func, this, otherArgs);
  };
}
function baseRest(func, start2) {
  return setToString$1(overRest(func, start2, identity$1), func + "");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isArrayLike$1(value) {
  return value != null && isLength(value.length) && !isFunction$3(value);
}
function isIterateeCall(value, index2, object) {
  if (!isObject$5(object)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike$1(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
    return eq(object[index2], value);
  }
  return false;
}
var objectProto$b = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$b;
  return value === proto;
}
function baseTimes(n2, iteratee2) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee2(index2);
  }
  return result;
}
var argsTag$3 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$3;
}
var objectProto$a = Object.prototype;
var hasOwnProperty$a = objectProto$a.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$a.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments$1 = isArguments;
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
var isBuffer$1 = nativeIsBuffer || stubFalse;
var isBuffer$2 = isBuffer$1;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types2) {
      return types2;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;
var objectProto$9 = Object.prototype;
var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$4(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$9.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;
var objectProto$8 = Object.prototype;
var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$8.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys$1(object) {
  return isArrayLike$1(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject$5(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$7.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike$1(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray$4(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$6 = Object.prototype;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
function hashGet(key) {
  var data2 = this.__data__;
  if (nativeCreate$1) {
    var result = data2[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$6.call(data2, key) ? data2[key] : void 0;
}
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function hashHas(key) {
  var data2 = this.__data__;
  return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$5.call(data2, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data2 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data2[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array, key) {
  var length2 = array.length;
  while (length2--) {
    if (eq(array[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var arrayProto$1 = Array.prototype;
var splice$1 = arrayProto$1.splice;
function listCacheDelete(key) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index2 == lastIndex) {
    data2.pop();
  } else {
    splice$1.call(data2, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key);
  return index2 < 0 ? void 0 : data2[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key);
  if (index2 < 0) {
    ++this.size;
    data2.push([key, value]);
  } else {
    data2[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root$1, "Map");
var Map$2 = Map$1;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map2, key) {
  var data2 = map2.__data__;
  return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data2 = getMapData(this, key), size = data2.size;
  data2.set(key, value);
  this.size += data2.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var stringToPath$1 = stringToPath;
function toString$1(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object) {
  if (isArray$4(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath$1(toString$1(value));
}
var INFINITY = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function baseGet(object, path) {
  path = castPath(path, object);
  var index2 = 0, length2 = path.length;
  while (object != null && index2 < length2) {
    object = object[toKey(path[index2++])];
  }
  return index2 && index2 == length2 ? object : void 0;
}
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
function arrayPush(array, values2) {
  var index2 = -1, length2 = values2.length, offset = array.length;
  while (++index2 < length2) {
    array[offset + index2] = values2[index2];
  }
  return array;
}
var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray$4(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index2 = -1, length2 = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length2) {
    var value = array[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
function flatten(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? baseFlatten(array, 1) : [];
}
function flatRest(func) {
  return setToString$1(overRest(func, void 0, flatten), func + "");
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
var objectTag$3 = "[object Object]";
var funcProto = Function.prototype, objectProto$4 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$1(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$4.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
function baseSlice(array, start2, end3) {
  var index2 = -1, length2 = array.length;
  if (start2 < 0) {
    start2 = -start2 > length2 ? 0 : length2 + start2;
  }
  end3 = end3 > length2 ? length2 : end3;
  if (end3 < 0) {
    end3 += length2;
  }
  length2 = start2 > end3 ? 0 : end3 - start2 >>> 0;
  start2 >>>= 0;
  var result = Array(length2);
  while (++index2 < length2) {
    result[index2] = array[index2 + start2];
  }
  return result;
}
function castSlice(array, start2, end3) {
  var length2 = array.length;
  end3 = end3 === void 0 ? length2 : end3;
  return !start2 && end3 >= length2 ? array : baseSlice(array, start2, end3);
}
var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f";
var rsZWJ$2 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
function asciiToArray(string) {
  return string.split("");
}
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d";
var reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
function stringToArray(string) {
  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
}
function createCaseFirst(methodName) {
  return function(string) {
    string = toString$1(string);
    var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var upperFirst = createCaseFirst("toUpperCase");
var upperFirst$1 = upperFirst;
function capitalize(string) {
  return upperFirst$1(toString$1(string).toLowerCase());
}
function arrayReduce(array, iteratee2, accumulator, initAccum) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  if (initAccum && length2) {
    accumulator = array[++index2];
  }
  while (++index2 < length2) {
    accumulator = iteratee2(accumulator, array[index2], index2, array);
  }
  return accumulator;
}
function basePropertyOf(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var deburredLetters = {
  "\xC0": "A",
  "\xC1": "A",
  "\xC2": "A",
  "\xC3": "A",
  "\xC4": "A",
  "\xC5": "A",
  "\xE0": "a",
  "\xE1": "a",
  "\xE2": "a",
  "\xE3": "a",
  "\xE4": "a",
  "\xE5": "a",
  "\xC7": "C",
  "\xE7": "c",
  "\xD0": "D",
  "\xF0": "d",
  "\xC8": "E",
  "\xC9": "E",
  "\xCA": "E",
  "\xCB": "E",
  "\xE8": "e",
  "\xE9": "e",
  "\xEA": "e",
  "\xEB": "e",
  "\xCC": "I",
  "\xCD": "I",
  "\xCE": "I",
  "\xCF": "I",
  "\xEC": "i",
  "\xED": "i",
  "\xEE": "i",
  "\xEF": "i",
  "\xD1": "N",
  "\xF1": "n",
  "\xD2": "O",
  "\xD3": "O",
  "\xD4": "O",
  "\xD5": "O",
  "\xD6": "O",
  "\xD8": "O",
  "\xF2": "o",
  "\xF3": "o",
  "\xF4": "o",
  "\xF5": "o",
  "\xF6": "o",
  "\xF8": "o",
  "\xD9": "U",
  "\xDA": "U",
  "\xDB": "U",
  "\xDC": "U",
  "\xF9": "u",
  "\xFA": "u",
  "\xFB": "u",
  "\xFC": "u",
  "\xDD": "Y",
  "\xFD": "y",
  "\xFF": "y",
  "\xC6": "Ae",
  "\xE6": "ae",
  "\xDE": "Th",
  "\xFE": "th",
  "\xDF": "ss",
  "\u0100": "A",
  "\u0102": "A",
  "\u0104": "A",
  "\u0101": "a",
  "\u0103": "a",
  "\u0105": "a",
  "\u0106": "C",
  "\u0108": "C",
  "\u010A": "C",
  "\u010C": "C",
  "\u0107": "c",
  "\u0109": "c",
  "\u010B": "c",
  "\u010D": "c",
  "\u010E": "D",
  "\u0110": "D",
  "\u010F": "d",
  "\u0111": "d",
  "\u0112": "E",
  "\u0114": "E",
  "\u0116": "E",
  "\u0118": "E",
  "\u011A": "E",
  "\u0113": "e",
  "\u0115": "e",
  "\u0117": "e",
  "\u0119": "e",
  "\u011B": "e",
  "\u011C": "G",
  "\u011E": "G",
  "\u0120": "G",
  "\u0122": "G",
  "\u011D": "g",
  "\u011F": "g",
  "\u0121": "g",
  "\u0123": "g",
  "\u0124": "H",
  "\u0126": "H",
  "\u0125": "h",
  "\u0127": "h",
  "\u0128": "I",
  "\u012A": "I",
  "\u012C": "I",
  "\u012E": "I",
  "\u0130": "I",
  "\u0129": "i",
  "\u012B": "i",
  "\u012D": "i",
  "\u012F": "i",
  "\u0131": "i",
  "\u0134": "J",
  "\u0135": "j",
  "\u0136": "K",
  "\u0137": "k",
  "\u0138": "k",
  "\u0139": "L",
  "\u013B": "L",
  "\u013D": "L",
  "\u013F": "L",
  "\u0141": "L",
  "\u013A": "l",
  "\u013C": "l",
  "\u013E": "l",
  "\u0140": "l",
  "\u0142": "l",
  "\u0143": "N",
  "\u0145": "N",
  "\u0147": "N",
  "\u014A": "N",
  "\u0144": "n",
  "\u0146": "n",
  "\u0148": "n",
  "\u014B": "n",
  "\u014C": "O",
  "\u014E": "O",
  "\u0150": "O",
  "\u014D": "o",
  "\u014F": "o",
  "\u0151": "o",
  "\u0154": "R",
  "\u0156": "R",
  "\u0158": "R",
  "\u0155": "r",
  "\u0157": "r",
  "\u0159": "r",
  "\u015A": "S",
  "\u015C": "S",
  "\u015E": "S",
  "\u0160": "S",
  "\u015B": "s",
  "\u015D": "s",
  "\u015F": "s",
  "\u0161": "s",
  "\u0162": "T",
  "\u0164": "T",
  "\u0166": "T",
  "\u0163": "t",
  "\u0165": "t",
  "\u0167": "t",
  "\u0168": "U",
  "\u016A": "U",
  "\u016C": "U",
  "\u016E": "U",
  "\u0170": "U",
  "\u0172": "U",
  "\u0169": "u",
  "\u016B": "u",
  "\u016D": "u",
  "\u016F": "u",
  "\u0171": "u",
  "\u0173": "u",
  "\u0174": "W",
  "\u0175": "w",
  "\u0176": "Y",
  "\u0177": "y",
  "\u0178": "Y",
  "\u0179": "Z",
  "\u017B": "Z",
  "\u017D": "Z",
  "\u017A": "z",
  "\u017C": "z",
  "\u017E": "z",
  "\u0132": "IJ",
  "\u0133": "ij",
  "\u0152": "Oe",
  "\u0153": "oe",
  "\u0149": "'n",
  "\u017F": "s"
};
var deburrLetter = basePropertyOf(deburredLetters);
var deburrLetter$1 = deburrLetter;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsCombo$1 = "[" + rsComboRange$1 + "]";
var reComboMark = RegExp(rsCombo$1, "g");
function deburr(string) {
  string = toString$1(string);
  return string && string.replace(reLatin, deburrLetter$1).replace(reComboMark, "");
}
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "['\u2019]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}
function words(string, pattern, guard) {
  string = toString$1(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}
var rsApos = "['\u2019]";
var reApos = RegExp(rsApos, "g");
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
  };
}
var camelCase$2 = createCompounder(function(result, word, index2) {
  word = word.toLowerCase();
  return result + (index2 ? capitalize(word) : word);
});
var camelCase$3 = camelCase$2;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data2 = this.__data__, result = data2["delete"](key);
  this.size = data2.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data2 = this.__data__;
  if (data2 instanceof ListCache) {
    var pairs = data2.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data2.size;
      return this;
    }
    data2 = this.__data__ = new MapCache(pairs);
  }
  data2.set(key, value);
  this.size = data2.size;
  return this;
}
function Stack(entries) {
  var data2 = this.__data__ = new ListCache(entries);
  this.size = data2.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(object, source2) {
  return object && copyObject(source2, keys$1(source2), object);
}
function baseAssignIn(object, source2) {
  return object && copyObject(source2, keysIn(source2), object);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer$1 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
function cloneBuffer(buffer2, isDeep) {
  if (isDeep) {
    return buffer2.slice();
  }
  var length2 = buffer2.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer2.constructor(length2);
  buffer2.copy(result);
  return result;
}
function arrayFilter(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length2) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$3 = Object.prototype;
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var getSymbols$1 = getSymbols;
function copySymbols(source2, object) {
  return copyObject(source2, getSymbols$1(source2), object);
}
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols$1(object));
    object = getPrototype$1(object);
  }
  return result;
};
var getSymbolsIn$1 = getSymbolsIn;
function copySymbolsIn(source2, object) {
  return copyObject(source2, getSymbolsIn$1(source2), object);
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$4(object) ? result : arrayPush(result, symbolsFunc(object));
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys$1, getSymbols$1);
}
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
}
var DataView$1 = getNative(root$1, "DataView");
var DataView$2 = DataView$1;
var Promise$1 = getNative(root$1, "Promise");
var Promise$2 = Promise$1;
var Set$1 = getNative(root$1, "Set");
var Set$2 = Set$1;
var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$3 = "[object DataView]";
var dataViewCtorString = toSource(DataView$2), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$3);
var getTag = baseGetTag;
if (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$3 || Map$2 && getTag(new Map$2()) != mapTag$4 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$4 || WeakMap$3 && getTag(new WeakMap$3()) != weakMapTag$1) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$3;
        case mapCtorString:
          return mapTag$4;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$4;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var objectProto$2 = Object.prototype;
var hasOwnProperty$3 = objectProto$2.hasOwnProperty;
function initCloneArray(array) {
  var length2 = array.length, result = new array.constructor(length2);
  if (length2 && typeof array[0] == "string" && hasOwnProperty$3.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var Uint8Array$1 = root$1.Uint8Array;
var Uint8Array$2 = Uint8Array$1;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
}
var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object);
    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object);
    case dataViewTag$2:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$3:
      return new Ctor();
    case numberTag$2:
    case stringTag$2:
      return new Ctor(object);
    case regexpTag$2:
      return cloneRegExp(object);
    case setTag$3:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object);
  }
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
}
var mapTag$2 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$2;
}
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
var isMap$1 = isMap;
var setTag$2 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$2;
}
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet$3 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet$4 = isSet$3;
var CLONE_DEEP_FLAG$3 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$3, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$5(value)) {
    return value;
  }
  var isArr = isArray$4(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$2(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet$4(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys$1;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var CLONE_DEEP_FLAG$2 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG$2 | CLONE_SYMBOLS_FLAG$1);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values2) {
  var index2 = -1, length2 = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache();
  while (++index2 < length2) {
    this.add(values2[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache2, key) {
  return cache2.has(key);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
function mapToArray(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
function setToArray(set) {
  var index2 = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag:
      var convert2 = mapToArray;
    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert2 || (convert2 = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$4(object), othIsArr = isArray$4(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$2(object)) {
    if (!isBuffer$2(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object, source2, matchData, customizer) {
  var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length2;
  }
  object = Object(object);
  while (index2--) {
    var data2 = matchData[index2];
    if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
      return false;
    }
  }
  while (++index2 < length2) {
    data2 = matchData[index2];
    var key = data2[0], objValue = object[key], srcValue = data2[1];
    if (noCustomizer && data2[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source2, stack);
      }
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject$5(value);
}
function getMatchData(object) {
  var result = keys$1(object), length2 = result.length;
  while (length2--) {
    var key = result[length2], value = object[key];
    result[length2] = [key, value, isStrictComparable(value)];
  }
  return result;
}
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
function baseMatches(source2) {
  var matchData = getMatchData(source2);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source2 || baseIsMatch(object, source2, matchData);
  };
}
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index2 = -1, length2 = path.length, result = false;
  while (++index2 < length2) {
    var key = toKey(path[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length2) {
    return result;
  }
  length2 = object == null ? 0 : object.length;
  return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray$4(object) || isArguments$1(object));
}
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$1;
  }
  if (typeof value == "object") {
    return isArray$4(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
function createBaseFor(fromRight) {
  return function(object, iteratee2, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
    while (length2--) {
      var key = props[fromRight ? length2 : ++index2];
      if (iteratee2(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor = createBaseFor();
var baseFor$1 = baseFor;
function baseForOwn(object, iteratee2) {
  return object && baseFor$1(object, iteratee2, keys$1);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee2) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$1(collection)) {
      return eachFunc(collection, iteratee2);
    }
    var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length2) {
      if (iteratee2(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach = createBaseEach(baseForOwn);
var baseEach$1 = baseEach;
var now = function() {
  return root$1.Date.now();
};
var now$1 = now;
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject$5(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$1());
  }
  function debounced() {
    var time = now$1(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function last$1(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? array[length2 - 1] : void 0;
}
function arrayEvery(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (!predicate(array[index2], index2, array)) {
      return false;
    }
  }
  return true;
}
function baseEvery(collection, predicate) {
  var result = true;
  baseEach$1(collection, function(value, index2, collection2) {
    result = !!predicate(value, index2, collection2);
    return result;
  });
  return result;
}
function every$1(collection, predicate, guard) {
  var func = isArray$4(collection) ? arrayEvery : baseEvery;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee(predicate));
}
function baseMap(collection, iteratee2) {
  var index2 = -1, result = isArrayLike$1(collection) ? Array(collection.length) : [];
  baseEach$1(collection, function(value, key, collection2) {
    result[++index2] = iteratee2(value, key, collection2);
  });
  return result;
}
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
function isMatch(object, source2) {
  return object === source2 || baseIsMatch(object, source2, getMatchData(source2));
}
var CLONE_DEEP_FLAG$1 = 1;
function iteratee(func) {
  return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG$1));
}
var kebabCase = createCompounder(function(result, word, index2) {
  return result + (index2 ? "-" : "") + word.toLowerCase();
});
var kebabCase$1 = kebabCase;
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last$1(path))];
}
function customOmitClone(value) {
  return isPlainObject$1(value) ? void 0 : value;
}
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length2 = paths.length;
  while (length2--) {
    baseUnset(result, paths[length2]);
  }
  return result;
});
var omit$1 = omit;
function baseSet(object, path, value, customizer) {
  if (!isObject$5(object)) {
    return object;
  }
  path = castPath(path, object);
  var index2 = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
  while (nested != null && ++index2 < length2) {
    var key = toKey(path[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$5(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
function basePickBy(object, paths, predicate) {
  var index2 = -1, length2 = paths.length, result = {};
  while (++index2 < length2) {
    var path = paths[index2], value = baseGet(object, path);
    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}
function baseSortBy(array, comparer) {
  var length2 = array.length;
  array.sort(comparer);
  while (length2--) {
    array[length2] = array[length2].value;
  }
  return array;
}
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
function compareMultiple(object, other, orders) {
  var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
  while (++index2 < length2) {
    var result = compareAscending(objCriteria[index2], othCriteria[index2]);
    if (result) {
      if (index2 >= ordersLength) {
        return result;
      }
      var order = orders[index2];
      return result * (order == "desc" ? -1 : 1);
    }
  }
  return object.index - other.index;
}
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap(iteratees, function(iteratee2) {
      if (isArray$4(iteratee2)) {
        return function(value) {
          return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
        };
      }
      return iteratee2;
    });
  } else {
    iteratees = [identity$1];
  }
  var index2 = -1;
  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
  var result = baseMap(collection, function(value, key, collection2) {
    var criteria = arrayMap(iteratees, function(iteratee2) {
      return iteratee2(value);
    });
    return { "criteria": criteria, "index": ++index2, "value": value };
  });
  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});
var pick$1 = pick;
function baseIndexOfWith(array, value, fromIndex, comparator) {
  var index2 = fromIndex - 1, length2 = array.length;
  while (++index2 < length2) {
    if (comparator(array[index2], value)) {
      return index2;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function basePullAll(array, values2, iteratee2, comparator) {
  var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length2 = values2.length, seen = array;
  if (array === values2) {
    values2 = copyArray(values2);
  }
  if (iteratee2) {
    seen = arrayMap(array, baseUnary(iteratee2));
  }
  while (++index2 < length2) {
    var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
    while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array) {
        splice.call(seen, fromIndex, 1);
      }
      splice.call(array, fromIndex, 1);
    }
  }
  return array;
}
function pullAll(array, values2) {
  return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
}
var pull$1 = baseRest(pullAll);
var pull$2 = pull$1;
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length2 = iteratees.length;
  if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});
var sortBy$1 = sortBy;
const convert = function(test) {
  if (test === void 0 || test === null) {
    return ok;
  }
  if (typeof test === "string") {
    return typeFactory(test);
  }
  if (typeof test === "object") {
    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
  }
  if (typeof test === "function") {
    return castFactory(test);
  }
  throw new Error("Expected function, string, or object as test");
};
function anyFactory(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  return castFactory(all3);
  function all3(node) {
    let key;
    for (key in check) {
      if (node[key] !== check[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node) {
    return node && node.type === check;
  }
}
function castFactory(check) {
  return assertion;
  function assertion(node, ...parameters) {
    return Boolean(node && typeof node === "object" && "type" in node && Boolean(check.call(this, node, ...parameters)));
  }
}
function ok() {
  return true;
}
function color$1(d) {
  return d;
}
const CONTINUE = true;
const EXIT = false;
const SKIP = "skip";
const visitParents = function(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  const is = convert(test);
  const step = reverse ? -1 : 1;
  factory2(tree, void 0, [])();
  function factory2(node, index2, parents) {
    const value = node && typeof node === "object" ? node : {};
    if (typeof value.type === "string") {
      const name2 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
      Object.defineProperty(visit2, "name", {
        value: "node (" + color$1(node.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = [];
      let subresult;
      let offset;
      let grandparents;
      if (!test || is(node, index2, parents[parents.length - 1] || null)) {
        result = toResult(visitor(node, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if (node.children && result[0] !== SKIP) {
        offset = (reverse ? node.children.length : -1) + step;
        grandparents = parents.concat(node);
        while (offset > -1 && offset < node.children.length) {
          subresult = factory2(node.children[offset], offset, grandparents)();
          if (subresult[0] === EXIT) {
            return subresult;
          }
          offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
        }
      }
      return result;
    }
  }
};
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return [value];
}
const visit = function(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node, parents) {
    const parent2 = parents[parents.length - 1];
    return visitor(node, parent2 ? parent2.children.indexOf(node) : null, parent2);
  }
};
var fastDeepEqual = function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length2, i2, keys2;
    if (Array.isArray(a)) {
      length2 = a.length;
      if (length2 != b.length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (!equal(a[i2], b[i2]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys2 = Object.keys(a);
    length2 = keys2.length;
    if (length2 !== Object.keys(b).length)
      return false;
    for (i2 = length2; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys2[i2]))
        return false;
    for (i2 = length2; i2-- !== 0; ) {
      var key = keys2[i2];
      if (!equal(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
const generateId = () => (Math.random() * 1e20).toString(36);
const insertAt$1 = (index2 = 0, ins, arr, replace = false) => [...arr.slice(0, index2), ...[ins].flat(), ...arr.slice(replace ? index2 + 1 : index2)];
const replaceItem$1 = (match, newItem, arr) => {
  match = typeof match === "function" ? match : (x) => x === match;
  const index2 = arr.findIndex(match);
  if (index2 < 0)
    return arr;
  return insertAt$1(index2, newItem, arr, true);
};
const swapIndex = (indexA, indexB, arr) => {
  if (!arr[indexA] || !arr[indexB])
    return arr;
  arr = [...arr];
  const prevA = arr[indexA];
  arr[indexA] = arr[indexB];
  arr[indexB] = prevA;
  return arr;
};
const swapItems = (itemA, itemB, arr) => {
  const indexA = arr.findIndex((x) => x === itemA);
  const indexB = arr.findIndex((x) => x === itemB);
  if (indexA < 0 || indexB < 0)
    return arr;
  return swapIndex(indexA, indexB, arr);
};
const toDataNode$1 = (node) => {
  if (!node)
    return null;
  return {
    id: node.id,
    props: node.props,
    childIds: (node.children || []).map((x) => x.id)
  };
};
const toSceneNode = (node) => {
  return {
    id: node.id,
    props: node.props,
    children: []
  };
};
const toSceneTree = (nodes, rootId) => {
  const root2 = nodes.find((x) => x.id === rootId);
  if (!root2)
    return null;
  const childIds = root2.childIds;
  return {
    id: root2.id,
    props: root2.props,
    children: childIds.map((x) => toSceneTree(nodes, x)).filter(Boolean)
  };
};
const forEachDown$1 = (node, fn) => {
  fn(node);
  const children = node.children || [];
  children.forEach((x) => forEachDown$1(x, (next, parent2) => {
    fn(next, parent2 || node);
  }));
};
const mapDown = (node, fn) => {
  const result = fn(node);
  return {
    ...result,
    children: ((result == null ? void 0 : result.children) || (node == null ? void 0 : node.children) || []).map((x) => mapDown(x, fn))
  };
};
const mapDownAsync = async (node, fn) => {
  var _a2;
  const children = (_a2 = node == null ? void 0 : node.children) != null ? _a2 : [];
  return {
    ...await fn(node),
    children: await Promise.all(children.map((x) => mapDownAsync(x, fn)))
  };
};
const getElementAttributes = (x) => {
  return Object.values(x.attributes).reduce((acc, x2) => {
    return {
      ...acc,
      [x2.name]: x2.value
    };
  }, {});
};
const asArray = (x) => {
  return isArray$4(x) ? x : [x];
};
const sizeToNum = (x, parentSize) => {
  if (typeof x === "number")
    return x;
  if (typeof x === "string") {
    if (x.indexOf("%") > -1) {
      return parseFloat(x) / 100 * parentSize;
    }
    return parseFloat(x);
  }
  return 0;
};
const asSize = (x) => {
  if (typeof x === "number")
    return x + "px";
  if (typeof x === "string") {
    if (x.indexOf("%") > -1) {
      return parseFloat(x) + "%";
    }
    return x;
  }
  return "0px";
};
const asDuration = (x) => {
  if (typeof x === "string") {
    return x;
  }
  if (typeof x === "number")
    return x + "ms";
  return "0ms";
};
const find$2 = (tree, condition) => {
  if (!tree)
    throw new Error("requires a tree to search");
  if (!condition)
    throw new Error("requires a condition");
  const predicate = iteratee(condition);
  let result;
  visit(tree, function(node) {
    if (predicate(node)) {
      result = node;
      return false;
    }
  });
  return result;
};
const findAll = (tree, condition) => {
  if (!tree)
    throw new Error("requires a tree to search");
  if (!condition)
    throw new Error("requires a condition");
  const predicate = iteratee(condition);
  let result = [];
  visit(tree, function(node) {
    if (predicate(node)) {
      result.push(node);
    }
  });
  return result;
};
const values = (map2) => Array.from(map2.values());
var Logic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  deepEqual: fastDeepEqual,
  generateId,
  insertAt: insertAt$1,
  replaceItem: replaceItem$1,
  swapIndex,
  swapItems,
  toDataNode: toDataNode$1,
  toSceneNode,
  toSceneTree,
  forEachDown: forEachDown$1,
  mapDown,
  mapDownAsync,
  getElementAttributes,
  asArray,
  sizeToNum,
  asSize,
  asDuration,
  find: find$2,
  findAll,
  values,
  pick: pick$1,
  pull: pull$2,
  omit: omit$1,
  isEqual,
  cloneDeep,
  sortBy: sortBy$1,
  debounce: debounce$1,
  camelCase: camelCase$3,
  kebabCase: kebabCase$1,
  isArray: isArray$4,
  every: every$1
}, Symbol.toStringTag, { value: "Module" }));
var lib$2 = {};
function e(e2) {
  this.message = e2;
}
e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
var r$1 = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r2) {
  var t2 = String(r2).replace(/=+$/, "");
  if (t2.length % 4 == 1)
    throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var n2, o2, a = 0, i2 = 0, c = ""; o2 = t2.charAt(i2++); ~o2 && (n2 = a % 4 ? 64 * n2 + o2 : o2, a++ % 4) ? c += String.fromCharCode(255 & n2 >> (-2 * a & 6)) : 0)
    o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
  return c;
};
function t(e2) {
  var t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
  switch (t2.length % 4) {
    case 0:
      break;
    case 2:
      t2 += "==";
      break;
    case 3:
      t2 += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(e3) {
      return decodeURIComponent(r$1(e3).replace(/(.)/g, function(e4, r2) {
        var t3 = r2.charCodeAt(0).toString(16).toUpperCase();
        return t3.length < 2 && (t3 = "0" + t3), "%" + t3;
      }));
    }(t2);
  } catch (e3) {
    return r$1(t2);
  }
}
function n(e2) {
  this.message = e2;
}
function o(e2, r2) {
  if ("string" != typeof e2)
    throw new n("Invalid token specified");
  var o2 = true === (r2 = r2 || {}).header ? 0 : 1;
  try {
    return JSON.parse(t(e2.split(".")[o2]));
  } catch (e3) {
    throw new n("Invalid token specified: " + e3.message);
  }
}
n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
var jwtDecode_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": o,
  InvalidTokenError: n
}, Symbol.toStringTag, { value: "Module" }));
var require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(jwtDecode_esm);
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate$1(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate$1(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var _nodeId;
var _clockseq;
var _lastMSecs = 0;
var _lastNSecs = 0;
function v1(options, buf, offset) {
  var i2 = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i2++] = tl >>> 24 & 255;
  b[i2++] = tl >>> 16 & 255;
  b[i2++] = tl >>> 8 & 255;
  b[i2++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i2++] = tmh >>> 8 & 255;
  b[i2++] = tmh & 255;
  b[i2++] = tmh >>> 24 & 15 | 16;
  b[i2++] = tmh >>> 16 & 255;
  b[i2++] = clockseq >>> 8 | 128;
  b[i2++] = clockseq & 255;
  for (var n2 = 0; n2 < 6; ++n2) {
    b[i2 + n2] = node[n2];
  }
  return buf || stringify(b);
}
function parse$2(uuid) {
  if (!validate$1(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    bytes.push(str.charCodeAt(i2));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name2, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse$2(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = bytes[i2];
      }
      return buf;
    }
    return stringify(bytes);
  }
  try {
    generateUUID.name = name2;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL$1;
  return generateUUID;
}
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i2 = 0; i2 < msg.length; ++i2) {
      bytes[i2] = msg.charCodeAt(i2);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i2 = 0; i2 < length32; i2 += 8) {
    var x = input[i2 >> 5] >>> i2 % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i2 = 0; i2 < x.length; i2 += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i2], 7, -680876936);
    d = md5ff(d, a, b, c, x[i2 + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i2 + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i2 + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i2 + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i2 + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i2 + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i2 + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i2 + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i2 + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i2 + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i2 + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i2 + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i2 + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i2 + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i2 + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i2 + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i2 + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i2 + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i2], 20, -373897302);
    a = md5gg(a, b, c, d, x[i2 + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i2 + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i2 + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i2 + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i2 + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i2 + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i2 + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i2 + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i2 + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i2 + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i2 + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i2 + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i2 + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i2 + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i2 + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i2 + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i2 + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i2 + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i2 + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i2 + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i2 + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i2], 11, -358537222);
    c = md5hh(c, d, a, b, x[i2 + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i2 + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i2 + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i2 + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i2 + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i2 + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i2], 6, -198630844);
    d = md5ii(d, a, b, c, x[i2 + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i2 + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i2 + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i2 + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i2 + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i2 + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i2 + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i2 + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i2 + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i2 + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i2 + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i2 + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i2 + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i2 + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i2 + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i2 = 0; i2 < length8; i2 += 8) {
    output[i2 >> 5] |= (input[i2 / 8] & 255) << i2 % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t2)), s), b);
}
function md5ff(a, b, c, d, x, s, t2) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t2);
}
function md5gg(a, b, c, d, x, s, t2) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t2);
}
function md5hh(a, b, c, d, x, s, t2) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t2);
}
function md5ii(a, b, c, d, x, s, t2) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t2);
}
var v3 = v35("v3", 48, md5);
var v3$1 = v3;
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return stringify(rnds);
}
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n2) {
  return x << n2 | x >>> 32 - n2;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i2 = 0; i2 < msg.length; ++i2) {
      bytes.push(msg.charCodeAt(i2));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t2 = 0; t2 < 16; ++t2) {
      W[t2] = M[_i2][t2];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e2 = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e2 + K[s] + W[_t2] >>> 0;
      e2 = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e2 >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var v5 = v35("v5", 80, sha1);
var v5$1 = v5;
var nil = "00000000-0000-0000-0000-000000000000";
function version$4(uuid) {
  if (!validate$1(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  v1,
  v3: v3$1,
  v4,
  v5: v5$1,
  NIL: nil,
  version: version$4,
  validate: validate$1,
  stringify,
  parse: parse$2
}, Symbol.toStringTag, { value: "Module" }));
var require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser);
class EnhancedMap$1 extends Map {
  computeIfAbsent(key, computer) {
    if (this.has(key)) {
      return this.get(key);
    }
    const newValue = computer(key);
    this.set(key, newValue);
    return newValue;
  }
  computeIfPresent(key, computer) {
    const currentValue = this.get(key);
    if (currentValue === void 0) {
      return void 0;
    }
    const newValue = computer(key, currentValue);
    if (newValue !== void 0) {
      this.set(key, newValue);
    } else {
      this.delete(key);
    }
    return newValue;
  }
  compute(key, computer) {
    const currentValue = this.get(key);
    const newValue = computer(key, currentValue);
    if (newValue) {
      this.set(key, newValue);
    } else {
      this.delete(key);
    }
    return newValue;
  }
}
var InternalLogLevel$1;
(function(InternalLogLevel2) {
  InternalLogLevel2[InternalLogLevel2["Trace"] = 0] = "Trace";
  InternalLogLevel2[InternalLogLevel2["Debug"] = 1] = "Debug";
  InternalLogLevel2[InternalLogLevel2["Info"] = 2] = "Info";
  InternalLogLevel2[InternalLogLevel2["Warn"] = 3] = "Warn";
  InternalLogLevel2[InternalLogLevel2["Error"] = 4] = "Error";
})(InternalLogLevel$1 || (InternalLogLevel$1 = {}));
function getInternalLogger$1(name2) {
  return provider$1.getLogger(name2);
}
const INTERNAL_LOGGING_SETTINGS$1 = {
  setInternalLogLevel: (level) => provider$1.changeLogLevel(level),
  setOutput: (fnOutput) => provider$1.changeOutput(fnOutput),
  reset: () => provider$1.reset()
};
class InternalLoggerImpl$1 {
  constructor(name2, level, fnOutput) {
    this._name = name2;
    this._level = level;
    this._fnOutput = fnOutput;
  }
  trace(msg) {
    this.log(InternalLogLevel$1.Trace, msg);
  }
  debug(msg) {
    this.log(InternalLogLevel$1.Debug, msg);
  }
  error(msg, error) {
    this.log(InternalLogLevel$1.Error, msg, error);
  }
  info(msg) {
    this.log(InternalLogLevel$1.Info, msg);
  }
  warn(msg, error) {
    this.log(InternalLogLevel$1.Warn, msg, error);
  }
  setLevel(level) {
    this._level = level;
  }
  setOutput(fnOutput) {
    this._fnOutput = fnOutput;
  }
  log(level, msg, error) {
    if (this._level > level) {
      return;
    }
    this._fnOutput(`${InternalLogLevel$1[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${msg()}${error ? "\n" + error.stack : ""}`);
  }
}
class InternalProviderImpl$1 {
  constructor() {
    this._loggers = new EnhancedMap$1();
    this._logLevel = InternalLogLevel$1.Error;
    this._fnOutput = InternalProviderImpl$1.logConsole;
  }
  getLogger(name2) {
    return this._loggers.computeIfAbsent(name2, (key) => new InternalLoggerImpl$1(key, this._logLevel, this._fnOutput));
  }
  changeLogLevel(level) {
    this._logLevel = level;
    this._loggers.forEach((logger2) => logger2.setLevel(level));
  }
  changeOutput(_fnOutput) {
    this._fnOutput = _fnOutput;
    this._loggers.forEach((logger2) => logger2.setOutput(this._fnOutput));
  }
  reset() {
    this.changeLogLevel(InternalLogLevel$1.Error);
    this._fnOutput = InternalProviderImpl$1.logConsole;
    this._loggers.forEach((logger2) => logger2.setOutput(this._fnOutput));
  }
  static logConsole(msg) {
    if (console && console.log) {
      console.log(msg);
    }
  }
}
const provider$1 = new InternalProviderImpl$1();
var InternalLogger$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get InternalLogLevel() {
    return InternalLogLevel$1;
  },
  getInternalLogger: getInternalLogger$1,
  INTERNAL_LOGGING_SETTINGS: INTERNAL_LOGGING_SETTINGS$1
});
var LogLevel$2;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Trace"] = 0] = "Trace";
  LogLevel2[LogLevel2["Debug"] = 1] = "Debug";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Warn"] = 3] = "Warn";
  LogLevel2[LogLevel2["Error"] = 4] = "Error";
  LogLevel2[LogLevel2["Fatal"] = 5] = "Fatal";
})(LogLevel$2 || (LogLevel$2 = {}));
(function(LogLevel2) {
  function toLogLevel(val) {
    switch (val.toLowerCase()) {
      case "trace":
        return LogLevel2.Trace;
      case "debug":
        return LogLevel2.Debug;
      case "info":
        return LogLevel2.Info;
      case "warn":
        return LogLevel2.Warn;
      case "error":
        return LogLevel2.Error;
      case "fatal":
        return LogLevel2.Fatal;
      default:
        return void 0;
    }
  }
  LogLevel2.toLogLevel = toLogLevel;
})(LogLevel$2 || (LogLevel$2 = {}));
class CoreLoggerImpl$1 {
  constructor(runtime) {
    this._runtime = runtime;
  }
  get id() {
    return this._runtime.id;
  }
  get logLevel() {
    return this._runtime.level;
  }
  get runtimeSettings() {
    return Object.assign({}, this._runtime);
  }
  set runtimeSettings(runtime) {
    this._runtime = runtime;
  }
  trace(message, ...args) {
    this.logMessage(LogLevel$2.Trace, message, args);
  }
  debug(message, ...args) {
    this.logMessage(LogLevel$2.Debug, message, args);
  }
  info(message, ...args) {
    this.logMessage(LogLevel$2.Info, message, args);
  }
  warn(message, ...args) {
    this.logMessage(LogLevel$2.Warn, message, args);
  }
  error(message, ...args) {
    this.logMessage(LogLevel$2.Error, message, args);
  }
  fatal(message, ...args) {
    this.logMessage(LogLevel$2.Fatal, message, args);
  }
  logMessage(level, logMessageType, args) {
    if (this._runtime.level > level) {
      return;
    }
    const nowMillis = Date.now();
    const message = typeof logMessageType === "string" ? logMessageType : logMessageType();
    const errorAndArgs = CoreLoggerImpl$1.getErrorAndArgs(args);
    switch (this._runtime.channel.type) {
      case "RawLogChannel":
        this._runtime.channel.write({
          message,
          exception: errorAndArgs.error,
          args: errorAndArgs.args,
          timeInMillis: nowMillis,
          level,
          logNames: this._runtime.name
        }, this._runtime.argumentFormatter);
        return;
      case "LogChannel":
        this._runtime.channel.write(this.createLogMessage(message, level, errorAndArgs, nowMillis));
        break;
    }
  }
  formatArgValue(value) {
    try {
      return this._runtime.argumentFormatter(value);
    } catch (e2) {
      return `>>ARG CONVERT FAILED: '${value !== void 0 ? value.toString() : "undefined"}'<<`;
    }
  }
  createLogMessage(message, level, errorAndArgs, nowMillis) {
    let errorResult;
    const error = errorAndArgs.error;
    const args = errorAndArgs.args;
    if (error) {
      errorResult = `${error.name}: ${error.message}`;
      if (error.stack) {
        errorResult += `@
${error.stack}`;
      }
    }
    const dateFormatted = this._runtime.dateFormatter(nowMillis);
    let levelAsStr = LogLevel$2[level].toUpperCase();
    if (levelAsStr.length < 5) {
      levelAsStr += " ";
    }
    const names = typeof this._runtime.name === "string" ? this._runtime.name : this._runtime.name.join(", ");
    const argsFormatted = typeof args !== "undefined" && args.length > 0 ? " [" + args.map((arg) => this.formatArgValue(arg)).join(", ") + "]" : "";
    const completedMessage = dateFormatted + " " + levelAsStr + " [" + names + "] " + message + argsFormatted;
    return {
      message: completedMessage,
      error: errorResult
    };
  }
  static getErrorAndArgs(args) {
    if (args.length === 0) {
      return {};
    }
    let error;
    let actualArgs;
    const value0 = args[0];
    if (value0 instanceof Error) {
      error = value0;
      actualArgs = args.length > 1 ? args.slice(1) : void 0;
      return { error, args: actualArgs };
    }
    if (typeof value0 === "function") {
      const errorOrArgs = value0();
      if (errorOrArgs instanceof Error) {
        error = errorOrArgs;
        actualArgs = args.length > 1 ? args.slice(1) : void 0;
        return { error, args: actualArgs };
      }
      if (args.length === 1) {
        if (Array.isArray(errorOrArgs)) {
          return { args: errorOrArgs.length > 0 ? errorOrArgs : void 0 };
        } else {
          return { args: errorOrArgs };
        }
      } else {
        if (Array.isArray(errorOrArgs)) {
          return { args: [...errorOrArgs, ...args.slice(1)] };
        }
        return { args: [errorOrArgs, ...args.slice(1)] };
      }
    }
    return { args };
  }
}
function padStart$1(value, length2, fillChar = " ") {
  return padInternal$1(value, length2, "start", fillChar);
}
function padEnd$1(value, length2, fillChar = " ") {
  return padInternal$1(value, length2, "end", fillChar);
}
function maxLengthStringValueInArray$1(arr) {
  return arr.map((v) => v.length).reduce((previous, current) => {
    if (current > previous) {
      return current;
    }
    return previous;
  }, 0);
}
function padInternal$1(value, length2, padType, fillChar = " ") {
  if (length2 <= value.length) {
    return value;
  }
  if (fillChar.length > 1) {
    throw new Error(`Fill char must be one char exactly, it is: ${fillChar.length}`);
  }
  const charsNeeded = length2 - value.length;
  let padding = "";
  for (let i2 = 0; i2 < charsNeeded; i2++) {
    padding += fillChar;
  }
  if (padType === "start") {
    return padding + value;
  }
  return value + padding;
}
function formatArgument$1(arg) {
  if (arg === void 0) {
    return "undefined";
  }
  return JSON.stringify(arg);
}
function formatDate$1(millisSinceEpoch) {
  const date = new Date(millisSinceEpoch);
  const year = date.getFullYear();
  const month = padStart$1((date.getMonth() + 1).toString(), 2, "0");
  const day = padStart$1(date.getDate().toString(), 2, "0");
  const hours = padStart$1(date.getHours().toString(), 2, "0");
  const minutes = padStart$1(date.getMinutes().toString(), 2, "0");
  const seconds = padStart$1(date.getSeconds().toString(), 2, "0");
  const millis = padStart$1(date.getMilliseconds().toString(), 2, "0");
  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds},${millis}`;
}
class ConsoleLogChannel$1 {
  constructor() {
    this.type = "LogChannel";
  }
  write(msg) {
    if (console && console.log) {
      console.log(msg.message + (msg.error ? `
${msg.error}` : ""));
    }
  }
}
var DefaultChannels$1;
(function(DefaultChannels2) {
  function createConsoleChannel() {
    return new ConsoleLogChannel$1();
  }
  DefaultChannels2.createConsoleChannel = createConsoleChannel;
})(DefaultChannels$1 || (DefaultChannels$1 = {}));
class LogProviderImpl$1 {
  constructor(name2, settings) {
    this._log = getInternalLogger$1("core.impl.LogProviderImpl");
    this._name = name2;
    this._settings = settings;
    this._loggers = new EnhancedMap$1();
    this._idToKeyMap = new EnhancedMap$1();
    this._globalRuntimeSettings = { level: settings.level, channel: settings.channel };
    this._nextLoggerId = 1;
    this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);
  }
  get runtimeSettings() {
    return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });
  }
  getLogger(name2) {
    return this.getOrCreateLogger(name2);
  }
  updateLoggerRuntime(log2, settings) {
    this._log.debug(() => `Updating logger ${log2.id} runtime settings using: '${JSON.stringify(settings)}'`);
    const key = this._idToKeyMap.get(log2.id);
    if (key === void 0) {
      this._log.warn(() => `Cannot update logger with id: ${log2.id}, it was not found.`);
      return false;
    }
    this._loggers.computeIfPresent(key, (currentKey, currentValue) => {
      currentValue.runtimeSettings = LogProviderImpl$1.mergeRuntimeSettingsIntoLogRuntime(currentValue.runtimeSettings, settings);
      return currentValue;
    });
    return true;
  }
  updateRuntimeSettings(settings) {
    this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(settings)}'`);
    this._globalRuntimeSettings = {
      level: settings.level !== void 0 ? settings.level : this._globalRuntimeSettings.level,
      channel: settings.channel !== void 0 ? settings.channel : this._globalRuntimeSettings.channel
    };
    this._loggers.forEach((logger2) => logger2.runtimeSettings = LogProviderImpl$1.mergeRuntimeSettingsIntoLogRuntime(logger2.runtimeSettings, settings));
  }
  clear() {
    this._loggers.clear();
    this._idToKeyMap.clear();
    this._globalRuntimeSettings = Object.assign({}, this._settings);
    this._nextLoggerId = 1;
  }
  getOrCreateLogger(name2) {
    const key = LogProviderImpl$1.createKey(name2);
    const logger2 = this._loggers.computeIfAbsent(key, () => {
      const runtime = {
        level: this._globalRuntimeSettings.level,
        channel: this._globalRuntimeSettings.channel,
        id: this.nextLoggerId(),
        name: name2,
        argumentFormatter: this._settings.argumentFormatter,
        dateFormatter: this._settings.dateFormatter
      };
      return new CoreLoggerImpl$1(runtime);
    });
    this._idToKeyMap.computeIfAbsent(logger2.id, () => key);
    return logger2;
  }
  nextLoggerId() {
    const result = this._name + "_" + this._nextLoggerId;
    this._nextLoggerId++;
    return result;
  }
  static mergeRuntimeSettingsIntoLogRuntime(currentSettings, settings) {
    return Object.assign(Object.assign({}, currentSettings), {
      level: settings.level !== void 0 ? settings.level : currentSettings.level,
      channel: settings.channel !== void 0 ? settings.channel : currentSettings.channel
    });
  }
  static createKey(name2) {
    if (typeof name2 === "string") {
      return name2;
    }
    return name2.join(",");
  }
}
function createLogProvider$1(name2, settings) {
  return new LogProviderImpl$1(name2, settings);
}
var index$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EnhancedMap: EnhancedMap$1,
  padStart: padStart$1,
  padEnd: padEnd$1,
  maxLengthStringValueInArray: maxLengthStringValueInArray$1
});
class ArrayLogChannel {
  constructor() {
    this._buffer = [];
    this.type = "LogChannel";
  }
  write(msg) {
    this._buffer.push(msg);
  }
  get logMessages() {
    return this._buffer;
  }
  get messages() {
    return this._buffer.map((msg) => msg.message);
  }
}
class ArrayRawLogChannel {
  constructor() {
    this._buffer = [];
    this.type = "RawLogChannel";
  }
  write(msg, _) {
    this._buffer.push(msg);
  }
  get messages() {
    return this._buffer.map((m) => m.message);
  }
  get errors() {
    return this._buffer.map((m) => m.exception);
  }
  get size() {
    return this._buffer.length;
  }
  get rawMessages() {
    return this._buffer;
  }
  clear() {
    this._buffer = [];
  }
}
class TestControlMessage {
  constructor() {
    this._messages = [];
    this.write = this.write.bind(this);
  }
  get messages() {
    return this._messages;
  }
  write(msg) {
    this._messages.push(msg);
  }
  clear() {
    this._messages = [];
  }
}
var TestClasses = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArrayLogChannel,
  ArrayRawLogChannel,
  TestControlMessage
});
var typescriptLogging_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $internal: InternalLogger$1,
  $test: TestClasses,
  get DefaultChannels() {
    return DefaultChannels$1;
  },
  get LogLevel() {
    return LogLevel$2;
  },
  createLogProvider: createLogProvider$1,
  formatArgument: formatArgument$1,
  formatDate: formatDate$1,
  util: index$4
}, Symbol.toStringTag, { value: "Module" }));
var require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(typescriptLogging_esm);
var layoutapi = {};
var lib$1 = {};
var lib = {};
var Metadata = {};
Object.defineProperty(Metadata, "__esModule", { value: true });
Metadata.Metadata = void 0;
Metadata.Metadata = function Metadata2(init2) {
  const data2 = /* @__PURE__ */ new Map();
  const metadata = {
    set(key, value) {
      key = normalizeKey(key);
      if (Array.isArray(value)) {
        if (value.length === 0) {
          data2.delete(key);
        } else {
          for (const item of value) {
            validate(key, item);
          }
          data2.set(key, key.endsWith("-bin") ? value : [value.join(", ")]);
        }
      } else {
        validate(key, value);
        data2.set(key, [value]);
      }
      return metadata;
    },
    append(key, value) {
      key = normalizeKey(key);
      validate(key, value);
      let values2 = data2.get(key);
      if (values2 == null) {
        values2 = [];
        data2.set(key, values2);
      }
      values2.push(value);
      if (!key.endsWith("-bin")) {
        data2.set(key, [values2.join(", ")]);
      }
      return metadata;
    },
    delete(key) {
      key = normalizeKey(key);
      data2.delete(key);
    },
    get(key) {
      var _a2;
      key = normalizeKey(key);
      return (_a2 = data2.get(key)) === null || _a2 === void 0 ? void 0 : _a2[0];
    },
    getAll(key) {
      var _a2;
      key = normalizeKey(key);
      return (_a2 = data2.get(key)) !== null && _a2 !== void 0 ? _a2 : [];
    },
    has(key) {
      key = normalizeKey(key);
      return data2.has(key);
    },
    [Symbol.iterator]() {
      return data2[Symbol.iterator]();
    }
  };
  if (init2 != null) {
    const entries = isIterable$1(init2) ? init2 : Object.entries(init2);
    for (const [key, value] of entries) {
      metadata.set(key, value);
    }
  }
  return metadata;
};
function normalizeKey(key) {
  return key.toLowerCase();
}
function validate(key, value) {
  if (!/^[0-9a-z_.-]+$/.test(key)) {
    throw new Error(`Metadata key '${key}' contains illegal characters`);
  }
  if (key.endsWith("-bin")) {
    if (!(value instanceof Uint8Array)) {
      throw new Error(`Metadata key '${key}' ends with '-bin', thus it must have binary value`);
    }
  } else {
    if (typeof value !== "string") {
      throw new Error(`Metadata key '${key}' doesn't end with '-bin', thus it must have string value`);
    }
    if (!/^[ -~]*$/.test(value)) {
      throw new Error(`Metadata value '${value}' of key '${key}' contains illegal characters`);
    }
  }
}
function isIterable$1(value) {
  return Symbol.iterator in value;
}
var Status = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Status = void 0;
  (function(Status2) {
    Status2[Status2["OK"] = 0] = "OK";
    Status2[Status2["CANCELLED"] = 1] = "CANCELLED";
    Status2[Status2["UNKNOWN"] = 2] = "UNKNOWN";
    Status2[Status2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    Status2[Status2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    Status2[Status2["NOT_FOUND"] = 5] = "NOT_FOUND";
    Status2[Status2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    Status2[Status2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    Status2[Status2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    Status2[Status2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    Status2[Status2["ABORTED"] = 10] = "ABORTED";
    Status2[Status2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    Status2[Status2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    Status2[Status2["INTERNAL"] = 13] = "INTERNAL";
    Status2[Status2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    Status2[Status2["DATA_LOSS"] = 15] = "DATA_LOSS";
    Status2[Status2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
  })(exports2.Status || (exports2.Status = {}));
})(Status);
var MethodDescriptor = {};
Object.defineProperty(MethodDescriptor, "__esModule", { value: true });
var CallOptions = {};
Object.defineProperty(CallOptions, "__esModule", { value: true });
var ClientMiddleware = {};
Object.defineProperty(ClientMiddleware, "__esModule", { value: true });
var composeClientMiddleware$1 = {};
Object.defineProperty(composeClientMiddleware$1, "__esModule", { value: true });
composeClientMiddleware$1.composeClientMiddleware = void 0;
function composeClientMiddleware(middleware1, middleware2) {
  return (call, options) => {
    return middleware2({
      ...call,
      next: (request3, options2) => {
        return middleware1({ ...call, request: request3 }, options2);
      }
    }, options);
  };
}
composeClientMiddleware$1.composeClientMiddleware = composeClientMiddleware;
var ClientError$1 = {};
var cjs = {};
var helpers = {};
helpers.__esModule = void 0;
helpers.__esModule = true;
var objectSetPrototypeOfIsDefined = typeof Object.setPrototypeOf === "function";
var objectGetPrototypeOfIsDefined = typeof Object.getPrototypeOf === "function";
var objectDefinePropertyIsDefined = typeof Object.defineProperty === "function";
var objectCreateIsDefined = typeof Object.create === "function";
var objectHasOwnPropertyIsDefined = typeof Object.prototype.hasOwnProperty === "function";
var setPrototypeOf = function setPrototypeOf2(target, prototype) {
  if (objectSetPrototypeOfIsDefined) {
    Object.setPrototypeOf(target, prototype);
  } else {
    target.__proto__ = prototype;
  }
};
helpers.setPrototypeOf = setPrototypeOf;
var getPrototypeOf = function getPrototypeOf2(target) {
  if (objectGetPrototypeOfIsDefined) {
    return Object.getPrototypeOf(target);
  } else {
    return target.__proto__ || target.prototype;
  }
};
helpers.getPrototypeOf = getPrototypeOf;
var ie8ObjectDefinePropertyBug = false;
var defineProperty = function defineProperty2(target, name2, propertyDescriptor) {
  if (objectDefinePropertyIsDefined && !ie8ObjectDefinePropertyBug) {
    try {
      Object.defineProperty(target, name2, propertyDescriptor);
    } catch (e2) {
      ie8ObjectDefinePropertyBug = true;
      defineProperty2(target, name2, propertyDescriptor);
    }
  } else {
    target[name2] = propertyDescriptor.value;
  }
};
helpers.defineProperty = defineProperty;
var hasOwnProperty = function hasOwnProperty2(target, name2) {
  if (objectHasOwnPropertyIsDefined) {
    return target.hasOwnProperty(target, name2);
  } else {
    return target[name2] === void 0;
  }
};
helpers.hasOwnProperty = hasOwnProperty;
var objectCreate = function objectCreate2(prototype, propertyDescriptors) {
  if (objectCreateIsDefined) {
    return Object.create(prototype, propertyDescriptors);
  } else {
    var F = function F2() {
    };
    F.prototype = prototype;
    var result = new F();
    if (typeof propertyDescriptors === "undefined") {
      return result;
    }
    if (typeof propertyDescriptors === "null") {
      throw new Error("PropertyDescriptors must not be null.");
    }
    if (typeof propertyDescriptors === "object") {
      for (var key in propertyDescriptors) {
        if (hasOwnProperty(propertyDescriptors, key)) {
          result[key] = propertyDescriptors[key].value;
        }
      }
    }
    return result;
  }
};
helpers.objectCreate = objectCreate;
(function(exports2) {
  exports2.__esModule = void 0;
  exports2.__esModule = true;
  var helpers$1 = helpers;
  var setPrototypeOf3 = helpers$1.setPrototypeOf;
  var getPrototypeOf3 = helpers$1.getPrototypeOf;
  var defineProperty3 = helpers$1.defineProperty;
  var objectCreate3 = helpers$1.objectCreate;
  var uglyErrorPrinting = new Error().toString() === "[object Error]";
  var extendableErrorName = "";
  function ExtendableError(message) {
    var originalConstructor = this.constructor;
    var constructorName = originalConstructor.name || function() {
      var constructorNameMatch = originalConstructor.toString().match(/^function\s*([^\s(]+)/);
      return constructorNameMatch === null ? extendableErrorName ? extendableErrorName : "Error" : constructorNameMatch[1];
    }();
    var constructorNameIsError = constructorName === "Error";
    var name2 = constructorNameIsError ? extendableErrorName : constructorName;
    var instance = Error.apply(this, arguments);
    setPrototypeOf3(instance, getPrototypeOf3(this));
    if (!(instance instanceof originalConstructor) || !(instance instanceof ExtendableError)) {
      var instance = this;
      Error.apply(this, arguments);
      defineProperty3(instance, "message", {
        configurable: true,
        enumerable: false,
        value: message,
        writable: true
      });
    }
    defineProperty3(instance, "name", {
      configurable: true,
      enumerable: false,
      value: name2,
      writable: true
    });
    if (Error.captureStackTrace) {
      Error.captureStackTrace(instance, constructorNameIsError ? ExtendableError : originalConstructor);
    }
    if (instance.stack === void 0) {
      var err = new Error(message);
      err.name = instance.name;
      instance.stack = err.stack;
    }
    if (uglyErrorPrinting) {
      defineProperty3(instance, "toString", {
        configurable: true,
        enumerable: false,
        value: function toString4() {
          return (this.name || "Error") + (typeof this.message === "undefined" ? "" : ": " + this.message);
        },
        writable: true
      });
    }
    return instance;
  }
  extendableErrorName = ExtendableError.name || "ExtendableError";
  ExtendableError.prototype = objectCreate3(Error.prototype, {
    constructor: {
      value: Error,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  exports2.ExtendableError = ExtendableError;
  exports2["default"] = exports2.ExtendableError;
})(cjs);
Object.defineProperty(ClientError$1, "__esModule", { value: true });
ClientError$1.ClientError = void 0;
const ts_error_1$1 = cjs;
const Status_1$1 = Status;
class ClientError extends ts_error_1$1.ExtendableError {
  constructor(path, code, details) {
    super(`${path} ${Status_1$1.Status[code]}: ${details}`);
    this.path = path;
    this.code = code;
    this.details = details;
    this.name = "ClientError";
    Object.defineProperty(this, "@@nice-grpc", {
      value: true
    });
    Object.defineProperty(this, "@@nice-grpc:ClientError", {
      value: true
    });
  }
  static [Symbol.hasInstance](instance) {
    if (this !== ClientError) {
      return this.prototype.isPrototypeOf(instance);
    }
    return typeof instance === "object" && instance !== null && (instance.constructor === ClientError || instance["@@nice-grpc:ClientError"] === true || instance.name === "ClientError" && instance["@@nice-grpc"] === true);
  }
}
ClientError$1.ClientError = ClientError;
var CallContext = {};
Object.defineProperty(CallContext, "__esModule", { value: true });
var ServerMiddleware = {};
Object.defineProperty(ServerMiddleware, "__esModule", { value: true });
var composeServerMiddleware$1 = {};
Object.defineProperty(composeServerMiddleware$1, "__esModule", { value: true });
composeServerMiddleware$1.composeServerMiddleware = void 0;
function composeServerMiddleware(middleware1, middleware2) {
  return (call, context2) => {
    return middleware1({
      ...call,
      next: (request3, context1) => {
        return middleware2({ ...call, request: request3 }, context1);
      }
    }, context2);
  };
}
composeServerMiddleware$1.composeServerMiddleware = composeServerMiddleware;
var ServerError$1 = {};
Object.defineProperty(ServerError$1, "__esModule", { value: true });
ServerError$1.ServerError = void 0;
const ts_error_1 = cjs;
const Status_1 = Status;
class ServerError extends ts_error_1.ExtendableError {
  constructor(code, details) {
    super(`${Status_1.Status[code]}: ${details}`);
    this.code = code;
    this.details = details;
    this.name = "ServerError";
    Object.defineProperty(this, "@@nice-grpc", {
      value: true
    });
    Object.defineProperty(this, "@@nice-grpc:ServerError", {
      value: true
    });
  }
  static [Symbol.hasInstance](instance) {
    if (this !== ServerError) {
      return this.prototype.isPrototypeOf(instance);
    }
    return typeof instance === "object" && instance !== null && (instance.constructor === ServerError || instance["@@nice-grpc:ServerError"] === true || instance.name === "ServerError" && instance["@@nice-grpc"] === true);
  }
}
ServerError$1.ServerError = ServerError;
(function(exports2) {
  var __createBinding2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m[k];
  });
  var __exportStar = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding2(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(Metadata, exports2);
  __exportStar(Status, exports2);
  __exportStar(MethodDescriptor, exports2);
  __exportStar(CallOptions, exports2);
  __exportStar(ClientMiddleware, exports2);
  __exportStar(composeClientMiddleware$1, exports2);
  __exportStar(ClientError$1, exports2);
  __exportStar(CallContext, exports2);
  __exportStar(ServerMiddleware, exports2);
  __exportStar(composeServerMiddleware$1, exports2);
  __exportStar(ServerError$1, exports2);
})(lib);
var serviceDefinitions = {};
var grpcWeb = {};
Object.defineProperty(grpcWeb, "__esModule", { value: true });
grpcWeb.isGrpcWebServiceDefinition = grpcWeb.fromGrpcWebServiceDefinition = void 0;
function fromGrpcWebServiceDefinition(definition) {
  const result = {};
  for (const [key, value] of Object.entries(definition)) {
    if (key === "serviceName") {
      continue;
    }
    const method = value;
    result[uncapitalize(key)] = {
      path: `/${definition.serviceName}/${key}`,
      requestStream: method.requestStream,
      responseStream: method.responseStream,
      requestDeserialize: method.requestType.deserializeBinary,
      requestSerialize: (value2) => value2.serializeBinary(),
      responseDeserialize: method.responseType.deserializeBinary,
      responseSerialize: (value2) => value2.serializeBinary(),
      options: {}
    };
  }
  return result;
}
grpcWeb.fromGrpcWebServiceDefinition = fromGrpcWebServiceDefinition;
function isGrpcWebServiceDefinition(definition) {
  return "prototype" in definition;
}
grpcWeb.isGrpcWebServiceDefinition = isGrpcWebServiceDefinition;
function uncapitalize(value) {
  if (value.length === 0) {
    return value;
  }
  return value[0].toLowerCase() + value.slice(1);
}
var tsProto = {};
Object.defineProperty(tsProto, "__esModule", { value: true });
tsProto.isTsProtoServiceDefinition = tsProto.fromTsProtoServiceDefinition = void 0;
function fromTsProtoServiceDefinition(definition) {
  const result = {};
  for (const [key, method] of Object.entries(definition.methods)) {
    const requestEncode = method.requestType.encode;
    const requestFromPartial = method.requestType.fromPartial;
    const responseEncode = method.responseType.encode;
    const responseFromPartial = method.responseType.fromPartial;
    result[key] = {
      path: `/${definition.fullName}/${method.name}`,
      requestStream: method.requestStream,
      responseStream: method.responseStream,
      requestDeserialize: method.requestType.decode,
      requestSerialize: requestFromPartial != null ? (value) => requestEncode(requestFromPartial(value)).finish() : (value) => requestEncode(value).finish(),
      responseDeserialize: method.responseType.decode,
      responseSerialize: responseFromPartial != null ? (value) => responseEncode(responseFromPartial(value)).finish() : (value) => responseEncode(value).finish(),
      options: method.options
    };
  }
  return result;
}
tsProto.fromTsProtoServiceDefinition = fromTsProtoServiceDefinition;
function isTsProtoServiceDefinition(definition) {
  return "name" in definition && "fullName" in definition && "methods" in definition;
}
tsProto.isTsProtoServiceDefinition = isTsProtoServiceDefinition;
Object.defineProperty(serviceDefinitions, "__esModule", { value: true });
serviceDefinitions.toGrpcWebMethodDefinition = serviceDefinitions.normalizeServiceDefinition = void 0;
const grpc_web_1$5 = grpcWeb;
const ts_proto_1 = tsProto;
function normalizeServiceDefinition(definition) {
  if ((0, grpc_web_1$5.isGrpcWebServiceDefinition)(definition)) {
    return (0, grpc_web_1$5.fromGrpcWebServiceDefinition)(definition);
  } else if ((0, ts_proto_1.isTsProtoServiceDefinition)(definition)) {
    return (0, ts_proto_1.fromTsProtoServiceDefinition)(definition);
  } else {
    return definition;
  }
}
serviceDefinitions.normalizeServiceDefinition = normalizeServiceDefinition;
function toGrpcWebMethodDefinition(definition) {
  const [, serviceName, methodName] = definition.path.split("/");
  return {
    service: {
      serviceName
    },
    methodName,
    requestStream: definition.requestStream,
    responseStream: definition.responseStream,
    requestType: class {
      constructor() {
        throw new Error("Unexpected instantiation");
      }
      static deserializeBinary(bytes) {
        return definition.requestDeserialize(bytes);
      }
    },
    responseType: class {
      constructor() {
        throw new Error("Unexpected instantiation");
      }
      static deserializeBinary(bytes) {
        return definition.responseDeserialize(bytes);
      }
    }
  };
}
serviceDefinitions.toGrpcWebMethodDefinition = toGrpcWebMethodDefinition;
var channel = {};
Object.defineProperty(channel, "__esModule", { value: true });
channel.createChannel = void 0;
function createChannel(address, transport) {
  return { address, transport };
}
channel.createChannel = createChannel;
var ClientFactory = {};
var createBidiStreamingMethod$1 = {};
var grpcWebClient_umd = { exports: {} };
(function(module2, exports2) {
  !function(e2, t2) {
    module2.exports = t2();
  }(commonjsGlobal$1, function() {
    return e2 = { 418: function(e3, t3) {
      !function(e4, t4) {
        for (var r2 in t4)
          e4[r2] = t4[r2];
      }(t3, function(e4) {
        var t4 = {};
        function r2(n2) {
          if (t4[n2])
            return t4[n2].exports;
          var o2 = t4[n2] = { i: n2, l: false, exports: {} };
          return e4[n2].call(o2.exports, o2, o2.exports, r2), o2.l = true, o2.exports;
        }
        return r2.m = e4, r2.c = t4, r2.i = function(e5) {
          return e5;
        }, r2.d = function(e5, t5, n2) {
          r2.o(e5, t5) || Object.defineProperty(e5, t5, { configurable: false, enumerable: true, get: n2 });
        }, r2.n = function(e5) {
          var t5 = e5 && e5.__esModule ? function() {
            return e5.default;
          } : function() {
            return e5;
          };
          return r2.d(t5, "a", t5), t5;
        }, r2.o = function(e5, t5) {
          return Object.prototype.hasOwnProperty.call(e5, t5);
        }, r2.p = "", r2(r2.s = 1);
      }([function(e4, t4, r2) {
        Object.defineProperty(t4, "__esModule", { value: true });
        var n2 = r2(3), o2 = function() {
          function e5(e6, t5) {
            void 0 === e6 && (e6 = {}), void 0 === t5 && (t5 = { splitValues: false });
            var r3, o3 = this;
            this.headersMap = {}, e6 && ("undefined" != typeof Headers && e6 instanceof Headers ? n2.getHeaderKeys(e6).forEach(function(r4) {
              n2.getHeaderValues(e6, r4).forEach(function(e7) {
                t5.splitValues ? o3.append(r4, n2.splitHeaderValue(e7)) : o3.append(r4, e7);
              });
            }) : "object" == typeof (r3 = e6) && "object" == typeof r3.headersMap && "function" == typeof r3.forEach ? e6.forEach(function(e7, t6) {
              o3.append(e7, t6);
            }) : "undefined" != typeof Map && e6 instanceof Map ? e6.forEach(function(e7, t6) {
              o3.append(t6, e7);
            }) : "string" == typeof e6 ? this.appendFromString(e6) : "object" == typeof e6 && Object.getOwnPropertyNames(e6).forEach(function(t6) {
              var r4 = e6[t6];
              Array.isArray(r4) ? r4.forEach(function(e7) {
                o3.append(t6, e7);
              }) : o3.append(t6, r4);
            }));
          }
          return e5.prototype.appendFromString = function(e6) {
            for (var t5 = e6.split("\r\n"), r3 = 0; r3 < t5.length; r3++) {
              var n3 = t5[r3], o3 = n3.indexOf(":");
              if (o3 > 0) {
                var s = n3.substring(0, o3).trim(), i2 = n3.substring(o3 + 1).trim();
                this.append(s, i2);
              }
            }
          }, e5.prototype.delete = function(e6, t5) {
            var r3 = n2.normalizeName(e6);
            if (void 0 === t5)
              delete this.headersMap[r3];
            else {
              var o3 = this.headersMap[r3];
              if (o3) {
                var s = o3.indexOf(t5);
                s >= 0 && o3.splice(s, 1), 0 === o3.length && delete this.headersMap[r3];
              }
            }
          }, e5.prototype.append = function(e6, t5) {
            var r3 = this, o3 = n2.normalizeName(e6);
            Array.isArray(this.headersMap[o3]) || (this.headersMap[o3] = []), Array.isArray(t5) ? t5.forEach(function(e7) {
              r3.headersMap[o3].push(n2.normalizeValue(e7));
            }) : this.headersMap[o3].push(n2.normalizeValue(t5));
          }, e5.prototype.set = function(e6, t5) {
            var r3 = n2.normalizeName(e6);
            if (Array.isArray(t5)) {
              var o3 = [];
              t5.forEach(function(e7) {
                o3.push(n2.normalizeValue(e7));
              }), this.headersMap[r3] = o3;
            } else
              this.headersMap[r3] = [n2.normalizeValue(t5)];
          }, e5.prototype.has = function(e6, t5) {
            var r3 = this.headersMap[n2.normalizeName(e6)];
            if (!Array.isArray(r3))
              return false;
            if (void 0 !== t5) {
              var o3 = n2.normalizeValue(t5);
              return r3.indexOf(o3) >= 0;
            }
            return true;
          }, e5.prototype.get = function(e6) {
            var t5 = this.headersMap[n2.normalizeName(e6)];
            return void 0 !== t5 ? t5.concat() : [];
          }, e5.prototype.forEach = function(e6) {
            var t5 = this;
            Object.getOwnPropertyNames(this.headersMap).forEach(function(r3) {
              e6(r3, t5.headersMap[r3]);
            }, this);
          }, e5.prototype.toHeaders = function() {
            if ("undefined" != typeof Headers) {
              var e6 = new Headers();
              return this.forEach(function(t5, r3) {
                r3.forEach(function(r4) {
                  e6.append(t5, r4);
                });
              }), e6;
            }
            throw new Error("Headers class is not defined");
          }, e5;
        }();
        t4.BrowserHeaders = o2;
      }, function(e4, t4, r2) {
        Object.defineProperty(t4, "__esModule", { value: true });
        var n2 = r2(0);
        t4.BrowserHeaders = n2.BrowserHeaders;
      }, function(e4, t4, r2) {
        Object.defineProperty(t4, "__esModule", { value: true }), t4.iterateHeaders = function(e5, t5) {
          for (var r3 = e5[Symbol.iterator](), n2 = r3.next(); !n2.done; )
            t5(n2.value[0]), n2 = r3.next();
        }, t4.iterateHeadersKeys = function(e5, t5) {
          for (var r3 = e5.keys(), n2 = r3.next(); !n2.done; )
            t5(n2.value), n2 = r3.next();
        };
      }, function(e4, t4, r2) {
        Object.defineProperty(t4, "__esModule", { value: true });
        var n2 = r2(2);
        t4.normalizeName = function(e5) {
          if ("string" != typeof e5 && (e5 = String(e5)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(e5))
            throw new TypeError("Invalid character in header field name");
          return e5.toLowerCase();
        }, t4.normalizeValue = function(e5) {
          return "string" != typeof e5 && (e5 = String(e5)), e5;
        }, t4.getHeaderValues = function(e5, t5) {
          var r3 = e5;
          if (r3 instanceof Headers && r3.getAll)
            return r3.getAll(t5);
          var n3 = r3.get(t5);
          return n3 && "string" == typeof n3 ? [n3] : n3;
        }, t4.getHeaderKeys = function(e5) {
          var t5 = e5, r3 = {}, o2 = [];
          return t5.keys ? n2.iterateHeadersKeys(t5, function(e6) {
            r3[e6] || (r3[e6] = true, o2.push(e6));
          }) : t5.forEach ? t5.forEach(function(e6, t6) {
            r3[t6] || (r3[t6] = true, o2.push(t6));
          }) : n2.iterateHeaders(t5, function(e6) {
            var t6 = e6[0];
            r3[t6] || (r3[t6] = true, o2.push(t6));
          }), o2;
        }, t4.splitHeaderValue = function(e5) {
          var t5 = [];
          return e5.split(", ").forEach(function(e6) {
            e6.split(",").forEach(function(e7) {
              t5.push(e7);
            });
          }), t5;
        };
      }]));
    }, 617: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.ChunkParser = t3.ChunkType = t3.encodeASCII = t3.decodeASCII = void 0;
      var n2, o2 = r2(65);
      function s(e4) {
        return 9 === (t4 = e4) || 10 === t4 || 13 === t4 || e4 >= 32 && e4 <= 126;
        var t4;
      }
      function i2(e4) {
        for (var t4 = 0; t4 !== e4.length; ++t4)
          if (!s(e4[t4]))
            throw new Error("Metadata is not valid (printable) ASCII");
        return String.fromCharCode.apply(String, Array.prototype.slice.call(e4));
      }
      function a(e4) {
        return 128 == (128 & e4.getUint8(0));
      }
      function u(e4) {
        return e4.getUint32(1, false);
      }
      function d(e4, t4, r3) {
        return e4.byteLength - t4 >= r3;
      }
      function c(e4, t4, r3) {
        if (e4.slice)
          return e4.slice(t4, r3);
        var n3 = e4.length;
        void 0 !== r3 && (n3 = r3);
        for (var o3 = new Uint8Array(n3 - t4), s2 = 0, i3 = t4; i3 < n3; i3++)
          o3[s2++] = e4[i3];
        return o3;
      }
      t3.decodeASCII = i2, t3.encodeASCII = function(e4) {
        for (var t4 = new Uint8Array(e4.length), r3 = 0; r3 !== e4.length; ++r3) {
          var n3 = e4.charCodeAt(r3);
          if (!s(n3))
            throw new Error("Metadata contains invalid ASCII");
          t4[r3] = n3;
        }
        return t4;
      }, function(e4) {
        e4[e4.MESSAGE = 1] = "MESSAGE", e4[e4.TRAILERS = 2] = "TRAILERS";
      }(n2 = t3.ChunkType || (t3.ChunkType = {}));
      var p = function() {
        function e4() {
          this.buffer = null, this.position = 0;
        }
        return e4.prototype.parse = function(e5, t4) {
          if (0 === e5.length && t4)
            return [];
          var r3, s2 = [];
          if (null == this.buffer)
            this.buffer = e5, this.position = 0;
          else if (this.position === this.buffer.byteLength)
            this.buffer = e5, this.position = 0;
          else {
            var p2 = this.buffer.byteLength - this.position, h = new Uint8Array(p2 + e5.byteLength), f2 = c(this.buffer, this.position);
            h.set(f2, 0);
            var l = new Uint8Array(e5);
            h.set(l, p2), this.buffer = h, this.position = 0;
          }
          for (; ; ) {
            if (!d(this.buffer, this.position, 5))
              return s2;
            var g = c(this.buffer, this.position, this.position + 5), b = new DataView(g.buffer, g.byteOffset, g.byteLength), y = u(b);
            if (!d(this.buffer, this.position, 5 + y))
              return s2;
            var v = c(this.buffer, this.position + 5, this.position + 5 + y);
            if (this.position += 5 + y, a(b))
              return s2.push({ chunkType: n2.TRAILERS, trailers: (r3 = v, new o2.Metadata(i2(r3))) }), s2;
            s2.push({ chunkType: n2.MESSAGE, data: v });
          }
        }, e4;
      }();
      t3.ChunkParser = p;
    }, 8: function(e3, t3) {
      var r2;
      Object.defineProperty(t3, "__esModule", { value: true }), t3.httpStatusToCode = t3.Code = void 0, function(e4) {
        e4[e4.OK = 0] = "OK", e4[e4.Canceled = 1] = "Canceled", e4[e4.Unknown = 2] = "Unknown", e4[e4.InvalidArgument = 3] = "InvalidArgument", e4[e4.DeadlineExceeded = 4] = "DeadlineExceeded", e4[e4.NotFound = 5] = "NotFound", e4[e4.AlreadyExists = 6] = "AlreadyExists", e4[e4.PermissionDenied = 7] = "PermissionDenied", e4[e4.ResourceExhausted = 8] = "ResourceExhausted", e4[e4.FailedPrecondition = 9] = "FailedPrecondition", e4[e4.Aborted = 10] = "Aborted", e4[e4.OutOfRange = 11] = "OutOfRange", e4[e4.Unimplemented = 12] = "Unimplemented", e4[e4.Internal = 13] = "Internal", e4[e4.Unavailable = 14] = "Unavailable", e4[e4.DataLoss = 15] = "DataLoss", e4[e4.Unauthenticated = 16] = "Unauthenticated";
      }(r2 = t3.Code || (t3.Code = {})), t3.httpStatusToCode = function(e4) {
        switch (e4) {
          case 0:
            return r2.Internal;
          case 200:
            return r2.OK;
          case 400:
            return r2.InvalidArgument;
          case 401:
            return r2.Unauthenticated;
          case 403:
            return r2.PermissionDenied;
          case 404:
            return r2.NotFound;
          case 409:
            return r2.Aborted;
          case 412:
            return r2.FailedPrecondition;
          case 429:
            return r2.ResourceExhausted;
          case 499:
            return r2.Canceled;
          case 500:
            return r2.Unknown;
          case 501:
            return r2.Unimplemented;
          case 503:
            return r2.Unavailable;
          case 504:
            return r2.DeadlineExceeded;
          default:
            return r2.Unknown;
        }
      };
    }, 934: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.client = void 0;
      var n2 = r2(65), o2 = r2(617), s = r2(8), i2 = r2(346), a = r2(57), u = r2(882);
      t3.client = function(e4, t4) {
        return new d(e4, t4);
      };
      var d = function() {
        function e4(e5, t4) {
          this.started = false, this.sentFirstMessage = false, this.completed = false, this.closed = false, this.finishedSending = false, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new o2.ChunkParser(), this.methodDefinition = e5, this.props = t4, this.createTransport();
        }
        return e4.prototype.createTransport = function() {
          var e5 = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName, t4 = { methodDefinition: this.methodDefinition, debug: this.props.debug || false, url: e5, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };
          this.props.transport ? this.transport = this.props.transport(t4) : this.transport = a.makeDefaultTransport(t4);
        }, e4.prototype.onTransportHeaders = function(e5, t4) {
          if (this.props.debug && i2.debug("onHeaders", e5, t4), this.closed)
            this.props.debug && i2.debug("grpc.onHeaders received after request was closed - ignoring");
          else if (0 === t4)
            ;
          else {
            this.responseHeaders = e5, this.props.debug && i2.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
            var r3 = c(e5);
            this.props.debug && i2.debug("onHeaders.gRPCStatus", r3);
            var n3 = r3 && r3 >= 0 ? r3 : s.httpStatusToCode(t4);
            this.props.debug && i2.debug("onHeaders.code", n3);
            var o3 = e5.get("grpc-message") || [];
            if (this.props.debug && i2.debug("onHeaders.gRPCMessage", o3), this.rawOnHeaders(e5), n3 !== s.Code.OK) {
              var a2 = this.decodeGRPCStatus(o3[0]);
              this.rawOnError(n3, a2, e5);
            }
          }
        }, e4.prototype.onTransportChunk = function(e5) {
          var t4 = this;
          if (this.closed)
            this.props.debug && i2.debug("grpc.onChunk received after request was closed - ignoring");
          else {
            var r3 = [];
            try {
              r3 = this.parser.parse(e5);
            } catch (e6) {
              return this.props.debug && i2.debug("onChunk.parsing error", e6, e6.message), void this.rawOnError(s.Code.Internal, "parsing error: " + e6.message);
            }
            r3.forEach(function(e6) {
              if (e6.chunkType === o2.ChunkType.MESSAGE) {
                var r4 = t4.methodDefinition.responseType.deserializeBinary(e6.data);
                t4.rawOnMessage(r4);
              } else
                e6.chunkType === o2.ChunkType.TRAILERS && (t4.responseHeaders ? (t4.responseTrailers = new n2.Metadata(e6.trailers), t4.props.debug && i2.debug("onChunk.trailers", t4.responseTrailers)) : (t4.responseHeaders = new n2.Metadata(e6.trailers), t4.rawOnHeaders(t4.responseHeaders)));
            });
          }
        }, e4.prototype.onTransportEnd = function() {
          if (this.props.debug && i2.debug("grpc.onEnd"), this.closed)
            this.props.debug && i2.debug("grpc.onEnd received after request was closed - ignoring");
          else if (void 0 !== this.responseTrailers) {
            var e5 = c(this.responseTrailers);
            if (null !== e5) {
              var t4 = this.responseTrailers.get("grpc-message"), r3 = this.decodeGRPCStatus(t4[0]);
              this.rawOnEnd(e5, r3, this.responseTrailers);
            } else
              this.rawOnError(s.Code.Internal, "Response closed without grpc-status (Trailers provided)");
          } else {
            if (void 0 === this.responseHeaders)
              return void this.rawOnError(s.Code.Unknown, "Response closed without headers");
            var n3 = c(this.responseHeaders), o3 = this.responseHeaders.get("grpc-message");
            if (this.props.debug && i2.debug("grpc.headers only response ", n3, o3), null === n3)
              return void this.rawOnEnd(s.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
            var a2 = this.decodeGRPCStatus(o3[0]);
            this.rawOnEnd(n3, a2, this.responseHeaders);
          }
        }, e4.prototype.decodeGRPCStatus = function(e5) {
          if (!e5)
            return "";
          try {
            return decodeURIComponent(e5);
          } catch (t4) {
            return e5;
          }
        }, e4.prototype.rawOnEnd = function(e5, t4, r3) {
          var n3 = this;
          this.props.debug && i2.debug("rawOnEnd", e5, t4, r3), this.completed || (this.completed = true, this.onEndCallbacks.forEach(function(o3) {
            if (!n3.closed)
              try {
                o3(e5, t4, r3);
              } catch (e6) {
                setTimeout(function() {
                  throw e6;
                }, 0);
              }
          }));
        }, e4.prototype.rawOnHeaders = function(e5) {
          this.props.debug && i2.debug("rawOnHeaders", e5), this.completed || this.onHeadersCallbacks.forEach(function(t4) {
            try {
              t4(e5);
            } catch (e6) {
              setTimeout(function() {
                throw e6;
              }, 0);
            }
          });
        }, e4.prototype.rawOnError = function(e5, t4, r3) {
          var o3 = this;
          void 0 === r3 && (r3 = new n2.Metadata()), this.props.debug && i2.debug("rawOnError", e5, t4), this.completed || (this.completed = true, this.onEndCallbacks.forEach(function(n3) {
            if (!o3.closed)
              try {
                n3(e5, t4, r3);
              } catch (e6) {
                setTimeout(function() {
                  throw e6;
                }, 0);
              }
          }));
        }, e4.prototype.rawOnMessage = function(e5) {
          var t4 = this;
          this.props.debug && i2.debug("rawOnMessage", e5.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach(function(r3) {
            if (!t4.closed)
              try {
                r3(e5);
              } catch (e6) {
                setTimeout(function() {
                  throw e6;
                }, 0);
              }
          });
        }, e4.prototype.onHeaders = function(e5) {
          this.onHeadersCallbacks.push(e5);
        }, e4.prototype.onMessage = function(e5) {
          this.onMessageCallbacks.push(e5);
        }, e4.prototype.onEnd = function(e5) {
          this.onEndCallbacks.push(e5);
        }, e4.prototype.start = function(e5) {
          if (this.started)
            throw new Error("Client already started - cannot .start()");
          this.started = true;
          var t4 = new n2.Metadata(e5 || {});
          t4.set("content-type", "application/grpc-web+proto"), t4.set("x-grpc-web", "1"), this.transport.start(t4);
        }, e4.prototype.send = function(e5) {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .send()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .send()");
          if (!this.methodDefinition.requestStream && this.sentFirstMessage)
            throw new Error("Message already sent for non-client-streaming method - cannot .send()");
          this.sentFirstMessage = true;
          var t4 = u.frameRequest(e5);
          this.transport.sendMessage(t4);
        }, e4.prototype.finishSend = function() {
          if (!this.started)
            throw new Error("Client not started - .finishSend() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .finishSend()");
          this.finishedSending = true, this.transport.finishSend();
        }, e4.prototype.close = function() {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .close()");
          this.closed = true, this.props.debug && i2.debug("request.abort aborting request"), this.transport.cancel();
        }, e4;
      }();
      function c(e4) {
        var t4 = e4.get("grpc-status") || [];
        if (t4.length > 0)
          try {
            var r3 = t4[0];
            return parseInt(r3, 10);
          } catch (e5) {
            return null;
          }
        return null;
      }
    }, 346: function(e3, t3) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.debug = void 0, t3.debug = function() {
        for (var e4 = [], t4 = 0; t4 < arguments.length; t4++)
          e4[t4] = arguments[t4];
        console.debug ? console.debug.apply(null, e4) : console.log.apply(null, e4);
      };
    }, 607: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.grpc = void 0;
      var n2, o2 = r2(418), s = r2(57), i2 = r2(229), a = r2(540), u = r2(210), d = r2(859), c = r2(8), p = r2(938), h = r2(35), f2 = r2(934);
      (n2 = t3.grpc || (t3.grpc = {})).setDefaultTransport = s.setDefaultTransportFactory, n2.CrossBrowserHttpTransport = d.CrossBrowserHttpTransport, n2.FetchReadableStreamTransport = i2.FetchReadableStreamTransport, n2.XhrTransport = u.XhrTransport, n2.WebsocketTransport = a.WebsocketTransport, n2.Code = c.Code, n2.Metadata = o2.BrowserHeaders, n2.client = function(e4, t4) {
        return f2.client(e4, t4);
      }, n2.invoke = p.invoke, n2.unary = h.unary;
    }, 938: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.invoke = void 0;
      var n2 = r2(934);
      t3.invoke = function(e4, t4) {
        if (e4.requestStream)
          throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
        var r3 = n2.client(e4, { host: t4.host, transport: t4.transport, debug: t4.debug });
        return t4.onHeaders && r3.onHeaders(t4.onHeaders), t4.onMessage && r3.onMessage(t4.onMessage), t4.onEnd && r3.onEnd(t4.onEnd), r3.start(t4.metadata), r3.send(t4.request), r3.finishSend(), { close: function() {
          r3.close();
        } };
      };
    }, 65: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.Metadata = void 0;
      var n2 = r2(418);
      Object.defineProperty(t3, "Metadata", { enumerable: true, get: function() {
        return n2.BrowserHeaders;
      } });
    }, 57: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.makeDefaultTransport = t3.setDefaultTransportFactory = void 0;
      var n2 = r2(859), o2 = function(e4) {
        return n2.CrossBrowserHttpTransport({ withCredentials: false })(e4);
      };
      t3.setDefaultTransportFactory = function(e4) {
        o2 = e4;
      }, t3.makeDefaultTransport = function(e4) {
        return o2(e4);
      };
    }, 229: function(e3, t3, r2) {
      var n2 = this && this.__assign || function() {
        return (n2 = Object.assign || function(e4) {
          for (var t4, r3 = 1, n3 = arguments.length; r3 < n3; r3++)
            for (var o3 in t4 = arguments[r3])
              Object.prototype.hasOwnProperty.call(t4, o3) && (e4[o3] = t4[o3]);
          return e4;
        }).apply(this, arguments);
      };
      Object.defineProperty(t3, "__esModule", { value: true }), t3.detectFetchSupport = t3.FetchReadableStreamTransport = void 0;
      var o2 = r2(65), s = r2(346);
      t3.FetchReadableStreamTransport = function(e4) {
        return function(t4) {
          return function(e5, t5) {
            return e5.debug && s.debug("fetchRequest", e5), new i2(e5, t5);
          }(t4, e4);
        };
      };
      var i2 = function() {
        function e4(e5, t4) {
          this.cancelled = false, this.controller = self.AbortController && new AbortController(), this.options = e5, this.init = t4;
        }
        return e4.prototype.pump = function(e5, t4) {
          var r3 = this;
          if (this.reader = e5, this.cancelled)
            return this.options.debug && s.debug("Fetch.pump.cancel at first pump"), void this.reader.cancel().catch(function(e6) {
              r3.options.debug && s.debug("Fetch.pump.reader.cancel exception", e6);
            });
          this.reader.read().then(function(e6) {
            if (e6.done)
              return r3.options.onEnd(), t4;
            r3.options.onChunk(e6.value), r3.pump(r3.reader, t4);
          }).catch(function(e6) {
            r3.cancelled ? r3.options.debug && s.debug("Fetch.catch - request cancelled") : (r3.cancelled = true, r3.options.debug && s.debug("Fetch.catch", e6.message), r3.options.onEnd(e6));
          });
        }, e4.prototype.send = function(e5) {
          var t4 = this;
          fetch(this.options.url, n2(n2({}, this.init), { headers: this.metadata.toHeaders(), method: "POST", body: e5, signal: this.controller && this.controller.signal })).then(function(e6) {
            if (t4.options.debug && s.debug("Fetch.response", e6), t4.options.onHeaders(new o2.Metadata(e6.headers), e6.status), !e6.body)
              return e6;
            t4.pump(e6.body.getReader(), e6);
          }).catch(function(e6) {
            t4.cancelled ? t4.options.debug && s.debug("Fetch.catch - request cancelled") : (t4.cancelled = true, t4.options.debug && s.debug("Fetch.catch", e6.message), t4.options.onEnd(e6));
          });
        }, e4.prototype.sendMessage = function(e5) {
          this.send(e5);
        }, e4.prototype.finishSend = function() {
        }, e4.prototype.start = function(e5) {
          this.metadata = e5;
        }, e4.prototype.cancel = function() {
          var e5 = this;
          this.cancelled ? this.options.debug && s.debug("Fetch.cancel already cancelled") : (this.cancelled = true, this.controller ? (this.options.debug && s.debug("Fetch.cancel.controller.abort"), this.controller.abort()) : this.options.debug && s.debug("Fetch.cancel.missing abort controller"), this.reader ? (this.options.debug && s.debug("Fetch.cancel.reader.cancel"), this.reader.cancel().catch(function(t4) {
            e5.options.debug && s.debug("Fetch.cancel.reader.cancel exception", t4);
          })) : this.options.debug && s.debug("Fetch.cancel before reader"));
        }, e4;
      }();
      t3.detectFetchSupport = function() {
        return "undefined" != typeof Response && Response.prototype.hasOwnProperty("body") && "function" == typeof Headers;
      };
    }, 859: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.CrossBrowserHttpTransport = void 0;
      var n2 = r2(229), o2 = r2(210);
      t3.CrossBrowserHttpTransport = function(e4) {
        if (n2.detectFetchSupport()) {
          var t4 = { credentials: e4.withCredentials ? "include" : "same-origin" };
          return n2.FetchReadableStreamTransport(t4);
        }
        return o2.XhrTransport({ withCredentials: e4.withCredentials });
      };
    }, 210: function(e3, t3, r2) {
      var n2, o2 = this && this.__extends || (n2 = function(e4, t4) {
        return (n2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e5, t5) {
          e5.__proto__ = t5;
        } || function(e5, t5) {
          for (var r3 in t5)
            Object.prototype.hasOwnProperty.call(t5, r3) && (e5[r3] = t5[r3]);
        })(e4, t4);
      }, function(e4, t4) {
        function r3() {
          this.constructor = e4;
        }
        n2(e4, t4), e4.prototype = null === t4 ? Object.create(t4) : (r3.prototype = t4.prototype, new r3());
      });
      Object.defineProperty(t3, "__esModule", { value: true }), t3.stringToArrayBuffer = t3.MozChunkedArrayBufferXHR = t3.XHR = t3.XhrTransport = void 0;
      var s = r2(65), i2 = r2(346), a = r2(849);
      t3.XhrTransport = function(e4) {
        return function(t4) {
          if (a.detectMozXHRSupport())
            return new d(t4, e4);
          if (a.detectXHROverrideMimeTypeSupport())
            return new u(t4, e4);
          throw new Error("This environment's XHR implementation cannot support binary transfer.");
        };
      };
      var u = function() {
        function e4(e5, t4) {
          this.options = e5, this.init = t4;
        }
        return e4.prototype.onProgressEvent = function() {
          this.options.debug && i2.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
          var e5 = this.xhr.response.substr(this.index);
          this.index = this.xhr.response.length;
          var t4 = p(e5);
          this.options.onChunk(t4);
        }, e4.prototype.onLoadEvent = function() {
          this.options.debug && i2.debug("XHR.onLoadEvent"), this.options.onEnd();
        }, e4.prototype.onStateChange = function() {
          this.options.debug && i2.debug("XHR.onStateChange", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new s.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);
        }, e4.prototype.sendMessage = function(e5) {
          this.xhr.send(e5);
        }, e4.prototype.finishSend = function() {
        }, e4.prototype.start = function(e5) {
          var t4 = this;
          this.metadata = e5;
          var r3 = new XMLHttpRequest();
          this.xhr = r3, r3.open("POST", this.options.url), this.configureXhr(), this.metadata.forEach(function(e6, t5) {
            r3.setRequestHeader(e6, t5.join(", "));
          }), r3.withCredentials = Boolean(this.init.withCredentials), r3.addEventListener("readystatechange", this.onStateChange.bind(this)), r3.addEventListener("progress", this.onProgressEvent.bind(this)), r3.addEventListener("loadend", this.onLoadEvent.bind(this)), r3.addEventListener("error", function(e6) {
            t4.options.debug && i2.debug("XHR.error", e6), t4.options.onEnd(e6.error);
          });
        }, e4.prototype.configureXhr = function() {
          this.xhr.responseType = "text", this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }, e4.prototype.cancel = function() {
          this.options.debug && i2.debug("XHR.abort"), this.xhr.abort();
        }, e4;
      }();
      t3.XHR = u;
      var d = function(e4) {
        function t4() {
          return null !== e4 && e4.apply(this, arguments) || this;
        }
        return o2(t4, e4), t4.prototype.configureXhr = function() {
          this.options.debug && i2.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"), this.xhr.responseType = "moz-chunked-arraybuffer";
        }, t4.prototype.onProgressEvent = function() {
          var e5 = this.xhr.response;
          this.options.debug && i2.debug("MozXHR.onProgressEvent: ", new Uint8Array(e5)), this.options.onChunk(new Uint8Array(e5));
        }, t4;
      }(u);
      function c(e4, t4) {
        var r3 = e4.charCodeAt(t4);
        if (r3 >= 55296 && r3 <= 56319) {
          var n3 = e4.charCodeAt(t4 + 1);
          n3 >= 56320 && n3 <= 57343 && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320));
        }
        return r3;
      }
      function p(e4) {
        for (var t4 = new Uint8Array(e4.length), r3 = 0, n3 = 0; n3 < e4.length; n3++) {
          var o3 = String.prototype.codePointAt ? e4.codePointAt(n3) : c(e4, n3);
          t4[r3++] = 255 & o3;
        }
        return t4;
      }
      t3.MozChunkedArrayBufferXHR = d, t3.stringToArrayBuffer = p;
    }, 849: function(e3, t3) {
      var r2;
      function n2() {
        if (void 0 !== r2)
          return r2;
        if (XMLHttpRequest) {
          r2 = new XMLHttpRequest();
          try {
            r2.open("GET", "https://localhost");
          } catch (e4) {
          }
        }
        return r2;
      }
      function o2(e4) {
        var t4 = n2();
        if (!t4)
          return false;
        try {
          return t4.responseType = e4, t4.responseType === e4;
        } catch (e5) {
        }
        return false;
      }
      Object.defineProperty(t3, "__esModule", { value: true }), t3.detectXHROverrideMimeTypeSupport = t3.detectMozXHRSupport = t3.xhrSupportsResponseType = void 0, t3.xhrSupportsResponseType = o2, t3.detectMozXHRSupport = function() {
        return "undefined" != typeof XMLHttpRequest && o2("moz-chunked-arraybuffer");
      }, t3.detectXHROverrideMimeTypeSupport = function() {
        return "undefined" != typeof XMLHttpRequest && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
      };
    }, 540: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.WebsocketTransport = void 0;
      var n2, o2 = r2(346), s = r2(617);
      !function(e4) {
        e4[e4.FINISH_SEND = 1] = "FINISH_SEND";
      }(n2 || (n2 = {}));
      var i2 = new Uint8Array([1]);
      t3.WebsocketTransport = function() {
        return function(e4) {
          return function(e5) {
            e5.debug && o2.debug("websocketRequest", e5);
            var t4, r3 = function(e6) {
              if ("https://" === e6.substr(0, 8))
                return "wss://" + e6.substr(8);
              if ("http://" === e6.substr(0, 7))
                return "ws://" + e6.substr(7);
              throw new Error("Websocket transport constructed with non-https:// or http:// host.");
            }(e5.url), a = [];
            function u(e6) {
              if (e6 === n2.FINISH_SEND)
                t4.send(i2);
              else {
                var r4 = e6, o3 = new Int8Array(r4.byteLength + 1);
                o3.set(new Uint8Array([0])), o3.set(r4, 1), t4.send(o3);
              }
            }
            return { sendMessage: function(e6) {
              t4 && t4.readyState !== t4.CONNECTING ? u(e6) : a.push(e6);
            }, finishSend: function() {
              t4 && t4.readyState !== t4.CONNECTING ? u(n2.FINISH_SEND) : a.push(n2.FINISH_SEND);
            }, start: function(n3) {
              (t4 = new WebSocket(r3, ["grpc-websockets"])).binaryType = "arraybuffer", t4.onopen = function() {
                var r4;
                e5.debug && o2.debug("websocketRequest.onopen"), t4.send((r4 = "", n3.forEach(function(e6, t5) {
                  r4 += e6 + ": " + t5.join(", ") + "\r\n";
                }), s.encodeASCII(r4))), a.forEach(function(e6) {
                  u(e6);
                });
              }, t4.onclose = function(t5) {
                e5.debug && o2.debug("websocketRequest.onclose", t5), e5.onEnd();
              }, t4.onerror = function(t5) {
                e5.debug && o2.debug("websocketRequest.onerror", t5);
              }, t4.onmessage = function(t5) {
                e5.onChunk(new Uint8Array(t5.data));
              };
            }, cancel: function() {
              e5.debug && o2.debug("websocket.abort"), t4.close();
            } };
          }(e4);
        };
      };
    }, 35: function(e3, t3, r2) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.unary = void 0;
      var n2 = r2(65), o2 = r2(934);
      t3.unary = function(e4, t4) {
        if (e4.responseStream)
          throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
        if (e4.requestStream)
          throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
        var r3 = null, s = null, i2 = o2.client(e4, { host: t4.host, transport: t4.transport, debug: t4.debug });
        return i2.onHeaders(function(e5) {
          r3 = e5;
        }), i2.onMessage(function(e5) {
          s = e5;
        }), i2.onEnd(function(e5, o3, i3) {
          t4.onEnd({ status: e5, statusMessage: o3, headers: r3 || new n2.Metadata(), message: s, trailers: i3 });
        }), i2.start(t4.metadata), i2.send(t4.request), i2.finishSend(), { close: function() {
          i2.close();
        } };
      };
    }, 882: function(e3, t3) {
      Object.defineProperty(t3, "__esModule", { value: true }), t3.frameRequest = void 0, t3.frameRequest = function(e4) {
        var t4 = e4.serializeBinary(), r2 = new ArrayBuffer(t4.byteLength + 5);
        return new DataView(r2, 1, 4).setUint32(0, t4.length, false), new Uint8Array(r2, 5).set(t4), new Uint8Array(r2);
      };
    } }, t2 = {}, function r2(n2) {
      if (t2[n2])
        return t2[n2].exports;
      var o2 = t2[n2] = { exports: {} };
      return e2[n2].call(o2.exports, o2, o2.exports, r2), o2.exports;
    }(607);
    var e2, t2;
  });
})(grpcWebClient_umd);
class AbortError extends Error {
  constructor() {
    super("The operation has been aborted");
    this.message = "The operation has been aborted";
    this.name = "AbortError";
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}
function isAbortError(error) {
  return typeof error === "object" && error !== null && error.name === "AbortError";
}
function throwIfAborted(signal) {
  if (signal.aborted) {
    throw new AbortError();
  }
}
function rethrowAbortError(error) {
  if (isAbortError(error)) {
    throw error;
  }
  return;
}
function catchAbortError(error) {
  if (isAbortError(error)) {
    return;
  }
  throw error;
}
function execute(signal, executor) {
  return new Promise((resolve, reject) => {
    if (signal.aborted) {
      reject(new AbortError());
      return;
    }
    let removeAbortListener;
    let finished = false;
    function finish3() {
      if (!finished) {
        finished = true;
        if (removeAbortListener != null) {
          removeAbortListener();
        }
      }
    }
    const callback = executor((value) => {
      resolve(value);
      finish3();
    }, (reason) => {
      reject(reason);
      finish3();
    });
    if (!finished) {
      const listener = () => {
        const callbackResult = callback();
        if (callbackResult == null) {
          reject(new AbortError());
        } else {
          callbackResult.then(() => {
            reject(new AbortError());
          }, (reason) => {
            reject(reason);
          });
        }
        finish3();
      };
      signal.addEventListener("abort", listener);
      removeAbortListener = () => {
        signal.removeEventListener("abort", listener);
      };
    }
  });
}
function abortable(signal, promise) {
  if (signal.aborted) {
    const noop2 = () => {
    };
    promise.then(noop2, noop2);
  }
  return execute(signal, (resolve, reject) => {
    promise.then(resolve, reject);
    return () => {
    };
  });
}
function delay$1(signal, dueTime) {
  return execute(signal, (resolve) => {
    const ms = typeof dueTime === "number" ? dueTime : dueTime.getTime() - Date.now();
    const timer2 = setTimeout(resolve, ms);
    return () => {
      clearTimeout(timer2);
    };
  });
}
function forever(signal) {
  return execute(signal, () => () => {
  });
}
function waitForEvent(signal, target, eventName, options) {
  return execute(signal, (resolve) => {
    let unlisten;
    let finished = false;
    const handler = (...args) => {
      resolve(args.length > 1 ? args : args[0]);
      finished = true;
      if (unlisten != null) {
        unlisten();
      }
    };
    unlisten = listen(target, eventName, handler, options);
    if (finished) {
      unlisten();
    }
    return () => {
      finished = true;
      if (unlisten != null) {
        unlisten();
      }
    };
  });
}
function listen(target, eventName, handler, options) {
  if (isEventTarget(target)) {
    target.addEventListener(eventName, handler, options);
    return () => target.removeEventListener(eventName, handler, options);
  }
  if (isJQueryStyleEventEmitter(target)) {
    target.on(eventName, handler);
    return () => target.off(eventName, handler);
  }
  if (isNodeStyleEventEmitter(target)) {
    target.addListener(eventName, handler);
    return () => target.removeListener(eventName, handler);
  }
  throw new Error("Invalid event target");
}
function isNodeStyleEventEmitter(sourceObj) {
  return isFunction$2(sourceObj.addListener) && isFunction$2(sourceObj.removeListener);
}
function isJQueryStyleEventEmitter(sourceObj) {
  return isFunction$2(sourceObj.on) && isFunction$2(sourceObj.off);
}
function isEventTarget(sourceObj) {
  return isFunction$2(sourceObj.addEventListener) && isFunction$2(sourceObj.removeEventListener);
}
const isFunction$2 = (obj) => typeof obj === "function";
var browser$3 = { exports: {} };
const _global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : void 0;
if (!_global) {
  throw new Error(`Unable to find global scope. Are you sure this is running in the browser?`);
}
if (!_global.AbortController) {
  throw new Error(`Could not find "AbortController" in the global scope. You need to polyfill it first`);
}
browser$3.exports = _global.AbortController;
browser$3.exports.default = _global.AbortController;
var AbortController$1 = browser$3.exports;
function all(signal, executor) {
  return new Promise((resolve, reject) => {
    if (signal.aborted) {
      reject(new AbortError());
      return;
    }
    const innerAbortController = new AbortController$1();
    const promises = executor(innerAbortController.signal);
    if (promises.length === 0) {
      resolve([]);
      return;
    }
    const abortListener = () => {
      innerAbortController.abort();
    };
    signal.addEventListener("abort", abortListener);
    let rejection;
    const results = new Array(promises.length);
    let settledCount = 0;
    function settled() {
      settledCount += 1;
      if (settledCount === promises.length) {
        signal.removeEventListener("abort", abortListener);
        if (rejection != null) {
          reject(rejection.reason);
        } else {
          resolve(results);
        }
      }
    }
    for (const [i2, promise] of promises.entries()) {
      promise.then((value) => {
        results[i2] = value;
        settled();
      }, (reason) => {
        innerAbortController.abort();
        if (rejection == null || !isAbortError(reason) && isAbortError(rejection.reason)) {
          rejection = { reason };
        }
        settled();
      });
    }
  });
}
function race$2(signal, executor) {
  return new Promise((resolve, reject) => {
    if (signal.aborted) {
      reject(new AbortError());
      return;
    }
    const innerAbortController = new AbortController$1();
    const promises = executor(innerAbortController.signal);
    const abortListener = () => {
      innerAbortController.abort();
    };
    signal.addEventListener("abort", abortListener);
    let settledCount = 0;
    function settled(result2) {
      innerAbortController.abort();
      settledCount += 1;
      if (settledCount === promises.length) {
        signal.removeEventListener("abort", abortListener);
        if (result2.status === "fulfilled") {
          resolve(result2.value);
        } else {
          reject(result2.reason);
        }
      }
    }
    let result;
    for (const promise of promises) {
      promise.then((value) => {
        if (result == null) {
          result = { status: "fulfilled", value };
        }
        settled(result);
      }, (reason) => {
        if (result == null || !isAbortError(reason) && (result.status === "fulfilled" || isAbortError(result.reason))) {
          result = { status: "rejected", reason };
        }
        settled(result);
      });
    }
  });
}
async function retry$1(signal, fn, options = {}) {
  const { baseMs = 1e3, maxDelayMs = 15e3, onError, maxAttempts = Infinity } = options;
  let attempt = 0;
  const reset3 = () => {
    attempt = -1;
  };
  while (true) {
    try {
      return await fn(signal, attempt, reset3);
    } catch (error) {
      rethrowAbortError(error);
      if (attempt >= maxAttempts) {
        throw error;
      }
      let delayMs;
      if (attempt === -1) {
        delayMs = 0;
      } else {
        const backoff = Math.min(maxDelayMs, Math.pow(2, attempt) * baseMs);
        delayMs = Math.round(backoff * (1 + Math.random()) / 2);
      }
      if (onError) {
        onError(error, attempt, delayMs);
      }
      if (delayMs !== 0) {
        await delay$1(signal, delayMs);
      }
      attempt += 1;
    }
  }
}
function spawn(signal, fn) {
  if (signal.aborted) {
    return Promise.reject(new AbortError());
  }
  const deferredFunctions = [];
  const spawnAbortController = new AbortController$1();
  const spawnSignal = spawnAbortController.signal;
  const abortSpawn = () => {
    spawnAbortController.abort();
  };
  signal.addEventListener("abort", abortSpawn);
  const removeAbortListener = () => {
    signal.removeEventListener("abort", abortSpawn);
  };
  const tasks = /* @__PURE__ */ new Set();
  const abortTasks = () => {
    for (const task of tasks) {
      task.abort();
    }
  };
  spawnSignal.addEventListener("abort", abortTasks);
  const removeSpawnAbortListener = () => {
    spawnSignal.removeEventListener("abort", abortTasks);
  };
  let promise = new Promise((resolve, reject) => {
    let result;
    let failure;
    fork3((signal2) => fn(signal2, {
      defer(fn2) {
        deferredFunctions.push(fn2);
      },
      fork: fork3
    })).join().then((value) => {
      spawnAbortController.abort();
      result = { value };
    }, (error) => {
      spawnAbortController.abort();
      if (!isAbortError(error) || failure == null) {
        failure = { error };
      }
    });
    function fork3(forkFn) {
      if (spawnSignal.aborted) {
        return {
          abort() {
          },
          async join() {
            throw new AbortError();
          }
        };
      }
      const taskAbortController = new AbortController$1();
      const taskSignal = taskAbortController.signal;
      const taskPromise = forkFn(taskSignal);
      const task = {
        abort() {
          taskAbortController.abort();
        },
        join: () => taskPromise
      };
      tasks.add(task);
      taskPromise.catch(catchAbortError).catch((error) => {
        failure = { error };
        spawnAbortController.abort();
      }).finally(() => {
        tasks.delete(task);
        if (tasks.size === 0) {
          if (failure != null) {
            reject(failure.error);
          } else {
            resolve(result.value);
          }
        }
      });
      return task;
    }
  });
  promise = promise.finally(() => {
    removeAbortListener();
    removeSpawnAbortListener();
    let deferPromise = Promise.resolve();
    for (let i2 = deferredFunctions.length - 1; i2 >= 0; i2--) {
      deferPromise = deferPromise.finally(deferredFunctions[i2]);
    }
    return deferPromise;
  });
  return promise;
}
function run(fn) {
  const abortController = new AbortController$1();
  const promise = fn(abortController.signal).catch(catchAbortError);
  return () => {
    abortController.abort();
    return promise;
  };
}
var es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  abortable,
  AbortError,
  isAbortError,
  throwIfAborted,
  rethrowAbortError,
  catchAbortError,
  delay: delay$1,
  execute,
  forever,
  waitForEvent,
  all,
  race: race$2,
  retry: retry$1,
  spawn,
  run
}, Symbol.toStringTag, { value: "Module" }));
var require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(es);
var AsyncSink$1 = {};
Object.defineProperty(AsyncSink$1, "__esModule", { value: true });
AsyncSink$1.AsyncSink = void 0;
const ARRAY_VALUE = "value";
const ARRAY_ERROR = "error";
class AsyncSink {
  constructor() {
    this._ended = false;
    this._values = [];
    this._resolvers = [];
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  write(value) {
    this._push({ type: ARRAY_VALUE, value });
  }
  error(error) {
    this._push({ type: ARRAY_ERROR, error });
  }
  _push(item) {
    if (this._ended) {
      throw new Error("AsyncSink already ended");
    }
    if (this._resolvers.length > 0) {
      const { resolve, reject } = this._resolvers.shift();
      if (item.type === ARRAY_ERROR) {
        reject(item.error);
      } else {
        resolve({ done: false, value: item.value });
      }
    } else {
      this._values.push(item);
    }
  }
  next() {
    if (this._values.length > 0) {
      const { type, value, error } = this._values.shift();
      if (type === ARRAY_ERROR) {
        return Promise.reject(error);
      } else {
        return Promise.resolve({ done: false, value });
      }
    }
    if (this._ended) {
      return Promise.resolve({ done: true });
    }
    return new Promise((resolve, reject) => {
      this._resolvers.push({ resolve, reject });
    });
  }
  end() {
    while (this._resolvers.length > 0) {
      this._resolvers.shift().resolve({ done: true });
    }
    this._ended = true;
  }
}
AsyncSink$1.AsyncSink = AsyncSink;
var isAsyncIterable$1 = {};
Object.defineProperty(isAsyncIterable$1, "__esModule", { value: true });
isAsyncIterable$1.isAsyncIterable = void 0;
function isAsyncIterable(value) {
  return value != null && Symbol.asyncIterator in value;
}
isAsyncIterable$1.isAsyncIterable = isAsyncIterable;
var convertMetadata = {};
var base64$4 = { exports: {} };
(function(module2, exports2) {
  (function(global2, factory2) {
    module2.exports = factory2();
  })(typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof commonjsGlobal$1 !== "undefined" ? commonjsGlobal$1 : commonjsGlobal$1, function() {
    var version2 = "3.7.2";
    var VERSION = version2;
    var _hasatob = typeof atob === "function";
    var _hasbtoa = typeof btoa === "function";
    var _hasBuffer = typeof Buffer === "function";
    var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
    var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
    var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var b64chs = Array.prototype.slice.call(b64ch);
    var b64tab = function(a) {
      var tab = {};
      a.forEach(function(c, i2) {
        return tab[c] = i2;
      });
      return tab;
    }(b64chs);
    var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
    var _fromCC = String.fromCharCode.bind(String);
    var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : function(it, fn) {
      if (fn === void 0) {
        fn = function(x) {
          return x;
        };
      }
      return new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
    };
    var _mkUriSafe = function(src) {
      return src.replace(/=/g, "").replace(/[+\/]/g, function(m0) {
        return m0 == "+" ? "-" : "_";
      });
    };
    var _tidyB64 = function(s) {
      return s.replace(/[^A-Za-z0-9\+\/]/g, "");
    };
    var btoaPolyfill = function(bin) {
      var u32, c0, c1, c2, asc = "";
      var pad = bin.length % 3;
      for (var i2 = 0; i2 < bin.length; ) {
        if ((c0 = bin.charCodeAt(i2++)) > 255 || (c1 = bin.charCodeAt(i2++)) > 255 || (c2 = bin.charCodeAt(i2++)) > 255)
          throw new TypeError("invalid character found");
        u32 = c0 << 16 | c1 << 8 | c2;
        asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
      }
      return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
    };
    var _btoa = _hasbtoa ? function(bin) {
      return btoa(bin);
    } : _hasBuffer ? function(bin) {
      return Buffer.from(bin, "binary").toString("base64");
    } : btoaPolyfill;
    var _fromUint8Array = _hasBuffer ? function(u8a) {
      return Buffer.from(u8a).toString("base64");
    } : function(u8a) {
      var maxargs = 4096;
      var strs = [];
      for (var i2 = 0, l = u8a.length; i2 < l; i2 += maxargs) {
        strs.push(_fromCC.apply(null, u8a.subarray(i2, i2 + maxargs)));
      }
      return _btoa(strs.join(""));
    };
    var fromUint8Array = function(u8a, urlsafe) {
      if (urlsafe === void 0) {
        urlsafe = false;
      }
      return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
    };
    var cb_utob = function(c) {
      if (c.length < 2) {
        var cc = c.charCodeAt(0);
        return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
      } else {
        var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
        return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
      }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
      return u.replace(re_utob, cb_utob);
    };
    var _encode = _hasBuffer ? function(s) {
      return Buffer.from(s, "utf8").toString("base64");
    } : _TE ? function(s) {
      return _fromUint8Array(_TE.encode(s));
    } : function(s) {
      return _btoa(utob(s));
    };
    var encode2 = function(src, urlsafe) {
      if (urlsafe === void 0) {
        urlsafe = false;
      }
      return urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
    };
    var encodeURI = function(src) {
      return encode2(src, true);
    };
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function(cccc) {
      switch (cccc.length) {
        case 4:
          var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
          return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
        case 3:
          return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
        default:
          return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
      }
    };
    var btou = function(b) {
      return b.replace(re_btou, cb_btou);
    };
    var atobPolyfill = function(asc) {
      asc = asc.replace(/\s+/g, "");
      if (!b64re.test(asc))
        throw new TypeError("malformed base64.");
      asc += "==".slice(2 - (asc.length & 3));
      var u24, bin = "", r1, r2;
      for (var i2 = 0; i2 < asc.length; ) {
        u24 = b64tab[asc.charAt(i2++)] << 18 | b64tab[asc.charAt(i2++)] << 12 | (r1 = b64tab[asc.charAt(i2++)]) << 6 | (r2 = b64tab[asc.charAt(i2++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
      }
      return bin;
    };
    var _atob = _hasatob ? function(asc) {
      return atob(_tidyB64(asc));
    } : _hasBuffer ? function(asc) {
      return Buffer.from(asc, "base64").toString("binary");
    } : atobPolyfill;
    var _toUint8Array = _hasBuffer ? function(a) {
      return _U8Afrom(Buffer.from(a, "base64"));
    } : function(a) {
      return _U8Afrom(_atob(a), function(c) {
        return c.charCodeAt(0);
      });
    };
    var toUint8Array = function(a) {
      return _toUint8Array(_unURI(a));
    };
    var _decode = _hasBuffer ? function(a) {
      return Buffer.from(a, "base64").toString("utf8");
    } : _TD ? function(a) {
      return _TD.decode(_toUint8Array(a));
    } : function(a) {
      return btou(_atob(a));
    };
    var _unURI = function(a) {
      return _tidyB64(a.replace(/[-_]/g, function(m0) {
        return m0 == "-" ? "+" : "/";
      }));
    };
    var decode = function(src) {
      return _decode(_unURI(src));
    };
    var isValid = function(src) {
      if (typeof src !== "string")
        return false;
      var s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
      return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
    };
    var _noEnum = function(v) {
      return {
        value: v,
        enumerable: false,
        writable: true,
        configurable: true
      };
    };
    var extendString = function() {
      var _add = function(name2, body) {
        return Object.defineProperty(String.prototype, name2, _noEnum(body));
      };
      _add("fromBase64", function() {
        return decode(this);
      });
      _add("toBase64", function(urlsafe) {
        return encode2(this, urlsafe);
      });
      _add("toBase64URI", function() {
        return encode2(this, true);
      });
      _add("toBase64URL", function() {
        return encode2(this, true);
      });
      _add("toUint8Array", function() {
        return toUint8Array(this);
      });
    };
    var extendUint8Array = function() {
      var _add = function(name2, body) {
        return Object.defineProperty(Uint8Array.prototype, name2, _noEnum(body));
      };
      _add("toBase64", function(urlsafe) {
        return fromUint8Array(this, urlsafe);
      });
      _add("toBase64URI", function() {
        return fromUint8Array(this, true);
      });
      _add("toBase64URL", function() {
        return fromUint8Array(this, true);
      });
    };
    var extendBuiltins = function() {
      extendString();
      extendUint8Array();
    };
    var gBase64 = {
      version: version2,
      VERSION,
      atob: _atob,
      atobPolyfill,
      btoa: _btoa,
      btoaPolyfill,
      fromBase64: decode,
      toBase64: encode2,
      encode: encode2,
      encodeURI,
      encodeURL: encodeURI,
      utob,
      btou,
      decode,
      isValid,
      fromUint8Array,
      toUint8Array,
      extendString,
      extendUint8Array,
      extendBuiltins
    };
    gBase64.Base64 = {};
    Object.keys(gBase64).forEach(function(k) {
      return gBase64.Base64[k] = gBase64[k];
    });
    return gBase64;
  });
})(base64$4);
Object.defineProperty(convertMetadata, "__esModule", { value: true });
convertMetadata.convertMetadataFromGrpcWeb = convertMetadata.convertMetadataToGrpcWeb = void 0;
const grpc_web_1$4 = grpcWebClient_umd.exports;
const nice_grpc_common_1$5 = lib;
const js_base64_1 = base64$4.exports;
function convertMetadataToGrpcWeb(metadata) {
  const grpcMetadata = new grpc_web_1$4.grpc.Metadata();
  for (const [key, values2] of metadata) {
    for (const value of values2) {
      grpcMetadata.append(key, typeof value === "string" ? value : js_base64_1.Base64.fromUint8Array(value));
    }
  }
  return grpcMetadata;
}
convertMetadata.convertMetadataToGrpcWeb = convertMetadataToGrpcWeb;
function convertMetadataFromGrpcWeb(grpcMetadata) {
  const metadata = (0, nice_grpc_common_1$5.Metadata)();
  for (const [key, values2] of Object.entries(grpcMetadata.headersMap)) {
    metadata.set(key, key.endsWith("-bin") ? values2.map((value) => js_base64_1.Base64.toUint8Array(value)) : values2);
  }
  return metadata;
}
convertMetadata.convertMetadataFromGrpcWeb = convertMetadataFromGrpcWeb;
var __importDefault$9 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(createBidiStreamingMethod$1, "__esModule", { value: true });
createBidiStreamingMethod$1.createBidiStreamingMethod = void 0;
const nice_grpc_common_1$4 = lib;
const grpc_web_1$3 = grpcWebClient_umd.exports;
const abort_controller_x_1$4 = require$$1$1;
const node_abort_controller_1$3 = __importDefault$9(browser$3.exports);
const AsyncSink_1$1 = AsyncSink$1;
const service_definitions_1$4 = serviceDefinitions;
const isAsyncIterable_1$3 = isAsyncIterable$1;
const convertMetadata_1$3 = convertMetadata;
function createBidiStreamingMethod(definition, channel2, middleware, defaultOptions) {
  const grpcMethodDefinition = (0, service_definitions_1$4.toGrpcWebMethodDefinition)(definition);
  const methodDescriptor = {
    path: definition.path,
    requestStream: definition.requestStream,
    responseStream: definition.responseStream,
    options: definition.options
  };
  async function* bidiStreamingMethod(request3, options) {
    if (!(0, isAsyncIterable_1$3.isAsyncIterable)(request3)) {
      throw new Error("A middleware passed invalid request to next(): expected a single message for bidirectional streaming method");
    }
    const { metadata = (0, nice_grpc_common_1$4.Metadata)(), signal = new node_abort_controller_1$3.default().signal, onHeader, onTrailer } = options;
    const pipeAbortController = new node_abort_controller_1$3.default();
    const sink = new AsyncSink_1$1.AsyncSink();
    const client = grpc_web_1$3.grpc.client(grpcMethodDefinition, {
      host: channel2.address,
      transport: channel2.transport
    });
    client.onHeaders((headers) => {
      onHeader === null || onHeader === void 0 ? void 0 : onHeader((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(headers));
    });
    client.onMessage((message) => {
      sink.write(message);
    });
    client.onEnd((code, message, trailers) => {
      onTrailer === null || onTrailer === void 0 ? void 0 : onTrailer((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(trailers));
      if (code === grpc_web_1$3.grpc.Code.OK) {
        sink.end();
      } else {
        sink.error(new nice_grpc_common_1$4.ClientError(definition.path, +code, message));
      }
    });
    client.start((0, convertMetadata_1$3.convertMetadataToGrpcWeb)(metadata));
    let pipeError;
    pipeRequest$1(pipeAbortController.signal, request3, client, definition).then(() => {
      client.finishSend();
    }, (err) => {
      if (!(0, abort_controller_x_1$4.isAbortError)(err)) {
        pipeError = err;
        client.close();
        sink.end();
      }
    });
    const abortListener = () => {
      sink.error(new abort_controller_x_1$4.AbortError());
      pipeAbortController.abort();
      client.close();
    };
    signal.addEventListener("abort", abortListener);
    try {
      yield* sink;
    } finally {
      pipeAbortController.abort();
      signal.removeEventListener("abort", abortListener);
      (0, abort_controller_x_1$4.throwIfAborted)(signal);
      if (pipeError) {
        throw pipeError;
      }
    }
  }
  const method = middleware == null ? bidiStreamingMethod : (request3, options) => middleware({
    method: methodDescriptor,
    requestStream: true,
    request: request3,
    responseStream: true,
    next: bidiStreamingMethod
  }, options);
  return (request3, options) => {
    const iterable = method(request3, {
      ...defaultOptions,
      ...options
    });
    const iterator2 = iterable[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const result = await iterator2.next();
            if (result.done && result.value != null) {
              return await iterator2.throw(new Error("A middleware returned a message, but expected to return void for bidirectional streaming method"));
            }
            return result;
          },
          return() {
            return iterator2.return();
          },
          throw(err) {
            return iterator2.throw(err);
          }
        };
      }
    };
  };
}
createBidiStreamingMethod$1.createBidiStreamingMethod = createBidiStreamingMethod;
async function pipeRequest$1(signal, request3, client, definition) {
  for await (const item of request3) {
    (0, abort_controller_x_1$4.throwIfAborted)(signal);
    client.send({
      serializeBinary: () => definition.requestSerialize(item)
    });
  }
}
var createClientStreamingMethod$1 = {};
var __importDefault$8 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(createClientStreamingMethod$1, "__esModule", { value: true });
createClientStreamingMethod$1.createClientStreamingMethod = void 0;
const nice_grpc_common_1$3 = lib;
const grpc_web_1$2 = grpcWebClient_umd.exports;
const abort_controller_x_1$3 = require$$1$1;
const node_abort_controller_1$2 = __importDefault$8(browser$3.exports);
const service_definitions_1$3 = serviceDefinitions;
const isAsyncIterable_1$2 = isAsyncIterable$1;
const convertMetadata_1$2 = convertMetadata;
function createClientStreamingMethod(definition, channel2, middleware, defaultOptions) {
  const grpcMethodDefinition = (0, service_definitions_1$3.toGrpcWebMethodDefinition)(definition);
  const methodDescriptor = {
    path: definition.path,
    requestStream: definition.requestStream,
    responseStream: definition.responseStream,
    options: definition.options
  };
  async function* clientStreamingMethod(request3, options) {
    if (!(0, isAsyncIterable_1$2.isAsyncIterable)(request3)) {
      throw new Error("A middleware passed invalid request to next(): expected a single message for client streaming method");
    }
    const { metadata = (0, nice_grpc_common_1$3.Metadata)(), signal = new node_abort_controller_1$2.default().signal, onHeader, onTrailer } = options;
    return await (0, abort_controller_x_1$3.execute)(signal, (resolve, reject) => {
      const pipeAbortController = new node_abort_controller_1$2.default();
      let response;
      const client = grpc_web_1$2.grpc.client(grpcMethodDefinition, {
        host: channel2.address,
        transport: channel2.transport
      });
      client.onHeaders((headers) => {
        onHeader === null || onHeader === void 0 ? void 0 : onHeader((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(headers));
      });
      client.onMessage((message) => {
        response = message;
      });
      client.onEnd((code, message, trailers) => {
        onTrailer === null || onTrailer === void 0 ? void 0 : onTrailer((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(trailers));
        pipeAbortController.abort();
        if (code === grpc_web_1$2.grpc.Code.OK) {
          resolve(response);
        } else {
          reject(new nice_grpc_common_1$3.ClientError(definition.path, +code, message));
        }
      });
      client.start((0, convertMetadata_1$2.convertMetadataToGrpcWeb)(metadata));
      pipeRequest(pipeAbortController.signal, request3, client, definition).then(() => {
        client.finishSend();
      }, (err) => {
        if (!(0, abort_controller_x_1$3.isAbortError)(err)) {
          reject(err);
          client.close();
        }
      });
      return () => {
        pipeAbortController.abort();
        client.close();
      };
    });
  }
  const method = middleware == null ? clientStreamingMethod : (request3, options) => middleware({
    method: methodDescriptor,
    requestStream: true,
    request: request3,
    responseStream: false,
    next: clientStreamingMethod
  }, options);
  return async (request3, options) => {
    const iterable = method(request3, {
      ...defaultOptions,
      ...options
    });
    const iterator2 = iterable[Symbol.asyncIterator]();
    let result = await iterator2.next();
    while (true) {
      if (!result.done) {
        result = await iterator2.throw(new Error("A middleware yielded a message, but expected to only return a message for client streaming method"));
        continue;
      }
      if (result.value == null) {
        result = await iterator2.throw(new Error("A middleware returned void, but expected to return a message for client streaming method"));
        continue;
      }
      return result.value;
    }
  };
}
createClientStreamingMethod$1.createClientStreamingMethod = createClientStreamingMethod;
async function pipeRequest(signal, request3, client, definition) {
  for await (const item of request3) {
    (0, abort_controller_x_1$3.throwIfAborted)(signal);
    client.send({
      serializeBinary: () => definition.requestSerialize(item)
    });
  }
}
var createServerStreamingMethod$1 = {};
var __importDefault$7 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(createServerStreamingMethod$1, "__esModule", { value: true });
createServerStreamingMethod$1.createServerStreamingMethod = void 0;
const grpc_web_1$1 = grpcWebClient_umd.exports;
const abort_controller_x_1$2 = require$$1$1;
const AsyncSink_1 = AsyncSink$1;
const nice_grpc_common_1$2 = lib;
const node_abort_controller_1$1 = __importDefault$7(browser$3.exports);
const service_definitions_1$2 = serviceDefinitions;
const convertMetadata_1$1 = convertMetadata;
const isAsyncIterable_1$1 = isAsyncIterable$1;
function createServerStreamingMethod(definition, channel2, middleware, defaultOptions) {
  const grpcMethodDefinition = (0, service_definitions_1$2.toGrpcWebMethodDefinition)(definition);
  const methodDescriptor = {
    path: definition.path,
    requestStream: definition.requestStream,
    responseStream: definition.responseStream,
    options: definition.options
  };
  async function* serverStreamingMethod(request3, options) {
    if ((0, isAsyncIterable_1$1.isAsyncIterable)(request3)) {
      throw new Error("A middleware passed invalid request to next(): expected a single message for server streaming method");
    }
    const { metadata = (0, nice_grpc_common_1$2.Metadata)(), signal = new node_abort_controller_1$1.default().signal, onHeader, onTrailer } = options;
    const sink = new AsyncSink_1.AsyncSink();
    const client = grpc_web_1$1.grpc.client(grpcMethodDefinition, {
      host: channel2.address,
      transport: channel2.transport
    });
    client.onHeaders((headers) => {
      onHeader === null || onHeader === void 0 ? void 0 : onHeader((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(headers));
    });
    client.onMessage((message) => {
      sink.write(message);
    });
    client.onEnd((code, message, trailers) => {
      onTrailer === null || onTrailer === void 0 ? void 0 : onTrailer((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(trailers));
      if (code === grpc_web_1$1.grpc.Code.OK) {
        sink.end();
      } else {
        sink.error(new nice_grpc_common_1$2.ClientError(definition.path, +code, message));
      }
    });
    client.start((0, convertMetadata_1$1.convertMetadataToGrpcWeb)(metadata));
    client.send({
      serializeBinary: () => definition.requestSerialize(request3)
    });
    client.finishSend();
    const abortListener = () => {
      sink.error(new abort_controller_x_1$2.AbortError());
      client.close();
    };
    signal.addEventListener("abort", abortListener);
    try {
      yield* sink;
    } finally {
      signal.removeEventListener("abort", abortListener);
      (0, abort_controller_x_1$2.throwIfAborted)(signal);
    }
  }
  const method = middleware == null ? serverStreamingMethod : (request3, options) => middleware({
    method: methodDescriptor,
    requestStream: false,
    request: request3,
    responseStream: true,
    next: serverStreamingMethod
  }, options);
  return (request3, options) => {
    const iterable = method(request3, {
      ...defaultOptions,
      ...options
    });
    const iterator2 = iterable[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const result = await iterator2.next();
            if (result.done && result.value != null) {
              return await iterator2.throw(new Error("A middleware returned a message, but expected to return void for server streaming method"));
            }
            return result;
          },
          return() {
            return iterator2.return();
          },
          throw(err) {
            return iterator2.throw(err);
          }
        };
      }
    };
  };
}
createServerStreamingMethod$1.createServerStreamingMethod = createServerStreamingMethod;
var createUnaryMethod$1 = {};
var __importDefault$6 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(createUnaryMethod$1, "__esModule", { value: true });
createUnaryMethod$1.createUnaryMethod = void 0;
const nice_grpc_common_1$1 = lib;
const grpc_web_1 = grpcWebClient_umd.exports;
const abort_controller_x_1$1 = require$$1$1;
const node_abort_controller_1 = __importDefault$6(browser$3.exports);
const service_definitions_1$1 = serviceDefinitions;
const isAsyncIterable_1 = isAsyncIterable$1;
const convertMetadata_1 = convertMetadata;
function createUnaryMethod(definition, channel2, middleware, defaultOptions) {
  const grpcMethodDefinition = (0, service_definitions_1$1.toGrpcWebMethodDefinition)(definition);
  const methodDescriptor = {
    path: definition.path,
    requestStream: definition.requestStream,
    responseStream: definition.responseStream,
    options: definition.options
  };
  async function* unaryMethod(request3, options) {
    if ((0, isAsyncIterable_1.isAsyncIterable)(request3)) {
      throw new Error("A middleware passed invalid request to next(): expected a single message for unary method");
    }
    const { metadata = (0, nice_grpc_common_1$1.Metadata)(), signal = new node_abort_controller_1.default().signal, onHeader, onTrailer } = options;
    return await (0, abort_controller_x_1$1.execute)(signal, (resolve, reject) => {
      let response;
      const client = grpc_web_1.grpc.client(grpcMethodDefinition, {
        host: channel2.address,
        transport: channel2.transport
      });
      client.onHeaders((headers) => {
        onHeader === null || onHeader === void 0 ? void 0 : onHeader((0, convertMetadata_1.convertMetadataFromGrpcWeb)(headers));
      });
      client.onMessage((message) => {
        response = message;
      });
      client.onEnd((code, message, trailers) => {
        onTrailer === null || onTrailer === void 0 ? void 0 : onTrailer((0, convertMetadata_1.convertMetadataFromGrpcWeb)(trailers));
        if (code === grpc_web_1.grpc.Code.OK) {
          resolve(response);
        } else {
          reject(new nice_grpc_common_1$1.ClientError(definition.path, +code, message));
        }
      });
      client.start((0, convertMetadata_1.convertMetadataToGrpcWeb)(metadata));
      client.send({
        serializeBinary: () => definition.requestSerialize(request3)
      });
      client.finishSend();
      return () => {
        client.close();
      };
    });
  }
  const method = middleware == null ? unaryMethod : (request3, options) => middleware({
    method: methodDescriptor,
    requestStream: false,
    request: request3,
    responseStream: false,
    next: unaryMethod
  }, options);
  return async (request3, options) => {
    const iterable = method(request3, {
      ...defaultOptions,
      ...options
    });
    const iterator2 = iterable[Symbol.asyncIterator]();
    let result = await iterator2.next();
    while (true) {
      if (!result.done) {
        result = await iterator2.throw(new Error("A middleware yielded a message, but expected to only return a message for unary method"));
        continue;
      }
      if (result.value == null) {
        result = await iterator2.throw(new Error("A middleware returned void, but expected to return a message for unary method"));
        continue;
      }
      return result.value;
    }
  };
}
createUnaryMethod$1.createUnaryMethod = createUnaryMethod;
Object.defineProperty(ClientFactory, "__esModule", { value: true });
ClientFactory.createClient = ClientFactory.createClientFactory = void 0;
const nice_grpc_common_1 = lib;
const service_definitions_1 = serviceDefinitions;
const createBidiStreamingMethod_1 = createBidiStreamingMethod$1;
const createClientStreamingMethod_1 = createClientStreamingMethod$1;
const createServerStreamingMethod_1 = createServerStreamingMethod$1;
const createUnaryMethod_1 = createUnaryMethod$1;
function createClientFactory() {
  return createClientFactoryWithMiddleware();
}
ClientFactory.createClientFactory = createClientFactory;
function createClient(definition, channel2, defaultCallOptions) {
  return createClientFactory().create(definition, channel2, defaultCallOptions);
}
ClientFactory.createClient = createClient;
function createClientFactoryWithMiddleware(middleware) {
  return {
    use(newMiddleware) {
      return createClientFactoryWithMiddleware(middleware == null ? newMiddleware : (0, nice_grpc_common_1.composeClientMiddleware)(middleware, newMiddleware));
    },
    create(definition, channel2, defaultCallOptions = {}) {
      const client = {};
      const methodEntries = Object.entries((0, service_definitions_1.normalizeServiceDefinition)(definition));
      for (const [methodName, methodDefinition] of methodEntries) {
        const defaultOptions = {
          ...defaultCallOptions["*"],
          ...defaultCallOptions[methodName]
        };
        if (!methodDefinition.requestStream) {
          if (!methodDefinition.responseStream) {
            client[methodName] = (0, createUnaryMethod_1.createUnaryMethod)(methodDefinition, channel2, middleware, defaultOptions);
          } else {
            client[methodName] = (0, createServerStreamingMethod_1.createServerStreamingMethod)(methodDefinition, channel2, middleware, defaultOptions);
          }
        } else {
          if (!methodDefinition.responseStream) {
            client[methodName] = (0, createClientStreamingMethod_1.createClientStreamingMethod)(methodDefinition, channel2, middleware, defaultOptions);
          } else {
            client[methodName] = (0, createBidiStreamingMethod_1.createBidiStreamingMethod)(methodDefinition, channel2, middleware, defaultOptions);
          }
        }
      }
      return client;
    }
  };
}
var Client = {};
Object.defineProperty(Client, "__esModule", { value: true });
(function(exports2) {
  var __createBinding2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m[k];
  });
  var __exportStar = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding2(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Status = exports2.Metadata = exports2.composeClientMiddleware = exports2.ClientError = void 0;
  var nice_grpc_common_12 = lib;
  Object.defineProperty(exports2, "ClientError", { enumerable: true, get: function() {
    return nice_grpc_common_12.ClientError;
  } });
  Object.defineProperty(exports2, "composeClientMiddleware", { enumerable: true, get: function() {
    return nice_grpc_common_12.composeClientMiddleware;
  } });
  Object.defineProperty(exports2, "Metadata", { enumerable: true, get: function() {
    return nice_grpc_common_12.Metadata;
  } });
  Object.defineProperty(exports2, "Status", { enumerable: true, get: function() {
    return nice_grpc_common_12.Status;
  } });
  __exportStar(serviceDefinitions, exports2);
  __exportStar(channel, exports2);
  __exportStar(ClientFactory, exports2);
  __exportStar(Client, exports2);
})(lib$1);
var dist$2 = {};
var api$3 = {};
var umd = { exports: {} };
(function(module2, exports2) {
  var Long2 = function(exports3) {
    Object.defineProperty(exports3, "__esModule", {
      value: true
    });
    exports3.default = void 0;
    /**
     * @license
     * Copyright 2009 The Closure Library Authors
     * Copyright 2020 Daniel Wirtz / The long.js Authors.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * SPDX-License-Identifier: Apache-2.0
     */
    var wasm2 = null;
    try {
      wasm2 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
    } catch (e2) {
    }
    function Long3(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long3.prototype.__isLong__;
    Object.defineProperty(Long3.prototype, "__isLong__", {
      value: true
    });
    function isLong2(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    function ctz32(value) {
      var c = Math.clz32(value & -value);
      return value ? 31 - c : c;
    }
    Long3.isLong = isLong2;
    var INT_CACHE2 = {};
    var UINT_CACHE2 = {};
    function fromInt2(value, unsigned) {
      var obj, cachedObj, cache2;
      if (unsigned) {
        value >>>= 0;
        if (cache2 = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE2[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits2(value, 0, true);
        if (cache2)
          UINT_CACHE2[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache2 = -128 <= value && value < 128) {
          cachedObj = INT_CACHE2[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits2(value, value < 0 ? -1 : 0, false);
        if (cache2)
          INT_CACHE2[value] = obj;
        return obj;
      }
    }
    Long3.fromInt = fromInt2;
    function fromNumber3(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO2 : ZERO2;
      if (unsigned) {
        if (value < 0)
          return UZERO2;
        if (value >= TWO_PWR_64_DBL2)
          return MAX_UNSIGNED_VALUE2;
      } else {
        if (value <= -TWO_PWR_63_DBL2)
          return MIN_VALUE2;
        if (value + 1 >= TWO_PWR_63_DBL2)
          return MAX_VALUE2;
      }
      if (value < 0)
        return fromNumber3(-value, unsigned).neg();
      return fromBits2(value % TWO_PWR_32_DBL2 | 0, value / TWO_PWR_32_DBL2 | 0, unsigned);
    }
    Long3.fromNumber = fromNumber3;
    function fromBits2(lowBits, highBits, unsigned) {
      return new Long3(lowBits, highBits, unsigned);
    }
    Long3.fromBits = fromBits2;
    var pow_dbl2 = Math.pow;
    function fromString2(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (typeof unsigned === "number") {
        radix = unsigned;
        unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return unsigned ? UZERO2 : ZERO2;
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p === 0) {
        return fromString2(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber3(pow_dbl2(radix, 8));
      var result = ZERO2;
      for (var i2 = 0; i2 < str.length; i2 += 8) {
        var size = Math.min(8, str.length - i2), value = parseInt(str.substring(i2, i2 + size), radix);
        if (size < 8) {
          var power = fromNumber3(pow_dbl2(radix, size));
          result = result.mul(power).add(fromNumber3(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber3(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long3.fromString = fromString2;
    function fromValue2(val, unsigned) {
      if (typeof val === "number")
        return fromNumber3(val, unsigned);
      if (typeof val === "string")
        return fromString2(val, unsigned);
      return fromBits2(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long3.fromValue = fromValue2;
    var TWO_PWR_16_DBL2 = 1 << 16;
    var TWO_PWR_24_DBL2 = 1 << 24;
    var TWO_PWR_32_DBL2 = TWO_PWR_16_DBL2 * TWO_PWR_16_DBL2;
    var TWO_PWR_64_DBL2 = TWO_PWR_32_DBL2 * TWO_PWR_32_DBL2;
    var TWO_PWR_63_DBL2 = TWO_PWR_64_DBL2 / 2;
    var TWO_PWR_242 = fromInt2(TWO_PWR_24_DBL2);
    var ZERO2 = fromInt2(0);
    Long3.ZERO = ZERO2;
    var UZERO2 = fromInt2(0, true);
    Long3.UZERO = UZERO2;
    var ONE2 = fromInt2(1);
    Long3.ONE = ONE2;
    var UONE2 = fromInt2(1, true);
    Long3.UONE = UONE2;
    var NEG_ONE2 = fromInt2(-1);
    Long3.NEG_ONE = NEG_ONE2;
    var MAX_VALUE2 = fromBits2(4294967295 | 0, 2147483647 | 0, false);
    Long3.MAX_VALUE = MAX_VALUE2;
    var MAX_UNSIGNED_VALUE2 = fromBits2(4294967295 | 0, 4294967295 | 0, true);
    Long3.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE2;
    var MIN_VALUE2 = fromBits2(0, 2147483648 | 0, false);
    Long3.MIN_VALUE = MIN_VALUE2;
    var LongPrototype2 = Long3.prototype;
    LongPrototype2.toInt = function toInt2() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype2.toNumber = function toNumber4() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL2 + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL2 + (this.low >>> 0);
    };
    LongPrototype2.toString = function toString4(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE2)) {
          var radixLong = fromNumber3(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber3(pow_dbl2(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype2.getHighBits = function getHighBits2() {
      return this.high;
    };
    LongPrototype2.getHighBitsUnsigned = function getHighBitsUnsigned2() {
      return this.high >>> 0;
    };
    LongPrototype2.getLowBits = function getLowBits2() {
      return this.low;
    };
    LongPrototype2.getLowBitsUnsigned = function getLowBitsUnsigned2() {
      return this.low >>> 0;
    };
    LongPrototype2.getNumBitsAbs = function getNumBitsAbs2() {
      if (this.isNegative())
        return this.eq(MIN_VALUE2) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype2.isZero = function isZero2() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype2.eqz = LongPrototype2.isZero;
    LongPrototype2.isNegative = function isNegative2() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype2.isPositive = function isPositive2() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype2.isOdd = function isOdd2() {
      return (this.low & 1) === 1;
    };
    LongPrototype2.isEven = function isEven2() {
      return (this.low & 1) === 0;
    };
    LongPrototype2.equals = function equals2(other) {
      if (!isLong2(other))
        other = fromValue2(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype2.eq = LongPrototype2.equals;
    LongPrototype2.notEquals = function notEquals2(other) {
      return !this.eq(other);
    };
    LongPrototype2.neq = LongPrototype2.notEquals;
    LongPrototype2.ne = LongPrototype2.notEquals;
    LongPrototype2.lessThan = function lessThan2(other) {
      return this.comp(other) < 0;
    };
    LongPrototype2.lt = LongPrototype2.lessThan;
    LongPrototype2.lessThanOrEqual = function lessThanOrEqual2(other) {
      return this.comp(other) <= 0;
    };
    LongPrototype2.lte = LongPrototype2.lessThanOrEqual;
    LongPrototype2.le = LongPrototype2.lessThanOrEqual;
    LongPrototype2.greaterThan = function greaterThan2(other) {
      return this.comp(other) > 0;
    };
    LongPrototype2.gt = LongPrototype2.greaterThan;
    LongPrototype2.greaterThanOrEqual = function greaterThanOrEqual2(other) {
      return this.comp(other) >= 0;
    };
    LongPrototype2.gte = LongPrototype2.greaterThanOrEqual;
    LongPrototype2.ge = LongPrototype2.greaterThanOrEqual;
    LongPrototype2.compare = function compare2(other) {
      if (!isLong2(other))
        other = fromValue2(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype2.comp = LongPrototype2.compare;
    LongPrototype2.negate = function negate2() {
      if (!this.unsigned && this.eq(MIN_VALUE2))
        return MIN_VALUE2;
      return this.not().add(ONE2);
    };
    LongPrototype2.neg = LongPrototype2.negate;
    LongPrototype2.add = function add2(addend) {
      if (!isLong2(addend))
        addend = fromValue2(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits2(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype2.subtract = function subtract2(subtrahend) {
      if (!isLong2(subtrahend))
        subtrahend = fromValue2(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype2.sub = LongPrototype2.subtract;
    LongPrototype2.multiply = function multiply2(multiplier) {
      if (this.isZero())
        return this;
      if (!isLong2(multiplier))
        multiplier = fromValue2(multiplier);
      if (wasm2) {
        var low = wasm2["mul"](this.low, this.high, multiplier.low, multiplier.high);
        return fromBits2(low, wasm2["get_high"](), this.unsigned);
      }
      if (multiplier.isZero())
        return this.unsigned ? UZERO2 : ZERO2;
      if (this.eq(MIN_VALUE2))
        return multiplier.isOdd() ? MIN_VALUE2 : ZERO2;
      if (multiplier.eq(MIN_VALUE2))
        return this.isOdd() ? MIN_VALUE2 : ZERO2;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_242) && multiplier.lt(TWO_PWR_242))
        return fromNumber3(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits2(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype2.mul = LongPrototype2.multiply;
    LongPrototype2.divide = function divide2(divisor) {
      if (!isLong2(divisor))
        divisor = fromValue2(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm2) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm2["div_u"] : wasm2["div_s"])(this.low, this.high, divisor.low, divisor.high);
        return fromBits2(low, wasm2["get_high"](), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO2 : ZERO2;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE2)) {
          if (divisor.eq(ONE2) || divisor.eq(NEG_ONE2))
            return MIN_VALUE2;
          else if (divisor.eq(MIN_VALUE2))
            return ONE2;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO2)) {
              return divisor.isNegative() ? ONE2 : NEG_ONE2;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE2))
          return this.unsigned ? UZERO2 : ZERO2;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO2;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO2;
        if (divisor.gt(this.shru(1)))
          return UONE2;
        res = UZERO2;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl2(2, log2 - 48), approxRes = fromNumber3(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber3(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE2;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype2.div = LongPrototype2.divide;
    LongPrototype2.modulo = function modulo2(divisor) {
      if (!isLong2(divisor))
        divisor = fromValue2(divisor);
      if (wasm2) {
        var low = (this.unsigned ? wasm2["rem_u"] : wasm2["rem_s"])(this.low, this.high, divisor.low, divisor.high);
        return fromBits2(low, wasm2["get_high"](), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype2.mod = LongPrototype2.modulo;
    LongPrototype2.rem = LongPrototype2.modulo;
    LongPrototype2.not = function not3() {
      return fromBits2(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype2.countLeadingZeros = function countLeadingZeros() {
      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
    };
    LongPrototype2.clz = LongPrototype2.countLeadingZeros;
    LongPrototype2.countTrailingZeros = function countTrailingZeros() {
      return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
    };
    LongPrototype2.ctz = LongPrototype2.countTrailingZeros;
    LongPrototype2.and = function and2(other) {
      if (!isLong2(other))
        other = fromValue2(other);
      return fromBits2(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype2.or = function or2(other) {
      if (!isLong2(other))
        other = fromValue2(other);
      return fromBits2(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype2.xor = function xor2(other) {
      if (!isLong2(other))
        other = fromValue2(other);
      return fromBits2(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype2.shiftLeft = function shiftLeft2(numBits) {
      if (isLong2(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits2(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits2(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype2.shl = LongPrototype2.shiftLeft;
    LongPrototype2.shiftRight = function shiftRight2(numBits) {
      if (isLong2(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits2(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits2(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype2.shr = LongPrototype2.shiftRight;
    LongPrototype2.shiftRightUnsigned = function shiftRightUnsigned2(numBits) {
      if (isLong2(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits < 32)
        return fromBits2(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
      if (numBits === 32)
        return fromBits2(this.high, 0, this.unsigned);
      return fromBits2(this.high >>> numBits - 32, 0, this.unsigned);
    };
    LongPrototype2.shru = LongPrototype2.shiftRightUnsigned;
    LongPrototype2.shr_u = LongPrototype2.shiftRightUnsigned;
    LongPrototype2.rotateLeft = function rotateLeft(numBits) {
      var b;
      if (isLong2(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits === 32)
        return fromBits2(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits2(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits2(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
    };
    LongPrototype2.rotl = LongPrototype2.rotateLeft;
    LongPrototype2.rotateRight = function rotateRight(numBits) {
      var b;
      if (isLong2(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits === 32)
        return fromBits2(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits2(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits2(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
    };
    LongPrototype2.rotr = LongPrototype2.rotateRight;
    LongPrototype2.toSigned = function toSigned2() {
      if (!this.unsigned)
        return this;
      return fromBits2(this.low, this.high, false);
    };
    LongPrototype2.toUnsigned = function toUnsigned2() {
      if (this.unsigned)
        return this;
      return fromBits2(this.low, this.high, true);
    };
    LongPrototype2.toBytes = function toBytes2(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype2.toBytesLE = function toBytesLE2() {
      var hi = this.high, lo = this.low;
      return [lo & 255, lo >>> 8 & 255, lo >>> 16 & 255, lo >>> 24, hi & 255, hi >>> 8 & 255, hi >>> 16 & 255, hi >>> 24];
    };
    LongPrototype2.toBytesBE = function toBytesBE2() {
      var hi = this.high, lo = this.low;
      return [hi >>> 24, hi >>> 16 & 255, hi >>> 8 & 255, hi & 255, lo >>> 24, lo >>> 16 & 255, lo >>> 8 & 255, lo & 255];
    };
    Long3.fromBytes = function fromBytes2(bytes, unsigned, le) {
      return le ? Long3.fromBytesLE(bytes, unsigned) : Long3.fromBytesBE(bytes, unsigned);
    };
    Long3.fromBytesLE = function fromBytesLE2(bytes, unsigned) {
      return new Long3(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
    };
    Long3.fromBytesBE = function fromBytesBE2(bytes, unsigned) {
      return new Long3(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
    };
    var _default = Long3;
    exports3.default = _default;
    return "default" in exports3 ? exports3.default : exports3;
  }({});
  module2.exports = Long2;
})(umd);
var indexMinimal$1 = {};
var minimal$3 = {};
var aspromise$1 = asPromise;
function asPromise(fn, ctx) {
  var params = new Array(arguments.length - 1), offset = 0, index2 = 2, pending = true;
  while (index2 < arguments.length)
    params[offset++] = arguments[index2++];
  return new Promise(function executor(resolve, reject) {
    params[offset] = function callback(err) {
      if (pending) {
        pending = false;
        if (err)
          reject(err);
        else {
          var params2 = new Array(arguments.length - 1), offset2 = 0;
          while (offset2 < params2.length)
            params2[offset2++] = arguments[offset2];
          resolve.apply(null, params2);
        }
      }
    };
    try {
      fn.apply(ctx || null, params);
    } catch (err) {
      if (pending) {
        pending = false;
        reject(err);
      }
    }
  });
}
var base64$3 = {};
(function(exports2) {
  var base642 = exports2;
  base642.length = function length2(string) {
    var p = string.length;
    if (!p)
      return 0;
    var n2 = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
      ++n2;
    return Math.ceil(string.length * 3) / 4 - n2;
  };
  var b64 = new Array(64);
  var s64 = new Array(123);
  for (var i2 = 0; i2 < 64; )
    s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
  base642.encode = function encode2(buffer2, start2, end3) {
    var parts = null, chunk = [];
    var i3 = 0, j = 0, t2;
    while (start2 < end3) {
      var b = buffer2[start2++];
      switch (j) {
        case 0:
          chunk[i3++] = b64[b >> 2];
          t2 = (b & 3) << 4;
          j = 1;
          break;
        case 1:
          chunk[i3++] = b64[t2 | b >> 4];
          t2 = (b & 15) << 2;
          j = 2;
          break;
        case 2:
          chunk[i3++] = b64[t2 | b >> 6];
          chunk[i3++] = b64[b & 63];
          j = 0;
          break;
      }
      if (i3 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i3 = 0;
      }
    }
    if (j) {
      chunk[i3++] = b64[t2];
      chunk[i3++] = 61;
      if (j === 1)
        chunk[i3++] = 61;
    }
    if (parts) {
      if (i3)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i3));
  };
  var invalidEncoding = "invalid encoding";
  base642.decode = function decode(string, buffer2, offset) {
    var start2 = offset;
    var j = 0, t2;
    for (var i3 = 0; i3 < string.length; ) {
      var c = string.charCodeAt(i3++);
      if (c === 61 && j > 1)
        break;
      if ((c = s64[c]) === void 0)
        throw Error(invalidEncoding);
      switch (j) {
        case 0:
          t2 = c;
          j = 1;
          break;
        case 1:
          buffer2[offset++] = t2 << 2 | (c & 48) >> 4;
          t2 = c;
          j = 2;
          break;
        case 2:
          buffer2[offset++] = (t2 & 15) << 4 | (c & 60) >> 2;
          t2 = c;
          j = 3;
          break;
        case 3:
          buffer2[offset++] = (t2 & 3) << 6 | c;
          j = 0;
          break;
      }
    }
    if (j === 1)
      throw Error(invalidEncoding);
    return offset - start2;
  };
  base642.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
  };
})(base64$3);
var eventemitter$1 = EventEmitter$1;
function EventEmitter$1() {
  this._listeners = {};
}
EventEmitter$1.prototype.on = function on2(evt, fn, ctx) {
  (this._listeners[evt] || (this._listeners[evt] = [])).push({
    fn,
    ctx: ctx || this
  });
  return this;
};
EventEmitter$1.prototype.off = function off(evt, fn) {
  if (evt === void 0)
    this._listeners = {};
  else {
    if (fn === void 0)
      this._listeners[evt] = [];
    else {
      var listeners2 = this._listeners[evt];
      for (var i2 = 0; i2 < listeners2.length; )
        if (listeners2[i2].fn === fn)
          listeners2.splice(i2, 1);
        else
          ++i2;
    }
  }
  return this;
};
EventEmitter$1.prototype.emit = function emit(evt) {
  var listeners2 = this._listeners[evt];
  if (listeners2) {
    var args = [], i2 = 1;
    for (; i2 < arguments.length; )
      args.push(arguments[i2++]);
    for (i2 = 0; i2 < listeners2.length; )
      listeners2[i2].fn.apply(listeners2[i2++].ctx, args);
  }
  return this;
};
var float$1 = factory(factory);
function factory(exports2) {
  if (typeof Float32Array !== "undefined")
    (function() {
      var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
      function writeFloat_f32_cpy(val, buf, pos) {
        f32[0] = val;
        buf[pos] = f8b[0];
        buf[pos + 1] = f8b[1];
        buf[pos + 2] = f8b[2];
        buf[pos + 3] = f8b[3];
      }
      function writeFloat_f32_rev(val, buf, pos) {
        f32[0] = val;
        buf[pos] = f8b[3];
        buf[pos + 1] = f8b[2];
        buf[pos + 2] = f8b[1];
        buf[pos + 3] = f8b[0];
      }
      exports2.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
      exports2.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
      function readFloat_f32_cpy(buf, pos) {
        f8b[0] = buf[pos];
        f8b[1] = buf[pos + 1];
        f8b[2] = buf[pos + 2];
        f8b[3] = buf[pos + 3];
        return f32[0];
      }
      function readFloat_f32_rev(buf, pos) {
        f8b[3] = buf[pos];
        f8b[2] = buf[pos + 1];
        f8b[1] = buf[pos + 2];
        f8b[0] = buf[pos + 3];
        return f32[0];
      }
      exports2.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
      exports2.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
    })();
  else
    (function() {
      function writeFloat_ieee754(writeUint, val, buf, pos) {
        var sign = val < 0 ? 1 : 0;
        if (sign)
          val = -val;
        if (val === 0)
          writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
        else if (isNaN(val))
          writeUint(2143289344, buf, pos);
        else if (val > 34028234663852886e22)
          writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
        else if (val < 11754943508222875e-54)
          writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
        else {
          var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
          writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
        }
      }
      exports2.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
      exports2.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
      function readFloat_ieee754(readUint, buf, pos) {
        var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
        return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
      }
      exports2.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
      exports2.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
    })();
  if (typeof Float64Array !== "undefined")
    (function() {
      var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
      function writeDouble_f64_cpy(val, buf, pos) {
        f64[0] = val;
        buf[pos] = f8b[0];
        buf[pos + 1] = f8b[1];
        buf[pos + 2] = f8b[2];
        buf[pos + 3] = f8b[3];
        buf[pos + 4] = f8b[4];
        buf[pos + 5] = f8b[5];
        buf[pos + 6] = f8b[6];
        buf[pos + 7] = f8b[7];
      }
      function writeDouble_f64_rev(val, buf, pos) {
        f64[0] = val;
        buf[pos] = f8b[7];
        buf[pos + 1] = f8b[6];
        buf[pos + 2] = f8b[5];
        buf[pos + 3] = f8b[4];
        buf[pos + 4] = f8b[3];
        buf[pos + 5] = f8b[2];
        buf[pos + 6] = f8b[1];
        buf[pos + 7] = f8b[0];
      }
      exports2.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
      exports2.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
      function readDouble_f64_cpy(buf, pos) {
        f8b[0] = buf[pos];
        f8b[1] = buf[pos + 1];
        f8b[2] = buf[pos + 2];
        f8b[3] = buf[pos + 3];
        f8b[4] = buf[pos + 4];
        f8b[5] = buf[pos + 5];
        f8b[6] = buf[pos + 6];
        f8b[7] = buf[pos + 7];
        return f64[0];
      }
      function readDouble_f64_rev(buf, pos) {
        f8b[7] = buf[pos];
        f8b[6] = buf[pos + 1];
        f8b[5] = buf[pos + 2];
        f8b[4] = buf[pos + 3];
        f8b[3] = buf[pos + 4];
        f8b[2] = buf[pos + 5];
        f8b[1] = buf[pos + 6];
        f8b[0] = buf[pos + 7];
        return f64[0];
      }
      exports2.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
      exports2.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
    })();
  else
    (function() {
      function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
        var sign = val < 0 ? 1 : 0;
        if (sign)
          val = -val;
        if (val === 0) {
          writeUint(0, buf, pos + off0);
          writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
        } else if (isNaN(val)) {
          writeUint(0, buf, pos + off0);
          writeUint(2146959360, buf, pos + off1);
        } else if (val > 17976931348623157e292) {
          writeUint(0, buf, pos + off0);
          writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
        } else {
          var mantissa;
          if (val < 22250738585072014e-324) {
            mantissa = val / 5e-324;
            writeUint(mantissa >>> 0, buf, pos + off0);
            writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
          } else {
            var exponent = Math.floor(Math.log(val) / Math.LN2);
            if (exponent === 1024)
              exponent = 1023;
            mantissa = val * Math.pow(2, -exponent);
            writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
            writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
          }
        }
      }
      exports2.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
      exports2.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
      function readDouble_ieee754(readUint, off0, off1, buf, pos) {
        var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
        var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
        return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
      }
      exports2.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
      exports2.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
    })();
  return exports2;
}
function writeUintLE(val, buf, pos) {
  buf[pos] = val & 255;
  buf[pos + 1] = val >>> 8 & 255;
  buf[pos + 2] = val >>> 16 & 255;
  buf[pos + 3] = val >>> 24;
}
function writeUintBE(val, buf, pos) {
  buf[pos] = val >>> 24;
  buf[pos + 1] = val >>> 16 & 255;
  buf[pos + 2] = val >>> 8 & 255;
  buf[pos + 3] = val & 255;
}
function readUintLE(buf, pos) {
  return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
}
function readUintBE(buf, pos) {
  return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
}
var inquire_1$1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (e2) {
  }
  return null;
}
var utf8$5 = {};
(function(exports2) {
  var utf82 = exports2;
  utf82.length = function utf8_length(string) {
    var len = 0, c = 0;
    for (var i2 = 0; i2 < string.length; ++i2) {
      c = string.charCodeAt(i2);
      if (c < 128)
        len += 1;
      else if (c < 2048)
        len += 2;
      else if ((c & 64512) === 55296 && (string.charCodeAt(i2 + 1) & 64512) === 56320) {
        ++i2;
        len += 4;
      } else
        len += 3;
    }
    return len;
  };
  utf82.read = function utf8_read(buffer2, start2, end3) {
    var len = end3 - start2;
    if (len < 1)
      return "";
    var parts = null, chunk = [], i2 = 0, t2;
    while (start2 < end3) {
      t2 = buffer2[start2++];
      if (t2 < 128)
        chunk[i2++] = t2;
      else if (t2 > 191 && t2 < 224)
        chunk[i2++] = (t2 & 31) << 6 | buffer2[start2++] & 63;
      else if (t2 > 239 && t2 < 365) {
        t2 = ((t2 & 7) << 18 | (buffer2[start2++] & 63) << 12 | (buffer2[start2++] & 63) << 6 | buffer2[start2++] & 63) - 65536;
        chunk[i2++] = 55296 + (t2 >> 10);
        chunk[i2++] = 56320 + (t2 & 1023);
      } else
        chunk[i2++] = (t2 & 15) << 12 | (buffer2[start2++] & 63) << 6 | buffer2[start2++] & 63;
      if (i2 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i2 = 0;
      }
    }
    if (parts) {
      if (i2)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i2));
  };
  utf82.write = function utf8_write(string, buffer2, offset) {
    var start2 = offset, c1, c2;
    for (var i2 = 0; i2 < string.length; ++i2) {
      c1 = string.charCodeAt(i2);
      if (c1 < 128) {
        buffer2[offset++] = c1;
      } else if (c1 < 2048) {
        buffer2[offset++] = c1 >> 6 | 192;
        buffer2[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i2 + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
        ++i2;
        buffer2[offset++] = c1 >> 18 | 240;
        buffer2[offset++] = c1 >> 12 & 63 | 128;
        buffer2[offset++] = c1 >> 6 & 63 | 128;
        buffer2[offset++] = c1 & 63 | 128;
      } else {
        buffer2[offset++] = c1 >> 12 | 224;
        buffer2[offset++] = c1 >> 6 & 63 | 128;
        buffer2[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start2;
  };
})(utf8$5);
var pool_1$1 = pool;
function pool(alloc3, slice2, size) {
  var SIZE = size || 8192;
  var MAX = SIZE >>> 1;
  var slab = null;
  var offset = SIZE;
  return function pool_alloc(size2) {
    if (size2 < 1 || size2 > MAX)
      return alloc3(size2);
    if (offset + size2 > SIZE) {
      slab = alloc3(SIZE);
      offset = 0;
    }
    var buf = slice2.call(slab, offset, offset += size2);
    if (offset & 7)
      offset = (offset | 7) + 1;
    return buf;
  };
}
var longbits$1 = LongBits$4;
var util$a = minimal$3;
function LongBits$4(lo, hi) {
  this.lo = lo >>> 0;
  this.hi = hi >>> 0;
}
var zero = LongBits$4.zero = new LongBits$4(0, 0);
zero.toNumber = function() {
  return 0;
};
zero.zzEncode = zero.zzDecode = function() {
  return this;
};
zero.length = function() {
  return 1;
};
var zeroHash = LongBits$4.zeroHash = "\0\0\0\0\0\0\0\0";
LongBits$4.fromNumber = function fromNumber2(value) {
  if (value === 0)
    return zero;
  var sign = value < 0;
  if (sign)
    value = -value;
  var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
  if (sign) {
    hi = ~hi >>> 0;
    lo = ~lo >>> 0;
    if (++lo > 4294967295) {
      lo = 0;
      if (++hi > 4294967295)
        hi = 0;
    }
  }
  return new LongBits$4(lo, hi);
};
LongBits$4.from = function from2(value) {
  if (typeof value === "number")
    return LongBits$4.fromNumber(value);
  if (util$a.isString(value)) {
    if (util$a.Long)
      value = util$a.Long.fromString(value);
    else
      return LongBits$4.fromNumber(parseInt(value, 10));
  }
  return value.low || value.high ? new LongBits$4(value.low >>> 0, value.high >>> 0) : zero;
};
LongBits$4.prototype.toNumber = function toNumber2(unsigned) {
  if (!unsigned && this.hi >>> 31) {
    var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
    if (!lo)
      hi = hi + 1 >>> 0;
    return -(lo + hi * 4294967296);
  }
  return this.lo + this.hi * 4294967296;
};
LongBits$4.prototype.toLong = function toLong(unsigned) {
  return util$a.Long ? new util$a.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};
var charCodeAt = String.prototype.charCodeAt;
LongBits$4.fromHash = function fromHash(hash) {
  if (hash === zeroHash)
    return zero;
  return new LongBits$4((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
};
LongBits$4.prototype.toHash = function toHash() {
  return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
};
LongBits$4.prototype.zzEncode = function zzEncode() {
  var mask = this.hi >> 31;
  this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
  this.lo = (this.lo << 1 ^ mask) >>> 0;
  return this;
};
LongBits$4.prototype.zzDecode = function zzDecode() {
  var mask = -(this.lo & 1);
  this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
  this.hi = (this.hi >>> 1 ^ mask) >>> 0;
  return this;
};
LongBits$4.prototype.length = function length() {
  var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
  return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
};
(function(exports2) {
  var util2 = exports2;
  util2.asPromise = aspromise$1;
  util2.base64 = base64$3;
  util2.EventEmitter = eventemitter$1;
  util2.float = float$1;
  util2.inquire = inquire_1$1;
  util2.utf8 = utf8$5;
  util2.pool = pool_1$1;
  util2.LongBits = longbits$1;
  util2.isNode = Boolean(typeof commonjsGlobal$1 !== "undefined" && commonjsGlobal$1 && commonjsGlobal$1.process && commonjsGlobal$1.process.versions && commonjsGlobal$1.process.versions.node);
  util2.global = util2.isNode && commonjsGlobal$1 || typeof window !== "undefined" && window || typeof self !== "undefined" && self || commonjsGlobal$1;
  util2.emptyArray = Object.freeze ? Object.freeze([]) : [];
  util2.emptyObject = Object.freeze ? Object.freeze({}) : {};
  util2.isInteger = Number.isInteger || function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
  util2.isString = function isString2(value) {
    return typeof value === "string" || value instanceof String;
  };
  util2.isObject = function isObject2(value) {
    return value && typeof value === "object";
  };
  util2.isset = util2.isSet = function isSet2(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop))
      return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
  };
  util2.Buffer = function() {
    try {
      var Buffer2 = util2.inquire("buffer").Buffer;
      return Buffer2.prototype.utf8Write ? Buffer2 : null;
    } catch (e2) {
      return null;
    }
  }();
  util2._Buffer_from = null;
  util2._Buffer_allocUnsafe = null;
  util2.newBuffer = function newBuffer(sizeOrArray) {
    return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
  };
  util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  util2.Long = util2.global.dcodeIO && util2.global.dcodeIO.Long || util2.global.Long || util2.inquire("long");
  util2.key2Re = /^true|false|0|1$/;
  util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
  util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
  util2.longToHash = function longToHash(value) {
    return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
  };
  util2.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util2.LongBits.fromHash(hash);
    if (util2.Long)
      return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
  };
  function merge2(dst, src, ifNotSet) {
    for (var keys2 = Object.keys(src), i2 = 0; i2 < keys2.length; ++i2)
      if (dst[keys2[i2]] === void 0 || !ifNotSet)
        dst[keys2[i2]] = src[keys2[i2]];
    return dst;
  }
  util2.merge = merge2;
  util2.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
  };
  function newError(name2) {
    function CustomError(message, properties) {
      if (!(this instanceof CustomError))
        return new CustomError(message, properties);
      Object.defineProperty(this, "message", { get: function() {
        return message;
      } });
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, CustomError);
      else
        Object.defineProperty(this, "stack", { value: new Error().stack || "" });
      if (properties)
        merge2(this, properties);
    }
    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
    Object.defineProperty(CustomError.prototype, "name", { get: function() {
      return name2;
    } });
    CustomError.prototype.toString = function toString4() {
      return this.name + ": " + this.message;
    };
    return CustomError;
  }
  util2.newError = newError;
  util2.ProtocolError = newError("ProtocolError");
  util2.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i2 = 0; i2 < fieldNames.length; ++i2)
      fieldMap[fieldNames[i2]] = 1;
    return function() {
      for (var keys2 = Object.keys(this), i3 = keys2.length - 1; i3 > -1; --i3)
        if (fieldMap[keys2[i3]] === 1 && this[keys2[i3]] !== void 0 && this[keys2[i3]] !== null)
          return keys2[i3];
    };
  };
  util2.oneOfSetter = function setOneOf(fieldNames) {
    return function(name2) {
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        if (fieldNames[i2] !== name2)
          delete this[fieldNames[i2]];
    };
  };
  util2.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
  };
  util2._configure = function() {
    var Buffer2 = util2.Buffer;
    if (!Buffer2) {
      util2._Buffer_from = util2._Buffer_allocUnsafe = null;
      return;
    }
    util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
      return new Buffer2(value, encoding);
    };
    util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
      return new Buffer2(size);
    };
  };
})(minimal$3);
var writer$3 = Writer$3;
var util$9 = minimal$3;
var BufferWriter$3;
var LongBits$3 = util$9.LongBits, base64$2 = util$9.base64, utf8$4 = util$9.utf8;
function Op$1(fn, len, val) {
  this.fn = fn;
  this.len = len;
  this.next = void 0;
  this.val = val;
}
function noop$3() {
}
function State$1(writer2) {
  this.head = writer2.head;
  this.tail = writer2.tail;
  this.len = writer2.len;
  this.next = writer2.states;
}
function Writer$3() {
  this.len = 0;
  this.head = new Op$1(noop$3, 0, 0);
  this.tail = this.head;
  this.states = null;
}
var create$4 = function create2() {
  return util$9.Buffer ? function create_buffer_setup() {
    return (Writer$3.create = function create_buffer() {
      return new BufferWriter$3();
    })();
  } : function create_array4() {
    return new Writer$3();
  };
};
Writer$3.create = create$4();
Writer$3.alloc = function alloc(size) {
  return new util$9.Array(size);
};
if (util$9.Array !== Array)
  Writer$3.alloc = util$9.pool(Writer$3.alloc, util$9.Array.prototype.subarray);
Writer$3.prototype._push = function push(fn, len, val) {
  this.tail = this.tail.next = new Op$1(fn, len, val);
  this.len += len;
  return this;
};
function writeByte$1(val, buf, pos) {
  buf[pos] = val & 255;
}
function writeVarint32$1(val, buf, pos) {
  while (val > 127) {
    buf[pos++] = val & 127 | 128;
    val >>>= 7;
  }
  buf[pos] = val;
}
function VarintOp$1(len, val) {
  this.len = len;
  this.next = void 0;
  this.val = val;
}
VarintOp$1.prototype = Object.create(Op$1.prototype);
VarintOp$1.prototype.fn = writeVarint32$1;
Writer$3.prototype.uint32 = function write_uint32(value) {
  this.len += (this.tail = this.tail.next = new VarintOp$1((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
  return this;
};
Writer$3.prototype.int32 = function write_int32(value) {
  return value < 0 ? this._push(writeVarint64$1, 10, LongBits$3.fromNumber(value)) : this.uint32(value);
};
Writer$3.prototype.sint32 = function write_sint32(value) {
  return this.uint32((value << 1 ^ value >> 31) >>> 0);
};
function writeVarint64$1(val, buf, pos) {
  while (val.hi) {
    buf[pos++] = val.lo & 127 | 128;
    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
    val.hi >>>= 7;
  }
  while (val.lo > 127) {
    buf[pos++] = val.lo & 127 | 128;
    val.lo = val.lo >>> 7;
  }
  buf[pos++] = val.lo;
}
Writer$3.prototype.uint64 = function write_uint64(value) {
  var bits = LongBits$3.from(value);
  return this._push(writeVarint64$1, bits.length(), bits);
};
Writer$3.prototype.int64 = Writer$3.prototype.uint64;
Writer$3.prototype.sint64 = function write_sint64(value) {
  var bits = LongBits$3.from(value).zzEncode();
  return this._push(writeVarint64$1, bits.length(), bits);
};
Writer$3.prototype.bool = function write_bool(value) {
  return this._push(writeByte$1, 1, value ? 1 : 0);
};
function writeFixed32$1(val, buf, pos) {
  buf[pos] = val & 255;
  buf[pos + 1] = val >>> 8 & 255;
  buf[pos + 2] = val >>> 16 & 255;
  buf[pos + 3] = val >>> 24;
}
Writer$3.prototype.fixed32 = function write_fixed32(value) {
  return this._push(writeFixed32$1, 4, value >>> 0);
};
Writer$3.prototype.sfixed32 = Writer$3.prototype.fixed32;
Writer$3.prototype.fixed64 = function write_fixed64(value) {
  var bits = LongBits$3.from(value);
  return this._push(writeFixed32$1, 4, bits.lo)._push(writeFixed32$1, 4, bits.hi);
};
Writer$3.prototype.sfixed64 = Writer$3.prototype.fixed64;
Writer$3.prototype.float = function write_float(value) {
  return this._push(util$9.float.writeFloatLE, 4, value);
};
Writer$3.prototype.double = function write_double(value) {
  return this._push(util$9.float.writeDoubleLE, 8, value);
};
var writeBytes$1 = util$9.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
  buf.set(val, pos);
} : function writeBytes_for(val, buf, pos) {
  for (var i2 = 0; i2 < val.length; ++i2)
    buf[pos + i2] = val[i2];
};
Writer$3.prototype.bytes = function write_bytes(value) {
  var len = value.length >>> 0;
  if (!len)
    return this._push(writeByte$1, 1, 0);
  if (util$9.isString(value)) {
    var buf = Writer$3.alloc(len = base64$2.length(value));
    base64$2.decode(value, buf, 0);
    value = buf;
  }
  return this.uint32(len)._push(writeBytes$1, len, value);
};
Writer$3.prototype.string = function write_string(value) {
  var len = utf8$4.length(value);
  return len ? this.uint32(len)._push(utf8$4.write, len, value) : this._push(writeByte$1, 1, 0);
};
Writer$3.prototype.fork = function fork() {
  this.states = new State$1(this);
  this.head = this.tail = new Op$1(noop$3, 0, 0);
  this.len = 0;
  return this;
};
Writer$3.prototype.reset = function reset() {
  if (this.states) {
    this.head = this.states.head;
    this.tail = this.states.tail;
    this.len = this.states.len;
    this.states = this.states.next;
  } else {
    this.head = this.tail = new Op$1(noop$3, 0, 0);
    this.len = 0;
  }
  return this;
};
Writer$3.prototype.ldelim = function ldelim() {
  var head = this.head, tail = this.tail, len = this.len;
  this.reset().uint32(len);
  if (len) {
    this.tail.next = head.next;
    this.tail = tail;
    this.len += len;
  }
  return this;
};
Writer$3.prototype.finish = function finish() {
  var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
  while (head) {
    head.fn(head.val, buf, pos);
    pos += head.len;
    head = head.next;
  }
  return buf;
};
Writer$3._configure = function(BufferWriter_) {
  BufferWriter$3 = BufferWriter_;
  Writer$3.create = create$4();
  BufferWriter$3._configure();
};
var writer_buffer$1 = BufferWriter$2;
var Writer$2 = writer$3;
(BufferWriter$2.prototype = Object.create(Writer$2.prototype)).constructor = BufferWriter$2;
var util$8 = minimal$3;
function BufferWriter$2() {
  Writer$2.call(this);
}
BufferWriter$2._configure = function() {
  BufferWriter$2.alloc = util$8._Buffer_allocUnsafe;
  BufferWriter$2.writeBytesBuffer = util$8.Buffer && util$8.Buffer.prototype instanceof Uint8Array && util$8.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytesBuffer_copy(val, buf, pos) {
    if (val.copy)
      val.copy(buf, pos, 0, val.length);
    else
      for (var i2 = 0; i2 < val.length; )
        buf[pos++] = val[i2++];
  };
};
BufferWriter$2.prototype.bytes = function write_bytes_buffer(value) {
  if (util$8.isString(value))
    value = util$8._Buffer_from(value, "base64");
  var len = value.length >>> 0;
  this.uint32(len);
  if (len)
    this._push(BufferWriter$2.writeBytesBuffer, len, value);
  return this;
};
function writeStringBuffer$1(val, buf, pos) {
  if (val.length < 40)
    util$8.utf8.write(val, buf, pos);
  else if (buf.utf8Write)
    buf.utf8Write(val, pos);
  else
    buf.write(val, pos);
}
BufferWriter$2.prototype.string = function write_string_buffer(value) {
  var len = util$8.Buffer.byteLength(value);
  this.uint32(len);
  if (len)
    this._push(writeStringBuffer$1, len, value);
  return this;
};
BufferWriter$2._configure();
var reader$1 = Reader$3;
var util$7 = minimal$3;
var BufferReader$3;
var LongBits$2 = util$7.LongBits, utf8$3 = util$7.utf8;
function indexOutOfRange$1(reader2, writeLength) {
  return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
}
function Reader$3(buffer2) {
  this.buf = buffer2;
  this.pos = 0;
  this.len = buffer2.length;
}
var create_array$1 = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
  if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
    return new Reader$3(buffer2);
  throw Error("illegal buffer");
} : function create_array2(buffer2) {
  if (Array.isArray(buffer2))
    return new Reader$3(buffer2);
  throw Error("illegal buffer");
};
var create$3 = function create3() {
  return util$7.Buffer ? function create_buffer_setup(buffer2) {
    return (Reader$3.create = function create_buffer(buffer3) {
      return util$7.Buffer.isBuffer(buffer3) ? new BufferReader$3(buffer3) : create_array$1(buffer3);
    })(buffer2);
  } : create_array$1;
};
Reader$3.create = create$3();
Reader$3.prototype._slice = util$7.Array.prototype.subarray || util$7.Array.prototype.slice;
Reader$3.prototype.uint32 = function read_uint32_setup() {
  var value = 4294967295;
  return function read_uint32() {
    value = (this.buf[this.pos] & 127) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    if ((this.pos += 5) > this.len) {
      this.pos = this.len;
      throw indexOutOfRange$1(this, 10);
    }
    return value;
  };
}();
Reader$3.prototype.int32 = function read_int32() {
  return this.uint32() | 0;
};
Reader$3.prototype.sint32 = function read_sint32() {
  var value = this.uint32();
  return value >>> 1 ^ -(value & 1) | 0;
};
function readLongVarint$1() {
  var bits = new LongBits$2(0, 0);
  var i2 = 0;
  if (this.len - this.pos > 4) {
    for (; i2 < 4; ++i2) {
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
    bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
    bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
    if (this.buf[this.pos++] < 128)
      return bits;
    i2 = 0;
  } else {
    for (; i2 < 3; ++i2) {
      if (this.pos >= this.len)
        throw indexOutOfRange$1(this);
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
    bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
    return bits;
  }
  if (this.len - this.pos > 4) {
    for (; i2 < 5; ++i2) {
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
  } else {
    for (; i2 < 5; ++i2) {
      if (this.pos >= this.len)
        throw indexOutOfRange$1(this);
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
  }
  throw Error("invalid varint encoding");
}
Reader$3.prototype.bool = function read_bool() {
  return this.uint32() !== 0;
};
function readFixed32_end$1(buf, end3) {
  return (buf[end3 - 4] | buf[end3 - 3] << 8 | buf[end3 - 2] << 16 | buf[end3 - 1] << 24) >>> 0;
}
Reader$3.prototype.fixed32 = function read_fixed32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange$1(this, 4);
  return readFixed32_end$1(this.buf, this.pos += 4);
};
Reader$3.prototype.sfixed32 = function read_sfixed32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange$1(this, 4);
  return readFixed32_end$1(this.buf, this.pos += 4) | 0;
};
function readFixed64$1() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange$1(this, 8);
  return new LongBits$2(readFixed32_end$1(this.buf, this.pos += 4), readFixed32_end$1(this.buf, this.pos += 4));
}
Reader$3.prototype.float = function read_float() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange$1(this, 4);
  var value = util$7.float.readFloatLE(this.buf, this.pos);
  this.pos += 4;
  return value;
};
Reader$3.prototype.double = function read_double() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange$1(this, 4);
  var value = util$7.float.readDoubleLE(this.buf, this.pos);
  this.pos += 8;
  return value;
};
Reader$3.prototype.bytes = function read_bytes() {
  var length2 = this.uint32(), start2 = this.pos, end3 = this.pos + length2;
  if (end3 > this.len)
    throw indexOutOfRange$1(this, length2);
  this.pos += length2;
  if (Array.isArray(this.buf))
    return this.buf.slice(start2, end3);
  return start2 === end3 ? new this.buf.constructor(0) : this._slice.call(this.buf, start2, end3);
};
Reader$3.prototype.string = function read_string() {
  var bytes = this.bytes();
  return utf8$3.read(bytes, 0, bytes.length);
};
Reader$3.prototype.skip = function skip2(length2) {
  if (typeof length2 === "number") {
    if (this.pos + length2 > this.len)
      throw indexOutOfRange$1(this, length2);
    this.pos += length2;
  } else {
    do {
      if (this.pos >= this.len)
        throw indexOutOfRange$1(this);
    } while (this.buf[this.pos++] & 128);
  }
  return this;
};
Reader$3.prototype.skipType = function(wireType) {
  switch (wireType) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      while ((wireType = this.uint32() & 7) !== 4) {
        this.skipType(wireType);
      }
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + wireType + " at offset " + this.pos);
  }
  return this;
};
Reader$3._configure = function(BufferReader_) {
  BufferReader$3 = BufferReader_;
  Reader$3.create = create$3();
  BufferReader$3._configure();
  var fn = util$7.Long ? "toLong" : "toNumber";
  util$7.merge(Reader$3.prototype, {
    int64: function read_int64() {
      return readLongVarint$1.call(this)[fn](false);
    },
    uint64: function read_uint64() {
      return readLongVarint$1.call(this)[fn](true);
    },
    sint64: function read_sint64() {
      return readLongVarint$1.call(this).zzDecode()[fn](false);
    },
    fixed64: function read_fixed64() {
      return readFixed64$1.call(this)[fn](true);
    },
    sfixed64: function read_sfixed64() {
      return readFixed64$1.call(this)[fn](false);
    }
  });
};
var reader_buffer$1 = BufferReader$2;
var Reader$2 = reader$1;
(BufferReader$2.prototype = Object.create(Reader$2.prototype)).constructor = BufferReader$2;
var util$6 = minimal$3;
function BufferReader$2(buffer2) {
  Reader$2.call(this, buffer2);
}
BufferReader$2._configure = function() {
  if (util$6.Buffer)
    BufferReader$2.prototype._slice = util$6.Buffer.prototype.slice;
};
BufferReader$2.prototype.string = function read_string_buffer() {
  var len = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};
BufferReader$2._configure();
var rpc$1 = {};
var service$1 = Service$1;
var util$5 = minimal$3;
(Service$1.prototype = Object.create(util$5.EventEmitter.prototype)).constructor = Service$1;
function Service$1(rpcImpl, requestDelimited, responseDelimited) {
  if (typeof rpcImpl !== "function")
    throw TypeError("rpcImpl must be a function");
  util$5.EventEmitter.call(this);
  this.rpcImpl = rpcImpl;
  this.requestDelimited = Boolean(requestDelimited);
  this.responseDelimited = Boolean(responseDelimited);
}
Service$1.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request3, callback) {
  if (!request3)
    throw TypeError("request must be specified");
  var self2 = this;
  if (!callback)
    return util$5.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request3);
  if (!self2.rpcImpl) {
    setTimeout(function() {
      callback(Error("already ended"));
    }, 0);
    return void 0;
  }
  try {
    return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request3).finish(), function rpcCallback(err, response) {
      if (err) {
        self2.emit("error", err, method);
        return callback(err);
      }
      if (response === null) {
        self2.end(true);
        return void 0;
      }
      if (!(response instanceof responseCtor)) {
        try {
          response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
        } catch (err2) {
          self2.emit("error", err2, method);
          return callback(err2);
        }
      }
      self2.emit("data", response, method);
      return callback(null, response);
    });
  } catch (err) {
    self2.emit("error", err, method);
    setTimeout(function() {
      callback(err);
    }, 0);
    return void 0;
  }
};
Service$1.prototype.end = function end(endedByRPC) {
  if (this.rpcImpl) {
    if (!endedByRPC)
      this.rpcImpl(null, null, null);
    this.rpcImpl = null;
    this.emit("end").off();
  }
  return this;
};
(function(exports2) {
  var rpc2 = exports2;
  rpc2.Service = service$1;
})(rpc$1);
var roots$1 = {};
(function(exports2) {
  var protobuf = exports2;
  protobuf.build = "minimal";
  protobuf.Writer = writer$3;
  protobuf.BufferWriter = writer_buffer$1;
  protobuf.Reader = reader$1;
  protobuf.BufferReader = reader_buffer$1;
  protobuf.util = minimal$3;
  protobuf.rpc = rpc$1;
  protobuf.roots = roots$1;
  protobuf.configure = configure;
  function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
  }
  configure();
})(indexMinimal$1);
var minimal$2 = indexMinimal$1;
var struct$2 = {};
(function(exports2) {
  var __createBinding2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar2 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __importDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ListValue = exports2.Value = exports2.Struct_FieldsEntry = exports2.Struct = exports2.nullValueToNumber = exports2.nullValueToJSON = exports2.nullValueFromJSON = exports2.NullValue = exports2.protobufPackage = void 0;
  const long_12 = __importDefault2(umd.exports);
  const _m02 = __importStar2(minimal$2);
  exports2.protobufPackage = "google.protobuf";
  var NullValue;
  (function(NullValue2) {
    NullValue2["NULL_VALUE"] = "NULL_VALUE";
  })(NullValue = exports2.NullValue || (exports2.NullValue = {}));
  function nullValueFromJSON(object) {
    switch (object) {
      case 0:
      case "NULL_VALUE":
        return NullValue.NULL_VALUE;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum NullValue");
    }
  }
  exports2.nullValueFromJSON = nullValueFromJSON;
  function nullValueToJSON(object) {
    switch (object) {
      case NullValue.NULL_VALUE:
        return "NULL_VALUE";
      default:
        return "UNKNOWN";
    }
  }
  exports2.nullValueToJSON = nullValueToJSON;
  function nullValueToNumber(object) {
    switch (object) {
      case NullValue.NULL_VALUE:
        return 0;
      default:
        return 0;
    }
  }
  exports2.nullValueToNumber = nullValueToNumber;
  function createBaseStruct() {
    return { fields: {} };
  }
  exports2.Struct = {
    encode(message, writer2 = _m02.Writer.create()) {
      Object.entries(message.fields).forEach(([key, value]) => {
        if (value !== void 0) {
          exports2.Struct_FieldsEntry.encode({ key, value }, writer2.uint32(10).fork()).ldelim();
        }
      });
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseStruct();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            const entry1 = exports2.Struct_FieldsEntry.decode(reader2, reader2.uint32());
            if (entry1.value !== void 0) {
              message.fields[entry1.key] = entry1.value;
            }
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        fields: isObject2(object.fields) ? Object.entries(object.fields).reduce((acc, [key, value]) => {
          acc[key] = value;
          return acc;
        }, {}) : {}
      };
    },
    toJSON(message) {
      const obj = {};
      obj.fields = {};
      if (message.fields) {
        Object.entries(message.fields).forEach(([k, v]) => {
          obj.fields[k] = v;
        });
      }
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseStruct();
      message.fields = Object.entries((_a2 = object.fields) !== null && _a2 !== void 0 ? _a2 : {}).reduce((acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = value;
        }
        return acc;
      }, {});
      return message;
    },
    wrap(object) {
      const struct2 = createBaseStruct();
      if (object !== void 0) {
        Object.keys(object).forEach((key) => {
          struct2.fields[key] = object[key];
        });
      }
      return struct2;
    },
    unwrap(message) {
      const object = {};
      Object.keys(message.fields).forEach((key) => {
        object[key] = message.fields[key];
      });
      return object;
    }
  };
  function createBaseStruct_FieldsEntry() {
    return { key: "", value: void 0 };
  }
  exports2.Struct_FieldsEntry = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.key !== "") {
        writer2.uint32(10).string(message.key);
      }
      if (message.value !== void 0) {
        exports2.Value.encode(exports2.Value.wrap(message.value), writer2.uint32(18).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseStruct_FieldsEntry();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.key = reader2.string();
            break;
          case 2:
            message.value = exports2.Value.unwrap(exports2.Value.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        key: isSet2(object.key) ? String(object.key) : "",
        value: isSet2(object === null || object === void 0 ? void 0 : object.value) ? object.value : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.key !== void 0 && (obj.key = message.key);
      message.value !== void 0 && (obj.value = message.value);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseStruct_FieldsEntry();
      message.key = (_a2 = object.key) !== null && _a2 !== void 0 ? _a2 : "";
      message.value = (_b = object.value) !== null && _b !== void 0 ? _b : void 0;
      return message;
    }
  };
  function createBaseValue() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  exports2.Value = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.nullValue !== void 0) {
        writer2.uint32(8).int32(nullValueToNumber(message.nullValue));
      }
      if (message.numberValue !== void 0) {
        writer2.uint32(17).double(message.numberValue);
      }
      if (message.stringValue !== void 0) {
        writer2.uint32(26).string(message.stringValue);
      }
      if (message.boolValue !== void 0) {
        writer2.uint32(32).bool(message.boolValue);
      }
      if (message.structValue !== void 0) {
        exports2.Struct.encode(exports2.Struct.wrap(message.structValue), writer2.uint32(42).fork()).ldelim();
      }
      if (message.listValue !== void 0) {
        exports2.ListValue.encode(exports2.ListValue.wrap(message.listValue), writer2.uint32(50).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseValue();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.nullValue = nullValueFromJSON(reader2.int32());
            break;
          case 2:
            message.numberValue = reader2.double();
            break;
          case 3:
            message.stringValue = reader2.string();
            break;
          case 4:
            message.boolValue = reader2.bool();
            break;
          case 5:
            message.structValue = exports2.Struct.unwrap(exports2.Struct.decode(reader2, reader2.uint32()));
            break;
          case 6:
            message.listValue = exports2.ListValue.unwrap(exports2.ListValue.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        nullValue: isSet2(object.nullValue) ? nullValueFromJSON(object.nullValue) : void 0,
        numberValue: isSet2(object.numberValue) ? Number(object.numberValue) : void 0,
        stringValue: isSet2(object.stringValue) ? String(object.stringValue) : void 0,
        boolValue: isSet2(object.boolValue) ? Boolean(object.boolValue) : void 0,
        structValue: isObject2(object.structValue) ? object.structValue : void 0,
        listValue: Array.isArray(object.listValue) ? [...object.listValue] : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.nullValue !== void 0 && (obj.nullValue = message.nullValue !== void 0 ? nullValueToJSON(message.nullValue) : void 0);
      message.numberValue !== void 0 && (obj.numberValue = message.numberValue);
      message.stringValue !== void 0 && (obj.stringValue = message.stringValue);
      message.boolValue !== void 0 && (obj.boolValue = message.boolValue);
      message.structValue !== void 0 && (obj.structValue = message.structValue);
      message.listValue !== void 0 && (obj.listValue = message.listValue);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e, _f;
      const message = createBaseValue();
      message.nullValue = (_a2 = object.nullValue) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.numberValue = (_b = object.numberValue) !== null && _b !== void 0 ? _b : void 0;
      message.stringValue = (_c = object.stringValue) !== null && _c !== void 0 ? _c : void 0;
      message.boolValue = (_d = object.boolValue) !== null && _d !== void 0 ? _d : void 0;
      message.structValue = (_e = object.structValue) !== null && _e !== void 0 ? _e : void 0;
      message.listValue = (_f = object.listValue) !== null && _f !== void 0 ? _f : void 0;
      return message;
    },
    wrap(value) {
      const result = createBaseValue();
      if (value === null) {
        result.nullValue = NullValue.NULL_VALUE;
      } else if (typeof value === "boolean") {
        result.boolValue = value;
      } else if (typeof value === "number") {
        result.numberValue = value;
      } else if (typeof value === "string") {
        result.stringValue = value;
      } else if (Array.isArray(value)) {
        result.listValue = value;
      } else if (typeof value === "object") {
        result.structValue = value;
      } else if (typeof value !== "undefined") {
        throw new Error("Unsupported any value type: " + typeof value);
      }
      return result;
    },
    unwrap(message) {
      if ((message === null || message === void 0 ? void 0 : message.stringValue) !== void 0) {
        return message.stringValue;
      } else if ((message === null || message === void 0 ? void 0 : message.numberValue) !== void 0) {
        return message.numberValue;
      } else if ((message === null || message === void 0 ? void 0 : message.boolValue) !== void 0) {
        return message.boolValue;
      } else if ((message === null || message === void 0 ? void 0 : message.structValue) !== void 0) {
        return message.structValue;
      } else if ((message === null || message === void 0 ? void 0 : message.listValue) !== void 0) {
        return message.listValue;
      } else if ((message === null || message === void 0 ? void 0 : message.nullValue) !== void 0) {
        return null;
      }
      return void 0;
    }
  };
  function createBaseListValue() {
    return { values: [] };
  }
  exports2.ListValue = {
    encode(message, writer2 = _m02.Writer.create()) {
      for (const v of message.values) {
        exports2.Value.encode(exports2.Value.wrap(v), writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseListValue();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.values.push(exports2.Value.unwrap(exports2.Value.decode(reader2, reader2.uint32())));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        values: Array.isArray(object === null || object === void 0 ? void 0 : object.values) ? [...object.values] : []
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.values) {
        obj.values = message.values.map((e2) => e2);
      } else {
        obj.values = [];
      }
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseListValue();
      message.values = ((_a2 = object.values) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
      return message;
    },
    wrap(value) {
      const result = createBaseListValue();
      result.values = value !== null && value !== void 0 ? value : [];
      return result;
    },
    unwrap(message) {
      return message.values;
    }
  };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal$1 !== "undefined")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  if (_m02.util.Long !== long_12.default) {
    _m02.util.Long = long_12.default;
    _m02.configure();
  }
  function isObject2(value) {
    return typeof value === "object" && value !== null;
  }
  function isSet2(value) {
    return value !== null && value !== void 0;
  }
})(struct$2);
(function(exports2) {
  var __createBinding2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar2 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __importDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.LayoutServiceDefinition = exports2.LayoutServiceClientImpl = exports2.LayerServiceDefinition = exports2.LayerServiceClientImpl = exports2.Event = exports2.LayerEvent = exports2.LayoutEvent = exports2.BatchLayerRequest_BatchItem = exports2.BatchLayerRequest = exports2.BatchDeleteLayerRequest = exports2.DeleteLayerPayload = exports2.UpdateLayerRequest = exports2.GetLayerRequest = exports2.CreateLayerRequest = exports2.ListLayersResponse = exports2.ListLayersRequest = exports2.PartialLayerWithID = exports2.PartialLayer = exports2.LayerAnimation = exports2.DeleteLayoutResponse = exports2.DeleteLayoutRequest = exports2.DeleteLayoutPayload = exports2.UpdateLayoutRequest = exports2.GetLayoutRequest = exports2.CreateLayoutRequest = exports2.ListLayoutsResponse = exports2.ListLayoutsRequest = exports2.PartialLayout = exports2.BatchLayerResponse_BatchLayerItem = exports2.BatchLayerResponse = exports2.DeleteLayerResponse = exports2.DeleteLayerRequest = exports2.Layer = exports2.Layout = exports2.Transition_TransitionStinger = exports2.Transition_TransitionStingerCut = exports2.Transition_TransitionSwipe = exports2.Transition_TransitionCrossfade = exports2.Transition_TransitionFadeToColor = exports2.Transition_TransitionCut = exports2.Transition_TransitionMediaType = exports2.Transition = exports2.transition_TransitionSwipeTypeToNumber = exports2.transition_TransitionSwipeTypeToJSON = exports2.transition_TransitionSwipeTypeFromJSON = exports2.Transition_TransitionSwipeType = exports2.transition_TransitionDirectionToNumber = exports2.transition_TransitionDirectionToJSON = exports2.transition_TransitionDirectionFromJSON = exports2.Transition_TransitionDirection = exports2.eventTypeToNumber = exports2.eventTypeToJSON = exports2.eventTypeFromJSON = exports2.EventType = exports2.eventSubTypeToNumber = exports2.eventSubTypeToJSON = exports2.eventSubTypeFromJSON = exports2.EventSubType = exports2.requestAnimationModeToNumber = exports2.requestAnimationModeToJSON = exports2.requestAnimationModeFromJSON = exports2.RequestAnimationMode = exports2.layoutTypeToNumber = exports2.layoutTypeToJSON = exports2.layoutTypeFromJSON = exports2.LayoutType = exports2.protobufPackage = void 0;
  const long_12 = __importDefault2(umd.exports);
  const _m02 = __importStar2(minimal$2);
  const struct_1 = struct$2;
  exports2.protobufPackage = "apis.layout.v2";
  var LayoutType;
  (function(LayoutType2) {
    LayoutType2["LAYOUT_TYPE_UNSPECIFIED"] = "LAYOUT_TYPE_UNSPECIFIED";
    LayoutType2["LAYOUT_TYPE_SCENELESS"] = "LAYOUT_TYPE_SCENELESS";
    LayoutType2["LAYOUT_TYPE_SCENE"] = "LAYOUT_TYPE_SCENE";
  })(LayoutType = exports2.LayoutType || (exports2.LayoutType = {}));
  function layoutTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "LAYOUT_TYPE_UNSPECIFIED":
        return LayoutType.LAYOUT_TYPE_UNSPECIFIED;
      case 1:
      case "LAYOUT_TYPE_SCENELESS":
        return LayoutType.LAYOUT_TYPE_SCENELESS;
      case 2:
      case "LAYOUT_TYPE_SCENE":
        return LayoutType.LAYOUT_TYPE_SCENE;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum LayoutType");
    }
  }
  exports2.layoutTypeFromJSON = layoutTypeFromJSON;
  function layoutTypeToJSON(object) {
    switch (object) {
      case LayoutType.LAYOUT_TYPE_UNSPECIFIED:
        return "LAYOUT_TYPE_UNSPECIFIED";
      case LayoutType.LAYOUT_TYPE_SCENELESS:
        return "LAYOUT_TYPE_SCENELESS";
      case LayoutType.LAYOUT_TYPE_SCENE:
        return "LAYOUT_TYPE_SCENE";
      default:
        return "UNKNOWN";
    }
  }
  exports2.layoutTypeToJSON = layoutTypeToJSON;
  function layoutTypeToNumber(object) {
    switch (object) {
      case LayoutType.LAYOUT_TYPE_UNSPECIFIED:
        return 0;
      case LayoutType.LAYOUT_TYPE_SCENELESS:
        return 1;
      case LayoutType.LAYOUT_TYPE_SCENE:
        return 2;
      default:
        return 0;
    }
  }
  exports2.layoutTypeToNumber = layoutTypeToNumber;
  var RequestAnimationMode;
  (function(RequestAnimationMode2) {
    RequestAnimationMode2["REQUEST_ANIMATION_MODE_UNSPECIFIED"] = "REQUEST_ANIMATION_MODE_UNSPECIFIED";
    RequestAnimationMode2["REQUEST_ANIMATION_MODE_PARALLEL"] = "REQUEST_ANIMATION_MODE_PARALLEL";
    RequestAnimationMode2["REQUEST_ANIMATION_MODE_SERIES"] = "REQUEST_ANIMATION_MODE_SERIES";
  })(RequestAnimationMode = exports2.RequestAnimationMode || (exports2.RequestAnimationMode = {}));
  function requestAnimationModeFromJSON(object) {
    switch (object) {
      case 0:
      case "REQUEST_ANIMATION_MODE_UNSPECIFIED":
        return RequestAnimationMode.REQUEST_ANIMATION_MODE_UNSPECIFIED;
      case 1:
      case "REQUEST_ANIMATION_MODE_PARALLEL":
        return RequestAnimationMode.REQUEST_ANIMATION_MODE_PARALLEL;
      case 2:
      case "REQUEST_ANIMATION_MODE_SERIES":
        return RequestAnimationMode.REQUEST_ANIMATION_MODE_SERIES;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum RequestAnimationMode");
    }
  }
  exports2.requestAnimationModeFromJSON = requestAnimationModeFromJSON;
  function requestAnimationModeToJSON(object) {
    switch (object) {
      case RequestAnimationMode.REQUEST_ANIMATION_MODE_UNSPECIFIED:
        return "REQUEST_ANIMATION_MODE_UNSPECIFIED";
      case RequestAnimationMode.REQUEST_ANIMATION_MODE_PARALLEL:
        return "REQUEST_ANIMATION_MODE_PARALLEL";
      case RequestAnimationMode.REQUEST_ANIMATION_MODE_SERIES:
        return "REQUEST_ANIMATION_MODE_SERIES";
      default:
        return "UNKNOWN";
    }
  }
  exports2.requestAnimationModeToJSON = requestAnimationModeToJSON;
  function requestAnimationModeToNumber(object) {
    switch (object) {
      case RequestAnimationMode.REQUEST_ANIMATION_MODE_UNSPECIFIED:
        return 0;
      case RequestAnimationMode.REQUEST_ANIMATION_MODE_PARALLEL:
        return 1;
      case RequestAnimationMode.REQUEST_ANIMATION_MODE_SERIES:
        return 2;
      default:
        return 0;
    }
  }
  exports2.requestAnimationModeToNumber = requestAnimationModeToNumber;
  var EventSubType2;
  (function(EventSubType3) {
    EventSubType3["EVENT_SUB_TYPE_UNSPECIFIED"] = "EVENT_SUB_TYPE_UNSPECIFIED";
    EventSubType3["EVENT_SUB_TYPE_CREATE"] = "EVENT_SUB_TYPE_CREATE";
    EventSubType3["EVENT_SUB_TYPE_UPDATE"] = "EVENT_SUB_TYPE_UPDATE";
    EventSubType3["EVENT_SUB_TYPE_DELETE"] = "EVENT_SUB_TYPE_DELETE";
    EventSubType3["EVENT_SUB_TYPE_BATCH"] = "EVENT_SUB_TYPE_BATCH";
  })(EventSubType2 = exports2.EventSubType || (exports2.EventSubType = {}));
  function eventSubTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "EVENT_SUB_TYPE_UNSPECIFIED":
        return EventSubType2.EVENT_SUB_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_SUB_TYPE_CREATE":
        return EventSubType2.EVENT_SUB_TYPE_CREATE;
      case 2:
      case "EVENT_SUB_TYPE_UPDATE":
        return EventSubType2.EVENT_SUB_TYPE_UPDATE;
      case 3:
      case "EVENT_SUB_TYPE_DELETE":
        return EventSubType2.EVENT_SUB_TYPE_DELETE;
      case 4:
      case "EVENT_SUB_TYPE_BATCH":
        return EventSubType2.EVENT_SUB_TYPE_BATCH;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum EventSubType");
    }
  }
  exports2.eventSubTypeFromJSON = eventSubTypeFromJSON;
  function eventSubTypeToJSON(object) {
    switch (object) {
      case EventSubType2.EVENT_SUB_TYPE_UNSPECIFIED:
        return "EVENT_SUB_TYPE_UNSPECIFIED";
      case EventSubType2.EVENT_SUB_TYPE_CREATE:
        return "EVENT_SUB_TYPE_CREATE";
      case EventSubType2.EVENT_SUB_TYPE_UPDATE:
        return "EVENT_SUB_TYPE_UPDATE";
      case EventSubType2.EVENT_SUB_TYPE_DELETE:
        return "EVENT_SUB_TYPE_DELETE";
      case EventSubType2.EVENT_SUB_TYPE_BATCH:
        return "EVENT_SUB_TYPE_BATCH";
      default:
        return "UNKNOWN";
    }
  }
  exports2.eventSubTypeToJSON = eventSubTypeToJSON;
  function eventSubTypeToNumber(object) {
    switch (object) {
      case EventSubType2.EVENT_SUB_TYPE_UNSPECIFIED:
        return 0;
      case EventSubType2.EVENT_SUB_TYPE_CREATE:
        return 1;
      case EventSubType2.EVENT_SUB_TYPE_UPDATE:
        return 2;
      case EventSubType2.EVENT_SUB_TYPE_DELETE:
        return 3;
      case EventSubType2.EVENT_SUB_TYPE_BATCH:
        return 4;
      default:
        return 0;
    }
  }
  exports2.eventSubTypeToNumber = eventSubTypeToNumber;
  var EventType2;
  (function(EventType3) {
    EventType3["EVENT_TYPE_UNSPECIFIED"] = "EVENT_TYPE_UNSPECIFIED";
    EventType3["EVENT_TYPE_LAYOUT"] = "EVENT_TYPE_LAYOUT";
    EventType3["EVENT_TYPE_LAYER"] = "EVENT_TYPE_LAYER";
  })(EventType2 = exports2.EventType || (exports2.EventType = {}));
  function eventTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "EVENT_TYPE_UNSPECIFIED":
        return EventType2.EVENT_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_TYPE_LAYOUT":
        return EventType2.EVENT_TYPE_LAYOUT;
      case 2:
      case "EVENT_TYPE_LAYER":
        return EventType2.EVENT_TYPE_LAYER;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum EventType");
    }
  }
  exports2.eventTypeFromJSON = eventTypeFromJSON;
  function eventTypeToJSON(object) {
    switch (object) {
      case EventType2.EVENT_TYPE_UNSPECIFIED:
        return "EVENT_TYPE_UNSPECIFIED";
      case EventType2.EVENT_TYPE_LAYOUT:
        return "EVENT_TYPE_LAYOUT";
      case EventType2.EVENT_TYPE_LAYER:
        return "EVENT_TYPE_LAYER";
      default:
        return "UNKNOWN";
    }
  }
  exports2.eventTypeToJSON = eventTypeToJSON;
  function eventTypeToNumber(object) {
    switch (object) {
      case EventType2.EVENT_TYPE_UNSPECIFIED:
        return 0;
      case EventType2.EVENT_TYPE_LAYOUT:
        return 1;
      case EventType2.EVENT_TYPE_LAYER:
        return 2;
      default:
        return 0;
    }
  }
  exports2.eventTypeToNumber = eventTypeToNumber;
  var Transition_TransitionDirection;
  (function(Transition_TransitionDirection2) {
    Transition_TransitionDirection2["TRANSITION_DIRECTION_UNSPECIFIED"] = "TRANSITION_DIRECTION_UNSPECIFIED";
    Transition_TransitionDirection2["TRANSITION_DIRECTION_LEFT"] = "TRANSITION_DIRECTION_LEFT";
    Transition_TransitionDirection2["TRANSITION_DIRECTION_RIGHT"] = "TRANSITION_DIRECTION_RIGHT";
    Transition_TransitionDirection2["TRANSITION_DIRECTION_UP"] = "TRANSITION_DIRECTION_UP";
    Transition_TransitionDirection2["TRANSITION_DIRECTION_DOWN"] = "TRANSITION_DIRECTION_DOWN";
  })(Transition_TransitionDirection = exports2.Transition_TransitionDirection || (exports2.Transition_TransitionDirection = {}));
  function transition_TransitionDirectionFromJSON(object) {
    switch (object) {
      case 0:
      case "TRANSITION_DIRECTION_UNSPECIFIED":
        return Transition_TransitionDirection.TRANSITION_DIRECTION_UNSPECIFIED;
      case 1:
      case "TRANSITION_DIRECTION_LEFT":
        return Transition_TransitionDirection.TRANSITION_DIRECTION_LEFT;
      case 2:
      case "TRANSITION_DIRECTION_RIGHT":
        return Transition_TransitionDirection.TRANSITION_DIRECTION_RIGHT;
      case 3:
      case "TRANSITION_DIRECTION_UP":
        return Transition_TransitionDirection.TRANSITION_DIRECTION_UP;
      case 4:
      case "TRANSITION_DIRECTION_DOWN":
        return Transition_TransitionDirection.TRANSITION_DIRECTION_DOWN;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum Transition_TransitionDirection");
    }
  }
  exports2.transition_TransitionDirectionFromJSON = transition_TransitionDirectionFromJSON;
  function transition_TransitionDirectionToJSON(object) {
    switch (object) {
      case Transition_TransitionDirection.TRANSITION_DIRECTION_UNSPECIFIED:
        return "TRANSITION_DIRECTION_UNSPECIFIED";
      case Transition_TransitionDirection.TRANSITION_DIRECTION_LEFT:
        return "TRANSITION_DIRECTION_LEFT";
      case Transition_TransitionDirection.TRANSITION_DIRECTION_RIGHT:
        return "TRANSITION_DIRECTION_RIGHT";
      case Transition_TransitionDirection.TRANSITION_DIRECTION_UP:
        return "TRANSITION_DIRECTION_UP";
      case Transition_TransitionDirection.TRANSITION_DIRECTION_DOWN:
        return "TRANSITION_DIRECTION_DOWN";
      default:
        return "UNKNOWN";
    }
  }
  exports2.transition_TransitionDirectionToJSON = transition_TransitionDirectionToJSON;
  function transition_TransitionDirectionToNumber(object) {
    switch (object) {
      case Transition_TransitionDirection.TRANSITION_DIRECTION_UNSPECIFIED:
        return 0;
      case Transition_TransitionDirection.TRANSITION_DIRECTION_LEFT:
        return 1;
      case Transition_TransitionDirection.TRANSITION_DIRECTION_RIGHT:
        return 2;
      case Transition_TransitionDirection.TRANSITION_DIRECTION_UP:
        return 3;
      case Transition_TransitionDirection.TRANSITION_DIRECTION_DOWN:
        return 4;
      default:
        return 0;
    }
  }
  exports2.transition_TransitionDirectionToNumber = transition_TransitionDirectionToNumber;
  var Transition_TransitionSwipeType;
  (function(Transition_TransitionSwipeType2) {
    Transition_TransitionSwipeType2["TRANSITION_SWIPE_TYPE_UNSPECIFIED"] = "TRANSITION_SWIPE_TYPE_UNSPECIFIED";
    Transition_TransitionSwipeType2["TRANSITION_SWIPE_TYPE_COMBINED"] = "TRANSITION_SWIPE_TYPE_COMBINED";
    Transition_TransitionSwipeType2["TRANSITION_SWIPE_TYPE_SOURCE"] = "TRANSITION_SWIPE_TYPE_SOURCE";
    Transition_TransitionSwipeType2["TRANSITION_SWIPE_TYPE_DESTINATION"] = "TRANSITION_SWIPE_TYPE_DESTINATION";
  })(Transition_TransitionSwipeType = exports2.Transition_TransitionSwipeType || (exports2.Transition_TransitionSwipeType = {}));
  function transition_TransitionSwipeTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "TRANSITION_SWIPE_TYPE_UNSPECIFIED":
        return Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_UNSPECIFIED;
      case 1:
      case "TRANSITION_SWIPE_TYPE_COMBINED":
        return Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_COMBINED;
      case 2:
      case "TRANSITION_SWIPE_TYPE_SOURCE":
        return Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_SOURCE;
      case 3:
      case "TRANSITION_SWIPE_TYPE_DESTINATION":
        return Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_DESTINATION;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum Transition_TransitionSwipeType");
    }
  }
  exports2.transition_TransitionSwipeTypeFromJSON = transition_TransitionSwipeTypeFromJSON;
  function transition_TransitionSwipeTypeToJSON(object) {
    switch (object) {
      case Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_UNSPECIFIED:
        return "TRANSITION_SWIPE_TYPE_UNSPECIFIED";
      case Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_COMBINED:
        return "TRANSITION_SWIPE_TYPE_COMBINED";
      case Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_SOURCE:
        return "TRANSITION_SWIPE_TYPE_SOURCE";
      case Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_DESTINATION:
        return "TRANSITION_SWIPE_TYPE_DESTINATION";
      default:
        return "UNKNOWN";
    }
  }
  exports2.transition_TransitionSwipeTypeToJSON = transition_TransitionSwipeTypeToJSON;
  function transition_TransitionSwipeTypeToNumber(object) {
    switch (object) {
      case Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_UNSPECIFIED:
        return 0;
      case Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_COMBINED:
        return 1;
      case Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_SOURCE:
        return 2;
      case Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_DESTINATION:
        return 3;
      default:
        return 0;
    }
  }
  exports2.transition_TransitionSwipeTypeToNumber = transition_TransitionSwipeTypeToNumber;
  function createBaseTransition() {
    return {
      fromLayoutIds: [],
      cut: void 0,
      crossfade: void 0,
      fadeToColor: void 0,
      swipe: void 0,
      stinger: void 0
    };
  }
  exports2.Transition = {
    encode(message, writer2 = _m02.Writer.create()) {
      for (const v of message.fromLayoutIds) {
        writer2.uint32(10).string(v);
      }
      if (message.cut !== void 0) {
        exports2.Transition_TransitionCut.encode(message.cut, writer2.uint32(82).fork()).ldelim();
      }
      if (message.crossfade !== void 0) {
        exports2.Transition_TransitionCrossfade.encode(message.crossfade, writer2.uint32(90).fork()).ldelim();
      }
      if (message.fadeToColor !== void 0) {
        exports2.Transition_TransitionFadeToColor.encode(message.fadeToColor, writer2.uint32(98).fork()).ldelim();
      }
      if (message.swipe !== void 0) {
        exports2.Transition_TransitionSwipe.encode(message.swipe, writer2.uint32(106).fork()).ldelim();
      }
      if (message.stinger !== void 0) {
        exports2.Transition_TransitionStinger.encode(message.stinger, writer2.uint32(114).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseTransition();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.fromLayoutIds.push(reader2.string());
            break;
          case 10:
            message.cut = exports2.Transition_TransitionCut.decode(reader2, reader2.uint32());
            break;
          case 11:
            message.crossfade = exports2.Transition_TransitionCrossfade.decode(reader2, reader2.uint32());
            break;
          case 12:
            message.fadeToColor = exports2.Transition_TransitionFadeToColor.decode(reader2, reader2.uint32());
            break;
          case 13:
            message.swipe = exports2.Transition_TransitionSwipe.decode(reader2, reader2.uint32());
            break;
          case 14:
            message.stinger = exports2.Transition_TransitionStinger.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        fromLayoutIds: Array.isArray(object === null || object === void 0 ? void 0 : object.fromLayoutIds) ? object.fromLayoutIds.map((e2) => String(e2)) : [],
        cut: isSet2(object.cut) ? exports2.Transition_TransitionCut.fromJSON(object.cut) : void 0,
        crossfade: isSet2(object.crossfade) ? exports2.Transition_TransitionCrossfade.fromJSON(object.crossfade) : void 0,
        fadeToColor: isSet2(object.fadeToColor) ? exports2.Transition_TransitionFadeToColor.fromJSON(object.fadeToColor) : void 0,
        swipe: isSet2(object.swipe) ? exports2.Transition_TransitionSwipe.fromJSON(object.swipe) : void 0,
        stinger: isSet2(object.stinger) ? exports2.Transition_TransitionStinger.fromJSON(object.stinger) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.fromLayoutIds) {
        obj.fromLayoutIds = message.fromLayoutIds.map((e2) => e2);
      } else {
        obj.fromLayoutIds = [];
      }
      message.cut !== void 0 && (obj.cut = message.cut ? exports2.Transition_TransitionCut.toJSON(message.cut) : void 0);
      message.crossfade !== void 0 && (obj.crossfade = message.crossfade ? exports2.Transition_TransitionCrossfade.toJSON(message.crossfade) : void 0);
      message.fadeToColor !== void 0 && (obj.fadeToColor = message.fadeToColor ? exports2.Transition_TransitionFadeToColor.toJSON(message.fadeToColor) : void 0);
      message.swipe !== void 0 && (obj.swipe = message.swipe ? exports2.Transition_TransitionSwipe.toJSON(message.swipe) : void 0);
      message.stinger !== void 0 && (obj.stinger = message.stinger ? exports2.Transition_TransitionStinger.toJSON(message.stinger) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseTransition();
      message.fromLayoutIds = ((_a2 = object.fromLayoutIds) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
      message.cut = object.cut !== void 0 && object.cut !== null ? exports2.Transition_TransitionCut.fromPartial(object.cut) : void 0;
      message.crossfade = object.crossfade !== void 0 && object.crossfade !== null ? exports2.Transition_TransitionCrossfade.fromPartial(object.crossfade) : void 0;
      message.fadeToColor = object.fadeToColor !== void 0 && object.fadeToColor !== null ? exports2.Transition_TransitionFadeToColor.fromPartial(object.fadeToColor) : void 0;
      message.swipe = object.swipe !== void 0 && object.swipe !== null ? exports2.Transition_TransitionSwipe.fromPartial(object.swipe) : void 0;
      message.stinger = object.stinger !== void 0 && object.stinger !== null ? exports2.Transition_TransitionStinger.fromPartial(object.stinger) : void 0;
      return message;
    }
  };
  function createBaseTransition_TransitionMediaType() {
    return { url: "", volume: 0 };
  }
  exports2.Transition_TransitionMediaType = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.url !== "") {
        writer2.uint32(10).string(message.url);
      }
      if (message.volume !== 0) {
        writer2.uint32(17).double(message.volume);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseTransition_TransitionMediaType();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.url = reader2.string();
            break;
          case 2:
            message.volume = reader2.double();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        url: isSet2(object.url) ? String(object.url) : "",
        volume: isSet2(object.volume) ? Number(object.volume) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.url !== void 0 && (obj.url = message.url);
      message.volume !== void 0 && (obj.volume = message.volume);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseTransition_TransitionMediaType();
      message.url = (_a2 = object.url) !== null && _a2 !== void 0 ? _a2 : "";
      message.volume = (_b = object.volume) !== null && _b !== void 0 ? _b : 0;
      return message;
    }
  };
  function createBaseTransition_TransitionCut() {
    return {};
  }
  exports2.Transition_TransitionCut = {
    encode(_, writer2 = _m02.Writer.create()) {
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseTransition_TransitionCut();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(_) {
      return {};
    },
    toJSON(_) {
      const obj = {};
      return obj;
    },
    fromPartial(_) {
      const message = createBaseTransition_TransitionCut();
      return message;
    }
  };
  function createBaseTransition_TransitionFadeToColor() {
    return { durationMs: 0, backgroundColor: "" };
  }
  exports2.Transition_TransitionFadeToColor = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.durationMs !== 0) {
        writer2.uint32(8).int32(message.durationMs);
      }
      if (message.backgroundColor !== "") {
        writer2.uint32(18).string(message.backgroundColor);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseTransition_TransitionFadeToColor();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.durationMs = reader2.int32();
            break;
          case 2:
            message.backgroundColor = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        durationMs: isSet2(object.durationMs) ? Number(object.durationMs) : 0,
        backgroundColor: isSet2(object.backgroundColor) ? String(object.backgroundColor) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.durationMs !== void 0 && (obj.durationMs = Math.round(message.durationMs));
      message.backgroundColor !== void 0 && (obj.backgroundColor = message.backgroundColor);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseTransition_TransitionFadeToColor();
      message.durationMs = (_a2 = object.durationMs) !== null && _a2 !== void 0 ? _a2 : 0;
      message.backgroundColor = (_b = object.backgroundColor) !== null && _b !== void 0 ? _b : "";
      return message;
    }
  };
  function createBaseTransition_TransitionCrossfade() {
    return { durationMs: 0 };
  }
  exports2.Transition_TransitionCrossfade = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.durationMs !== 0) {
        writer2.uint32(8).int32(message.durationMs);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseTransition_TransitionCrossfade();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.durationMs = reader2.int32();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        durationMs: isSet2(object.durationMs) ? Number(object.durationMs) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.durationMs !== void 0 && (obj.durationMs = Math.round(message.durationMs));
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseTransition_TransitionCrossfade();
      message.durationMs = (_a2 = object.durationMs) !== null && _a2 !== void 0 ? _a2 : 0;
      return message;
    }
  };
  function createBaseTransition_TransitionSwipe() {
    return {
      durationMs: 0,
      direction: Transition_TransitionDirection.TRANSITION_DIRECTION_UNSPECIFIED,
      combinedAnimation: Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_UNSPECIFIED
    };
  }
  exports2.Transition_TransitionSwipe = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.durationMs !== 0) {
        writer2.uint32(8).int32(message.durationMs);
      }
      if (message.direction !== Transition_TransitionDirection.TRANSITION_DIRECTION_UNSPECIFIED) {
        writer2.uint32(16).int32(transition_TransitionDirectionToNumber(message.direction));
      }
      if (message.combinedAnimation !== Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_UNSPECIFIED) {
        writer2.uint32(24).int32(transition_TransitionSwipeTypeToNumber(message.combinedAnimation));
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseTransition_TransitionSwipe();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.durationMs = reader2.int32();
            break;
          case 2:
            message.direction = transition_TransitionDirectionFromJSON(reader2.int32());
            break;
          case 3:
            message.combinedAnimation = transition_TransitionSwipeTypeFromJSON(reader2.int32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        durationMs: isSet2(object.durationMs) ? Number(object.durationMs) : 0,
        direction: isSet2(object.direction) ? transition_TransitionDirectionFromJSON(object.direction) : Transition_TransitionDirection.TRANSITION_DIRECTION_UNSPECIFIED,
        combinedAnimation: isSet2(object.combinedAnimation) ? transition_TransitionSwipeTypeFromJSON(object.combinedAnimation) : Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_UNSPECIFIED
      };
    },
    toJSON(message) {
      const obj = {};
      message.durationMs !== void 0 && (obj.durationMs = Math.round(message.durationMs));
      message.direction !== void 0 && (obj.direction = transition_TransitionDirectionToJSON(message.direction));
      message.combinedAnimation !== void 0 && (obj.combinedAnimation = transition_TransitionSwipeTypeToJSON(message.combinedAnimation));
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseTransition_TransitionSwipe();
      message.durationMs = (_a2 = object.durationMs) !== null && _a2 !== void 0 ? _a2 : 0;
      message.direction = (_b = object.direction) !== null && _b !== void 0 ? _b : Transition_TransitionDirection.TRANSITION_DIRECTION_UNSPECIFIED;
      message.combinedAnimation = (_c = object.combinedAnimation) !== null && _c !== void 0 ? _c : Transition_TransitionSwipeType.TRANSITION_SWIPE_TYPE_UNSPECIFIED;
      return message;
    }
  };
  function createBaseTransition_TransitionStingerCut() {
    return { cutPointMs: 0, media: void 0 };
  }
  exports2.Transition_TransitionStingerCut = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.cutPointMs !== 0) {
        writer2.uint32(8).int32(message.cutPointMs);
      }
      if (message.media !== void 0) {
        exports2.Transition_TransitionMediaType.encode(message.media, writer2.uint32(18).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseTransition_TransitionStingerCut();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.cutPointMs = reader2.int32();
            break;
          case 2:
            message.media = exports2.Transition_TransitionMediaType.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        cutPointMs: isSet2(object.cutPointMs) ? Number(object.cutPointMs) : 0,
        media: isSet2(object.media) ? exports2.Transition_TransitionMediaType.fromJSON(object.media) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.cutPointMs !== void 0 && (obj.cutPointMs = Math.round(message.cutPointMs));
      message.media !== void 0 && (obj.media = message.media ? exports2.Transition_TransitionMediaType.toJSON(message.media) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseTransition_TransitionStingerCut();
      message.cutPointMs = (_a2 = object.cutPointMs) !== null && _a2 !== void 0 ? _a2 : 0;
      message.media = object.media !== void 0 && object.media !== null ? exports2.Transition_TransitionMediaType.fromPartial(object.media) : void 0;
      return message;
    }
  };
  function createBaseTransition_TransitionStinger() {
    return { cut: void 0 };
  }
  exports2.Transition_TransitionStinger = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.cut !== void 0) {
        exports2.Transition_TransitionStingerCut.encode(message.cut, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseTransition_TransitionStinger();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.cut = exports2.Transition_TransitionStingerCut.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        cut: isSet2(object.cut) ? exports2.Transition_TransitionStingerCut.fromJSON(object.cut) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.cut !== void 0 && (obj.cut = message.cut ? exports2.Transition_TransitionStingerCut.toJSON(message.cut) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseTransition_TransitionStinger();
      message.cut = object.cut !== void 0 && object.cut !== null ? exports2.Transition_TransitionStingerCut.fromPartial(object.cut) : void 0;
      return message;
    }
  };
  function createBaseLayout() {
    return {
      id: "",
      width: 0,
      height: 0,
      metadata: void 0,
      projectId: void 0,
      collectionId: void 0,
      type: void 0,
      transitions: [],
      requestMetadata: void 0
    };
  }
  exports2.Layout = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.id !== "") {
        writer2.uint32(10).string(message.id);
      }
      if (message.width !== 0) {
        writer2.uint32(16).int32(message.width);
      }
      if (message.height !== 0) {
        writer2.uint32(24).int32(message.height);
      }
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(50).fork()).ldelim();
      }
      if (message.projectId !== void 0) {
        writer2.uint32(58).string(message.projectId);
      }
      if (message.collectionId !== void 0) {
        writer2.uint32(66).string(message.collectionId);
      }
      if (message.type !== void 0) {
        writer2.uint32(72).int32(layoutTypeToNumber(message.type));
      }
      for (const v of message.transitions) {
        exports2.Transition.encode(v, writer2.uint32(82).fork()).ldelim();
      }
      if (message.requestMetadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(810).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseLayout();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.id = reader2.string();
            break;
          case 2:
            message.width = reader2.int32();
            break;
          case 3:
            message.height = reader2.int32();
            break;
          case 6:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 7:
            message.projectId = reader2.string();
            break;
          case 8:
            message.collectionId = reader2.string();
            break;
          case 9:
            message.type = layoutTypeFromJSON(reader2.int32());
            break;
          case 10:
            message.transitions.push(exports2.Transition.decode(reader2, reader2.uint32()));
            break;
          case 101:
            message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        id: isSet2(object.id) ? String(object.id) : "",
        width: isSet2(object.width) ? Number(object.width) : 0,
        height: isSet2(object.height) ? Number(object.height) : 0,
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0,
        projectId: isSet2(object.projectId) ? String(object.projectId) : void 0,
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : void 0,
        type: isSet2(object.type) ? layoutTypeFromJSON(object.type) : void 0,
        transitions: Array.isArray(object === null || object === void 0 ? void 0 : object.transitions) ? object.transitions.map((e2) => exports2.Transition.fromJSON(e2)) : [],
        requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.id !== void 0 && (obj.id = message.id);
      message.width !== void 0 && (obj.width = Math.round(message.width));
      message.height !== void 0 && (obj.height = Math.round(message.height));
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.type !== void 0 && (obj.type = message.type !== void 0 ? layoutTypeToJSON(message.type) : void 0);
      if (message.transitions) {
        obj.transitions = message.transitions.map((e2) => e2 ? exports2.Transition.toJSON(e2) : void 0);
      } else {
        obj.transitions = [];
      }
      message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
      const message = createBaseLayout();
      message.id = (_a2 = object.id) !== null && _a2 !== void 0 ? _a2 : "";
      message.width = (_b = object.width) !== null && _b !== void 0 ? _b : 0;
      message.height = (_c = object.height) !== null && _c !== void 0 ? _c : 0;
      message.metadata = (_d = object.metadata) !== null && _d !== void 0 ? _d : void 0;
      message.projectId = (_e = object.projectId) !== null && _e !== void 0 ? _e : void 0;
      message.collectionId = (_f = object.collectionId) !== null && _f !== void 0 ? _f : void 0;
      message.type = (_g = object.type) !== null && _g !== void 0 ? _g : void 0;
      message.transitions = ((_h = object.transitions) === null || _h === void 0 ? void 0 : _h.map((e2) => exports2.Transition.fromPartial(e2))) || [];
      message.requestMetadata = (_j = object.requestMetadata) !== null && _j !== void 0 ? _j : void 0;
      return message;
    }
  };
  function createBaseLayer() {
    return {
      type: "",
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: 0,
      opacity: 0,
      scale: 0,
      hidden: false,
      children: void 0,
      metadata: void 0,
      id: "",
      layoutId: "",
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  exports2.Layer = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.type !== "") {
        writer2.uint32(10).string(message.type);
      }
      if (message.data !== void 0) {
        struct_1.Struct.encode(struct_1.Struct.wrap(message.data), writer2.uint32(18).fork()).ldelim();
      }
      if (message.x !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.x), writer2.uint32(26).fork()).ldelim();
      }
      if (message.y !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.y), writer2.uint32(34).fork()).ldelim();
      }
      if (message.width !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.width), writer2.uint32(42).fork()).ldelim();
      }
      if (message.height !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.height), writer2.uint32(50).fork()).ldelim();
      }
      if (message.rotation !== 0) {
        writer2.uint32(57).double(message.rotation);
      }
      if (message.opacity !== 0) {
        writer2.uint32(65).double(message.opacity);
      }
      if (message.scale !== 0) {
        writer2.uint32(73).double(message.scale);
      }
      if (message.hidden === true) {
        writer2.uint32(80).bool(message.hidden);
      }
      if (message.children !== void 0) {
        struct_1.ListValue.encode(struct_1.ListValue.wrap(message.children), writer2.uint32(98).fork()).ldelim();
      }
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(114).fork()).ldelim();
      }
      if (message.id !== "") {
        writer2.uint32(802).string(message.id);
      }
      if (message.layoutId !== "") {
        writer2.uint32(818).string(message.layoutId);
      }
      if (message.requestMetadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(810).fork()).ldelim();
      }
      for (const v of message.requestAnimation) {
        exports2.LayerAnimation.encode(v, writer2.uint32(826).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseLayer();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.type = reader2.string();
            break;
          case 2:
            message.data = struct_1.Struct.unwrap(struct_1.Struct.decode(reader2, reader2.uint32()));
            break;
          case 3:
            message.x = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 4:
            message.y = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 5:
            message.width = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 6:
            message.height = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 7:
            message.rotation = reader2.double();
            break;
          case 8:
            message.opacity = reader2.double();
            break;
          case 9:
            message.scale = reader2.double();
            break;
          case 10:
            message.hidden = reader2.bool();
            break;
          case 12:
            message.children = struct_1.ListValue.unwrap(struct_1.ListValue.decode(reader2, reader2.uint32()));
            break;
          case 14:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 100:
            message.id = reader2.string();
            break;
          case 102:
            message.layoutId = reader2.string();
            break;
          case 101:
            message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 103:
            message.requestAnimation.push(exports2.LayerAnimation.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        type: isSet2(object.type) ? String(object.type) : "",
        data: isObject2(object.data) ? object.data : void 0,
        x: isSet2(object === null || object === void 0 ? void 0 : object.x) ? object.x : void 0,
        y: isSet2(object === null || object === void 0 ? void 0 : object.y) ? object.y : void 0,
        width: isSet2(object === null || object === void 0 ? void 0 : object.width) ? object.width : void 0,
        height: isSet2(object === null || object === void 0 ? void 0 : object.height) ? object.height : void 0,
        rotation: isSet2(object.rotation) ? Number(object.rotation) : 0,
        opacity: isSet2(object.opacity) ? Number(object.opacity) : 0,
        scale: isSet2(object.scale) ? Number(object.scale) : 0,
        hidden: isSet2(object.hidden) ? Boolean(object.hidden) : false,
        children: Array.isArray(object.children) ? [...object.children] : void 0,
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0,
        id: isSet2(object.id) ? String(object.id) : "",
        layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "",
        requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0,
        requestAnimation: Array.isArray(object === null || object === void 0 ? void 0 : object.requestAnimation) ? object.requestAnimation.map((e2) => exports2.LayerAnimation.fromJSON(e2)) : []
      };
    },
    toJSON(message) {
      const obj = {};
      message.type !== void 0 && (obj.type = message.type);
      message.data !== void 0 && (obj.data = message.data);
      message.x !== void 0 && (obj.x = message.x);
      message.y !== void 0 && (obj.y = message.y);
      message.width !== void 0 && (obj.width = message.width);
      message.height !== void 0 && (obj.height = message.height);
      message.rotation !== void 0 && (obj.rotation = message.rotation);
      message.opacity !== void 0 && (obj.opacity = message.opacity);
      message.scale !== void 0 && (obj.scale = message.scale);
      message.hidden !== void 0 && (obj.hidden = message.hidden);
      message.children !== void 0 && (obj.children = message.children);
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.id !== void 0 && (obj.id = message.id);
      message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
      message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
      if (message.requestAnimation) {
        obj.requestAnimation = message.requestAnimation.map((e2) => e2 ? exports2.LayerAnimation.toJSON(e2) : void 0);
      } else {
        obj.requestAnimation = [];
      }
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
      const message = createBaseLayer();
      message.type = (_a2 = object.type) !== null && _a2 !== void 0 ? _a2 : "";
      message.data = (_b = object.data) !== null && _b !== void 0 ? _b : void 0;
      message.x = (_c = object.x) !== null && _c !== void 0 ? _c : void 0;
      message.y = (_d = object.y) !== null && _d !== void 0 ? _d : void 0;
      message.width = (_e = object.width) !== null && _e !== void 0 ? _e : void 0;
      message.height = (_f = object.height) !== null && _f !== void 0 ? _f : void 0;
      message.rotation = (_g = object.rotation) !== null && _g !== void 0 ? _g : 0;
      message.opacity = (_h = object.opacity) !== null && _h !== void 0 ? _h : 0;
      message.scale = (_j = object.scale) !== null && _j !== void 0 ? _j : 0;
      message.hidden = (_k = object.hidden) !== null && _k !== void 0 ? _k : false;
      message.children = (_l = object.children) !== null && _l !== void 0 ? _l : void 0;
      message.metadata = (_m = object.metadata) !== null && _m !== void 0 ? _m : void 0;
      message.id = (_o = object.id) !== null && _o !== void 0 ? _o : "";
      message.layoutId = (_p = object.layoutId) !== null && _p !== void 0 ? _p : "";
      message.requestMetadata = (_q = object.requestMetadata) !== null && _q !== void 0 ? _q : void 0;
      message.requestAnimation = ((_r = object.requestAnimation) === null || _r === void 0 ? void 0 : _r.map((e2) => exports2.LayerAnimation.fromPartial(e2))) || [];
      return message;
    }
  };
  function createBaseDeleteLayerRequest() {
    return { layoutId: "", layerId: "", payload: void 0 };
  }
  exports2.DeleteLayerRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.layoutId !== "") {
        writer2.uint32(10).string(message.layoutId);
      }
      if (message.layerId !== "") {
        writer2.uint32(18).string(message.layerId);
      }
      if (message.payload !== void 0) {
        exports2.DeleteLayerPayload.encode(message.payload, writer2.uint32(26).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDeleteLayerRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.layoutId = reader2.string();
            break;
          case 2:
            message.layerId = reader2.string();
            break;
          case 3:
            message.payload = exports2.DeleteLayerPayload.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "",
        layerId: isSet2(object.layerId) ? String(object.layerId) : "",
        payload: isSet2(object.payload) ? exports2.DeleteLayerPayload.fromJSON(object.payload) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
      message.layerId !== void 0 && (obj.layerId = message.layerId);
      message.payload !== void 0 && (obj.payload = message.payload ? exports2.DeleteLayerPayload.toJSON(message.payload) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseDeleteLayerRequest();
      message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
      message.layerId = (_b = object.layerId) !== null && _b !== void 0 ? _b : "";
      message.payload = object.payload !== void 0 && object.payload !== null ? exports2.DeleteLayerPayload.fromPartial(object.payload) : void 0;
      return message;
    }
  };
  function createBaseDeleteLayerResponse() {
    return { id: "", layoutId: "", requestMetadata: void 0 };
  }
  exports2.DeleteLayerResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.id !== "") {
        writer2.uint32(10).string(message.id);
      }
      if (message.layoutId !== "") {
        writer2.uint32(18).string(message.layoutId);
      }
      if (message.requestMetadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDeleteLayerResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.id = reader2.string();
            break;
          case 2:
            message.layoutId = reader2.string();
            break;
          case 100:
            message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        id: isSet2(object.id) ? String(object.id) : "",
        layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "",
        requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.id !== void 0 && (obj.id = message.id);
      message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
      message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseDeleteLayerResponse();
      message.id = (_a2 = object.id) !== null && _a2 !== void 0 ? _a2 : "";
      message.layoutId = (_b = object.layoutId) !== null && _b !== void 0 ? _b : "";
      message.requestMetadata = (_c = object.requestMetadata) !== null && _c !== void 0 ? _c : void 0;
      return message;
    }
  };
  function createBaseBatchLayerResponse() {
    return {
      layers: [],
      layoutId: "",
      requestMetadata: void 0,
      requestAnimationMode: RequestAnimationMode.REQUEST_ANIMATION_MODE_UNSPECIFIED
    };
  }
  exports2.BatchLayerResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      for (const v of message.layers) {
        exports2.BatchLayerResponse_BatchLayerItem.encode(v, writer2.uint32(18).fork()).ldelim();
      }
      if (message.layoutId !== "") {
        writer2.uint32(26).string(message.layoutId);
      }
      if (message.requestMetadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
      }
      if (message.requestAnimationMode !== RequestAnimationMode.REQUEST_ANIMATION_MODE_UNSPECIFIED) {
        writer2.uint32(808).int32(requestAnimationModeToNumber(message.requestAnimationMode));
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseBatchLayerResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 2:
            message.layers.push(exports2.BatchLayerResponse_BatchLayerItem.decode(reader2, reader2.uint32()));
            break;
          case 3:
            message.layoutId = reader2.string();
            break;
          case 100:
            message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 101:
            message.requestAnimationMode = requestAnimationModeFromJSON(reader2.int32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e2) => exports2.BatchLayerResponse_BatchLayerItem.fromJSON(e2)) : [],
        layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "",
        requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0,
        requestAnimationMode: isSet2(object.requestAnimationMode) ? requestAnimationModeFromJSON(object.requestAnimationMode) : RequestAnimationMode.REQUEST_ANIMATION_MODE_UNSPECIFIED
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.layers) {
        obj.layers = message.layers.map((e2) => e2 ? exports2.BatchLayerResponse_BatchLayerItem.toJSON(e2) : void 0);
      } else {
        obj.layers = [];
      }
      message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
      message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
      message.requestAnimationMode !== void 0 && (obj.requestAnimationMode = requestAnimationModeToJSON(message.requestAnimationMode));
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d;
      const message = createBaseBatchLayerResponse();
      message.layers = ((_a2 = object.layers) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports2.BatchLayerResponse_BatchLayerItem.fromPartial(e2))) || [];
      message.layoutId = (_b = object.layoutId) !== null && _b !== void 0 ? _b : "";
      message.requestMetadata = (_c = object.requestMetadata) !== null && _c !== void 0 ? _c : void 0;
      message.requestAnimationMode = (_d = object.requestAnimationMode) !== null && _d !== void 0 ? _d : RequestAnimationMode.REQUEST_ANIMATION_MODE_UNSPECIFIED;
      return message;
    }
  };
  function createBaseBatchLayerResponse_BatchLayerItem() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  exports2.BatchLayerResponse_BatchLayerItem = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.create !== void 0) {
        exports2.Layer.encode(message.create, writer2.uint32(10).fork()).ldelim();
      }
      if (message.update !== void 0) {
        exports2.Layer.encode(message.update, writer2.uint32(18).fork()).ldelim();
      }
      if (message.delete !== void 0) {
        exports2.DeleteLayerResponse.encode(message.delete, writer2.uint32(26).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseBatchLayerResponse_BatchLayerItem();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.create = exports2.Layer.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.update = exports2.Layer.decode(reader2, reader2.uint32());
            break;
          case 3:
            message.delete = exports2.DeleteLayerResponse.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        create: isSet2(object.create) ? exports2.Layer.fromJSON(object.create) : void 0,
        update: isSet2(object.update) ? exports2.Layer.fromJSON(object.update) : void 0,
        delete: isSet2(object.delete) ? exports2.DeleteLayerResponse.fromJSON(object.delete) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.create !== void 0 && (obj.create = message.create ? exports2.Layer.toJSON(message.create) : void 0);
      message.update !== void 0 && (obj.update = message.update ? exports2.Layer.toJSON(message.update) : void 0);
      message.delete !== void 0 && (obj.delete = message.delete ? exports2.DeleteLayerResponse.toJSON(message.delete) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseBatchLayerResponse_BatchLayerItem();
      message.create = object.create !== void 0 && object.create !== null ? exports2.Layer.fromPartial(object.create) : void 0;
      message.update = object.update !== void 0 && object.update !== null ? exports2.Layer.fromPartial(object.update) : void 0;
      message.delete = object.delete !== void 0 && object.delete !== null ? exports2.DeleteLayerResponse.fromPartial(object.delete) : void 0;
      return message;
    }
  };
  function createBasePartialLayout() {
    return {
      width: void 0,
      height: void 0,
      metadata: void 0,
      projectId: void 0,
      collectionId: void 0,
      type: void 0,
      transitions: [],
      requestMetadata: void 0
    };
  }
  exports2.PartialLayout = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.width !== void 0) {
        writer2.uint32(16).int32(message.width);
      }
      if (message.height !== void 0) {
        writer2.uint32(24).int32(message.height);
      }
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(50).fork()).ldelim();
      }
      if (message.projectId !== void 0) {
        writer2.uint32(58).string(message.projectId);
      }
      if (message.collectionId !== void 0) {
        writer2.uint32(66).string(message.collectionId);
      }
      if (message.type !== void 0) {
        writer2.uint32(72).int32(layoutTypeToNumber(message.type));
      }
      for (const v of message.transitions) {
        exports2.Transition.encode(v, writer2.uint32(82).fork()).ldelim();
      }
      if (message.requestMetadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(810).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBasePartialLayout();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 2:
            message.width = reader2.int32();
            break;
          case 3:
            message.height = reader2.int32();
            break;
          case 6:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 7:
            message.projectId = reader2.string();
            break;
          case 8:
            message.collectionId = reader2.string();
            break;
          case 9:
            message.type = layoutTypeFromJSON(reader2.int32());
            break;
          case 10:
            message.transitions.push(exports2.Transition.decode(reader2, reader2.uint32()));
            break;
          case 101:
            message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        width: isSet2(object.width) ? Number(object.width) : void 0,
        height: isSet2(object.height) ? Number(object.height) : void 0,
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0,
        projectId: isSet2(object.projectId) ? String(object.projectId) : void 0,
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : void 0,
        type: isSet2(object.type) ? layoutTypeFromJSON(object.type) : void 0,
        transitions: Array.isArray(object === null || object === void 0 ? void 0 : object.transitions) ? object.transitions.map((e2) => exports2.Transition.fromJSON(e2)) : [],
        requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.width !== void 0 && (obj.width = Math.round(message.width));
      message.height !== void 0 && (obj.height = Math.round(message.height));
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.type !== void 0 && (obj.type = message.type !== void 0 ? layoutTypeToJSON(message.type) : void 0);
      if (message.transitions) {
        obj.transitions = message.transitions.map((e2) => e2 ? exports2.Transition.toJSON(e2) : void 0);
      } else {
        obj.transitions = [];
      }
      message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e, _f, _g, _h;
      const message = createBasePartialLayout();
      message.width = (_a2 = object.width) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.height = (_b = object.height) !== null && _b !== void 0 ? _b : void 0;
      message.metadata = (_c = object.metadata) !== null && _c !== void 0 ? _c : void 0;
      message.projectId = (_d = object.projectId) !== null && _d !== void 0 ? _d : void 0;
      message.collectionId = (_e = object.collectionId) !== null && _e !== void 0 ? _e : void 0;
      message.type = (_f = object.type) !== null && _f !== void 0 ? _f : void 0;
      message.transitions = ((_g = object.transitions) === null || _g === void 0 ? void 0 : _g.map((e2) => exports2.Transition.fromPartial(e2))) || [];
      message.requestMetadata = (_h = object.requestMetadata) !== null && _h !== void 0 ? _h : void 0;
      return message;
    }
  };
  function createBaseListLayoutsRequest() {
    return { projectId: void 0, collectionId: void 0, type: void 0 };
  }
  exports2.ListLayoutsRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.projectId !== void 0) {
        writer2.uint32(10).string(message.projectId);
      }
      if (message.collectionId !== void 0) {
        writer2.uint32(18).string(message.collectionId);
      }
      if (message.type !== void 0) {
        writer2.uint32(24).int32(layoutTypeToNumber(message.type));
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseListLayoutsRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.projectId = reader2.string();
            break;
          case 2:
            message.collectionId = reader2.string();
            break;
          case 3:
            message.type = layoutTypeFromJSON(reader2.int32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        projectId: isSet2(object.projectId) ? String(object.projectId) : void 0,
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : void 0,
        type: isSet2(object.type) ? layoutTypeFromJSON(object.type) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.type !== void 0 && (obj.type = message.type !== void 0 ? layoutTypeToJSON(message.type) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseListLayoutsRequest();
      message.projectId = (_a2 = object.projectId) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.collectionId = (_b = object.collectionId) !== null && _b !== void 0 ? _b : void 0;
      message.type = (_c = object.type) !== null && _c !== void 0 ? _c : void 0;
      return message;
    }
  };
  function createBaseListLayoutsResponse() {
    return { layouts: [] };
  }
  exports2.ListLayoutsResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      for (const v of message.layouts) {
        exports2.Layout.encode(v, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseListLayoutsResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.layouts.push(exports2.Layout.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        layouts: Array.isArray(object === null || object === void 0 ? void 0 : object.layouts) ? object.layouts.map((e2) => exports2.Layout.fromJSON(e2)) : []
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.layouts) {
        obj.layouts = message.layouts.map((e2) => e2 ? exports2.Layout.toJSON(e2) : void 0);
      } else {
        obj.layouts = [];
      }
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseListLayoutsResponse();
      message.layouts = ((_a2 = object.layouts) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports2.Layout.fromPartial(e2))) || [];
      return message;
    }
  };
  function createBaseCreateLayoutRequest() {
    return { layout: void 0 };
  }
  exports2.CreateLayoutRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.layout !== void 0) {
        exports2.PartialLayout.encode(message.layout, writer2.uint32(18).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCreateLayoutRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 2:
            message.layout = exports2.PartialLayout.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        layout: isSet2(object.layout) ? exports2.PartialLayout.fromJSON(object.layout) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.layout !== void 0 && (obj.layout = message.layout ? exports2.PartialLayout.toJSON(message.layout) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseCreateLayoutRequest();
      message.layout = object.layout !== void 0 && object.layout !== null ? exports2.PartialLayout.fromPartial(object.layout) : void 0;
      return message;
    }
  };
  function createBaseGetLayoutRequest() {
    return { layoutId: "" };
  }
  exports2.GetLayoutRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.layoutId !== "") {
        writer2.uint32(10).string(message.layoutId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetLayoutRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.layoutId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        layoutId: isSet2(object.layoutId) ? String(object.layoutId) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseGetLayoutRequest();
      message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
      return message;
    }
  };
  function createBaseUpdateLayoutRequest() {
    return { layoutId: "", layout: void 0 };
  }
  exports2.UpdateLayoutRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.layoutId !== "") {
        writer2.uint32(10).string(message.layoutId);
      }
      if (message.layout !== void 0) {
        exports2.PartialLayout.encode(message.layout, writer2.uint32(26).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseUpdateLayoutRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.layoutId = reader2.string();
            break;
          case 3:
            message.layout = exports2.PartialLayout.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "",
        layout: isSet2(object.layout) ? exports2.PartialLayout.fromJSON(object.layout) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
      message.layout !== void 0 && (obj.layout = message.layout ? exports2.PartialLayout.toJSON(message.layout) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseUpdateLayoutRequest();
      message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
      message.layout = object.layout !== void 0 && object.layout !== null ? exports2.PartialLayout.fromPartial(object.layout) : void 0;
      return message;
    }
  };
  function createBaseDeleteLayoutPayload() {
    return { requestMetadata: void 0 };
  }
  exports2.DeleteLayoutPayload = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.requestMetadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDeleteLayoutPayload();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 100:
            message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseDeleteLayoutPayload();
      message.requestMetadata = (_a2 = object.requestMetadata) !== null && _a2 !== void 0 ? _a2 : void 0;
      return message;
    }
  };
  function createBaseDeleteLayoutRequest() {
    return { layoutId: "", payload: void 0 };
  }
  exports2.DeleteLayoutRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.layoutId !== "") {
        writer2.uint32(10).string(message.layoutId);
      }
      if (message.payload !== void 0) {
        exports2.DeleteLayoutPayload.encode(message.payload, writer2.uint32(18).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDeleteLayoutRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.layoutId = reader2.string();
            break;
          case 2:
            message.payload = exports2.DeleteLayoutPayload.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "",
        payload: isSet2(object.payload) ? exports2.DeleteLayoutPayload.fromJSON(object.payload) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
      message.payload !== void 0 && (obj.payload = message.payload ? exports2.DeleteLayoutPayload.toJSON(message.payload) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseDeleteLayoutRequest();
      message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
      message.payload = object.payload !== void 0 && object.payload !== null ? exports2.DeleteLayoutPayload.fromPartial(object.payload) : void 0;
      return message;
    }
  };
  function createBaseDeleteLayoutResponse() {
    return { id: "", requestMetadata: void 0 };
  }
  exports2.DeleteLayoutResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.id !== "") {
        writer2.uint32(18).string(message.id);
      }
      if (message.requestMetadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDeleteLayoutResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 2:
            message.id = reader2.string();
            break;
          case 100:
            message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        id: isSet2(object.id) ? String(object.id) : "",
        requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.id !== void 0 && (obj.id = message.id);
      message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseDeleteLayoutResponse();
      message.id = (_a2 = object.id) !== null && _a2 !== void 0 ? _a2 : "";
      message.requestMetadata = (_b = object.requestMetadata) !== null && _b !== void 0 ? _b : void 0;
      return message;
    }
  };
  function createBaseLayerAnimation() {
    return {
      properties: [],
      durationMs: 0,
      delayMs: void 0,
      easingMode: void 0
    };
  }
  exports2.LayerAnimation = {
    encode(message, writer2 = _m02.Writer.create()) {
      for (const v of message.properties) {
        writer2.uint32(10).string(v);
      }
      if (message.durationMs !== 0) {
        writer2.uint32(16).int32(message.durationMs);
      }
      if (message.delayMs !== void 0) {
        writer2.uint32(32).int32(message.delayMs);
      }
      if (message.easingMode !== void 0) {
        writer2.uint32(42).string(message.easingMode);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseLayerAnimation();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.properties.push(reader2.string());
            break;
          case 2:
            message.durationMs = reader2.int32();
            break;
          case 4:
            message.delayMs = reader2.int32();
            break;
          case 5:
            message.easingMode = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        properties: Array.isArray(object === null || object === void 0 ? void 0 : object.properties) ? object.properties.map((e2) => String(e2)) : [],
        durationMs: isSet2(object.durationMs) ? Number(object.durationMs) : 0,
        delayMs: isSet2(object.delayMs) ? Number(object.delayMs) : void 0,
        easingMode: isSet2(object.easingMode) ? String(object.easingMode) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.properties) {
        obj.properties = message.properties.map((e2) => e2);
      } else {
        obj.properties = [];
      }
      message.durationMs !== void 0 && (obj.durationMs = Math.round(message.durationMs));
      message.delayMs !== void 0 && (obj.delayMs = Math.round(message.delayMs));
      message.easingMode !== void 0 && (obj.easingMode = message.easingMode);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d;
      const message = createBaseLayerAnimation();
      message.properties = ((_a2 = object.properties) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
      message.durationMs = (_b = object.durationMs) !== null && _b !== void 0 ? _b : 0;
      message.delayMs = (_c = object.delayMs) !== null && _c !== void 0 ? _c : void 0;
      message.easingMode = (_d = object.easingMode) !== null && _d !== void 0 ? _d : void 0;
      return message;
    }
  };
  function createBasePartialLayer() {
    return {
      type: void 0,
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: void 0,
      opacity: void 0,
      scale: void 0,
      hidden: void 0,
      children: void 0,
      parentId: void 0,
      metadata: void 0,
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  exports2.PartialLayer = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.type !== void 0) {
        writer2.uint32(10).string(message.type);
      }
      if (message.data !== void 0) {
        struct_1.Struct.encode(struct_1.Struct.wrap(message.data), writer2.uint32(18).fork()).ldelim();
      }
      if (message.x !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.x), writer2.uint32(26).fork()).ldelim();
      }
      if (message.y !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.y), writer2.uint32(34).fork()).ldelim();
      }
      if (message.width !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.width), writer2.uint32(42).fork()).ldelim();
      }
      if (message.height !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.height), writer2.uint32(50).fork()).ldelim();
      }
      if (message.rotation !== void 0) {
        writer2.uint32(57).double(message.rotation);
      }
      if (message.opacity !== void 0) {
        writer2.uint32(65).double(message.opacity);
      }
      if (message.scale !== void 0) {
        writer2.uint32(73).double(message.scale);
      }
      if (message.hidden !== void 0) {
        writer2.uint32(80).bool(message.hidden);
      }
      if (message.children !== void 0) {
        struct_1.ListValue.encode(struct_1.ListValue.wrap(message.children), writer2.uint32(98).fork()).ldelim();
      }
      if (message.parentId !== void 0) {
        writer2.uint32(106).string(message.parentId);
      }
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(114).fork()).ldelim();
      }
      if (message.requestMetadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
      }
      for (const v of message.requestAnimation) {
        exports2.LayerAnimation.encode(v, writer2.uint32(826).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBasePartialLayer();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.type = reader2.string();
            break;
          case 2:
            message.data = struct_1.Struct.unwrap(struct_1.Struct.decode(reader2, reader2.uint32()));
            break;
          case 3:
            message.x = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 4:
            message.y = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 5:
            message.width = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 6:
            message.height = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 7:
            message.rotation = reader2.double();
            break;
          case 8:
            message.opacity = reader2.double();
            break;
          case 9:
            message.scale = reader2.double();
            break;
          case 10:
            message.hidden = reader2.bool();
            break;
          case 12:
            message.children = struct_1.ListValue.unwrap(struct_1.ListValue.decode(reader2, reader2.uint32()));
            break;
          case 13:
            message.parentId = reader2.string();
            break;
          case 14:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 100:
            message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 103:
            message.requestAnimation.push(exports2.LayerAnimation.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        type: isSet2(object.type) ? String(object.type) : void 0,
        data: isObject2(object.data) ? object.data : void 0,
        x: isSet2(object === null || object === void 0 ? void 0 : object.x) ? object.x : void 0,
        y: isSet2(object === null || object === void 0 ? void 0 : object.y) ? object.y : void 0,
        width: isSet2(object === null || object === void 0 ? void 0 : object.width) ? object.width : void 0,
        height: isSet2(object === null || object === void 0 ? void 0 : object.height) ? object.height : void 0,
        rotation: isSet2(object.rotation) ? Number(object.rotation) : void 0,
        opacity: isSet2(object.opacity) ? Number(object.opacity) : void 0,
        scale: isSet2(object.scale) ? Number(object.scale) : void 0,
        hidden: isSet2(object.hidden) ? Boolean(object.hidden) : void 0,
        children: Array.isArray(object.children) ? [...object.children] : void 0,
        parentId: isSet2(object.parentId) ? String(object.parentId) : void 0,
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0,
        requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0,
        requestAnimation: Array.isArray(object === null || object === void 0 ? void 0 : object.requestAnimation) ? object.requestAnimation.map((e2) => exports2.LayerAnimation.fromJSON(e2)) : []
      };
    },
    toJSON(message) {
      const obj = {};
      message.type !== void 0 && (obj.type = message.type);
      message.data !== void 0 && (obj.data = message.data);
      message.x !== void 0 && (obj.x = message.x);
      message.y !== void 0 && (obj.y = message.y);
      message.width !== void 0 && (obj.width = message.width);
      message.height !== void 0 && (obj.height = message.height);
      message.rotation !== void 0 && (obj.rotation = message.rotation);
      message.opacity !== void 0 && (obj.opacity = message.opacity);
      message.scale !== void 0 && (obj.scale = message.scale);
      message.hidden !== void 0 && (obj.hidden = message.hidden);
      message.children !== void 0 && (obj.children = message.children);
      message.parentId !== void 0 && (obj.parentId = message.parentId);
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
      if (message.requestAnimation) {
        obj.requestAnimation = message.requestAnimation.map((e2) => e2 ? exports2.LayerAnimation.toJSON(e2) : void 0);
      } else {
        obj.requestAnimation = [];
      }
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
      const message = createBasePartialLayer();
      message.type = (_a2 = object.type) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.data = (_b = object.data) !== null && _b !== void 0 ? _b : void 0;
      message.x = (_c = object.x) !== null && _c !== void 0 ? _c : void 0;
      message.y = (_d = object.y) !== null && _d !== void 0 ? _d : void 0;
      message.width = (_e = object.width) !== null && _e !== void 0 ? _e : void 0;
      message.height = (_f = object.height) !== null && _f !== void 0 ? _f : void 0;
      message.rotation = (_g = object.rotation) !== null && _g !== void 0 ? _g : void 0;
      message.opacity = (_h = object.opacity) !== null && _h !== void 0 ? _h : void 0;
      message.scale = (_j = object.scale) !== null && _j !== void 0 ? _j : void 0;
      message.hidden = (_k = object.hidden) !== null && _k !== void 0 ? _k : void 0;
      message.children = (_l = object.children) !== null && _l !== void 0 ? _l : void 0;
      message.parentId = (_m = object.parentId) !== null && _m !== void 0 ? _m : void 0;
      message.metadata = (_o = object.metadata) !== null && _o !== void 0 ? _o : void 0;
      message.requestMetadata = (_p = object.requestMetadata) !== null && _p !== void 0 ? _p : void 0;
      message.requestAnimation = ((_q = object.requestAnimation) === null || _q === void 0 ? void 0 : _q.map((e2) => exports2.LayerAnimation.fromPartial(e2))) || [];
      return message;
    }
  };
  function createBasePartialLayerWithID() {
    return {
      id: "",
      type: void 0,
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: void 0,
      opacity: void 0,
      scale: void 0,
      hidden: void 0,
      children: void 0,
      parentId: void 0,
      metadata: void 0,
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  exports2.PartialLayerWithID = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.id !== "") {
        writer2.uint32(8002).string(message.id);
      }
      if (message.type !== void 0) {
        writer2.uint32(10).string(message.type);
      }
      if (message.data !== void 0) {
        struct_1.Struct.encode(struct_1.Struct.wrap(message.data), writer2.uint32(18).fork()).ldelim();
      }
      if (message.x !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.x), writer2.uint32(26).fork()).ldelim();
      }
      if (message.y !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.y), writer2.uint32(34).fork()).ldelim();
      }
      if (message.width !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.width), writer2.uint32(42).fork()).ldelim();
      }
      if (message.height !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.height), writer2.uint32(50).fork()).ldelim();
      }
      if (message.rotation !== void 0) {
        writer2.uint32(57).double(message.rotation);
      }
      if (message.opacity !== void 0) {
        writer2.uint32(65).double(message.opacity);
      }
      if (message.scale !== void 0) {
        writer2.uint32(73).double(message.scale);
      }
      if (message.hidden !== void 0) {
        writer2.uint32(80).bool(message.hidden);
      }
      if (message.children !== void 0) {
        struct_1.ListValue.encode(struct_1.ListValue.wrap(message.children), writer2.uint32(98).fork()).ldelim();
      }
      if (message.parentId !== void 0) {
        writer2.uint32(106).string(message.parentId);
      }
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(114).fork()).ldelim();
      }
      if (message.requestMetadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
      }
      for (const v of message.requestAnimation) {
        exports2.LayerAnimation.encode(v, writer2.uint32(826).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBasePartialLayerWithID();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1e3:
            message.id = reader2.string();
            break;
          case 1:
            message.type = reader2.string();
            break;
          case 2:
            message.data = struct_1.Struct.unwrap(struct_1.Struct.decode(reader2, reader2.uint32()));
            break;
          case 3:
            message.x = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 4:
            message.y = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 5:
            message.width = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 6:
            message.height = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 7:
            message.rotation = reader2.double();
            break;
          case 8:
            message.opacity = reader2.double();
            break;
          case 9:
            message.scale = reader2.double();
            break;
          case 10:
            message.hidden = reader2.bool();
            break;
          case 12:
            message.children = struct_1.ListValue.unwrap(struct_1.ListValue.decode(reader2, reader2.uint32()));
            break;
          case 13:
            message.parentId = reader2.string();
            break;
          case 14:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 100:
            message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 103:
            message.requestAnimation.push(exports2.LayerAnimation.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        id: isSet2(object.id) ? String(object.id) : "",
        type: isSet2(object.type) ? String(object.type) : void 0,
        data: isObject2(object.data) ? object.data : void 0,
        x: isSet2(object === null || object === void 0 ? void 0 : object.x) ? object.x : void 0,
        y: isSet2(object === null || object === void 0 ? void 0 : object.y) ? object.y : void 0,
        width: isSet2(object === null || object === void 0 ? void 0 : object.width) ? object.width : void 0,
        height: isSet2(object === null || object === void 0 ? void 0 : object.height) ? object.height : void 0,
        rotation: isSet2(object.rotation) ? Number(object.rotation) : void 0,
        opacity: isSet2(object.opacity) ? Number(object.opacity) : void 0,
        scale: isSet2(object.scale) ? Number(object.scale) : void 0,
        hidden: isSet2(object.hidden) ? Boolean(object.hidden) : void 0,
        children: Array.isArray(object.children) ? [...object.children] : void 0,
        parentId: isSet2(object.parentId) ? String(object.parentId) : void 0,
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0,
        requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0,
        requestAnimation: Array.isArray(object === null || object === void 0 ? void 0 : object.requestAnimation) ? object.requestAnimation.map((e2) => exports2.LayerAnimation.fromJSON(e2)) : []
      };
    },
    toJSON(message) {
      const obj = {};
      message.id !== void 0 && (obj.id = message.id);
      message.type !== void 0 && (obj.type = message.type);
      message.data !== void 0 && (obj.data = message.data);
      message.x !== void 0 && (obj.x = message.x);
      message.y !== void 0 && (obj.y = message.y);
      message.width !== void 0 && (obj.width = message.width);
      message.height !== void 0 && (obj.height = message.height);
      message.rotation !== void 0 && (obj.rotation = message.rotation);
      message.opacity !== void 0 && (obj.opacity = message.opacity);
      message.scale !== void 0 && (obj.scale = message.scale);
      message.hidden !== void 0 && (obj.hidden = message.hidden);
      message.children !== void 0 && (obj.children = message.children);
      message.parentId !== void 0 && (obj.parentId = message.parentId);
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
      if (message.requestAnimation) {
        obj.requestAnimation = message.requestAnimation.map((e2) => e2 ? exports2.LayerAnimation.toJSON(e2) : void 0);
      } else {
        obj.requestAnimation = [];
      }
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
      const message = createBasePartialLayerWithID();
      message.id = (_a2 = object.id) !== null && _a2 !== void 0 ? _a2 : "";
      message.type = (_b = object.type) !== null && _b !== void 0 ? _b : void 0;
      message.data = (_c = object.data) !== null && _c !== void 0 ? _c : void 0;
      message.x = (_d = object.x) !== null && _d !== void 0 ? _d : void 0;
      message.y = (_e = object.y) !== null && _e !== void 0 ? _e : void 0;
      message.width = (_f = object.width) !== null && _f !== void 0 ? _f : void 0;
      message.height = (_g = object.height) !== null && _g !== void 0 ? _g : void 0;
      message.rotation = (_h = object.rotation) !== null && _h !== void 0 ? _h : void 0;
      message.opacity = (_j = object.opacity) !== null && _j !== void 0 ? _j : void 0;
      message.scale = (_k = object.scale) !== null && _k !== void 0 ? _k : void 0;
      message.hidden = (_l = object.hidden) !== null && _l !== void 0 ? _l : void 0;
      message.children = (_m = object.children) !== null && _m !== void 0 ? _m : void 0;
      message.parentId = (_o = object.parentId) !== null && _o !== void 0 ? _o : void 0;
      message.metadata = (_p = object.metadata) !== null && _p !== void 0 ? _p : void 0;
      message.requestMetadata = (_q = object.requestMetadata) !== null && _q !== void 0 ? _q : void 0;
      message.requestAnimation = ((_r = object.requestAnimation) === null || _r === void 0 ? void 0 : _r.map((e2) => exports2.LayerAnimation.fromPartial(e2))) || [];
      return message;
    }
  };
  function createBaseListLayersRequest() {
    return { layoutId: "" };
  }
  exports2.ListLayersRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.layoutId !== "") {
        writer2.uint32(10).string(message.layoutId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseListLayersRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.layoutId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        layoutId: isSet2(object.layoutId) ? String(object.layoutId) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseListLayersRequest();
      message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
      return message;
    }
  };
  function createBaseListLayersResponse() {
    return { layers: [] };
  }
  exports2.ListLayersResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      for (const v of message.layers) {
        exports2.Layer.encode(v, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseListLayersResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.layers.push(exports2.Layer.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e2) => exports2.Layer.fromJSON(e2)) : []
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.layers) {
        obj.layers = message.layers.map((e2) => e2 ? exports2.Layer.toJSON(e2) : void 0);
      } else {
        obj.layers = [];
      }
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseListLayersResponse();
      message.layers = ((_a2 = object.layers) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports2.Layer.fromPartial(e2))) || [];
      return message;
    }
  };
  function createBaseCreateLayerRequest() {
    return { layoutId: "", layer: void 0 };
  }
  exports2.CreateLayerRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.layoutId !== "") {
        writer2.uint32(10).string(message.layoutId);
      }
      if (message.layer !== void 0) {
        exports2.PartialLayer.encode(message.layer, writer2.uint32(18).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCreateLayerRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.layoutId = reader2.string();
            break;
          case 2:
            message.layer = exports2.PartialLayer.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "",
        layer: isSet2(object.layer) ? exports2.PartialLayer.fromJSON(object.layer) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
      message.layer !== void 0 && (obj.layer = message.layer ? exports2.PartialLayer.toJSON(message.layer) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseCreateLayerRequest();
      message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
      message.layer = object.layer !== void 0 && object.layer !== null ? exports2.PartialLayer.fromPartial(object.layer) : void 0;
      return message;
    }
  };
  function createBaseGetLayerRequest() {
    return { layoutId: "", layerId: "" };
  }
  exports2.GetLayerRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.layoutId !== "") {
        writer2.uint32(10).string(message.layoutId);
      }
      if (message.layerId !== "") {
        writer2.uint32(18).string(message.layerId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetLayerRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.layoutId = reader2.string();
            break;
          case 2:
            message.layerId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "",
        layerId: isSet2(object.layerId) ? String(object.layerId) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
      message.layerId !== void 0 && (obj.layerId = message.layerId);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseGetLayerRequest();
      message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
      message.layerId = (_b = object.layerId) !== null && _b !== void 0 ? _b : "";
      return message;
    }
  };
  function createBaseUpdateLayerRequest() {
    return { layoutId: "", layerId: "", layer: void 0 };
  }
  exports2.UpdateLayerRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.layoutId !== "") {
        writer2.uint32(10).string(message.layoutId);
      }
      if (message.layerId !== "") {
        writer2.uint32(18).string(message.layerId);
      }
      if (message.layer !== void 0) {
        exports2.PartialLayer.encode(message.layer, writer2.uint32(26).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseUpdateLayerRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.layoutId = reader2.string();
            break;
          case 2:
            message.layerId = reader2.string();
            break;
          case 3:
            message.layer = exports2.PartialLayer.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "",
        layerId: isSet2(object.layerId) ? String(object.layerId) : "",
        layer: isSet2(object.layer) ? exports2.PartialLayer.fromJSON(object.layer) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
      message.layerId !== void 0 && (obj.layerId = message.layerId);
      message.layer !== void 0 && (obj.layer = message.layer ? exports2.PartialLayer.toJSON(message.layer) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseUpdateLayerRequest();
      message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
      message.layerId = (_b = object.layerId) !== null && _b !== void 0 ? _b : "";
      message.layer = object.layer !== void 0 && object.layer !== null ? exports2.PartialLayer.fromPartial(object.layer) : void 0;
      return message;
    }
  };
  function createBaseDeleteLayerPayload() {
    return { requestMetadata: void 0 };
  }
  exports2.DeleteLayerPayload = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.requestMetadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDeleteLayerPayload();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 100:
            message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseDeleteLayerPayload();
      message.requestMetadata = (_a2 = object.requestMetadata) !== null && _a2 !== void 0 ? _a2 : void 0;
      return message;
    }
  };
  function createBaseBatchDeleteLayerRequest() {
    return { id: "", requestMetadata: void 0 };
  }
  exports2.BatchDeleteLayerRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.id !== "") {
        writer2.uint32(10).string(message.id);
      }
      if (message.requestMetadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseBatchDeleteLayerRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.id = reader2.string();
            break;
          case 100:
            message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        id: isSet2(object.id) ? String(object.id) : "",
        requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.id !== void 0 && (obj.id = message.id);
      message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseBatchDeleteLayerRequest();
      message.id = (_a2 = object.id) !== null && _a2 !== void 0 ? _a2 : "";
      message.requestMetadata = (_b = object.requestMetadata) !== null && _b !== void 0 ? _b : void 0;
      return message;
    }
  };
  function createBaseBatchLayerRequest() {
    return {
      layoutId: "",
      layers: [],
      requestMetadata: void 0,
      requestAnimationMode: void 0
    };
  }
  exports2.BatchLayerRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.layoutId !== "") {
        writer2.uint32(10).string(message.layoutId);
      }
      for (const v of message.layers) {
        exports2.BatchLayerRequest_BatchItem.encode(v, writer2.uint32(18).fork()).ldelim();
      }
      if (message.requestMetadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(802).fork()).ldelim();
      }
      if (message.requestAnimationMode !== void 0) {
        writer2.uint32(808).int32(requestAnimationModeToNumber(message.requestAnimationMode));
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseBatchLayerRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.layoutId = reader2.string();
            break;
          case 2:
            message.layers.push(exports2.BatchLayerRequest_BatchItem.decode(reader2, reader2.uint32()));
            break;
          case 100:
            message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 101:
            message.requestAnimationMode = requestAnimationModeFromJSON(reader2.int32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        layoutId: isSet2(object.layoutId) ? String(object.layoutId) : "",
        layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e2) => exports2.BatchLayerRequest_BatchItem.fromJSON(e2)) : [],
        requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0,
        requestAnimationMode: isSet2(object.requestAnimationMode) ? requestAnimationModeFromJSON(object.requestAnimationMode) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
      if (message.layers) {
        obj.layers = message.layers.map((e2) => e2 ? exports2.BatchLayerRequest_BatchItem.toJSON(e2) : void 0);
      } else {
        obj.layers = [];
      }
      message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
      message.requestAnimationMode !== void 0 && (obj.requestAnimationMode = message.requestAnimationMode !== void 0 ? requestAnimationModeToJSON(message.requestAnimationMode) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d;
      const message = createBaseBatchLayerRequest();
      message.layoutId = (_a2 = object.layoutId) !== null && _a2 !== void 0 ? _a2 : "";
      message.layers = ((_b = object.layers) === null || _b === void 0 ? void 0 : _b.map((e2) => exports2.BatchLayerRequest_BatchItem.fromPartial(e2))) || [];
      message.requestMetadata = (_c = object.requestMetadata) !== null && _c !== void 0 ? _c : void 0;
      message.requestAnimationMode = (_d = object.requestAnimationMode) !== null && _d !== void 0 ? _d : void 0;
      return message;
    }
  };
  function createBaseBatchLayerRequest_BatchItem() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  exports2.BatchLayerRequest_BatchItem = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.create !== void 0) {
        exports2.PartialLayer.encode(message.create, writer2.uint32(10).fork()).ldelim();
      }
      if (message.update !== void 0) {
        exports2.PartialLayerWithID.encode(message.update, writer2.uint32(18).fork()).ldelim();
      }
      if (message.delete !== void 0) {
        exports2.BatchDeleteLayerRequest.encode(message.delete, writer2.uint32(26).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseBatchLayerRequest_BatchItem();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.create = exports2.PartialLayer.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.update = exports2.PartialLayerWithID.decode(reader2, reader2.uint32());
            break;
          case 3:
            message.delete = exports2.BatchDeleteLayerRequest.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        create: isSet2(object.create) ? exports2.PartialLayer.fromJSON(object.create) : void 0,
        update: isSet2(object.update) ? exports2.PartialLayerWithID.fromJSON(object.update) : void 0,
        delete: isSet2(object.delete) ? exports2.BatchDeleteLayerRequest.fromJSON(object.delete) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.create !== void 0 && (obj.create = message.create ? exports2.PartialLayer.toJSON(message.create) : void 0);
      message.update !== void 0 && (obj.update = message.update ? exports2.PartialLayerWithID.toJSON(message.update) : void 0);
      message.delete !== void 0 && (obj.delete = message.delete ? exports2.BatchDeleteLayerRequest.toJSON(message.delete) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseBatchLayerRequest_BatchItem();
      message.create = object.create !== void 0 && object.create !== null ? exports2.PartialLayer.fromPartial(object.create) : void 0;
      message.update = object.update !== void 0 && object.update !== null ? exports2.PartialLayerWithID.fromPartial(object.update) : void 0;
      message.delete = object.delete !== void 0 && object.delete !== null ? exports2.BatchDeleteLayerRequest.fromPartial(object.delete) : void 0;
      return message;
    }
  };
  function createBaseLayoutEvent() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  exports2.LayoutEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.create !== void 0) {
        exports2.Layout.encode(message.create, writer2.uint32(10).fork()).ldelim();
      }
      if (message.update !== void 0) {
        exports2.Layout.encode(message.update, writer2.uint32(18).fork()).ldelim();
      }
      if (message.delete !== void 0) {
        exports2.DeleteLayoutResponse.encode(message.delete, writer2.uint32(26).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseLayoutEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.create = exports2.Layout.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.update = exports2.Layout.decode(reader2, reader2.uint32());
            break;
          case 3:
            message.delete = exports2.DeleteLayoutResponse.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        create: isSet2(object.create) ? exports2.Layout.fromJSON(object.create) : void 0,
        update: isSet2(object.update) ? exports2.Layout.fromJSON(object.update) : void 0,
        delete: isSet2(object.delete) ? exports2.DeleteLayoutResponse.fromJSON(object.delete) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.create !== void 0 && (obj.create = message.create ? exports2.Layout.toJSON(message.create) : void 0);
      message.update !== void 0 && (obj.update = message.update ? exports2.Layout.toJSON(message.update) : void 0);
      message.delete !== void 0 && (obj.delete = message.delete ? exports2.DeleteLayoutResponse.toJSON(message.delete) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseLayoutEvent();
      message.create = object.create !== void 0 && object.create !== null ? exports2.Layout.fromPartial(object.create) : void 0;
      message.update = object.update !== void 0 && object.update !== null ? exports2.Layout.fromPartial(object.update) : void 0;
      message.delete = object.delete !== void 0 && object.delete !== null ? exports2.DeleteLayoutResponse.fromPartial(object.delete) : void 0;
      return message;
    }
  };
  function createBaseLayerEvent() {
    return {
      create: void 0,
      update: void 0,
      delete: void 0,
      batch: void 0
    };
  }
  exports2.LayerEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.create !== void 0) {
        exports2.Layer.encode(message.create, writer2.uint32(10).fork()).ldelim();
      }
      if (message.update !== void 0) {
        exports2.Layer.encode(message.update, writer2.uint32(18).fork()).ldelim();
      }
      if (message.delete !== void 0) {
        exports2.DeleteLayerResponse.encode(message.delete, writer2.uint32(26).fork()).ldelim();
      }
      if (message.batch !== void 0) {
        exports2.BatchLayerResponse.encode(message.batch, writer2.uint32(34).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseLayerEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.create = exports2.Layer.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.update = exports2.Layer.decode(reader2, reader2.uint32());
            break;
          case 3:
            message.delete = exports2.DeleteLayerResponse.decode(reader2, reader2.uint32());
            break;
          case 4:
            message.batch = exports2.BatchLayerResponse.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        create: isSet2(object.create) ? exports2.Layer.fromJSON(object.create) : void 0,
        update: isSet2(object.update) ? exports2.Layer.fromJSON(object.update) : void 0,
        delete: isSet2(object.delete) ? exports2.DeleteLayerResponse.fromJSON(object.delete) : void 0,
        batch: isSet2(object.batch) ? exports2.BatchLayerResponse.fromJSON(object.batch) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.create !== void 0 && (obj.create = message.create ? exports2.Layer.toJSON(message.create) : void 0);
      message.update !== void 0 && (obj.update = message.update ? exports2.Layer.toJSON(message.update) : void 0);
      message.delete !== void 0 && (obj.delete = message.delete ? exports2.DeleteLayerResponse.toJSON(message.delete) : void 0);
      message.batch !== void 0 && (obj.batch = message.batch ? exports2.BatchLayerResponse.toJSON(message.batch) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseLayerEvent();
      message.create = object.create !== void 0 && object.create !== null ? exports2.Layer.fromPartial(object.create) : void 0;
      message.update = object.update !== void 0 && object.update !== null ? exports2.Layer.fromPartial(object.update) : void 0;
      message.delete = object.delete !== void 0 && object.delete !== null ? exports2.DeleteLayerResponse.fromPartial(object.delete) : void 0;
      message.batch = object.batch !== void 0 && object.batch !== null ? exports2.BatchLayerResponse.fromPartial(object.batch) : void 0;
      return message;
    }
  };
  function createBaseEvent() {
    return { layout: void 0, layer: void 0 };
  }
  exports2.Event = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.layout !== void 0) {
        exports2.LayoutEvent.encode(message.layout, writer2.uint32(10).fork()).ldelim();
      }
      if (message.layer !== void 0) {
        exports2.LayerEvent.encode(message.layer, writer2.uint32(18).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.layout = exports2.LayoutEvent.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.layer = exports2.LayerEvent.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        layout: isSet2(object.layout) ? exports2.LayoutEvent.fromJSON(object.layout) : void 0,
        layer: isSet2(object.layer) ? exports2.LayerEvent.fromJSON(object.layer) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.layout !== void 0 && (obj.layout = message.layout ? exports2.LayoutEvent.toJSON(message.layout) : void 0);
      message.layer !== void 0 && (obj.layer = message.layer ? exports2.LayerEvent.toJSON(message.layer) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseEvent();
      message.layout = object.layout !== void 0 && object.layout !== null ? exports2.LayoutEvent.fromPartial(object.layout) : void 0;
      message.layer = object.layer !== void 0 && object.layer !== null ? exports2.LayerEvent.fromPartial(object.layer) : void 0;
      return message;
    }
  };
  class LayerServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.ListLayers = this.ListLayers.bind(this);
      this.CreateLayer = this.CreateLayer.bind(this);
      this.GetLayer = this.GetLayer.bind(this);
      this.UpdateLayer = this.UpdateLayer.bind(this);
      this.DeleteLayer = this.DeleteLayer.bind(this);
      this.Batch = this.Batch.bind(this);
    }
    ListLayers(request3) {
      const data2 = exports2.ListLayersRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayerService", "ListLayers", data2);
      return promise.then((data3) => exports2.ListLayersResponse.decode(new _m02.Reader(data3)));
    }
    CreateLayer(request3) {
      const data2 = exports2.CreateLayerRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayerService", "CreateLayer", data2);
      return promise.then((data3) => exports2.Layer.decode(new _m02.Reader(data3)));
    }
    GetLayer(request3) {
      const data2 = exports2.GetLayerRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayerService", "GetLayer", data2);
      return promise.then((data3) => exports2.Layer.decode(new _m02.Reader(data3)));
    }
    UpdateLayer(request3) {
      const data2 = exports2.UpdateLayerRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayerService", "UpdateLayer", data2);
      return promise.then((data3) => exports2.Layer.decode(new _m02.Reader(data3)));
    }
    DeleteLayer(request3) {
      const data2 = exports2.DeleteLayerRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayerService", "DeleteLayer", data2);
      return promise.then((data3) => exports2.DeleteLayerResponse.decode(new _m02.Reader(data3)));
    }
    Batch(request3) {
      const data2 = exports2.BatchLayerRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayerService", "Batch", data2);
      return promise.then((data3) => exports2.BatchLayerResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.LayerServiceClientImpl = LayerServiceClientImpl;
  exports2.LayerServiceDefinition = {
    name: "LayerService",
    fullName: "apis.layout.v2.LayerService",
    methods: {
      listLayers: {
        name: "ListLayers",
        requestType: exports2.ListLayersRequest,
        requestStream: false,
        responseType: exports2.ListLayersResponse,
        responseStream: false,
        options: {}
      },
      createLayer: {
        name: "CreateLayer",
        requestType: exports2.CreateLayerRequest,
        requestStream: false,
        responseType: exports2.Layer,
        responseStream: false,
        options: {}
      },
      getLayer: {
        name: "GetLayer",
        requestType: exports2.GetLayerRequest,
        requestStream: false,
        responseType: exports2.Layer,
        responseStream: false,
        options: {}
      },
      updateLayer: {
        name: "UpdateLayer",
        requestType: exports2.UpdateLayerRequest,
        requestStream: false,
        responseType: exports2.Layer,
        responseStream: false,
        options: {}
      },
      deleteLayer: {
        name: "DeleteLayer",
        requestType: exports2.DeleteLayerRequest,
        requestStream: false,
        responseType: exports2.DeleteLayerResponse,
        responseStream: false,
        options: {}
      },
      batch: {
        name: "Batch",
        requestType: exports2.BatchLayerRequest,
        requestStream: false,
        responseType: exports2.BatchLayerResponse,
        responseStream: false,
        options: {}
      }
    }
  };
  class LayoutServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.ListLayouts = this.ListLayouts.bind(this);
      this.CreateLayout = this.CreateLayout.bind(this);
      this.GetLayout = this.GetLayout.bind(this);
      this.UpdateLayout = this.UpdateLayout.bind(this);
      this.DeleteLayout = this.DeleteLayout.bind(this);
    }
    ListLayouts(request3) {
      const data2 = exports2.ListLayoutsRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayoutService", "ListLayouts", data2);
      return promise.then((data3) => exports2.ListLayoutsResponse.decode(new _m02.Reader(data3)));
    }
    CreateLayout(request3) {
      const data2 = exports2.CreateLayoutRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayoutService", "CreateLayout", data2);
      return promise.then((data3) => exports2.Layout.decode(new _m02.Reader(data3)));
    }
    GetLayout(request3) {
      const data2 = exports2.GetLayoutRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayoutService", "GetLayout", data2);
      return promise.then((data3) => exports2.Layout.decode(new _m02.Reader(data3)));
    }
    UpdateLayout(request3) {
      const data2 = exports2.UpdateLayoutRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayoutService", "UpdateLayout", data2);
      return promise.then((data3) => exports2.Layout.decode(new _m02.Reader(data3)));
    }
    DeleteLayout(request3) {
      const data2 = exports2.DeleteLayoutRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.layout.v2.LayoutService", "DeleteLayout", data2);
      return promise.then((data3) => exports2.DeleteLayoutResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.LayoutServiceClientImpl = LayoutServiceClientImpl;
  exports2.LayoutServiceDefinition = {
    name: "LayoutService",
    fullName: "apis.layout.v2.LayoutService",
    methods: {
      listLayouts: {
        name: "ListLayouts",
        requestType: exports2.ListLayoutsRequest,
        requestStream: false,
        responseType: exports2.ListLayoutsResponse,
        responseStream: false,
        options: {}
      },
      createLayout: {
        name: "CreateLayout",
        requestType: exports2.CreateLayoutRequest,
        requestStream: false,
        responseType: exports2.Layout,
        responseStream: false,
        options: {}
      },
      getLayout: {
        name: "GetLayout",
        requestType: exports2.GetLayoutRequest,
        requestStream: false,
        responseType: exports2.Layout,
        responseStream: false,
        options: {}
      },
      updateLayout: {
        name: "UpdateLayout",
        requestType: exports2.UpdateLayoutRequest,
        requestStream: false,
        responseType: exports2.Layout,
        responseStream: false,
        options: {}
      },
      deleteLayout: {
        name: "DeleteLayout",
        requestType: exports2.DeleteLayoutRequest,
        requestStream: false,
        responseType: exports2.DeleteLayoutResponse,
        responseStream: false,
        options: {}
      }
    }
  };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal$1 !== "undefined")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  if (_m02.util.Long !== long_12.default) {
    _m02.util.Long = long_12.default;
    _m02.configure();
  }
  function isObject2(value) {
    return typeof value === "object" && value !== null;
  }
  function isSet2(value) {
    return value !== null && value !== void 0;
  }
})(api$3);
(function(exports2) {
  var __createBinding2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m[k];
  });
  var __exportStar = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !exports3.hasOwnProperty(p))
        __createBinding2(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.layoutApiEventMap = void 0;
  const api_12 = api$3;
  __exportStar(api$3, exports2);
  exports2.layoutApiEventMap = {
    [api_12.EventType.EVENT_TYPE_LAYOUT]: "layout",
    [api_12.EventType.EVENT_TYPE_LAYER]: "layer",
    [api_12.EventType.EVENT_TYPE_UNSPECIFIED]: "unspecified"
  };
})(dist$2);
var api$2 = {};
var browser$2 = false;
var __viteBrowserExternal = {};
var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
var require$$3 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var logger = {};
class EnhancedMap extends Map {
  computeIfAbsent(key, computer) {
    if (this.has(key)) {
      return this.get(key);
    }
    const newValue = computer(key);
    this.set(key, newValue);
    return newValue;
  }
  computeIfPresent(key, computer) {
    const currentValue = this.get(key);
    if (currentValue === void 0) {
      return void 0;
    }
    const newValue = computer(key, currentValue);
    if (newValue !== void 0) {
      this.set(key, newValue);
    } else {
      this.delete(key);
    }
    return newValue;
  }
  compute(key, computer) {
    const currentValue = this.get(key);
    const newValue = computer(key, currentValue);
    if (newValue) {
      this.set(key, newValue);
    } else {
      this.delete(key);
    }
    return newValue;
  }
}
var InternalLogLevel;
(function(InternalLogLevel2) {
  InternalLogLevel2[InternalLogLevel2["Trace"] = 0] = "Trace";
  InternalLogLevel2[InternalLogLevel2["Debug"] = 1] = "Debug";
  InternalLogLevel2[InternalLogLevel2["Info"] = 2] = "Info";
  InternalLogLevel2[InternalLogLevel2["Warn"] = 3] = "Warn";
  InternalLogLevel2[InternalLogLevel2["Error"] = 4] = "Error";
})(InternalLogLevel || (InternalLogLevel = {}));
function getInternalLogger(name2) {
  return provider.getLogger(name2);
}
const INTERNAL_LOGGING_SETTINGS = {
  setInternalLogLevel: (level) => provider.changeLogLevel(level),
  setOutput: (fnOutput) => provider.changeOutput(fnOutput),
  reset: () => provider.reset()
};
class InternalLoggerImpl {
  constructor(name2, level, fnOutput) {
    this._name = name2;
    this._level = level;
    this._fnOutput = fnOutput;
  }
  trace(msg) {
    this.log(InternalLogLevel.Trace, msg);
  }
  debug(msg) {
    this.log(InternalLogLevel.Debug, msg);
  }
  error(msg, error) {
    this.log(InternalLogLevel.Error, msg, error);
  }
  info(msg) {
    this.log(InternalLogLevel.Info, msg);
  }
  warn(msg, error) {
    this.log(InternalLogLevel.Warn, msg, error);
  }
  setLevel(level) {
    this._level = level;
  }
  setOutput(fnOutput) {
    this._fnOutput = fnOutput;
  }
  log(level, msg, error) {
    if (this._level > level) {
      return;
    }
    this._fnOutput(`${InternalLogLevel[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${msg()}${error ? "\n" + error.stack : ""}`);
  }
}
class InternalProviderImpl {
  constructor() {
    this._loggers = new EnhancedMap();
    this._logLevel = InternalLogLevel.Error;
    this._fnOutput = InternalProviderImpl.logConsole;
  }
  getLogger(name2) {
    return this._loggers.computeIfAbsent(name2, (key) => new InternalLoggerImpl(key, this._logLevel, this._fnOutput));
  }
  changeLogLevel(level) {
    this._logLevel = level;
    this._loggers.forEach((logger2) => logger2.setLevel(level));
  }
  changeOutput(_fnOutput) {
    this._fnOutput = _fnOutput;
    this._loggers.forEach((logger2) => logger2.setOutput(this._fnOutput));
  }
  reset() {
    this.changeLogLevel(InternalLogLevel.Error);
    this._fnOutput = InternalProviderImpl.logConsole;
    this._loggers.forEach((logger2) => logger2.setOutput(this._fnOutput));
  }
  static logConsole(msg) {
    if (console && console.log) {
      console.log(msg);
    }
  }
}
const provider = new InternalProviderImpl();
var InternalLogger = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get InternalLogLevel() {
    return InternalLogLevel;
  },
  getInternalLogger,
  INTERNAL_LOGGING_SETTINGS
});
var LogLevel$1;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Trace"] = 0] = "Trace";
  LogLevel2[LogLevel2["Debug"] = 1] = "Debug";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Warn"] = 3] = "Warn";
  LogLevel2[LogLevel2["Error"] = 4] = "Error";
  LogLevel2[LogLevel2["Fatal"] = 5] = "Fatal";
})(LogLevel$1 || (LogLevel$1 = {}));
(function(LogLevel2) {
  function toLogLevel(val) {
    switch (val.toLowerCase()) {
      case "trace":
        return LogLevel2.Trace;
      case "debug":
        return LogLevel2.Debug;
      case "info":
        return LogLevel2.Info;
      case "warn":
        return LogLevel2.Warn;
      case "error":
        return LogLevel2.Error;
      case "fatal":
        return LogLevel2.Fatal;
      default:
        return void 0;
    }
  }
  LogLevel2.toLogLevel = toLogLevel;
})(LogLevel$1 || (LogLevel$1 = {}));
class CoreLoggerImpl {
  constructor(runtime) {
    this._runtime = runtime;
  }
  get id() {
    return this._runtime.id;
  }
  get logLevel() {
    return this._runtime.level;
  }
  get runtimeSettings() {
    return Object.assign({}, this._runtime);
  }
  set runtimeSettings(runtime) {
    this._runtime = runtime;
  }
  trace(message, ...args) {
    this.logMessage(LogLevel$1.Trace, message, args);
  }
  debug(message, ...args) {
    this.logMessage(LogLevel$1.Debug, message, args);
  }
  info(message, ...args) {
    this.logMessage(LogLevel$1.Info, message, args);
  }
  warn(message, ...args) {
    this.logMessage(LogLevel$1.Warn, message, args);
  }
  error(message, ...args) {
    this.logMessage(LogLevel$1.Error, message, args);
  }
  fatal(message, ...args) {
    this.logMessage(LogLevel$1.Fatal, message, args);
  }
  logMessage(level, logMessageType, args) {
    if (this._runtime.level > level) {
      return;
    }
    const nowMillis = Date.now();
    const message = typeof logMessageType === "string" ? logMessageType : logMessageType();
    const errorAndArgs = CoreLoggerImpl.getErrorAndArgs(args);
    switch (this._runtime.channel.type) {
      case "RawLogChannel":
        this._runtime.channel.write({
          message,
          exception: errorAndArgs.error,
          args: errorAndArgs.args,
          timeInMillis: nowMillis,
          level,
          logNames: this._runtime.name
        }, this._runtime.argumentFormatter);
        return;
      case "LogChannel":
        this._runtime.channel.write(this.createLogMessage(message, level, errorAndArgs, nowMillis));
        break;
    }
  }
  formatArgValue(value) {
    try {
      return this._runtime.argumentFormatter(value);
    } catch (e2) {
      return `>>ARG CONVERT FAILED: '${value !== void 0 ? value.toString() : "undefined"}'<<`;
    }
  }
  createLogMessage(message, level, errorAndArgs, nowMillis) {
    let errorResult;
    const error = errorAndArgs.error;
    const args = errorAndArgs.args;
    if (error) {
      errorResult = `${error.name}: ${error.message}`;
      if (error.stack) {
        errorResult += `@
${error.stack}`;
      }
    }
    const dateFormatted = this._runtime.dateFormatter(nowMillis);
    let levelAsStr = LogLevel$1[level].toUpperCase();
    if (levelAsStr.length < 5) {
      levelAsStr += " ";
    }
    const names = typeof this._runtime.name === "string" ? this._runtime.name : this._runtime.name.join(", ");
    const argsFormatted = typeof args !== "undefined" && args.length > 0 ? " [" + args.map((arg) => this.formatArgValue(arg)).join(", ") + "]" : "";
    const completedMessage = dateFormatted + " " + levelAsStr + " [" + names + "] " + message + argsFormatted;
    return {
      message: completedMessage,
      error: errorResult
    };
  }
  static getErrorAndArgs(args) {
    if (args.length === 0) {
      return {};
    }
    let error;
    let actualArgs;
    const value0 = args[0];
    if (value0 instanceof Error) {
      error = value0;
      actualArgs = args.length > 1 ? args.slice(1) : void 0;
      return { error, args: actualArgs };
    }
    if (typeof value0 === "function") {
      const errorOrArgs = value0();
      if (errorOrArgs instanceof Error) {
        error = errorOrArgs;
        actualArgs = args.length > 1 ? args.slice(1) : void 0;
        return { error, args: actualArgs };
      }
      if (args.length === 1) {
        if (Array.isArray(errorOrArgs)) {
          return { args: errorOrArgs.length > 0 ? errorOrArgs : void 0 };
        } else {
          return { args: errorOrArgs };
        }
      } else {
        if (Array.isArray(errorOrArgs)) {
          return { args: [...errorOrArgs, ...args.slice(1)] };
        }
        return { args: [errorOrArgs, ...args.slice(1)] };
      }
    }
    return { args };
  }
}
function padStart(value, length2, fillChar = " ") {
  return padInternal(value, length2, "start", fillChar);
}
function padEnd(value, length2, fillChar = " ") {
  return padInternal(value, length2, "end", fillChar);
}
function maxLengthStringValueInArray(arr) {
  return arr.map((v) => v.length).reduce((previous, current) => {
    if (current > previous) {
      return current;
    }
    return previous;
  }, 0);
}
function padInternal(value, length2, padType, fillChar = " ") {
  if (length2 <= value.length) {
    return value;
  }
  if (fillChar.length > 1) {
    throw new Error(`Fill char must be one char exactly, it is: ${fillChar.length}`);
  }
  const charsNeeded = length2 - value.length;
  let padding = "";
  for (let i2 = 0; i2 < charsNeeded; i2++) {
    padding += fillChar;
  }
  if (padType === "start") {
    return padding + value;
  }
  return value + padding;
}
function formatArgument(arg) {
  if (arg === void 0) {
    return "undefined";
  }
  return JSON.stringify(arg);
}
function formatDate(millisSinceEpoch) {
  const date = new Date(millisSinceEpoch);
  const year = date.getFullYear();
  const month = padStart((date.getMonth() + 1).toString(), 2, "0");
  const day = padStart(date.getDate().toString(), 2, "0");
  const hours = padStart(date.getHours().toString(), 2, "0");
  const minutes = padStart(date.getMinutes().toString(), 2, "0");
  const seconds = padStart(date.getSeconds().toString(), 2, "0");
  const millis = padStart(date.getMilliseconds().toString(), 2, "0");
  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds},${millis}`;
}
class ConsoleLogChannel {
  constructor() {
    this.type = "LogChannel";
  }
  write(msg) {
    if (console && console.log) {
      console.log(msg.message + (msg.error ? `
${msg.error}` : ""));
    }
  }
}
var DefaultChannels;
(function(DefaultChannels2) {
  function createConsoleChannel() {
    return new ConsoleLogChannel();
  }
  DefaultChannels2.createConsoleChannel = createConsoleChannel;
})(DefaultChannels || (DefaultChannels = {}));
class LogProviderImpl {
  constructor(name2, settings) {
    this._log = getInternalLogger("core.impl.LogProviderImpl");
    this._name = name2;
    this._settings = settings;
    this._loggers = new EnhancedMap();
    this._idToKeyMap = new EnhancedMap();
    this._globalRuntimeSettings = { level: settings.level, channel: settings.channel };
    this._nextLoggerId = 1;
    this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);
  }
  get runtimeSettings() {
    return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });
  }
  getLogger(name2) {
    return this.getOrCreateLogger(name2);
  }
  updateLoggerRuntime(log2, settings) {
    this._log.debug(() => `Updating logger ${log2.id} runtime settings using: '${JSON.stringify(settings)}'`);
    const key = this._idToKeyMap.get(log2.id);
    if (key === void 0) {
      this._log.warn(() => `Cannot update logger with id: ${log2.id}, it was not found.`);
      return false;
    }
    this._loggers.computeIfPresent(key, (currentKey, currentValue) => {
      currentValue.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(currentValue.runtimeSettings, settings);
      return currentValue;
    });
    return true;
  }
  updateRuntimeSettings(settings) {
    this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(settings)}'`);
    this._globalRuntimeSettings = {
      level: settings.level !== void 0 ? settings.level : this._globalRuntimeSettings.level,
      channel: settings.channel !== void 0 ? settings.channel : this._globalRuntimeSettings.channel
    };
    this._loggers.forEach((logger2) => logger2.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(logger2.runtimeSettings, settings));
  }
  clear() {
    this._loggers.clear();
    this._idToKeyMap.clear();
    this._globalRuntimeSettings = Object.assign({}, this._settings);
    this._nextLoggerId = 1;
  }
  getOrCreateLogger(name2) {
    const key = LogProviderImpl.createKey(name2);
    const logger2 = this._loggers.computeIfAbsent(key, () => {
      const runtime = {
        level: this._globalRuntimeSettings.level,
        channel: this._globalRuntimeSettings.channel,
        id: this.nextLoggerId(),
        name: name2,
        argumentFormatter: this._settings.argumentFormatter,
        dateFormatter: this._settings.dateFormatter
      };
      return new CoreLoggerImpl(runtime);
    });
    this._idToKeyMap.computeIfAbsent(logger2.id, () => key);
    return logger2;
  }
  nextLoggerId() {
    const result = this._name + "_" + this._nextLoggerId;
    this._nextLoggerId++;
    return result;
  }
  static mergeRuntimeSettingsIntoLogRuntime(currentSettings, settings) {
    return Object.assign(Object.assign({}, currentSettings), {
      level: settings.level !== void 0 ? settings.level : currentSettings.level,
      channel: settings.channel !== void 0 ? settings.channel : currentSettings.channel
    });
  }
  static createKey(name2) {
    if (typeof name2 === "string") {
      return name2;
    }
    return name2.join(",");
  }
}
function createLogProvider(name2, settings) {
  return new LogProviderImpl(name2, settings);
}
var index$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EnhancedMap,
  padStart,
  padEnd,
  maxLengthStringValueInArray
});
class CategoryImpl {
  constructor(logger2, name2, parent2, fnGetOrCreateChildCategory) {
    this._children = [];
    this._logger = logger2;
    this._name = name2;
    this._parent = parent2;
    this._fnGetOrCreateChildCategory = fnGetOrCreateChildCategory;
  }
  get name() {
    return this._name;
  }
  get parent() {
    return this._parent;
  }
  get path() {
    const result = [];
    let tmpCat = this;
    while (tmpCat !== void 0) {
      result.push(tmpCat.name);
      tmpCat = tmpCat.parent;
    }
    return result.reverse();
  }
  get children() {
    return [...this._children];
  }
  addChild(childCategory) {
    if (childCategory.parent !== this) {
      throw new Error(`Cannot add child '${childCategory.name}', expected parent '${this._name} but got ${childCategory.parent ? childCategory.parent.name : "undefined"}'`);
    }
    this._children.push(childCategory);
  }
  getChildCategory(name2) {
    const existing = this._children.find((c) => c.name === name2);
    if (existing !== void 0) {
      return existing;
    }
    return this._fnGetOrCreateChildCategory(name2, this);
  }
  get id() {
    return this._logger.id;
  }
  get logLevel() {
    return this._logger.logLevel;
  }
  get runtimeSettings() {
    return this._logger.runtimeSettings;
  }
  get logger() {
    return this._logger;
  }
  trace(message, ...args) {
    this._logger.trace(message, ...args);
  }
  debug(message, ...args) {
    this._logger.debug(message, ...args);
  }
  info(message, ...args) {
    this._logger.info(message, ...args);
  }
  warn(message, ...args) {
    this._logger.warn(message, ...args);
  }
  error(message, ...args) {
    this._logger.error(message, ...args);
  }
  fatal(message, ...args) {
    this._logger.fatal(message, ...args);
  }
}
const CATEGORY_PATH_SEPARATOR = "#";
class CategoryProviderImpl {
  constructor(name2, config2) {
    this._name = name2;
    this._initialConfig = config2;
    this._categoryStorage = new CategoryStorage(name2, config2);
  }
  get name() {
    return this._name;
  }
  get config() {
    return this._initialConfig;
  }
  get runtimeConfig() {
    return this._categoryStorage.getCurrentRuntimeConfig();
  }
  getCategory(name2, parent2) {
    return this._categoryStorage.getOrCreateCategory(name2, parent2);
  }
  updateRuntimeSettingsCategory(category, settings) {
    this._categoryStorage.updateRuntimeSettingsCategory(category, settings);
  }
  updateRuntimeSettings(settings) {
    this._categoryStorage.updateRuntimeSettings(settings);
  }
  getRegisteredCategories() {
    return this._categoryStorage.getRegisteredCategories();
  }
  getCategoryByPath(path) {
    return this._categoryStorage.getCategoryByPath(path);
  }
}
class CategoryStorage {
  constructor(categoryProviderName, config2) {
    this._categoriesById = /* @__PURE__ */ new Map();
    this._categoriesByPath = /* @__PURE__ */ new Map();
    this._categoryProviderName = categoryProviderName;
    this._allowSameCategoryName = config2.allowSameCategoryName;
    this._logProvider = createLogProvider(categoryProviderName, Object.assign({}, config2));
    this.getOrCreateCategory = this.getOrCreateCategory.bind(this);
  }
  getOrCreateCategory(name2, parent2) {
    if (name2.indexOf(CATEGORY_PATH_SEPARATOR) !== -1) {
      throw new Error(`Cannot create category '${name2}', name cannot contain a '${CATEGORY_PATH_SEPARATOR}'.`);
    }
    const parentCategory = parent2 !== void 0 ? this.getParentCategory(parent2) : void 0;
    if (parentCategory === void 0) {
      return this.getOrCreateRootCategory(name2);
    }
    return this.getOrCreateChildCategory(name2, parentCategory);
  }
  updateRuntimeSettingsCategory(category, settings) {
    if (!category.id.startsWith(this._categoryProviderName)) {
      throw new Error(`Category '${category.name}' with LogId '${category.id}' is from a different CategoryProvider, cannot mix categories between providers.`);
    }
    const categoryImpl = this._categoriesById.get(category.id);
    if (categoryImpl === void 0) {
      return;
    }
    this._logProvider.updateLoggerRuntime(categoryImpl.logger, { level: settings.level });
    if (settings.disableRecursion !== void 0 && settings.disableRecursion) {
      return;
    }
    categoryImpl.children.forEach((childCategory) => this.updateRuntimeSettingsCategory(childCategory, settings));
  }
  updateRuntimeSettings(settings) {
    this._logProvider.updateRuntimeSettings(settings);
  }
  getCurrentRuntimeConfig() {
    return Object.assign(Object.assign({}, this._logProvider.runtimeSettings), { allowSameCategoryName: this._allowSameCategoryName });
  }
  getRegisteredCategories() {
    return [...this._categoriesById.values()];
  }
  getCategoryByPath(path) {
    return this._categoriesByPath.get(path);
  }
  getParentCategory(parent2) {
    let parentCategory;
    if (CategoryStorage.isLogId(parent2)) {
      parentCategory = this._categoriesById.get(parent2);
      if (parentCategory === void 0) {
        throw new Error(`Parent category was not found by LogId '${parent2}'. Are you sure you passed in the correct argument?`);
      }
    } else {
      parentCategory = this._categoriesById.get(parent2.id);
      if (parentCategory === void 0) {
        throw new Error(`Parent category '${parent2.name}' was not found by it's LogId '${parent2.id}'. Are you sure you passed in the correct parent category?`);
      }
    }
    return parentCategory;
  }
  getOrCreateRootCategory(name2) {
    const existingCategory = this._categoriesByPath.get(name2);
    if (existingCategory) {
      if (!this._allowSameCategoryName) {
        throw new Error(`Category '${name2} already exists, config flag allowSameCategoryName=false - therefore matching version 1 behavior (hence this Error)`);
      }
      return existingCategory;
    }
    const logger2 = this._logProvider.getLogger(name2);
    const category = new CategoryImpl(logger2, name2, void 0, this.getOrCreateCategory);
    this._categoriesById.set(category.id, category);
    this._categoriesByPath.set(name2, category);
    return category;
  }
  getOrCreateChildCategory(name2, parentCategory) {
    if (!parentCategory.id.startsWith(this._categoryProviderName)) {
      throw new Error(`Parent category '${parentCategory.name}' with LogId '${parentCategory.id}' is from a different CategoryProvider, cannot mix categories between providers.`);
    }
    const path = [...parentCategory.path, name2].join(CATEGORY_PATH_SEPARATOR);
    const existingChildCategory = this._categoriesByPath.get(path);
    if (existingChildCategory) {
      if (!this._allowSameCategoryName) {
        throw new Error(`Child category '${name2} already exists for parent category ${parentCategory.name}, config flag allowSameCategoryName=false - therefore matching version 1 behavior (hence this Error)`);
      }
      return existingChildCategory;
    }
    const logger2 = this._logProvider.getLogger(path);
    this._logProvider.updateLoggerRuntime(logger2, {
      level: parentCategory.logger.runtimeSettings.level,
      channel: parentCategory.logger.runtimeSettings.channel
    });
    const childCategory = new CategoryImpl(logger2, name2, parentCategory, this.getOrCreateCategory);
    this._categoriesById.set(childCategory.id, childCategory);
    this._categoriesByPath.set(childCategory.path.join(CATEGORY_PATH_SEPARATOR), childCategory);
    parentCategory.addChild(childCategory);
    return childCategory;
  }
  static isLogId(parent2) {
    return typeof parent2 === "string";
  }
}
class CategoryControlProviderImpl {
  constructor(provider2, messageChannel) {
    this._provider = provider2;
    this._messageChannel = messageChannel;
    this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(provider2);
  }
  get name() {
    return this._provider.name;
  }
  showSettings() {
    let result = `Available categories (CategoryProvider '${this._provider.name}'):
`;
    const categories = this.createCategoryInfoHierarchy();
    const maxWidthIndex = categories.size.toString().length;
    const maxWidthIdentifier = index$3.maxLengthStringValueInArray([...categories.values()].map((value) => value.category.name + " ".repeat(value.depth)));
    const providerLines = [...categories.values()].map((category, idx) => CategoryControlProviderImpl.createSettingLineCategory(category, idx, maxWidthIndex, maxWidthIdentifier));
    result += providerLines.join("\n") + (providerLines.length > 0 ? "\n" : "");
    this._messageChannel(result);
  }
  help() {
    const msg = `You can use the following commands (CategoryProvider ${this._provider.name}):
  showSettings()
    Shows the current configuration settings.
  update(level: CategoryControlProviderLogLevel, categoryId?: number | string, noRecurse?: boolean)
    Change the log level for a category (by default recursively).
      @param level      The log level to set - must be one of 'trace', 'debug', 'info', 'warn', 'error' or 'fatal'
      @param categoryId The category id or path of a category (e.g. root#child1) to update. Use showSettings() for id and/or name.
                        When omitted, it applies the level to all categories recursively.
  reset()
    Resets the log levels of the config groups back to when this control provider was created.
  save()
    Saves the current log levels for all categories of this provider. Use restore() to load last saved state.
  restore()
    Restore stored saved state, if any. Log levels will be set according to the saved state.
  help()
    Shows this help.
`;
    this._messageChannel(msg);
  }
  reset() {
    const currentCategories = new Map(this._provider.getRegisteredCategories().map((cat) => [cat.id, cat]));
    this._originalLogLevels.forEach((value, key) => {
      const category = currentCategories.get(key);
      if (category !== void 0) {
        this._provider.updateRuntimeSettingsCategory(category, { level: value, disableRecursion: true });
      }
      currentCategories.delete(key);
    });
    currentCategories.forEach((category) => {
      if (category.parent !== void 0) {
        this._provider.updateRuntimeSettingsCategory(category, { level: category.parent.logLevel, disableRecursion: true });
      }
    });
    this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(this._provider);
    this._messageChannel("Successfully reset log levels back to original state (from when this CategoryControlProvider was created).");
  }
  save() {
    if (!localStorage) {
      this._messageChannel("Cannot save state, localStorage is not available.");
      return;
    }
    const saveDataForAllRootCategories = this._provider.getRegisteredCategories().filter((cat) => cat.parent === void 0).map((rootCategory) => CategoryControlProviderImpl.createCategorySaveData(rootCategory));
    const saveData = {
      name: this._provider.name,
      rootCategories: saveDataForAllRootCategories
    };
    localStorage.setItem(this.createKey(), JSON.stringify(saveData));
    this._messageChannel(`Successfully saved state for CategoryControlProvider '${this._provider.name}'.`);
  }
  restore(logRestoreFailures) {
    const finalLogRestoreFailures = logRestoreFailures !== void 0 ? logRestoreFailures : true;
    if (!localStorage) {
      if (finalLogRestoreFailures) {
        this._messageChannel(`Will not attempt to restore state for CategoryControlProvider '${this._provider.name}', localStorage is not available.`);
      }
      return;
    }
    const key = this.createKey();
    const value = localStorage.getItem(key);
    if (value === null) {
      if (finalLogRestoreFailures) {
        this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', no data available.`);
      }
      return;
    }
    try {
      const savedData = JSON.parse(value);
      if (this._provider.name !== savedData.name) {
        if (finalLogRestoreFailures) {
          this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', data is not for provider - found name '${savedData.name}'.`);
        }
        return;
      }
      this.restoreBySaveData(savedData, finalLogRestoreFailures);
      this._messageChannel(`Successfully restored state for CategoryControlProvider '${this._provider.name}'`);
      this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(this._provider);
    } catch (e2) {
      localStorage.removeItem(key);
      this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', data is not valid. Invalid data removed from localStorage.`);
    }
  }
  update(level, categoryId, noRecurse) {
    if (typeof categoryId === "undefined") {
      this.updateAll(level);
    } else if (typeof categoryId === "number") {
      this.updateByIndex(level, categoryId, noRecurse !== void 0 ? noRecurse : false);
    } else {
      this.updateByPath(level, categoryId, noRecurse !== void 0 ? noRecurse : false);
    }
  }
  updateAll(level) {
    const logLevel = LogLevel$1.toLogLevel(level);
    this._provider.getRegisteredCategories().filter((cat) => cat.parent === void 0).forEach((cat) => this._provider.updateRuntimeSettingsCategory(cat, { level: logLevel }));
    this._messageChannel(`Updated all categories to use log level '${level.toLowerCase()}'`);
  }
  updateByPath(level, path, noRecurse) {
    const category = this._provider.getCategoryByPath(path);
    if (category === void 0) {
      this._messageChannel(`Failed to find a provider by path '${path}', please make sure to separate the parts by a ${CATEGORY_PATH_SEPARATOR}.`);
      return;
    }
    this._provider.updateRuntimeSettingsCategory(category, { level: LogLevel$1.toLogLevel(level), disableRecursion: noRecurse });
    this._messageChannel(`Successfully updated category '${category.name}' with path '${path}' to log level '${level.toLowerCase()}'${noRecurse ? "" : " and recursively applied to children (if any)"}.`);
  }
  updateByIndex(level, index2, noRecurse) {
    if (index2 < 0) {
      this._messageChannel(`Cannot update category by index '${index2}', it is negative.`);
      return;
    }
    const categories = this.createCategoryInfoHierarchy();
    if (index2 >= categories.size) {
      this._messageChannel(`Cannot update category by index '${index2}', it is outside of the range of available categories, use showSettings() to see the indices.`);
      return;
    }
    const category = [...categories.values()][index2].category;
    this._provider.updateRuntimeSettingsCategory(category, { level: LogLevel$1.toLogLevel(level), disableRecursion: noRecurse });
    this._messageChannel(`Successfully updated category '${category.name}' by index '${index2}' to log level '${level.toLowerCase()}'${noRecurse ? "" : " and recursively applied to children (if any)"}.`);
  }
  restoreBySaveData(saveData, logCannotRestore) {
    const restoreCategory = (categorySaveData, currentPath) => {
      const newPath = currentPath.length > 0 ? currentPath + CATEGORY_PATH_SEPARATOR + categorySaveData.name : categorySaveData.name;
      const category = this._provider.getCategoryByPath(newPath);
      if (category !== void 0) {
        const newLevel = LogLevel$1.toLogLevel(categorySaveData.level);
        if (newLevel !== void 0) {
          this._provider.updateRuntimeSettingsCategory(category, { level: newLevel, disableRecursion: true });
        } else if (logCannotRestore) {
          this._messageChannel(`CategoryControlProvider '${this._provider.name}' - cannot restore log level for category path '${newPath}', log level is invalid.`);
        }
        for (const childSaveData of categorySaveData.children) {
          restoreCategory(childSaveData, newPath);
        }
      } else if (logCannotRestore) {
        this._messageChannel(`CategoryControlProvider '${this._provider.name}' - failed to find a Category by path '${newPath}', will not restore category (and children)`);
      }
    };
    for (const rootSaveData of saveData.rootCategories) {
      restoreCategory(rootSaveData, "");
    }
  }
  createKey() {
    return `CategoryProvider-${this._provider.name}`;
  }
  createCategoryInfoHierarchy() {
    const result = /* @__PURE__ */ new Map();
    const rootCategories = this._provider.getRegisteredCategories().filter((cat) => cat.parent === void 0);
    rootCategories.forEach((category) => CategoryControlProviderImpl.addCategoryInfoHierarchy(category, 0, result));
    return result;
  }
  static createCategorySaveData(category) {
    return {
      name: category.name,
      level: LogLevel$1[category.logLevel],
      children: category.children.map((child) => this.createCategorySaveData(child))
    };
  }
  static loadCurrentGroupLogLevels(provider2) {
    return new Map(provider2.getRegisteredCategories().map((category) => [category.id, category.logLevel]));
  }
  static createSettingLineCategory(categoryInfo, index$12, maxWidthIndex, maxWidthIdentifier) {
    const prefix = " ".repeat(categoryInfo.depth);
    const catName = prefix + categoryInfo.category.name;
    return `  [${index$3.padStart(index$12.toString(), maxWidthIndex)}, ${index$3.padEnd(catName, maxWidthIdentifier)} (level=${index$3.padEnd(categoryInfo.logLevel, 5)})]`;
  }
  static addCategoryInfoHierarchy(category, currentDepth, result) {
    result.set(category.id, {
      category,
      logLevel: LogLevel$1[category.logLevel],
      depth: currentDepth
    });
    category.children.forEach((child) => this.addCategoryInfoHierarchy(child, currentDepth + 1, result));
  }
}
function categoryConfigDebug(config2) {
  return `CategoryConfig=level: ${LogLevel$1[config2.level].toString()}, allowSameCategoryName=${config2.allowSameCategoryName}`;
}
class CategoryProviderService {
  constructor() {
    this._log = InternalLogger.getInternalLogger("category.impl.CategoryProviderService");
    this._providers = new index$3.EnhancedMap();
  }
  createLogProvider(name2, config2) {
    const result = this._providers.compute(name2, (key, currentValue) => {
      if (currentValue) {
        throw new Error(`CategoryProvider with name '${name2}' already exists, cannot create another.`);
      }
      const finalConfig = mergeWithDefaults(config2);
      this._log.debug(() => `Creating new CategoryProvider with name '${name2}', using config settings '${categoryConfigDebug(finalConfig)}'.`);
      return new CategoryProviderImpl(name2, finalConfig);
    });
    if (result) {
      return result;
    }
    throw new Error("No CategoryProvider? This is a bug.");
  }
  getCategoryControl(fnValue) {
    const fnMessageChannel = fnValue ? fnValue : (value) => {
      if (console && console.log) {
        console.log(value);
      } else {
        throw new Error("Cannot use console (it is not present), please specify a custom function to write to.");
      }
    };
    return {
      help: () => fnMessageChannel(CategoryProviderService.help()),
      showSettings: () => fnMessageChannel(this.showSettings()),
      getProvider: (id) => this.getCategoryControlProviderByIdOrName(id, fnMessageChannel)
    };
  }
  clear() {
    this._providers.clear();
  }
  showSettings() {
    let result = "Available CategoryProviders:\n";
    const maxWidthIndex = this._providers.size.toString().length;
    const maxWidthName = index$3.maxLengthStringValueInArray([...this._providers.keys()]);
    const lines = [...this._providers.entries()].map((entry, index$12) => {
      const name2 = entry[0];
      return `  [${index$3.padStart(index$12.toString(), maxWidthIndex)}, ${index$3.padEnd(name2, maxWidthName)}]`;
    });
    result += lines.join("\n") + (lines.length > 0 ? "\n" : "");
    return result;
  }
  getCategoryControlProviderByIdOrName(id, messageChannel) {
    if (typeof id === "string") {
      const provider2 = this._providers.get(id);
      if (provider2 === void 0) {
        throw new Error(`Provider with name '${id}' does not exist.`);
      }
      return new CategoryControlProviderImpl(provider2, messageChannel);
    }
    const providers = [...this._providers.values()];
    if (id < 0 || id >= providers.length) {
      throw new Error(`Provider with index '${id}' does not exist (outside of range).`);
    }
    return new CategoryControlProviderImpl(providers[id], messageChannel);
  }
  static help() {
    return "You can use the following commands:\n  showSettings()\n    Shows the current configuration settings.\n  getProvider: (id: number | string): CategoryControlProvider\n    Get access to a CategoryControlProvider to change log levels.\n      @param id The id (use showSettings to see) or name of the provider\n  help()\n    Shows this help.\n";
  }
}
const CATEGORY_PROVIDER_SERVICE = new CategoryProviderService();
const CATEGORY_LOG_CONTROL = (fnValue) => CATEGORY_PROVIDER_SERVICE.getCategoryControl(fnValue);
function mergeWithDefaults(config2) {
  const defaultConfig = {
    channel: DefaultChannels.createConsoleChannel(),
    allowSameCategoryName: true,
    level: LogLevel$1.Error,
    dateFormatter: formatDate,
    argumentFormatter: formatArgument
  };
  if (!config2) {
    return defaultConfig;
  }
  return {
    channel: config2.channel ? config2.channel : defaultConfig.channel,
    allowSameCategoryName: config2.allowSameCategoryName !== void 0 ? config2.allowSameCategoryName : defaultConfig.allowSameCategoryName,
    level: config2.level ? config2.level : defaultConfig.level,
    dateFormatter: config2.dateFormatter ? config2.dateFormatter : defaultConfig.dateFormatter,
    argumentFormatter: config2.argumentFormatter ? config2.argumentFormatter : defaultConfig.argumentFormatter
  };
}
var CategoryProvider;
(function(CategoryProvider2) {
  function createProvider(name2, config2) {
    return CATEGORY_PROVIDER_SERVICE.createLogProvider(name2, config2);
  }
  CategoryProvider2.createProvider = createProvider;
  function clear() {
    CATEGORY_PROVIDER_SERVICE.clear();
  }
  CategoryProvider2.clear = clear;
})(CategoryProvider || (CategoryProvider = {}));
var typescriptLoggingCategory_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CATEGORY_LOG_CONTROL,
  get CategoryProvider() {
    return CategoryProvider;
  }
}, Symbol.toStringTag, { value: "Module" }));
var require$$1 = /* @__PURE__ */ getAugmentedNamespace(typescriptLoggingCategory_esm);
Object.defineProperty(logger, "__esModule", { value: true });
logger.logger = void 0;
const typescript_logging_1 = require$$2$1;
const typescript_logging_category_style_1 = require$$1;
logger.logger = typescript_logging_category_style_1.CategoryProvider.createProvider("ApiStream", { allowSameCategoryName: true, level: typescript_logging_1.LogLevel.Warn });
var version$3 = "1.0.23";
var __createBinding$4 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o2, k2, desc);
} : function(o2, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o2[k2] = m[k];
});
var __setModuleDefault$4 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(o2, v) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v });
} : function(o2, v) {
  o2["default"] = v;
});
var __importStar$4 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k in mod2)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
        __createBinding$4(result, mod2, k);
  }
  __setModuleDefault$4(result, mod2);
  return result;
};
var __importDefault$5 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(api$2, "__esModule", { value: true });
api$2.ApiClient = void 0;
const NiceGrpc$1 = __importStar$4(lib$1);
const abort_controller_x_1 = require$$1$1;
const detect_node_1 = __importDefault$5(browser$2);
const NodeTransport = __importStar$4(require$$3);
const logger_1 = logger;
const clientVersion$1 = version$3;
class ApiClient {
  constructor(sessionId, server, sdkVersion, logCategory, apiLogCallback, eventLogCallback) {
    this.sessionId = sessionId;
    this.sdkVersion = sdkVersion;
    this.version = clientVersion$1;
    this.apiLogCallback = apiLogCallback;
    this.eventLogCallback = eventLogCallback;
    this.log = logger_1.logger.getCategory(logCategory);
    this.channel = NiceGrpc$1.createChannel(server, detect_node_1.default ? NodeTransport.NodeHttpTransport() : void 0);
    this.clientFactory = NiceGrpc$1.createClientFactory().use(this.logMiddleware.bind(this));
  }
  async *logMiddleware(call, options) {
    const { path } = call.method;
    try {
      const result = yield* call.next(call.request, options);
      this.log.debug(`-> ${path}: ok`);
      this.log.trace(`${JSON.stringify(call.request)} -> ${path}: ${JSON.stringify(result)}`);
      if (this.apiLogCallback) {
        let parts = path.split("/");
        let serviceParts = parts[1].split(".");
        let service2 = serviceParts[serviceParts.length - 1];
        let version2 = serviceParts[serviceParts.length - 2];
        let api2 = serviceParts[serviceParts.length - 3];
        let func = parts[2];
        this.apiLogCallback(api2, service2, func, call.request, result);
      }
      return result;
    } catch (error) {
      this.log.trace(`${JSON.stringify(call.request)} -> ${path}`);
      if (error instanceof NiceGrpc$1.ClientError) {
        this.log.warn(`-> ${path}: error: ${NiceGrpc$1.Status[error.code]}: ${error.details}`);
      } else if ((0, abort_controller_x_1.isAbortError)(error)) {
        this.log.warn(`-> ${path}: cancel`);
      } else {
        this.log.warn(`-> ${path}: error: ${error === null || error === void 0 ? void 0 : error.stack}`);
      }
      throw error;
    }
  }
  setAccessToken(accessToken) {
    if (this.accessToken == void 0 || this.accessToken != accessToken) {
      this.log.debug("access token refreshed");
      this.accessToken = accessToken;
      this.setup();
    }
  }
  makeGrpcMetadata() {
    let metadata = NiceGrpc$1.Metadata({
      Authorization: `Bearer ${this.accessToken}`,
      Version: this.version,
      SessionId: this.sessionId
    });
    if (this.sdkVersion != void 0) {
      metadata.set("SdkVersion", this.sdkVersion);
    }
    return metadata;
  }
  setup() {
    let options = {
      metadata: this.makeGrpcMetadata()
    };
    this._setup(options);
  }
  _setup(options) {
  }
}
api$2.ApiClient = ApiClient;
var decorator = {};
Object.defineProperty(decorator, "__esModule", { value: true });
decorator.RequiresSdkAuthentication = void 0;
function RequiresSdkAuthentication() {
  return function(target, propertyKey) {
    const _internalPropertyKey = Symbol(propertyKey);
    Object.defineProperty(target, propertyKey, {
      get: function() {
        if (!this[_internalPropertyKey]) {
          throw new Error("Please authenticate ApiStream by calling apiStream.load( accessToken )");
        }
        return this[_internalPropertyKey];
      },
      set: function(val) {
        this[_internalPropertyKey] = val;
      }
    });
  };
}
decorator.RequiresSdkAuthentication = RequiresSdkAuthentication;
var __createBinding$3 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o2, k2, desc);
} : function(o2, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o2[k2] = m[k];
});
var __setModuleDefault$3 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(o2, v) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v });
} : function(o2, v) {
  o2["default"] = v;
});
var __decorate = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d = decorators[i2])
        r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __importStar$3 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k in mod2)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
        __createBinding$3(result, mod2, k);
  }
  __setModuleDefault$3(result, mod2);
  return result;
};
var __metadata = commonjsGlobal$1 && commonjsGlobal$1.__metadata || function(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
Object.defineProperty(layoutapi, "__esModule", { value: true });
layoutapi.LayoutApi = void 0;
__importStar$3(lib$1);
const LayoutApiModel = __importStar$3(dist$2);
const api_1$1 = api$2;
const decorator_1 = decorator;
const LOG_CATEGORY$1 = "LayoutApi";
class LayoutApi extends api_1$1.ApiClient {
  constructor(sessionId, eventApi, server, sdkVersion, apiLogCallback) {
    super(sessionId, server, sdkVersion, LOG_CATEGORY$1, apiLogCallback);
    this.handlers = {};
    this.eventApi = eventApi;
    this.eventApi.on("event", { name: `${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:*`, ignoreSessionEvents: true }, (evt) => {
      var _a2;
      const [, eventName] = evt.name.split(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:`);
      const [type, subtype] = eventName.split(":");
      const payload = evt.payload;
      for (const handler of (_a2 = this.handlers[type]) !== null && _a2 !== void 0 ? _a2 : []) {
        handler(Object.values(payload).find((i2) => !!i2), subtype);
      }
    });
  }
  _setup(options) {
    this.layer = this.clientFactory.create(LayoutApiModel.LayerServiceDefinition, this.channel, {
      "*": options
    });
    this.layout = this.clientFactory.create(LayoutApiModel.LayoutServiceDefinition, this.channel, {
      "*": options
    });
  }
  async subscribeToLayout(layoutId) {
    await Promise.all([
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { layoutId } }),
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { layoutId } })
    ]);
  }
  async unsubscribeFromLayout(layoutId) {
    await Promise.all([
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { layoutId } }),
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { layoutId } })
    ]);
  }
  async subscribeToLayoutsInProject(collectionId, projectId) {
    await Promise.all([
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { collectionId, projectId } }),
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { collectionId, projectId } })
    ]);
  }
  async unsubscribeFromLayoutsInProject(collectionId, projectId) {
    await Promise.all([
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { collectionId, projectId } }),
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { collectionId, projectId } })
    ]);
  }
  on(type, handler) {
    var _a2;
    this.handlers[type] = (_a2 = this.handlers[type]) !== null && _a2 !== void 0 ? _a2 : [];
    this.handlers[type].push(handler);
  }
  off(type, handler) {
    this.handlers[type] = this.handlers[type].filter((i2) => i2 !== handler);
  }
}
LayoutApi.LAYOUTAPI_EVENT_PREFIX = "apistream:layout";
__decorate([
  (0, decorator_1.RequiresSdkAuthentication)(),
  __metadata("design:type", Object)
], LayoutApi.prototype, "layout", void 0);
__decorate([
  (0, decorator_1.RequiresSdkAuthentication)(),
  __metadata("design:type", Object)
], LayoutApi.prototype, "layer", void 0);
layoutapi.LayoutApi = LayoutApi;
var liveapi = {};
var api$1 = {};
var timestamp$1 = {};
var __createBinding$2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o2, k2, desc);
} : function(o2, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o2[k2] = m[k];
});
var __setModuleDefault$2 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(o2, v) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v });
} : function(o2, v) {
  o2["default"] = v;
});
var __importStar$2 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k in mod2)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
        __createBinding$2(result, mod2, k);
  }
  __setModuleDefault$2(result, mod2);
  return result;
};
var __importDefault$4 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(timestamp$1, "__esModule", { value: true });
timestamp$1.Timestamp = timestamp$1.protobufPackage = void 0;
const long_1$1 = __importDefault$4(umd.exports);
const _m0$2 = __importStar$2(minimal$2);
timestamp$1.protobufPackage = "google.protobuf";
function createBaseTimestamp() {
  return { seconds: 0, nanos: 0 };
}
timestamp$1.Timestamp = {
  encode(message, writer2 = _m0$2.Writer.create()) {
    if (message.seconds !== 0) {
      writer2.uint32(8).int64(message.seconds);
    }
    if (message.nanos !== 0) {
      writer2.uint32(16).int32(message.nanos);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0$2.Reader ? input : new _m0$2.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTimestamp();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.seconds = longToNumber$2(reader2.int64());
          break;
        case 2:
          message.nanos = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      seconds: isSet$2(object.seconds) ? Number(object.seconds) : 0,
      nanos: isSet$2(object.nanos) ? Number(object.nanos) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.seconds !== void 0 && (obj.seconds = Math.round(message.seconds));
    message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
    return obj;
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseTimestamp();
    message.seconds = (_a2 = object.seconds) !== null && _a2 !== void 0 ? _a2 : 0;
    message.nanos = (_b = object.nanos) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
var globalThis$1 = (() => {
  if (typeof globalThis$1 !== "undefined")
    return globalThis$1;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof commonjsGlobal$1 !== "undefined")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber$2(long2) {
  if (long2.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis$1.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long2.toNumber();
}
if (_m0$2.util.Long !== long_1$1.default) {
  _m0$2.util.Long = long_1$1.default;
  _m0$2.configure();
}
function isSet$2(value) {
  return value !== null && value !== void 0;
}
var struct$1 = {};
(function(exports2) {
  var __createBinding2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar2 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __importDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ListValue = exports2.Value = exports2.Struct_FieldsEntry = exports2.Struct = exports2.nullValueToNumber = exports2.nullValueToJSON = exports2.nullValueFromJSON = exports2.NullValue = exports2.protobufPackage = void 0;
  const long_12 = __importDefault2(umd.exports);
  const _m02 = __importStar2(minimal$2);
  exports2.protobufPackage = "google.protobuf";
  var NullValue;
  (function(NullValue2) {
    NullValue2["NULL_VALUE"] = "NULL_VALUE";
  })(NullValue = exports2.NullValue || (exports2.NullValue = {}));
  function nullValueFromJSON(object) {
    switch (object) {
      case 0:
      case "NULL_VALUE":
        return NullValue.NULL_VALUE;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum NullValue");
    }
  }
  exports2.nullValueFromJSON = nullValueFromJSON;
  function nullValueToJSON(object) {
    switch (object) {
      case NullValue.NULL_VALUE:
        return "NULL_VALUE";
      default:
        return "UNKNOWN";
    }
  }
  exports2.nullValueToJSON = nullValueToJSON;
  function nullValueToNumber(object) {
    switch (object) {
      case NullValue.NULL_VALUE:
        return 0;
      default:
        return 0;
    }
  }
  exports2.nullValueToNumber = nullValueToNumber;
  function createBaseStruct() {
    return { fields: {} };
  }
  exports2.Struct = {
    encode(message, writer2 = _m02.Writer.create()) {
      Object.entries(message.fields).forEach(([key, value]) => {
        if (value !== void 0) {
          exports2.Struct_FieldsEntry.encode({ key, value }, writer2.uint32(10).fork()).ldelim();
        }
      });
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseStruct();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            const entry1 = exports2.Struct_FieldsEntry.decode(reader2, reader2.uint32());
            if (entry1.value !== void 0) {
              message.fields[entry1.key] = entry1.value;
            }
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        fields: isObject2(object.fields) ? Object.entries(object.fields).reduce((acc, [key, value]) => {
          acc[key] = value;
          return acc;
        }, {}) : {}
      };
    },
    toJSON(message) {
      const obj = {};
      obj.fields = {};
      if (message.fields) {
        Object.entries(message.fields).forEach(([k, v]) => {
          obj.fields[k] = v;
        });
      }
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseStruct();
      message.fields = Object.entries((_a2 = object.fields) !== null && _a2 !== void 0 ? _a2 : {}).reduce((acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = value;
        }
        return acc;
      }, {});
      return message;
    },
    wrap(object) {
      const struct2 = createBaseStruct();
      if (object !== void 0) {
        Object.keys(object).forEach((key) => {
          struct2.fields[key] = object[key];
        });
      }
      return struct2;
    },
    unwrap(message) {
      const object = {};
      Object.keys(message.fields).forEach((key) => {
        object[key] = message.fields[key];
      });
      return object;
    }
  };
  function createBaseStruct_FieldsEntry() {
    return { key: "", value: void 0 };
  }
  exports2.Struct_FieldsEntry = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.key !== "") {
        writer2.uint32(10).string(message.key);
      }
      if (message.value !== void 0) {
        exports2.Value.encode(exports2.Value.wrap(message.value), writer2.uint32(18).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseStruct_FieldsEntry();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.key = reader2.string();
            break;
          case 2:
            message.value = exports2.Value.unwrap(exports2.Value.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        key: isSet2(object.key) ? String(object.key) : "",
        value: isSet2(object === null || object === void 0 ? void 0 : object.value) ? object.value : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.key !== void 0 && (obj.key = message.key);
      message.value !== void 0 && (obj.value = message.value);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseStruct_FieldsEntry();
      message.key = (_a2 = object.key) !== null && _a2 !== void 0 ? _a2 : "";
      message.value = (_b = object.value) !== null && _b !== void 0 ? _b : void 0;
      return message;
    }
  };
  function createBaseValue() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  exports2.Value = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.nullValue !== void 0) {
        writer2.uint32(8).int32(nullValueToNumber(message.nullValue));
      }
      if (message.numberValue !== void 0) {
        writer2.uint32(17).double(message.numberValue);
      }
      if (message.stringValue !== void 0) {
        writer2.uint32(26).string(message.stringValue);
      }
      if (message.boolValue !== void 0) {
        writer2.uint32(32).bool(message.boolValue);
      }
      if (message.structValue !== void 0) {
        exports2.Struct.encode(exports2.Struct.wrap(message.structValue), writer2.uint32(42).fork()).ldelim();
      }
      if (message.listValue !== void 0) {
        exports2.ListValue.encode(exports2.ListValue.wrap(message.listValue), writer2.uint32(50).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseValue();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.nullValue = nullValueFromJSON(reader2.int32());
            break;
          case 2:
            message.numberValue = reader2.double();
            break;
          case 3:
            message.stringValue = reader2.string();
            break;
          case 4:
            message.boolValue = reader2.bool();
            break;
          case 5:
            message.structValue = exports2.Struct.unwrap(exports2.Struct.decode(reader2, reader2.uint32()));
            break;
          case 6:
            message.listValue = exports2.ListValue.unwrap(exports2.ListValue.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        nullValue: isSet2(object.nullValue) ? nullValueFromJSON(object.nullValue) : void 0,
        numberValue: isSet2(object.numberValue) ? Number(object.numberValue) : void 0,
        stringValue: isSet2(object.stringValue) ? String(object.stringValue) : void 0,
        boolValue: isSet2(object.boolValue) ? Boolean(object.boolValue) : void 0,
        structValue: isObject2(object.structValue) ? object.structValue : void 0,
        listValue: Array.isArray(object.listValue) ? [...object.listValue] : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.nullValue !== void 0 && (obj.nullValue = message.nullValue !== void 0 ? nullValueToJSON(message.nullValue) : void 0);
      message.numberValue !== void 0 && (obj.numberValue = message.numberValue);
      message.stringValue !== void 0 && (obj.stringValue = message.stringValue);
      message.boolValue !== void 0 && (obj.boolValue = message.boolValue);
      message.structValue !== void 0 && (obj.structValue = message.structValue);
      message.listValue !== void 0 && (obj.listValue = message.listValue);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e, _f;
      const message = createBaseValue();
      message.nullValue = (_a2 = object.nullValue) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.numberValue = (_b = object.numberValue) !== null && _b !== void 0 ? _b : void 0;
      message.stringValue = (_c = object.stringValue) !== null && _c !== void 0 ? _c : void 0;
      message.boolValue = (_d = object.boolValue) !== null && _d !== void 0 ? _d : void 0;
      message.structValue = (_e = object.structValue) !== null && _e !== void 0 ? _e : void 0;
      message.listValue = (_f = object.listValue) !== null && _f !== void 0 ? _f : void 0;
      return message;
    },
    wrap(value) {
      const result = createBaseValue();
      if (value === null) {
        result.nullValue = NullValue.NULL_VALUE;
      } else if (typeof value === "boolean") {
        result.boolValue = value;
      } else if (typeof value === "number") {
        result.numberValue = value;
      } else if (typeof value === "string") {
        result.stringValue = value;
      } else if (Array.isArray(value)) {
        result.listValue = value;
      } else if (typeof value === "object") {
        result.structValue = value;
      } else if (typeof value !== "undefined") {
        throw new Error("Unsupported any value type: " + typeof value);
      }
      return result;
    },
    unwrap(message) {
      if ((message === null || message === void 0 ? void 0 : message.stringValue) !== void 0) {
        return message.stringValue;
      } else if ((message === null || message === void 0 ? void 0 : message.numberValue) !== void 0) {
        return message.numberValue;
      } else if ((message === null || message === void 0 ? void 0 : message.boolValue) !== void 0) {
        return message.boolValue;
      } else if ((message === null || message === void 0 ? void 0 : message.structValue) !== void 0) {
        return message.structValue;
      } else if ((message === null || message === void 0 ? void 0 : message.listValue) !== void 0) {
        return message.listValue;
      } else if ((message === null || message === void 0 ? void 0 : message.nullValue) !== void 0) {
        return null;
      }
      return void 0;
    }
  };
  function createBaseListValue() {
    return { values: [] };
  }
  exports2.ListValue = {
    encode(message, writer2 = _m02.Writer.create()) {
      for (const v of message.values) {
        exports2.Value.encode(exports2.Value.wrap(v), writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseListValue();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.values.push(exports2.Value.unwrap(exports2.Value.decode(reader2, reader2.uint32())));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        values: Array.isArray(object === null || object === void 0 ? void 0 : object.values) ? [...object.values] : []
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.values) {
        obj.values = message.values.map((e2) => e2);
      } else {
        obj.values = [];
      }
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseListValue();
      message.values = ((_a2 = object.values) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
      return message;
    },
    wrap(value) {
      const result = createBaseListValue();
      result.values = value !== null && value !== void 0 ? value : [];
      return result;
    },
    unwrap(message) {
      return message.values;
    }
  };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal$1 !== "undefined")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  if (_m02.util.Long !== long_12.default) {
    _m02.util.Long = long_12.default;
    _m02.configure();
  }
  function isObject2(value) {
    return typeof value === "object" && value !== null;
  }
  function isSet2(value) {
    return value !== null && value !== void 0;
  }
})(struct$1);
var field_mask = {};
var __createBinding$1 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o2, k2, desc);
} : function(o2, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o2[k2] = m[k];
});
var __setModuleDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(o2, v) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v });
} : function(o2, v) {
  o2["default"] = v;
});
var __importStar$1 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k in mod2)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
        __createBinding$1(result, mod2, k);
  }
  __setModuleDefault$1(result, mod2);
  return result;
};
var __importDefault$3 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(field_mask, "__esModule", { value: true });
field_mask.FieldMask = field_mask.protobufPackage = void 0;
const long_1 = __importDefault$3(umd.exports);
const _m0$1 = __importStar$1(minimal$2);
field_mask.protobufPackage = "google.protobuf";
function createBaseFieldMask() {
  return { paths: [] };
}
field_mask.FieldMask = {
  encode(message, writer2 = _m0$1.Writer.create()) {
    for (const v of message.paths) {
      writer2.uint32(10).string(v);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0$1.Reader ? input : new _m0$1.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseFieldMask();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.paths.push(reader2.string());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      paths: typeof object === "string" ? object.split(",").filter(Boolean) : Array.isArray(object === null || object === void 0 ? void 0 : object.paths) ? object.paths.map(String) : []
    };
  },
  toJSON(message) {
    return message.paths.join(",");
  },
  fromPartial(object) {
    var _a2;
    const message = createBaseFieldMask();
    message.paths = ((_a2 = object.paths) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
    return message;
  },
  wrap(paths) {
    return { paths };
  },
  unwrap(message) {
    return message.paths;
  }
};
if (_m0$1.util.Long !== long_1.default) {
  _m0$1.util.Long = long_1.default;
  _m0$1.configure();
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar2 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __importDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Role = exports2.regionToNumber = exports2.regionToJSON = exports2.regionFromJSON = exports2.Region = exports2.sourceTriggerActionToNumber = exports2.sourceTriggerActionToJSON = exports2.sourceTriggerActionFromJSON = exports2.SourceTriggerAction = exports2.s3ACLToNumber = exports2.s3ACLToJSON = exports2.s3ACLFromJSON = exports2.S3ACL = exports2.projectBroadcastPhaseToNumber = exports2.projectBroadcastPhaseToJSON = exports2.projectBroadcastPhaseFromJSON = exports2.ProjectBroadcastPhase = exports2.videoCodecRateControlModeToNumber = exports2.videoCodecRateControlModeToJSON = exports2.videoCodecRateControlModeFromJSON = exports2.VideoCodecRateControlMode = exports2.audioCodecToNumber = exports2.audioCodecToJSON = exports2.audioCodecFromJSON = exports2.AudioCodec = exports2.videoCodecProfileToNumber = exports2.videoCodecProfileToJSON = exports2.videoCodecProfileFromJSON = exports2.VideoCodecProfile = exports2.videoCodecToNumber = exports2.videoCodecToJSON = exports2.videoCodecFromJSON = exports2.VideoCodec = exports2.renderingQualityToNumber = exports2.renderingQualityToJSON = exports2.renderingQualityFromJSON = exports2.RenderingQuality = exports2.audioChannelLayoutToNumber = exports2.audioChannelLayoutToJSON = exports2.audioChannelLayoutFromJSON = exports2.AudioChannelLayout = exports2.videoColorSpaceToNumber = exports2.videoColorSpaceToJSON = exports2.videoColorSpaceFromJSON = exports2.VideoColorSpace = exports2.imageFormatToNumber = exports2.imageFormatToJSON = exports2.imageFormatFromJSON = exports2.ImageFormat = exports2.protobufPackage = void 0;
  exports2.HostedWebRtc = exports2.Composition = exports2.ExternalComposition = exports2.SceneComposition = exports2.StudioSdkComposition = exports2.PreviewAddress = exports2.PreviewWebRtcAddress = exports2.PreviewHlsPullAddress = exports2.ProjectTrigger = exports2.WebRtcTrigger = exports2.SourceTrigger = exports2.DestinationAddress = exports2.S3StorageAddress = exports2.ObjectStoragePackaging = exports2.HlsPackaging = exports2.HlsLifecycle = exports2.HlsLifecycleVod = exports2.HlsLifecycleLive = exports2.DestinationAgoraPushAddress = exports2.DestinationRtmpPushAddress = exports2.SourceAddress = exports2.RtmpPullAddress = exports2.SrtPushAddress = exports2.SourceRtmpPushAddress = exports2.Encoding = exports2.AudioEncoding = exports2.VideoEncoding = exports2.VideoCodecRateControl = exports2.Rendering = exports2.AudioRendering = exports2.VideoRendering = exports2.eventTypeToNumber = exports2.eventTypeToJSON = exports2.eventTypeFromJSON = exports2.EventType = exports2.eventSubTypeToNumber = exports2.eventSubTypeToJSON = exports2.eventSubTypeFromJSON = exports2.EventSubType = exports2.connectStateToNumber = exports2.connectStateToJSON = exports2.connectStateFromJSON = exports2.ConnectState = exports2.projectBroadcastErrorToNumber = exports2.projectBroadcastErrorToJSON = exports2.projectBroadcastErrorFromJSON = exports2.ProjectBroadcastError = exports2.roleToNumber = exports2.roleToJSON = exports2.roleFromJSON = void 0;
  exports2.DeleteSourceResponse = exports2.DeleteSourceRequest = exports2.CreateSourceResponse = exports2.CreateSourceRequest = exports2.UpdateDestinationResponse = exports2.UpdateDestinationRequest = exports2.DeleteDestinationResponse = exports2.DeleteDestinationRequest = exports2.GetDestinationResponse = exports2.GetDestinationRequest = exports2.CreateDestinationResponse = exports2.CreateDestinationRequest = exports2.StopProjectWebRtcResponse = exports2.StopProjectWebRtcRequest = exports2.StartProjectWebRtcResponse = exports2.StartProjectWebRtcRequest = exports2.GetProjectBroadcastStatusResponse = exports2.GetProjectBroadcastStatusRequest = exports2.GetProjectBroadcastSnapshotResponse = exports2.GetProjectBroadcastSnapshotRequest = exports2.GetProjectResponse = exports2.GetProjectRequest = exports2.StopProjectBroadcastResponse = exports2.StopProjectBroadcastRequest = exports2.StartProjectBroadcastResponse = exports2.StartProjectBroadcastRequest = exports2.DeleteProjectResponse = exports2.DeleteProjectRequest = exports2.UpdateProjectResponse = exports2.UpdateProjectRequest = exports2.CreateProjectResponse = exports2.CreateProjectRequest = exports2.GetCollectionsResponse = exports2.GetCollectionsRequest = exports2.DeleteCollectionResponse = exports2.DeleteCollectionRequest = exports2.UpdateCollectionResponse = exports2.UpdateCollectionRequest = exports2.GetCollectionResponse = exports2.GetCollectionRequest = exports2.CreateCollectionResponse = exports2.CreateCollectionRequest = exports2.Collection = exports2.Project = exports2.Destination = exports2.Source = exports2.ProjectBroadcastStatus = exports2.LatLong = exports2.WebRtcAccess = exports2.WebRtc = void 0;
  exports2.DestinationEvent = exports2.CollectionEvent = exports2.SourceStateEvent = exports2.SourceRemoveEvent = exports2.SourceAddEvent = exports2.SourceUpdateEvent = exports2.SourceDeleteEvent = exports2.SourceCreateEvent = exports2.CollectionUpdateEvent = exports2.CollectionDeleteEvent = exports2.CollectionCreateEvent = exports2.ProjectBroadcastStateEvent = exports2.ProjectUpdateEvent = exports2.ProjectDeleteEvent = exports2.ProjectCreateEvent = exports2.DestinationStateEvent = exports2.DestinationUpdateEvent = exports2.DestinationDeleteEvent = exports2.DestinationCreateEvent = exports2.GetTestTokenResponse = exports2.GetTestTokenRequest = exports2.GetJsonWebKeySetResponse = exports2.GetJsonWebKeySetRequest = exports2.JsonWebKey = exports2.GuestCodeRedirectResponse = exports2.GuestCodeRedirectRequest = exports2.GuestCode = exports2.RefreshAccessTokenResponse = exports2.RefreshAccessTokenRequest = exports2.CreateWebRtcAccessTokenResponse = exports2.CreateWebRtcAccessTokenRequest = exports2.CreateGuestAccessTokenResponse = exports2.CreateGuestAccessTokenRequest = exports2.GuestAccessToken = exports2.GuestAccessTokenExchange = exports2.GuestAccessTokenDirect = exports2.CreateAccessTokenResponse = exports2.CreateAccessTokenRequest = exports2.RemoveSourceFromProjectResponse = exports2.RemoveSourceFromProjectRequest = exports2.UpdateSourceResponse = exports2.UpdateSourceRequest = exports2.GetSourcesResponse = exports2.GetSourcesRequest = exports2.GetSourceResponse = exports2.GetSourceRequest = exports2.UpdateSourceInProjectResponse = exports2.UpdateSourceInProjectRequest = exports2.AddSourceToProjectResponse = exports2.AddSourceToProjectRequest = void 0;
  exports2.PublicAuthenticationServiceDefinition = exports2.PublicAuthenticationServiceClientImpl = exports2.AuthenticationServiceDefinition = exports2.AuthenticationServiceClientImpl = exports2.BackendAuthenticationServiceDefinition = exports2.BackendAuthenticationServiceClientImpl = exports2.SourceServiceDefinition = exports2.SourceServiceClientImpl = exports2.DestinationServiceDefinition = exports2.DestinationServiceClientImpl = exports2.ProjectServiceDefinition = exports2.ProjectServiceClientImpl = exports2.CollectionServiceDefinition = exports2.CollectionServiceClientImpl = exports2.LiveEvent = exports2.SourceEvent = exports2.ProjectEvent = void 0;
  const long_12 = __importDefault2(umd.exports);
  const _m02 = __importStar2(minimal$2);
  const timestamp_1 = timestamp$1;
  const struct_1 = struct$1;
  const field_mask_1 = field_mask;
  exports2.protobufPackage = "live.v21";
  var ImageFormat;
  (function(ImageFormat2) {
    ImageFormat2["IMAGE_FORMAT_UNSPECIFIED"] = "IMAGE_FORMAT_UNSPECIFIED";
    ImageFormat2["IMAGE_FORMAT_JPEG"] = "IMAGE_FORMAT_JPEG";
  })(ImageFormat = exports2.ImageFormat || (exports2.ImageFormat = {}));
  function imageFormatFromJSON(object) {
    switch (object) {
      case 0:
      case "IMAGE_FORMAT_UNSPECIFIED":
        return ImageFormat.IMAGE_FORMAT_UNSPECIFIED;
      case 1:
      case "IMAGE_FORMAT_JPEG":
        return ImageFormat.IMAGE_FORMAT_JPEG;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum ImageFormat");
    }
  }
  exports2.imageFormatFromJSON = imageFormatFromJSON;
  function imageFormatToJSON(object) {
    switch (object) {
      case ImageFormat.IMAGE_FORMAT_UNSPECIFIED:
        return "IMAGE_FORMAT_UNSPECIFIED";
      case ImageFormat.IMAGE_FORMAT_JPEG:
        return "IMAGE_FORMAT_JPEG";
      default:
        return "UNKNOWN";
    }
  }
  exports2.imageFormatToJSON = imageFormatToJSON;
  function imageFormatToNumber(object) {
    switch (object) {
      case ImageFormat.IMAGE_FORMAT_UNSPECIFIED:
        return 0;
      case ImageFormat.IMAGE_FORMAT_JPEG:
        return 1;
      default:
        return 0;
    }
  }
  exports2.imageFormatToNumber = imageFormatToNumber;
  var VideoColorSpace;
  (function(VideoColorSpace2) {
    VideoColorSpace2["VIDEO_COLOR_SPACE_UNSPECIFIED"] = "VIDEO_COLOR_SPACE_UNSPECIFIED";
    VideoColorSpace2["VIDEO_COLOR_SPACE_YUV420"] = "VIDEO_COLOR_SPACE_YUV420";
  })(VideoColorSpace = exports2.VideoColorSpace || (exports2.VideoColorSpace = {}));
  function videoColorSpaceFromJSON(object) {
    switch (object) {
      case 0:
      case "VIDEO_COLOR_SPACE_UNSPECIFIED":
        return VideoColorSpace.VIDEO_COLOR_SPACE_UNSPECIFIED;
      case 1:
      case "VIDEO_COLOR_SPACE_YUV420":
        return VideoColorSpace.VIDEO_COLOR_SPACE_YUV420;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum VideoColorSpace");
    }
  }
  exports2.videoColorSpaceFromJSON = videoColorSpaceFromJSON;
  function videoColorSpaceToJSON(object) {
    switch (object) {
      case VideoColorSpace.VIDEO_COLOR_SPACE_UNSPECIFIED:
        return "VIDEO_COLOR_SPACE_UNSPECIFIED";
      case VideoColorSpace.VIDEO_COLOR_SPACE_YUV420:
        return "VIDEO_COLOR_SPACE_YUV420";
      default:
        return "UNKNOWN";
    }
  }
  exports2.videoColorSpaceToJSON = videoColorSpaceToJSON;
  function videoColorSpaceToNumber(object) {
    switch (object) {
      case VideoColorSpace.VIDEO_COLOR_SPACE_UNSPECIFIED:
        return 0;
      case VideoColorSpace.VIDEO_COLOR_SPACE_YUV420:
        return 1;
      default:
        return 0;
    }
  }
  exports2.videoColorSpaceToNumber = videoColorSpaceToNumber;
  var AudioChannelLayout;
  (function(AudioChannelLayout2) {
    AudioChannelLayout2["AUDIO_CHANNEL_LAYOUT_UNSPECIFIED"] = "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED";
    AudioChannelLayout2["AUDIO_CHANNEL_LAYOUT_STEREO"] = "AUDIO_CHANNEL_LAYOUT_STEREO";
  })(AudioChannelLayout = exports2.AudioChannelLayout || (exports2.AudioChannelLayout = {}));
  function audioChannelLayoutFromJSON(object) {
    switch (object) {
      case 0:
      case "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED":
        return AudioChannelLayout.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED;
      case 1:
      case "AUDIO_CHANNEL_LAYOUT_STEREO":
        return AudioChannelLayout.AUDIO_CHANNEL_LAYOUT_STEREO;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum AudioChannelLayout");
    }
  }
  exports2.audioChannelLayoutFromJSON = audioChannelLayoutFromJSON;
  function audioChannelLayoutToJSON(object) {
    switch (object) {
      case AudioChannelLayout.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED:
        return "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED";
      case AudioChannelLayout.AUDIO_CHANNEL_LAYOUT_STEREO:
        return "AUDIO_CHANNEL_LAYOUT_STEREO";
      default:
        return "UNKNOWN";
    }
  }
  exports2.audioChannelLayoutToJSON = audioChannelLayoutToJSON;
  function audioChannelLayoutToNumber(object) {
    switch (object) {
      case AudioChannelLayout.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED:
        return 0;
      case AudioChannelLayout.AUDIO_CHANNEL_LAYOUT_STEREO:
        return 1;
      default:
        return 0;
    }
  }
  exports2.audioChannelLayoutToNumber = audioChannelLayoutToNumber;
  var RenderingQuality2;
  (function(RenderingQuality3) {
    RenderingQuality3["RENDERING_QUALITY_UNSPECIFIED"] = "RENDERING_QUALITY_UNSPECIFIED";
    RenderingQuality3["RENDERING_QUALITY_STANDARD"] = "RENDERING_QUALITY_STANDARD";
    RenderingQuality3["RENDERING_QUALITY_HIGH"] = "RENDERING_QUALITY_HIGH";
  })(RenderingQuality2 = exports2.RenderingQuality || (exports2.RenderingQuality = {}));
  function renderingQualityFromJSON(object) {
    switch (object) {
      case 0:
      case "RENDERING_QUALITY_UNSPECIFIED":
        return RenderingQuality2.RENDERING_QUALITY_UNSPECIFIED;
      case 1:
      case "RENDERING_QUALITY_STANDARD":
        return RenderingQuality2.RENDERING_QUALITY_STANDARD;
      case 2:
      case "RENDERING_QUALITY_HIGH":
        return RenderingQuality2.RENDERING_QUALITY_HIGH;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum RenderingQuality");
    }
  }
  exports2.renderingQualityFromJSON = renderingQualityFromJSON;
  function renderingQualityToJSON(object) {
    switch (object) {
      case RenderingQuality2.RENDERING_QUALITY_UNSPECIFIED:
        return "RENDERING_QUALITY_UNSPECIFIED";
      case RenderingQuality2.RENDERING_QUALITY_STANDARD:
        return "RENDERING_QUALITY_STANDARD";
      case RenderingQuality2.RENDERING_QUALITY_HIGH:
        return "RENDERING_QUALITY_HIGH";
      default:
        return "UNKNOWN";
    }
  }
  exports2.renderingQualityToJSON = renderingQualityToJSON;
  function renderingQualityToNumber(object) {
    switch (object) {
      case RenderingQuality2.RENDERING_QUALITY_UNSPECIFIED:
        return 0;
      case RenderingQuality2.RENDERING_QUALITY_STANDARD:
        return 1;
      case RenderingQuality2.RENDERING_QUALITY_HIGH:
        return 2;
      default:
        return 0;
    }
  }
  exports2.renderingQualityToNumber = renderingQualityToNumber;
  var VideoCodec2;
  (function(VideoCodec3) {
    VideoCodec3["VIDEO_CODEC_UNSPECIFIED"] = "VIDEO_CODEC_UNSPECIFIED";
    VideoCodec3["VIDEO_CODEC_H264"] = "VIDEO_CODEC_H264";
  })(VideoCodec2 = exports2.VideoCodec || (exports2.VideoCodec = {}));
  function videoCodecFromJSON(object) {
    switch (object) {
      case 0:
      case "VIDEO_CODEC_UNSPECIFIED":
        return VideoCodec2.VIDEO_CODEC_UNSPECIFIED;
      case 1:
      case "VIDEO_CODEC_H264":
        return VideoCodec2.VIDEO_CODEC_H264;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum VideoCodec");
    }
  }
  exports2.videoCodecFromJSON = videoCodecFromJSON;
  function videoCodecToJSON(object) {
    switch (object) {
      case VideoCodec2.VIDEO_CODEC_UNSPECIFIED:
        return "VIDEO_CODEC_UNSPECIFIED";
      case VideoCodec2.VIDEO_CODEC_H264:
        return "VIDEO_CODEC_H264";
      default:
        return "UNKNOWN";
    }
  }
  exports2.videoCodecToJSON = videoCodecToJSON;
  function videoCodecToNumber(object) {
    switch (object) {
      case VideoCodec2.VIDEO_CODEC_UNSPECIFIED:
        return 0;
      case VideoCodec2.VIDEO_CODEC_H264:
        return 1;
      default:
        return 0;
    }
  }
  exports2.videoCodecToNumber = videoCodecToNumber;
  var VideoCodecProfile2;
  (function(VideoCodecProfile3) {
    VideoCodecProfile3["VIDEO_CODEC_PROFILE_UNSPECIFIED"] = "VIDEO_CODEC_PROFILE_UNSPECIFIED";
    VideoCodecProfile3["VIDEO_CODEC_PROFILE_BASELINE"] = "VIDEO_CODEC_PROFILE_BASELINE";
    VideoCodecProfile3["VIDEO_CODEC_PROFILE_MAIN"] = "VIDEO_CODEC_PROFILE_MAIN";
    VideoCodecProfile3["VIDEO_CODEC_PROFILE_HIGH"] = "VIDEO_CODEC_PROFILE_HIGH";
  })(VideoCodecProfile2 = exports2.VideoCodecProfile || (exports2.VideoCodecProfile = {}));
  function videoCodecProfileFromJSON(object) {
    switch (object) {
      case 0:
      case "VIDEO_CODEC_PROFILE_UNSPECIFIED":
        return VideoCodecProfile2.VIDEO_CODEC_PROFILE_UNSPECIFIED;
      case 2:
      case "VIDEO_CODEC_PROFILE_BASELINE":
        return VideoCodecProfile2.VIDEO_CODEC_PROFILE_BASELINE;
      case 3:
      case "VIDEO_CODEC_PROFILE_MAIN":
        return VideoCodecProfile2.VIDEO_CODEC_PROFILE_MAIN;
      case 4:
      case "VIDEO_CODEC_PROFILE_HIGH":
        return VideoCodecProfile2.VIDEO_CODEC_PROFILE_HIGH;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum VideoCodecProfile");
    }
  }
  exports2.videoCodecProfileFromJSON = videoCodecProfileFromJSON;
  function videoCodecProfileToJSON(object) {
    switch (object) {
      case VideoCodecProfile2.VIDEO_CODEC_PROFILE_UNSPECIFIED:
        return "VIDEO_CODEC_PROFILE_UNSPECIFIED";
      case VideoCodecProfile2.VIDEO_CODEC_PROFILE_BASELINE:
        return "VIDEO_CODEC_PROFILE_BASELINE";
      case VideoCodecProfile2.VIDEO_CODEC_PROFILE_MAIN:
        return "VIDEO_CODEC_PROFILE_MAIN";
      case VideoCodecProfile2.VIDEO_CODEC_PROFILE_HIGH:
        return "VIDEO_CODEC_PROFILE_HIGH";
      default:
        return "UNKNOWN";
    }
  }
  exports2.videoCodecProfileToJSON = videoCodecProfileToJSON;
  function videoCodecProfileToNumber(object) {
    switch (object) {
      case VideoCodecProfile2.VIDEO_CODEC_PROFILE_UNSPECIFIED:
        return 0;
      case VideoCodecProfile2.VIDEO_CODEC_PROFILE_BASELINE:
        return 2;
      case VideoCodecProfile2.VIDEO_CODEC_PROFILE_MAIN:
        return 3;
      case VideoCodecProfile2.VIDEO_CODEC_PROFILE_HIGH:
        return 4;
      default:
        return 0;
    }
  }
  exports2.videoCodecProfileToNumber = videoCodecProfileToNumber;
  var AudioCodec2;
  (function(AudioCodec3) {
    AudioCodec3["AUDIO_CODEC_UNSPECIFIED"] = "AUDIO_CODEC_UNSPECIFIED";
    AudioCodec3["AUDIO_CODEC_AAC"] = "AUDIO_CODEC_AAC";
  })(AudioCodec2 = exports2.AudioCodec || (exports2.AudioCodec = {}));
  function audioCodecFromJSON(object) {
    switch (object) {
      case 0:
      case "AUDIO_CODEC_UNSPECIFIED":
        return AudioCodec2.AUDIO_CODEC_UNSPECIFIED;
      case 1:
      case "AUDIO_CODEC_AAC":
        return AudioCodec2.AUDIO_CODEC_AAC;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum AudioCodec");
    }
  }
  exports2.audioCodecFromJSON = audioCodecFromJSON;
  function audioCodecToJSON(object) {
    switch (object) {
      case AudioCodec2.AUDIO_CODEC_UNSPECIFIED:
        return "AUDIO_CODEC_UNSPECIFIED";
      case AudioCodec2.AUDIO_CODEC_AAC:
        return "AUDIO_CODEC_AAC";
      default:
        return "UNKNOWN";
    }
  }
  exports2.audioCodecToJSON = audioCodecToJSON;
  function audioCodecToNumber(object) {
    switch (object) {
      case AudioCodec2.AUDIO_CODEC_UNSPECIFIED:
        return 0;
      case AudioCodec2.AUDIO_CODEC_AAC:
        return 1;
      default:
        return 0;
    }
  }
  exports2.audioCodecToNumber = audioCodecToNumber;
  var VideoCodecRateControlMode;
  (function(VideoCodecRateControlMode2) {
    VideoCodecRateControlMode2["VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED"] = "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED";
    VideoCodecRateControlMode2["VIDEO_CODEC_RATE_CONTROL_MODE_CBR"] = "VIDEO_CODEC_RATE_CONTROL_MODE_CBR";
  })(VideoCodecRateControlMode = exports2.VideoCodecRateControlMode || (exports2.VideoCodecRateControlMode = {}));
  function videoCodecRateControlModeFromJSON(object) {
    switch (object) {
      case 0:
      case "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED":
        return VideoCodecRateControlMode.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED;
      case 1:
      case "VIDEO_CODEC_RATE_CONTROL_MODE_CBR":
        return VideoCodecRateControlMode.VIDEO_CODEC_RATE_CONTROL_MODE_CBR;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum VideoCodecRateControlMode");
    }
  }
  exports2.videoCodecRateControlModeFromJSON = videoCodecRateControlModeFromJSON;
  function videoCodecRateControlModeToJSON(object) {
    switch (object) {
      case VideoCodecRateControlMode.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED:
        return "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED";
      case VideoCodecRateControlMode.VIDEO_CODEC_RATE_CONTROL_MODE_CBR:
        return "VIDEO_CODEC_RATE_CONTROL_MODE_CBR";
      default:
        return "UNKNOWN";
    }
  }
  exports2.videoCodecRateControlModeToJSON = videoCodecRateControlModeToJSON;
  function videoCodecRateControlModeToNumber(object) {
    switch (object) {
      case VideoCodecRateControlMode.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED:
        return 0;
      case VideoCodecRateControlMode.VIDEO_CODEC_RATE_CONTROL_MODE_CBR:
        return 1;
      default:
        return 0;
    }
  }
  exports2.videoCodecRateControlModeToNumber = videoCodecRateControlModeToNumber;
  var ProjectBroadcastPhase2;
  (function(ProjectBroadcastPhase3) {
    ProjectBroadcastPhase3["PROJECT_BROADCAST_PHASE_UNSPECIFIED"] = "PROJECT_BROADCAST_PHASE_UNSPECIFIED";
    ProjectBroadcastPhase3["PROJECT_BROADCAST_PHASE_NOT_RUNNING"] = "PROJECT_BROADCAST_PHASE_NOT_RUNNING";
    ProjectBroadcastPhase3["PROJECT_BROADCAST_PHASE_WAITING"] = "PROJECT_BROADCAST_PHASE_WAITING";
    ProjectBroadcastPhase3["PROJECT_BROADCAST_PHASE_STARTING"] = "PROJECT_BROADCAST_PHASE_STARTING";
    ProjectBroadcastPhase3["PROJECT_BROADCAST_PHASE_RUNNING"] = "PROJECT_BROADCAST_PHASE_RUNNING";
    ProjectBroadcastPhase3["PROJECT_BROADCAST_PHASE_STOPPING"] = "PROJECT_BROADCAST_PHASE_STOPPING";
    ProjectBroadcastPhase3["PROJECT_BROADCAST_PHASE_STOPPED"] = "PROJECT_BROADCAST_PHASE_STOPPED";
    ProjectBroadcastPhase3["PROJECT_BROADCAST_PHASE_ARCHIVED"] = "PROJECT_BROADCAST_PHASE_ARCHIVED";
  })(ProjectBroadcastPhase2 = exports2.ProjectBroadcastPhase || (exports2.ProjectBroadcastPhase = {}));
  function projectBroadcastPhaseFromJSON(object) {
    switch (object) {
      case 0:
      case "PROJECT_BROADCAST_PHASE_UNSPECIFIED":
        return ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_UNSPECIFIED;
      case 1:
      case "PROJECT_BROADCAST_PHASE_NOT_RUNNING":
        return ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_NOT_RUNNING;
      case 2:
      case "PROJECT_BROADCAST_PHASE_WAITING":
        return ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_WAITING;
      case 3:
      case "PROJECT_BROADCAST_PHASE_STARTING":
        return ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STARTING;
      case 4:
      case "PROJECT_BROADCAST_PHASE_RUNNING":
        return ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_RUNNING;
      case 5:
      case "PROJECT_BROADCAST_PHASE_STOPPING":
        return ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STOPPING;
      case 6:
      case "PROJECT_BROADCAST_PHASE_STOPPED":
        return ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STOPPED;
      case 7:
      case "PROJECT_BROADCAST_PHASE_ARCHIVED":
        return ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_ARCHIVED;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum ProjectBroadcastPhase");
    }
  }
  exports2.projectBroadcastPhaseFromJSON = projectBroadcastPhaseFromJSON;
  function projectBroadcastPhaseToJSON(object) {
    switch (object) {
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_UNSPECIFIED:
        return "PROJECT_BROADCAST_PHASE_UNSPECIFIED";
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_NOT_RUNNING:
        return "PROJECT_BROADCAST_PHASE_NOT_RUNNING";
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_WAITING:
        return "PROJECT_BROADCAST_PHASE_WAITING";
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STARTING:
        return "PROJECT_BROADCAST_PHASE_STARTING";
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_RUNNING:
        return "PROJECT_BROADCAST_PHASE_RUNNING";
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STOPPING:
        return "PROJECT_BROADCAST_PHASE_STOPPING";
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STOPPED:
        return "PROJECT_BROADCAST_PHASE_STOPPED";
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_ARCHIVED:
        return "PROJECT_BROADCAST_PHASE_ARCHIVED";
      default:
        return "UNKNOWN";
    }
  }
  exports2.projectBroadcastPhaseToJSON = projectBroadcastPhaseToJSON;
  function projectBroadcastPhaseToNumber(object) {
    switch (object) {
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_UNSPECIFIED:
        return 0;
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_NOT_RUNNING:
        return 1;
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_WAITING:
        return 2;
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STARTING:
        return 3;
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_RUNNING:
        return 4;
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STOPPING:
        return 5;
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_STOPPED:
        return 6;
      case ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_ARCHIVED:
        return 7;
      default:
        return 0;
    }
  }
  exports2.projectBroadcastPhaseToNumber = projectBroadcastPhaseToNumber;
  var S3ACL;
  (function(S3ACL2) {
    S3ACL2["S3ACL_UNSPECIFIED"] = "S3ACL_UNSPECIFIED";
    S3ACL2["S3ACL_PRIVATE"] = "S3ACL_PRIVATE";
    S3ACL2["S3ACL_PUBLIC_READ"] = "S3ACL_PUBLIC_READ";
    S3ACL2["S3ACL_PUBLIC_READ_WRITE"] = "S3ACL_PUBLIC_READ_WRITE";
    S3ACL2["S3ACL_AUTHENTICATED_READ"] = "S3ACL_AUTHENTICATED_READ";
    S3ACL2["S3ACL_BUCKET_OWNER_READ"] = "S3ACL_BUCKET_OWNER_READ";
    S3ACL2["S3ACL_BUCKET_OWNER_FULL_CONTROL"] = "S3ACL_BUCKET_OWNER_FULL_CONTROL";
  })(S3ACL = exports2.S3ACL || (exports2.S3ACL = {}));
  function s3ACLFromJSON(object) {
    switch (object) {
      case 0:
      case "S3ACL_UNSPECIFIED":
        return S3ACL.S3ACL_UNSPECIFIED;
      case 1:
      case "S3ACL_PRIVATE":
        return S3ACL.S3ACL_PRIVATE;
      case 2:
      case "S3ACL_PUBLIC_READ":
        return S3ACL.S3ACL_PUBLIC_READ;
      case 3:
      case "S3ACL_PUBLIC_READ_WRITE":
        return S3ACL.S3ACL_PUBLIC_READ_WRITE;
      case 4:
      case "S3ACL_AUTHENTICATED_READ":
        return S3ACL.S3ACL_AUTHENTICATED_READ;
      case 5:
      case "S3ACL_BUCKET_OWNER_READ":
        return S3ACL.S3ACL_BUCKET_OWNER_READ;
      case 6:
      case "S3ACL_BUCKET_OWNER_FULL_CONTROL":
        return S3ACL.S3ACL_BUCKET_OWNER_FULL_CONTROL;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum S3ACL");
    }
  }
  exports2.s3ACLFromJSON = s3ACLFromJSON;
  function s3ACLToJSON(object) {
    switch (object) {
      case S3ACL.S3ACL_UNSPECIFIED:
        return "S3ACL_UNSPECIFIED";
      case S3ACL.S3ACL_PRIVATE:
        return "S3ACL_PRIVATE";
      case S3ACL.S3ACL_PUBLIC_READ:
        return "S3ACL_PUBLIC_READ";
      case S3ACL.S3ACL_PUBLIC_READ_WRITE:
        return "S3ACL_PUBLIC_READ_WRITE";
      case S3ACL.S3ACL_AUTHENTICATED_READ:
        return "S3ACL_AUTHENTICATED_READ";
      case S3ACL.S3ACL_BUCKET_OWNER_READ:
        return "S3ACL_BUCKET_OWNER_READ";
      case S3ACL.S3ACL_BUCKET_OWNER_FULL_CONTROL:
        return "S3ACL_BUCKET_OWNER_FULL_CONTROL";
      default:
        return "UNKNOWN";
    }
  }
  exports2.s3ACLToJSON = s3ACLToJSON;
  function s3ACLToNumber(object) {
    switch (object) {
      case S3ACL.S3ACL_UNSPECIFIED:
        return 0;
      case S3ACL.S3ACL_PRIVATE:
        return 1;
      case S3ACL.S3ACL_PUBLIC_READ:
        return 2;
      case S3ACL.S3ACL_PUBLIC_READ_WRITE:
        return 3;
      case S3ACL.S3ACL_AUTHENTICATED_READ:
        return 4;
      case S3ACL.S3ACL_BUCKET_OWNER_READ:
        return 5;
      case S3ACL.S3ACL_BUCKET_OWNER_FULL_CONTROL:
        return 6;
      default:
        return 0;
    }
  }
  exports2.s3ACLToNumber = s3ACLToNumber;
  var SourceTriggerAction;
  (function(SourceTriggerAction2) {
    SourceTriggerAction2["SOURCE_TRIGGER_ACTION_UNSPECIFIED"] = "SOURCE_TRIGGER_ACTION_UNSPECIFIED";
    SourceTriggerAction2["SOURCE_TRIGGER_ACTION_IGNORE"] = "SOURCE_TRIGGER_ACTION_IGNORE";
    SourceTriggerAction2["SOURCE_TRIGGER_ACTION_OR"] = "SOURCE_TRIGGER_ACTION_OR";
  })(SourceTriggerAction = exports2.SourceTriggerAction || (exports2.SourceTriggerAction = {}));
  function sourceTriggerActionFromJSON(object) {
    switch (object) {
      case 0:
      case "SOURCE_TRIGGER_ACTION_UNSPECIFIED":
        return SourceTriggerAction.SOURCE_TRIGGER_ACTION_UNSPECIFIED;
      case 1:
      case "SOURCE_TRIGGER_ACTION_IGNORE":
        return SourceTriggerAction.SOURCE_TRIGGER_ACTION_IGNORE;
      case 3:
      case "SOURCE_TRIGGER_ACTION_OR":
        return SourceTriggerAction.SOURCE_TRIGGER_ACTION_OR;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum SourceTriggerAction");
    }
  }
  exports2.sourceTriggerActionFromJSON = sourceTriggerActionFromJSON;
  function sourceTriggerActionToJSON(object) {
    switch (object) {
      case SourceTriggerAction.SOURCE_TRIGGER_ACTION_UNSPECIFIED:
        return "SOURCE_TRIGGER_ACTION_UNSPECIFIED";
      case SourceTriggerAction.SOURCE_TRIGGER_ACTION_IGNORE:
        return "SOURCE_TRIGGER_ACTION_IGNORE";
      case SourceTriggerAction.SOURCE_TRIGGER_ACTION_OR:
        return "SOURCE_TRIGGER_ACTION_OR";
      default:
        return "UNKNOWN";
    }
  }
  exports2.sourceTriggerActionToJSON = sourceTriggerActionToJSON;
  function sourceTriggerActionToNumber(object) {
    switch (object) {
      case SourceTriggerAction.SOURCE_TRIGGER_ACTION_UNSPECIFIED:
        return 0;
      case SourceTriggerAction.SOURCE_TRIGGER_ACTION_IGNORE:
        return 1;
      case SourceTriggerAction.SOURCE_TRIGGER_ACTION_OR:
        return 3;
      default:
        return 0;
    }
  }
  exports2.sourceTriggerActionToNumber = sourceTriggerActionToNumber;
  var Region;
  (function(Region2) {
    Region2["REGION_UNSPECIFIED"] = "REGION_UNSPECIFIED";
    Region2["REGION_US_EAST_1"] = "REGION_US_EAST_1";
    Region2["REGION_US_EAST_2"] = "REGION_US_EAST_2";
    Region2["REGION_US_WEST_1"] = "REGION_US_WEST_1";
    Region2["REGION_US_WEST_2"] = "REGION_US_WEST_2";
    Region2["REGION_US_CENTRAL_1"] = "REGION_US_CENTRAL_1";
    Region2["REGION_AP_SOUTHEAST_1"] = "REGION_AP_SOUTHEAST_1";
    Region2["REGION_CA_EAST_1"] = "REGION_CA_EAST_1";
    Region2["REGION_EU_CENTRAL_1"] = "REGION_EU_CENTRAL_1";
    Region2["REGION_EU_WEST_1"] = "REGION_EU_WEST_1";
  })(Region = exports2.Region || (exports2.Region = {}));
  function regionFromJSON(object) {
    switch (object) {
      case 0:
      case "REGION_UNSPECIFIED":
        return Region.REGION_UNSPECIFIED;
      case 1:
      case "REGION_US_EAST_1":
        return Region.REGION_US_EAST_1;
      case 2:
      case "REGION_US_EAST_2":
        return Region.REGION_US_EAST_2;
      case 3:
      case "REGION_US_WEST_1":
        return Region.REGION_US_WEST_1;
      case 4:
      case "REGION_US_WEST_2":
        return Region.REGION_US_WEST_2;
      case 5:
      case "REGION_US_CENTRAL_1":
        return Region.REGION_US_CENTRAL_1;
      case 10:
      case "REGION_AP_SOUTHEAST_1":
        return Region.REGION_AP_SOUTHEAST_1;
      case 20:
      case "REGION_CA_EAST_1":
        return Region.REGION_CA_EAST_1;
      case 30:
      case "REGION_EU_CENTRAL_1":
        return Region.REGION_EU_CENTRAL_1;
      case 31:
      case "REGION_EU_WEST_1":
        return Region.REGION_EU_WEST_1;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum Region");
    }
  }
  exports2.regionFromJSON = regionFromJSON;
  function regionToJSON(object) {
    switch (object) {
      case Region.REGION_UNSPECIFIED:
        return "REGION_UNSPECIFIED";
      case Region.REGION_US_EAST_1:
        return "REGION_US_EAST_1";
      case Region.REGION_US_EAST_2:
        return "REGION_US_EAST_2";
      case Region.REGION_US_WEST_1:
        return "REGION_US_WEST_1";
      case Region.REGION_US_WEST_2:
        return "REGION_US_WEST_2";
      case Region.REGION_US_CENTRAL_1:
        return "REGION_US_CENTRAL_1";
      case Region.REGION_AP_SOUTHEAST_1:
        return "REGION_AP_SOUTHEAST_1";
      case Region.REGION_CA_EAST_1:
        return "REGION_CA_EAST_1";
      case Region.REGION_EU_CENTRAL_1:
        return "REGION_EU_CENTRAL_1";
      case Region.REGION_EU_WEST_1:
        return "REGION_EU_WEST_1";
      default:
        return "UNKNOWN";
    }
  }
  exports2.regionToJSON = regionToJSON;
  function regionToNumber(object) {
    switch (object) {
      case Region.REGION_UNSPECIFIED:
        return 0;
      case Region.REGION_US_EAST_1:
        return 1;
      case Region.REGION_US_EAST_2:
        return 2;
      case Region.REGION_US_WEST_1:
        return 3;
      case Region.REGION_US_WEST_2:
        return 4;
      case Region.REGION_US_CENTRAL_1:
        return 5;
      case Region.REGION_AP_SOUTHEAST_1:
        return 10;
      case Region.REGION_CA_EAST_1:
        return 20;
      case Region.REGION_EU_CENTRAL_1:
        return 30;
      case Region.REGION_EU_WEST_1:
        return 31;
      default:
        return 0;
    }
  }
  exports2.regionToNumber = regionToNumber;
  var Role2;
  (function(Role3) {
    Role3["ROLE_UNSPECIFIED"] = "ROLE_UNSPECIFIED";
    Role3["ROLE_HOST"] = "ROLE_HOST";
    Role3["ROLE_COHOST"] = "ROLE_COHOST";
    Role3["ROLE_CONTRIBUTOR"] = "ROLE_CONTRIBUTOR";
    Role3["ROLE_GUEST"] = "ROLE_GUEST";
    Role3["ROLE_VIEWER"] = "ROLE_VIEWER";
    Role3["ROLE_RENDERER"] = "ROLE_RENDERER";
    Role3["ROLE_PLATFORM"] = "ROLE_PLATFORM";
    Role3["ROLE_IMPERSONATE"] = "ROLE_IMPERSONATE";
  })(Role2 = exports2.Role || (exports2.Role = {}));
  function roleFromJSON(object) {
    switch (object) {
      case 0:
      case "ROLE_UNSPECIFIED":
        return Role2.ROLE_UNSPECIFIED;
      case 1:
      case "ROLE_HOST":
        return Role2.ROLE_HOST;
      case 2:
      case "ROLE_COHOST":
        return Role2.ROLE_COHOST;
      case 3:
      case "ROLE_CONTRIBUTOR":
        return Role2.ROLE_CONTRIBUTOR;
      case 4:
      case "ROLE_GUEST":
        return Role2.ROLE_GUEST;
      case 5:
      case "ROLE_VIEWER":
        return Role2.ROLE_VIEWER;
      case 6:
      case "ROLE_RENDERER":
        return Role2.ROLE_RENDERER;
      case 7:
      case "ROLE_PLATFORM":
        return Role2.ROLE_PLATFORM;
      case 8:
      case "ROLE_IMPERSONATE":
        return Role2.ROLE_IMPERSONATE;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum Role");
    }
  }
  exports2.roleFromJSON = roleFromJSON;
  function roleToJSON(object) {
    switch (object) {
      case Role2.ROLE_UNSPECIFIED:
        return "ROLE_UNSPECIFIED";
      case Role2.ROLE_HOST:
        return "ROLE_HOST";
      case Role2.ROLE_COHOST:
        return "ROLE_COHOST";
      case Role2.ROLE_CONTRIBUTOR:
        return "ROLE_CONTRIBUTOR";
      case Role2.ROLE_GUEST:
        return "ROLE_GUEST";
      case Role2.ROLE_VIEWER:
        return "ROLE_VIEWER";
      case Role2.ROLE_RENDERER:
        return "ROLE_RENDERER";
      case Role2.ROLE_PLATFORM:
        return "ROLE_PLATFORM";
      case Role2.ROLE_IMPERSONATE:
        return "ROLE_IMPERSONATE";
      default:
        return "UNKNOWN";
    }
  }
  exports2.roleToJSON = roleToJSON;
  function roleToNumber(object) {
    switch (object) {
      case Role2.ROLE_UNSPECIFIED:
        return 0;
      case Role2.ROLE_HOST:
        return 1;
      case Role2.ROLE_COHOST:
        return 2;
      case Role2.ROLE_CONTRIBUTOR:
        return 3;
      case Role2.ROLE_GUEST:
        return 4;
      case Role2.ROLE_VIEWER:
        return 5;
      case Role2.ROLE_RENDERER:
        return 6;
      case Role2.ROLE_PLATFORM:
        return 7;
      case Role2.ROLE_IMPERSONATE:
        return 8;
      default:
        return 0;
    }
  }
  exports2.roleToNumber = roleToNumber;
  var ProjectBroadcastError;
  (function(ProjectBroadcastError2) {
    ProjectBroadcastError2["PROJECT_BROADCAST_ERROR_UNSPECIFIED"] = "PROJECT_BROADCAST_ERROR_UNSPECIFIED";
    ProjectBroadcastError2["PROJECT_BROADCAST_ERROR_INTERNAL"] = "PROJECT_BROADCAST_ERROR_INTERNAL";
    ProjectBroadcastError2["PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED"] = "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED";
  })(ProjectBroadcastError = exports2.ProjectBroadcastError || (exports2.ProjectBroadcastError = {}));
  function projectBroadcastErrorFromJSON(object) {
    switch (object) {
      case 0:
      case "PROJECT_BROADCAST_ERROR_UNSPECIFIED":
        return ProjectBroadcastError.PROJECT_BROADCAST_ERROR_UNSPECIFIED;
      case 1:
      case "PROJECT_BROADCAST_ERROR_INTERNAL":
        return ProjectBroadcastError.PROJECT_BROADCAST_ERROR_INTERNAL;
      case 2:
      case "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED":
        return ProjectBroadcastError.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum ProjectBroadcastError");
    }
  }
  exports2.projectBroadcastErrorFromJSON = projectBroadcastErrorFromJSON;
  function projectBroadcastErrorToJSON(object) {
    switch (object) {
      case ProjectBroadcastError.PROJECT_BROADCAST_ERROR_UNSPECIFIED:
        return "PROJECT_BROADCAST_ERROR_UNSPECIFIED";
      case ProjectBroadcastError.PROJECT_BROADCAST_ERROR_INTERNAL:
        return "PROJECT_BROADCAST_ERROR_INTERNAL";
      case ProjectBroadcastError.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED:
        return "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED";
      default:
        return "UNKNOWN";
    }
  }
  exports2.projectBroadcastErrorToJSON = projectBroadcastErrorToJSON;
  function projectBroadcastErrorToNumber(object) {
    switch (object) {
      case ProjectBroadcastError.PROJECT_BROADCAST_ERROR_UNSPECIFIED:
        return 0;
      case ProjectBroadcastError.PROJECT_BROADCAST_ERROR_INTERNAL:
        return 1;
      case ProjectBroadcastError.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED:
        return 2;
      default:
        return 0;
    }
  }
  exports2.projectBroadcastErrorToNumber = projectBroadcastErrorToNumber;
  var ConnectState;
  (function(ConnectState2) {
    ConnectState2["CONNECT_STATE_UNSPECIFIED"] = "CONNECT_STATE_UNSPECIFIED";
    ConnectState2["CONNECT_STATE_CONNECTED"] = "CONNECT_STATE_CONNECTED";
    ConnectState2["CONNECT_STATE_DISCONNECTED"] = "CONNECT_STATE_DISCONNECTED";
  })(ConnectState = exports2.ConnectState || (exports2.ConnectState = {}));
  function connectStateFromJSON(object) {
    switch (object) {
      case 0:
      case "CONNECT_STATE_UNSPECIFIED":
        return ConnectState.CONNECT_STATE_UNSPECIFIED;
      case 1:
      case "CONNECT_STATE_CONNECTED":
        return ConnectState.CONNECT_STATE_CONNECTED;
      case 2:
      case "CONNECT_STATE_DISCONNECTED":
        return ConnectState.CONNECT_STATE_DISCONNECTED;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum ConnectState");
    }
  }
  exports2.connectStateFromJSON = connectStateFromJSON;
  function connectStateToJSON(object) {
    switch (object) {
      case ConnectState.CONNECT_STATE_UNSPECIFIED:
        return "CONNECT_STATE_UNSPECIFIED";
      case ConnectState.CONNECT_STATE_CONNECTED:
        return "CONNECT_STATE_CONNECTED";
      case ConnectState.CONNECT_STATE_DISCONNECTED:
        return "CONNECT_STATE_DISCONNECTED";
      default:
        return "UNKNOWN";
    }
  }
  exports2.connectStateToJSON = connectStateToJSON;
  function connectStateToNumber(object) {
    switch (object) {
      case ConnectState.CONNECT_STATE_UNSPECIFIED:
        return 0;
      case ConnectState.CONNECT_STATE_CONNECTED:
        return 1;
      case ConnectState.CONNECT_STATE_DISCONNECTED:
        return 2;
      default:
        return 0;
    }
  }
  exports2.connectStateToNumber = connectStateToNumber;
  var EventSubType2;
  (function(EventSubType3) {
    EventSubType3["EVENT_SUB_TYPE_UNSPECIFIED"] = "EVENT_SUB_TYPE_UNSPECIFIED";
    EventSubType3["EVENT_SUB_TYPE_CREATE"] = "EVENT_SUB_TYPE_CREATE";
    EventSubType3["EVENT_SUB_TYPE_UPDATE"] = "EVENT_SUB_TYPE_UPDATE";
    EventSubType3["EVENT_SUB_TYPE_DELETE"] = "EVENT_SUB_TYPE_DELETE";
    EventSubType3["EVENT_SUB_TYPE_ADD"] = "EVENT_SUB_TYPE_ADD";
    EventSubType3["EVENT_SUB_TYPE_REMOVE"] = "EVENT_SUB_TYPE_REMOVE";
    EventSubType3["EVENT_SUB_TYPE_STATE"] = "EVENT_SUB_TYPE_STATE";
  })(EventSubType2 = exports2.EventSubType || (exports2.EventSubType = {}));
  function eventSubTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "EVENT_SUB_TYPE_UNSPECIFIED":
        return EventSubType2.EVENT_SUB_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_SUB_TYPE_CREATE":
        return EventSubType2.EVENT_SUB_TYPE_CREATE;
      case 2:
      case "EVENT_SUB_TYPE_UPDATE":
        return EventSubType2.EVENT_SUB_TYPE_UPDATE;
      case 3:
      case "EVENT_SUB_TYPE_DELETE":
        return EventSubType2.EVENT_SUB_TYPE_DELETE;
      case 4:
      case "EVENT_SUB_TYPE_ADD":
        return EventSubType2.EVENT_SUB_TYPE_ADD;
      case 5:
      case "EVENT_SUB_TYPE_REMOVE":
        return EventSubType2.EVENT_SUB_TYPE_REMOVE;
      case 6:
      case "EVENT_SUB_TYPE_STATE":
        return EventSubType2.EVENT_SUB_TYPE_STATE;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum EventSubType");
    }
  }
  exports2.eventSubTypeFromJSON = eventSubTypeFromJSON;
  function eventSubTypeToJSON(object) {
    switch (object) {
      case EventSubType2.EVENT_SUB_TYPE_UNSPECIFIED:
        return "EVENT_SUB_TYPE_UNSPECIFIED";
      case EventSubType2.EVENT_SUB_TYPE_CREATE:
        return "EVENT_SUB_TYPE_CREATE";
      case EventSubType2.EVENT_SUB_TYPE_UPDATE:
        return "EVENT_SUB_TYPE_UPDATE";
      case EventSubType2.EVENT_SUB_TYPE_DELETE:
        return "EVENT_SUB_TYPE_DELETE";
      case EventSubType2.EVENT_SUB_TYPE_ADD:
        return "EVENT_SUB_TYPE_ADD";
      case EventSubType2.EVENT_SUB_TYPE_REMOVE:
        return "EVENT_SUB_TYPE_REMOVE";
      case EventSubType2.EVENT_SUB_TYPE_STATE:
        return "EVENT_SUB_TYPE_STATE";
      default:
        return "UNKNOWN";
    }
  }
  exports2.eventSubTypeToJSON = eventSubTypeToJSON;
  function eventSubTypeToNumber(object) {
    switch (object) {
      case EventSubType2.EVENT_SUB_TYPE_UNSPECIFIED:
        return 0;
      case EventSubType2.EVENT_SUB_TYPE_CREATE:
        return 1;
      case EventSubType2.EVENT_SUB_TYPE_UPDATE:
        return 2;
      case EventSubType2.EVENT_SUB_TYPE_DELETE:
        return 3;
      case EventSubType2.EVENT_SUB_TYPE_ADD:
        return 4;
      case EventSubType2.EVENT_SUB_TYPE_REMOVE:
        return 5;
      case EventSubType2.EVENT_SUB_TYPE_STATE:
        return 6;
      default:
        return 0;
    }
  }
  exports2.eventSubTypeToNumber = eventSubTypeToNumber;
  var EventType2;
  (function(EventType3) {
    EventType3["EVENT_TYPE_UNSPECIFIED"] = "EVENT_TYPE_UNSPECIFIED";
    EventType3["EVENT_TYPE_COLLECTION"] = "EVENT_TYPE_COLLECTION";
    EventType3["EVENT_TYPE_PROJECT"] = "EVENT_TYPE_PROJECT";
    EventType3["EVENT_TYPE_SOURCE"] = "EVENT_TYPE_SOURCE";
    EventType3["EVENT_TYPE_DESTINATION"] = "EVENT_TYPE_DESTINATION";
  })(EventType2 = exports2.EventType || (exports2.EventType = {}));
  function eventTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "EVENT_TYPE_UNSPECIFIED":
        return EventType2.EVENT_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_TYPE_COLLECTION":
        return EventType2.EVENT_TYPE_COLLECTION;
      case 2:
      case "EVENT_TYPE_PROJECT":
        return EventType2.EVENT_TYPE_PROJECT;
      case 4:
      case "EVENT_TYPE_SOURCE":
        return EventType2.EVENT_TYPE_SOURCE;
      case 5:
      case "EVENT_TYPE_DESTINATION":
        return EventType2.EVENT_TYPE_DESTINATION;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum EventType");
    }
  }
  exports2.eventTypeFromJSON = eventTypeFromJSON;
  function eventTypeToJSON(object) {
    switch (object) {
      case EventType2.EVENT_TYPE_UNSPECIFIED:
        return "EVENT_TYPE_UNSPECIFIED";
      case EventType2.EVENT_TYPE_COLLECTION:
        return "EVENT_TYPE_COLLECTION";
      case EventType2.EVENT_TYPE_PROJECT:
        return "EVENT_TYPE_PROJECT";
      case EventType2.EVENT_TYPE_SOURCE:
        return "EVENT_TYPE_SOURCE";
      case EventType2.EVENT_TYPE_DESTINATION:
        return "EVENT_TYPE_DESTINATION";
      default:
        return "UNKNOWN";
    }
  }
  exports2.eventTypeToJSON = eventTypeToJSON;
  function eventTypeToNumber(object) {
    switch (object) {
      case EventType2.EVENT_TYPE_UNSPECIFIED:
        return 0;
      case EventType2.EVENT_TYPE_COLLECTION:
        return 1;
      case EventType2.EVENT_TYPE_PROJECT:
        return 2;
      case EventType2.EVENT_TYPE_SOURCE:
        return 4;
      case EventType2.EVENT_TYPE_DESTINATION:
        return 5;
      default:
        return 0;
    }
  }
  exports2.eventTypeToNumber = eventTypeToNumber;
  function createBaseVideoRendering() {
    return {
      height: void 0,
      width: void 0,
      framerate: void 0,
      colorSpace: void 0
    };
  }
  exports2.VideoRendering = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.height !== void 0) {
        writer2.uint32(8).uint32(message.height);
      }
      if (message.width !== void 0) {
        writer2.uint32(16).uint32(message.width);
      }
      if (message.framerate !== void 0) {
        writer2.uint32(29).float(message.framerate);
      }
      if (message.colorSpace !== void 0) {
        writer2.uint32(32).int32(videoColorSpaceToNumber(message.colorSpace));
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseVideoRendering();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.height = reader2.uint32();
            break;
          case 2:
            message.width = reader2.uint32();
            break;
          case 3:
            message.framerate = reader2.float();
            break;
          case 4:
            message.colorSpace = videoColorSpaceFromJSON(reader2.int32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        height: isSet2(object.height) ? Number(object.height) : void 0,
        width: isSet2(object.width) ? Number(object.width) : void 0,
        framerate: isSet2(object.framerate) ? Number(object.framerate) : void 0,
        colorSpace: isSet2(object.colorSpace) ? videoColorSpaceFromJSON(object.colorSpace) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.height !== void 0 && (obj.height = Math.round(message.height));
      message.width !== void 0 && (obj.width = Math.round(message.width));
      message.framerate !== void 0 && (obj.framerate = message.framerate);
      message.colorSpace !== void 0 && (obj.colorSpace = message.colorSpace !== void 0 ? videoColorSpaceToJSON(message.colorSpace) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d;
      const message = createBaseVideoRendering();
      message.height = (_a2 = object.height) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.width = (_b = object.width) !== null && _b !== void 0 ? _b : void 0;
      message.framerate = (_c = object.framerate) !== null && _c !== void 0 ? _c : void 0;
      message.colorSpace = (_d = object.colorSpace) !== null && _d !== void 0 ? _d : void 0;
      return message;
    }
  };
  function createBaseAudioRendering() {
    return { channelLayout: void 0 };
  }
  exports2.AudioRendering = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.channelLayout !== void 0) {
        writer2.uint32(8).int32(audioChannelLayoutToNumber(message.channelLayout));
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseAudioRendering();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.channelLayout = audioChannelLayoutFromJSON(reader2.int32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        channelLayout: isSet2(object.channelLayout) ? audioChannelLayoutFromJSON(object.channelLayout) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.channelLayout !== void 0 && (obj.channelLayout = message.channelLayout !== void 0 ? audioChannelLayoutToJSON(message.channelLayout) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseAudioRendering();
      message.channelLayout = (_a2 = object.channelLayout) !== null && _a2 !== void 0 ? _a2 : void 0;
      return message;
    }
  };
  function createBaseRendering() {
    return {
      video: void 0,
      audio: void 0,
      quality: void 0,
      targetLatency: void 0,
      complexity: void 0
    };
  }
  exports2.Rendering = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.video !== void 0) {
        exports2.VideoRendering.encode(message.video, writer2.uint32(10).fork()).ldelim();
      }
      if (message.audio !== void 0) {
        exports2.AudioRendering.encode(message.audio, writer2.uint32(18).fork()).ldelim();
      }
      if (message.quality !== void 0) {
        writer2.uint32(24).int32(renderingQualityToNumber(message.quality));
      }
      if (message.targetLatency !== void 0) {
        writer2.uint32(32).uint32(message.targetLatency);
      }
      if (message.complexity !== void 0) {
        writer2.uint32(40).int32(message.complexity);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseRendering();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.video = exports2.VideoRendering.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.audio = exports2.AudioRendering.decode(reader2, reader2.uint32());
            break;
          case 3:
            message.quality = renderingQualityFromJSON(reader2.int32());
            break;
          case 4:
            message.targetLatency = reader2.uint32();
            break;
          case 5:
            message.complexity = reader2.int32();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        video: isSet2(object.video) ? exports2.VideoRendering.fromJSON(object.video) : void 0,
        audio: isSet2(object.audio) ? exports2.AudioRendering.fromJSON(object.audio) : void 0,
        quality: isSet2(object.quality) ? renderingQualityFromJSON(object.quality) : void 0,
        targetLatency: isSet2(object.targetLatency) ? Number(object.targetLatency) : void 0,
        complexity: isSet2(object.complexity) ? Number(object.complexity) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.video !== void 0 && (obj.video = message.video ? exports2.VideoRendering.toJSON(message.video) : void 0);
      message.audio !== void 0 && (obj.audio = message.audio ? exports2.AudioRendering.toJSON(message.audio) : void 0);
      message.quality !== void 0 && (obj.quality = message.quality !== void 0 ? renderingQualityToJSON(message.quality) : void 0);
      message.targetLatency !== void 0 && (obj.targetLatency = Math.round(message.targetLatency));
      message.complexity !== void 0 && (obj.complexity = Math.round(message.complexity));
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseRendering();
      message.video = object.video !== void 0 && object.video !== null ? exports2.VideoRendering.fromPartial(object.video) : void 0;
      message.audio = object.audio !== void 0 && object.audio !== null ? exports2.AudioRendering.fromPartial(object.audio) : void 0;
      message.quality = (_a2 = object.quality) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.targetLatency = (_b = object.targetLatency) !== null && _b !== void 0 ? _b : void 0;
      message.complexity = (_c = object.complexity) !== null && _c !== void 0 ? _c : void 0;
      return message;
    }
  };
  function createBaseVideoCodecRateControl() {
    return {
      mode: void 0,
      targetBitrate: void 0,
      maxKeyFrameInterval: void 0
    };
  }
  exports2.VideoCodecRateControl = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.mode !== void 0) {
        writer2.uint32(8).int32(videoCodecRateControlModeToNumber(message.mode));
      }
      if (message.targetBitrate !== void 0) {
        writer2.uint32(16).uint32(message.targetBitrate);
      }
      if (message.maxKeyFrameInterval !== void 0) {
        writer2.uint32(24).uint32(message.maxKeyFrameInterval);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseVideoCodecRateControl();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.mode = videoCodecRateControlModeFromJSON(reader2.int32());
            break;
          case 2:
            message.targetBitrate = reader2.uint32();
            break;
          case 3:
            message.maxKeyFrameInterval = reader2.uint32();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        mode: isSet2(object.mode) ? videoCodecRateControlModeFromJSON(object.mode) : void 0,
        targetBitrate: isSet2(object.targetBitrate) ? Number(object.targetBitrate) : void 0,
        maxKeyFrameInterval: isSet2(object.maxKeyFrameInterval) ? Number(object.maxKeyFrameInterval) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.mode !== void 0 && (obj.mode = message.mode !== void 0 ? videoCodecRateControlModeToJSON(message.mode) : void 0);
      message.targetBitrate !== void 0 && (obj.targetBitrate = Math.round(message.targetBitrate));
      message.maxKeyFrameInterval !== void 0 && (obj.maxKeyFrameInterval = Math.round(message.maxKeyFrameInterval));
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseVideoCodecRateControl();
      message.mode = (_a2 = object.mode) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.targetBitrate = (_b = object.targetBitrate) !== null && _b !== void 0 ? _b : void 0;
      message.maxKeyFrameInterval = (_c = object.maxKeyFrameInterval) !== null && _c !== void 0 ? _c : void 0;
      return message;
    }
  };
  function createBaseVideoEncoding() {
    return { codec: void 0, rateControl: void 0, profile: void 0 };
  }
  exports2.VideoEncoding = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.codec !== void 0) {
        writer2.uint32(8).int32(videoCodecToNumber(message.codec));
      }
      if (message.rateControl !== void 0) {
        exports2.VideoCodecRateControl.encode(message.rateControl, writer2.uint32(18).fork()).ldelim();
      }
      if (message.profile !== void 0) {
        writer2.uint32(32).int32(videoCodecProfileToNumber(message.profile));
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseVideoEncoding();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.codec = videoCodecFromJSON(reader2.int32());
            break;
          case 2:
            message.rateControl = exports2.VideoCodecRateControl.decode(reader2, reader2.uint32());
            break;
          case 4:
            message.profile = videoCodecProfileFromJSON(reader2.int32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        codec: isSet2(object.codec) ? videoCodecFromJSON(object.codec) : void 0,
        rateControl: isSet2(object.rateControl) ? exports2.VideoCodecRateControl.fromJSON(object.rateControl) : void 0,
        profile: isSet2(object.profile) ? videoCodecProfileFromJSON(object.profile) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.codec !== void 0 && (obj.codec = message.codec !== void 0 ? videoCodecToJSON(message.codec) : void 0);
      message.rateControl !== void 0 && (obj.rateControl = message.rateControl ? exports2.VideoCodecRateControl.toJSON(message.rateControl) : void 0);
      message.profile !== void 0 && (obj.profile = message.profile !== void 0 ? videoCodecProfileToJSON(message.profile) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseVideoEncoding();
      message.codec = (_a2 = object.codec) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.rateControl = object.rateControl !== void 0 && object.rateControl !== null ? exports2.VideoCodecRateControl.fromPartial(object.rateControl) : void 0;
      message.profile = (_b = object.profile) !== null && _b !== void 0 ? _b : void 0;
      return message;
    }
  };
  function createBaseAudioEncoding() {
    return { codec: void 0 };
  }
  exports2.AudioEncoding = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.codec !== void 0) {
        writer2.uint32(8).int32(audioCodecToNumber(message.codec));
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseAudioEncoding();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.codec = audioCodecFromJSON(reader2.int32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        codec: isSet2(object.codec) ? audioCodecFromJSON(object.codec) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.codec !== void 0 && (obj.codec = message.codec !== void 0 ? audioCodecToJSON(message.codec) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseAudioEncoding();
      message.codec = (_a2 = object.codec) !== null && _a2 !== void 0 ? _a2 : void 0;
      return message;
    }
  };
  function createBaseEncoding() {
    return { video: void 0, audio: void 0 };
  }
  exports2.Encoding = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.video !== void 0) {
        exports2.VideoEncoding.encode(message.video, writer2.uint32(10).fork()).ldelim();
      }
      if (message.audio !== void 0) {
        exports2.AudioEncoding.encode(message.audio, writer2.uint32(18).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseEncoding();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.video = exports2.VideoEncoding.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.audio = exports2.AudioEncoding.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        video: isSet2(object.video) ? exports2.VideoEncoding.fromJSON(object.video) : void 0,
        audio: isSet2(object.audio) ? exports2.AudioEncoding.fromJSON(object.audio) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.video !== void 0 && (obj.video = message.video ? exports2.VideoEncoding.toJSON(message.video) : void 0);
      message.audio !== void 0 && (obj.audio = message.audio ? exports2.AudioEncoding.toJSON(message.audio) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseEncoding();
      message.video = object.video !== void 0 && object.video !== null ? exports2.VideoEncoding.fromPartial(object.video) : void 0;
      message.audio = object.audio !== void 0 && object.audio !== null ? exports2.AudioEncoding.fromPartial(object.audio) : void 0;
      return message;
    }
  };
  function createBaseSourceRtmpPushAddress() {
    return {
      enabled: void 0,
      key: void 0,
      url: void 0,
      baseUrl: void 0
    };
  }
  exports2.SourceRtmpPushAddress = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.enabled !== void 0) {
        writer2.uint32(8).bool(message.enabled);
      }
      if (message.key !== void 0) {
        writer2.uint32(18).string(message.key);
      }
      if (message.url !== void 0) {
        writer2.uint32(26).string(message.url);
      }
      if (message.baseUrl !== void 0) {
        writer2.uint32(34).string(message.baseUrl);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseSourceRtmpPushAddress();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.enabled = reader2.bool();
            break;
          case 2:
            message.key = reader2.string();
            break;
          case 3:
            message.url = reader2.string();
            break;
          case 4:
            message.baseUrl = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        enabled: isSet2(object.enabled) ? Boolean(object.enabled) : void 0,
        key: isSet2(object.key) ? String(object.key) : void 0,
        url: isSet2(object.url) ? String(object.url) : void 0,
        baseUrl: isSet2(object.baseUrl) ? String(object.baseUrl) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.enabled !== void 0 && (obj.enabled = message.enabled);
      message.key !== void 0 && (obj.key = message.key);
      message.url !== void 0 && (obj.url = message.url);
      message.baseUrl !== void 0 && (obj.baseUrl = message.baseUrl);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d;
      const message = createBaseSourceRtmpPushAddress();
      message.enabled = (_a2 = object.enabled) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.key = (_b = object.key) !== null && _b !== void 0 ? _b : void 0;
      message.url = (_c = object.url) !== null && _c !== void 0 ? _c : void 0;
      message.baseUrl = (_d = object.baseUrl) !== null && _d !== void 0 ? _d : void 0;
      return message;
    }
  };
  function createBaseSrtPushAddress() {
    return {
      enabled: void 0,
      streamId: void 0,
      url: void 0,
      baseUrl: void 0
    };
  }
  exports2.SrtPushAddress = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.enabled !== void 0) {
        writer2.uint32(8).bool(message.enabled);
      }
      if (message.streamId !== void 0) {
        writer2.uint32(18).string(message.streamId);
      }
      if (message.url !== void 0) {
        writer2.uint32(26).string(message.url);
      }
      if (message.baseUrl !== void 0) {
        writer2.uint32(34).string(message.baseUrl);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseSrtPushAddress();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.enabled = reader2.bool();
            break;
          case 2:
            message.streamId = reader2.string();
            break;
          case 3:
            message.url = reader2.string();
            break;
          case 4:
            message.baseUrl = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        enabled: isSet2(object.enabled) ? Boolean(object.enabled) : void 0,
        streamId: isSet2(object.streamId) ? String(object.streamId) : void 0,
        url: isSet2(object.url) ? String(object.url) : void 0,
        baseUrl: isSet2(object.baseUrl) ? String(object.baseUrl) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.enabled !== void 0 && (obj.enabled = message.enabled);
      message.streamId !== void 0 && (obj.streamId = message.streamId);
      message.url !== void 0 && (obj.url = message.url);
      message.baseUrl !== void 0 && (obj.baseUrl = message.baseUrl);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d;
      const message = createBaseSrtPushAddress();
      message.enabled = (_a2 = object.enabled) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.streamId = (_b = object.streamId) !== null && _b !== void 0 ? _b : void 0;
      message.url = (_c = object.url) !== null && _c !== void 0 ? _c : void 0;
      message.baseUrl = (_d = object.baseUrl) !== null && _d !== void 0 ? _d : void 0;
      return message;
    }
  };
  function createBaseRtmpPullAddress() {
    return { url: "" };
  }
  exports2.RtmpPullAddress = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.url !== "") {
        writer2.uint32(10).string(message.url);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseRtmpPullAddress();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.url = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        url: isSet2(object.url) ? String(object.url) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.url !== void 0 && (obj.url = message.url);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseRtmpPullAddress();
      message.url = (_a2 = object.url) !== null && _a2 !== void 0 ? _a2 : "";
      return message;
    }
  };
  function createBaseSourceAddress() {
    return { rtmpPush: void 0, srtPush: void 0, rtmpPull: void 0 };
  }
  exports2.SourceAddress = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.rtmpPush !== void 0) {
        exports2.SourceRtmpPushAddress.encode(message.rtmpPush, writer2.uint32(10).fork()).ldelim();
      }
      if (message.srtPush !== void 0) {
        exports2.SrtPushAddress.encode(message.srtPush, writer2.uint32(18).fork()).ldelim();
      }
      if (message.rtmpPull !== void 0) {
        exports2.RtmpPullAddress.encode(message.rtmpPull, writer2.uint32(26).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseSourceAddress();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.rtmpPush = exports2.SourceRtmpPushAddress.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.srtPush = exports2.SrtPushAddress.decode(reader2, reader2.uint32());
            break;
          case 3:
            message.rtmpPull = exports2.RtmpPullAddress.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        rtmpPush: isSet2(object.rtmpPush) ? exports2.SourceRtmpPushAddress.fromJSON(object.rtmpPush) : void 0,
        srtPush: isSet2(object.srtPush) ? exports2.SrtPushAddress.fromJSON(object.srtPush) : void 0,
        rtmpPull: isSet2(object.rtmpPull) ? exports2.RtmpPullAddress.fromJSON(object.rtmpPull) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.rtmpPush !== void 0 && (obj.rtmpPush = message.rtmpPush ? exports2.SourceRtmpPushAddress.toJSON(message.rtmpPush) : void 0);
      message.srtPush !== void 0 && (obj.srtPush = message.srtPush ? exports2.SrtPushAddress.toJSON(message.srtPush) : void 0);
      message.rtmpPull !== void 0 && (obj.rtmpPull = message.rtmpPull ? exports2.RtmpPullAddress.toJSON(message.rtmpPull) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseSourceAddress();
      message.rtmpPush = object.rtmpPush !== void 0 && object.rtmpPush !== null ? exports2.SourceRtmpPushAddress.fromPartial(object.rtmpPush) : void 0;
      message.srtPush = object.srtPush !== void 0 && object.srtPush !== null ? exports2.SrtPushAddress.fromPartial(object.srtPush) : void 0;
      message.rtmpPull = object.rtmpPull !== void 0 && object.rtmpPull !== null ? exports2.RtmpPullAddress.fromPartial(object.rtmpPull) : void 0;
      return message;
    }
  };
  function createBaseDestinationRtmpPushAddress() {
    return { key: void 0, url: "" };
  }
  exports2.DestinationRtmpPushAddress = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.key !== void 0) {
        writer2.uint32(10).string(message.key);
      }
      if (message.url !== "") {
        writer2.uint32(18).string(message.url);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDestinationRtmpPushAddress();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.key = reader2.string();
            break;
          case 2:
            message.url = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        key: isSet2(object.key) ? String(object.key) : void 0,
        url: isSet2(object.url) ? String(object.url) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.key !== void 0 && (obj.key = message.key);
      message.url !== void 0 && (obj.url = message.url);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseDestinationRtmpPushAddress();
      message.key = (_a2 = object.key) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.url = (_b = object.url) !== null && _b !== void 0 ? _b : "";
      return message;
    }
  };
  function createBaseDestinationAgoraPushAddress() {
    return { appId: "", channelId: "", userId: "" };
  }
  exports2.DestinationAgoraPushAddress = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.appId !== "") {
        writer2.uint32(10).string(message.appId);
      }
      if (message.channelId !== "") {
        writer2.uint32(18).string(message.channelId);
      }
      if (message.userId !== "") {
        writer2.uint32(26).string(message.userId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDestinationAgoraPushAddress();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.appId = reader2.string();
            break;
          case 2:
            message.channelId = reader2.string();
            break;
          case 3:
            message.userId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        appId: isSet2(object.appId) ? String(object.appId) : "",
        channelId: isSet2(object.channelId) ? String(object.channelId) : "",
        userId: isSet2(object.userId) ? String(object.userId) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.appId !== void 0 && (obj.appId = message.appId);
      message.channelId !== void 0 && (obj.channelId = message.channelId);
      message.userId !== void 0 && (obj.userId = message.userId);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseDestinationAgoraPushAddress();
      message.appId = (_a2 = object.appId) !== null && _a2 !== void 0 ? _a2 : "";
      message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
      message.userId = (_c = object.userId) !== null && _c !== void 0 ? _c : "";
      return message;
    }
  };
  function createBaseHlsLifecycleLive() {
    return { playlistCount: void 0, fileCount: void 0 };
  }
  exports2.HlsLifecycleLive = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.playlistCount !== void 0) {
        writer2.uint32(8).int32(message.playlistCount);
      }
      if (message.fileCount !== void 0) {
        writer2.uint32(16).int32(message.fileCount);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseHlsLifecycleLive();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.playlistCount = reader2.int32();
            break;
          case 2:
            message.fileCount = reader2.int32();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        playlistCount: isSet2(object.playlistCount) ? Number(object.playlistCount) : void 0,
        fileCount: isSet2(object.fileCount) ? Number(object.fileCount) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.playlistCount !== void 0 && (obj.playlistCount = Math.round(message.playlistCount));
      message.fileCount !== void 0 && (obj.fileCount = Math.round(message.fileCount));
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseHlsLifecycleLive();
      message.playlistCount = (_a2 = object.playlistCount) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.fileCount = (_b = object.fileCount) !== null && _b !== void 0 ? _b : void 0;
      return message;
    }
  };
  function createBaseHlsLifecycleVod() {
    return { maxDuration: void 0 };
  }
  exports2.HlsLifecycleVod = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.maxDuration !== void 0) {
        writer2.uint32(8).int32(message.maxDuration);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseHlsLifecycleVod();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.maxDuration = reader2.int32();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        maxDuration: isSet2(object.maxDuration) ? Number(object.maxDuration) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.maxDuration !== void 0 && (obj.maxDuration = Math.round(message.maxDuration));
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseHlsLifecycleVod();
      message.maxDuration = (_a2 = object.maxDuration) !== null && _a2 !== void 0 ? _a2 : void 0;
      return message;
    }
  };
  function createBaseHlsLifecycle() {
    return { vod: void 0, live: void 0 };
  }
  exports2.HlsLifecycle = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.vod !== void 0) {
        exports2.HlsLifecycleVod.encode(message.vod, writer2.uint32(10).fork()).ldelim();
      }
      if (message.live !== void 0) {
        exports2.HlsLifecycleLive.encode(message.live, writer2.uint32(18).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseHlsLifecycle();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.vod = exports2.HlsLifecycleVod.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.live = exports2.HlsLifecycleLive.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        vod: isSet2(object.vod) ? exports2.HlsLifecycleVod.fromJSON(object.vod) : void 0,
        live: isSet2(object.live) ? exports2.HlsLifecycleLive.fromJSON(object.live) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.vod !== void 0 && (obj.vod = message.vod ? exports2.HlsLifecycleVod.toJSON(message.vod) : void 0);
      message.live !== void 0 && (obj.live = message.live ? exports2.HlsLifecycleLive.toJSON(message.live) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseHlsLifecycle();
      message.vod = object.vod !== void 0 && object.vod !== null ? exports2.HlsLifecycleVod.fromPartial(object.vod) : void 0;
      message.live = object.live !== void 0 && object.live !== null ? exports2.HlsLifecycleLive.fromPartial(object.live) : void 0;
      return message;
    }
  };
  function createBaseHlsPackaging() {
    return { lifecycle: void 0, segmentDuration: void 0 };
  }
  exports2.HlsPackaging = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.lifecycle !== void 0) {
        exports2.HlsLifecycle.encode(message.lifecycle, writer2.uint32(10).fork()).ldelim();
      }
      if (message.segmentDuration !== void 0) {
        writer2.uint32(16).int32(message.segmentDuration);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseHlsPackaging();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.lifecycle = exports2.HlsLifecycle.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.segmentDuration = reader2.int32();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        lifecycle: isSet2(object.lifecycle) ? exports2.HlsLifecycle.fromJSON(object.lifecycle) : void 0,
        segmentDuration: isSet2(object.segmentDuration) ? Number(object.segmentDuration) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.lifecycle !== void 0 && (obj.lifecycle = message.lifecycle ? exports2.HlsLifecycle.toJSON(message.lifecycle) : void 0);
      message.segmentDuration !== void 0 && (obj.segmentDuration = Math.round(message.segmentDuration));
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseHlsPackaging();
      message.lifecycle = object.lifecycle !== void 0 && object.lifecycle !== null ? exports2.HlsLifecycle.fromPartial(object.lifecycle) : void 0;
      message.segmentDuration = (_a2 = object.segmentDuration) !== null && _a2 !== void 0 ? _a2 : void 0;
      return message;
    }
  };
  function createBaseObjectStoragePackaging() {
    return { hls: void 0 };
  }
  exports2.ObjectStoragePackaging = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.hls !== void 0) {
        exports2.HlsPackaging.encode(message.hls, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseObjectStoragePackaging();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.hls = exports2.HlsPackaging.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        hls: isSet2(object.hls) ? exports2.HlsPackaging.fromJSON(object.hls) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.hls !== void 0 && (obj.hls = message.hls ? exports2.HlsPackaging.toJSON(message.hls) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseObjectStoragePackaging();
      message.hls = object.hls !== void 0 && object.hls !== null ? exports2.HlsPackaging.fromPartial(object.hls) : void 0;
      return message;
    }
  };
  function createBaseS3StorageAddress() {
    return {
      region: "",
      bucket: "",
      prefix: void 0,
      accessKey: "",
      secretKey: "",
      token: void 0,
      tokenDuration: void 0,
      acl: void 0,
      endpoint: void 0,
      packaging: void 0
    };
  }
  exports2.S3StorageAddress = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.region !== "") {
        writer2.uint32(10).string(message.region);
      }
      if (message.bucket !== "") {
        writer2.uint32(18).string(message.bucket);
      }
      if (message.prefix !== void 0) {
        writer2.uint32(26).string(message.prefix);
      }
      if (message.accessKey !== "") {
        writer2.uint32(34).string(message.accessKey);
      }
      if (message.secretKey !== "") {
        writer2.uint32(42).string(message.secretKey);
      }
      if (message.token !== void 0) {
        writer2.uint32(50).string(message.token);
      }
      if (message.tokenDuration !== void 0) {
        writer2.uint32(56).int32(message.tokenDuration);
      }
      if (message.acl !== void 0) {
        writer2.uint32(64).int32(s3ACLToNumber(message.acl));
      }
      if (message.endpoint !== void 0) {
        writer2.uint32(74).string(message.endpoint);
      }
      if (message.packaging !== void 0) {
        exports2.ObjectStoragePackaging.encode(message.packaging, writer2.uint32(82).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseS3StorageAddress();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.region = reader2.string();
            break;
          case 2:
            message.bucket = reader2.string();
            break;
          case 3:
            message.prefix = reader2.string();
            break;
          case 4:
            message.accessKey = reader2.string();
            break;
          case 5:
            message.secretKey = reader2.string();
            break;
          case 6:
            message.token = reader2.string();
            break;
          case 7:
            message.tokenDuration = reader2.int32();
            break;
          case 8:
            message.acl = s3ACLFromJSON(reader2.int32());
            break;
          case 9:
            message.endpoint = reader2.string();
            break;
          case 10:
            message.packaging = exports2.ObjectStoragePackaging.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        region: isSet2(object.region) ? String(object.region) : "",
        bucket: isSet2(object.bucket) ? String(object.bucket) : "",
        prefix: isSet2(object.prefix) ? String(object.prefix) : void 0,
        accessKey: isSet2(object.accessKey) ? String(object.accessKey) : "",
        secretKey: isSet2(object.secretKey) ? String(object.secretKey) : "",
        token: isSet2(object.token) ? String(object.token) : void 0,
        tokenDuration: isSet2(object.tokenDuration) ? Number(object.tokenDuration) : void 0,
        acl: isSet2(object.acl) ? s3ACLFromJSON(object.acl) : void 0,
        endpoint: isSet2(object.endpoint) ? String(object.endpoint) : void 0,
        packaging: isSet2(object.packaging) ? exports2.ObjectStoragePackaging.fromJSON(object.packaging) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.region !== void 0 && (obj.region = message.region);
      message.bucket !== void 0 && (obj.bucket = message.bucket);
      message.prefix !== void 0 && (obj.prefix = message.prefix);
      message.accessKey !== void 0 && (obj.accessKey = message.accessKey);
      message.secretKey !== void 0 && (obj.secretKey = message.secretKey);
      message.token !== void 0 && (obj.token = message.token);
      message.tokenDuration !== void 0 && (obj.tokenDuration = Math.round(message.tokenDuration));
      message.acl !== void 0 && (obj.acl = message.acl !== void 0 ? s3ACLToJSON(message.acl) : void 0);
      message.endpoint !== void 0 && (obj.endpoint = message.endpoint);
      message.packaging !== void 0 && (obj.packaging = message.packaging ? exports2.ObjectStoragePackaging.toJSON(message.packaging) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
      const message = createBaseS3StorageAddress();
      message.region = (_a2 = object.region) !== null && _a2 !== void 0 ? _a2 : "";
      message.bucket = (_b = object.bucket) !== null && _b !== void 0 ? _b : "";
      message.prefix = (_c = object.prefix) !== null && _c !== void 0 ? _c : void 0;
      message.accessKey = (_d = object.accessKey) !== null && _d !== void 0 ? _d : "";
      message.secretKey = (_e = object.secretKey) !== null && _e !== void 0 ? _e : "";
      message.token = (_f = object.token) !== null && _f !== void 0 ? _f : void 0;
      message.tokenDuration = (_g = object.tokenDuration) !== null && _g !== void 0 ? _g : void 0;
      message.acl = (_h = object.acl) !== null && _h !== void 0 ? _h : void 0;
      message.endpoint = (_j = object.endpoint) !== null && _j !== void 0 ? _j : void 0;
      message.packaging = object.packaging !== void 0 && object.packaging !== null ? exports2.ObjectStoragePackaging.fromPartial(object.packaging) : void 0;
      return message;
    }
  };
  function createBaseDestinationAddress() {
    return { rtmpPush: void 0, agora: void 0, s3Storage: void 0 };
  }
  exports2.DestinationAddress = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.rtmpPush !== void 0) {
        exports2.DestinationRtmpPushAddress.encode(message.rtmpPush, writer2.uint32(10).fork()).ldelim();
      }
      if (message.agora !== void 0) {
        exports2.DestinationAgoraPushAddress.encode(message.agora, writer2.uint32(18).fork()).ldelim();
      }
      if (message.s3Storage !== void 0) {
        exports2.S3StorageAddress.encode(message.s3Storage, writer2.uint32(26).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDestinationAddress();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.rtmpPush = exports2.DestinationRtmpPushAddress.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.agora = exports2.DestinationAgoraPushAddress.decode(reader2, reader2.uint32());
            break;
          case 3:
            message.s3Storage = exports2.S3StorageAddress.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        rtmpPush: isSet2(object.rtmpPush) ? exports2.DestinationRtmpPushAddress.fromJSON(object.rtmpPush) : void 0,
        agora: isSet2(object.agora) ? exports2.DestinationAgoraPushAddress.fromJSON(object.agora) : void 0,
        s3Storage: isSet2(object.s3Storage) ? exports2.S3StorageAddress.fromJSON(object.s3Storage) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.rtmpPush !== void 0 && (obj.rtmpPush = message.rtmpPush ? exports2.DestinationRtmpPushAddress.toJSON(message.rtmpPush) : void 0);
      message.agora !== void 0 && (obj.agora = message.agora ? exports2.DestinationAgoraPushAddress.toJSON(message.agora) : void 0);
      message.s3Storage !== void 0 && (obj.s3Storage = message.s3Storage ? exports2.S3StorageAddress.toJSON(message.s3Storage) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseDestinationAddress();
      message.rtmpPush = object.rtmpPush !== void 0 && object.rtmpPush !== null ? exports2.DestinationRtmpPushAddress.fromPartial(object.rtmpPush) : void 0;
      message.agora = object.agora !== void 0 && object.agora !== null ? exports2.DestinationAgoraPushAddress.fromPartial(object.agora) : void 0;
      message.s3Storage = object.s3Storage !== void 0 && object.s3Storage !== null ? exports2.S3StorageAddress.fromPartial(object.s3Storage) : void 0;
      return message;
    }
  };
  function createBaseSourceTrigger() {
    return { sourceId: "", start: void 0, stop: void 0 };
  }
  exports2.SourceTrigger = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.sourceId !== "") {
        writer2.uint32(10).string(message.sourceId);
      }
      if (message.start !== void 0) {
        writer2.uint32(16).int32(sourceTriggerActionToNumber(message.start));
      }
      if (message.stop !== void 0) {
        writer2.uint32(24).int32(sourceTriggerActionToNumber(message.stop));
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseSourceTrigger();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.sourceId = reader2.string();
            break;
          case 2:
            message.start = sourceTriggerActionFromJSON(reader2.int32());
            break;
          case 3:
            message.stop = sourceTriggerActionFromJSON(reader2.int32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "",
        start: isSet2(object.start) ? sourceTriggerActionFromJSON(object.start) : void 0,
        stop: isSet2(object.stop) ? sourceTriggerActionFromJSON(object.stop) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
      message.start !== void 0 && (obj.start = message.start !== void 0 ? sourceTriggerActionToJSON(message.start) : void 0);
      message.stop !== void 0 && (obj.stop = message.stop !== void 0 ? sourceTriggerActionToJSON(message.stop) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseSourceTrigger();
      message.sourceId = (_a2 = object.sourceId) !== null && _a2 !== void 0 ? _a2 : "";
      message.start = (_b = object.start) !== null && _b !== void 0 ? _b : void 0;
      message.stop = (_c = object.stop) !== null && _c !== void 0 ? _c : void 0;
      return message;
    }
  };
  function createBaseWebRtcTrigger() {
    return { stop: void 0 };
  }
  exports2.WebRtcTrigger = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.stop !== void 0) {
        writer2.uint32(24).int32(sourceTriggerActionToNumber(message.stop));
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseWebRtcTrigger();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 3:
            message.stop = sourceTriggerActionFromJSON(reader2.int32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        stop: isSet2(object.stop) ? sourceTriggerActionFromJSON(object.stop) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.stop !== void 0 && (obj.stop = message.stop !== void 0 ? sourceTriggerActionToJSON(message.stop) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseWebRtcTrigger();
      message.stop = (_a2 = object.stop) !== null && _a2 !== void 0 ? _a2 : void 0;
      return message;
    }
  };
  function createBaseProjectTrigger() {
    return { source: void 0 };
  }
  exports2.ProjectTrigger = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.source !== void 0) {
        exports2.SourceTrigger.encode(message.source, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseProjectTrigger();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.source = exports2.SourceTrigger.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        source: isSet2(object.source) ? exports2.SourceTrigger.fromJSON(object.source) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.source !== void 0 && (obj.source = message.source ? exports2.SourceTrigger.toJSON(message.source) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseProjectTrigger();
      message.source = object.source !== void 0 && object.source !== null ? exports2.SourceTrigger.fromPartial(object.source) : void 0;
      return message;
    }
  };
  function createBasePreviewHlsPullAddress() {
    return { enabled: void 0, url: void 0 };
  }
  exports2.PreviewHlsPullAddress = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.enabled !== void 0) {
        writer2.uint32(8).bool(message.enabled);
      }
      if (message.url !== void 0) {
        writer2.uint32(18).string(message.url);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBasePreviewHlsPullAddress();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.enabled = reader2.bool();
            break;
          case 2:
            message.url = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        enabled: isSet2(object.enabled) ? Boolean(object.enabled) : void 0,
        url: isSet2(object.url) ? String(object.url) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.enabled !== void 0 && (obj.enabled = message.enabled);
      message.url !== void 0 && (obj.url = message.url);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBasePreviewHlsPullAddress();
      message.enabled = (_a2 = object.enabled) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.url = (_b = object.url) !== null && _b !== void 0 ? _b : void 0;
      return message;
    }
  };
  function createBasePreviewWebRtcAddress() {
    return {
      enabled: void 0,
      displayName: void 0,
      participantId: void 0
    };
  }
  exports2.PreviewWebRtcAddress = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.enabled !== void 0) {
        writer2.uint32(8).bool(message.enabled);
      }
      if (message.displayName !== void 0) {
        writer2.uint32(18).string(message.displayName);
      }
      if (message.participantId !== void 0) {
        writer2.uint32(26).string(message.participantId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBasePreviewWebRtcAddress();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.enabled = reader2.bool();
            break;
          case 2:
            message.displayName = reader2.string();
            break;
          case 3:
            message.participantId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        enabled: isSet2(object.enabled) ? Boolean(object.enabled) : void 0,
        displayName: isSet2(object.displayName) ? String(object.displayName) : void 0,
        participantId: isSet2(object.participantId) ? String(object.participantId) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.enabled !== void 0 && (obj.enabled = message.enabled);
      message.displayName !== void 0 && (obj.displayName = message.displayName);
      message.participantId !== void 0 && (obj.participantId = message.participantId);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBasePreviewWebRtcAddress();
      message.enabled = (_a2 = object.enabled) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.displayName = (_b = object.displayName) !== null && _b !== void 0 ? _b : void 0;
      message.participantId = (_c = object.participantId) !== null && _c !== void 0 ? _c : void 0;
      return message;
    }
  };
  function createBasePreviewAddress() {
    return { webrtc: void 0 };
  }
  exports2.PreviewAddress = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.webrtc !== void 0) {
        exports2.PreviewWebRtcAddress.encode(message.webrtc, writer2.uint32(18).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBasePreviewAddress();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 2:
            message.webrtc = exports2.PreviewWebRtcAddress.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        webrtc: isSet2(object.webrtc) ? exports2.PreviewWebRtcAddress.fromJSON(object.webrtc) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.webrtc !== void 0 && (obj.webrtc = message.webrtc ? exports2.PreviewWebRtcAddress.toJSON(message.webrtc) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBasePreviewAddress();
      message.webrtc = object.webrtc !== void 0 && object.webrtc !== null ? exports2.PreviewWebRtcAddress.fromPartial(object.webrtc) : void 0;
      return message;
    }
  };
  function createBaseStudioSdkComposition() {
    return { rendererUrl: void 0, version: void 0 };
  }
  exports2.StudioSdkComposition = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.rendererUrl !== void 0) {
        writer2.uint32(10).string(message.rendererUrl);
      }
      if (message.version !== void 0) {
        writer2.uint32(18).string(message.version);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseStudioSdkComposition();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.rendererUrl = reader2.string();
            break;
          case 2:
            message.version = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        rendererUrl: isSet2(object.rendererUrl) ? String(object.rendererUrl) : void 0,
        version: isSet2(object.version) ? String(object.version) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.rendererUrl !== void 0 && (obj.rendererUrl = message.rendererUrl);
      message.version !== void 0 && (obj.version = message.version);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseStudioSdkComposition();
      message.rendererUrl = (_a2 = object.rendererUrl) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.version = (_b = object.version) !== null && _b !== void 0 ? _b : void 0;
      return message;
    }
  };
  function createBaseSceneComposition() {
    return {
      rendererUrl: void 0,
      selectedLayoutId: void 0,
      debug: void 0
    };
  }
  exports2.SceneComposition = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.rendererUrl !== void 0) {
        writer2.uint32(10).string(message.rendererUrl);
      }
      if (message.selectedLayoutId !== void 0) {
        writer2.uint32(18).string(message.selectedLayoutId);
      }
      if (message.debug !== void 0) {
        writer2.uint32(24).bool(message.debug);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseSceneComposition();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.rendererUrl = reader2.string();
            break;
          case 2:
            message.selectedLayoutId = reader2.string();
            break;
          case 3:
            message.debug = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        rendererUrl: isSet2(object.rendererUrl) ? String(object.rendererUrl) : void 0,
        selectedLayoutId: isSet2(object.selectedLayoutId) ? String(object.selectedLayoutId) : void 0,
        debug: isSet2(object.debug) ? Boolean(object.debug) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.rendererUrl !== void 0 && (obj.rendererUrl = message.rendererUrl);
      message.selectedLayoutId !== void 0 && (obj.selectedLayoutId = message.selectedLayoutId);
      message.debug !== void 0 && (obj.debug = message.debug);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseSceneComposition();
      message.rendererUrl = (_a2 = object.rendererUrl) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.selectedLayoutId = (_b = object.selectedLayoutId) !== null && _b !== void 0 ? _b : void 0;
      message.debug = (_c = object.debug) !== null && _c !== void 0 ? _c : void 0;
      return message;
    }
  };
  function createBaseExternalComposition() {
    return { url: "" };
  }
  exports2.ExternalComposition = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.url !== "") {
        writer2.uint32(10).string(message.url);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseExternalComposition();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.url = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        url: isSet2(object.url) ? String(object.url) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.url !== void 0 && (obj.url = message.url);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseExternalComposition();
      message.url = (_a2 = object.url) !== null && _a2 !== void 0 ? _a2 : "";
      return message;
    }
  };
  function createBaseComposition() {
    return { external: void 0, studioSdk: void 0, scene: void 0 };
  }
  exports2.Composition = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.external !== void 0) {
        exports2.ExternalComposition.encode(message.external, writer2.uint32(10).fork()).ldelim();
      }
      if (message.studioSdk !== void 0) {
        exports2.StudioSdkComposition.encode(message.studioSdk, writer2.uint32(18).fork()).ldelim();
      }
      if (message.scene !== void 0) {
        exports2.SceneComposition.encode(message.scene, writer2.uint32(34).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseComposition();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.external = exports2.ExternalComposition.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.studioSdk = exports2.StudioSdkComposition.decode(reader2, reader2.uint32());
            break;
          case 4:
            message.scene = exports2.SceneComposition.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        external: isSet2(object.external) ? exports2.ExternalComposition.fromJSON(object.external) : void 0,
        studioSdk: isSet2(object.studioSdk) ? exports2.StudioSdkComposition.fromJSON(object.studioSdk) : void 0,
        scene: isSet2(object.scene) ? exports2.SceneComposition.fromJSON(object.scene) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.external !== void 0 && (obj.external = message.external ? exports2.ExternalComposition.toJSON(message.external) : void 0);
      message.studioSdk !== void 0 && (obj.studioSdk = message.studioSdk ? exports2.StudioSdkComposition.toJSON(message.studioSdk) : void 0);
      message.scene !== void 0 && (obj.scene = message.scene ? exports2.SceneComposition.toJSON(message.scene) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseComposition();
      message.external = object.external !== void 0 && object.external !== null ? exports2.ExternalComposition.fromPartial(object.external) : void 0;
      message.studioSdk = object.studioSdk !== void 0 && object.studioSdk !== null ? exports2.StudioSdkComposition.fromPartial(object.studioSdk) : void 0;
      message.scene = object.scene !== void 0 && object.scene !== null ? exports2.SceneComposition.fromPartial(object.scene) : void 0;
      return message;
    }
  };
  function createBaseHostedWebRtc() {
    return { enabled: void 0 };
  }
  exports2.HostedWebRtc = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.enabled !== void 0) {
        writer2.uint32(8).bool(message.enabled);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseHostedWebRtc();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.enabled = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        enabled: isSet2(object.enabled) ? Boolean(object.enabled) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.enabled !== void 0 && (obj.enabled = message.enabled);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseHostedWebRtc();
      message.enabled = (_a2 = object.enabled) !== null && _a2 !== void 0 ? _a2 : void 0;
      return message;
    }
  };
  function createBaseWebRtc() {
    return { hosted: void 0 };
  }
  exports2.WebRtc = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.hosted !== void 0) {
        exports2.HostedWebRtc.encode(message.hosted, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseWebRtc();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.hosted = exports2.HostedWebRtc.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        hosted: isSet2(object.hosted) ? exports2.HostedWebRtc.fromJSON(object.hosted) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.hosted !== void 0 && (obj.hosted = message.hosted ? exports2.HostedWebRtc.toJSON(message.hosted) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseWebRtc();
      message.hosted = object.hosted !== void 0 && object.hosted !== null ? exports2.HostedWebRtc.fromPartial(object.hosted) : void 0;
      return message;
    }
  };
  function createBaseWebRtcAccess() {
    return { accessToken: "", participantId: void 0 };
  }
  exports2.WebRtcAccess = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.accessToken !== "") {
        writer2.uint32(10).string(message.accessToken);
      }
      if (message.participantId !== void 0) {
        writer2.uint32(26).string(message.participantId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseWebRtcAccess();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.accessToken = reader2.string();
            break;
          case 3:
            message.participantId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        accessToken: isSet2(object.accessToken) ? String(object.accessToken) : "",
        participantId: isSet2(object.participantId) ? String(object.participantId) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.accessToken !== void 0 && (obj.accessToken = message.accessToken);
      message.participantId !== void 0 && (obj.participantId = message.participantId);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseWebRtcAccess();
      message.accessToken = (_a2 = object.accessToken) !== null && _a2 !== void 0 ? _a2 : "";
      message.participantId = (_b = object.participantId) !== null && _b !== void 0 ? _b : void 0;
      return message;
    }
  };
  function createBaseLatLong() {
    return { latitude: 0, longitude: 0 };
  }
  exports2.LatLong = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.latitude !== 0) {
        writer2.uint32(9).double(message.latitude);
      }
      if (message.longitude !== 0) {
        writer2.uint32(17).double(message.longitude);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseLatLong();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.latitude = reader2.double();
            break;
          case 2:
            message.longitude = reader2.double();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        latitude: isSet2(object.latitude) ? Number(object.latitude) : 0,
        longitude: isSet2(object.longitude) ? Number(object.longitude) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.latitude !== void 0 && (obj.latitude = message.latitude);
      message.longitude !== void 0 && (obj.longitude = message.longitude);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseLatLong();
      message.latitude = (_a2 = object.latitude) !== null && _a2 !== void 0 ? _a2 : 0;
      message.longitude = (_b = object.longitude) !== null && _b !== void 0 ? _b : 0;
      return message;
    }
  };
  function createBaseProjectBroadcastStatus() {
    return {
      collectionId: "",
      projectId: "",
      broadcastId: void 0,
      duration: void 0,
      start: void 0,
      stop: void 0,
      phase: ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_UNSPECIFIED,
      region: void 0,
      datacenter: void 0
    };
  }
  exports2.ProjectBroadcastStatus = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.broadcastId !== void 0) {
        writer2.uint32(26).string(message.broadcastId);
      }
      if (message.duration !== void 0) {
        writer2.uint32(32).uint32(message.duration);
      }
      if (message.start !== void 0) {
        timestamp_1.Timestamp.encode(toTimestamp(message.start), writer2.uint32(42).fork()).ldelim();
      }
      if (message.stop !== void 0) {
        timestamp_1.Timestamp.encode(toTimestamp(message.stop), writer2.uint32(50).fork()).ldelim();
      }
      if (message.phase !== ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_UNSPECIFIED) {
        writer2.uint32(56).int32(projectBroadcastPhaseToNumber(message.phase));
      }
      if (message.region !== void 0) {
        writer2.uint32(64).int32(regionToNumber(message.region));
      }
      if (message.datacenter !== void 0) {
        writer2.uint32(74).string(message.datacenter);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseProjectBroadcastStatus();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.broadcastId = reader2.string();
            break;
          case 4:
            message.duration = reader2.uint32();
            break;
          case 5:
            message.start = fromTimestamp(timestamp_1.Timestamp.decode(reader2, reader2.uint32()));
            break;
          case 6:
            message.stop = fromTimestamp(timestamp_1.Timestamp.decode(reader2, reader2.uint32()));
            break;
          case 7:
            message.phase = projectBroadcastPhaseFromJSON(reader2.int32());
            break;
          case 8:
            message.region = regionFromJSON(reader2.int32());
            break;
          case 9:
            message.datacenter = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        broadcastId: isSet2(object.broadcastId) ? String(object.broadcastId) : void 0,
        duration: isSet2(object.duration) ? Number(object.duration) : void 0,
        start: isSet2(object.start) ? String(object.start) : void 0,
        stop: isSet2(object.stop) ? String(object.stop) : void 0,
        phase: isSet2(object.phase) ? projectBroadcastPhaseFromJSON(object.phase) : ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_UNSPECIFIED,
        region: isSet2(object.region) ? regionFromJSON(object.region) : void 0,
        datacenter: isSet2(object.datacenter) ? String(object.datacenter) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.broadcastId !== void 0 && (obj.broadcastId = message.broadcastId);
      message.duration !== void 0 && (obj.duration = Math.round(message.duration));
      message.start !== void 0 && (obj.start = message.start);
      message.stop !== void 0 && (obj.stop = message.stop);
      message.phase !== void 0 && (obj.phase = projectBroadcastPhaseToJSON(message.phase));
      message.region !== void 0 && (obj.region = message.region !== void 0 ? regionToJSON(message.region) : void 0);
      message.datacenter !== void 0 && (obj.datacenter = message.datacenter);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
      const message = createBaseProjectBroadcastStatus();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.broadcastId = (_c = object.broadcastId) !== null && _c !== void 0 ? _c : void 0;
      message.duration = (_d = object.duration) !== null && _d !== void 0 ? _d : void 0;
      message.start = (_e = object.start) !== null && _e !== void 0 ? _e : void 0;
      message.stop = (_f = object.stop) !== null && _f !== void 0 ? _f : void 0;
      message.phase = (_g = object.phase) !== null && _g !== void 0 ? _g : ProjectBroadcastPhase2.PROJECT_BROADCAST_PHASE_UNSPECIFIED;
      message.region = (_h = object.region) !== null && _h !== void 0 ? _h : void 0;
      message.datacenter = (_j = object.datacenter) !== null && _j !== void 0 ? _j : void 0;
      return message;
    }
  };
  function createBaseSource() {
    return {
      collectionId: "",
      sourceId: "",
      metadata: void 0,
      preview: void 0,
      address: void 0
    };
  }
  exports2.Source = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.sourceId !== "") {
        writer2.uint32(18).string(message.sourceId);
      }
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(26).fork()).ldelim();
      }
      if (message.preview !== void 0) {
        exports2.PreviewAddress.encode(message.preview, writer2.uint32(34).fork()).ldelim();
      }
      if (message.address !== void 0) {
        exports2.SourceAddress.encode(message.address, writer2.uint32(50).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseSource();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.sourceId = reader2.string();
            break;
          case 3:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 4:
            message.preview = exports2.PreviewAddress.decode(reader2, reader2.uint32());
            break;
          case 6:
            message.address = exports2.SourceAddress.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "",
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0,
        preview: isSet2(object.preview) ? exports2.PreviewAddress.fromJSON(object.preview) : void 0,
        address: isSet2(object.address) ? exports2.SourceAddress.fromJSON(object.address) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.preview !== void 0 && (obj.preview = message.preview ? exports2.PreviewAddress.toJSON(message.preview) : void 0);
      message.address !== void 0 && (obj.address = message.address ? exports2.SourceAddress.toJSON(message.address) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseSource();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
      message.metadata = (_c = object.metadata) !== null && _c !== void 0 ? _c : void 0;
      message.preview = object.preview !== void 0 && object.preview !== null ? exports2.PreviewAddress.fromPartial(object.preview) : void 0;
      message.address = object.address !== void 0 && object.address !== null ? exports2.SourceAddress.fromPartial(object.address) : void 0;
      return message;
    }
  };
  function createBaseDestination() {
    return {
      collectionId: "",
      projectId: "",
      destinationId: "",
      metadata: void 0,
      enabled: void 0,
      address: void 0,
      timeout: void 0
    };
  }
  exports2.Destination = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.destinationId !== "") {
        writer2.uint32(26).string(message.destinationId);
      }
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(34).fork()).ldelim();
      }
      if (message.enabled !== void 0) {
        writer2.uint32(40).bool(message.enabled);
      }
      if (message.address !== void 0) {
        exports2.DestinationAddress.encode(message.address, writer2.uint32(50).fork()).ldelim();
      }
      if (message.timeout !== void 0) {
        writer2.uint32(56).uint32(message.timeout);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDestination();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.destinationId = reader2.string();
            break;
          case 4:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 5:
            message.enabled = reader2.bool();
            break;
          case 6:
            message.address = exports2.DestinationAddress.decode(reader2, reader2.uint32());
            break;
          case 7:
            message.timeout = reader2.uint32();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        destinationId: isSet2(object.destinationId) ? String(object.destinationId) : "",
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0,
        enabled: isSet2(object.enabled) ? Boolean(object.enabled) : void 0,
        address: isSet2(object.address) ? exports2.DestinationAddress.fromJSON(object.address) : void 0,
        timeout: isSet2(object.timeout) ? Number(object.timeout) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.destinationId !== void 0 && (obj.destinationId = message.destinationId);
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.enabled !== void 0 && (obj.enabled = message.enabled);
      message.address !== void 0 && (obj.address = message.address ? exports2.DestinationAddress.toJSON(message.address) : void 0);
      message.timeout !== void 0 && (obj.timeout = Math.round(message.timeout));
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e, _f;
      const message = createBaseDestination();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.destinationId = (_c = object.destinationId) !== null && _c !== void 0 ? _c : "";
      message.metadata = (_d = object.metadata) !== null && _d !== void 0 ? _d : void 0;
      message.enabled = (_e = object.enabled) !== null && _e !== void 0 ? _e : void 0;
      message.address = object.address !== void 0 && object.address !== null ? exports2.DestinationAddress.fromPartial(object.address) : void 0;
      message.timeout = (_f = object.timeout) !== null && _f !== void 0 ? _f : void 0;
      return message;
    }
  };
  function createBaseProject() {
    return {
      collectionId: "",
      projectId: "",
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      sources: [],
      destinations: [],
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      triggers: [],
      location: void 0,
      guestCodes: []
    };
  }
  exports2.Project = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(26).fork()).ldelim();
      }
      if (message.rendering !== void 0) {
        exports2.Rendering.encode(message.rendering, writer2.uint32(34).fork()).ldelim();
      }
      if (message.encoding !== void 0) {
        exports2.Encoding.encode(message.encoding, writer2.uint32(42).fork()).ldelim();
      }
      for (const v of message.sources) {
        exports2.Source.encode(v, writer2.uint32(50).fork()).ldelim();
      }
      for (const v of message.destinations) {
        exports2.Destination.encode(v, writer2.uint32(58).fork()).ldelim();
      }
      if (message.composition !== void 0) {
        exports2.Composition.encode(message.composition, writer2.uint32(66).fork()).ldelim();
      }
      if (message.maxDuration !== void 0) {
        writer2.uint32(72).uint32(message.maxDuration);
      }
      if (message.webrtc !== void 0) {
        exports2.WebRtc.encode(message.webrtc, writer2.uint32(82).fork()).ldelim();
      }
      for (const v of message.triggers) {
        exports2.ProjectTrigger.encode(v, writer2.uint32(90).fork()).ldelim();
      }
      if (message.location !== void 0) {
        exports2.LatLong.encode(message.location, writer2.uint32(98).fork()).ldelim();
      }
      for (const v of message.guestCodes) {
        exports2.GuestCode.encode(v, writer2.uint32(106).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseProject();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 4:
            message.rendering = exports2.Rendering.decode(reader2, reader2.uint32());
            break;
          case 5:
            message.encoding = exports2.Encoding.decode(reader2, reader2.uint32());
            break;
          case 6:
            message.sources.push(exports2.Source.decode(reader2, reader2.uint32()));
            break;
          case 7:
            message.destinations.push(exports2.Destination.decode(reader2, reader2.uint32()));
            break;
          case 8:
            message.composition = exports2.Composition.decode(reader2, reader2.uint32());
            break;
          case 9:
            message.maxDuration = reader2.uint32();
            break;
          case 10:
            message.webrtc = exports2.WebRtc.decode(reader2, reader2.uint32());
            break;
          case 11:
            message.triggers.push(exports2.ProjectTrigger.decode(reader2, reader2.uint32()));
            break;
          case 12:
            message.location = exports2.LatLong.decode(reader2, reader2.uint32());
            break;
          case 13:
            message.guestCodes.push(exports2.GuestCode.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0,
        rendering: isSet2(object.rendering) ? exports2.Rendering.fromJSON(object.rendering) : void 0,
        encoding: isSet2(object.encoding) ? exports2.Encoding.fromJSON(object.encoding) : void 0,
        sources: Array.isArray(object === null || object === void 0 ? void 0 : object.sources) ? object.sources.map((e2) => exports2.Source.fromJSON(e2)) : [],
        destinations: Array.isArray(object === null || object === void 0 ? void 0 : object.destinations) ? object.destinations.map((e2) => exports2.Destination.fromJSON(e2)) : [],
        composition: isSet2(object.composition) ? exports2.Composition.fromJSON(object.composition) : void 0,
        maxDuration: isSet2(object.maxDuration) ? Number(object.maxDuration) : void 0,
        webrtc: isSet2(object.webrtc) ? exports2.WebRtc.fromJSON(object.webrtc) : void 0,
        triggers: Array.isArray(object === null || object === void 0 ? void 0 : object.triggers) ? object.triggers.map((e2) => exports2.ProjectTrigger.fromJSON(e2)) : [],
        location: isSet2(object.location) ? exports2.LatLong.fromJSON(object.location) : void 0,
        guestCodes: Array.isArray(object === null || object === void 0 ? void 0 : object.guestCodes) ? object.guestCodes.map((e2) => exports2.GuestCode.fromJSON(e2)) : []
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.rendering !== void 0 && (obj.rendering = message.rendering ? exports2.Rendering.toJSON(message.rendering) : void 0);
      message.encoding !== void 0 && (obj.encoding = message.encoding ? exports2.Encoding.toJSON(message.encoding) : void 0);
      if (message.sources) {
        obj.sources = message.sources.map((e2) => e2 ? exports2.Source.toJSON(e2) : void 0);
      } else {
        obj.sources = [];
      }
      if (message.destinations) {
        obj.destinations = message.destinations.map((e2) => e2 ? exports2.Destination.toJSON(e2) : void 0);
      } else {
        obj.destinations = [];
      }
      message.composition !== void 0 && (obj.composition = message.composition ? exports2.Composition.toJSON(message.composition) : void 0);
      message.maxDuration !== void 0 && (obj.maxDuration = Math.round(message.maxDuration));
      message.webrtc !== void 0 && (obj.webrtc = message.webrtc ? exports2.WebRtc.toJSON(message.webrtc) : void 0);
      if (message.triggers) {
        obj.triggers = message.triggers.map((e2) => e2 ? exports2.ProjectTrigger.toJSON(e2) : void 0);
      } else {
        obj.triggers = [];
      }
      message.location !== void 0 && (obj.location = message.location ? exports2.LatLong.toJSON(message.location) : void 0);
      if (message.guestCodes) {
        obj.guestCodes = message.guestCodes.map((e2) => e2 ? exports2.GuestCode.toJSON(e2) : void 0);
      } else {
        obj.guestCodes = [];
      }
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e, _f, _g, _h;
      const message = createBaseProject();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.metadata = (_c = object.metadata) !== null && _c !== void 0 ? _c : void 0;
      message.rendering = object.rendering !== void 0 && object.rendering !== null ? exports2.Rendering.fromPartial(object.rendering) : void 0;
      message.encoding = object.encoding !== void 0 && object.encoding !== null ? exports2.Encoding.fromPartial(object.encoding) : void 0;
      message.sources = ((_d = object.sources) === null || _d === void 0 ? void 0 : _d.map((e2) => exports2.Source.fromPartial(e2))) || [];
      message.destinations = ((_e = object.destinations) === null || _e === void 0 ? void 0 : _e.map((e2) => exports2.Destination.fromPartial(e2))) || [];
      message.composition = object.composition !== void 0 && object.composition !== null ? exports2.Composition.fromPartial(object.composition) : void 0;
      message.maxDuration = (_f = object.maxDuration) !== null && _f !== void 0 ? _f : void 0;
      message.webrtc = object.webrtc !== void 0 && object.webrtc !== null ? exports2.WebRtc.fromPartial(object.webrtc) : void 0;
      message.triggers = ((_g = object.triggers) === null || _g === void 0 ? void 0 : _g.map((e2) => exports2.ProjectTrigger.fromPartial(e2))) || [];
      message.location = object.location !== void 0 && object.location !== null ? exports2.LatLong.fromPartial(object.location) : void 0;
      message.guestCodes = ((_h = object.guestCodes) === null || _h === void 0 ? void 0 : _h.map((e2) => exports2.GuestCode.fromPartial(e2))) || [];
      return message;
    }
  };
  function createBaseCollection() {
    return { collectionId: "", metadata: void 0, projects: [], sources: [] };
  }
  exports2.Collection = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(18).fork()).ldelim();
      }
      for (const v of message.projects) {
        exports2.Project.encode(v, writer2.uint32(26).fork()).ldelim();
      }
      for (const v of message.sources) {
        exports2.Source.encode(v, writer2.uint32(34).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCollection();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 3:
            message.projects.push(exports2.Project.decode(reader2, reader2.uint32()));
            break;
          case 4:
            message.sources.push(exports2.Source.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0,
        projects: Array.isArray(object === null || object === void 0 ? void 0 : object.projects) ? object.projects.map((e2) => exports2.Project.fromJSON(e2)) : [],
        sources: Array.isArray(object === null || object === void 0 ? void 0 : object.sources) ? object.sources.map((e2) => exports2.Source.fromJSON(e2)) : []
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      if (message.projects) {
        obj.projects = message.projects.map((e2) => e2 ? exports2.Project.toJSON(e2) : void 0);
      } else {
        obj.projects = [];
      }
      if (message.sources) {
        obj.sources = message.sources.map((e2) => e2 ? exports2.Source.toJSON(e2) : void 0);
      } else {
        obj.sources = [];
      }
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d;
      const message = createBaseCollection();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.metadata = (_b = object.metadata) !== null && _b !== void 0 ? _b : void 0;
      message.projects = ((_c = object.projects) === null || _c === void 0 ? void 0 : _c.map((e2) => exports2.Project.fromPartial(e2))) || [];
      message.sources = ((_d = object.sources) === null || _d === void 0 ? void 0 : _d.map((e2) => exports2.Source.fromPartial(e2))) || [];
      return message;
    }
  };
  function createBaseCreateCollectionRequest() {
    return { metadata: void 0 };
  }
  exports2.CreateCollectionRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCreateCollectionRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseCreateCollectionRequest();
      message.metadata = (_a2 = object.metadata) !== null && _a2 !== void 0 ? _a2 : void 0;
      return message;
    }
  };
  function createBaseCreateCollectionResponse() {
    return { collection: void 0 };
  }
  exports2.CreateCollectionResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collection !== void 0) {
        exports2.Collection.encode(message.collection, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCreateCollectionResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collection = exports2.Collection.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collection: isSet2(object.collection) ? exports2.Collection.fromJSON(object.collection) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collection !== void 0 && (obj.collection = message.collection ? exports2.Collection.toJSON(message.collection) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseCreateCollectionResponse();
      message.collection = object.collection !== void 0 && object.collection !== null ? exports2.Collection.fromPartial(object.collection) : void 0;
      return message;
    }
  };
  function createBaseGetCollectionRequest() {
    return {
      collectionId: "",
      populateProjects: void 0,
      populateSources: void 0
    };
  }
  exports2.GetCollectionRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.populateProjects !== void 0) {
        writer2.uint32(16).bool(message.populateProjects);
      }
      if (message.populateSources !== void 0) {
        writer2.uint32(24).bool(message.populateSources);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetCollectionRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.populateProjects = reader2.bool();
            break;
          case 3:
            message.populateSources = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        populateProjects: isSet2(object.populateProjects) ? Boolean(object.populateProjects) : void 0,
        populateSources: isSet2(object.populateSources) ? Boolean(object.populateSources) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.populateProjects !== void 0 && (obj.populateProjects = message.populateProjects);
      message.populateSources !== void 0 && (obj.populateSources = message.populateSources);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseGetCollectionRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.populateProjects = (_b = object.populateProjects) !== null && _b !== void 0 ? _b : void 0;
      message.populateSources = (_c = object.populateSources) !== null && _c !== void 0 ? _c : void 0;
      return message;
    }
  };
  function createBaseGetCollectionResponse() {
    return { collection: void 0 };
  }
  exports2.GetCollectionResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collection !== void 0) {
        exports2.Collection.encode(message.collection, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetCollectionResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collection = exports2.Collection.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collection: isSet2(object.collection) ? exports2.Collection.fromJSON(object.collection) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collection !== void 0 && (obj.collection = message.collection ? exports2.Collection.toJSON(message.collection) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseGetCollectionResponse();
      message.collection = object.collection !== void 0 && object.collection !== null ? exports2.Collection.fromPartial(object.collection) : void 0;
      return message;
    }
  };
  function createBaseUpdateCollectionRequest() {
    return { collectionId: "", updateMask: void 0, metadata: void 0 };
  }
  exports2.UpdateCollectionRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.updateMask !== void 0) {
        field_mask_1.FieldMask.encode(field_mask_1.FieldMask.wrap(message.updateMask), writer2.uint32(18).fork()).ldelim();
      }
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(26).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseUpdateCollectionRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.updateMask = field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.decode(reader2, reader2.uint32()));
            break;
          case 3:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        updateMask: isSet2(object.updateMask) ? field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.fromJSON(object.updateMask)) : void 0,
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.updateMask !== void 0 && (obj.updateMask = field_mask_1.FieldMask.toJSON(field_mask_1.FieldMask.wrap(message.updateMask)));
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseUpdateCollectionRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.updateMask = (_b = object.updateMask) !== null && _b !== void 0 ? _b : void 0;
      message.metadata = (_c = object.metadata) !== null && _c !== void 0 ? _c : void 0;
      return message;
    }
  };
  function createBaseUpdateCollectionResponse() {
    return { collection: void 0 };
  }
  exports2.UpdateCollectionResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collection !== void 0) {
        exports2.Collection.encode(message.collection, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseUpdateCollectionResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collection = exports2.Collection.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collection: isSet2(object.collection) ? exports2.Collection.fromJSON(object.collection) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collection !== void 0 && (obj.collection = message.collection ? exports2.Collection.toJSON(message.collection) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseUpdateCollectionResponse();
      message.collection = object.collection !== void 0 && object.collection !== null ? exports2.Collection.fromPartial(object.collection) : void 0;
      return message;
    }
  };
  function createBaseDeleteCollectionRequest() {
    return { collectionId: "", force: void 0 };
  }
  exports2.DeleteCollectionRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.force !== void 0) {
        writer2.uint32(16).bool(message.force);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDeleteCollectionRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.force = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        force: isSet2(object.force) ? Boolean(object.force) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.force !== void 0 && (obj.force = message.force);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseDeleteCollectionRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.force = (_b = object.force) !== null && _b !== void 0 ? _b : void 0;
      return message;
    }
  };
  function createBaseDeleteCollectionResponse() {
    return { sourcesDeleted: 0, projectsDeleted: 0, projectIdsStopped: [] };
  }
  exports2.DeleteCollectionResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.sourcesDeleted !== 0) {
        writer2.uint32(8).uint32(message.sourcesDeleted);
      }
      if (message.projectsDeleted !== 0) {
        writer2.uint32(16).uint32(message.projectsDeleted);
      }
      for (const v of message.projectIdsStopped) {
        writer2.uint32(26).string(v);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDeleteCollectionResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.sourcesDeleted = reader2.uint32();
            break;
          case 2:
            message.projectsDeleted = reader2.uint32();
            break;
          case 3:
            message.projectIdsStopped.push(reader2.string());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        sourcesDeleted: isSet2(object.sourcesDeleted) ? Number(object.sourcesDeleted) : 0,
        projectsDeleted: isSet2(object.projectsDeleted) ? Number(object.projectsDeleted) : 0,
        projectIdsStopped: Array.isArray(object === null || object === void 0 ? void 0 : object.projectIdsStopped) ? object.projectIdsStopped.map((e2) => String(e2)) : []
      };
    },
    toJSON(message) {
      const obj = {};
      message.sourcesDeleted !== void 0 && (obj.sourcesDeleted = Math.round(message.sourcesDeleted));
      message.projectsDeleted !== void 0 && (obj.projectsDeleted = Math.round(message.projectsDeleted));
      if (message.projectIdsStopped) {
        obj.projectIdsStopped = message.projectIdsStopped.map((e2) => e2);
      } else {
        obj.projectIdsStopped = [];
      }
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseDeleteCollectionResponse();
      message.sourcesDeleted = (_a2 = object.sourcesDeleted) !== null && _a2 !== void 0 ? _a2 : 0;
      message.projectsDeleted = (_b = object.projectsDeleted) !== null && _b !== void 0 ? _b : 0;
      message.projectIdsStopped = ((_c = object.projectIdsStopped) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
      return message;
    }
  };
  function createBaseGetCollectionsRequest() {
    return {};
  }
  exports2.GetCollectionsRequest = {
    encode(_, writer2 = _m02.Writer.create()) {
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetCollectionsRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(_) {
      return {};
    },
    toJSON(_) {
      const obj = {};
      return obj;
    },
    fromPartial(_) {
      const message = createBaseGetCollectionsRequest();
      return message;
    }
  };
  function createBaseGetCollectionsResponse() {
    return { collections: [] };
  }
  exports2.GetCollectionsResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      for (const v of message.collections) {
        exports2.Collection.encode(v, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetCollectionsResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collections.push(exports2.Collection.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collections: Array.isArray(object === null || object === void 0 ? void 0 : object.collections) ? object.collections.map((e2) => exports2.Collection.fromJSON(e2)) : []
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.collections) {
        obj.collections = message.collections.map((e2) => e2 ? exports2.Collection.toJSON(e2) : void 0);
      } else {
        obj.collections = [];
      }
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseGetCollectionsResponse();
      message.collections = ((_a2 = object.collections) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports2.Collection.fromPartial(e2))) || [];
      return message;
    }
  };
  function createBaseCreateProjectRequest() {
    return {
      collectionId: "",
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      location: void 0
    };
  }
  exports2.CreateProjectRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(18).fork()).ldelim();
      }
      if (message.rendering !== void 0) {
        exports2.Rendering.encode(message.rendering, writer2.uint32(26).fork()).ldelim();
      }
      if (message.encoding !== void 0) {
        exports2.Encoding.encode(message.encoding, writer2.uint32(34).fork()).ldelim();
      }
      if (message.composition !== void 0) {
        exports2.Composition.encode(message.composition, writer2.uint32(42).fork()).ldelim();
      }
      if (message.maxDuration !== void 0) {
        writer2.uint32(48).uint32(message.maxDuration);
      }
      if (message.webrtc !== void 0) {
        exports2.WebRtc.encode(message.webrtc, writer2.uint32(58).fork()).ldelim();
      }
      if (message.location !== void 0) {
        exports2.LatLong.encode(message.location, writer2.uint32(74).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCreateProjectRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 3:
            message.rendering = exports2.Rendering.decode(reader2, reader2.uint32());
            break;
          case 4:
            message.encoding = exports2.Encoding.decode(reader2, reader2.uint32());
            break;
          case 5:
            message.composition = exports2.Composition.decode(reader2, reader2.uint32());
            break;
          case 6:
            message.maxDuration = reader2.uint32();
            break;
          case 7:
            message.webrtc = exports2.WebRtc.decode(reader2, reader2.uint32());
            break;
          case 9:
            message.location = exports2.LatLong.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0,
        rendering: isSet2(object.rendering) ? exports2.Rendering.fromJSON(object.rendering) : void 0,
        encoding: isSet2(object.encoding) ? exports2.Encoding.fromJSON(object.encoding) : void 0,
        composition: isSet2(object.composition) ? exports2.Composition.fromJSON(object.composition) : void 0,
        maxDuration: isSet2(object.maxDuration) ? Number(object.maxDuration) : void 0,
        webrtc: isSet2(object.webrtc) ? exports2.WebRtc.fromJSON(object.webrtc) : void 0,
        location: isSet2(object.location) ? exports2.LatLong.fromJSON(object.location) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.rendering !== void 0 && (obj.rendering = message.rendering ? exports2.Rendering.toJSON(message.rendering) : void 0);
      message.encoding !== void 0 && (obj.encoding = message.encoding ? exports2.Encoding.toJSON(message.encoding) : void 0);
      message.composition !== void 0 && (obj.composition = message.composition ? exports2.Composition.toJSON(message.composition) : void 0);
      message.maxDuration !== void 0 && (obj.maxDuration = Math.round(message.maxDuration));
      message.webrtc !== void 0 && (obj.webrtc = message.webrtc ? exports2.WebRtc.toJSON(message.webrtc) : void 0);
      message.location !== void 0 && (obj.location = message.location ? exports2.LatLong.toJSON(message.location) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseCreateProjectRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.metadata = (_b = object.metadata) !== null && _b !== void 0 ? _b : void 0;
      message.rendering = object.rendering !== void 0 && object.rendering !== null ? exports2.Rendering.fromPartial(object.rendering) : void 0;
      message.encoding = object.encoding !== void 0 && object.encoding !== null ? exports2.Encoding.fromPartial(object.encoding) : void 0;
      message.composition = object.composition !== void 0 && object.composition !== null ? exports2.Composition.fromPartial(object.composition) : void 0;
      message.maxDuration = (_c = object.maxDuration) !== null && _c !== void 0 ? _c : void 0;
      message.webrtc = object.webrtc !== void 0 && object.webrtc !== null ? exports2.WebRtc.fromPartial(object.webrtc) : void 0;
      message.location = object.location !== void 0 && object.location !== null ? exports2.LatLong.fromPartial(object.location) : void 0;
      return message;
    }
  };
  function createBaseCreateProjectResponse() {
    return { project: void 0 };
  }
  exports2.CreateProjectResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.project !== void 0) {
        exports2.Project.encode(message.project, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCreateProjectResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.project = exports2.Project.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        project: isSet2(object.project) ? exports2.Project.fromJSON(object.project) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.project !== void 0 && (obj.project = message.project ? exports2.Project.toJSON(message.project) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseCreateProjectResponse();
      message.project = object.project !== void 0 && object.project !== null ? exports2.Project.fromPartial(object.project) : void 0;
      return message;
    }
  };
  function createBaseUpdateProjectRequest() {
    return {
      collectionId: "",
      projectId: "",
      updateMask: void 0,
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      location: void 0
    };
  }
  exports2.UpdateProjectRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.updateMask !== void 0) {
        field_mask_1.FieldMask.encode(field_mask_1.FieldMask.wrap(message.updateMask), writer2.uint32(26).fork()).ldelim();
      }
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(34).fork()).ldelim();
      }
      if (message.rendering !== void 0) {
        exports2.Rendering.encode(message.rendering, writer2.uint32(42).fork()).ldelim();
      }
      if (message.encoding !== void 0) {
        exports2.Encoding.encode(message.encoding, writer2.uint32(50).fork()).ldelim();
      }
      if (message.composition !== void 0) {
        exports2.Composition.encode(message.composition, writer2.uint32(58).fork()).ldelim();
      }
      if (message.maxDuration !== void 0) {
        writer2.uint32(64).uint32(message.maxDuration);
      }
      if (message.webrtc !== void 0) {
        exports2.WebRtc.encode(message.webrtc, writer2.uint32(74).fork()).ldelim();
      }
      if (message.location !== void 0) {
        exports2.LatLong.encode(message.location, writer2.uint32(82).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseUpdateProjectRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.updateMask = field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.decode(reader2, reader2.uint32()));
            break;
          case 4:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 5:
            message.rendering = exports2.Rendering.decode(reader2, reader2.uint32());
            break;
          case 6:
            message.encoding = exports2.Encoding.decode(reader2, reader2.uint32());
            break;
          case 7:
            message.composition = exports2.Composition.decode(reader2, reader2.uint32());
            break;
          case 8:
            message.maxDuration = reader2.uint32();
            break;
          case 9:
            message.webrtc = exports2.WebRtc.decode(reader2, reader2.uint32());
            break;
          case 10:
            message.location = exports2.LatLong.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        updateMask: isSet2(object.updateMask) ? field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.fromJSON(object.updateMask)) : void 0,
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0,
        rendering: isSet2(object.rendering) ? exports2.Rendering.fromJSON(object.rendering) : void 0,
        encoding: isSet2(object.encoding) ? exports2.Encoding.fromJSON(object.encoding) : void 0,
        composition: isSet2(object.composition) ? exports2.Composition.fromJSON(object.composition) : void 0,
        maxDuration: isSet2(object.maxDuration) ? Number(object.maxDuration) : void 0,
        webrtc: isSet2(object.webrtc) ? exports2.WebRtc.fromJSON(object.webrtc) : void 0,
        location: isSet2(object.location) ? exports2.LatLong.fromJSON(object.location) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.updateMask !== void 0 && (obj.updateMask = field_mask_1.FieldMask.toJSON(field_mask_1.FieldMask.wrap(message.updateMask)));
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.rendering !== void 0 && (obj.rendering = message.rendering ? exports2.Rendering.toJSON(message.rendering) : void 0);
      message.encoding !== void 0 && (obj.encoding = message.encoding ? exports2.Encoding.toJSON(message.encoding) : void 0);
      message.composition !== void 0 && (obj.composition = message.composition ? exports2.Composition.toJSON(message.composition) : void 0);
      message.maxDuration !== void 0 && (obj.maxDuration = Math.round(message.maxDuration));
      message.webrtc !== void 0 && (obj.webrtc = message.webrtc ? exports2.WebRtc.toJSON(message.webrtc) : void 0);
      message.location !== void 0 && (obj.location = message.location ? exports2.LatLong.toJSON(message.location) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e;
      const message = createBaseUpdateProjectRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.updateMask = (_c = object.updateMask) !== null && _c !== void 0 ? _c : void 0;
      message.metadata = (_d = object.metadata) !== null && _d !== void 0 ? _d : void 0;
      message.rendering = object.rendering !== void 0 && object.rendering !== null ? exports2.Rendering.fromPartial(object.rendering) : void 0;
      message.encoding = object.encoding !== void 0 && object.encoding !== null ? exports2.Encoding.fromPartial(object.encoding) : void 0;
      message.composition = object.composition !== void 0 && object.composition !== null ? exports2.Composition.fromPartial(object.composition) : void 0;
      message.maxDuration = (_e = object.maxDuration) !== null && _e !== void 0 ? _e : void 0;
      message.webrtc = object.webrtc !== void 0 && object.webrtc !== null ? exports2.WebRtc.fromPartial(object.webrtc) : void 0;
      message.location = object.location !== void 0 && object.location !== null ? exports2.LatLong.fromPartial(object.location) : void 0;
      return message;
    }
  };
  function createBaseUpdateProjectResponse() {
    return { project: void 0, broadcastUpdated: false };
  }
  exports2.UpdateProjectResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.project !== void 0) {
        exports2.Project.encode(message.project, writer2.uint32(10).fork()).ldelim();
      }
      if (message.broadcastUpdated === true) {
        writer2.uint32(16).bool(message.broadcastUpdated);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseUpdateProjectResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.project = exports2.Project.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.broadcastUpdated = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        project: isSet2(object.project) ? exports2.Project.fromJSON(object.project) : void 0,
        broadcastUpdated: isSet2(object.broadcastUpdated) ? Boolean(object.broadcastUpdated) : false
      };
    },
    toJSON(message) {
      const obj = {};
      message.project !== void 0 && (obj.project = message.project ? exports2.Project.toJSON(message.project) : void 0);
      message.broadcastUpdated !== void 0 && (obj.broadcastUpdated = message.broadcastUpdated);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseUpdateProjectResponse();
      message.project = object.project !== void 0 && object.project !== null ? exports2.Project.fromPartial(object.project) : void 0;
      message.broadcastUpdated = (_a2 = object.broadcastUpdated) !== null && _a2 !== void 0 ? _a2 : false;
      return message;
    }
  };
  function createBaseDeleteProjectRequest() {
    return { collectionId: "", projectId: "", force: void 0 };
  }
  exports2.DeleteProjectRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.force !== void 0) {
        writer2.uint32(24).bool(message.force);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDeleteProjectRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.force = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        force: isSet2(object.force) ? Boolean(object.force) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.force !== void 0 && (obj.force = message.force);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseDeleteProjectRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.force = (_c = object.force) !== null && _c !== void 0 ? _c : void 0;
      return message;
    }
  };
  function createBaseDeleteProjectResponse() {
    return { broadcastStopped: false, layoutsDeleted: 0 };
  }
  exports2.DeleteProjectResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.broadcastStopped === true) {
        writer2.uint32(8).bool(message.broadcastStopped);
      }
      if (message.layoutsDeleted !== 0) {
        writer2.uint32(16).uint32(message.layoutsDeleted);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDeleteProjectResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.broadcastStopped = reader2.bool();
            break;
          case 2:
            message.layoutsDeleted = reader2.uint32();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        broadcastStopped: isSet2(object.broadcastStopped) ? Boolean(object.broadcastStopped) : false,
        layoutsDeleted: isSet2(object.layoutsDeleted) ? Number(object.layoutsDeleted) : 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.broadcastStopped !== void 0 && (obj.broadcastStopped = message.broadcastStopped);
      message.layoutsDeleted !== void 0 && (obj.layoutsDeleted = Math.round(message.layoutsDeleted));
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseDeleteProjectResponse();
      message.broadcastStopped = (_a2 = object.broadcastStopped) !== null && _a2 !== void 0 ? _a2 : false;
      message.layoutsDeleted = (_b = object.layoutsDeleted) !== null && _b !== void 0 ? _b : 0;
      return message;
    }
  };
  function createBaseStartProjectBroadcastRequest() {
    return { collectionId: "", projectId: "", webrtcStart: void 0 };
  }
  exports2.StartProjectBroadcastRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.webrtcStart !== void 0) {
        writer2.uint32(24).bool(message.webrtcStart);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseStartProjectBroadcastRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.webrtcStart = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        webrtcStart: isSet2(object.webrtcStart) ? Boolean(object.webrtcStart) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.webrtcStart !== void 0 && (obj.webrtcStart = message.webrtcStart);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseStartProjectBroadcastRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.webrtcStart = (_c = object.webrtcStart) !== null && _c !== void 0 ? _c : void 0;
      return message;
    }
  };
  function createBaseStartProjectBroadcastResponse() {
    return { broadcastId: "" };
  }
  exports2.StartProjectBroadcastResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.broadcastId !== "") {
        writer2.uint32(10).string(message.broadcastId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseStartProjectBroadcastResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.broadcastId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        broadcastId: isSet2(object.broadcastId) ? String(object.broadcastId) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.broadcastId !== void 0 && (obj.broadcastId = message.broadcastId);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseStartProjectBroadcastResponse();
      message.broadcastId = (_a2 = object.broadcastId) !== null && _a2 !== void 0 ? _a2 : "";
      return message;
    }
  };
  function createBaseStopProjectBroadcastRequest() {
    return { collectionId: "", projectId: "", webrtcStop: void 0 };
  }
  exports2.StopProjectBroadcastRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.webrtcStop !== void 0) {
        writer2.uint32(24).bool(message.webrtcStop);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseStopProjectBroadcastRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.webrtcStop = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        webrtcStop: isSet2(object.webrtcStop) ? Boolean(object.webrtcStop) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.webrtcStop !== void 0 && (obj.webrtcStop = message.webrtcStop);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseStopProjectBroadcastRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.webrtcStop = (_c = object.webrtcStop) !== null && _c !== void 0 ? _c : void 0;
      return message;
    }
  };
  function createBaseStopProjectBroadcastResponse() {
    return {};
  }
  exports2.StopProjectBroadcastResponse = {
    encode(_, writer2 = _m02.Writer.create()) {
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseStopProjectBroadcastResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(_) {
      return {};
    },
    toJSON(_) {
      const obj = {};
      return obj;
    },
    fromPartial(_) {
      const message = createBaseStopProjectBroadcastResponse();
      return message;
    }
  };
  function createBaseGetProjectRequest() {
    return { collectionId: "", projectId: "", status: void 0 };
  }
  exports2.GetProjectRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.status !== void 0) {
        writer2.uint32(24).bool(message.status);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetProjectRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.status = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        status: isSet2(object.status) ? Boolean(object.status) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.status !== void 0 && (obj.status = message.status);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseGetProjectRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.status = (_c = object.status) !== null && _c !== void 0 ? _c : void 0;
      return message;
    }
  };
  function createBaseGetProjectResponse() {
    return { project: void 0, status: void 0 };
  }
  exports2.GetProjectResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.project !== void 0) {
        exports2.Project.encode(message.project, writer2.uint32(10).fork()).ldelim();
      }
      if (message.status !== void 0) {
        exports2.ProjectBroadcastStatus.encode(message.status, writer2.uint32(18).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetProjectResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.project = exports2.Project.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.status = exports2.ProjectBroadcastStatus.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        project: isSet2(object.project) ? exports2.Project.fromJSON(object.project) : void 0,
        status: isSet2(object.status) ? exports2.ProjectBroadcastStatus.fromJSON(object.status) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.project !== void 0 && (obj.project = message.project ? exports2.Project.toJSON(message.project) : void 0);
      message.status !== void 0 && (obj.status = message.status ? exports2.ProjectBroadcastStatus.toJSON(message.status) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseGetProjectResponse();
      message.project = object.project !== void 0 && object.project !== null ? exports2.Project.fromPartial(object.project) : void 0;
      message.status = object.status !== void 0 && object.status !== null ? exports2.ProjectBroadcastStatus.fromPartial(object.status) : void 0;
      return message;
    }
  };
  function createBaseGetProjectBroadcastSnapshotRequest() {
    return { collectionId: "", projectId: "", format: void 0 };
  }
  exports2.GetProjectBroadcastSnapshotRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.format !== void 0) {
        writer2.uint32(24).int32(imageFormatToNumber(message.format));
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetProjectBroadcastSnapshotRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.format = imageFormatFromJSON(reader2.int32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        format: isSet2(object.format) ? imageFormatFromJSON(object.format) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.format !== void 0 && (obj.format = message.format !== void 0 ? imageFormatToJSON(message.format) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseGetProjectBroadcastSnapshotRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.format = (_c = object.format) !== null && _c !== void 0 ? _c : void 0;
      return message;
    }
  };
  function createBaseGetProjectBroadcastSnapshotResponse() {
    return {
      format: ImageFormat.IMAGE_FORMAT_UNSPECIFIED,
      image: new Uint8Array()
    };
  }
  exports2.GetProjectBroadcastSnapshotResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.format !== ImageFormat.IMAGE_FORMAT_UNSPECIFIED) {
        writer2.uint32(8).int32(imageFormatToNumber(message.format));
      }
      if (message.image.length !== 0) {
        writer2.uint32(18).bytes(message.image);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetProjectBroadcastSnapshotResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.format = imageFormatFromJSON(reader2.int32());
            break;
          case 2:
            message.image = reader2.bytes();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        format: isSet2(object.format) ? imageFormatFromJSON(object.format) : ImageFormat.IMAGE_FORMAT_UNSPECIFIED,
        image: isSet2(object.image) ? bytesFromBase642(object.image) : new Uint8Array()
      };
    },
    toJSON(message) {
      const obj = {};
      message.format !== void 0 && (obj.format = imageFormatToJSON(message.format));
      message.image !== void 0 && (obj.image = base64FromBytes2(message.image !== void 0 ? message.image : new Uint8Array()));
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseGetProjectBroadcastSnapshotResponse();
      message.format = (_a2 = object.format) !== null && _a2 !== void 0 ? _a2 : ImageFormat.IMAGE_FORMAT_UNSPECIFIED;
      message.image = (_b = object.image) !== null && _b !== void 0 ? _b : new Uint8Array();
      return message;
    }
  };
  function createBaseGetProjectBroadcastStatusRequest() {
    return { collectionId: "", projectId: "" };
  }
  exports2.GetProjectBroadcastStatusRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetProjectBroadcastStatusRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseGetProjectBroadcastStatusRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      return message;
    }
  };
  function createBaseGetProjectBroadcastStatusResponse() {
    return { status: void 0 };
  }
  exports2.GetProjectBroadcastStatusResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.status !== void 0) {
        exports2.ProjectBroadcastStatus.encode(message.status, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetProjectBroadcastStatusResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.status = exports2.ProjectBroadcastStatus.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        status: isSet2(object.status) ? exports2.ProjectBroadcastStatus.fromJSON(object.status) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.status !== void 0 && (obj.status = message.status ? exports2.ProjectBroadcastStatus.toJSON(message.status) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseGetProjectBroadcastStatusResponse();
      message.status = object.status !== void 0 && object.status !== null ? exports2.ProjectBroadcastStatus.fromPartial(object.status) : void 0;
      return message;
    }
  };
  function createBaseStartProjectWebRtcRequest() {
    return { collectionId: "", projectId: "" };
  }
  exports2.StartProjectWebRtcRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseStartProjectWebRtcRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseStartProjectWebRtcRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      return message;
    }
  };
  function createBaseStartProjectWebRtcResponse() {
    return {};
  }
  exports2.StartProjectWebRtcResponse = {
    encode(_, writer2 = _m02.Writer.create()) {
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseStartProjectWebRtcResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(_) {
      return {};
    },
    toJSON(_) {
      const obj = {};
      return obj;
    },
    fromPartial(_) {
      const message = createBaseStartProjectWebRtcResponse();
      return message;
    }
  };
  function createBaseStopProjectWebRtcRequest() {
    return { collectionId: "", projectId: "" };
  }
  exports2.StopProjectWebRtcRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseStopProjectWebRtcRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseStopProjectWebRtcRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      return message;
    }
  };
  function createBaseStopProjectWebRtcResponse() {
    return {};
  }
  exports2.StopProjectWebRtcResponse = {
    encode(_, writer2 = _m02.Writer.create()) {
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseStopProjectWebRtcResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(_) {
      return {};
    },
    toJSON(_) {
      const obj = {};
      return obj;
    },
    fromPartial(_) {
      const message = createBaseStopProjectWebRtcResponse();
      return message;
    }
  };
  function createBaseCreateDestinationRequest() {
    return {
      collectionId: "",
      projectId: "",
      metadata: void 0,
      address: void 0,
      enabled: void 0,
      timeout: void 0
    };
  }
  exports2.CreateDestinationRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(26).fork()).ldelim();
      }
      if (message.address !== void 0) {
        exports2.DestinationAddress.encode(message.address, writer2.uint32(42).fork()).ldelim();
      }
      if (message.enabled !== void 0) {
        writer2.uint32(48).bool(message.enabled);
      }
      if (message.timeout !== void 0) {
        writer2.uint32(56).uint32(message.timeout);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCreateDestinationRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 5:
            message.address = exports2.DestinationAddress.decode(reader2, reader2.uint32());
            break;
          case 6:
            message.enabled = reader2.bool();
            break;
          case 7:
            message.timeout = reader2.uint32();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0,
        address: isSet2(object.address) ? exports2.DestinationAddress.fromJSON(object.address) : void 0,
        enabled: isSet2(object.enabled) ? Boolean(object.enabled) : void 0,
        timeout: isSet2(object.timeout) ? Number(object.timeout) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.address !== void 0 && (obj.address = message.address ? exports2.DestinationAddress.toJSON(message.address) : void 0);
      message.enabled !== void 0 && (obj.enabled = message.enabled);
      message.timeout !== void 0 && (obj.timeout = Math.round(message.timeout));
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e;
      const message = createBaseCreateDestinationRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.metadata = (_c = object.metadata) !== null && _c !== void 0 ? _c : void 0;
      message.address = object.address !== void 0 && object.address !== null ? exports2.DestinationAddress.fromPartial(object.address) : void 0;
      message.enabled = (_d = object.enabled) !== null && _d !== void 0 ? _d : void 0;
      message.timeout = (_e = object.timeout) !== null && _e !== void 0 ? _e : void 0;
      return message;
    }
  };
  function createBaseCreateDestinationResponse() {
    return { destination: void 0 };
  }
  exports2.CreateDestinationResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.destination !== void 0) {
        exports2.Destination.encode(message.destination, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCreateDestinationResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.destination = exports2.Destination.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        destination: isSet2(object.destination) ? exports2.Destination.fromJSON(object.destination) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.destination !== void 0 && (obj.destination = message.destination ? exports2.Destination.toJSON(message.destination) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseCreateDestinationResponse();
      message.destination = object.destination !== void 0 && object.destination !== null ? exports2.Destination.fromPartial(object.destination) : void 0;
      return message;
    }
  };
  function createBaseGetDestinationRequest() {
    return { collectionId: "", projectId: "", destinationId: "" };
  }
  exports2.GetDestinationRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.destinationId !== "") {
        writer2.uint32(26).string(message.destinationId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetDestinationRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.destinationId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        destinationId: isSet2(object.destinationId) ? String(object.destinationId) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.destinationId !== void 0 && (obj.destinationId = message.destinationId);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseGetDestinationRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.destinationId = (_c = object.destinationId) !== null && _c !== void 0 ? _c : "";
      return message;
    }
  };
  function createBaseGetDestinationResponse() {
    return { destination: void 0 };
  }
  exports2.GetDestinationResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.destination !== void 0) {
        exports2.Destination.encode(message.destination, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetDestinationResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.destination = exports2.Destination.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        destination: isSet2(object.destination) ? exports2.Destination.fromJSON(object.destination) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.destination !== void 0 && (obj.destination = message.destination ? exports2.Destination.toJSON(message.destination) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseGetDestinationResponse();
      message.destination = object.destination !== void 0 && object.destination !== null ? exports2.Destination.fromPartial(object.destination) : void 0;
      return message;
    }
  };
  function createBaseDeleteDestinationRequest() {
    return {
      collectionId: "",
      projectId: "",
      destinationId: "",
      force: void 0
    };
  }
  exports2.DeleteDestinationRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.destinationId !== "") {
        writer2.uint32(26).string(message.destinationId);
      }
      if (message.force !== void 0) {
        writer2.uint32(32).bool(message.force);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDeleteDestinationRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.destinationId = reader2.string();
            break;
          case 4:
            message.force = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        destinationId: isSet2(object.destinationId) ? String(object.destinationId) : "",
        force: isSet2(object.force) ? Boolean(object.force) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.destinationId !== void 0 && (obj.destinationId = message.destinationId);
      message.force !== void 0 && (obj.force = message.force);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d;
      const message = createBaseDeleteDestinationRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.destinationId = (_c = object.destinationId) !== null && _c !== void 0 ? _c : "";
      message.force = (_d = object.force) !== null && _d !== void 0 ? _d : void 0;
      return message;
    }
  };
  function createBaseDeleteDestinationResponse() {
    return { broadcastUpdated: false };
  }
  exports2.DeleteDestinationResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.broadcastUpdated === true) {
        writer2.uint32(8).bool(message.broadcastUpdated);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDeleteDestinationResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.broadcastUpdated = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        broadcastUpdated: isSet2(object.broadcastUpdated) ? Boolean(object.broadcastUpdated) : false
      };
    },
    toJSON(message) {
      const obj = {};
      message.broadcastUpdated !== void 0 && (obj.broadcastUpdated = message.broadcastUpdated);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseDeleteDestinationResponse();
      message.broadcastUpdated = (_a2 = object.broadcastUpdated) !== null && _a2 !== void 0 ? _a2 : false;
      return message;
    }
  };
  function createBaseUpdateDestinationRequest() {
    return {
      collectionId: "",
      projectId: "",
      destinationId: "",
      updateMask: void 0,
      metadata: void 0,
      address: void 0,
      enabled: void 0,
      timeout: void 0
    };
  }
  exports2.UpdateDestinationRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.destinationId !== "") {
        writer2.uint32(26).string(message.destinationId);
      }
      if (message.updateMask !== void 0) {
        field_mask_1.FieldMask.encode(field_mask_1.FieldMask.wrap(message.updateMask), writer2.uint32(34).fork()).ldelim();
      }
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(42).fork()).ldelim();
      }
      if (message.address !== void 0) {
        exports2.DestinationAddress.encode(message.address, writer2.uint32(50).fork()).ldelim();
      }
      if (message.enabled !== void 0) {
        writer2.uint32(56).bool(message.enabled);
      }
      if (message.timeout !== void 0) {
        writer2.uint32(64).uint32(message.timeout);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseUpdateDestinationRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.destinationId = reader2.string();
            break;
          case 4:
            message.updateMask = field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.decode(reader2, reader2.uint32()));
            break;
          case 5:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 6:
            message.address = exports2.DestinationAddress.decode(reader2, reader2.uint32());
            break;
          case 7:
            message.enabled = reader2.bool();
            break;
          case 8:
            message.timeout = reader2.uint32();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        destinationId: isSet2(object.destinationId) ? String(object.destinationId) : "",
        updateMask: isSet2(object.updateMask) ? field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.fromJSON(object.updateMask)) : void 0,
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0,
        address: isSet2(object.address) ? exports2.DestinationAddress.fromJSON(object.address) : void 0,
        enabled: isSet2(object.enabled) ? Boolean(object.enabled) : void 0,
        timeout: isSet2(object.timeout) ? Number(object.timeout) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.destinationId !== void 0 && (obj.destinationId = message.destinationId);
      message.updateMask !== void 0 && (obj.updateMask = field_mask_1.FieldMask.toJSON(field_mask_1.FieldMask.wrap(message.updateMask)));
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.address !== void 0 && (obj.address = message.address ? exports2.DestinationAddress.toJSON(message.address) : void 0);
      message.enabled !== void 0 && (obj.enabled = message.enabled);
      message.timeout !== void 0 && (obj.timeout = Math.round(message.timeout));
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e, _f, _g;
      const message = createBaseUpdateDestinationRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.destinationId = (_c = object.destinationId) !== null && _c !== void 0 ? _c : "";
      message.updateMask = (_d = object.updateMask) !== null && _d !== void 0 ? _d : void 0;
      message.metadata = (_e = object.metadata) !== null && _e !== void 0 ? _e : void 0;
      message.address = object.address !== void 0 && object.address !== null ? exports2.DestinationAddress.fromPartial(object.address) : void 0;
      message.enabled = (_f = object.enabled) !== null && _f !== void 0 ? _f : void 0;
      message.timeout = (_g = object.timeout) !== null && _g !== void 0 ? _g : void 0;
      return message;
    }
  };
  function createBaseUpdateDestinationResponse() {
    return { destination: void 0, broadcastUpdated: false };
  }
  exports2.UpdateDestinationResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.destination !== void 0) {
        exports2.Destination.encode(message.destination, writer2.uint32(10).fork()).ldelim();
      }
      if (message.broadcastUpdated === true) {
        writer2.uint32(16).bool(message.broadcastUpdated);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseUpdateDestinationResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.destination = exports2.Destination.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.broadcastUpdated = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        destination: isSet2(object.destination) ? exports2.Destination.fromJSON(object.destination) : void 0,
        broadcastUpdated: isSet2(object.broadcastUpdated) ? Boolean(object.broadcastUpdated) : false
      };
    },
    toJSON(message) {
      const obj = {};
      message.destination !== void 0 && (obj.destination = message.destination ? exports2.Destination.toJSON(message.destination) : void 0);
      message.broadcastUpdated !== void 0 && (obj.broadcastUpdated = message.broadcastUpdated);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseUpdateDestinationResponse();
      message.destination = object.destination !== void 0 && object.destination !== null ? exports2.Destination.fromPartial(object.destination) : void 0;
      message.broadcastUpdated = (_a2 = object.broadcastUpdated) !== null && _a2 !== void 0 ? _a2 : false;
      return message;
    }
  };
  function createBaseCreateSourceRequest() {
    return {
      collectionId: "",
      metadata: void 0,
      address: void 0,
      preview: void 0
    };
  }
  exports2.CreateSourceRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(18).fork()).ldelim();
      }
      if (message.address !== void 0) {
        exports2.SourceAddress.encode(message.address, writer2.uint32(26).fork()).ldelim();
      }
      if (message.preview !== void 0) {
        exports2.PreviewAddress.encode(message.preview, writer2.uint32(34).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCreateSourceRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 3:
            message.address = exports2.SourceAddress.decode(reader2, reader2.uint32());
            break;
          case 4:
            message.preview = exports2.PreviewAddress.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0,
        address: isSet2(object.address) ? exports2.SourceAddress.fromJSON(object.address) : void 0,
        preview: isSet2(object.preview) ? exports2.PreviewAddress.fromJSON(object.preview) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.address !== void 0 && (obj.address = message.address ? exports2.SourceAddress.toJSON(message.address) : void 0);
      message.preview !== void 0 && (obj.preview = message.preview ? exports2.PreviewAddress.toJSON(message.preview) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseCreateSourceRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.metadata = (_b = object.metadata) !== null && _b !== void 0 ? _b : void 0;
      message.address = object.address !== void 0 && object.address !== null ? exports2.SourceAddress.fromPartial(object.address) : void 0;
      message.preview = object.preview !== void 0 && object.preview !== null ? exports2.PreviewAddress.fromPartial(object.preview) : void 0;
      return message;
    }
  };
  function createBaseCreateSourceResponse() {
    return { source: void 0 };
  }
  exports2.CreateSourceResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.source !== void 0) {
        exports2.Source.encode(message.source, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCreateSourceResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.source = exports2.Source.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        source: isSet2(object.source) ? exports2.Source.fromJSON(object.source) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.source !== void 0 && (obj.source = message.source ? exports2.Source.toJSON(message.source) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseCreateSourceResponse();
      message.source = object.source !== void 0 && object.source !== null ? exports2.Source.fromPartial(object.source) : void 0;
      return message;
    }
  };
  function createBaseDeleteSourceRequest() {
    return { collectionId: "", sourceId: "", force: void 0 };
  }
  exports2.DeleteSourceRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.sourceId !== "") {
        writer2.uint32(18).string(message.sourceId);
      }
      if (message.force !== void 0) {
        writer2.uint32(24).bool(message.force);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDeleteSourceRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.sourceId = reader2.string();
            break;
          case 3:
            message.force = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "",
        force: isSet2(object.force) ? Boolean(object.force) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
      message.force !== void 0 && (obj.force = message.force);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseDeleteSourceRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
      message.force = (_c = object.force) !== null && _c !== void 0 ? _c : void 0;
      return message;
    }
  };
  function createBaseDeleteSourceResponse() {
    return { projectIdsUpdated: [] };
  }
  exports2.DeleteSourceResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      for (const v of message.projectIdsUpdated) {
        writer2.uint32(26).string(v);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDeleteSourceResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 3:
            message.projectIdsUpdated.push(reader2.string());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        projectIdsUpdated: Array.isArray(object === null || object === void 0 ? void 0 : object.projectIdsUpdated) ? object.projectIdsUpdated.map((e2) => String(e2)) : []
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.projectIdsUpdated) {
        obj.projectIdsUpdated = message.projectIdsUpdated.map((e2) => e2);
      } else {
        obj.projectIdsUpdated = [];
      }
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseDeleteSourceResponse();
      message.projectIdsUpdated = ((_a2 = object.projectIdsUpdated) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
      return message;
    }
  };
  function createBaseAddSourceToProjectRequest() {
    return { collectionId: "", projectId: "", sourceId: "", trigger: void 0 };
  }
  exports2.AddSourceToProjectRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.sourceId !== "") {
        writer2.uint32(26).string(message.sourceId);
      }
      if (message.trigger !== void 0) {
        exports2.SourceTrigger.encode(message.trigger, writer2.uint32(34).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseAddSourceToProjectRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.sourceId = reader2.string();
            break;
          case 4:
            message.trigger = exports2.SourceTrigger.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "",
        trigger: isSet2(object.trigger) ? exports2.SourceTrigger.fromJSON(object.trigger) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
      message.trigger !== void 0 && (obj.trigger = message.trigger ? exports2.SourceTrigger.toJSON(message.trigger) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseAddSourceToProjectRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.sourceId = (_c = object.sourceId) !== null && _c !== void 0 ? _c : "";
      message.trigger = object.trigger !== void 0 && object.trigger !== null ? exports2.SourceTrigger.fromPartial(object.trigger) : void 0;
      return message;
    }
  };
  function createBaseAddSourceToProjectResponse() {
    return { project: void 0, broadcastUpdated: false };
  }
  exports2.AddSourceToProjectResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.project !== void 0) {
        exports2.Project.encode(message.project, writer2.uint32(10).fork()).ldelim();
      }
      if (message.broadcastUpdated === true) {
        writer2.uint32(16).bool(message.broadcastUpdated);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseAddSourceToProjectResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.project = exports2.Project.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.broadcastUpdated = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        project: isSet2(object.project) ? exports2.Project.fromJSON(object.project) : void 0,
        broadcastUpdated: isSet2(object.broadcastUpdated) ? Boolean(object.broadcastUpdated) : false
      };
    },
    toJSON(message) {
      const obj = {};
      message.project !== void 0 && (obj.project = message.project ? exports2.Project.toJSON(message.project) : void 0);
      message.broadcastUpdated !== void 0 && (obj.broadcastUpdated = message.broadcastUpdated);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseAddSourceToProjectResponse();
      message.project = object.project !== void 0 && object.project !== null ? exports2.Project.fromPartial(object.project) : void 0;
      message.broadcastUpdated = (_a2 = object.broadcastUpdated) !== null && _a2 !== void 0 ? _a2 : false;
      return message;
    }
  };
  function createBaseUpdateSourceInProjectRequest() {
    return {
      collectionId: "",
      projectId: "",
      sourceId: "",
      updateMask: void 0,
      trigger: void 0
    };
  }
  exports2.UpdateSourceInProjectRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.sourceId !== "") {
        writer2.uint32(26).string(message.sourceId);
      }
      if (message.updateMask !== void 0) {
        field_mask_1.FieldMask.encode(field_mask_1.FieldMask.wrap(message.updateMask), writer2.uint32(34).fork()).ldelim();
      }
      if (message.trigger !== void 0) {
        exports2.SourceTrigger.encode(message.trigger, writer2.uint32(42).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseUpdateSourceInProjectRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.sourceId = reader2.string();
            break;
          case 4:
            message.updateMask = field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.decode(reader2, reader2.uint32()));
            break;
          case 5:
            message.trigger = exports2.SourceTrigger.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "",
        updateMask: isSet2(object.updateMask) ? field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.fromJSON(object.updateMask)) : void 0,
        trigger: isSet2(object.trigger) ? exports2.SourceTrigger.fromJSON(object.trigger) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
      message.updateMask !== void 0 && (obj.updateMask = field_mask_1.FieldMask.toJSON(field_mask_1.FieldMask.wrap(message.updateMask)));
      message.trigger !== void 0 && (obj.trigger = message.trigger ? exports2.SourceTrigger.toJSON(message.trigger) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d;
      const message = createBaseUpdateSourceInProjectRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.sourceId = (_c = object.sourceId) !== null && _c !== void 0 ? _c : "";
      message.updateMask = (_d = object.updateMask) !== null && _d !== void 0 ? _d : void 0;
      message.trigger = object.trigger !== void 0 && object.trigger !== null ? exports2.SourceTrigger.fromPartial(object.trigger) : void 0;
      return message;
    }
  };
  function createBaseUpdateSourceInProjectResponse() {
    return { project: void 0 };
  }
  exports2.UpdateSourceInProjectResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.project !== void 0) {
        exports2.Project.encode(message.project, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseUpdateSourceInProjectResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.project = exports2.Project.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        project: isSet2(object.project) ? exports2.Project.fromJSON(object.project) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.project !== void 0 && (obj.project = message.project ? exports2.Project.toJSON(message.project) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseUpdateSourceInProjectResponse();
      message.project = object.project !== void 0 && object.project !== null ? exports2.Project.fromPartial(object.project) : void 0;
      return message;
    }
  };
  function createBaseGetSourceRequest() {
    return { collectionId: "", sourceId: "" };
  }
  exports2.GetSourceRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.sourceId !== "") {
        writer2.uint32(26).string(message.sourceId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetSourceRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 3:
            message.sourceId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        sourceId: isSet2(object.sourceId) ? String(object.sourceId) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseGetSourceRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
      return message;
    }
  };
  function createBaseGetSourceResponse() {
    return { source: void 0 };
  }
  exports2.GetSourceResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.source !== void 0) {
        exports2.Source.encode(message.source, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetSourceResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.source = exports2.Source.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        source: isSet2(object.source) ? exports2.Source.fromJSON(object.source) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.source !== void 0 && (obj.source = message.source ? exports2.Source.toJSON(message.source) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseGetSourceResponse();
      message.source = object.source !== void 0 && object.source !== null ? exports2.Source.fromPartial(object.source) : void 0;
      return message;
    }
  };
  function createBaseGetSourcesRequest() {
    return { collectionId: "" };
  }
  exports2.GetSourcesRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetSourcesRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseGetSourcesRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      return message;
    }
  };
  function createBaseGetSourcesResponse() {
    return { sources: [] };
  }
  exports2.GetSourcesResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      for (const v of message.sources) {
        exports2.Source.encode(v, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetSourcesResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.sources.push(exports2.Source.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        sources: Array.isArray(object === null || object === void 0 ? void 0 : object.sources) ? object.sources.map((e2) => exports2.Source.fromJSON(e2)) : []
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.sources) {
        obj.sources = message.sources.map((e2) => e2 ? exports2.Source.toJSON(e2) : void 0);
      } else {
        obj.sources = [];
      }
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseGetSourcesResponse();
      message.sources = ((_a2 = object.sources) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports2.Source.fromPartial(e2))) || [];
      return message;
    }
  };
  function createBaseUpdateSourceRequest() {
    return {
      collectionId: "",
      sourceId: "",
      updateMask: void 0,
      metadata: void 0,
      address: void 0,
      preview: void 0
    };
  }
  exports2.UpdateSourceRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.sourceId !== "") {
        writer2.uint32(26).string(message.sourceId);
      }
      if (message.updateMask !== void 0) {
        field_mask_1.FieldMask.encode(field_mask_1.FieldMask.wrap(message.updateMask), writer2.uint32(34).fork()).ldelim();
      }
      if (message.metadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.metadata), writer2.uint32(42).fork()).ldelim();
      }
      if (message.address !== void 0) {
        exports2.SourceAddress.encode(message.address, writer2.uint32(50).fork()).ldelim();
      }
      if (message.preview !== void 0) {
        exports2.PreviewAddress.encode(message.preview, writer2.uint32(58).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseUpdateSourceRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 3:
            message.sourceId = reader2.string();
            break;
          case 4:
            message.updateMask = field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.decode(reader2, reader2.uint32()));
            break;
          case 5:
            message.metadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 6:
            message.address = exports2.SourceAddress.decode(reader2, reader2.uint32());
            break;
          case 7:
            message.preview = exports2.PreviewAddress.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "",
        updateMask: isSet2(object.updateMask) ? field_mask_1.FieldMask.unwrap(field_mask_1.FieldMask.fromJSON(object.updateMask)) : void 0,
        metadata: isSet2(object === null || object === void 0 ? void 0 : object.metadata) ? object.metadata : void 0,
        address: isSet2(object.address) ? exports2.SourceAddress.fromJSON(object.address) : void 0,
        preview: isSet2(object.preview) ? exports2.PreviewAddress.fromJSON(object.preview) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
      message.updateMask !== void 0 && (obj.updateMask = field_mask_1.FieldMask.toJSON(field_mask_1.FieldMask.wrap(message.updateMask)));
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.address !== void 0 && (obj.address = message.address ? exports2.SourceAddress.toJSON(message.address) : void 0);
      message.preview !== void 0 && (obj.preview = message.preview ? exports2.PreviewAddress.toJSON(message.preview) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d;
      const message = createBaseUpdateSourceRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
      message.updateMask = (_c = object.updateMask) !== null && _c !== void 0 ? _c : void 0;
      message.metadata = (_d = object.metadata) !== null && _d !== void 0 ? _d : void 0;
      message.address = object.address !== void 0 && object.address !== null ? exports2.SourceAddress.fromPartial(object.address) : void 0;
      message.preview = object.preview !== void 0 && object.preview !== null ? exports2.PreviewAddress.fromPartial(object.preview) : void 0;
      return message;
    }
  };
  function createBaseUpdateSourceResponse() {
    return { source: void 0, broadcastUpdated: false };
  }
  exports2.UpdateSourceResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.source !== void 0) {
        exports2.Source.encode(message.source, writer2.uint32(10).fork()).ldelim();
      }
      if (message.broadcastUpdated === true) {
        writer2.uint32(16).bool(message.broadcastUpdated);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseUpdateSourceResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.source = exports2.Source.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.broadcastUpdated = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        source: isSet2(object.source) ? exports2.Source.fromJSON(object.source) : void 0,
        broadcastUpdated: isSet2(object.broadcastUpdated) ? Boolean(object.broadcastUpdated) : false
      };
    },
    toJSON(message) {
      const obj = {};
      message.source !== void 0 && (obj.source = message.source ? exports2.Source.toJSON(message.source) : void 0);
      message.broadcastUpdated !== void 0 && (obj.broadcastUpdated = message.broadcastUpdated);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseUpdateSourceResponse();
      message.source = object.source !== void 0 && object.source !== null ? exports2.Source.fromPartial(object.source) : void 0;
      message.broadcastUpdated = (_a2 = object.broadcastUpdated) !== null && _a2 !== void 0 ? _a2 : false;
      return message;
    }
  };
  function createBaseRemoveSourceFromProjectRequest() {
    return { collectionId: "", projectId: "", sourceId: "", force: void 0 };
  }
  exports2.RemoveSourceFromProjectRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.sourceId !== "") {
        writer2.uint32(26).string(message.sourceId);
      }
      if (message.force !== void 0) {
        writer2.uint32(32).bool(message.force);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseRemoveSourceFromProjectRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.sourceId = reader2.string();
            break;
          case 4:
            message.force = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "",
        force: isSet2(object.force) ? Boolean(object.force) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
      message.force !== void 0 && (obj.force = message.force);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d;
      const message = createBaseRemoveSourceFromProjectRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.sourceId = (_c = object.sourceId) !== null && _c !== void 0 ? _c : "";
      message.force = (_d = object.force) !== null && _d !== void 0 ? _d : void 0;
      return message;
    }
  };
  function createBaseRemoveSourceFromProjectResponse() {
    return { project: void 0, broadcastUpdated: false };
  }
  exports2.RemoveSourceFromProjectResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.project !== void 0) {
        exports2.Project.encode(message.project, writer2.uint32(10).fork()).ldelim();
      }
      if (message.broadcastUpdated === true) {
        writer2.uint32(16).bool(message.broadcastUpdated);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseRemoveSourceFromProjectResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.project = exports2.Project.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.broadcastUpdated = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        project: isSet2(object.project) ? exports2.Project.fromJSON(object.project) : void 0,
        broadcastUpdated: isSet2(object.broadcastUpdated) ? Boolean(object.broadcastUpdated) : false
      };
    },
    toJSON(message) {
      const obj = {};
      message.project !== void 0 && (obj.project = message.project ? exports2.Project.toJSON(message.project) : void 0);
      message.broadcastUpdated !== void 0 && (obj.broadcastUpdated = message.broadcastUpdated);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseRemoveSourceFromProjectResponse();
      message.project = object.project !== void 0 && object.project !== null ? exports2.Project.fromPartial(object.project) : void 0;
      message.broadcastUpdated = (_a2 = object.broadcastUpdated) !== null && _a2 !== void 0 ? _a2 : false;
      return message;
    }
  };
  function createBaseCreateAccessTokenRequest() {
    return {
      serviceUserId: "",
      displayName: void 0,
      role: void 0,
      maxDuration: void 0
    };
  }
  exports2.CreateAccessTokenRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.serviceUserId !== "") {
        writer2.uint32(10).string(message.serviceUserId);
      }
      if (message.displayName !== void 0) {
        writer2.uint32(34).string(message.displayName);
      }
      if (message.role !== void 0) {
        writer2.uint32(16).int32(roleToNumber(message.role));
      }
      if (message.maxDuration !== void 0) {
        writer2.uint32(24).uint32(message.maxDuration);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCreateAccessTokenRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.serviceUserId = reader2.string();
            break;
          case 4:
            message.displayName = reader2.string();
            break;
          case 2:
            message.role = roleFromJSON(reader2.int32());
            break;
          case 3:
            message.maxDuration = reader2.uint32();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        serviceUserId: isSet2(object.serviceUserId) ? String(object.serviceUserId) : "",
        displayName: isSet2(object.displayName) ? String(object.displayName) : void 0,
        role: isSet2(object.role) ? roleFromJSON(object.role) : void 0,
        maxDuration: isSet2(object.maxDuration) ? Number(object.maxDuration) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.serviceUserId !== void 0 && (obj.serviceUserId = message.serviceUserId);
      message.displayName !== void 0 && (obj.displayName = message.displayName);
      message.role !== void 0 && (obj.role = message.role !== void 0 ? roleToJSON(message.role) : void 0);
      message.maxDuration !== void 0 && (obj.maxDuration = Math.round(message.maxDuration));
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d;
      const message = createBaseCreateAccessTokenRequest();
      message.serviceUserId = (_a2 = object.serviceUserId) !== null && _a2 !== void 0 ? _a2 : "";
      message.displayName = (_b = object.displayName) !== null && _b !== void 0 ? _b : void 0;
      message.role = (_c = object.role) !== null && _c !== void 0 ? _c : void 0;
      message.maxDuration = (_d = object.maxDuration) !== null && _d !== void 0 ? _d : void 0;
      return message;
    }
  };
  function createBaseCreateAccessTokenResponse() {
    return { accessToken: "" };
  }
  exports2.CreateAccessTokenResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.accessToken !== "") {
        writer2.uint32(10).string(message.accessToken);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCreateAccessTokenResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.accessToken = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        accessToken: isSet2(object.accessToken) ? String(object.accessToken) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.accessToken !== void 0 && (obj.accessToken = message.accessToken);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseCreateAccessTokenResponse();
      message.accessToken = (_a2 = object.accessToken) !== null && _a2 !== void 0 ? _a2 : "";
      return message;
    }
  };
  function createBaseGuestAccessTokenDirect() {
    return { displayName: "", serviceUserId: void 0 };
  }
  exports2.GuestAccessTokenDirect = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.displayName !== "") {
        writer2.uint32(10).string(message.displayName);
      }
      if (message.serviceUserId !== void 0) {
        writer2.uint32(18).string(message.serviceUserId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGuestAccessTokenDirect();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.displayName = reader2.string();
            break;
          case 2:
            message.serviceUserId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        displayName: isSet2(object.displayName) ? String(object.displayName) : "",
        serviceUserId: isSet2(object.serviceUserId) ? String(object.serviceUserId) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.displayName !== void 0 && (obj.displayName = message.displayName);
      message.serviceUserId !== void 0 && (obj.serviceUserId = message.serviceUserId);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseGuestAccessTokenDirect();
      message.displayName = (_a2 = object.displayName) !== null && _a2 !== void 0 ? _a2 : "";
      message.serviceUserId = (_b = object.serviceUserId) !== null && _b !== void 0 ? _b : void 0;
      return message;
    }
  };
  function createBaseGuestAccessTokenExchange() {
    return { maxDuration: void 0 };
  }
  exports2.GuestAccessTokenExchange = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.maxDuration !== void 0) {
        writer2.uint32(8).uint32(message.maxDuration);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGuestAccessTokenExchange();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.maxDuration = reader2.uint32();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        maxDuration: isSet2(object.maxDuration) ? Number(object.maxDuration) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.maxDuration !== void 0 && (obj.maxDuration = Math.round(message.maxDuration));
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseGuestAccessTokenExchange();
      message.maxDuration = (_a2 = object.maxDuration) !== null && _a2 !== void 0 ? _a2 : void 0;
      return message;
    }
  };
  function createBaseGuestAccessToken() {
    return { direct: void 0, exchange: void 0 };
  }
  exports2.GuestAccessToken = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.direct !== void 0) {
        exports2.GuestAccessTokenDirect.encode(message.direct, writer2.uint32(10).fork()).ldelim();
      }
      if (message.exchange !== void 0) {
        exports2.GuestAccessTokenExchange.encode(message.exchange, writer2.uint32(18).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGuestAccessToken();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.direct = exports2.GuestAccessTokenDirect.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.exchange = exports2.GuestAccessTokenExchange.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        direct: isSet2(object.direct) ? exports2.GuestAccessTokenDirect.fromJSON(object.direct) : void 0,
        exchange: isSet2(object.exchange) ? exports2.GuestAccessTokenExchange.fromJSON(object.exchange) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.direct !== void 0 && (obj.direct = message.direct ? exports2.GuestAccessTokenDirect.toJSON(message.direct) : void 0);
      message.exchange !== void 0 && (obj.exchange = message.exchange ? exports2.GuestAccessTokenExchange.toJSON(message.exchange) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseGuestAccessToken();
      message.direct = object.direct !== void 0 && object.direct !== null ? exports2.GuestAccessTokenDirect.fromPartial(object.direct) : void 0;
      message.exchange = object.exchange !== void 0 && object.exchange !== null ? exports2.GuestAccessTokenExchange.fromPartial(object.exchange) : void 0;
      return message;
    }
  };
  function createBaseCreateGuestAccessTokenRequest() {
    return {
      collectionId: "",
      projectId: "",
      maxDuration: void 0,
      role: Role2.ROLE_UNSPECIFIED,
      token: void 0,
      url: void 0
    };
  }
  exports2.CreateGuestAccessTokenRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.maxDuration !== void 0) {
        writer2.uint32(24).uint32(message.maxDuration);
      }
      if (message.role !== Role2.ROLE_UNSPECIFIED) {
        writer2.uint32(32).int32(roleToNumber(message.role));
      }
      if (message.token !== void 0) {
        exports2.GuestAccessToken.encode(message.token, writer2.uint32(42).fork()).ldelim();
      }
      if (message.url !== void 0) {
        writer2.uint32(50).string(message.url);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCreateGuestAccessTokenRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.maxDuration = reader2.uint32();
            break;
          case 4:
            message.role = roleFromJSON(reader2.int32());
            break;
          case 5:
            message.token = exports2.GuestAccessToken.decode(reader2, reader2.uint32());
            break;
          case 6:
            message.url = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        maxDuration: isSet2(object.maxDuration) ? Number(object.maxDuration) : void 0,
        role: isSet2(object.role) ? roleFromJSON(object.role) : Role2.ROLE_UNSPECIFIED,
        token: isSet2(object.token) ? exports2.GuestAccessToken.fromJSON(object.token) : void 0,
        url: isSet2(object.url) ? String(object.url) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.maxDuration !== void 0 && (obj.maxDuration = Math.round(message.maxDuration));
      message.role !== void 0 && (obj.role = roleToJSON(message.role));
      message.token !== void 0 && (obj.token = message.token ? exports2.GuestAccessToken.toJSON(message.token) : void 0);
      message.url !== void 0 && (obj.url = message.url);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e;
      const message = createBaseCreateGuestAccessTokenRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.maxDuration = (_c = object.maxDuration) !== null && _c !== void 0 ? _c : void 0;
      message.role = (_d = object.role) !== null && _d !== void 0 ? _d : Role2.ROLE_UNSPECIFIED;
      message.token = object.token !== void 0 && object.token !== null ? exports2.GuestAccessToken.fromPartial(object.token) : void 0;
      message.url = (_e = object.url) !== null && _e !== void 0 ? _e : void 0;
      return message;
    }
  };
  function createBaseCreateGuestAccessTokenResponse() {
    return { accessToken: "", url: void 0 };
  }
  exports2.CreateGuestAccessTokenResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.accessToken !== "") {
        writer2.uint32(10).string(message.accessToken);
      }
      if (message.url !== void 0) {
        writer2.uint32(18).string(message.url);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCreateGuestAccessTokenResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.accessToken = reader2.string();
            break;
          case 2:
            message.url = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        accessToken: isSet2(object.accessToken) ? String(object.accessToken) : "",
        url: isSet2(object.url) ? String(object.url) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.accessToken !== void 0 && (obj.accessToken = message.accessToken);
      message.url !== void 0 && (obj.url = message.url);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseCreateGuestAccessTokenResponse();
      message.accessToken = (_a2 = object.accessToken) !== null && _a2 !== void 0 ? _a2 : "";
      message.url = (_b = object.url) !== null && _b !== void 0 ? _b : void 0;
      return message;
    }
  };
  function createBaseCreateWebRtcAccessTokenRequest() {
    return { collectionId: "", projectId: "", displayName: "" };
  }
  exports2.CreateWebRtcAccessTokenRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.displayName !== "") {
        writer2.uint32(26).string(message.displayName);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCreateWebRtcAccessTokenRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.displayName = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        displayName: isSet2(object.displayName) ? String(object.displayName) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.displayName !== void 0 && (obj.displayName = message.displayName);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseCreateWebRtcAccessTokenRequest();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.displayName = (_c = object.displayName) !== null && _c !== void 0 ? _c : "";
      return message;
    }
  };
  function createBaseCreateWebRtcAccessTokenResponse() {
    return { webrtcAccess: void 0 };
  }
  exports2.CreateWebRtcAccessTokenResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.webrtcAccess !== void 0) {
        exports2.WebRtcAccess.encode(message.webrtcAccess, writer2.uint32(18).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCreateWebRtcAccessTokenResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 2:
            message.webrtcAccess = exports2.WebRtcAccess.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        webrtcAccess: isSet2(object.webrtcAccess) ? exports2.WebRtcAccess.fromJSON(object.webrtcAccess) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.webrtcAccess !== void 0 && (obj.webrtcAccess = message.webrtcAccess ? exports2.WebRtcAccess.toJSON(message.webrtcAccess) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseCreateWebRtcAccessTokenResponse();
      message.webrtcAccess = object.webrtcAccess !== void 0 && object.webrtcAccess !== null ? exports2.WebRtcAccess.fromPartial(object.webrtcAccess) : void 0;
      return message;
    }
  };
  function createBaseRefreshAccessTokenRequest() {
    return {};
  }
  exports2.RefreshAccessTokenRequest = {
    encode(_, writer2 = _m02.Writer.create()) {
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseRefreshAccessTokenRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(_) {
      return {};
    },
    toJSON(_) {
      const obj = {};
      return obj;
    },
    fromPartial(_) {
      const message = createBaseRefreshAccessTokenRequest();
      return message;
    }
  };
  function createBaseRefreshAccessTokenResponse() {
    return {};
  }
  exports2.RefreshAccessTokenResponse = {
    encode(_, writer2 = _m02.Writer.create()) {
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseRefreshAccessTokenResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(_) {
      return {};
    },
    toJSON(_) {
      const obj = {};
      return obj;
    },
    fromPartial(_) {
      const message = createBaseRefreshAccessTokenResponse();
      return message;
    }
  };
  function createBaseGuestCode() {
    return {
      collectionId: "",
      projectId: "",
      code: "",
      url: "",
      autoDelete: void 0
    };
  }
  exports2.GuestCode = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.code !== "") {
        writer2.uint32(26).string(message.code);
      }
      if (message.url !== "") {
        writer2.uint32(34).string(message.url);
      }
      if (message.autoDelete !== void 0) {
        timestamp_1.Timestamp.encode(toTimestamp(message.autoDelete), writer2.uint32(42).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGuestCode();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.code = reader2.string();
            break;
          case 4:
            message.url = reader2.string();
            break;
          case 5:
            message.autoDelete = fromTimestamp(timestamp_1.Timestamp.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        code: isSet2(object.code) ? String(object.code) : "",
        url: isSet2(object.url) ? String(object.url) : "",
        autoDelete: isSet2(object.autoDelete) ? String(object.autoDelete) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.code !== void 0 && (obj.code = message.code);
      message.url !== void 0 && (obj.url = message.url);
      message.autoDelete !== void 0 && (obj.autoDelete = message.autoDelete);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e;
      const message = createBaseGuestCode();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.code = (_c = object.code) !== null && _c !== void 0 ? _c : "";
      message.url = (_d = object.url) !== null && _d !== void 0 ? _d : "";
      message.autoDelete = (_e = object.autoDelete) !== null && _e !== void 0 ? _e : void 0;
      return message;
    }
  };
  function createBaseGuestCodeRedirectRequest() {
    return { serviceId: "", code: "" };
  }
  exports2.GuestCodeRedirectRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.serviceId !== "") {
        writer2.uint32(10).string(message.serviceId);
      }
      if (message.code !== "") {
        writer2.uint32(18).string(message.code);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGuestCodeRedirectRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.serviceId = reader2.string();
            break;
          case 2:
            message.code = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        serviceId: isSet2(object.serviceId) ? String(object.serviceId) : "",
        code: isSet2(object.code) ? String(object.code) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.serviceId !== void 0 && (obj.serviceId = message.serviceId);
      message.code !== void 0 && (obj.code = message.code);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseGuestCodeRedirectRequest();
      message.serviceId = (_a2 = object.serviceId) !== null && _a2 !== void 0 ? _a2 : "";
      message.code = (_b = object.code) !== null && _b !== void 0 ? _b : "";
      return message;
    }
  };
  function createBaseGuestCodeRedirectResponse() {
    return {};
  }
  exports2.GuestCodeRedirectResponse = {
    encode(_, writer2 = _m02.Writer.create()) {
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGuestCodeRedirectResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(_) {
      return {};
    },
    toJSON(_) {
      const obj = {};
      return obj;
    },
    fromPartial(_) {
      const message = createBaseGuestCodeRedirectResponse();
      return message;
    }
  };
  function createBaseJsonWebKey() {
    return { alg: "", kty: "", use: "", kid: "", e: "", n: "" };
  }
  exports2.JsonWebKey = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.alg !== "") {
        writer2.uint32(10).string(message.alg);
      }
      if (message.kty !== "") {
        writer2.uint32(18).string(message.kty);
      }
      if (message.use !== "") {
        writer2.uint32(26).string(message.use);
      }
      if (message.kid !== "") {
        writer2.uint32(34).string(message.kid);
      }
      if (message.e !== "") {
        writer2.uint32(42).string(message.e);
      }
      if (message.n !== "") {
        writer2.uint32(50).string(message.n);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseJsonWebKey();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.alg = reader2.string();
            break;
          case 2:
            message.kty = reader2.string();
            break;
          case 3:
            message.use = reader2.string();
            break;
          case 4:
            message.kid = reader2.string();
            break;
          case 5:
            message.e = reader2.string();
            break;
          case 6:
            message.n = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        alg: isSet2(object.alg) ? String(object.alg) : "",
        kty: isSet2(object.kty) ? String(object.kty) : "",
        use: isSet2(object.use) ? String(object.use) : "",
        kid: isSet2(object.kid) ? String(object.kid) : "",
        e: isSet2(object.e) ? String(object.e) : "",
        n: isSet2(object.n) ? String(object.n) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.alg !== void 0 && (obj.alg = message.alg);
      message.kty !== void 0 && (obj.kty = message.kty);
      message.use !== void 0 && (obj.use = message.use);
      message.kid !== void 0 && (obj.kid = message.kid);
      message.e !== void 0 && (obj.e = message.e);
      message.n !== void 0 && (obj.n = message.n);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e, _f;
      const message = createBaseJsonWebKey();
      message.alg = (_a2 = object.alg) !== null && _a2 !== void 0 ? _a2 : "";
      message.kty = (_b = object.kty) !== null && _b !== void 0 ? _b : "";
      message.use = (_c = object.use) !== null && _c !== void 0 ? _c : "";
      message.kid = (_d = object.kid) !== null && _d !== void 0 ? _d : "";
      message.e = (_e = object.e) !== null && _e !== void 0 ? _e : "";
      message.n = (_f = object.n) !== null && _f !== void 0 ? _f : "";
      return message;
    }
  };
  function createBaseGetJsonWebKeySetRequest() {
    return {};
  }
  exports2.GetJsonWebKeySetRequest = {
    encode(_, writer2 = _m02.Writer.create()) {
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetJsonWebKeySetRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(_) {
      return {};
    },
    toJSON(_) {
      const obj = {};
      return obj;
    },
    fromPartial(_) {
      const message = createBaseGetJsonWebKeySetRequest();
      return message;
    }
  };
  function createBaseGetJsonWebKeySetResponse() {
    return { keys: [] };
  }
  exports2.GetJsonWebKeySetResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      for (const v of message.keys) {
        exports2.JsonWebKey.encode(v, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetJsonWebKeySetResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.keys.push(exports2.JsonWebKey.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        keys: Array.isArray(object === null || object === void 0 ? void 0 : object.keys) ? object.keys.map((e2) => exports2.JsonWebKey.fromJSON(e2)) : []
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.keys) {
        obj.keys = message.keys.map((e2) => e2 ? exports2.JsonWebKey.toJSON(e2) : void 0);
      } else {
        obj.keys = [];
      }
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseGetJsonWebKeySetResponse();
      message.keys = ((_a2 = object.keys) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => exports2.JsonWebKey.fromPartial(e2))) || [];
      return message;
    }
  };
  function createBaseGetTestTokenRequest() {
    return {};
  }
  exports2.GetTestTokenRequest = {
    encode(_, writer2 = _m02.Writer.create()) {
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetTestTokenRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(_) {
      return {};
    },
    toJSON(_) {
      const obj = {};
      return obj;
    },
    fromPartial(_) {
      const message = createBaseGetTestTokenRequest();
      return message;
    }
  };
  function createBaseGetTestTokenResponse() {
    return { accessToken: "" };
  }
  exports2.GetTestTokenResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.accessToken !== "") {
        writer2.uint32(10).string(message.accessToken);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseGetTestTokenResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.accessToken = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        accessToken: isSet2(object.accessToken) ? String(object.accessToken) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.accessToken !== void 0 && (obj.accessToken = message.accessToken);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseGetTestTokenResponse();
      message.accessToken = (_a2 = object.accessToken) !== null && _a2 !== void 0 ? _a2 : "";
      return message;
    }
  };
  function createBaseDestinationCreateEvent() {
    return {
      collectionId: "",
      projectId: "",
      destinationId: "",
      destination: void 0
    };
  }
  exports2.DestinationCreateEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.destinationId !== "") {
        writer2.uint32(26).string(message.destinationId);
      }
      if (message.destination !== void 0) {
        exports2.Destination.encode(message.destination, writer2.uint32(34).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDestinationCreateEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.destinationId = reader2.string();
            break;
          case 4:
            message.destination = exports2.Destination.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        destinationId: isSet2(object.destinationId) ? String(object.destinationId) : "",
        destination: isSet2(object.destination) ? exports2.Destination.fromJSON(object.destination) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.destinationId !== void 0 && (obj.destinationId = message.destinationId);
      message.destination !== void 0 && (obj.destination = message.destination ? exports2.Destination.toJSON(message.destination) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseDestinationCreateEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.destinationId = (_c = object.destinationId) !== null && _c !== void 0 ? _c : "";
      message.destination = object.destination !== void 0 && object.destination !== null ? exports2.Destination.fromPartial(object.destination) : void 0;
      return message;
    }
  };
  function createBaseDestinationDeleteEvent() {
    return { collectionId: "", projectId: "", destinationId: "" };
  }
  exports2.DestinationDeleteEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.destinationId !== "") {
        writer2.uint32(26).string(message.destinationId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDestinationDeleteEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.destinationId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        destinationId: isSet2(object.destinationId) ? String(object.destinationId) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.destinationId !== void 0 && (obj.destinationId = message.destinationId);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseDestinationDeleteEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.destinationId = (_c = object.destinationId) !== null && _c !== void 0 ? _c : "";
      return message;
    }
  };
  function createBaseDestinationUpdateEvent() {
    return {
      collectionId: "",
      projectId: "",
      destinationId: "",
      updateMask: [],
      destination: void 0
    };
  }
  exports2.DestinationUpdateEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.destinationId !== "") {
        writer2.uint32(26).string(message.destinationId);
      }
      for (const v of message.updateMask) {
        writer2.uint32(34).string(v);
      }
      if (message.destination !== void 0) {
        exports2.Destination.encode(message.destination, writer2.uint32(42).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDestinationUpdateEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.destinationId = reader2.string();
            break;
          case 4:
            message.updateMask.push(reader2.string());
            break;
          case 5:
            message.destination = exports2.Destination.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        destinationId: isSet2(object.destinationId) ? String(object.destinationId) : "",
        updateMask: Array.isArray(object === null || object === void 0 ? void 0 : object.updateMask) ? object.updateMask.map((e2) => String(e2)) : [],
        destination: isSet2(object.destination) ? exports2.Destination.fromJSON(object.destination) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.destinationId !== void 0 && (obj.destinationId = message.destinationId);
      if (message.updateMask) {
        obj.updateMask = message.updateMask.map((e2) => e2);
      } else {
        obj.updateMask = [];
      }
      message.destination !== void 0 && (obj.destination = message.destination ? exports2.Destination.toJSON(message.destination) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d;
      const message = createBaseDestinationUpdateEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.destinationId = (_c = object.destinationId) !== null && _c !== void 0 ? _c : "";
      message.updateMask = ((_d = object.updateMask) === null || _d === void 0 ? void 0 : _d.map((e2) => e2)) || [];
      message.destination = object.destination !== void 0 && object.destination !== null ? exports2.Destination.fromPartial(object.destination) : void 0;
      return message;
    }
  };
  function createBaseDestinationStateEvent() {
    return {
      collectionId: "",
      projectId: "",
      destinationId: "",
      connect: void 0
    };
  }
  exports2.DestinationStateEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.destinationId !== "") {
        writer2.uint32(26).string(message.destinationId);
      }
      if (message.connect !== void 0) {
        writer2.uint32(32).int32(connectStateToNumber(message.connect));
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDestinationStateEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.destinationId = reader2.string();
            break;
          case 4:
            message.connect = connectStateFromJSON(reader2.int32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        destinationId: isSet2(object.destinationId) ? String(object.destinationId) : "",
        connect: isSet2(object.connect) ? connectStateFromJSON(object.connect) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.destinationId !== void 0 && (obj.destinationId = message.destinationId);
      message.connect !== void 0 && (obj.connect = message.connect !== void 0 ? connectStateToJSON(message.connect) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d;
      const message = createBaseDestinationStateEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.destinationId = (_c = object.destinationId) !== null && _c !== void 0 ? _c : "";
      message.connect = (_d = object.connect) !== null && _d !== void 0 ? _d : void 0;
      return message;
    }
  };
  function createBaseProjectCreateEvent() {
    return { collectionId: "", projectId: "", project: void 0 };
  }
  exports2.ProjectCreateEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.project !== void 0) {
        exports2.Project.encode(message.project, writer2.uint32(26).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseProjectCreateEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.project = exports2.Project.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        project: isSet2(object.project) ? exports2.Project.fromJSON(object.project) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.project !== void 0 && (obj.project = message.project ? exports2.Project.toJSON(message.project) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseProjectCreateEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.project = object.project !== void 0 && object.project !== null ? exports2.Project.fromPartial(object.project) : void 0;
      return message;
    }
  };
  function createBaseProjectDeleteEvent() {
    return { collectionId: "", projectId: "" };
  }
  exports2.ProjectDeleteEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseProjectDeleteEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseProjectDeleteEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      return message;
    }
  };
  function createBaseProjectUpdateEvent() {
    return {
      collectionId: "",
      projectId: "",
      updateMask: [],
      project: void 0
    };
  }
  exports2.ProjectUpdateEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      for (const v of message.updateMask) {
        writer2.uint32(26).string(v);
      }
      if (message.project !== void 0) {
        exports2.Project.encode(message.project, writer2.uint32(34).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseProjectUpdateEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.updateMask.push(reader2.string());
            break;
          case 4:
            message.project = exports2.Project.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        updateMask: Array.isArray(object === null || object === void 0 ? void 0 : object.updateMask) ? object.updateMask.map((e2) => String(e2)) : [],
        project: isSet2(object.project) ? exports2.Project.fromJSON(object.project) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      if (message.updateMask) {
        obj.updateMask = message.updateMask.map((e2) => e2);
      } else {
        obj.updateMask = [];
      }
      message.project !== void 0 && (obj.project = message.project ? exports2.Project.toJSON(message.project) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseProjectUpdateEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.updateMask = ((_c = object.updateMask) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
      message.project = object.project !== void 0 && object.project !== null ? exports2.Project.fromPartial(object.project) : void 0;
      return message;
    }
  };
  function createBaseProjectBroadcastStateEvent() {
    return {
      collectionId: "",
      projectId: "",
      broadcastId: "",
      phase: void 0,
      error: void 0
    };
  }
  exports2.ProjectBroadcastStateEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.broadcastId !== "") {
        writer2.uint32(26).string(message.broadcastId);
      }
      if (message.phase !== void 0) {
        writer2.uint32(32).int32(projectBroadcastPhaseToNumber(message.phase));
      }
      if (message.error !== void 0) {
        writer2.uint32(40).int32(projectBroadcastErrorToNumber(message.error));
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseProjectBroadcastStateEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.broadcastId = reader2.string();
            break;
          case 4:
            message.phase = projectBroadcastPhaseFromJSON(reader2.int32());
            break;
          case 5:
            message.error = projectBroadcastErrorFromJSON(reader2.int32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        broadcastId: isSet2(object.broadcastId) ? String(object.broadcastId) : "",
        phase: isSet2(object.phase) ? projectBroadcastPhaseFromJSON(object.phase) : void 0,
        error: isSet2(object.error) ? projectBroadcastErrorFromJSON(object.error) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.broadcastId !== void 0 && (obj.broadcastId = message.broadcastId);
      message.phase !== void 0 && (obj.phase = message.phase !== void 0 ? projectBroadcastPhaseToJSON(message.phase) : void 0);
      message.error !== void 0 && (obj.error = message.error !== void 0 ? projectBroadcastErrorToJSON(message.error) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e;
      const message = createBaseProjectBroadcastStateEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.broadcastId = (_c = object.broadcastId) !== null && _c !== void 0 ? _c : "";
      message.phase = (_d = object.phase) !== null && _d !== void 0 ? _d : void 0;
      message.error = (_e = object.error) !== null && _e !== void 0 ? _e : void 0;
      return message;
    }
  };
  function createBaseCollectionCreateEvent() {
    return { collectionId: "", collection: void 0 };
  }
  exports2.CollectionCreateEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.collection !== void 0) {
        exports2.Collection.encode(message.collection, writer2.uint32(18).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCollectionCreateEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.collection = exports2.Collection.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        collection: isSet2(object.collection) ? exports2.Collection.fromJSON(object.collection) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.collection !== void 0 && (obj.collection = message.collection ? exports2.Collection.toJSON(message.collection) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseCollectionCreateEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.collection = object.collection !== void 0 && object.collection !== null ? exports2.Collection.fromPartial(object.collection) : void 0;
      return message;
    }
  };
  function createBaseCollectionDeleteEvent() {
    return { collectionId: "" };
  }
  exports2.CollectionDeleteEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCollectionDeleteEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseCollectionDeleteEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      return message;
    }
  };
  function createBaseCollectionUpdateEvent() {
    return { collectionId: "", updateMask: [], collection: void 0 };
  }
  exports2.CollectionUpdateEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      for (const v of message.updateMask) {
        writer2.uint32(18).string(v);
      }
      if (message.collection !== void 0) {
        exports2.Collection.encode(message.collection, writer2.uint32(26).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCollectionUpdateEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.updateMask.push(reader2.string());
            break;
          case 3:
            message.collection = exports2.Collection.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        updateMask: Array.isArray(object === null || object === void 0 ? void 0 : object.updateMask) ? object.updateMask.map((e2) => String(e2)) : [],
        collection: isSet2(object.collection) ? exports2.Collection.fromJSON(object.collection) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      if (message.updateMask) {
        obj.updateMask = message.updateMask.map((e2) => e2);
      } else {
        obj.updateMask = [];
      }
      message.collection !== void 0 && (obj.collection = message.collection ? exports2.Collection.toJSON(message.collection) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseCollectionUpdateEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.updateMask = ((_b = object.updateMask) === null || _b === void 0 ? void 0 : _b.map((e2) => e2)) || [];
      message.collection = object.collection !== void 0 && object.collection !== null ? exports2.Collection.fromPartial(object.collection) : void 0;
      return message;
    }
  };
  function createBaseSourceCreateEvent() {
    return { collectionId: "", sourceId: "", source: void 0 };
  }
  exports2.SourceCreateEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.sourceId !== "") {
        writer2.uint32(18).string(message.sourceId);
      }
      if (message.source !== void 0) {
        exports2.Source.encode(message.source, writer2.uint32(26).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseSourceCreateEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.sourceId = reader2.string();
            break;
          case 3:
            message.source = exports2.Source.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "",
        source: isSet2(object.source) ? exports2.Source.fromJSON(object.source) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
      message.source !== void 0 && (obj.source = message.source ? exports2.Source.toJSON(message.source) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseSourceCreateEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
      message.source = object.source !== void 0 && object.source !== null ? exports2.Source.fromPartial(object.source) : void 0;
      return message;
    }
  };
  function createBaseSourceDeleteEvent() {
    return { collectionId: "", sourceId: "" };
  }
  exports2.SourceDeleteEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.sourceId !== "") {
        writer2.uint32(18).string(message.sourceId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseSourceDeleteEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.sourceId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        sourceId: isSet2(object.sourceId) ? String(object.sourceId) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseSourceDeleteEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
      return message;
    }
  };
  function createBaseSourceUpdateEvent() {
    return { collectionId: "", sourceId: "", updateMask: [], source: void 0 };
  }
  exports2.SourceUpdateEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.sourceId !== "") {
        writer2.uint32(18).string(message.sourceId);
      }
      for (const v of message.updateMask) {
        writer2.uint32(26).string(v);
      }
      if (message.source !== void 0) {
        exports2.Source.encode(message.source, writer2.uint32(34).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseSourceUpdateEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.sourceId = reader2.string();
            break;
          case 3:
            message.updateMask.push(reader2.string());
            break;
          case 4:
            message.source = exports2.Source.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "",
        updateMask: Array.isArray(object === null || object === void 0 ? void 0 : object.updateMask) ? object.updateMask.map((e2) => String(e2)) : [],
        source: isSet2(object.source) ? exports2.Source.fromJSON(object.source) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
      if (message.updateMask) {
        obj.updateMask = message.updateMask.map((e2) => e2);
      } else {
        obj.updateMask = [];
      }
      message.source !== void 0 && (obj.source = message.source ? exports2.Source.toJSON(message.source) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseSourceUpdateEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
      message.updateMask = ((_c = object.updateMask) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
      message.source = object.source !== void 0 && object.source !== null ? exports2.Source.fromPartial(object.source) : void 0;
      return message;
    }
  };
  function createBaseSourceAddEvent() {
    return { collectionId: "", sourceId: "", projectId: "", source: void 0 };
  }
  exports2.SourceAddEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.sourceId !== "") {
        writer2.uint32(18).string(message.sourceId);
      }
      if (message.projectId !== "") {
        writer2.uint32(26).string(message.projectId);
      }
      if (message.source !== void 0) {
        exports2.Source.encode(message.source, writer2.uint32(34).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseSourceAddEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.sourceId = reader2.string();
            break;
          case 3:
            message.projectId = reader2.string();
            break;
          case 4:
            message.source = exports2.Source.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        source: isSet2(object.source) ? exports2.Source.fromJSON(object.source) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.source !== void 0 && (obj.source = message.source ? exports2.Source.toJSON(message.source) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseSourceAddEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
      message.projectId = (_c = object.projectId) !== null && _c !== void 0 ? _c : "";
      message.source = object.source !== void 0 && object.source !== null ? exports2.Source.fromPartial(object.source) : void 0;
      return message;
    }
  };
  function createBaseSourceRemoveEvent() {
    return { collectionId: "", sourceId: "", projectId: "" };
  }
  exports2.SourceRemoveEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.sourceId !== "") {
        writer2.uint32(18).string(message.sourceId);
      }
      if (message.projectId !== "") {
        writer2.uint32(26).string(message.projectId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseSourceRemoveEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.sourceId = reader2.string();
            break;
          case 3:
            message.projectId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseSourceRemoveEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.sourceId = (_b = object.sourceId) !== null && _b !== void 0 ? _b : "";
      message.projectId = (_c = object.projectId) !== null && _c !== void 0 ? _c : "";
      return message;
    }
  };
  function createBaseSourceStateEvent() {
    return { collectionId: "", projectId: "", sourceId: "", connect: void 0 };
  }
  exports2.SourceStateEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== "") {
        writer2.uint32(10).string(message.collectionId);
      }
      if (message.projectId !== "") {
        writer2.uint32(18).string(message.projectId);
      }
      if (message.sourceId !== "") {
        writer2.uint32(26).string(message.sourceId);
      }
      if (message.connect !== void 0) {
        writer2.uint32(32).int32(connectStateToNumber(message.connect));
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseSourceStateEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collectionId = reader2.string();
            break;
          case 2:
            message.projectId = reader2.string();
            break;
          case 3:
            message.sourceId = reader2.string();
            break;
          case 4:
            message.connect = connectStateFromJSON(reader2.int32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : "",
        projectId: isSet2(object.projectId) ? String(object.projectId) : "",
        sourceId: isSet2(object.sourceId) ? String(object.sourceId) : "",
        connect: isSet2(object.connect) ? connectStateFromJSON(object.connect) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.sourceId !== void 0 && (obj.sourceId = message.sourceId);
      message.connect !== void 0 && (obj.connect = message.connect !== void 0 ? connectStateToJSON(message.connect) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d;
      const message = createBaseSourceStateEvent();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : "";
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : "";
      message.sourceId = (_c = object.sourceId) !== null && _c !== void 0 ? _c : "";
      message.connect = (_d = object.connect) !== null && _d !== void 0 ? _d : void 0;
      return message;
    }
  };
  function createBaseCollectionEvent() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  exports2.CollectionEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.create !== void 0) {
        exports2.CollectionCreateEvent.encode(message.create, writer2.uint32(10).fork()).ldelim();
      }
      if (message.update !== void 0) {
        exports2.CollectionUpdateEvent.encode(message.update, writer2.uint32(18).fork()).ldelim();
      }
      if (message.delete !== void 0) {
        exports2.CollectionDeleteEvent.encode(message.delete, writer2.uint32(26).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseCollectionEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.create = exports2.CollectionCreateEvent.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.update = exports2.CollectionUpdateEvent.decode(reader2, reader2.uint32());
            break;
          case 3:
            message.delete = exports2.CollectionDeleteEvent.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        create: isSet2(object.create) ? exports2.CollectionCreateEvent.fromJSON(object.create) : void 0,
        update: isSet2(object.update) ? exports2.CollectionUpdateEvent.fromJSON(object.update) : void 0,
        delete: isSet2(object.delete) ? exports2.CollectionDeleteEvent.fromJSON(object.delete) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.create !== void 0 && (obj.create = message.create ? exports2.CollectionCreateEvent.toJSON(message.create) : void 0);
      message.update !== void 0 && (obj.update = message.update ? exports2.CollectionUpdateEvent.toJSON(message.update) : void 0);
      message.delete !== void 0 && (obj.delete = message.delete ? exports2.CollectionDeleteEvent.toJSON(message.delete) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseCollectionEvent();
      message.create = object.create !== void 0 && object.create !== null ? exports2.CollectionCreateEvent.fromPartial(object.create) : void 0;
      message.update = object.update !== void 0 && object.update !== null ? exports2.CollectionUpdateEvent.fromPartial(object.update) : void 0;
      message.delete = object.delete !== void 0 && object.delete !== null ? exports2.CollectionDeleteEvent.fromPartial(object.delete) : void 0;
      return message;
    }
  };
  function createBaseDestinationEvent() {
    return {
      create: void 0,
      update: void 0,
      delete: void 0,
      state: void 0
    };
  }
  exports2.DestinationEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.create !== void 0) {
        exports2.DestinationCreateEvent.encode(message.create, writer2.uint32(10).fork()).ldelim();
      }
      if (message.update !== void 0) {
        exports2.DestinationUpdateEvent.encode(message.update, writer2.uint32(18).fork()).ldelim();
      }
      if (message.delete !== void 0) {
        exports2.DestinationDeleteEvent.encode(message.delete, writer2.uint32(26).fork()).ldelim();
      }
      if (message.state !== void 0) {
        exports2.DestinationStateEvent.encode(message.state, writer2.uint32(34).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseDestinationEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.create = exports2.DestinationCreateEvent.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.update = exports2.DestinationUpdateEvent.decode(reader2, reader2.uint32());
            break;
          case 3:
            message.delete = exports2.DestinationDeleteEvent.decode(reader2, reader2.uint32());
            break;
          case 4:
            message.state = exports2.DestinationStateEvent.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        create: isSet2(object.create) ? exports2.DestinationCreateEvent.fromJSON(object.create) : void 0,
        update: isSet2(object.update) ? exports2.DestinationUpdateEvent.fromJSON(object.update) : void 0,
        delete: isSet2(object.delete) ? exports2.DestinationDeleteEvent.fromJSON(object.delete) : void 0,
        state: isSet2(object.state) ? exports2.DestinationStateEvent.fromJSON(object.state) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.create !== void 0 && (obj.create = message.create ? exports2.DestinationCreateEvent.toJSON(message.create) : void 0);
      message.update !== void 0 && (obj.update = message.update ? exports2.DestinationUpdateEvent.toJSON(message.update) : void 0);
      message.delete !== void 0 && (obj.delete = message.delete ? exports2.DestinationDeleteEvent.toJSON(message.delete) : void 0);
      message.state !== void 0 && (obj.state = message.state ? exports2.DestinationStateEvent.toJSON(message.state) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseDestinationEvent();
      message.create = object.create !== void 0 && object.create !== null ? exports2.DestinationCreateEvent.fromPartial(object.create) : void 0;
      message.update = object.update !== void 0 && object.update !== null ? exports2.DestinationUpdateEvent.fromPartial(object.update) : void 0;
      message.delete = object.delete !== void 0 && object.delete !== null ? exports2.DestinationDeleteEvent.fromPartial(object.delete) : void 0;
      message.state = object.state !== void 0 && object.state !== null ? exports2.DestinationStateEvent.fromPartial(object.state) : void 0;
      return message;
    }
  };
  function createBaseProjectEvent() {
    return {
      create: void 0,
      update: void 0,
      delete: void 0,
      state: void 0
    };
  }
  exports2.ProjectEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.create !== void 0) {
        exports2.ProjectCreateEvent.encode(message.create, writer2.uint32(10).fork()).ldelim();
      }
      if (message.update !== void 0) {
        exports2.ProjectUpdateEvent.encode(message.update, writer2.uint32(18).fork()).ldelim();
      }
      if (message.delete !== void 0) {
        exports2.ProjectDeleteEvent.encode(message.delete, writer2.uint32(26).fork()).ldelim();
      }
      if (message.state !== void 0) {
        exports2.ProjectBroadcastStateEvent.encode(message.state, writer2.uint32(34).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseProjectEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.create = exports2.ProjectCreateEvent.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.update = exports2.ProjectUpdateEvent.decode(reader2, reader2.uint32());
            break;
          case 3:
            message.delete = exports2.ProjectDeleteEvent.decode(reader2, reader2.uint32());
            break;
          case 4:
            message.state = exports2.ProjectBroadcastStateEvent.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        create: isSet2(object.create) ? exports2.ProjectCreateEvent.fromJSON(object.create) : void 0,
        update: isSet2(object.update) ? exports2.ProjectUpdateEvent.fromJSON(object.update) : void 0,
        delete: isSet2(object.delete) ? exports2.ProjectDeleteEvent.fromJSON(object.delete) : void 0,
        state: isSet2(object.state) ? exports2.ProjectBroadcastStateEvent.fromJSON(object.state) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.create !== void 0 && (obj.create = message.create ? exports2.ProjectCreateEvent.toJSON(message.create) : void 0);
      message.update !== void 0 && (obj.update = message.update ? exports2.ProjectUpdateEvent.toJSON(message.update) : void 0);
      message.delete !== void 0 && (obj.delete = message.delete ? exports2.ProjectDeleteEvent.toJSON(message.delete) : void 0);
      message.state !== void 0 && (obj.state = message.state ? exports2.ProjectBroadcastStateEvent.toJSON(message.state) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseProjectEvent();
      message.create = object.create !== void 0 && object.create !== null ? exports2.ProjectCreateEvent.fromPartial(object.create) : void 0;
      message.update = object.update !== void 0 && object.update !== null ? exports2.ProjectUpdateEvent.fromPartial(object.update) : void 0;
      message.delete = object.delete !== void 0 && object.delete !== null ? exports2.ProjectDeleteEvent.fromPartial(object.delete) : void 0;
      message.state = object.state !== void 0 && object.state !== null ? exports2.ProjectBroadcastStateEvent.fromPartial(object.state) : void 0;
      return message;
    }
  };
  function createBaseSourceEvent() {
    return {
      create: void 0,
      update: void 0,
      delete: void 0,
      add: void 0,
      remove: void 0,
      state: void 0
    };
  }
  exports2.SourceEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.create !== void 0) {
        exports2.SourceCreateEvent.encode(message.create, writer2.uint32(10).fork()).ldelim();
      }
      if (message.update !== void 0) {
        exports2.SourceUpdateEvent.encode(message.update, writer2.uint32(18).fork()).ldelim();
      }
      if (message.delete !== void 0) {
        exports2.SourceDeleteEvent.encode(message.delete, writer2.uint32(26).fork()).ldelim();
      }
      if (message.add !== void 0) {
        exports2.SourceAddEvent.encode(message.add, writer2.uint32(34).fork()).ldelim();
      }
      if (message.remove !== void 0) {
        exports2.SourceDeleteEvent.encode(message.remove, writer2.uint32(42).fork()).ldelim();
      }
      if (message.state !== void 0) {
        exports2.SourceStateEvent.encode(message.state, writer2.uint32(50).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseSourceEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.create = exports2.SourceCreateEvent.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.update = exports2.SourceUpdateEvent.decode(reader2, reader2.uint32());
            break;
          case 3:
            message.delete = exports2.SourceDeleteEvent.decode(reader2, reader2.uint32());
            break;
          case 4:
            message.add = exports2.SourceAddEvent.decode(reader2, reader2.uint32());
            break;
          case 5:
            message.remove = exports2.SourceDeleteEvent.decode(reader2, reader2.uint32());
            break;
          case 6:
            message.state = exports2.SourceStateEvent.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        create: isSet2(object.create) ? exports2.SourceCreateEvent.fromJSON(object.create) : void 0,
        update: isSet2(object.update) ? exports2.SourceUpdateEvent.fromJSON(object.update) : void 0,
        delete: isSet2(object.delete) ? exports2.SourceDeleteEvent.fromJSON(object.delete) : void 0,
        add: isSet2(object.add) ? exports2.SourceAddEvent.fromJSON(object.add) : void 0,
        remove: isSet2(object.remove) ? exports2.SourceDeleteEvent.fromJSON(object.remove) : void 0,
        state: isSet2(object.state) ? exports2.SourceStateEvent.fromJSON(object.state) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.create !== void 0 && (obj.create = message.create ? exports2.SourceCreateEvent.toJSON(message.create) : void 0);
      message.update !== void 0 && (obj.update = message.update ? exports2.SourceUpdateEvent.toJSON(message.update) : void 0);
      message.delete !== void 0 && (obj.delete = message.delete ? exports2.SourceDeleteEvent.toJSON(message.delete) : void 0);
      message.add !== void 0 && (obj.add = message.add ? exports2.SourceAddEvent.toJSON(message.add) : void 0);
      message.remove !== void 0 && (obj.remove = message.remove ? exports2.SourceDeleteEvent.toJSON(message.remove) : void 0);
      message.state !== void 0 && (obj.state = message.state ? exports2.SourceStateEvent.toJSON(message.state) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = createBaseSourceEvent();
      message.create = object.create !== void 0 && object.create !== null ? exports2.SourceCreateEvent.fromPartial(object.create) : void 0;
      message.update = object.update !== void 0 && object.update !== null ? exports2.SourceUpdateEvent.fromPartial(object.update) : void 0;
      message.delete = object.delete !== void 0 && object.delete !== null ? exports2.SourceDeleteEvent.fromPartial(object.delete) : void 0;
      message.add = object.add !== void 0 && object.add !== null ? exports2.SourceAddEvent.fromPartial(object.add) : void 0;
      message.remove = object.remove !== void 0 && object.remove !== null ? exports2.SourceDeleteEvent.fromPartial(object.remove) : void 0;
      message.state = object.state !== void 0 && object.state !== null ? exports2.SourceStateEvent.fromPartial(object.state) : void 0;
      return message;
    }
  };
  function createBaseLiveEvent() {
    return {
      collection: void 0,
      destination: void 0,
      project: void 0,
      source: void 0,
      unspecified: void 0
    };
  }
  exports2.LiveEvent = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collection !== void 0) {
        exports2.CollectionEvent.encode(message.collection, writer2.uint32(10).fork()).ldelim();
      }
      if (message.destination !== void 0) {
        exports2.DestinationEvent.encode(message.destination, writer2.uint32(18).fork()).ldelim();
      }
      if (message.project !== void 0) {
        exports2.ProjectEvent.encode(message.project, writer2.uint32(26).fork()).ldelim();
      }
      if (message.source !== void 0) {
        exports2.SourceEvent.encode(message.source, writer2.uint32(34).fork()).ldelim();
      }
      if (message.unspecified !== void 0) {
        writer2.uint32(40).int32((0, struct_1.nullValueToNumber)(message.unspecified));
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseLiveEvent();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.collection = exports2.CollectionEvent.decode(reader2, reader2.uint32());
            break;
          case 2:
            message.destination = exports2.DestinationEvent.decode(reader2, reader2.uint32());
            break;
          case 3:
            message.project = exports2.ProjectEvent.decode(reader2, reader2.uint32());
            break;
          case 4:
            message.source = exports2.SourceEvent.decode(reader2, reader2.uint32());
            break;
          case 5:
            message.unspecified = (0, struct_1.nullValueFromJSON)(reader2.int32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collection: isSet2(object.collection) ? exports2.CollectionEvent.fromJSON(object.collection) : void 0,
        destination: isSet2(object.destination) ? exports2.DestinationEvent.fromJSON(object.destination) : void 0,
        project: isSet2(object.project) ? exports2.ProjectEvent.fromJSON(object.project) : void 0,
        source: isSet2(object.source) ? exports2.SourceEvent.fromJSON(object.source) : void 0,
        unspecified: isSet2(object.unspecified) ? (0, struct_1.nullValueFromJSON)(object.unspecified) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collection !== void 0 && (obj.collection = message.collection ? exports2.CollectionEvent.toJSON(message.collection) : void 0);
      message.destination !== void 0 && (obj.destination = message.destination ? exports2.DestinationEvent.toJSON(message.destination) : void 0);
      message.project !== void 0 && (obj.project = message.project ? exports2.ProjectEvent.toJSON(message.project) : void 0);
      message.source !== void 0 && (obj.source = message.source ? exports2.SourceEvent.toJSON(message.source) : void 0);
      message.unspecified !== void 0 && (obj.unspecified = message.unspecified !== void 0 ? (0, struct_1.nullValueToJSON)(message.unspecified) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseLiveEvent();
      message.collection = object.collection !== void 0 && object.collection !== null ? exports2.CollectionEvent.fromPartial(object.collection) : void 0;
      message.destination = object.destination !== void 0 && object.destination !== null ? exports2.DestinationEvent.fromPartial(object.destination) : void 0;
      message.project = object.project !== void 0 && object.project !== null ? exports2.ProjectEvent.fromPartial(object.project) : void 0;
      message.source = object.source !== void 0 && object.source !== null ? exports2.SourceEvent.fromPartial(object.source) : void 0;
      message.unspecified = (_a2 = object.unspecified) !== null && _a2 !== void 0 ? _a2 : void 0;
      return message;
    }
  };
  class CollectionServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.CreateCollection = this.CreateCollection.bind(this);
      this.GetCollection = this.GetCollection.bind(this);
      this.GetCollections = this.GetCollections.bind(this);
      this.UpdateCollection = this.UpdateCollection.bind(this);
      this.DeleteCollection = this.DeleteCollection.bind(this);
    }
    CreateCollection(request3) {
      const data2 = exports2.CreateCollectionRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.CollectionService", "CreateCollection", data2);
      return promise.then((data3) => exports2.CreateCollectionResponse.decode(new _m02.Reader(data3)));
    }
    GetCollection(request3) {
      const data2 = exports2.GetCollectionRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.CollectionService", "GetCollection", data2);
      return promise.then((data3) => exports2.GetCollectionResponse.decode(new _m02.Reader(data3)));
    }
    GetCollections(request3) {
      const data2 = exports2.GetCollectionsRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.CollectionService", "GetCollections", data2);
      return promise.then((data3) => exports2.GetCollectionsResponse.decode(new _m02.Reader(data3)));
    }
    UpdateCollection(request3) {
      const data2 = exports2.UpdateCollectionRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.CollectionService", "UpdateCollection", data2);
      return promise.then((data3) => exports2.UpdateCollectionResponse.decode(new _m02.Reader(data3)));
    }
    DeleteCollection(request3) {
      const data2 = exports2.DeleteCollectionRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.CollectionService", "DeleteCollection", data2);
      return promise.then((data3) => exports2.DeleteCollectionResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.CollectionServiceClientImpl = CollectionServiceClientImpl;
  exports2.CollectionServiceDefinition = {
    name: "CollectionService",
    fullName: "live.v21.CollectionService",
    methods: {
      createCollection: {
        name: "CreateCollection",
        requestType: exports2.CreateCollectionRequest,
        requestStream: false,
        responseType: exports2.CreateCollectionResponse,
        responseStream: false,
        options: {}
      },
      getCollection: {
        name: "GetCollection",
        requestType: exports2.GetCollectionRequest,
        requestStream: false,
        responseType: exports2.GetCollectionResponse,
        responseStream: false,
        options: {}
      },
      getCollections: {
        name: "GetCollections",
        requestType: exports2.GetCollectionsRequest,
        requestStream: false,
        responseType: exports2.GetCollectionsResponse,
        responseStream: false,
        options: {}
      },
      updateCollection: {
        name: "UpdateCollection",
        requestType: exports2.UpdateCollectionRequest,
        requestStream: false,
        responseType: exports2.UpdateCollectionResponse,
        responseStream: false,
        options: {}
      },
      deleteCollection: {
        name: "DeleteCollection",
        requestType: exports2.DeleteCollectionRequest,
        requestStream: false,
        responseType: exports2.DeleteCollectionResponse,
        responseStream: false,
        options: {}
      }
    }
  };
  class ProjectServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.CreateProject = this.CreateProject.bind(this);
      this.GetProject = this.GetProject.bind(this);
      this.DeleteProject = this.DeleteProject.bind(this);
      this.UpdateProject = this.UpdateProject.bind(this);
      this.StartProjectBroadcast = this.StartProjectBroadcast.bind(this);
      this.StopProjectBroadcast = this.StopProjectBroadcast.bind(this);
      this.StartProjectWebRtc = this.StartProjectWebRtc.bind(this);
      this.StopProjectWebRtc = this.StopProjectWebRtc.bind(this);
      this.GetProjectBroadcastSnapshot = this.GetProjectBroadcastSnapshot.bind(this);
      this.GetProjectBroadcastStatus = this.GetProjectBroadcastStatus.bind(this);
    }
    CreateProject(request3) {
      const data2 = exports2.CreateProjectRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "CreateProject", data2);
      return promise.then((data3) => exports2.CreateProjectResponse.decode(new _m02.Reader(data3)));
    }
    GetProject(request3) {
      const data2 = exports2.GetProjectRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "GetProject", data2);
      return promise.then((data3) => exports2.GetProjectResponse.decode(new _m02.Reader(data3)));
    }
    DeleteProject(request3) {
      const data2 = exports2.DeleteProjectRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "DeleteProject", data2);
      return promise.then((data3) => exports2.DeleteProjectResponse.decode(new _m02.Reader(data3)));
    }
    UpdateProject(request3) {
      const data2 = exports2.UpdateProjectRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "UpdateProject", data2);
      return promise.then((data3) => exports2.UpdateProjectResponse.decode(new _m02.Reader(data3)));
    }
    StartProjectBroadcast(request3) {
      const data2 = exports2.StartProjectBroadcastRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "StartProjectBroadcast", data2);
      return promise.then((data3) => exports2.StartProjectBroadcastResponse.decode(new _m02.Reader(data3)));
    }
    StopProjectBroadcast(request3) {
      const data2 = exports2.StopProjectBroadcastRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "StopProjectBroadcast", data2);
      return promise.then((data3) => exports2.StopProjectBroadcastResponse.decode(new _m02.Reader(data3)));
    }
    StartProjectWebRtc(request3) {
      const data2 = exports2.StartProjectWebRtcRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "StartProjectWebRtc", data2);
      return promise.then((data3) => exports2.StartProjectWebRtcResponse.decode(new _m02.Reader(data3)));
    }
    StopProjectWebRtc(request3) {
      const data2 = exports2.StopProjectWebRtcRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "StopProjectWebRtc", data2);
      return promise.then((data3) => exports2.StopProjectWebRtcResponse.decode(new _m02.Reader(data3)));
    }
    GetProjectBroadcastSnapshot(request3) {
      const data2 = exports2.GetProjectBroadcastSnapshotRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "GetProjectBroadcastSnapshot", data2);
      return promise.then((data3) => exports2.GetProjectBroadcastSnapshotResponse.decode(new _m02.Reader(data3)));
    }
    GetProjectBroadcastStatus(request3) {
      const data2 = exports2.GetProjectBroadcastStatusRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.ProjectService", "GetProjectBroadcastStatus", data2);
      return promise.then((data3) => exports2.GetProjectBroadcastStatusResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.ProjectServiceClientImpl = ProjectServiceClientImpl;
  exports2.ProjectServiceDefinition = {
    name: "ProjectService",
    fullName: "live.v21.ProjectService",
    methods: {
      createProject: {
        name: "CreateProject",
        requestType: exports2.CreateProjectRequest,
        requestStream: false,
        responseType: exports2.CreateProjectResponse,
        responseStream: false,
        options: {}
      },
      getProject: {
        name: "GetProject",
        requestType: exports2.GetProjectRequest,
        requestStream: false,
        responseType: exports2.GetProjectResponse,
        responseStream: false,
        options: {}
      },
      deleteProject: {
        name: "DeleteProject",
        requestType: exports2.DeleteProjectRequest,
        requestStream: false,
        responseType: exports2.DeleteProjectResponse,
        responseStream: false,
        options: {}
      },
      updateProject: {
        name: "UpdateProject",
        requestType: exports2.UpdateProjectRequest,
        requestStream: false,
        responseType: exports2.UpdateProjectResponse,
        responseStream: false,
        options: {}
      },
      startProjectBroadcast: {
        name: "StartProjectBroadcast",
        requestType: exports2.StartProjectBroadcastRequest,
        requestStream: false,
        responseType: exports2.StartProjectBroadcastResponse,
        responseStream: false,
        options: {}
      },
      stopProjectBroadcast: {
        name: "StopProjectBroadcast",
        requestType: exports2.StopProjectBroadcastRequest,
        requestStream: false,
        responseType: exports2.StopProjectBroadcastResponse,
        responseStream: false,
        options: {}
      },
      startProjectWebRtc: {
        name: "StartProjectWebRtc",
        requestType: exports2.StartProjectWebRtcRequest,
        requestStream: false,
        responseType: exports2.StartProjectWebRtcResponse,
        responseStream: false,
        options: {}
      },
      stopProjectWebRtc: {
        name: "StopProjectWebRtc",
        requestType: exports2.StopProjectWebRtcRequest,
        requestStream: false,
        responseType: exports2.StopProjectWebRtcResponse,
        responseStream: false,
        options: {}
      },
      getProjectBroadcastSnapshot: {
        name: "GetProjectBroadcastSnapshot",
        requestType: exports2.GetProjectBroadcastSnapshotRequest,
        requestStream: false,
        responseType: exports2.GetProjectBroadcastSnapshotResponse,
        responseStream: false,
        options: {}
      },
      getProjectBroadcastStatus: {
        name: "GetProjectBroadcastStatus",
        requestType: exports2.GetProjectBroadcastStatusRequest,
        requestStream: false,
        responseType: exports2.GetProjectBroadcastStatusResponse,
        responseStream: false,
        options: {}
      }
    }
  };
  class DestinationServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.CreateDestination = this.CreateDestination.bind(this);
      this.GetDestination = this.GetDestination.bind(this);
      this.UpdateDestination = this.UpdateDestination.bind(this);
      this.DeleteDestination = this.DeleteDestination.bind(this);
    }
    CreateDestination(request3) {
      const data2 = exports2.CreateDestinationRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.DestinationService", "CreateDestination", data2);
      return promise.then((data3) => exports2.CreateDestinationResponse.decode(new _m02.Reader(data3)));
    }
    GetDestination(request3) {
      const data2 = exports2.GetDestinationRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.DestinationService", "GetDestination", data2);
      return promise.then((data3) => exports2.GetDestinationResponse.decode(new _m02.Reader(data3)));
    }
    UpdateDestination(request3) {
      const data2 = exports2.UpdateDestinationRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.DestinationService", "UpdateDestination", data2);
      return promise.then((data3) => exports2.UpdateDestinationResponse.decode(new _m02.Reader(data3)));
    }
    DeleteDestination(request3) {
      const data2 = exports2.DeleteDestinationRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.DestinationService", "DeleteDestination", data2);
      return promise.then((data3) => exports2.DeleteDestinationResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.DestinationServiceClientImpl = DestinationServiceClientImpl;
  exports2.DestinationServiceDefinition = {
    name: "DestinationService",
    fullName: "live.v21.DestinationService",
    methods: {
      createDestination: {
        name: "CreateDestination",
        requestType: exports2.CreateDestinationRequest,
        requestStream: false,
        responseType: exports2.CreateDestinationResponse,
        responseStream: false,
        options: {}
      },
      getDestination: {
        name: "GetDestination",
        requestType: exports2.GetDestinationRequest,
        requestStream: false,
        responseType: exports2.GetDestinationResponse,
        responseStream: false,
        options: {}
      },
      updateDestination: {
        name: "UpdateDestination",
        requestType: exports2.UpdateDestinationRequest,
        requestStream: false,
        responseType: exports2.UpdateDestinationResponse,
        responseStream: false,
        options: {}
      },
      deleteDestination: {
        name: "DeleteDestination",
        requestType: exports2.DeleteDestinationRequest,
        requestStream: false,
        responseType: exports2.DeleteDestinationResponse,
        responseStream: false,
        options: {}
      }
    }
  };
  class SourceServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.CreateSource = this.CreateSource.bind(this);
      this.DeleteSource = this.DeleteSource.bind(this);
      this.UpdateSource = this.UpdateSource.bind(this);
      this.UpdateSourceInProject = this.UpdateSourceInProject.bind(this);
      this.GetSource = this.GetSource.bind(this);
      this.GetSources = this.GetSources.bind(this);
      this.AddSourceToProject = this.AddSourceToProject.bind(this);
      this.RemoveSourceFromProject = this.RemoveSourceFromProject.bind(this);
    }
    CreateSource(request3) {
      const data2 = exports2.CreateSourceRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.SourceService", "CreateSource", data2);
      return promise.then((data3) => exports2.CreateSourceResponse.decode(new _m02.Reader(data3)));
    }
    DeleteSource(request3) {
      const data2 = exports2.DeleteSourceRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.SourceService", "DeleteSource", data2);
      return promise.then((data3) => exports2.DeleteSourceResponse.decode(new _m02.Reader(data3)));
    }
    UpdateSource(request3) {
      const data2 = exports2.UpdateSourceRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.SourceService", "UpdateSource", data2);
      return promise.then((data3) => exports2.UpdateSourceResponse.decode(new _m02.Reader(data3)));
    }
    UpdateSourceInProject(request3) {
      const data2 = exports2.UpdateSourceInProjectRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.SourceService", "UpdateSourceInProject", data2);
      return promise.then((data3) => exports2.UpdateSourceInProjectResponse.decode(new _m02.Reader(data3)));
    }
    GetSource(request3) {
      const data2 = exports2.GetSourceRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.SourceService", "GetSource", data2);
      return promise.then((data3) => exports2.GetSourceResponse.decode(new _m02.Reader(data3)));
    }
    GetSources(request3) {
      const data2 = exports2.GetSourcesRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.SourceService", "GetSources", data2);
      return promise.then((data3) => exports2.GetSourcesResponse.decode(new _m02.Reader(data3)));
    }
    AddSourceToProject(request3) {
      const data2 = exports2.AddSourceToProjectRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.SourceService", "AddSourceToProject", data2);
      return promise.then((data3) => exports2.AddSourceToProjectResponse.decode(new _m02.Reader(data3)));
    }
    RemoveSourceFromProject(request3) {
      const data2 = exports2.RemoveSourceFromProjectRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.SourceService", "RemoveSourceFromProject", data2);
      return promise.then((data3) => exports2.RemoveSourceFromProjectResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.SourceServiceClientImpl = SourceServiceClientImpl;
  exports2.SourceServiceDefinition = {
    name: "SourceService",
    fullName: "live.v21.SourceService",
    methods: {
      createSource: {
        name: "CreateSource",
        requestType: exports2.CreateSourceRequest,
        requestStream: false,
        responseType: exports2.CreateSourceResponse,
        responseStream: false,
        options: {}
      },
      deleteSource: {
        name: "DeleteSource",
        requestType: exports2.DeleteSourceRequest,
        requestStream: false,
        responseType: exports2.DeleteSourceResponse,
        responseStream: false,
        options: {}
      },
      updateSource: {
        name: "UpdateSource",
        requestType: exports2.UpdateSourceRequest,
        requestStream: false,
        responseType: exports2.UpdateSourceResponse,
        responseStream: false,
        options: {}
      },
      updateSourceInProject: {
        name: "UpdateSourceInProject",
        requestType: exports2.UpdateSourceInProjectRequest,
        requestStream: false,
        responseType: exports2.UpdateSourceInProjectResponse,
        responseStream: false,
        options: {}
      },
      getSource: {
        name: "GetSource",
        requestType: exports2.GetSourceRequest,
        requestStream: false,
        responseType: exports2.GetSourceResponse,
        responseStream: false,
        options: {}
      },
      getSources: {
        name: "GetSources",
        requestType: exports2.GetSourcesRequest,
        requestStream: false,
        responseType: exports2.GetSourcesResponse,
        responseStream: false,
        options: {}
      },
      addSourceToProject: {
        name: "AddSourceToProject",
        requestType: exports2.AddSourceToProjectRequest,
        requestStream: false,
        responseType: exports2.AddSourceToProjectResponse,
        responseStream: false,
        options: {}
      },
      removeSourceFromProject: {
        name: "RemoveSourceFromProject",
        requestType: exports2.RemoveSourceFromProjectRequest,
        requestStream: false,
        responseType: exports2.RemoveSourceFromProjectResponse,
        responseStream: false,
        options: {}
      }
    }
  };
  class BackendAuthenticationServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.CreateAccessToken = this.CreateAccessToken.bind(this);
    }
    CreateAccessToken(request3) {
      const data2 = exports2.CreateAccessTokenRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.BackendAuthenticationService", "CreateAccessToken", data2);
      return promise.then((data3) => exports2.CreateAccessTokenResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.BackendAuthenticationServiceClientImpl = BackendAuthenticationServiceClientImpl;
  exports2.BackendAuthenticationServiceDefinition = {
    name: "BackendAuthenticationService",
    fullName: "live.v21.BackendAuthenticationService",
    methods: {
      createAccessToken: {
        name: "CreateAccessToken",
        requestType: exports2.CreateAccessTokenRequest,
        requestStream: false,
        responseType: exports2.CreateAccessTokenResponse,
        responseStream: false,
        options: {}
      }
    }
  };
  class AuthenticationServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.CreateGuestAccessToken = this.CreateGuestAccessToken.bind(this);
      this.RefreshAccessToken = this.RefreshAccessToken.bind(this);
      this.CreateWebRtcAccessToken = this.CreateWebRtcAccessToken.bind(this);
    }
    CreateGuestAccessToken(request3) {
      const data2 = exports2.CreateGuestAccessTokenRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.AuthenticationService", "CreateGuestAccessToken", data2);
      return promise.then((data3) => exports2.CreateGuestAccessTokenResponse.decode(new _m02.Reader(data3)));
    }
    RefreshAccessToken(request3) {
      const data2 = exports2.RefreshAccessTokenRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.AuthenticationService", "RefreshAccessToken", data2);
      return promise.then((data3) => exports2.RefreshAccessTokenResponse.decode(new _m02.Reader(data3)));
    }
    CreateWebRtcAccessToken(request3) {
      const data2 = exports2.CreateWebRtcAccessTokenRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.AuthenticationService", "CreateWebRtcAccessToken", data2);
      return promise.then((data3) => exports2.CreateWebRtcAccessTokenResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.AuthenticationServiceClientImpl = AuthenticationServiceClientImpl;
  exports2.AuthenticationServiceDefinition = {
    name: "AuthenticationService",
    fullName: "live.v21.AuthenticationService",
    methods: {
      createGuestAccessToken: {
        name: "CreateGuestAccessToken",
        requestType: exports2.CreateGuestAccessTokenRequest,
        requestStream: false,
        responseType: exports2.CreateGuestAccessTokenResponse,
        responseStream: false,
        options: {}
      },
      refreshAccessToken: {
        name: "RefreshAccessToken",
        requestType: exports2.RefreshAccessTokenRequest,
        requestStream: false,
        responseType: exports2.RefreshAccessTokenResponse,
        responseStream: false,
        options: {}
      },
      createWebRtcAccessToken: {
        name: "CreateWebRtcAccessToken",
        requestType: exports2.CreateWebRtcAccessTokenRequest,
        requestStream: false,
        responseType: exports2.CreateWebRtcAccessTokenResponse,
        responseStream: false,
        options: {}
      }
    }
  };
  class PublicAuthenticationServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.GetJsonWebKeySet = this.GetJsonWebKeySet.bind(this);
      this.GuestCodeRedirect = this.GuestCodeRedirect.bind(this);
    }
    GetJsonWebKeySet(request3) {
      const data2 = exports2.GetJsonWebKeySetRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.PublicAuthenticationService", "GetJsonWebKeySet", data2);
      return promise.then((data3) => exports2.GetJsonWebKeySetResponse.decode(new _m02.Reader(data3)));
    }
    GuestCodeRedirect(request3) {
      const data2 = exports2.GuestCodeRedirectRequest.encode(request3).finish();
      const promise = this.rpc.request("live.v21.PublicAuthenticationService", "GuestCodeRedirect", data2);
      return promise.then((data3) => exports2.GuestCodeRedirectResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.PublicAuthenticationServiceClientImpl = PublicAuthenticationServiceClientImpl;
  exports2.PublicAuthenticationServiceDefinition = {
    name: "PublicAuthenticationService",
    fullName: "live.v21.PublicAuthenticationService",
    methods: {
      getJsonWebKeySet: {
        name: "GetJsonWebKeySet",
        requestType: exports2.GetJsonWebKeySetRequest,
        requestStream: false,
        responseType: exports2.GetJsonWebKeySetResponse,
        responseStream: false,
        options: {}
      },
      guestCodeRedirect: {
        name: "GuestCodeRedirect",
        requestType: exports2.GuestCodeRedirectRequest,
        requestStream: false,
        responseType: exports2.GuestCodeRedirectResponse,
        responseStream: false,
        options: {}
      }
    }
  };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal$1 !== "undefined")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  const atob2 = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
  function bytesFromBase642(b64) {
    const bin = atob2(b64);
    const arr = new Uint8Array(bin.length);
    for (let i2 = 0; i2 < bin.length; ++i2) {
      arr[i2] = bin.charCodeAt(i2);
    }
    return arr;
  }
  const btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
  function base64FromBytes2(arr) {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return btoa2(bin.join(""));
  }
  function toTimestamp(dateStr) {
    const date = new Date(dateStr);
    const seconds = date.getTime() / 1e3;
    const nanos = date.getTime() % 1e3 * 1e6;
    return { seconds, nanos };
  }
  function fromTimestamp(t2) {
    let millis = t2.seconds * 1e3;
    millis += t2.nanos / 1e6;
    return new Date(millis).toISOString();
  }
  if (_m02.util.Long !== long_12.default) {
    _m02.util.Long = long_12.default;
    _m02.configure();
  }
  function isSet2(value) {
    return value !== null && value !== void 0;
  }
})(api$1);
(function(exports2) {
  var __createBinding2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __decorate2 = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d = decorators[i2])
          r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
    return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  var __importStar2 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __metadata2 = commonjsGlobal$1 && commonjsGlobal$1.__metadata || function(k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(k, v);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.LiveApi = void 0;
  const NiceGrpc2 = __importStar2(lib$1);
  const api_12 = api$2;
  const LiveApiModel = __importStar2(api$1);
  const decorator_12 = decorator;
  const LOG_CATEGORY2 = "LiveApi";
  class LiveApi extends api_12.ApiClient {
    constructor(sessionId, eventApi, server, onAccessTokenRefresh, apiKey, sdkVersion, apiLogCallback) {
      super(sessionId, server, sdkVersion, LOG_CATEGORY2, apiLogCallback);
      this.handlers = {};
      this.eventApi = eventApi;
      this.accessTokenRefreshCallback = onAccessTokenRefresh;
      this.publicAuthentication = this.clientFactory.create(LiveApiModel.PublicAuthenticationServiceDefinition, this.channel);
      if (apiKey != void 0) {
        this.backendAuthentication = this.clientFactory.create(LiveApiModel.BackendAuthenticationServiceDefinition, this.channel, {
          "*": { metadata: NiceGrpc2.Metadata({ "X-Api-Key": apiKey }) }
        });
      }
      this.eventApi.on("event", { name: `${LiveApi.LIVEAPI_EVENT_PREFIX}:*`, ignoreSessionEvents: true, allowedSessionEvents: [`${LiveApi.LIVEAPI_EVENT_PREFIX}:EVENT_TYPE_PROJECT:EVENT_SUB_TYPE_STATE`] }, this.eventCallback.bind(this));
    }
    on(type, handler) {
      var _a2;
      this.handlers[type] = (_a2 = this.handlers[type]) !== null && _a2 !== void 0 ? _a2 : [];
      this.handlers[type].push(handler);
    }
    off(type, handler) {
      this.handlers[type] = this.handlers[type].filter((i2) => i2 !== handler);
    }
    emitToHandlers(name2, subType, payload) {
      var _a2;
      for (const handler of (_a2 = this.handlers[name2]) !== null && _a2 !== void 0 ? _a2 : []) {
        handler(Object.values(payload).find((i2) => !!i2), subType);
      }
    }
    async subscribeToCollection(collectionId) {
      await this.eventApi.subscribe(`${LiveApi.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId } });
    }
    async unsubscribeFromCollection(collectionId) {
      await this.eventApi.unsubscribe(`${LiveApi.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId } });
    }
    async subscribeToProject(collectionId, projectId) {
      await this.eventApi.subscribe(`${LiveApi.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId, projectId } });
    }
    async unsubscribeFromProject(collectionId, projectId) {
      await this.eventApi.unsubscribe(`${LiveApi.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId, projectId } });
    }
    eventCallback(event2) {
      let typeAndSubType = event2.name.split(`${LiveApi.LIVEAPI_EVENT_PREFIX}:`)[1];
      let parts = typeAndSubType.split(":");
      let eventType = LiveApiModel.eventTypeFromJSON(parts[0]);
      let eventSubType = LiveApiModel.eventSubTypeFromJSON(parts[1]);
      this.log.info("processing event: " + eventType + "/" + eventSubType);
      if (LiveApi.liveApiEventMap[eventType]) {
        this.emitToHandlers(eventType, eventSubType, event2.payload);
      }
    }
    _setup(options) {
      let self2 = this;
      options.onHeader = function(header) {
        let jwtHeader = header.get("Authorization");
        if (jwtHeader != null) {
          const headerParts = jwtHeader.split(" ");
          if (headerParts.length == 2 && headerParts[0] == "Bearer") {
            let accessToken = headerParts[1];
            self2.log.info("received refresh token");
            self2.accessTokenRefreshCallback(accessToken);
          }
        }
      };
      this.collection = this.clientFactory.create(LiveApiModel.CollectionServiceDefinition, this.channel, {
        "*": options
      });
      this.project = this.clientFactory.create(LiveApiModel.ProjectServiceDefinition, this.channel, {
        "*": options
      });
      this.source = this.clientFactory.create(LiveApiModel.SourceServiceDefinition, this.channel, {
        "*": options
      });
      this.destination = this.clientFactory.create(LiveApiModel.DestinationServiceDefinition, this.channel, {
        "*": options
      });
      this.authentication = this.clientFactory.create(LiveApiModel.AuthenticationServiceDefinition, this.channel, {
        "*": options
      });
    }
  }
  LiveApi.LIVEAPI_EVENT_PREFIX = "apistream:live";
  __decorate2([
    (0, decorator_12.RequiresSdkAuthentication)(),
    __metadata2("design:type", Object)
  ], LiveApi.prototype, "collection", void 0);
  __decorate2([
    (0, decorator_12.RequiresSdkAuthentication)(),
    __metadata2("design:type", Object)
  ], LiveApi.prototype, "project", void 0);
  __decorate2([
    (0, decorator_12.RequiresSdkAuthentication)(),
    __metadata2("design:type", Object)
  ], LiveApi.prototype, "source", void 0);
  __decorate2([
    (0, decorator_12.RequiresSdkAuthentication)(),
    __metadata2("design:type", Object)
  ], LiveApi.prototype, "destination", void 0);
  __decorate2([
    (0, decorator_12.RequiresSdkAuthentication)(),
    __metadata2("design:type", Object)
  ], LiveApi.prototype, "authentication", void 0);
  exports2.LiveApi = LiveApi;
  (function(LiveApi2) {
    LiveApi2.liveApiEventMap = {
      [LiveApiModel.EventType.EVENT_TYPE_COLLECTION]: "collection",
      [LiveApiModel.EventType.EVENT_TYPE_PROJECT]: "project",
      [LiveApiModel.EventType.EVENT_TYPE_SOURCE]: "source",
      [LiveApiModel.EventType.EVENT_TYPE_DESTINATION]: "destination",
      [LiveApiModel.EventType.EVENT_TYPE_UNSPECIFIED]: "unspecified"
    };
  })(LiveApi = exports2.LiveApi || (exports2.LiveApi = {}));
})(liveapi);
var eventapi = {};
var dist$1 = {};
var api = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function isFunction$1(x) {
  return typeof x === "function";
}
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config$2 = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(value) {
    if (value) {
      var error = /* @__PURE__ */ new Error();
      /* @__PURE__ */ console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
    }
    _enable_super_gross_mode_that_will_cause_bad_things = value;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};
function hostReportError(err) {
  setTimeout(function() {
    throw err;
  }, 0);
}
var empty$2 = {
  closed: true,
  next: function(value) {
  },
  error: function(err) {
    if (config$2.useDeprecatedSynchronousErrorHandling) {
      throw err;
    } else {
      hostReportError(err);
    }
  },
  complete: function() {
  }
};
var isArray$2 = /* @__PURE__ */ function() {
  return Array.isArray || function(x) {
    return x && typeof x.length === "number";
  };
}();
function isObject$4(x) {
  return x !== null && typeof x === "object";
}
var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
  function UnsubscriptionErrorImpl2(errors) {
    Error.call(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
    return this;
  }
  UnsubscriptionErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return UnsubscriptionErrorImpl2;
}();
var UnsubscriptionError = UnsubscriptionErrorImpl;
var Subscription = /* @__PURE__ */ function() {
  function Subscription2(unsubscribe) {
    this.closed = false;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (unsubscribe) {
      this._ctorUnsubscribe = true;
      this._unsubscribe = unsubscribe;
    }
  }
  Subscription2.prototype.unsubscribe = function() {
    var errors;
    if (this.closed) {
      return;
    }
    var _a2 = this, _parentOrParents = _a2._parentOrParents, _ctorUnsubscribe = _a2._ctorUnsubscribe, _unsubscribe = _a2._unsubscribe, _subscriptions = _a2._subscriptions;
    this.closed = true;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (_parentOrParents instanceof Subscription2) {
      _parentOrParents.remove(this);
    } else if (_parentOrParents !== null) {
      for (var index2 = 0; index2 < _parentOrParents.length; ++index2) {
        var parent_1 = _parentOrParents[index2];
        parent_1.remove(this);
      }
    }
    if (isFunction$1(_unsubscribe)) {
      if (_ctorUnsubscribe) {
        this._unsubscribe = void 0;
      }
      try {
        _unsubscribe.call(this);
      } catch (e2) {
        errors = e2 instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e2.errors) : [e2];
      }
    }
    if (isArray$2(_subscriptions)) {
      var index2 = -1;
      var len = _subscriptions.length;
      while (++index2 < len) {
        var sub = _subscriptions[index2];
        if (isObject$4(sub)) {
          try {
            sub.unsubscribe();
          } catch (e2) {
            errors = errors || [];
            if (e2 instanceof UnsubscriptionError) {
              errors = errors.concat(flattenUnsubscriptionErrors(e2.errors));
            } else {
              errors.push(e2);
            }
          }
        }
      }
    }
    if (errors) {
      throw new UnsubscriptionError(errors);
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var subscription = teardown;
    if (!teardown) {
      return Subscription2.EMPTY;
    }
    switch (typeof teardown) {
      case "function":
        subscription = new Subscription2(teardown);
      case "object":
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
          return subscription;
        } else if (this.closed) {
          subscription.unsubscribe();
          return subscription;
        } else if (!(subscription instanceof Subscription2)) {
          var tmp = subscription;
          subscription = new Subscription2();
          subscription._subscriptions = [tmp];
        }
        break;
      default: {
        throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
      }
    }
    var _parentOrParents = subscription._parentOrParents;
    if (_parentOrParents === null) {
      subscription._parentOrParents = this;
    } else if (_parentOrParents instanceof Subscription2) {
      if (_parentOrParents === this) {
        return subscription;
      }
      subscription._parentOrParents = [_parentOrParents, this];
    } else if (_parentOrParents.indexOf(this) === -1) {
      _parentOrParents.push(this);
    } else {
      return subscription;
    }
    var subscriptions = this._subscriptions;
    if (subscriptions === null) {
      this._subscriptions = [subscription];
    } else {
      subscriptions.push(subscription);
    }
    return subscription;
  };
  Subscription2.prototype.remove = function(subscription) {
    var subscriptions = this._subscriptions;
    if (subscriptions) {
      var subscriptionIndex = subscriptions.indexOf(subscription);
      if (subscriptionIndex !== -1) {
        subscriptions.splice(subscriptionIndex, 1);
      }
    }
  };
  Subscription2.EMPTY = function(empty2) {
    empty2.closed = true;
    return empty2;
  }(new Subscription2());
  return Subscription2;
}();
function flattenUnsubscriptionErrors(errors) {
  return errors.reduce(function(errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}
var rxSubscriber = /* @__PURE__ */ function() {
  return typeof Symbol === "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
}();
var Subscriber = /* @__PURE__ */ function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destinationOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this.syncErrorValue = null;
    _this.syncErrorThrown = false;
    _this.syncErrorThrowable = false;
    _this.isStopped = false;
    switch (arguments.length) {
      case 0:
        _this.destination = empty$2;
        break;
      case 1:
        if (!destinationOrNext) {
          _this.destination = empty$2;
          break;
        }
        if (typeof destinationOrNext === "object") {
          if (destinationOrNext instanceof Subscriber2) {
            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
            _this.destination = destinationOrNext;
            destinationOrNext.add(_this);
          } else {
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext);
          }
          break;
        }
      default:
        _this.syncErrorThrowable = true;
        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
        break;
    }
    return _this;
  }
  Subscriber2.prototype[rxSubscriber] = function() {
    return this;
  };
  Subscriber2.create = function(next, error, complete) {
    var subscriber = new Subscriber2(next, error, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
  };
  Subscriber2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.isStopped = true;
    _super.prototype.unsubscribe.call(this);
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    this.destination.error(err);
    this.unsubscribe();
  };
  Subscriber2.prototype._complete = function() {
    this.destination.complete();
    this.unsubscribe();
  };
  Subscriber2.prototype._unsubscribeAndRecycle = function() {
    var _parentOrParents = this._parentOrParents;
    this._parentOrParents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parentOrParents = _parentOrParents;
    return this;
  };
  return Subscriber2;
}(Subscription);
var SafeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this._parentSubscriber = _parentSubscriber;
    var next;
    var context2 = _this;
    if (isFunction$1(observerOrNext)) {
      next = observerOrNext;
    } else if (observerOrNext) {
      next = observerOrNext.next;
      error = observerOrNext.error;
      complete = observerOrNext.complete;
      if (observerOrNext !== empty$2) {
        context2 = Object.create(observerOrNext);
        if (isFunction$1(context2.unsubscribe)) {
          _this.add(context2.unsubscribe.bind(context2));
        }
        context2.unsubscribe = _this.unsubscribe.bind(_this);
      }
    }
    _this._context = context2;
    _this._next = next;
    _this._error = error;
    _this._complete = complete;
    return _this;
  }
  SafeSubscriber2.prototype.next = function(value) {
    if (!this.isStopped && this._next) {
      var _parentSubscriber = this._parentSubscriber;
      if (!config$2.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
        this.__tryOrUnsub(this._next, value);
      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      var useDeprecatedSynchronousErrorHandling = config$2.useDeprecatedSynchronousErrorHandling;
      if (this._error) {
        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._error, err);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, this._error, err);
          this.unsubscribe();
        }
      } else if (!_parentSubscriber.syncErrorThrowable) {
        this.unsubscribe();
        if (useDeprecatedSynchronousErrorHandling) {
          throw err;
        }
        hostReportError(err);
      } else {
        if (useDeprecatedSynchronousErrorHandling) {
          _parentSubscriber.syncErrorValue = err;
          _parentSubscriber.syncErrorThrown = true;
        } else {
          hostReportError(err);
        }
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.complete = function() {
    var _this = this;
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      if (this._complete) {
        var wrappedComplete = function() {
          return _this._complete.call(_this._context);
        };
        if (!config$2.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(wrappedComplete);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, wrappedComplete);
          this.unsubscribe();
        }
      } else {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrUnsub = function(fn, value) {
    try {
      fn.call(this._context, value);
    } catch (err) {
      this.unsubscribe();
      if (config$2.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        hostReportError(err);
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrSetError = function(parent2, fn, value) {
    if (!config$2.useDeprecatedSynchronousErrorHandling) {
      throw new Error("bad call");
    }
    try {
      fn.call(this._context, value);
    } catch (err) {
      if (config$2.useDeprecatedSynchronousErrorHandling) {
        parent2.syncErrorValue = err;
        parent2.syncErrorThrown = true;
        return true;
      } else {
        hostReportError(err);
        return true;
      }
    }
    return false;
  };
  SafeSubscriber2.prototype._unsubscribe = function() {
    var _parentSubscriber = this._parentSubscriber;
    this._context = null;
    this._parentSubscriber = null;
    _parentSubscriber.unsubscribe();
  };
  return SafeSubscriber2;
}(Subscriber);
function canReportError(observer) {
  while (observer) {
    var _a2 = observer, closed_1 = _a2.closed, destination = _a2.destination, isStopped = _a2.isStopped;
    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }
  return true;
}
function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber) {
      return nextOrObserver;
    }
    if (nextOrObserver[rxSubscriber]) {
      return nextOrObserver[rxSubscriber]();
    }
  }
  if (!nextOrObserver && !error && !complete) {
    return new Subscriber(empty$2);
  }
  return new Subscriber(nextOrObserver, error, complete);
}
var observable = /* @__PURE__ */ function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x) {
  return x;
}
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = /* @__PURE__ */ function() {
  function Observable2(subscribe2) {
    this._isScalar = false;
    if (subscribe2) {
      this._subscribe = subscribe2;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var operator = this.operator;
    var sink = toSubscriber(observerOrNext, error, complete);
    if (operator) {
      sink.add(operator.call(sink, this.source));
    } else {
      sink.add(this.source || config$2.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
    }
    if (config$2.useDeprecatedSynchronousErrorHandling) {
      if (sink.syncErrorThrowable) {
        sink.syncErrorThrowable = false;
        if (sink.syncErrorThrown) {
          throw sink.syncErrorValue;
        }
      }
    }
    return sink;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      if (config$2.useDeprecatedSynchronousErrorHandling) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
      }
      if (canReportError(sink)) {
        sink.error(err);
      } else {
        console.warn(err);
      }
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscription;
      subscription = _this.subscribe(function(value) {
        try {
          next(value);
        } catch (err) {
          reject(err);
          if (subscription) {
            subscription.unsubscribe();
          }
        }
      }, reject, resolve);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var source2 = this.source;
    return source2 && source2.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    if (operations.length === 0) {
      return this;
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe2) {
    return new Observable2(subscribe2);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = config$2.Promise || Promise;
  }
  if (!promiseCtor) {
    throw new Error("no Promise impl found");
  }
  return promiseCtor;
}
var subscribeToArray = function(array) {
  return function(subscriber) {
    for (var i2 = 0, len = array.length; i2 < len && !subscriber.closed; i2++) {
      subscriber.next(array[i2]);
    }
    subscriber.complete();
  };
};
var subscribeToPromise = function(promise) {
  return function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, hostReportError);
    return subscriber;
  };
};
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = /* @__PURE__ */ getSymbolIterator();
var subscribeToIterable = function(iterable) {
  return function(subscriber) {
    var iterator$1 = iterable[iterator]();
    do {
      var item = void 0;
      try {
        item = iterator$1.next();
      } catch (err) {
        subscriber.error(err);
        return subscriber;
      }
      if (item.done) {
        subscriber.complete();
        break;
      }
      subscriber.next(item.value);
      if (subscriber.closed) {
        break;
      }
    } while (true);
    if (typeof iterator$1.return === "function") {
      subscriber.add(function() {
        if (iterator$1.return) {
          iterator$1.return();
        }
      });
    }
    return subscriber;
  };
};
var subscribeToObservable = function(obj) {
  return function(subscriber) {
    var obs = obj[observable]();
    if (typeof obs.subscribe !== "function") {
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    } else {
      return obs.subscribe(subscriber);
    }
  };
};
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};
function isPromise(value) {
  return !!value && typeof value.subscribe !== "function" && typeof value.then === "function";
}
var subscribeTo = function(result) {
  if (!!result && typeof result[observable] === "function") {
    return subscribeToObservable(result);
  } else if (isArrayLike(result)) {
    return subscribeToArray(result);
  } else if (isPromise(result)) {
    return subscribeToPromise(result);
  } else if (!!result && typeof result[iterator] === "function") {
    return subscribeToIterable(result);
  } else {
    var value = isObject$4(result) ? "an invalid object" : "'" + result + "'";
    var msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
    throw new TypeError(msg);
  }
};
var SimpleInnerSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SimpleInnerSubscriber2, _super);
  function SimpleInnerSubscriber2(parent2) {
    var _this = _super.call(this) || this;
    _this.parent = parent2;
    return _this;
  }
  SimpleInnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(value);
  };
  SimpleInnerSubscriber2.prototype._error = function(error) {
    this.parent.notifyError(error);
    this.unsubscribe();
  };
  SimpleInnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete();
    this.unsubscribe();
  };
  return SimpleInnerSubscriber2;
}(Subscriber);
var SimpleOuterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SimpleOuterSubscriber2, _super);
  function SimpleOuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  SimpleOuterSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  };
  SimpleOuterSubscriber2.prototype.notifyComplete = function() {
    this.destination.complete();
  };
  return SimpleOuterSubscriber2;
}(Subscriber);
function innerSubscribe(result, innerSubscriber) {
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  var subscription;
  try {
    subscription = subscribeTo(result)(innerSubscriber);
  } catch (error) {
    innerSubscriber.error(error);
  }
  return subscription;
}
function audit(durationSelector) {
  return function auditOperatorFunction(source2) {
    return source2.lift(new AuditOperator(durationSelector));
  };
}
var AuditOperator = /* @__PURE__ */ function() {
  function AuditOperator2(durationSelector) {
    this.durationSelector = durationSelector;
  }
  AuditOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
  };
  return AuditOperator2;
}();
var AuditSubscriber = /* @__PURE__ */ function(_super) {
  __extends(AuditSubscriber2, _super);
  function AuditSubscriber2(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.durationSelector = durationSelector;
    _this.hasValue = false;
    return _this;
  }
  AuditSubscriber2.prototype._next = function(value) {
    this.value = value;
    this.hasValue = true;
    if (!this.throttled) {
      var duration = void 0;
      try {
        var durationSelector = this.durationSelector;
        duration = durationSelector(value);
      } catch (err) {
        return this.destination.error(err);
      }
      var innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
      if (!innerSubscription || innerSubscription.closed) {
        this.clearThrottle();
      } else {
        this.add(this.throttled = innerSubscription);
      }
    }
  };
  AuditSubscriber2.prototype.clearThrottle = function() {
    var _a2 = this, value = _a2.value, hasValue = _a2.hasValue, throttled = _a2.throttled;
    if (throttled) {
      this.remove(throttled);
      this.throttled = void 0;
      throttled.unsubscribe();
    }
    if (hasValue) {
      this.value = void 0;
      this.hasValue = false;
      this.destination.next(value);
    }
  };
  AuditSubscriber2.prototype.notifyNext = function() {
    this.clearThrottle();
  };
  AuditSubscriber2.prototype.notifyComplete = function() {
    this.clearThrottle();
  };
  return AuditSubscriber2;
}(SimpleOuterSubscriber);
var Action = /* @__PURE__ */ function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state2, delay2) {
    return this;
  };
  return Action2;
}(Subscription);
var AsyncAction = /* @__PURE__ */ function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state2;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    clearInterval(id);
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state2, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state2, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state2, delay2) {
    var errored = false;
    var errorValue = void 0;
    try {
      this.work(state2);
    } catch (e2) {
      errored = true;
      errorValue = !!e2 && e2 || new Error(e2);
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype._unsubscribe = function() {
    var id = this.id;
    var scheduler = this.scheduler;
    var actions = scheduler.actions;
    var index2 = actions.indexOf(this);
    this.work = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;
    if (index2 !== -1) {
      actions.splice(index2, 1);
    }
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, null);
    }
    this.delay = null;
  };
  return AsyncAction2;
}(Action);
var Scheduler = /* @__PURE__ */ function() {
  function Scheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler2.now;
    }
    this.SchedulerAction = SchedulerAction;
    this.now = now2;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.SchedulerAction(this, work).schedule(state2, delay2);
  };
  Scheduler2.now = function() {
    return Date.now();
  };
  return Scheduler2;
}();
var AsyncScheduler = /* @__PURE__ */ function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, function() {
      if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
        return AsyncScheduler2.delegate.now();
      } else {
        return now2();
      }
    }) || this;
    _this.actions = [];
    _this.active = false;
    _this.scheduled = void 0;
    return _this;
  }
  AsyncScheduler2.prototype.schedule = function(work, delay2, state2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
      return AsyncScheduler2.delegate.schedule(work, delay2, state2);
    } else {
      return _super.prototype.schedule.call(this, work, delay2, state2);
    }
  };
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this.active) {
      actions.push(action);
      return;
    }
    var error;
    this.active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this.active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);
var asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction);
var async = asyncScheduler;
function isNumeric(val) {
  return !isArray$2(val) && val - parseFloat(val) + 1 >= 0;
}
function isScheduler(value) {
  return value && typeof value.schedule === "function";
}
function timer(dueTime, periodOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  var period = -1;
  if (isNumeric(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if (isScheduler(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }
  if (!isScheduler(scheduler)) {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch$1, due, {
      index: 0,
      period,
      subscriber
    });
  });
}
function dispatch$1(state2) {
  var index2 = state2.index, period = state2.period, subscriber = state2.subscriber;
  subscriber.next(index2);
  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }
  state2.index = index2 + 1;
  this.schedule(state2, period);
}
function auditTime(duration, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return audit(function() {
    return timer(duration, scheduler);
  });
}
function buffer(closingNotifier) {
  return function bufferOperatorFunction(source2) {
    return source2.lift(new BufferOperator(closingNotifier));
  };
}
var BufferOperator = /* @__PURE__ */ function() {
  function BufferOperator2(closingNotifier) {
    this.closingNotifier = closingNotifier;
  }
  BufferOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
  };
  return BufferOperator2;
}();
var BufferSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferSubscriber2, _super);
  function BufferSubscriber2(destination, closingNotifier) {
    var _this = _super.call(this, destination) || this;
    _this.buffer = [];
    _this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(_this)));
    return _this;
  }
  BufferSubscriber2.prototype._next = function(value) {
    this.buffer.push(value);
  };
  BufferSubscriber2.prototype.notifyNext = function() {
    var buffer2 = this.buffer;
    this.buffer = [];
    this.destination.next(buffer2);
  };
  return BufferSubscriber2;
}(SimpleOuterSubscriber);
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  return function bufferCountOperatorFunction(source2) {
    return source2.lift(new BufferCountOperator(bufferSize, startBufferEvery));
  };
}
var BufferCountOperator = /* @__PURE__ */ function() {
  function BufferCountOperator2(bufferSize, startBufferEvery) {
    this.bufferSize = bufferSize;
    this.startBufferEvery = startBufferEvery;
    if (!startBufferEvery || bufferSize === startBufferEvery) {
      this.subscriberClass = BufferCountSubscriber;
    } else {
      this.subscriberClass = BufferSkipCountSubscriber;
    }
  }
  BufferCountOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
  };
  return BufferCountOperator2;
}();
var BufferCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferCountSubscriber2, _super);
  function BufferCountSubscriber2(destination, bufferSize) {
    var _this = _super.call(this, destination) || this;
    _this.bufferSize = bufferSize;
    _this.buffer = [];
    return _this;
  }
  BufferCountSubscriber2.prototype._next = function(value) {
    var buffer2 = this.buffer;
    buffer2.push(value);
    if (buffer2.length == this.bufferSize) {
      this.destination.next(buffer2);
      this.buffer = [];
    }
  };
  BufferCountSubscriber2.prototype._complete = function() {
    var buffer2 = this.buffer;
    if (buffer2.length > 0) {
      this.destination.next(buffer2);
    }
    _super.prototype._complete.call(this);
  };
  return BufferCountSubscriber2;
}(Subscriber);
var BufferSkipCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferSkipCountSubscriber2, _super);
  function BufferSkipCountSubscriber2(destination, bufferSize, startBufferEvery) {
    var _this = _super.call(this, destination) || this;
    _this.bufferSize = bufferSize;
    _this.startBufferEvery = startBufferEvery;
    _this.buffers = [];
    _this.count = 0;
    return _this;
  }
  BufferSkipCountSubscriber2.prototype._next = function(value) {
    var _a2 = this, bufferSize = _a2.bufferSize, startBufferEvery = _a2.startBufferEvery, buffers = _a2.buffers, count2 = _a2.count;
    this.count++;
    if (count2 % startBufferEvery === 0) {
      buffers.push([]);
    }
    for (var i2 = buffers.length; i2--; ) {
      var buffer2 = buffers[i2];
      buffer2.push(value);
      if (buffer2.length === bufferSize) {
        buffers.splice(i2, 1);
        this.destination.next(buffer2);
      }
    }
  };
  BufferSkipCountSubscriber2.prototype._complete = function() {
    var _a2 = this, buffers = _a2.buffers, destination = _a2.destination;
    while (buffers.length > 0) {
      var buffer2 = buffers.shift();
      if (buffer2.length > 0) {
        destination.next(buffer2);
      }
    }
    _super.prototype._complete.call(this);
  };
  return BufferSkipCountSubscriber2;
}(Subscriber);
function bufferTime(bufferTimeSpan) {
  var length2 = arguments.length;
  var scheduler = async;
  if (isScheduler(arguments[arguments.length - 1])) {
    scheduler = arguments[arguments.length - 1];
    length2--;
  }
  var bufferCreationInterval = null;
  if (length2 >= 2) {
    bufferCreationInterval = arguments[1];
  }
  var maxBufferSize = Number.POSITIVE_INFINITY;
  if (length2 >= 3) {
    maxBufferSize = arguments[2];
  }
  return function bufferTimeOperatorFunction(source2) {
    return source2.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
  };
}
var BufferTimeOperator = /* @__PURE__ */ function() {
  function BufferTimeOperator2(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
    this.bufferTimeSpan = bufferTimeSpan;
    this.bufferCreationInterval = bufferCreationInterval;
    this.maxBufferSize = maxBufferSize;
    this.scheduler = scheduler;
  }
  BufferTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
  };
  return BufferTimeOperator2;
}();
var Context = /* @__PURE__ */ function() {
  function Context2() {
    this.buffer = [];
  }
  return Context2;
}();
var BufferTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferTimeSubscriber2, _super);
  function BufferTimeSubscriber2(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.bufferTimeSpan = bufferTimeSpan;
    _this.bufferCreationInterval = bufferCreationInterval;
    _this.maxBufferSize = maxBufferSize;
    _this.scheduler = scheduler;
    _this.contexts = [];
    var context2 = _this.openContext();
    _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
    if (_this.timespanOnly) {
      var timeSpanOnlyState = { subscriber: _this, context: context2, bufferTimeSpan };
      _this.add(context2.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    } else {
      var closeState = { subscriber: _this, context: context2 };
      var creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: _this, scheduler };
      _this.add(context2.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
      _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
    }
    return _this;
  }
  BufferTimeSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    var len = contexts.length;
    var filledBufferContext;
    for (var i2 = 0; i2 < len; i2++) {
      var context_1 = contexts[i2];
      var buffer2 = context_1.buffer;
      buffer2.push(value);
      if (buffer2.length == this.maxBufferSize) {
        filledBufferContext = context_1;
      }
    }
    if (filledBufferContext) {
      this.onBufferFull(filledBufferContext);
    }
  };
  BufferTimeSubscriber2.prototype._error = function(err) {
    this.contexts.length = 0;
    _super.prototype._error.call(this, err);
  };
  BufferTimeSubscriber2.prototype._complete = function() {
    var _a2 = this, contexts = _a2.contexts, destination = _a2.destination;
    while (contexts.length > 0) {
      var context_2 = contexts.shift();
      destination.next(context_2.buffer);
    }
    _super.prototype._complete.call(this);
  };
  BufferTimeSubscriber2.prototype._unsubscribe = function() {
    this.contexts = null;
  };
  BufferTimeSubscriber2.prototype.onBufferFull = function(context2) {
    this.closeContext(context2);
    var closeAction = context2.closeAction;
    closeAction.unsubscribe();
    this.remove(closeAction);
    if (!this.closed && this.timespanOnly) {
      context2 = this.openContext();
      var bufferTimeSpan = this.bufferTimeSpan;
      var timeSpanOnlyState = { subscriber: this, context: context2, bufferTimeSpan };
      this.add(context2.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    }
  };
  BufferTimeSubscriber2.prototype.openContext = function() {
    var context2 = new Context();
    this.contexts.push(context2);
    return context2;
  };
  BufferTimeSubscriber2.prototype.closeContext = function(context2) {
    this.destination.next(context2.buffer);
    var contexts = this.contexts;
    var spliceIndex = contexts ? contexts.indexOf(context2) : -1;
    if (spliceIndex >= 0) {
      contexts.splice(contexts.indexOf(context2), 1);
    }
  };
  return BufferTimeSubscriber2;
}(Subscriber);
function dispatchBufferTimeSpanOnly(state2) {
  var subscriber = state2.subscriber;
  var prevContext = state2.context;
  if (prevContext) {
    subscriber.closeContext(prevContext);
  }
  if (!subscriber.closed) {
    state2.context = subscriber.openContext();
    state2.context.closeAction = this.schedule(state2, state2.bufferTimeSpan);
  }
}
function dispatchBufferCreation(state2) {
  var bufferCreationInterval = state2.bufferCreationInterval, bufferTimeSpan = state2.bufferTimeSpan, subscriber = state2.subscriber, scheduler = state2.scheduler;
  var context2 = subscriber.openContext();
  var action = this;
  if (!subscriber.closed) {
    subscriber.add(context2.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context: context2 }));
    action.schedule(state2, bufferCreationInterval);
  }
}
function dispatchBufferClose(arg) {
  var subscriber = arg.subscriber, context2 = arg.context;
  subscriber.closeContext(context2);
}
var InnerSubscriber = /* @__PURE__ */ function(_super) {
  __extends(InnerSubscriber2, _super);
  function InnerSubscriber2(parent2, outerValue, outerIndex) {
    var _this = _super.call(this) || this;
    _this.parent = parent2;
    _this.outerValue = outerValue;
    _this.outerIndex = outerIndex;
    _this.index = 0;
    return _this;
  }
  InnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
  };
  InnerSubscriber2.prototype._error = function(error) {
    this.parent.notifyError(error, this);
    this.unsubscribe();
  };
  InnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete(this);
    this.unsubscribe();
  };
  return InnerSubscriber2;
}(Subscriber);
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
  if (innerSubscriber === void 0) {
    innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
  }
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  return subscribeTo(result)(innerSubscriber);
}
var OuterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(OuterSubscriber2, _super);
  function OuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  };
  OuterSubscriber2.prototype.notifyError = function(error, innerSub) {
    this.destination.error(error);
  };
  OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.destination.complete();
  };
  return OuterSubscriber2;
}(Subscriber);
function bufferToggle(openings, closingSelector) {
  return function bufferToggleOperatorFunction(source2) {
    return source2.lift(new BufferToggleOperator(openings, closingSelector));
  };
}
var BufferToggleOperator = /* @__PURE__ */ function() {
  function BufferToggleOperator2(openings, closingSelector) {
    this.openings = openings;
    this.closingSelector = closingSelector;
  }
  BufferToggleOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
  };
  return BufferToggleOperator2;
}();
var BufferToggleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferToggleSubscriber2, _super);
  function BufferToggleSubscriber2(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.closingSelector = closingSelector;
    _this.contexts = [];
    _this.add(subscribeToResult(_this, openings));
    return _this;
  }
  BufferToggleSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    var len = contexts.length;
    for (var i2 = 0; i2 < len; i2++) {
      contexts[i2].buffer.push(value);
    }
  };
  BufferToggleSubscriber2.prototype._error = function(err) {
    var contexts = this.contexts;
    while (contexts.length > 0) {
      var context_1 = contexts.shift();
      context_1.subscription.unsubscribe();
      context_1.buffer = null;
      context_1.subscription = null;
    }
    this.contexts = null;
    _super.prototype._error.call(this, err);
  };
  BufferToggleSubscriber2.prototype._complete = function() {
    var contexts = this.contexts;
    while (contexts.length > 0) {
      var context_2 = contexts.shift();
      this.destination.next(context_2.buffer);
      context_2.subscription.unsubscribe();
      context_2.buffer = null;
      context_2.subscription = null;
    }
    this.contexts = null;
    _super.prototype._complete.call(this);
  };
  BufferToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue) {
    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
  };
  BufferToggleSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.closeBuffer(innerSub.context);
  };
  BufferToggleSubscriber2.prototype.openBuffer = function(value) {
    try {
      var closingSelector = this.closingSelector;
      var closingNotifier = closingSelector.call(this, value);
      if (closingNotifier) {
        this.trySubscribe(closingNotifier);
      }
    } catch (err) {
      this._error(err);
    }
  };
  BufferToggleSubscriber2.prototype.closeBuffer = function(context2) {
    var contexts = this.contexts;
    if (contexts && context2) {
      var buffer2 = context2.buffer, subscription = context2.subscription;
      this.destination.next(buffer2);
      contexts.splice(contexts.indexOf(context2), 1);
      this.remove(subscription);
      subscription.unsubscribe();
    }
  };
  BufferToggleSubscriber2.prototype.trySubscribe = function(closingNotifier) {
    var contexts = this.contexts;
    var buffer2 = [];
    var subscription = new Subscription();
    var context2 = { buffer: buffer2, subscription };
    contexts.push(context2);
    var innerSubscription = subscribeToResult(this, closingNotifier, context2);
    if (!innerSubscription || innerSubscription.closed) {
      this.closeBuffer(context2);
    } else {
      innerSubscription.context = context2;
      this.add(innerSubscription);
      subscription.add(innerSubscription);
    }
  };
  return BufferToggleSubscriber2;
}(OuterSubscriber);
function bufferWhen(closingSelector) {
  return function(source2) {
    return source2.lift(new BufferWhenOperator(closingSelector));
  };
}
var BufferWhenOperator = /* @__PURE__ */ function() {
  function BufferWhenOperator2(closingSelector) {
    this.closingSelector = closingSelector;
  }
  BufferWhenOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
  };
  return BufferWhenOperator2;
}();
var BufferWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferWhenSubscriber2, _super);
  function BufferWhenSubscriber2(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.closingSelector = closingSelector;
    _this.subscribing = false;
    _this.openBuffer();
    return _this;
  }
  BufferWhenSubscriber2.prototype._next = function(value) {
    this.buffer.push(value);
  };
  BufferWhenSubscriber2.prototype._complete = function() {
    var buffer2 = this.buffer;
    if (buffer2) {
      this.destination.next(buffer2);
    }
    _super.prototype._complete.call(this);
  };
  BufferWhenSubscriber2.prototype._unsubscribe = function() {
    this.buffer = void 0;
    this.subscribing = false;
  };
  BufferWhenSubscriber2.prototype.notifyNext = function() {
    this.openBuffer();
  };
  BufferWhenSubscriber2.prototype.notifyComplete = function() {
    if (this.subscribing) {
      this.complete();
    } else {
      this.openBuffer();
    }
  };
  BufferWhenSubscriber2.prototype.openBuffer = function() {
    var closingSubscription = this.closingSubscription;
    if (closingSubscription) {
      this.remove(closingSubscription);
      closingSubscription.unsubscribe();
    }
    var buffer2 = this.buffer;
    if (this.buffer) {
      this.destination.next(buffer2);
    }
    this.buffer = [];
    var closingNotifier;
    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (err) {
      return this.error(err);
    }
    closingSubscription = new Subscription();
    this.closingSubscription = closingSubscription;
    this.add(closingSubscription);
    this.subscribing = true;
    closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));
    this.subscribing = false;
  };
  return BufferWhenSubscriber2;
}(SimpleOuterSubscriber);
function catchError(selector) {
  return function catchErrorOperatorFunction(source2) {
    var operator = new CatchOperator(selector);
    var caught = source2.lift(operator);
    return operator.caught = caught;
  };
}
var CatchOperator = /* @__PURE__ */ function() {
  function CatchOperator2(selector) {
    this.selector = selector;
  }
  CatchOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
  };
  return CatchOperator2;
}();
var CatchSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CatchSubscriber2, _super);
  function CatchSubscriber2(destination, selector, caught) {
    var _this = _super.call(this, destination) || this;
    _this.selector = selector;
    _this.caught = caught;
    return _this;
  }
  CatchSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var result = void 0;
      try {
        result = this.selector(err, this.caught);
      } catch (err2) {
        _super.prototype.error.call(this, err2);
        return;
      }
      this._unsubscribeAndRecycle();
      var innerSubscriber = new SimpleInnerSubscriber(this);
      this.add(innerSubscriber);
      var innerSubscription = innerSubscribe(result, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        this.add(innerSubscription);
      }
    }
  };
  return CatchSubscriber2;
}(SimpleOuterSubscriber);
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var i2 = 0;
    sub.add(scheduler.schedule(function() {
      if (i2 === input.length) {
        subscriber.complete();
        return;
      }
      subscriber.next(input[i2++]);
      if (!subscriber.closed) {
        sub.add(this.schedule());
      }
    }));
    return sub;
  });
}
function fromArray(input, scheduler) {
  if (!scheduler) {
    return new Observable(subscribeToArray(input));
  } else {
    return scheduleArray(input, scheduler);
  }
}
var NONE = {};
var CombineLatestOperator = /* @__PURE__ */ function() {
  function CombineLatestOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  CombineLatestOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
  };
  return CombineLatestOperator2;
}();
var CombineLatestSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CombineLatestSubscriber2, _super);
  function CombineLatestSubscriber2(destination, resultSelector) {
    var _this = _super.call(this, destination) || this;
    _this.resultSelector = resultSelector;
    _this.active = 0;
    _this.values = [];
    _this.observables = [];
    return _this;
  }
  CombineLatestSubscriber2.prototype._next = function(observable2) {
    this.values.push(NONE);
    this.observables.push(observable2);
  };
  CombineLatestSubscriber2.prototype._complete = function() {
    var observables = this.observables;
    var len = observables.length;
    if (len === 0) {
      this.destination.complete();
    } else {
      this.active = len;
      this.toRespond = len;
      for (var i2 = 0; i2 < len; i2++) {
        var observable2 = observables[i2];
        this.add(subscribeToResult(this, observable2, void 0, i2));
      }
    }
  };
  CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
    if ((this.active -= 1) === 0) {
      this.destination.complete();
    }
  };
  CombineLatestSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    var values2 = this.values;
    var oldVal = values2[outerIndex];
    var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
    values2[outerIndex] = innerValue;
    if (toRespond === 0) {
      if (this.resultSelector) {
        this._tryResultSelector(values2);
      } else {
        this.destination.next(values2.slice());
      }
    }
  };
  CombineLatestSubscriber2.prototype._tryResultSelector = function(values2) {
    var result;
    try {
      result = this.resultSelector.apply(this, values2);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return CombineLatestSubscriber2;
}(OuterSubscriber);
function combineAll(project) {
  return function(source2) {
    return source2.lift(new CombineLatestOperator(project));
  };
}
function scheduleObservable(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      var observable$1 = input[observable]();
      sub.add(observable$1.subscribe({
        next: function(value) {
          sub.add(scheduler.schedule(function() {
            return subscriber.next(value);
          }));
        },
        error: function(err) {
          sub.add(scheduler.schedule(function() {
            return subscriber.error(err);
          }));
        },
        complete: function() {
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }
      }));
    }));
    return sub;
  });
}
function schedulePromise(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      return input.then(function(value) {
        sub.add(scheduler.schedule(function() {
          subscriber.next(value);
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }));
      }, function(err) {
        sub.add(scheduler.schedule(function() {
          return subscriber.error(err);
        }));
      });
    }));
    return sub;
  });
}
function scheduleIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var iterator$1;
    sub.add(function() {
      if (iterator$1 && typeof iterator$1.return === "function") {
        iterator$1.return();
      }
    });
    sub.add(scheduler.schedule(function() {
      iterator$1 = input[iterator]();
      sub.add(scheduler.schedule(function() {
        if (subscriber.closed) {
          return;
        }
        var value;
        var done;
        try {
          var result = iterator$1.next();
          value = result.value;
          done = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}
function isInteropObservable(input) {
  return input && typeof input[observable] === "function";
}
function isIterable(input) {
  return input && typeof input[iterator] === "function";
}
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    } else if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    } else if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    } else if (isIterable(input) || typeof input === "string") {
      return scheduleIterable(input, scheduler);
    }
  }
  throw new TypeError((input !== null && typeof input || input) + " is not observable");
}
function from(input, scheduler) {
  if (!scheduler) {
    if (input instanceof Observable) {
      return input;
    }
    return new Observable(subscribeTo(input));
  } else {
    return scheduled(input, scheduler);
  }
}
function combineLatest() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var project = null;
  if (typeof observables[observables.length - 1] === "function") {
    project = observables.pop();
  }
  if (observables.length === 1 && isArray$2(observables[0])) {
    observables = observables[0].slice();
  }
  return function(source2) {
    return source2.lift.call(from([source2].concat(observables)), new CombineLatestOperator(project));
  };
}
function of$1() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = args[args.length - 1];
  if (isScheduler(scheduler)) {
    args.pop();
    return scheduleArray(args, scheduler);
  } else {
    return fromArray(args);
  }
}
function map(project, thisArg) {
  return function mapOperation(source2) {
    if (typeof project !== "function") {
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    }
    return source2.lift(new MapOperator(project, thisArg));
  };
}
var MapOperator = /* @__PURE__ */ function() {
  function MapOperator2(project, thisArg) {
    this.project = project;
    this.thisArg = thisArg;
  }
  MapOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  };
  return MapOperator2;
}();
var MapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MapSubscriber2, _super);
  function MapSubscriber2(destination, project, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.count = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }
  MapSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.project.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return MapSubscriber2;
}(Subscriber);
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return function(source2) {
      return source2.pipe(mergeMap(function(a, i2) {
        return from(project(a, i2)).pipe(map(function(b, ii) {
          return resultSelector(a, b, i2, ii);
        }));
      }, concurrent));
    };
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return function(source2) {
    return source2.lift(new MergeMapOperator(project, concurrent));
  };
}
var MergeMapOperator = /* @__PURE__ */ function() {
  function MergeMapOperator2(project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    this.project = project;
    this.concurrent = concurrent;
  }
  MergeMapOperator2.prototype.call = function(observer, source2) {
    return source2.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
  };
  return MergeMapOperator2;
}();
var MergeMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MergeMapSubscriber2, _super);
  function MergeMapSubscriber2(destination, project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.concurrent = concurrent;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }
  MergeMapSubscriber2.prototype._next = function(value) {
    if (this.active < this.concurrent) {
      this._tryNext(value);
    } else {
      this.buffer.push(value);
    }
  };
  MergeMapSubscriber2.prototype._tryNext = function(value) {
    var result;
    var index2 = this.index++;
    try {
      result = this.project(value, index2);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.active++;
    this._innerSub(result);
  };
  MergeMapSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  MergeMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.active === 0 && this.buffer.length === 0) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  MergeMapSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2.length > 0) {
      this._next(buffer2.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      this.destination.complete();
    }
  };
  return MergeMapSubscriber2;
}(SimpleOuterSubscriber);
var flatMap = mergeMap;
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return mergeMap(identity, concurrent);
}
function concatAll() {
  return mergeAll(1);
}
function concat$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return concatAll()(of$1.apply(void 0, observables));
}
function concat() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source2) {
    return source2.lift.call(concat$1.apply(void 0, [source2].concat(observables)));
  };
}
function concatMap(project, resultSelector) {
  return mergeMap(project, resultSelector, 1);
}
function concatMapTo(innerObservable, resultSelector) {
  return concatMap(function() {
    return innerObservable;
  }, resultSelector);
}
function count(predicate) {
  return function(source2) {
    return source2.lift(new CountOperator(predicate, source2));
  };
}
var CountOperator = /* @__PURE__ */ function() {
  function CountOperator2(predicate, source2) {
    this.predicate = predicate;
    this.source = source2;
  }
  CountOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
  };
  return CountOperator2;
}();
var CountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CountSubscriber2, _super);
  function CountSubscriber2(destination, predicate, source2) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source2;
    _this.count = 0;
    _this.index = 0;
    return _this;
  }
  CountSubscriber2.prototype._next = function(value) {
    if (this.predicate) {
      this._tryPredicate(value);
    } else {
      this.count++;
    }
  };
  CountSubscriber2.prototype._tryPredicate = function(value) {
    var result;
    try {
      result = this.predicate(value, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (result) {
      this.count++;
    }
  };
  CountSubscriber2.prototype._complete = function() {
    this.destination.next(this.count);
    this.destination.complete();
  };
  return CountSubscriber2;
}(Subscriber);
function debounce(durationSelector) {
  return function(source2) {
    return source2.lift(new DebounceOperator(durationSelector));
  };
}
var DebounceOperator = /* @__PURE__ */ function() {
  function DebounceOperator2(durationSelector) {
    this.durationSelector = durationSelector;
  }
  DebounceOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
  };
  return DebounceOperator2;
}();
var DebounceSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DebounceSubscriber2, _super);
  function DebounceSubscriber2(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.durationSelector = durationSelector;
    _this.hasValue = false;
    return _this;
  }
  DebounceSubscriber2.prototype._next = function(value) {
    try {
      var result = this.durationSelector.call(this, value);
      if (result) {
        this._tryNext(value, result);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  DebounceSubscriber2.prototype._complete = function() {
    this.emitValue();
    this.destination.complete();
  };
  DebounceSubscriber2.prototype._tryNext = function(value, duration) {
    var subscription = this.durationSubscription;
    this.value = value;
    this.hasValue = true;
    if (subscription) {
      subscription.unsubscribe();
      this.remove(subscription);
    }
    subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
    if (subscription && !subscription.closed) {
      this.add(this.durationSubscription = subscription);
    }
  };
  DebounceSubscriber2.prototype.notifyNext = function() {
    this.emitValue();
  };
  DebounceSubscriber2.prototype.notifyComplete = function() {
    this.emitValue();
  };
  DebounceSubscriber2.prototype.emitValue = function() {
    if (this.hasValue) {
      var value = this.value;
      var subscription = this.durationSubscription;
      if (subscription) {
        this.durationSubscription = void 0;
        subscription.unsubscribe();
        this.remove(subscription);
      }
      this.value = void 0;
      this.hasValue = false;
      _super.prototype._next.call(this, value);
    }
  };
  return DebounceSubscriber2;
}(SimpleOuterSubscriber);
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source2) {
    return source2.lift(new DebounceTimeOperator(dueTime, scheduler));
  };
}
var DebounceTimeOperator = /* @__PURE__ */ function() {
  function DebounceTimeOperator2(dueTime, scheduler) {
    this.dueTime = dueTime;
    this.scheduler = scheduler;
  }
  DebounceTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
  };
  return DebounceTimeOperator2;
}();
var DebounceTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DebounceTimeSubscriber2, _super);
  function DebounceTimeSubscriber2(destination, dueTime, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.dueTime = dueTime;
    _this.scheduler = scheduler;
    _this.debouncedSubscription = null;
    _this.lastValue = null;
    _this.hasValue = false;
    return _this;
  }
  DebounceTimeSubscriber2.prototype._next = function(value) {
    this.clearDebounce();
    this.lastValue = value;
    this.hasValue = true;
    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
  };
  DebounceTimeSubscriber2.prototype._complete = function() {
    this.debouncedNext();
    this.destination.complete();
  };
  DebounceTimeSubscriber2.prototype.debouncedNext = function() {
    this.clearDebounce();
    if (this.hasValue) {
      var lastValue = this.lastValue;
      this.lastValue = null;
      this.hasValue = false;
      this.destination.next(lastValue);
    }
  };
  DebounceTimeSubscriber2.prototype.clearDebounce = function() {
    var debouncedSubscription = this.debouncedSubscription;
    if (debouncedSubscription !== null) {
      this.remove(debouncedSubscription);
      debouncedSubscription.unsubscribe();
      this.debouncedSubscription = null;
    }
  };
  return DebounceTimeSubscriber2;
}(Subscriber);
function dispatchNext$1(subscriber) {
  subscriber.debouncedNext();
}
function defaultIfEmpty(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = null;
  }
  return function(source2) {
    return source2.lift(new DefaultIfEmptyOperator(defaultValue));
  };
}
var DefaultIfEmptyOperator = /* @__PURE__ */ function() {
  function DefaultIfEmptyOperator2(defaultValue) {
    this.defaultValue = defaultValue;
  }
  DefaultIfEmptyOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
  };
  return DefaultIfEmptyOperator2;
}();
var DefaultIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(DefaultIfEmptySubscriber2, _super);
  function DefaultIfEmptySubscriber2(destination, defaultValue) {
    var _this = _super.call(this, destination) || this;
    _this.defaultValue = defaultValue;
    _this.isEmpty = true;
    return _this;
  }
  DefaultIfEmptySubscriber2.prototype._next = function(value) {
    this.isEmpty = false;
    this.destination.next(value);
  };
  DefaultIfEmptySubscriber2.prototype._complete = function() {
    if (this.isEmpty) {
      this.destination.next(this.defaultValue);
    }
    this.destination.complete();
  };
  return DefaultIfEmptySubscriber2;
}(Subscriber);
function isDate$1(value) {
  return value instanceof Date && !isNaN(+value);
}
var EMPTY = /* @__PURE__ */ new Observable(function(subscriber) {
  return subscriber.complete();
});
function empty$1(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable(function(subscriber) {
    return scheduler.schedule(function() {
      return subscriber.complete();
    });
  });
}
function throwError(error, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      return subscriber.error(error);
    });
  } else {
    return new Observable(function(subscriber) {
      return scheduler.schedule(dispatch, 0, { error, subscriber });
    });
  }
}
function dispatch(_a2) {
  var error = _a2.error, subscriber = _a2.subscriber;
  subscriber.error(error);
}
var Notification = /* @__PURE__ */ function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    switch (this.kind) {
      case "N":
        return observer.next && observer.next(this.value);
      case "E":
        return observer.error && observer.error(this.error);
      case "C":
        return observer.complete && observer.complete();
    }
  };
  Notification2.prototype.do = function(next, error, complete) {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return next && next(this.value);
      case "E":
        return error && error(this.error);
      case "C":
        return complete && complete();
    }
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    if (nextOrObserver && typeof nextOrObserver.next === "function") {
      return this.observe(nextOrObserver);
    } else {
      return this.do(nextOrObserver, error, complete);
    }
  };
  Notification2.prototype.toObservable = function() {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return of$1(this.value);
      case "E":
        return throwError(this.error);
      case "C":
        return empty$1();
    }
    throw new Error("unexpected notification kind value");
  };
  Notification2.createNext = function(value) {
    if (typeof value !== "undefined") {
      return new Notification2("N", value);
    }
    return Notification2.undefinedValueNotification;
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  Notification2.undefinedValueNotification = new Notification2("N", void 0);
  return Notification2;
}();
function delay(delay2, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  var absoluteDelay = isDate$1(delay2);
  var delayFor = absoluteDelay ? +delay2 - scheduler.now() : Math.abs(delay2);
  return function(source2) {
    return source2.lift(new DelayOperator(delayFor, scheduler));
  };
}
var DelayOperator = /* @__PURE__ */ function() {
  function DelayOperator2(delay2, scheduler) {
    this.delay = delay2;
    this.scheduler = scheduler;
  }
  DelayOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
  };
  return DelayOperator2;
}();
var DelaySubscriber = /* @__PURE__ */ function(_super) {
  __extends(DelaySubscriber2, _super);
  function DelaySubscriber2(destination, delay2, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.delay = delay2;
    _this.scheduler = scheduler;
    _this.queue = [];
    _this.active = false;
    _this.errored = false;
    return _this;
  }
  DelaySubscriber2.dispatch = function(state2) {
    var source2 = state2.source;
    var queue2 = source2.queue;
    var scheduler = state2.scheduler;
    var destination = state2.destination;
    while (queue2.length > 0 && queue2[0].time - scheduler.now() <= 0) {
      queue2.shift().notification.observe(destination);
    }
    if (queue2.length > 0) {
      var delay_1 = Math.max(0, queue2[0].time - scheduler.now());
      this.schedule(state2, delay_1);
    } else {
      this.unsubscribe();
      source2.active = false;
    }
  };
  DelaySubscriber2.prototype._schedule = function(scheduler) {
    this.active = true;
    var destination = this.destination;
    destination.add(scheduler.schedule(DelaySubscriber2.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler
    }));
  };
  DelaySubscriber2.prototype.scheduleNotification = function(notification) {
    if (this.errored === true) {
      return;
    }
    var scheduler = this.scheduler;
    var message = new DelayMessage(scheduler.now() + this.delay, notification);
    this.queue.push(message);
    if (this.active === false) {
      this._schedule(scheduler);
    }
  };
  DelaySubscriber2.prototype._next = function(value) {
    this.scheduleNotification(Notification.createNext(value));
  };
  DelaySubscriber2.prototype._error = function(err) {
    this.errored = true;
    this.queue = [];
    this.destination.error(err);
    this.unsubscribe();
  };
  DelaySubscriber2.prototype._complete = function() {
    this.scheduleNotification(Notification.createComplete());
    this.unsubscribe();
  };
  return DelaySubscriber2;
}(Subscriber);
var DelayMessage = /* @__PURE__ */ function() {
  function DelayMessage2(time, notification) {
    this.time = time;
    this.notification = notification;
  }
  return DelayMessage2;
}();
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source2) {
      return new SubscriptionDelayObservable(source2, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
    };
  }
  return function(source2) {
    return source2.lift(new DelayWhenOperator(delayDurationSelector));
  };
}
var DelayWhenOperator = /* @__PURE__ */ function() {
  function DelayWhenOperator2(delayDurationSelector) {
    this.delayDurationSelector = delayDurationSelector;
  }
  DelayWhenOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
  };
  return DelayWhenOperator2;
}();
var DelayWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DelayWhenSubscriber2, _super);
  function DelayWhenSubscriber2(destination, delayDurationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.delayDurationSelector = delayDurationSelector;
    _this.completed = false;
    _this.delayNotifierSubscriptions = [];
    _this.index = 0;
    return _this;
  }
  DelayWhenSubscriber2.prototype.notifyNext = function(outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
    this.destination.next(outerValue);
    this.removeSubscription(innerSub);
    this.tryComplete();
  };
  DelayWhenSubscriber2.prototype.notifyError = function(error, innerSub) {
    this._error(error);
  };
  DelayWhenSubscriber2.prototype.notifyComplete = function(innerSub) {
    var value = this.removeSubscription(innerSub);
    if (value) {
      this.destination.next(value);
    }
    this.tryComplete();
  };
  DelayWhenSubscriber2.prototype._next = function(value) {
    var index2 = this.index++;
    try {
      var delayNotifier = this.delayDurationSelector(value, index2);
      if (delayNotifier) {
        this.tryDelay(delayNotifier, value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  DelayWhenSubscriber2.prototype._complete = function() {
    this.completed = true;
    this.tryComplete();
    this.unsubscribe();
  };
  DelayWhenSubscriber2.prototype.removeSubscription = function(subscription) {
    subscription.unsubscribe();
    var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
    if (subscriptionIdx !== -1) {
      this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
    }
    return subscription.outerValue;
  };
  DelayWhenSubscriber2.prototype.tryDelay = function(delayNotifier, value) {
    var notifierSubscription = subscribeToResult(this, delayNotifier, value);
    if (notifierSubscription && !notifierSubscription.closed) {
      var destination = this.destination;
      destination.add(notifierSubscription);
      this.delayNotifierSubscriptions.push(notifierSubscription);
    }
  };
  DelayWhenSubscriber2.prototype.tryComplete = function() {
    if (this.completed && this.delayNotifierSubscriptions.length === 0) {
      this.destination.complete();
    }
  };
  return DelayWhenSubscriber2;
}(OuterSubscriber);
var SubscriptionDelayObservable = /* @__PURE__ */ function(_super) {
  __extends(SubscriptionDelayObservable2, _super);
  function SubscriptionDelayObservable2(source2, subscriptionDelay) {
    var _this = _super.call(this) || this;
    _this.source = source2;
    _this.subscriptionDelay = subscriptionDelay;
    return _this;
  }
  SubscriptionDelayObservable2.prototype._subscribe = function(subscriber) {
    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
  };
  return SubscriptionDelayObservable2;
}(Observable);
var SubscriptionDelaySubscriber = /* @__PURE__ */ function(_super) {
  __extends(SubscriptionDelaySubscriber2, _super);
  function SubscriptionDelaySubscriber2(parent2, source2) {
    var _this = _super.call(this) || this;
    _this.parent = parent2;
    _this.source = source2;
    _this.sourceSubscribed = false;
    return _this;
  }
  SubscriptionDelaySubscriber2.prototype._next = function(unused) {
    this.subscribeToSource();
  };
  SubscriptionDelaySubscriber2.prototype._error = function(err) {
    this.unsubscribe();
    this.parent.error(err);
  };
  SubscriptionDelaySubscriber2.prototype._complete = function() {
    this.unsubscribe();
    this.subscribeToSource();
  };
  SubscriptionDelaySubscriber2.prototype.subscribeToSource = function() {
    if (!this.sourceSubscribed) {
      this.sourceSubscribed = true;
      this.unsubscribe();
      this.source.subscribe(this.parent);
    }
  };
  return SubscriptionDelaySubscriber2;
}(Subscriber);
function dematerialize() {
  return function dematerializeOperatorFunction(source2) {
    return source2.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator = /* @__PURE__ */ function() {
  function DeMaterializeOperator2() {
  }
  DeMaterializeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DeMaterializeSubscriber(subscriber));
  };
  return DeMaterializeOperator2;
}();
var DeMaterializeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DeMaterializeSubscriber2, _super);
  function DeMaterializeSubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  DeMaterializeSubscriber2.prototype._next = function(value) {
    value.observe(this.destination);
  };
  return DeMaterializeSubscriber2;
}(Subscriber);
function distinct(keySelector, flushes) {
  return function(source2) {
    return source2.lift(new DistinctOperator(keySelector, flushes));
  };
}
var DistinctOperator = /* @__PURE__ */ function() {
  function DistinctOperator2(keySelector, flushes) {
    this.keySelector = keySelector;
    this.flushes = flushes;
  }
  DistinctOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
  };
  return DistinctOperator2;
}();
var DistinctSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DistinctSubscriber2, _super);
  function DistinctSubscriber2(destination, keySelector, flushes) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.values = /* @__PURE__ */ new Set();
    if (flushes) {
      _this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(_this)));
    }
    return _this;
  }
  DistinctSubscriber2.prototype.notifyNext = function() {
    this.values.clear();
  };
  DistinctSubscriber2.prototype.notifyError = function(error) {
    this._error(error);
  };
  DistinctSubscriber2.prototype._next = function(value) {
    if (this.keySelector) {
      this._useKeySelector(value);
    } else {
      this._finalizeNext(value, value);
    }
  };
  DistinctSubscriber2.prototype._useKeySelector = function(value) {
    var key;
    var destination = this.destination;
    try {
      key = this.keySelector(value);
    } catch (err) {
      destination.error(err);
      return;
    }
    this._finalizeNext(key, value);
  };
  DistinctSubscriber2.prototype._finalizeNext = function(key, value) {
    var values2 = this.values;
    if (!values2.has(key)) {
      values2.add(key);
      this.destination.next(value);
    }
  };
  return DistinctSubscriber2;
}(SimpleOuterSubscriber);
function distinctUntilChanged(compare2, keySelector) {
  return function(source2) {
    return source2.lift(new DistinctUntilChangedOperator(compare2, keySelector));
  };
}
var DistinctUntilChangedOperator = /* @__PURE__ */ function() {
  function DistinctUntilChangedOperator2(compare2, keySelector) {
    this.compare = compare2;
    this.keySelector = keySelector;
  }
  DistinctUntilChangedOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
  };
  return DistinctUntilChangedOperator2;
}();
var DistinctUntilChangedSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DistinctUntilChangedSubscriber2, _super);
  function DistinctUntilChangedSubscriber2(destination, compare2, keySelector) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.hasKey = false;
    if (typeof compare2 === "function") {
      _this.compare = compare2;
    }
    return _this;
  }
  DistinctUntilChangedSubscriber2.prototype.compare = function(x, y) {
    return x === y;
  };
  DistinctUntilChangedSubscriber2.prototype._next = function(value) {
    var key;
    try {
      var keySelector = this.keySelector;
      key = keySelector ? keySelector(value) : value;
    } catch (err) {
      return this.destination.error(err);
    }
    var result = false;
    if (this.hasKey) {
      try {
        var compare2 = this.compare;
        result = compare2(this.key, key);
      } catch (err) {
        return this.destination.error(err);
      }
    } else {
      this.hasKey = true;
    }
    if (!result) {
      this.key = key;
      this.destination.next(value);
    }
  };
  return DistinctUntilChangedSubscriber2;
}(Subscriber);
function distinctUntilKeyChanged(key, compare2) {
  return distinctUntilChanged(function(x, y) {
    return compare2 ? compare2(x[key], y[key]) : x[key] === y[key];
  });
}
var ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {
  function ArgumentOutOfRangeErrorImpl2() {
    Error.call(this);
    this.message = "argument out of range";
    this.name = "ArgumentOutOfRangeError";
    return this;
  }
  ArgumentOutOfRangeErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return ArgumentOutOfRangeErrorImpl2;
}();
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
function filter(predicate, thisArg) {
  return function filterOperatorFunction(source2) {
    return source2.lift(new FilterOperator(predicate, thisArg));
  };
}
var FilterOperator = /* @__PURE__ */ function() {
  function FilterOperator2(predicate, thisArg) {
    this.predicate = predicate;
    this.thisArg = thisArg;
  }
  FilterOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
  };
  return FilterOperator2;
}();
var FilterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(FilterSubscriber2, _super);
  function FilterSubscriber2(destination, predicate, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.count = 0;
    return _this;
  }
  FilterSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.predicate.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (result) {
      this.destination.next(value);
    }
  };
  return FilterSubscriber2;
}(Subscriber);
var EmptyErrorImpl = /* @__PURE__ */ function() {
  function EmptyErrorImpl2() {
    Error.call(this);
    this.message = "no elements in sequence";
    this.name = "EmptyError";
    return this;
  }
  EmptyErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return EmptyErrorImpl2;
}();
var EmptyError = EmptyErrorImpl;
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return function(source2) {
    return source2.lift(new ThrowIfEmptyOperator(errorFactory));
  };
}
var ThrowIfEmptyOperator = /* @__PURE__ */ function() {
  function ThrowIfEmptyOperator2(errorFactory) {
    this.errorFactory = errorFactory;
  }
  ThrowIfEmptyOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
  };
  return ThrowIfEmptyOperator2;
}();
var ThrowIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrowIfEmptySubscriber2, _super);
  function ThrowIfEmptySubscriber2(destination, errorFactory) {
    var _this = _super.call(this, destination) || this;
    _this.errorFactory = errorFactory;
    _this.hasValue = false;
    return _this;
  }
  ThrowIfEmptySubscriber2.prototype._next = function(value) {
    this.hasValue = true;
    this.destination.next(value);
  };
  ThrowIfEmptySubscriber2.prototype._complete = function() {
    if (!this.hasValue) {
      var err = void 0;
      try {
        err = this.errorFactory();
      } catch (e2) {
        err = e2;
      }
      this.destination.error(err);
    } else {
      return this.destination.complete();
    }
  };
  return ThrowIfEmptySubscriber2;
}(Subscriber);
function defaultErrorFactory() {
  return new EmptyError();
}
function take(count2) {
  return function(source2) {
    if (count2 === 0) {
      return empty$1();
    } else {
      return source2.lift(new TakeOperator(count2));
    }
  };
}
var TakeOperator = /* @__PURE__ */ function() {
  function TakeOperator2(total) {
    this.total = total;
    if (this.total < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  TakeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TakeSubscriber(subscriber, this.total));
  };
  return TakeOperator2;
}();
var TakeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeSubscriber2, _super);
  function TakeSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.count = 0;
    return _this;
  }
  TakeSubscriber2.prototype._next = function(value) {
    var total = this.total;
    var count2 = ++this.count;
    if (count2 <= total) {
      this.destination.next(value);
      if (count2 === total) {
        this.destination.complete();
        this.unsubscribe();
      }
    }
  };
  return TakeSubscriber2;
}(Subscriber);
function elementAt(index2, defaultValue) {
  if (index2 < 0) {
    throw new ArgumentOutOfRangeError();
  }
  var hasDefaultValue = arguments.length >= 2;
  return function(source2) {
    return source2.pipe(filter(function(v, i2) {
      return i2 === index2;
    }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
function endWith() {
  var array = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array[_i] = arguments[_i];
  }
  return function(source2) {
    return concat$1(source2, of$1.apply(void 0, array));
  };
}
function every(predicate, thisArg) {
  return function(source2) {
    return source2.lift(new EveryOperator(predicate, thisArg, source2));
  };
}
var EveryOperator = /* @__PURE__ */ function() {
  function EveryOperator2(predicate, thisArg, source2) {
    this.predicate = predicate;
    this.thisArg = thisArg;
    this.source = source2;
  }
  EveryOperator2.prototype.call = function(observer, source2) {
    return source2.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
  };
  return EveryOperator2;
}();
var EverySubscriber = /* @__PURE__ */ function(_super) {
  __extends(EverySubscriber2, _super);
  function EverySubscriber2(destination, predicate, thisArg, source2) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.source = source2;
    _this.index = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }
  EverySubscriber2.prototype.notifyComplete = function(everyValueMatch) {
    this.destination.next(everyValueMatch);
    this.destination.complete();
  };
  EverySubscriber2.prototype._next = function(value) {
    var result = false;
    try {
      result = this.predicate.call(this.thisArg, value, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (!result) {
      this.notifyComplete(false);
    }
  };
  EverySubscriber2.prototype._complete = function() {
    this.notifyComplete(true);
  };
  return EverySubscriber2;
}(Subscriber);
function exhaust() {
  return function(source2) {
    return source2.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator = /* @__PURE__ */ function() {
  function SwitchFirstOperator2() {
  }
  SwitchFirstOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SwitchFirstSubscriber(subscriber));
  };
  return SwitchFirstOperator2;
}();
var SwitchFirstSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SwitchFirstSubscriber2, _super);
  function SwitchFirstSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasCompleted = false;
    _this.hasSubscription = false;
    return _this;
  }
  SwitchFirstSubscriber2.prototype._next = function(value) {
    if (!this.hasSubscription) {
      this.hasSubscription = true;
      this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));
    }
  };
  SwitchFirstSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (!this.hasSubscription) {
      this.destination.complete();
    }
  };
  SwitchFirstSubscriber2.prototype.notifyComplete = function() {
    this.hasSubscription = false;
    if (this.hasCompleted) {
      this.destination.complete();
    }
  };
  return SwitchFirstSubscriber2;
}(SimpleOuterSubscriber);
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source2) {
      return source2.pipe(exhaustMap(function(a, i2) {
        return from(project(a, i2)).pipe(map(function(b, ii) {
          return resultSelector(a, b, i2, ii);
        }));
      }));
    };
  }
  return function(source2) {
    return source2.lift(new ExhaustMapOperator(project));
  };
}
var ExhaustMapOperator = /* @__PURE__ */ function() {
  function ExhaustMapOperator2(project) {
    this.project = project;
  }
  ExhaustMapOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
  };
  return ExhaustMapOperator2;
}();
var ExhaustMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ExhaustMapSubscriber2, _super);
  function ExhaustMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.hasSubscription = false;
    _this.hasCompleted = false;
    _this.index = 0;
    return _this;
  }
  ExhaustMapSubscriber2.prototype._next = function(value) {
    if (!this.hasSubscription) {
      this.tryNext(value);
    }
  };
  ExhaustMapSubscriber2.prototype.tryNext = function(value) {
    var result;
    var index2 = this.index++;
    try {
      result = this.project(value, index2);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.hasSubscription = true;
    this._innerSub(result);
  };
  ExhaustMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(result, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  ExhaustMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (!this.hasSubscription) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  ExhaustMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  ExhaustMapSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  };
  ExhaustMapSubscriber2.prototype.notifyComplete = function() {
    this.hasSubscription = false;
    if (this.hasCompleted) {
      this.destination.complete();
    }
  };
  return ExhaustMapSubscriber2;
}(SimpleOuterSubscriber);
function expand(project, concurrent, scheduler) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
  return function(source2) {
    return source2.lift(new ExpandOperator(project, concurrent, scheduler));
  };
}
var ExpandOperator = /* @__PURE__ */ function() {
  function ExpandOperator2(project, concurrent, scheduler) {
    this.project = project;
    this.concurrent = concurrent;
    this.scheduler = scheduler;
  }
  ExpandOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
  };
  return ExpandOperator2;
}();
var ExpandSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ExpandSubscriber2, _super);
  function ExpandSubscriber2(destination, project, concurrent, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.concurrent = concurrent;
    _this.scheduler = scheduler;
    _this.index = 0;
    _this.active = 0;
    _this.hasCompleted = false;
    if (concurrent < Number.POSITIVE_INFINITY) {
      _this.buffer = [];
    }
    return _this;
  }
  ExpandSubscriber2.dispatch = function(arg) {
    var subscriber = arg.subscriber, result = arg.result, value = arg.value, index2 = arg.index;
    subscriber.subscribeToProjection(result, value, index2);
  };
  ExpandSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    if (destination.closed) {
      this._complete();
      return;
    }
    var index2 = this.index++;
    if (this.active < this.concurrent) {
      destination.next(value);
      try {
        var project = this.project;
        var result = project(value, index2);
        if (!this.scheduler) {
          this.subscribeToProjection(result, value, index2);
        } else {
          var state2 = { subscriber: this, result, value, index: index2 };
          var destination_1 = this.destination;
          destination_1.add(this.scheduler.schedule(ExpandSubscriber2.dispatch, 0, state2));
        }
      } catch (e2) {
        destination.error(e2);
      }
    } else {
      this.buffer.push(value);
    }
  };
  ExpandSubscriber2.prototype.subscribeToProjection = function(result, value, index2) {
    this.active++;
    var destination = this.destination;
    destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));
  };
  ExpandSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.hasCompleted && this.active === 0) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  ExpandSubscriber2.prototype.notifyNext = function(innerValue) {
    this._next(innerValue);
  };
  ExpandSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2 && buffer2.length > 0) {
      this._next(buffer2.shift());
    }
    if (this.hasCompleted && this.active === 0) {
      this.destination.complete();
    }
  };
  return ExpandSubscriber2;
}(SimpleOuterSubscriber);
function finalize(callback) {
  return function(source2) {
    return source2.lift(new FinallyOperator(callback));
  };
}
var FinallyOperator = /* @__PURE__ */ function() {
  function FinallyOperator2(callback) {
    this.callback = callback;
  }
  FinallyOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new FinallySubscriber(subscriber, this.callback));
  };
  return FinallyOperator2;
}();
var FinallySubscriber = /* @__PURE__ */ function(_super) {
  __extends(FinallySubscriber2, _super);
  function FinallySubscriber2(destination, callback) {
    var _this = _super.call(this, destination) || this;
    _this.add(new Subscription(callback));
    return _this;
  }
  return FinallySubscriber2;
}(Subscriber);
function find$1(predicate, thisArg) {
  if (typeof predicate !== "function") {
    throw new TypeError("predicate is not a function");
  }
  return function(source2) {
    return source2.lift(new FindValueOperator(predicate, source2, false, thisArg));
  };
}
var FindValueOperator = /* @__PURE__ */ function() {
  function FindValueOperator2(predicate, source2, yieldIndex, thisArg) {
    this.predicate = predicate;
    this.source = source2;
    this.yieldIndex = yieldIndex;
    this.thisArg = thisArg;
  }
  FindValueOperator2.prototype.call = function(observer, source2) {
    return source2.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
  };
  return FindValueOperator2;
}();
var FindValueSubscriber = /* @__PURE__ */ function(_super) {
  __extends(FindValueSubscriber2, _super);
  function FindValueSubscriber2(destination, predicate, source2, yieldIndex, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source2;
    _this.yieldIndex = yieldIndex;
    _this.thisArg = thisArg;
    _this.index = 0;
    return _this;
  }
  FindValueSubscriber2.prototype.notifyComplete = function(value) {
    var destination = this.destination;
    destination.next(value);
    destination.complete();
    this.unsubscribe();
  };
  FindValueSubscriber2.prototype._next = function(value) {
    var _a2 = this, predicate = _a2.predicate, thisArg = _a2.thisArg;
    var index2 = this.index++;
    try {
      var result = predicate.call(thisArg || this, value, index2, this.source);
      if (result) {
        this.notifyComplete(this.yieldIndex ? index2 : value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  FindValueSubscriber2.prototype._complete = function() {
    this.notifyComplete(this.yieldIndex ? -1 : void 0);
  };
  return FindValueSubscriber2;
}(Subscriber);
function findIndex(predicate, thisArg) {
  return function(source2) {
    return source2.lift(new FindValueOperator(predicate, source2, true, thisArg));
  };
}
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source2) {
    return source2.pipe(predicate ? filter(function(v, i2) {
      return predicate(v, i2, source2);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
  function ObjectUnsubscribedErrorImpl2() {
    Error.call(this);
    this.message = "object unsubscribed";
    this.name = "ObjectUnsubscribedError";
    return this;
  }
  ObjectUnsubscribedErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return ObjectUnsubscribedErrorImpl2;
}();
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
var SubjectSubscription = /* @__PURE__ */ function(_super) {
  __extends(SubjectSubscription2, _super);
  function SubjectSubscription2(subject, subscriber) {
    var _this = _super.call(this) || this;
    _this.subject = subject;
    _this.subscriber = subscriber;
    _this.closed = false;
    return _this;
  }
  SubjectSubscription2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.closed = true;
    var subject = this.subject;
    var observers = subject.observers;
    this.subject = null;
    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
      return;
    }
    var subscriberIndex = observers.indexOf(this.subscriber);
    if (subscriberIndex !== -1) {
      observers.splice(subscriberIndex, 1);
    }
  };
  return SubjectSubscription2;
}(Subscription);
var SubjectSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SubjectSubscriber2, _super);
  function SubjectSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    return _this;
  }
  return SubjectSubscriber2;
}(Subscriber);
var Subject = /* @__PURE__ */ function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.observers = [];
    _this.closed = false;
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype[rxSubscriber] = function() {
    return new SubjectSubscriber(this);
  };
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype.next = function(value) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    if (!this.isStopped) {
      var observers = this.observers;
      var len = observers.length;
      var copy = observers.slice();
      for (var i2 = 0; i2 < len; i2++) {
        copy[i2].next(value);
      }
    }
  };
  Subject2.prototype.error = function(err) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.hasError = true;
    this.thrownError = err;
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy = observers.slice();
    for (var i2 = 0; i2 < len; i2++) {
      copy[i2].error(err);
    }
    this.observers.length = 0;
  };
  Subject2.prototype.complete = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy = observers.slice();
    for (var i2 = 0; i2 < len; i2++) {
      copy[i2].complete();
    }
    this.observers.length = 0;
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = true;
    this.closed = true;
    this.observers = null;
  };
  Subject2.prototype._trySubscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return _super.prototype._trySubscribe.call(this, subscriber);
    }
  };
  Subject2.prototype._subscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription.EMPTY;
    } else if (this.isStopped) {
      subscriber.complete();
      return Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      return new SubjectSubscription(this, subscriber);
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source2) {
    return new AnonymousSubject(destination, source2);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = /* @__PURE__ */ function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source2) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source2;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var destination = this.destination;
    if (destination && destination.next) {
      destination.next(value);
    }
  };
  AnonymousSubject2.prototype.error = function(err) {
    var destination = this.destination;
    if (destination && destination.error) {
      this.destination.error(err);
    }
  };
  AnonymousSubject2.prototype.complete = function() {
    var destination = this.destination;
    if (destination && destination.complete) {
      this.destination.complete();
    }
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var source2 = this.source;
    if (source2) {
      return this.source.subscribe(subscriber);
    } else {
      return Subscription.EMPTY;
    }
  };
  return AnonymousSubject2;
}(Subject);
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
  return function(source2) {
    return source2.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
  };
}
var GroupByOperator = /* @__PURE__ */ function() {
  function GroupByOperator2(keySelector, elementSelector, durationSelector, subjectSelector) {
    this.keySelector = keySelector;
    this.elementSelector = elementSelector;
    this.durationSelector = durationSelector;
    this.subjectSelector = subjectSelector;
  }
  GroupByOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  };
  return GroupByOperator2;
}();
var GroupBySubscriber = /* @__PURE__ */ function(_super) {
  __extends(GroupBySubscriber2, _super);
  function GroupBySubscriber2(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.elementSelector = elementSelector;
    _this.durationSelector = durationSelector;
    _this.subjectSelector = subjectSelector;
    _this.groups = null;
    _this.attemptedToUnsubscribe = false;
    _this.count = 0;
    return _this;
  }
  GroupBySubscriber2.prototype._next = function(value) {
    var key;
    try {
      key = this.keySelector(value);
    } catch (err) {
      this.error(err);
      return;
    }
    this._group(value, key);
  };
  GroupBySubscriber2.prototype._group = function(value, key) {
    var groups = this.groups;
    if (!groups) {
      groups = this.groups = /* @__PURE__ */ new Map();
    }
    var group = groups.get(key);
    var element;
    if (this.elementSelector) {
      try {
        element = this.elementSelector(value);
      } catch (err) {
        this.error(err);
      }
    } else {
      element = value;
    }
    if (!group) {
      group = this.subjectSelector ? this.subjectSelector() : new Subject();
      groups.set(key, group);
      var groupedObservable = new GroupedObservable(key, group, this);
      this.destination.next(groupedObservable);
      if (this.durationSelector) {
        var duration = void 0;
        try {
          duration = this.durationSelector(new GroupedObservable(key, group));
        } catch (err) {
          this.error(err);
          return;
        }
        this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
      }
    }
    if (!group.closed) {
      group.next(element);
    }
  };
  GroupBySubscriber2.prototype._error = function(err) {
    var groups = this.groups;
    if (groups) {
      groups.forEach(function(group, key) {
        group.error(err);
      });
      groups.clear();
    }
    this.destination.error(err);
  };
  GroupBySubscriber2.prototype._complete = function() {
    var groups = this.groups;
    if (groups) {
      groups.forEach(function(group, key) {
        group.complete();
      });
      groups.clear();
    }
    this.destination.complete();
  };
  GroupBySubscriber2.prototype.removeGroup = function(key) {
    this.groups.delete(key);
  };
  GroupBySubscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.attemptedToUnsubscribe = true;
      if (this.count === 0) {
        _super.prototype.unsubscribe.call(this);
      }
    }
  };
  return GroupBySubscriber2;
}(Subscriber);
var GroupDurationSubscriber = /* @__PURE__ */ function(_super) {
  __extends(GroupDurationSubscriber2, _super);
  function GroupDurationSubscriber2(key, group, parent2) {
    var _this = _super.call(this, group) || this;
    _this.key = key;
    _this.group = group;
    _this.parent = parent2;
    return _this;
  }
  GroupDurationSubscriber2.prototype._next = function(value) {
    this.complete();
  };
  GroupDurationSubscriber2.prototype._unsubscribe = function() {
    var _a2 = this, parent2 = _a2.parent, key = _a2.key;
    this.key = this.parent = null;
    if (parent2) {
      parent2.removeGroup(key);
    }
  };
  return GroupDurationSubscriber2;
}(Subscriber);
var GroupedObservable = /* @__PURE__ */ function(_super) {
  __extends(GroupedObservable2, _super);
  function GroupedObservable2(key, groupSubject, refCountSubscription) {
    var _this = _super.call(this) || this;
    _this.key = key;
    _this.groupSubject = groupSubject;
    _this.refCountSubscription = refCountSubscription;
    return _this;
  }
  GroupedObservable2.prototype._subscribe = function(subscriber) {
    var subscription = new Subscription();
    var _a2 = this, refCountSubscription = _a2.refCountSubscription, groupSubject = _a2.groupSubject;
    if (refCountSubscription && !refCountSubscription.closed) {
      subscription.add(new InnerRefCountSubscription(refCountSubscription));
    }
    subscription.add(groupSubject.subscribe(subscriber));
    return subscription;
  };
  return GroupedObservable2;
}(Observable);
var InnerRefCountSubscription = /* @__PURE__ */ function(_super) {
  __extends(InnerRefCountSubscription2, _super);
  function InnerRefCountSubscription2(parent2) {
    var _this = _super.call(this) || this;
    _this.parent = parent2;
    parent2.count++;
    return _this;
  }
  InnerRefCountSubscription2.prototype.unsubscribe = function() {
    var parent2 = this.parent;
    if (!parent2.closed && !this.closed) {
      _super.prototype.unsubscribe.call(this);
      parent2.count -= 1;
      if (parent2.count === 0 && parent2.attemptedToUnsubscribe) {
        parent2.unsubscribe();
      }
    }
  };
  return InnerRefCountSubscription2;
}(Subscription);
function ignoreElements() {
  return function ignoreElementsOperatorFunction(source2) {
    return source2.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator = /* @__PURE__ */ function() {
  function IgnoreElementsOperator2() {
  }
  IgnoreElementsOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new IgnoreElementsSubscriber(subscriber));
  };
  return IgnoreElementsOperator2;
}();
var IgnoreElementsSubscriber = /* @__PURE__ */ function(_super) {
  __extends(IgnoreElementsSubscriber2, _super);
  function IgnoreElementsSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IgnoreElementsSubscriber2.prototype._next = function(unused) {
  };
  return IgnoreElementsSubscriber2;
}(Subscriber);
function isEmpty() {
  return function(source2) {
    return source2.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator = /* @__PURE__ */ function() {
  function IsEmptyOperator2() {
  }
  IsEmptyOperator2.prototype.call = function(observer, source2) {
    return source2.subscribe(new IsEmptySubscriber(observer));
  };
  return IsEmptyOperator2;
}();
var IsEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(IsEmptySubscriber2, _super);
  function IsEmptySubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  IsEmptySubscriber2.prototype.notifyComplete = function(isEmpty2) {
    var destination = this.destination;
    destination.next(isEmpty2);
    destination.complete();
  };
  IsEmptySubscriber2.prototype._next = function(value) {
    this.notifyComplete(false);
  };
  IsEmptySubscriber2.prototype._complete = function() {
    this.notifyComplete(true);
  };
  return IsEmptySubscriber2;
}(Subscriber);
function takeLast(count2) {
  return function takeLastOperatorFunction(source2) {
    if (count2 === 0) {
      return empty$1();
    } else {
      return source2.lift(new TakeLastOperator(count2));
    }
  };
}
var TakeLastOperator = /* @__PURE__ */ function() {
  function TakeLastOperator2(total) {
    this.total = total;
    if (this.total < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  TakeLastOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TakeLastSubscriber(subscriber, this.total));
  };
  return TakeLastOperator2;
}();
var TakeLastSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeLastSubscriber2, _super);
  function TakeLastSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.ring = new Array();
    _this.count = 0;
    return _this;
  }
  TakeLastSubscriber2.prototype._next = function(value) {
    var ring = this.ring;
    var total = this.total;
    var count2 = this.count++;
    if (ring.length < total) {
      ring.push(value);
    } else {
      var index2 = count2 % total;
      ring[index2] = value;
    }
  };
  TakeLastSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    var count2 = this.count;
    if (count2 > 0) {
      var total = this.count >= this.total ? this.total : this.count;
      var ring = this.ring;
      for (var i2 = 0; i2 < total; i2++) {
        var idx = count2++ % total;
        destination.next(ring[idx]);
      }
    }
    destination.complete();
  };
  return TakeLastSubscriber2;
}(Subscriber);
function last(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source2) {
    return source2.pipe(predicate ? filter(function(v, i2) {
      return predicate(v, i2, source2);
    }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function mapTo(value) {
  return function(source2) {
    return source2.lift(new MapToOperator(value));
  };
}
var MapToOperator = /* @__PURE__ */ function() {
  function MapToOperator2(value) {
    this.value = value;
  }
  MapToOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new MapToSubscriber(subscriber, this.value));
  };
  return MapToOperator2;
}();
var MapToSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MapToSubscriber2, _super);
  function MapToSubscriber2(destination, value) {
    var _this = _super.call(this, destination) || this;
    _this.value = value;
    return _this;
  }
  MapToSubscriber2.prototype._next = function(x) {
    this.destination.next(this.value);
  };
  return MapToSubscriber2;
}(Subscriber);
function materialize() {
  return function materializeOperatorFunction(source2) {
    return source2.lift(new MaterializeOperator());
  };
}
var MaterializeOperator = /* @__PURE__ */ function() {
  function MaterializeOperator2() {
  }
  MaterializeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new MaterializeSubscriber(subscriber));
  };
  return MaterializeOperator2;
}();
var MaterializeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MaterializeSubscriber2, _super);
  function MaterializeSubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  MaterializeSubscriber2.prototype._next = function(value) {
    this.destination.next(Notification.createNext(value));
  };
  MaterializeSubscriber2.prototype._error = function(err) {
    var destination = this.destination;
    destination.next(Notification.createError(err));
    destination.complete();
  };
  MaterializeSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    destination.next(Notification.createComplete());
    destination.complete();
  };
  return MaterializeSubscriber2;
}(Subscriber);
function scan(accumulator, seed) {
  var hasSeed = false;
  if (arguments.length >= 2) {
    hasSeed = true;
  }
  return function scanOperatorFunction(source2) {
    return source2.lift(new ScanOperator(accumulator, seed, hasSeed));
  };
}
var ScanOperator = /* @__PURE__ */ function() {
  function ScanOperator2(accumulator, seed, hasSeed) {
    if (hasSeed === void 0) {
      hasSeed = false;
    }
    this.accumulator = accumulator;
    this.seed = seed;
    this.hasSeed = hasSeed;
  }
  ScanOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
  };
  return ScanOperator2;
}();
var ScanSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ScanSubscriber2, _super);
  function ScanSubscriber2(destination, accumulator, _seed, hasSeed) {
    var _this = _super.call(this, destination) || this;
    _this.accumulator = accumulator;
    _this._seed = _seed;
    _this.hasSeed = hasSeed;
    _this.index = 0;
    return _this;
  }
  Object.defineProperty(ScanSubscriber2.prototype, "seed", {
    get: function() {
      return this._seed;
    },
    set: function(value) {
      this.hasSeed = true;
      this._seed = value;
    },
    enumerable: true,
    configurable: true
  });
  ScanSubscriber2.prototype._next = function(value) {
    if (!this.hasSeed) {
      this.seed = value;
      this.destination.next(value);
    } else {
      return this._tryNext(value);
    }
  };
  ScanSubscriber2.prototype._tryNext = function(value) {
    var index2 = this.index++;
    var result;
    try {
      result = this.accumulator(this.seed, value, index2);
    } catch (err) {
      this.destination.error(err);
    }
    this.seed = result;
    this.destination.next(result);
  };
  return ScanSubscriber2;
}(Subscriber);
function reduce(accumulator, seed) {
  if (arguments.length >= 2) {
    return function reduceOperatorFunctionWithSeed(source2) {
      return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source2);
    };
  }
  return function reduceOperatorFunction(source2) {
    return pipe(scan(function(acc, value, index2) {
      return accumulator(acc, value, index2 + 1);
    }), takeLast(1))(source2);
  };
}
function max(comparer) {
  var max2 = typeof comparer === "function" ? function(x, y) {
    return comparer(x, y) > 0 ? x : y;
  } : function(x, y) {
    return x > y ? x : y;
  };
  return reduce(max2);
}
function merge$2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var concurrent = Number.POSITIVE_INFINITY;
  var scheduler = null;
  var last2 = observables[observables.length - 1];
  if (isScheduler(last2)) {
    scheduler = observables.pop();
    if (observables.length > 1 && typeof observables[observables.length - 1] === "number") {
      concurrent = observables.pop();
    }
  } else if (typeof last2 === "number") {
    concurrent = observables.pop();
  }
  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
    return observables[0];
  }
  return mergeAll(concurrent)(fromArray(observables, scheduler));
}
function merge$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source2) {
    return source2.lift.call(merge$2.apply(void 0, [source2].concat(observables)));
  };
}
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap(function() {
    return innerObservable;
  }, concurrent);
}
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return function(source2) {
    return source2.lift(new MergeScanOperator(accumulator, seed, concurrent));
  };
}
var MergeScanOperator = /* @__PURE__ */ function() {
  function MergeScanOperator2(accumulator, seed, concurrent) {
    this.accumulator = accumulator;
    this.seed = seed;
    this.concurrent = concurrent;
  }
  MergeScanOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
  };
  return MergeScanOperator2;
}();
var MergeScanSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MergeScanSubscriber2, _super);
  function MergeScanSubscriber2(destination, accumulator, acc, concurrent) {
    var _this = _super.call(this, destination) || this;
    _this.accumulator = accumulator;
    _this.acc = acc;
    _this.concurrent = concurrent;
    _this.hasValue = false;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }
  MergeScanSubscriber2.prototype._next = function(value) {
    if (this.active < this.concurrent) {
      var index2 = this.index++;
      var destination = this.destination;
      var ish = void 0;
      try {
        var accumulator = this.accumulator;
        ish = accumulator(this.acc, value, index2);
      } catch (e2) {
        return destination.error(e2);
      }
      this.active++;
      this._innerSub(ish);
    } else {
      this.buffer.push(value);
    }
  };
  MergeScanSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  MergeScanSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.active === 0 && this.buffer.length === 0) {
      if (this.hasValue === false) {
        this.destination.next(this.acc);
      }
      this.destination.complete();
    }
    this.unsubscribe();
  };
  MergeScanSubscriber2.prototype.notifyNext = function(innerValue) {
    var destination = this.destination;
    this.acc = innerValue;
    this.hasValue = true;
    destination.next(innerValue);
  };
  MergeScanSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2.length > 0) {
      this._next(buffer2.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      if (this.hasValue === false) {
        this.destination.next(this.acc);
      }
      this.destination.complete();
    }
  };
  return MergeScanSubscriber2;
}(SimpleOuterSubscriber);
function min(comparer) {
  var min2 = typeof comparer === "function" ? function(x, y) {
    return comparer(x, y) < 0 ? x : y;
  } : function(x, y) {
    return x < y ? x : y;
  };
  return reduce(min2);
}
function refCount() {
  return function refCountOperatorFunction(source2) {
    return source2.lift(new RefCountOperator(source2));
  };
}
var RefCountOperator = /* @__PURE__ */ function() {
  function RefCountOperator2(connectable) {
    this.connectable = connectable;
  }
  RefCountOperator2.prototype.call = function(subscriber, source2) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable);
    var subscription = source2.subscribe(refCounter);
    if (!refCounter.closed) {
      refCounter.connection = connectable.connect();
    }
    return subscription;
  };
  return RefCountOperator2;
}();
var RefCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RefCountSubscriber2, _super);
  function RefCountSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  RefCountSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (!connectable) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var refCount2 = connectable._refCount;
    if (refCount2 <= 0) {
      this.connection = null;
      return;
    }
    connectable._refCount = refCount2 - 1;
    if (refCount2 > 1) {
      this.connection = null;
      return;
    }
    var connection = this.connection;
    var sharedConnection = connectable._connection;
    this.connection = null;
    if (sharedConnection && (!connection || sharedConnection === connection)) {
      sharedConnection.unsubscribe();
    }
  };
  return RefCountSubscriber2;
}(Subscriber);
var ConnectableObservable = /* @__PURE__ */ function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source2, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source2;
    _this.subjectFactory = subjectFactory;
    _this._refCount = 0;
    _this._isComplete = false;
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype.connect = function() {
    var connection = this._connection;
    if (!connection) {
      this._isComplete = false;
      connection = this._connection = new Subscription();
      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);
var connectableObservableDescriptor = /* @__PURE__ */ function() {
  var connectableProto = ConnectableObservable.prototype;
  return {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: true },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
  };
}();
var ConnectableSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ConnectableSubscriber2, _super);
  function ConnectableSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  ConnectableSubscriber2.prototype._error = function(err) {
    this._unsubscribe();
    _super.prototype._error.call(this, err);
  };
  ConnectableSubscriber2.prototype._complete = function() {
    this.connectable._isComplete = true;
    this._unsubscribe();
    _super.prototype._complete.call(this);
  };
  ConnectableSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (connectable) {
      this.connectable = null;
      var connection = connectable._connection;
      connectable._refCount = 0;
      connectable._subject = null;
      connectable._connection = null;
      if (connection) {
        connection.unsubscribe();
      }
    }
  };
  return ConnectableSubscriber2;
}(SubjectSubscriber);
function multicast(subjectOrSubjectFactory, selector) {
  return function multicastOperatorFunction(source2) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === "function") {
      subjectFactory = subjectOrSubjectFactory;
    } else {
      subjectFactory = function subjectFactory2() {
        return subjectOrSubjectFactory;
      };
    }
    if (typeof selector === "function") {
      return source2.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(source2, connectableObservableDescriptor);
    connectable.source = source2;
    connectable.subjectFactory = subjectFactory;
    return connectable;
  };
}
var MulticastOperator = /* @__PURE__ */ function() {
  function MulticastOperator2(subjectFactory, selector) {
    this.subjectFactory = subjectFactory;
    this.selector = selector;
  }
  MulticastOperator2.prototype.call = function(subscriber, source2) {
    var selector = this.selector;
    var subject = this.subjectFactory();
    var subscription = selector(subject).subscribe(subscriber);
    subscription.add(source2.subscribe(subject));
    return subscription;
  };
  return MulticastOperator2;
}();
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function observeOnOperatorFunction(source2) {
    return source2.lift(new ObserveOnOperator(scheduler, delay2));
  };
}
var ObserveOnOperator = /* @__PURE__ */ function() {
  function ObserveOnOperator2(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.scheduler = scheduler;
    this.delay = delay2;
  }
  ObserveOnOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
  };
  return ObserveOnOperator2;
}();
var ObserveOnSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ObserveOnSubscriber2, _super);
  function ObserveOnSubscriber2(destination, scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    var _this = _super.call(this, destination) || this;
    _this.scheduler = scheduler;
    _this.delay = delay2;
    return _this;
  }
  ObserveOnSubscriber2.dispatch = function(arg) {
    var notification = arg.notification, destination = arg.destination;
    notification.observe(destination);
    this.unsubscribe();
  };
  ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
    var destination = this.destination;
    destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
  };
  ObserveOnSubscriber2.prototype._next = function(value) {
    this.scheduleMessage(Notification.createNext(value));
  };
  ObserveOnSubscriber2.prototype._error = function(err) {
    this.scheduleMessage(Notification.createError(err));
    this.unsubscribe();
  };
  ObserveOnSubscriber2.prototype._complete = function() {
    this.scheduleMessage(Notification.createComplete());
    this.unsubscribe();
  };
  return ObserveOnSubscriber2;
}(Subscriber);
var ObserveOnMessage = /* @__PURE__ */ function() {
  function ObserveOnMessage2(notification, destination) {
    this.notification = notification;
    this.destination = destination;
  }
  return ObserveOnMessage2;
}();
function onErrorResumeNext() {
  var nextSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    nextSources[_i] = arguments[_i];
  }
  if (nextSources.length === 1 && isArray$2(nextSources[0])) {
    nextSources = nextSources[0];
  }
  return function(source2) {
    return source2.lift(new OnErrorResumeNextOperator(nextSources));
  };
}
var OnErrorResumeNextOperator = /* @__PURE__ */ function() {
  function OnErrorResumeNextOperator2(nextSources) {
    this.nextSources = nextSources;
  }
  OnErrorResumeNextOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
  };
  return OnErrorResumeNextOperator2;
}();
var OnErrorResumeNextSubscriber = /* @__PURE__ */ function(_super) {
  __extends(OnErrorResumeNextSubscriber2, _super);
  function OnErrorResumeNextSubscriber2(destination, nextSources) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.nextSources = nextSources;
    return _this;
  }
  OnErrorResumeNextSubscriber2.prototype.notifyError = function() {
    this.subscribeToNextSource();
  };
  OnErrorResumeNextSubscriber2.prototype.notifyComplete = function() {
    this.subscribeToNextSource();
  };
  OnErrorResumeNextSubscriber2.prototype._error = function(err) {
    this.subscribeToNextSource();
    this.unsubscribe();
  };
  OnErrorResumeNextSubscriber2.prototype._complete = function() {
    this.subscribeToNextSource();
    this.unsubscribe();
  };
  OnErrorResumeNextSubscriber2.prototype.subscribeToNextSource = function() {
    var next = this.nextSources.shift();
    if (!!next) {
      var innerSubscriber = new SimpleInnerSubscriber(this);
      var destination = this.destination;
      destination.add(innerSubscriber);
      var innerSubscription = innerSubscribe(next, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        destination.add(innerSubscription);
      }
    } else {
      this.destination.complete();
    }
  };
  return OnErrorResumeNextSubscriber2;
}(SimpleOuterSubscriber);
function pairwise() {
  return function(source2) {
    return source2.lift(new PairwiseOperator());
  };
}
var PairwiseOperator = /* @__PURE__ */ function() {
  function PairwiseOperator2() {
  }
  PairwiseOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new PairwiseSubscriber(subscriber));
  };
  return PairwiseOperator2;
}();
var PairwiseSubscriber = /* @__PURE__ */ function(_super) {
  __extends(PairwiseSubscriber2, _super);
  function PairwiseSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasPrev = false;
    return _this;
  }
  PairwiseSubscriber2.prototype._next = function(value) {
    var pair;
    if (this.hasPrev) {
      pair = [this.prev, value];
    } else {
      this.hasPrev = true;
    }
    this.prev = value;
    if (pair) {
      this.destination.next(pair);
    }
  };
  return PairwiseSubscriber2;
}(Subscriber);
function not(pred, thisArg) {
  function notPred() {
    return !notPred.pred.apply(notPred.thisArg, arguments);
  }
  notPred.pred = pred;
  notPred.thisArg = thisArg;
  return notPred;
}
function partition(predicate, thisArg) {
  return function(source2) {
    return [
      filter(predicate, thisArg)(source2),
      filter(not(predicate, thisArg))(source2)
    ];
  };
}
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length2 = properties.length;
  if (length2 === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return function(source2) {
    return map(plucker(properties, length2))(source2);
  };
}
function plucker(props, length2) {
  var mapper = function(x) {
    var currentProp = x;
    for (var i2 = 0; i2 < length2; i2++) {
      var p = currentProp != null ? currentProp[props[i2]] : void 0;
      if (p !== void 0) {
        currentProp = p;
      } else {
        return void 0;
      }
    }
    return currentProp;
  };
  return mapper;
}
function publish(selector) {
  return selector ? multicast(function() {
    return new Subject();
  }, selector) : multicast(new Subject());
}
var BehaviorSubject = /* @__PURE__ */ function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: true,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    if (subscription && !subscription.closed) {
      subscriber.next(this._value);
    }
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    if (this.hasError) {
      throw this.thrownError;
    } else if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return this._value;
    }
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);
function publishBehavior(value) {
  return function(source2) {
    return multicast(new BehaviorSubject(value))(source2);
  };
}
var AsyncSubject = /* @__PURE__ */ function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.value = null;
    _this.hasNext = false;
    _this.hasCompleted = false;
    return _this;
  }
  AsyncSubject2.prototype._subscribe = function(subscriber) {
    if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription.EMPTY;
    } else if (this.hasCompleted && this.hasNext) {
      subscriber.next(this.value);
      subscriber.complete();
      return Subscription.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.hasCompleted) {
      this.value = value;
      this.hasNext = true;
    }
  };
  AsyncSubject2.prototype.error = function(error) {
    if (!this.hasCompleted) {
      _super.prototype.error.call(this, error);
    }
  };
  AsyncSubject2.prototype.complete = function() {
    this.hasCompleted = true;
    if (this.hasNext) {
      _super.prototype.next.call(this, this.value);
    }
    _super.prototype.complete.call(this);
  };
  return AsyncSubject2;
}(Subject);
function publishLast() {
  return function(source2) {
    return multicast(new AsyncSubject())(source2);
  };
}
var QueueAction = /* @__PURE__ */ function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state2, delay2);
    }
    this.delay = delay2;
    this.state = state2;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state2, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state2, delay2) : this._execute(state2, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    return scheduler.flush(this);
  };
  return QueueAction2;
}(AsyncAction);
var QueueScheduler = /* @__PURE__ */ function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);
var queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction);
var queue = queueScheduler;
var ReplaySubject = /* @__PURE__ */ function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(bufferSize, windowTime2, scheduler) {
    if (bufferSize === void 0) {
      bufferSize = Number.POSITIVE_INFINITY;
    }
    if (windowTime2 === void 0) {
      windowTime2 = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this) || this;
    _this.scheduler = scheduler;
    _this._events = [];
    _this._infiniteTimeWindow = false;
    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
    _this._windowTime = windowTime2 < 1 ? 1 : windowTime2;
    if (windowTime2 === Number.POSITIVE_INFINITY) {
      _this._infiniteTimeWindow = true;
      _this.next = _this.nextInfiniteTimeWindow;
    } else {
      _this.next = _this.nextTimeWindow;
    }
    return _this;
  }
  ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value) {
    if (!this.isStopped) {
      var _events = this._events;
      _events.push(value);
      if (_events.length > this._bufferSize) {
        _events.shift();
      }
    }
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype.nextTimeWindow = function(value) {
    if (!this.isStopped) {
      this._events.push(new ReplayEvent(this._getNow(), value));
      this._trimBufferThenGetEvents();
    }
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    var _infiniteTimeWindow = this._infiniteTimeWindow;
    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
    var scheduler = this.scheduler;
    var len = _events.length;
    var subscription;
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.isStopped || this.hasError) {
      subscription = Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      subscription = new SubjectSubscription(this, subscriber);
    }
    if (scheduler) {
      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
    }
    if (_infiniteTimeWindow) {
      for (var i2 = 0; i2 < len && !subscriber.closed; i2++) {
        subscriber.next(_events[i2]);
      }
    } else {
      for (var i2 = 0; i2 < len && !subscriber.closed; i2++) {
        subscriber.next(_events[i2].value);
      }
    }
    if (this.hasError) {
      subscriber.error(this.thrownError);
    } else if (this.isStopped) {
      subscriber.complete();
    }
    return subscription;
  };
  ReplaySubject2.prototype._getNow = function() {
    return (this.scheduler || queue).now();
  };
  ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
    var now2 = this._getNow();
    var _bufferSize = this._bufferSize;
    var _windowTime = this._windowTime;
    var _events = this._events;
    var eventsCount = _events.length;
    var spliceCount = 0;
    while (spliceCount < eventsCount) {
      if (now2 - _events[spliceCount].time < _windowTime) {
        break;
      }
      spliceCount++;
    }
    if (eventsCount > _bufferSize) {
      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
    }
    if (spliceCount > 0) {
      _events.splice(0, spliceCount);
    }
    return _events;
  };
  return ReplaySubject2;
}(Subject);
var ReplayEvent = /* @__PURE__ */ function() {
  function ReplayEvent2(time, value) {
    this.time = time;
    this.value = value;
  }
  return ReplayEvent2;
}();
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, scheduler) {
  if (selectorOrScheduler && typeof selectorOrScheduler !== "function") {
    scheduler = selectorOrScheduler;
  }
  var selector = typeof selectorOrScheduler === "function" ? selectorOrScheduler : void 0;
  var subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
  return function(source2) {
    return multicast(function() {
      return subject;
    }, selector)(source2);
  };
}
function race$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  if (observables.length === 1) {
    if (isArray$2(observables[0])) {
      observables = observables[0];
    } else {
      return observables[0];
    }
  }
  return fromArray(observables, void 0).lift(new RaceOperator());
}
var RaceOperator = /* @__PURE__ */ function() {
  function RaceOperator2() {
  }
  RaceOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RaceSubscriber(subscriber));
  };
  return RaceOperator2;
}();
var RaceSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RaceSubscriber2, _super);
  function RaceSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasFirst = false;
    _this.observables = [];
    _this.subscriptions = [];
    return _this;
  }
  RaceSubscriber2.prototype._next = function(observable2) {
    this.observables.push(observable2);
  };
  RaceSubscriber2.prototype._complete = function() {
    var observables = this.observables;
    var len = observables.length;
    if (len === 0) {
      this.destination.complete();
    } else {
      for (var i2 = 0; i2 < len && !this.hasFirst; i2++) {
        var observable2 = observables[i2];
        var subscription = subscribeToResult(this, observable2, void 0, i2);
        if (this.subscriptions) {
          this.subscriptions.push(subscription);
        }
        this.add(subscription);
      }
      this.observables = null;
    }
  };
  RaceSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    if (!this.hasFirst) {
      this.hasFirst = true;
      for (var i2 = 0; i2 < this.subscriptions.length; i2++) {
        if (i2 !== outerIndex) {
          var subscription = this.subscriptions[i2];
          subscription.unsubscribe();
          this.remove(subscription);
        }
      }
      this.subscriptions = null;
    }
    this.destination.next(innerValue);
  };
  return RaceSubscriber2;
}(OuterSubscriber);
function race() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function raceOperatorFunction(source2) {
    if (observables.length === 1 && isArray$2(observables[0])) {
      observables = observables[0];
    }
    return source2.lift.call(race$1.apply(void 0, [source2].concat(observables)));
  };
}
function repeat(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source2) {
    if (count2 === 0) {
      return empty$1();
    } else if (count2 < 0) {
      return source2.lift(new RepeatOperator(-1, source2));
    } else {
      return source2.lift(new RepeatOperator(count2 - 1, source2));
    }
  };
}
var RepeatOperator = /* @__PURE__ */ function() {
  function RepeatOperator2(count2, source2) {
    this.count = count2;
    this.source = source2;
  }
  RepeatOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
  };
  return RepeatOperator2;
}();
var RepeatSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RepeatSubscriber2, _super);
  function RepeatSubscriber2(destination, count2, source2) {
    var _this = _super.call(this, destination) || this;
    _this.count = count2;
    _this.source = source2;
    return _this;
  }
  RepeatSubscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      var _a2 = this, source2 = _a2.source, count2 = _a2.count;
      if (count2 === 0) {
        return _super.prototype.complete.call(this);
      } else if (count2 > -1) {
        this.count = count2 - 1;
      }
      source2.subscribe(this._unsubscribeAndRecycle());
    }
  };
  return RepeatSubscriber2;
}(Subscriber);
function repeatWhen(notifier) {
  return function(source2) {
    return source2.lift(new RepeatWhenOperator(notifier));
  };
}
var RepeatWhenOperator = /* @__PURE__ */ function() {
  function RepeatWhenOperator2(notifier) {
    this.notifier = notifier;
  }
  RepeatWhenOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source2));
  };
  return RepeatWhenOperator2;
}();
var RepeatWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RepeatWhenSubscriber2, _super);
  function RepeatWhenSubscriber2(destination, notifier, source2) {
    var _this = _super.call(this, destination) || this;
    _this.notifier = notifier;
    _this.source = source2;
    _this.sourceIsBeingSubscribedTo = true;
    return _this;
  }
  RepeatWhenSubscriber2.prototype.notifyNext = function() {
    this.sourceIsBeingSubscribedTo = true;
    this.source.subscribe(this);
  };
  RepeatWhenSubscriber2.prototype.notifyComplete = function() {
    if (this.sourceIsBeingSubscribedTo === false) {
      return _super.prototype.complete.call(this);
    }
  };
  RepeatWhenSubscriber2.prototype.complete = function() {
    this.sourceIsBeingSubscribedTo = false;
    if (!this.isStopped) {
      if (!this.retries) {
        this.subscribeToRetries();
      }
      if (!this.retriesSubscription || this.retriesSubscription.closed) {
        return _super.prototype.complete.call(this);
      }
      this._unsubscribeAndRecycle();
      this.notifications.next(void 0);
    }
  };
  RepeatWhenSubscriber2.prototype._unsubscribe = function() {
    var _a2 = this, notifications = _a2.notifications, retriesSubscription = _a2.retriesSubscription;
    if (notifications) {
      notifications.unsubscribe();
      this.notifications = void 0;
    }
    if (retriesSubscription) {
      retriesSubscription.unsubscribe();
      this.retriesSubscription = void 0;
    }
    this.retries = void 0;
  };
  RepeatWhenSubscriber2.prototype._unsubscribeAndRecycle = function() {
    var _unsubscribe = this._unsubscribe;
    this._unsubscribe = null;
    _super.prototype._unsubscribeAndRecycle.call(this);
    this._unsubscribe = _unsubscribe;
    return this;
  };
  RepeatWhenSubscriber2.prototype.subscribeToRetries = function() {
    this.notifications = new Subject();
    var retries;
    try {
      var notifier = this.notifier;
      retries = notifier(this.notifications);
    } catch (e2) {
      return _super.prototype.complete.call(this);
    }
    this.retries = retries;
    this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
  };
  return RepeatWhenSubscriber2;
}(SimpleOuterSubscriber);
function retry(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source2) {
    return source2.lift(new RetryOperator(count2, source2));
  };
}
var RetryOperator = /* @__PURE__ */ function() {
  function RetryOperator2(count2, source2) {
    this.count = count2;
    this.source = source2;
  }
  RetryOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
  };
  return RetryOperator2;
}();
var RetrySubscriber = /* @__PURE__ */ function(_super) {
  __extends(RetrySubscriber2, _super);
  function RetrySubscriber2(destination, count2, source2) {
    var _this = _super.call(this, destination) || this;
    _this.count = count2;
    _this.source = source2;
    return _this;
  }
  RetrySubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _a2 = this, source2 = _a2.source, count2 = _a2.count;
      if (count2 === 0) {
        return _super.prototype.error.call(this, err);
      } else if (count2 > -1) {
        this.count = count2 - 1;
      }
      source2.subscribe(this._unsubscribeAndRecycle());
    }
  };
  return RetrySubscriber2;
}(Subscriber);
function retryWhen(notifier) {
  return function(source2) {
    return source2.lift(new RetryWhenOperator(notifier, source2));
  };
}
var RetryWhenOperator = /* @__PURE__ */ function() {
  function RetryWhenOperator2(notifier, source2) {
    this.notifier = notifier;
    this.source = source2;
  }
  RetryWhenOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
  };
  return RetryWhenOperator2;
}();
var RetryWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RetryWhenSubscriber2, _super);
  function RetryWhenSubscriber2(destination, notifier, source2) {
    var _this = _super.call(this, destination) || this;
    _this.notifier = notifier;
    _this.source = source2;
    return _this;
  }
  RetryWhenSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var errors = this.errors;
      var retries = this.retries;
      var retriesSubscription = this.retriesSubscription;
      if (!retries) {
        errors = new Subject();
        try {
          var notifier = this.notifier;
          retries = notifier(errors);
        } catch (e2) {
          return _super.prototype.error.call(this, e2);
        }
        retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
      } else {
        this.errors = void 0;
        this.retriesSubscription = void 0;
      }
      this._unsubscribeAndRecycle();
      this.errors = errors;
      this.retries = retries;
      this.retriesSubscription = retriesSubscription;
      errors.next(err);
    }
  };
  RetryWhenSubscriber2.prototype._unsubscribe = function() {
    var _a2 = this, errors = _a2.errors, retriesSubscription = _a2.retriesSubscription;
    if (errors) {
      errors.unsubscribe();
      this.errors = void 0;
    }
    if (retriesSubscription) {
      retriesSubscription.unsubscribe();
      this.retriesSubscription = void 0;
    }
    this.retries = void 0;
  };
  RetryWhenSubscriber2.prototype.notifyNext = function() {
    var _unsubscribe = this._unsubscribe;
    this._unsubscribe = null;
    this._unsubscribeAndRecycle();
    this._unsubscribe = _unsubscribe;
    this.source.subscribe(this);
  };
  return RetryWhenSubscriber2;
}(SimpleOuterSubscriber);
function sample(notifier) {
  return function(source2) {
    return source2.lift(new SampleOperator(notifier));
  };
}
var SampleOperator = /* @__PURE__ */ function() {
  function SampleOperator2(notifier) {
    this.notifier = notifier;
  }
  SampleOperator2.prototype.call = function(subscriber, source2) {
    var sampleSubscriber = new SampleSubscriber(subscriber);
    var subscription = source2.subscribe(sampleSubscriber);
    subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber)));
    return subscription;
  };
  return SampleOperator2;
}();
var SampleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SampleSubscriber2, _super);
  function SampleSubscriber2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.hasValue = false;
    return _this;
  }
  SampleSubscriber2.prototype._next = function(value) {
    this.value = value;
    this.hasValue = true;
  };
  SampleSubscriber2.prototype.notifyNext = function() {
    this.emitValue();
  };
  SampleSubscriber2.prototype.notifyComplete = function() {
    this.emitValue();
  };
  SampleSubscriber2.prototype.emitValue = function() {
    if (this.hasValue) {
      this.hasValue = false;
      this.destination.next(this.value);
    }
  };
  return SampleSubscriber2;
}(SimpleOuterSubscriber);
function sampleTime(period, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source2) {
    return source2.lift(new SampleTimeOperator(period, scheduler));
  };
}
var SampleTimeOperator = /* @__PURE__ */ function() {
  function SampleTimeOperator2(period, scheduler) {
    this.period = period;
    this.scheduler = scheduler;
  }
  SampleTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
  };
  return SampleTimeOperator2;
}();
var SampleTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SampleTimeSubscriber2, _super);
  function SampleTimeSubscriber2(destination, period, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.period = period;
    _this.scheduler = scheduler;
    _this.hasValue = false;
    _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period }));
    return _this;
  }
  SampleTimeSubscriber2.prototype._next = function(value) {
    this.lastValue = value;
    this.hasValue = true;
  };
  SampleTimeSubscriber2.prototype.notifyNext = function() {
    if (this.hasValue) {
      this.hasValue = false;
      this.destination.next(this.lastValue);
    }
  };
  return SampleTimeSubscriber2;
}(Subscriber);
function dispatchNotification(state2) {
  var subscriber = state2.subscriber, period = state2.period;
  subscriber.notifyNext();
  this.schedule(state2, period);
}
function sequenceEqual(compareTo, comparator) {
  return function(source2) {
    return source2.lift(new SequenceEqualOperator(compareTo, comparator));
  };
}
var SequenceEqualOperator = /* @__PURE__ */ function() {
  function SequenceEqualOperator2(compareTo, comparator) {
    this.compareTo = compareTo;
    this.comparator = comparator;
  }
  SequenceEqualOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
  };
  return SequenceEqualOperator2;
}();
var SequenceEqualSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SequenceEqualSubscriber2, _super);
  function SequenceEqualSubscriber2(destination, compareTo, comparator) {
    var _this = _super.call(this, destination) || this;
    _this.compareTo = compareTo;
    _this.comparator = comparator;
    _this._a = [];
    _this._b = [];
    _this._oneComplete = false;
    _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
    return _this;
  }
  SequenceEqualSubscriber2.prototype._next = function(value) {
    if (this._oneComplete && this._b.length === 0) {
      this.emit(false);
    } else {
      this._a.push(value);
      this.checkValues();
    }
  };
  SequenceEqualSubscriber2.prototype._complete = function() {
    if (this._oneComplete) {
      this.emit(this._a.length === 0 && this._b.length === 0);
    } else {
      this._oneComplete = true;
    }
    this.unsubscribe();
  };
  SequenceEqualSubscriber2.prototype.checkValues = function() {
    var _c = this, _a2 = _c._a, _b = _c._b, comparator = _c.comparator;
    while (_a2.length > 0 && _b.length > 0) {
      var a = _a2.shift();
      var b = _b.shift();
      var areEqual = false;
      try {
        areEqual = comparator ? comparator(a, b) : a === b;
      } catch (e2) {
        this.destination.error(e2);
      }
      if (!areEqual) {
        this.emit(false);
      }
    }
  };
  SequenceEqualSubscriber2.prototype.emit = function(value) {
    var destination = this.destination;
    destination.next(value);
    destination.complete();
  };
  SequenceEqualSubscriber2.prototype.nextB = function(value) {
    if (this._oneComplete && this._a.length === 0) {
      this.emit(false);
    } else {
      this._b.push(value);
      this.checkValues();
    }
  };
  SequenceEqualSubscriber2.prototype.completeB = function() {
    if (this._oneComplete) {
      this.emit(this._a.length === 0 && this._b.length === 0);
    } else {
      this._oneComplete = true;
    }
  };
  return SequenceEqualSubscriber2;
}(Subscriber);
var SequenceEqualCompareToSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SequenceEqualCompareToSubscriber2, _super);
  function SequenceEqualCompareToSubscriber2(destination, parent2) {
    var _this = _super.call(this, destination) || this;
    _this.parent = parent2;
    return _this;
  }
  SequenceEqualCompareToSubscriber2.prototype._next = function(value) {
    this.parent.nextB(value);
  };
  SequenceEqualCompareToSubscriber2.prototype._error = function(err) {
    this.parent.error(err);
    this.unsubscribe();
  };
  SequenceEqualCompareToSubscriber2.prototype._complete = function() {
    this.parent.completeB();
    this.unsubscribe();
  };
  return SequenceEqualCompareToSubscriber2;
}(Subscriber);
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(source2) {
    return refCount()(multicast(shareSubjectFactory)(source2));
  };
}
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var config2;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    config2 = configOrBufferSize;
  } else {
    config2 = {
      bufferSize: configOrBufferSize,
      windowTime: windowTime2,
      refCount: false,
      scheduler
    };
  }
  return function(source2) {
    return source2.lift(shareReplayOperator(config2));
  };
}
function shareReplayOperator(_a2) {
  var _b = _a2.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a2.windowTime, windowTime2 = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a2.refCount, scheduler = _a2.scheduler;
  var subject;
  var refCount2 = 0;
  var subscription;
  var hasError = false;
  var isComplete = false;
  return function shareReplayOperation(source2) {
    refCount2++;
    var innerSub;
    if (!subject || hasError) {
      hasError = false;
      subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
      innerSub = subject.subscribe(this);
      subscription = source2.subscribe({
        next: function(value) {
          subject.next(value);
        },
        error: function(err) {
          hasError = true;
          subject.error(err);
        },
        complete: function() {
          isComplete = true;
          subscription = void 0;
          subject.complete();
        }
      });
      if (isComplete) {
        subscription = void 0;
      }
    } else {
      innerSub = subject.subscribe(this);
    }
    this.add(function() {
      refCount2--;
      innerSub.unsubscribe();
      innerSub = void 0;
      if (subscription && !isComplete && useRefCount && refCount2 === 0) {
        subscription.unsubscribe();
        subscription = void 0;
        subject = void 0;
      }
    });
  };
}
function single(predicate) {
  return function(source2) {
    return source2.lift(new SingleOperator(predicate, source2));
  };
}
var SingleOperator = /* @__PURE__ */ function() {
  function SingleOperator2(predicate, source2) {
    this.predicate = predicate;
    this.source = source2;
  }
  SingleOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
  };
  return SingleOperator2;
}();
var SingleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SingleSubscriber2, _super);
  function SingleSubscriber2(destination, predicate, source2) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source2;
    _this.seenValue = false;
    _this.index = 0;
    return _this;
  }
  SingleSubscriber2.prototype.applySingleValue = function(value) {
    if (this.seenValue) {
      this.destination.error("Sequence contains more than one element");
    } else {
      this.seenValue = true;
      this.singleValue = value;
    }
  };
  SingleSubscriber2.prototype._next = function(value) {
    var index2 = this.index++;
    if (this.predicate) {
      this.tryNext(value, index2);
    } else {
      this.applySingleValue(value);
    }
  };
  SingleSubscriber2.prototype.tryNext = function(value, index2) {
    try {
      if (this.predicate(value, index2, this.source)) {
        this.applySingleValue(value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  SingleSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    if (this.index > 0) {
      destination.next(this.seenValue ? this.singleValue : void 0);
      destination.complete();
    } else {
      destination.error(new EmptyError());
    }
  };
  return SingleSubscriber2;
}(Subscriber);
function skip(count2) {
  return function(source2) {
    return source2.lift(new SkipOperator(count2));
  };
}
var SkipOperator = /* @__PURE__ */ function() {
  function SkipOperator2(total) {
    this.total = total;
  }
  SkipOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SkipSubscriber(subscriber, this.total));
  };
  return SkipOperator2;
}();
var SkipSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipSubscriber2, _super);
  function SkipSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.count = 0;
    return _this;
  }
  SkipSubscriber2.prototype._next = function(x) {
    if (++this.count > this.total) {
      this.destination.next(x);
    }
  };
  return SkipSubscriber2;
}(Subscriber);
function skipLast(count2) {
  return function(source2) {
    return source2.lift(new SkipLastOperator(count2));
  };
}
var SkipLastOperator = /* @__PURE__ */ function() {
  function SkipLastOperator2(_skipCount) {
    this._skipCount = _skipCount;
    if (this._skipCount < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  SkipLastOperator2.prototype.call = function(subscriber, source2) {
    if (this._skipCount === 0) {
      return source2.subscribe(new Subscriber(subscriber));
    } else {
      return source2.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
    }
  };
  return SkipLastOperator2;
}();
var SkipLastSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipLastSubscriber2, _super);
  function SkipLastSubscriber2(destination, _skipCount) {
    var _this = _super.call(this, destination) || this;
    _this._skipCount = _skipCount;
    _this._count = 0;
    _this._ring = new Array(_skipCount);
    return _this;
  }
  SkipLastSubscriber2.prototype._next = function(value) {
    var skipCount = this._skipCount;
    var count2 = this._count++;
    if (count2 < skipCount) {
      this._ring[count2] = value;
    } else {
      var currentIndex = count2 % skipCount;
      var ring = this._ring;
      var oldValue = ring[currentIndex];
      ring[currentIndex] = value;
      this.destination.next(oldValue);
    }
  };
  return SkipLastSubscriber2;
}(Subscriber);
function skipUntil(notifier) {
  return function(source2) {
    return source2.lift(new SkipUntilOperator(notifier));
  };
}
var SkipUntilOperator = /* @__PURE__ */ function() {
  function SkipUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  SkipUntilOperator2.prototype.call = function(destination, source2) {
    return source2.subscribe(new SkipUntilSubscriber(destination, this.notifier));
  };
  return SkipUntilOperator2;
}();
var SkipUntilSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipUntilSubscriber2, _super);
  function SkipUntilSubscriber2(destination, notifier) {
    var _this = _super.call(this, destination) || this;
    _this.hasValue = false;
    var innerSubscriber = new SimpleInnerSubscriber(_this);
    _this.add(innerSubscriber);
    _this.innerSubscription = innerSubscriber;
    var innerSubscription = innerSubscribe(notifier, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      _this.add(innerSubscription);
      _this.innerSubscription = innerSubscription;
    }
    return _this;
  }
  SkipUntilSubscriber2.prototype._next = function(value) {
    if (this.hasValue) {
      _super.prototype._next.call(this, value);
    }
  };
  SkipUntilSubscriber2.prototype.notifyNext = function() {
    this.hasValue = true;
    if (this.innerSubscription) {
      this.innerSubscription.unsubscribe();
    }
  };
  SkipUntilSubscriber2.prototype.notifyComplete = function() {
  };
  return SkipUntilSubscriber2;
}(SimpleOuterSubscriber);
function skipWhile(predicate) {
  return function(source2) {
    return source2.lift(new SkipWhileOperator(predicate));
  };
}
var SkipWhileOperator = /* @__PURE__ */ function() {
  function SkipWhileOperator2(predicate) {
    this.predicate = predicate;
  }
  SkipWhileOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
  };
  return SkipWhileOperator2;
}();
var SkipWhileSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipWhileSubscriber2, _super);
  function SkipWhileSubscriber2(destination, predicate) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.skipping = true;
    _this.index = 0;
    return _this;
  }
  SkipWhileSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    if (this.skipping) {
      this.tryCallPredicate(value);
    }
    if (!this.skipping) {
      destination.next(value);
    }
  };
  SkipWhileSubscriber2.prototype.tryCallPredicate = function(value) {
    try {
      var result = this.predicate(value, this.index++);
      this.skipping = Boolean(result);
    } catch (err) {
      this.destination.error(err);
    }
  };
  return SkipWhileSubscriber2;
}(Subscriber);
function startWith() {
  var array = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array[_i] = arguments[_i];
  }
  var scheduler = array[array.length - 1];
  if (isScheduler(scheduler)) {
    array.pop();
    return function(source2) {
      return concat$1(array, source2, scheduler);
    };
  } else {
    return function(source2) {
      return concat$1(array, source2);
    };
  }
}
var nextHandle = 1;
var RESOLVED = /* @__PURE__ */ function() {
  return /* @__PURE__ */ Promise.resolve();
}();
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    RESOLVED.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};
var AsapAction = /* @__PURE__ */ function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    if (scheduler.actions.length === 0) {
      Immediate.clearImmediate(id);
      scheduler.scheduled = void 0;
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);
var AsapScheduler = /* @__PURE__ */ function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this.active = true;
    this.scheduled = void 0;
    var actions = this.actions;
    var error;
    var index2 = -1;
    var count2 = actions.length;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index2 < count2 && (action = actions.shift()));
    this.active = false;
    if (error) {
      while (++index2 < count2 && (action = actions.shift())) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);
var asapScheduler = /* @__PURE__ */ new AsapScheduler(AsapAction);
var asap = asapScheduler;
var SubscribeOnObservable = /* @__PURE__ */ function(_super) {
  __extends(SubscribeOnObservable2, _super);
  function SubscribeOnObservable2(source2, delayTime, scheduler) {
    if (delayTime === void 0) {
      delayTime = 0;
    }
    if (scheduler === void 0) {
      scheduler = asap;
    }
    var _this = _super.call(this) || this;
    _this.source = source2;
    _this.delayTime = delayTime;
    _this.scheduler = scheduler;
    if (!isNumeric(delayTime) || delayTime < 0) {
      _this.delayTime = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== "function") {
      _this.scheduler = asap;
    }
    return _this;
  }
  SubscribeOnObservable2.create = function(source2, delay2, scheduler) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (scheduler === void 0) {
      scheduler = asap;
    }
    return new SubscribeOnObservable2(source2, delay2, scheduler);
  };
  SubscribeOnObservable2.dispatch = function(arg) {
    var source2 = arg.source, subscriber = arg.subscriber;
    return this.add(source2.subscribe(subscriber));
  };
  SubscribeOnObservable2.prototype._subscribe = function(subscriber) {
    var delay2 = this.delayTime;
    var source2 = this.source;
    var scheduler = this.scheduler;
    return scheduler.schedule(SubscribeOnObservable2.dispatch, delay2, {
      source: source2,
      subscriber
    });
  };
  return SubscribeOnObservable2;
}(Observable);
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function subscribeOnOperatorFunction(source2) {
    return source2.lift(new SubscribeOnOperator(scheduler, delay2));
  };
}
var SubscribeOnOperator = /* @__PURE__ */ function() {
  function SubscribeOnOperator2(scheduler, delay2) {
    this.scheduler = scheduler;
    this.delay = delay2;
  }
  SubscribeOnOperator2.prototype.call = function(subscriber, source2) {
    return new SubscribeOnObservable(source2, this.delay, this.scheduler).subscribe(subscriber);
  };
  return SubscribeOnOperator2;
}();
function switchMap(project, resultSelector) {
  if (typeof resultSelector === "function") {
    return function(source2) {
      return source2.pipe(switchMap(function(a, i2) {
        return from(project(a, i2)).pipe(map(function(b, ii) {
          return resultSelector(a, b, i2, ii);
        }));
      }));
    };
  }
  return function(source2) {
    return source2.lift(new SwitchMapOperator(project));
  };
}
var SwitchMapOperator = /* @__PURE__ */ function() {
  function SwitchMapOperator2(project) {
    this.project = project;
  }
  SwitchMapOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new SwitchMapSubscriber(subscriber, this.project));
  };
  return SwitchMapOperator2;
}();
var SwitchMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SwitchMapSubscriber2, _super);
  function SwitchMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.index = 0;
    return _this;
  }
  SwitchMapSubscriber2.prototype._next = function(value) {
    var result;
    var index2 = this.index++;
    try {
      result = this.project(value, index2);
    } catch (error) {
      this.destination.error(error);
      return;
    }
    this._innerSub(result);
  };
  SwitchMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscription = this.innerSubscription;
    if (innerSubscription) {
      innerSubscription.unsubscribe();
    }
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    this.innerSubscription = innerSubscribe(result, innerSubscriber);
    if (this.innerSubscription !== innerSubscriber) {
      destination.add(this.innerSubscription);
    }
  };
  SwitchMapSubscriber2.prototype._complete = function() {
    var innerSubscription = this.innerSubscription;
    if (!innerSubscription || innerSubscription.closed) {
      _super.prototype._complete.call(this);
    }
    this.unsubscribe();
  };
  SwitchMapSubscriber2.prototype._unsubscribe = function() {
    this.innerSubscription = void 0;
  };
  SwitchMapSubscriber2.prototype.notifyComplete = function() {
    this.innerSubscription = void 0;
    if (this.isStopped) {
      _super.prototype._complete.call(this);
    }
  };
  SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  return SwitchMapSubscriber2;
}(SimpleOuterSubscriber);
function switchAll() {
  return switchMap(identity);
}
function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap(function() {
    return innerObservable;
  });
}
function takeUntil(notifier) {
  return function(source2) {
    return source2.lift(new TakeUntilOperator(notifier));
  };
}
var TakeUntilOperator = /* @__PURE__ */ function() {
  function TakeUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  TakeUntilOperator2.prototype.call = function(subscriber, source2) {
    var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
    var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
    if (notifierSubscription && !takeUntilSubscriber.seenValue) {
      takeUntilSubscriber.add(notifierSubscription);
      return source2.subscribe(takeUntilSubscriber);
    }
    return takeUntilSubscriber;
  };
  return TakeUntilOperator2;
}();
var TakeUntilSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeUntilSubscriber2, _super);
  function TakeUntilSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.seenValue = false;
    return _this;
  }
  TakeUntilSubscriber2.prototype.notifyNext = function() {
    this.seenValue = true;
    this.complete();
  };
  TakeUntilSubscriber2.prototype.notifyComplete = function() {
  };
  return TakeUntilSubscriber2;
}(SimpleOuterSubscriber);
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return function(source2) {
    return source2.lift(new TakeWhileOperator(predicate, inclusive));
  };
}
var TakeWhileOperator = /* @__PURE__ */ function() {
  function TakeWhileOperator2(predicate, inclusive) {
    this.predicate = predicate;
    this.inclusive = inclusive;
  }
  TakeWhileOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
  };
  return TakeWhileOperator2;
}();
var TakeWhileSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeWhileSubscriber2, _super);
  function TakeWhileSubscriber2(destination, predicate, inclusive) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.inclusive = inclusive;
    _this.index = 0;
    return _this;
  }
  TakeWhileSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    var result;
    try {
      result = this.predicate(value, this.index++);
    } catch (err) {
      destination.error(err);
      return;
    }
    this.nextOrComplete(value, result);
  };
  TakeWhileSubscriber2.prototype.nextOrComplete = function(value, predicateResult) {
    var destination = this.destination;
    if (Boolean(predicateResult)) {
      destination.next(value);
    } else {
      if (this.inclusive) {
        destination.next(value);
      }
      destination.complete();
    }
  };
  return TakeWhileSubscriber2;
}(Subscriber);
function noop$2() {
}
function tap(nextOrObserver, error, complete) {
  return function tapOperatorFunction(source2) {
    return source2.lift(new DoOperator(nextOrObserver, error, complete));
  };
}
var DoOperator = /* @__PURE__ */ function() {
  function DoOperator2(nextOrObserver, error, complete) {
    this.nextOrObserver = nextOrObserver;
    this.error = error;
    this.complete = complete;
  }
  DoOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
  };
  return DoOperator2;
}();
var TapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TapSubscriber2, _super);
  function TapSubscriber2(destination, observerOrNext, error, complete) {
    var _this = _super.call(this, destination) || this;
    _this._tapNext = noop$2;
    _this._tapError = noop$2;
    _this._tapComplete = noop$2;
    _this._tapError = error || noop$2;
    _this._tapComplete = complete || noop$2;
    if (isFunction$1(observerOrNext)) {
      _this._context = _this;
      _this._tapNext = observerOrNext;
    } else if (observerOrNext) {
      _this._context = observerOrNext;
      _this._tapNext = observerOrNext.next || noop$2;
      _this._tapError = observerOrNext.error || noop$2;
      _this._tapComplete = observerOrNext.complete || noop$2;
    }
    return _this;
  }
  TapSubscriber2.prototype._next = function(value) {
    try {
      this._tapNext.call(this._context, value);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(value);
  };
  TapSubscriber2.prototype._error = function(err) {
    try {
      this._tapError.call(this._context, err);
    } catch (err2) {
      this.destination.error(err2);
      return;
    }
    this.destination.error(err);
  };
  TapSubscriber2.prototype._complete = function() {
    try {
      this._tapComplete.call(this._context);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    return this.destination.complete();
  };
  return TapSubscriber2;
}(Subscriber);
var defaultThrottleConfig = {
  leading: true,
  trailing: false
};
function throttle(durationSelector, config2) {
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source2) {
    return source2.lift(new ThrottleOperator(durationSelector, !!config2.leading, !!config2.trailing));
  };
}
var ThrottleOperator = /* @__PURE__ */ function() {
  function ThrottleOperator2(durationSelector, leading, trailing) {
    this.durationSelector = durationSelector;
    this.leading = leading;
    this.trailing = trailing;
  }
  ThrottleOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
  };
  return ThrottleOperator2;
}();
var ThrottleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrottleSubscriber2, _super);
  function ThrottleSubscriber2(destination, durationSelector, _leading, _trailing) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.durationSelector = durationSelector;
    _this._leading = _leading;
    _this._trailing = _trailing;
    _this._hasValue = false;
    return _this;
  }
  ThrottleSubscriber2.prototype._next = function(value) {
    this._hasValue = true;
    this._sendValue = value;
    if (!this._throttled) {
      if (this._leading) {
        this.send();
      } else {
        this.throttle(value);
      }
    }
  };
  ThrottleSubscriber2.prototype.send = function() {
    var _a2 = this, _hasValue = _a2._hasValue, _sendValue = _a2._sendValue;
    if (_hasValue) {
      this.destination.next(_sendValue);
      this.throttle(_sendValue);
    }
    this._hasValue = false;
    this._sendValue = void 0;
  };
  ThrottleSubscriber2.prototype.throttle = function(value) {
    var duration = this.tryDurationSelector(value);
    if (!!duration) {
      this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
    }
  };
  ThrottleSubscriber2.prototype.tryDurationSelector = function(value) {
    try {
      return this.durationSelector(value);
    } catch (err) {
      this.destination.error(err);
      return null;
    }
  };
  ThrottleSubscriber2.prototype.throttlingDone = function() {
    var _a2 = this, _throttled = _a2._throttled, _trailing = _a2._trailing;
    if (_throttled) {
      _throttled.unsubscribe();
    }
    this._throttled = void 0;
    if (_trailing) {
      this.send();
    }
  };
  ThrottleSubscriber2.prototype.notifyNext = function() {
    this.throttlingDone();
  };
  ThrottleSubscriber2.prototype.notifyComplete = function() {
    this.throttlingDone();
  };
  return ThrottleSubscriber2;
}(SimpleOuterSubscriber);
function throttleTime(duration, scheduler, config2) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source2) {
    return source2.lift(new ThrottleTimeOperator(duration, scheduler, config2.leading, config2.trailing));
  };
}
var ThrottleTimeOperator = /* @__PURE__ */ function() {
  function ThrottleTimeOperator2(duration, scheduler, leading, trailing) {
    this.duration = duration;
    this.scheduler = scheduler;
    this.leading = leading;
    this.trailing = trailing;
  }
  ThrottleTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
  };
  return ThrottleTimeOperator2;
}();
var ThrottleTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrottleTimeSubscriber2, _super);
  function ThrottleTimeSubscriber2(destination, duration, scheduler, leading, trailing) {
    var _this = _super.call(this, destination) || this;
    _this.duration = duration;
    _this.scheduler = scheduler;
    _this.leading = leading;
    _this.trailing = trailing;
    _this._hasTrailingValue = false;
    _this._trailingValue = null;
    return _this;
  }
  ThrottleTimeSubscriber2.prototype._next = function(value) {
    if (this.throttled) {
      if (this.trailing) {
        this._trailingValue = value;
        this._hasTrailingValue = true;
      }
    } else {
      this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
      if (this.leading) {
        this.destination.next(value);
      } else if (this.trailing) {
        this._trailingValue = value;
        this._hasTrailingValue = true;
      }
    }
  };
  ThrottleTimeSubscriber2.prototype._complete = function() {
    if (this._hasTrailingValue) {
      this.destination.next(this._trailingValue);
      this.destination.complete();
    } else {
      this.destination.complete();
    }
  };
  ThrottleTimeSubscriber2.prototype.clearThrottle = function() {
    var throttled = this.throttled;
    if (throttled) {
      if (this.trailing && this._hasTrailingValue) {
        this.destination.next(this._trailingValue);
        this._trailingValue = null;
        this._hasTrailingValue = false;
      }
      throttled.unsubscribe();
      this.remove(throttled);
      this.throttled = null;
    }
  };
  return ThrottleTimeSubscriber2;
}(Subscriber);
function dispatchNext(arg) {
  var subscriber = arg.subscriber;
  subscriber.clearThrottle();
}
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    var input;
    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source2 = input ? from(input) : empty$1();
    return source2.subscribe(subscriber);
  });
}
function timeInterval(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source2) {
    return defer(function() {
      return source2.pipe(scan(function(_a2, value) {
        var current = _a2.current;
        return { value, current: scheduler.now(), last: current };
      }, { current: scheduler.now(), value: void 0, last: void 0 }), map(function(_a2) {
        var current = _a2.current, last2 = _a2.last, value = _a2.value;
        return new TimeInterval(value, current - last2);
      }));
    });
  };
}
var TimeInterval = /* @__PURE__ */ function() {
  function TimeInterval2(value, interval) {
    this.value = value;
    this.interval = interval;
  }
  return TimeInterval2;
}();
var TimeoutErrorImpl = /* @__PURE__ */ function() {
  function TimeoutErrorImpl2() {
    Error.call(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    return this;
  }
  TimeoutErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return TimeoutErrorImpl2;
}();
var TimeoutError = TimeoutErrorImpl;
function timeoutWith(due, withObservable, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source2) {
    var absoluteTimeout = isDate$1(due);
    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return source2.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
  };
}
var TimeoutWithOperator = /* @__PURE__ */ function() {
  function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler) {
    this.waitFor = waitFor;
    this.absoluteTimeout = absoluteTimeout;
    this.withObservable = withObservable;
    this.scheduler = scheduler;
  }
  TimeoutWithOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  };
  return TimeoutWithOperator2;
}();
var TimeoutWithSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TimeoutWithSubscriber2, _super);
  function TimeoutWithSubscriber2(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.absoluteTimeout = absoluteTimeout;
    _this.waitFor = waitFor;
    _this.withObservable = withObservable;
    _this.scheduler = scheduler;
    _this.scheduleTimeout();
    return _this;
  }
  TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
    var withObservable = subscriber.withObservable;
    subscriber._unsubscribeAndRecycle();
    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
  };
  TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
    var action = this.action;
    if (action) {
      this.action = action.schedule(this, this.waitFor);
    } else {
      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
    }
  };
  TimeoutWithSubscriber2.prototype._next = function(value) {
    if (!this.absoluteTimeout) {
      this.scheduleTimeout();
    }
    _super.prototype._next.call(this, value);
  };
  TimeoutWithSubscriber2.prototype._unsubscribe = function() {
    this.action = void 0;
    this.scheduler = null;
    this.withObservable = null;
  };
  return TimeoutWithSubscriber2;
}(SimpleOuterSubscriber);
function timeout(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return timeoutWith(due, throwError(new TimeoutError()), scheduler);
}
function timestamp(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return map(function(value) {
    return new Timestamp(value, scheduler.now());
  });
}
var Timestamp = /* @__PURE__ */ function() {
  function Timestamp2(value, timestamp2) {
    this.value = value;
    this.timestamp = timestamp2;
  }
  return Timestamp2;
}();
function toArrayReducer(arr, item, index2) {
  if (index2 === 0) {
    return [item];
  }
  arr.push(item);
  return arr;
}
function toArray() {
  return reduce(toArrayReducer, []);
}
function window$1(windowBoundaries) {
  return function windowOperatorFunction(source2) {
    return source2.lift(new WindowOperator$1(windowBoundaries));
  };
}
var WindowOperator$1 = /* @__PURE__ */ function() {
  function WindowOperator2(windowBoundaries) {
    this.windowBoundaries = windowBoundaries;
  }
  WindowOperator2.prototype.call = function(subscriber, source2) {
    var windowSubscriber = new WindowSubscriber$1(subscriber);
    var sourceSubscription = source2.subscribe(windowSubscriber);
    if (!sourceSubscription.closed) {
      windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber)));
    }
    return sourceSubscription;
  };
  return WindowOperator2;
}();
var WindowSubscriber$1 = /* @__PURE__ */ function(_super) {
  __extends(WindowSubscriber2, _super);
  function WindowSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.window = new Subject();
    destination.next(_this.window);
    return _this;
  }
  WindowSubscriber2.prototype.notifyNext = function() {
    this.openWindow();
  };
  WindowSubscriber2.prototype.notifyError = function(error) {
    this._error(error);
  };
  WindowSubscriber2.prototype.notifyComplete = function() {
    this._complete();
  };
  WindowSubscriber2.prototype._next = function(value) {
    this.window.next(value);
  };
  WindowSubscriber2.prototype._error = function(err) {
    this.window.error(err);
    this.destination.error(err);
  };
  WindowSubscriber2.prototype._complete = function() {
    this.window.complete();
    this.destination.complete();
  };
  WindowSubscriber2.prototype._unsubscribe = function() {
    this.window = null;
  };
  WindowSubscriber2.prototype.openWindow = function() {
    var prevWindow = this.window;
    if (prevWindow) {
      prevWindow.complete();
    }
    var destination = this.destination;
    var newWindow = this.window = new Subject();
    destination.next(newWindow);
  };
  return WindowSubscriber2;
}(SimpleOuterSubscriber);
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }
  return function windowCountOperatorFunction(source2) {
    return source2.lift(new WindowCountOperator(windowSize, startWindowEvery));
  };
}
var WindowCountOperator = /* @__PURE__ */ function() {
  function WindowCountOperator2(windowSize, startWindowEvery) {
    this.windowSize = windowSize;
    this.startWindowEvery = startWindowEvery;
  }
  WindowCountOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
  };
  return WindowCountOperator2;
}();
var WindowCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowCountSubscriber2, _super);
  function WindowCountSubscriber2(destination, windowSize, startWindowEvery) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.windowSize = windowSize;
    _this.startWindowEvery = startWindowEvery;
    _this.windows = [new Subject()];
    _this.count = 0;
    destination.next(_this.windows[0]);
    return _this;
  }
  WindowCountSubscriber2.prototype._next = function(value) {
    var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
    var destination = this.destination;
    var windowSize = this.windowSize;
    var windows = this.windows;
    var len = windows.length;
    for (var i2 = 0; i2 < len && !this.closed; i2++) {
      windows[i2].next(value);
    }
    var c = this.count - windowSize + 1;
    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
      windows.shift().complete();
    }
    if (++this.count % startWindowEvery === 0 && !this.closed) {
      var window_1 = new Subject();
      windows.push(window_1);
      destination.next(window_1);
    }
  };
  WindowCountSubscriber2.prototype._error = function(err) {
    var windows = this.windows;
    if (windows) {
      while (windows.length > 0 && !this.closed) {
        windows.shift().error(err);
      }
    }
    this.destination.error(err);
  };
  WindowCountSubscriber2.prototype._complete = function() {
    var windows = this.windows;
    if (windows) {
      while (windows.length > 0 && !this.closed) {
        windows.shift().complete();
      }
    }
    this.destination.complete();
  };
  WindowCountSubscriber2.prototype._unsubscribe = function() {
    this.count = 0;
    this.windows = null;
  };
  return WindowCountSubscriber2;
}(Subscriber);
function windowTime(windowTimeSpan) {
  var scheduler = async;
  var windowCreationInterval = null;
  var maxWindowSize = Number.POSITIVE_INFINITY;
  if (isScheduler(arguments[3])) {
    scheduler = arguments[3];
  }
  if (isScheduler(arguments[2])) {
    scheduler = arguments[2];
  } else if (isNumeric(arguments[2])) {
    maxWindowSize = Number(arguments[2]);
  }
  if (isScheduler(arguments[1])) {
    scheduler = arguments[1];
  } else if (isNumeric(arguments[1])) {
    windowCreationInterval = Number(arguments[1]);
  }
  return function windowTimeOperatorFunction(source2) {
    return source2.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
  };
}
var WindowTimeOperator = /* @__PURE__ */ function() {
  function WindowTimeOperator2(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
    this.windowTimeSpan = windowTimeSpan;
    this.windowCreationInterval = windowCreationInterval;
    this.maxWindowSize = maxWindowSize;
    this.scheduler = scheduler;
  }
  WindowTimeOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
  };
  return WindowTimeOperator2;
}();
var CountedSubject = /* @__PURE__ */ function(_super) {
  __extends(CountedSubject2, _super);
  function CountedSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._numberOfNextedValues = 0;
    return _this;
  }
  CountedSubject2.prototype.next = function(value) {
    this._numberOfNextedValues++;
    _super.prototype.next.call(this, value);
  };
  Object.defineProperty(CountedSubject2.prototype, "numberOfNextedValues", {
    get: function() {
      return this._numberOfNextedValues;
    },
    enumerable: true,
    configurable: true
  });
  return CountedSubject2;
}(Subject);
var WindowTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowTimeSubscriber2, _super);
  function WindowTimeSubscriber2(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.windowTimeSpan = windowTimeSpan;
    _this.windowCreationInterval = windowCreationInterval;
    _this.maxWindowSize = maxWindowSize;
    _this.scheduler = scheduler;
    _this.windows = [];
    var window2 = _this.openWindow();
    if (windowCreationInterval !== null && windowCreationInterval >= 0) {
      var closeState = { subscriber: _this, window: window2, context: null };
      var creationState = { windowTimeSpan, windowCreationInterval, subscriber: _this, scheduler };
      _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
      _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
    } else {
      var timeSpanOnlyState = { subscriber: _this, window: window2, windowTimeSpan };
      _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
    }
    return _this;
  }
  WindowTimeSubscriber2.prototype._next = function(value) {
    var windows = this.windows;
    var len = windows.length;
    for (var i2 = 0; i2 < len; i2++) {
      var window_1 = windows[i2];
      if (!window_1.closed) {
        window_1.next(value);
        if (window_1.numberOfNextedValues >= this.maxWindowSize) {
          this.closeWindow(window_1);
        }
      }
    }
  };
  WindowTimeSubscriber2.prototype._error = function(err) {
    var windows = this.windows;
    while (windows.length > 0) {
      windows.shift().error(err);
    }
    this.destination.error(err);
  };
  WindowTimeSubscriber2.prototype._complete = function() {
    var windows = this.windows;
    while (windows.length > 0) {
      var window_2 = windows.shift();
      if (!window_2.closed) {
        window_2.complete();
      }
    }
    this.destination.complete();
  };
  WindowTimeSubscriber2.prototype.openWindow = function() {
    var window2 = new CountedSubject();
    this.windows.push(window2);
    var destination = this.destination;
    destination.next(window2);
    return window2;
  };
  WindowTimeSubscriber2.prototype.closeWindow = function(window2) {
    window2.complete();
    var windows = this.windows;
    windows.splice(windows.indexOf(window2), 1);
  };
  return WindowTimeSubscriber2;
}(Subscriber);
function dispatchWindowTimeSpanOnly(state2) {
  var subscriber = state2.subscriber, windowTimeSpan = state2.windowTimeSpan, window2 = state2.window;
  if (window2) {
    subscriber.closeWindow(window2);
  }
  state2.window = subscriber.openWindow();
  this.schedule(state2, windowTimeSpan);
}
function dispatchWindowCreation(state2) {
  var windowTimeSpan = state2.windowTimeSpan, subscriber = state2.subscriber, scheduler = state2.scheduler, windowCreationInterval = state2.windowCreationInterval;
  var window2 = subscriber.openWindow();
  var action = this;
  var context2 = { action, subscription: null };
  var timeSpanState = { subscriber, window: window2, context: context2 };
  context2.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
  action.add(context2.subscription);
  action.schedule(state2, windowCreationInterval);
}
function dispatchWindowClose(state2) {
  var subscriber = state2.subscriber, window2 = state2.window, context2 = state2.context;
  if (context2 && context2.action && context2.subscription) {
    context2.action.remove(context2.subscription);
  }
  subscriber.closeWindow(window2);
}
function windowToggle(openings, closingSelector) {
  return function(source2) {
    return source2.lift(new WindowToggleOperator(openings, closingSelector));
  };
}
var WindowToggleOperator = /* @__PURE__ */ function() {
  function WindowToggleOperator2(openings, closingSelector) {
    this.openings = openings;
    this.closingSelector = closingSelector;
  }
  WindowToggleOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
  };
  return WindowToggleOperator2;
}();
var WindowToggleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowToggleSubscriber2, _super);
  function WindowToggleSubscriber2(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.openings = openings;
    _this.closingSelector = closingSelector;
    _this.contexts = [];
    _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
    return _this;
  }
  WindowToggleSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    if (contexts) {
      var len = contexts.length;
      for (var i2 = 0; i2 < len; i2++) {
        contexts[i2].window.next(value);
      }
    }
  };
  WindowToggleSubscriber2.prototype._error = function(err) {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len = contexts.length;
      var index2 = -1;
      while (++index2 < len) {
        var context_1 = contexts[index2];
        context_1.window.error(err);
        context_1.subscription.unsubscribe();
      }
    }
    _super.prototype._error.call(this, err);
  };
  WindowToggleSubscriber2.prototype._complete = function() {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len = contexts.length;
      var index2 = -1;
      while (++index2 < len) {
        var context_2 = contexts[index2];
        context_2.window.complete();
        context_2.subscription.unsubscribe();
      }
    }
    _super.prototype._complete.call(this);
  };
  WindowToggleSubscriber2.prototype._unsubscribe = function() {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len = contexts.length;
      var index2 = -1;
      while (++index2 < len) {
        var context_3 = contexts[index2];
        context_3.window.unsubscribe();
        context_3.subscription.unsubscribe();
      }
    }
  };
  WindowToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    if (outerValue === this.openings) {
      var closingNotifier = void 0;
      try {
        var closingSelector = this.closingSelector;
        closingNotifier = closingSelector(innerValue);
      } catch (e2) {
        return this.error(e2);
      }
      var window_1 = new Subject();
      var subscription = new Subscription();
      var context_4 = { window: window_1, subscription };
      this.contexts.push(context_4);
      var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
      if (innerSubscription.closed) {
        this.closeWindow(this.contexts.length - 1);
      } else {
        innerSubscription.context = context_4;
        subscription.add(innerSubscription);
      }
      this.destination.next(window_1);
    } else {
      this.closeWindow(this.contexts.indexOf(outerValue));
    }
  };
  WindowToggleSubscriber2.prototype.notifyError = function(err) {
    this.error(err);
  };
  WindowToggleSubscriber2.prototype.notifyComplete = function(inner) {
    if (inner !== this.openSubscription) {
      this.closeWindow(this.contexts.indexOf(inner.context));
    }
  };
  WindowToggleSubscriber2.prototype.closeWindow = function(index2) {
    if (index2 === -1) {
      return;
    }
    var contexts = this.contexts;
    var context2 = contexts[index2];
    var window2 = context2.window, subscription = context2.subscription;
    contexts.splice(index2, 1);
    window2.complete();
    subscription.unsubscribe();
  };
  return WindowToggleSubscriber2;
}(OuterSubscriber);
function windowWhen(closingSelector) {
  return function windowWhenOperatorFunction(source2) {
    return source2.lift(new WindowOperator(closingSelector));
  };
}
var WindowOperator = /* @__PURE__ */ function() {
  function WindowOperator2(closingSelector) {
    this.closingSelector = closingSelector;
  }
  WindowOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
  };
  return WindowOperator2;
}();
var WindowSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowSubscriber2, _super);
  function WindowSubscriber2(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.closingSelector = closingSelector;
    _this.openWindow();
    return _this;
  }
  WindowSubscriber2.prototype.notifyNext = function(_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
    this.openWindow(innerSub);
  };
  WindowSubscriber2.prototype.notifyError = function(error) {
    this._error(error);
  };
  WindowSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.openWindow(innerSub);
  };
  WindowSubscriber2.prototype._next = function(value) {
    this.window.next(value);
  };
  WindowSubscriber2.prototype._error = function(err) {
    this.window.error(err);
    this.destination.error(err);
    this.unsubscribeClosingNotification();
  };
  WindowSubscriber2.prototype._complete = function() {
    this.window.complete();
    this.destination.complete();
    this.unsubscribeClosingNotification();
  };
  WindowSubscriber2.prototype.unsubscribeClosingNotification = function() {
    if (this.closingNotification) {
      this.closingNotification.unsubscribe();
    }
  };
  WindowSubscriber2.prototype.openWindow = function(innerSub) {
    if (innerSub === void 0) {
      innerSub = null;
    }
    if (innerSub) {
      this.remove(innerSub);
      innerSub.unsubscribe();
    }
    var prevWindow = this.window;
    if (prevWindow) {
      prevWindow.complete();
    }
    var window2 = this.window = new Subject();
    this.destination.next(window2);
    var closingNotifier;
    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (e2) {
      this.destination.error(e2);
      this.window.error(e2);
      return;
    }
    this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
  };
  return WindowSubscriber2;
}(OuterSubscriber);
function withLatestFrom() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return function(source2) {
    var project;
    if (typeof args[args.length - 1] === "function") {
      project = args.pop();
    }
    var observables = args;
    return source2.lift(new WithLatestFromOperator(observables, project));
  };
}
var WithLatestFromOperator = /* @__PURE__ */ function() {
  function WithLatestFromOperator2(observables, project) {
    this.observables = observables;
    this.project = project;
  }
  WithLatestFromOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
  };
  return WithLatestFromOperator2;
}();
var WithLatestFromSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WithLatestFromSubscriber2, _super);
  function WithLatestFromSubscriber2(destination, observables, project) {
    var _this = _super.call(this, destination) || this;
    _this.observables = observables;
    _this.project = project;
    _this.toRespond = [];
    var len = observables.length;
    _this.values = new Array(len);
    for (var i2 = 0; i2 < len; i2++) {
      _this.toRespond.push(i2);
    }
    for (var i2 = 0; i2 < len; i2++) {
      var observable2 = observables[i2];
      _this.add(subscribeToResult(_this, observable2, void 0, i2));
    }
    return _this;
  }
  WithLatestFromSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    this.values[outerIndex] = innerValue;
    var toRespond = this.toRespond;
    if (toRespond.length > 0) {
      var found = toRespond.indexOf(outerIndex);
      if (found !== -1) {
        toRespond.splice(found, 1);
      }
    }
  };
  WithLatestFromSubscriber2.prototype.notifyComplete = function() {
  };
  WithLatestFromSubscriber2.prototype._next = function(value) {
    if (this.toRespond.length === 0) {
      var args = [value].concat(this.values);
      if (this.project) {
        this._tryProject(args);
      } else {
        this.destination.next(args);
      }
    }
  };
  WithLatestFromSubscriber2.prototype._tryProject = function(args) {
    var result;
    try {
      result = this.project.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return WithLatestFromSubscriber2;
}(OuterSubscriber);
function zip$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = observables[observables.length - 1];
  if (typeof resultSelector === "function") {
    observables.pop();
  }
  return fromArray(observables, void 0).lift(new ZipOperator(resultSelector));
}
var ZipOperator = /* @__PURE__ */ function() {
  function ZipOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  ZipOperator2.prototype.call = function(subscriber, source2) {
    return source2.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
  };
  return ZipOperator2;
}();
var ZipSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ZipSubscriber2, _super);
  function ZipSubscriber2(destination, resultSelector, values2) {
    var _this = _super.call(this, destination) || this;
    _this.resultSelector = resultSelector;
    _this.iterators = [];
    _this.active = 0;
    _this.resultSelector = typeof resultSelector === "function" ? resultSelector : void 0;
    return _this;
  }
  ZipSubscriber2.prototype._next = function(value) {
    var iterators = this.iterators;
    if (isArray$2(value)) {
      iterators.push(new StaticArrayIterator(value));
    } else if (typeof value[iterator] === "function") {
      iterators.push(new StaticIterator(value[iterator]()));
    } else {
      iterators.push(new ZipBufferIterator(this.destination, this, value));
    }
  };
  ZipSubscriber2.prototype._complete = function() {
    var iterators = this.iterators;
    var len = iterators.length;
    this.unsubscribe();
    if (len === 0) {
      this.destination.complete();
      return;
    }
    this.active = len;
    for (var i2 = 0; i2 < len; i2++) {
      var iterator2 = iterators[i2];
      if (iterator2.stillUnsubscribed) {
        var destination = this.destination;
        destination.add(iterator2.subscribe());
      } else {
        this.active--;
      }
    }
  };
  ZipSubscriber2.prototype.notifyInactive = function() {
    this.active--;
    if (this.active === 0) {
      this.destination.complete();
    }
  };
  ZipSubscriber2.prototype.checkIterators = function() {
    var iterators = this.iterators;
    var len = iterators.length;
    var destination = this.destination;
    for (var i2 = 0; i2 < len; i2++) {
      var iterator2 = iterators[i2];
      if (typeof iterator2.hasValue === "function" && !iterator2.hasValue()) {
        return;
      }
    }
    var shouldComplete = false;
    var args = [];
    for (var i2 = 0; i2 < len; i2++) {
      var iterator2 = iterators[i2];
      var result = iterator2.next();
      if (iterator2.hasCompleted()) {
        shouldComplete = true;
      }
      if (result.done) {
        destination.complete();
        return;
      }
      args.push(result.value);
    }
    if (this.resultSelector) {
      this._tryresultSelector(args);
    } else {
      destination.next(args);
    }
    if (shouldComplete) {
      destination.complete();
    }
  };
  ZipSubscriber2.prototype._tryresultSelector = function(args) {
    var result;
    try {
      result = this.resultSelector.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return ZipSubscriber2;
}(Subscriber);
var StaticIterator = /* @__PURE__ */ function() {
  function StaticIterator2(iterator2) {
    this.iterator = iterator2;
    this.nextResult = iterator2.next();
  }
  StaticIterator2.prototype.hasValue = function() {
    return true;
  };
  StaticIterator2.prototype.next = function() {
    var result = this.nextResult;
    this.nextResult = this.iterator.next();
    return result;
  };
  StaticIterator2.prototype.hasCompleted = function() {
    var nextResult = this.nextResult;
    return Boolean(nextResult && nextResult.done);
  };
  return StaticIterator2;
}();
var StaticArrayIterator = /* @__PURE__ */ function() {
  function StaticArrayIterator2(array) {
    this.array = array;
    this.index = 0;
    this.length = 0;
    this.length = array.length;
  }
  StaticArrayIterator2.prototype[iterator] = function() {
    return this;
  };
  StaticArrayIterator2.prototype.next = function(value) {
    var i2 = this.index++;
    var array = this.array;
    return i2 < this.length ? { value: array[i2], done: false } : { value: null, done: true };
  };
  StaticArrayIterator2.prototype.hasValue = function() {
    return this.array.length > this.index;
  };
  StaticArrayIterator2.prototype.hasCompleted = function() {
    return this.array.length === this.index;
  };
  return StaticArrayIterator2;
}();
var ZipBufferIterator = /* @__PURE__ */ function(_super) {
  __extends(ZipBufferIterator2, _super);
  function ZipBufferIterator2(destination, parent2, observable2) {
    var _this = _super.call(this, destination) || this;
    _this.parent = parent2;
    _this.observable = observable2;
    _this.stillUnsubscribed = true;
    _this.buffer = [];
    _this.isComplete = false;
    return _this;
  }
  ZipBufferIterator2.prototype[iterator] = function() {
    return this;
  };
  ZipBufferIterator2.prototype.next = function() {
    var buffer2 = this.buffer;
    if (buffer2.length === 0 && this.isComplete) {
      return { value: null, done: true };
    } else {
      return { value: buffer2.shift(), done: false };
    }
  };
  ZipBufferIterator2.prototype.hasValue = function() {
    return this.buffer.length > 0;
  };
  ZipBufferIterator2.prototype.hasCompleted = function() {
    return this.buffer.length === 0 && this.isComplete;
  };
  ZipBufferIterator2.prototype.notifyComplete = function() {
    if (this.buffer.length > 0) {
      this.isComplete = true;
      this.parent.notifyInactive();
    } else {
      this.destination.complete();
    }
  };
  ZipBufferIterator2.prototype.notifyNext = function(innerValue) {
    this.buffer.push(innerValue);
    this.parent.checkIterators();
  };
  ZipBufferIterator2.prototype.subscribe = function() {
    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
  };
  return ZipBufferIterator2;
}(SimpleOuterSubscriber);
function zip() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function zipOperatorFunction(source2) {
    return source2.lift.call(zip$1.apply(void 0, [source2].concat(observables)));
  };
}
function zipAll(project) {
  return function(source2) {
    return source2.lift(new ZipOperator(project));
  };
}
var operators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audit,
  auditTime,
  buffer,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  combineAll,
  combineLatest,
  concat,
  concatAll,
  concatMap,
  concatMapTo,
  count,
  debounce,
  debounceTime,
  defaultIfEmpty,
  delay,
  delayWhen,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  elementAt,
  endWith,
  every,
  exhaust,
  exhaustMap,
  expand,
  filter,
  finalize,
  find: find$1,
  findIndex,
  first,
  groupBy,
  ignoreElements,
  isEmpty,
  last,
  map,
  mapTo,
  materialize,
  max,
  merge: merge$1,
  mergeAll,
  mergeMap,
  flatMap,
  mergeMapTo,
  mergeScan,
  min,
  multicast,
  observeOn,
  onErrorResumeNext,
  pairwise,
  partition,
  pluck,
  publish,
  publishBehavior,
  publishLast,
  publishReplay,
  race,
  reduce,
  repeat,
  repeatWhen,
  retry,
  retryWhen,
  refCount,
  sample,
  sampleTime,
  scan,
  sequenceEqual,
  share,
  shareReplay,
  single,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  subscribeOn,
  switchAll,
  switchMap,
  switchMapTo,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  throwIfEmpty,
  timeInterval,
  timeout,
  timeoutWith,
  timestamp,
  toArray,
  window: window$1,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zip,
  zipAll
}, Symbol.toStringTag, { value: "Module" }));
var require$$2 = /* @__PURE__ */ getAugmentedNamespace(operators);
var struct = {};
(function(exports2) {
  var __createBinding2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar2 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __importDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ListValue = exports2.Value = exports2.Struct_FieldsEntry = exports2.Struct = exports2.nullValueToNumber = exports2.nullValueToJSON = exports2.nullValueFromJSON = exports2.NullValue = exports2.protobufPackage = void 0;
  const long_12 = __importDefault2(umd.exports);
  const _m02 = __importStar2(minimal$2);
  exports2.protobufPackage = "google.protobuf";
  var NullValue;
  (function(NullValue2) {
    NullValue2["NULL_VALUE"] = "NULL_VALUE";
  })(NullValue = exports2.NullValue || (exports2.NullValue = {}));
  function nullValueFromJSON(object) {
    switch (object) {
      case 0:
      case "NULL_VALUE":
        return NullValue.NULL_VALUE;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum NullValue");
    }
  }
  exports2.nullValueFromJSON = nullValueFromJSON;
  function nullValueToJSON(object) {
    switch (object) {
      case NullValue.NULL_VALUE:
        return "NULL_VALUE";
      default:
        return "UNKNOWN";
    }
  }
  exports2.nullValueToJSON = nullValueToJSON;
  function nullValueToNumber(object) {
    switch (object) {
      case NullValue.NULL_VALUE:
        return 0;
      default:
        return 0;
    }
  }
  exports2.nullValueToNumber = nullValueToNumber;
  function createBaseStruct() {
    return { fields: {} };
  }
  exports2.Struct = {
    encode(message, writer2 = _m02.Writer.create()) {
      Object.entries(message.fields).forEach(([key, value]) => {
        if (value !== void 0) {
          exports2.Struct_FieldsEntry.encode({ key, value }, writer2.uint32(10).fork()).ldelim();
        }
      });
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseStruct();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            const entry1 = exports2.Struct_FieldsEntry.decode(reader2, reader2.uint32());
            if (entry1.value !== void 0) {
              message.fields[entry1.key] = entry1.value;
            }
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        fields: isObject2(object.fields) ? Object.entries(object.fields).reduce((acc, [key, value]) => {
          acc[key] = value;
          return acc;
        }, {}) : {}
      };
    },
    toJSON(message) {
      const obj = {};
      obj.fields = {};
      if (message.fields) {
        Object.entries(message.fields).forEach(([k, v]) => {
          obj.fields[k] = v;
        });
      }
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseStruct();
      message.fields = Object.entries((_a2 = object.fields) !== null && _a2 !== void 0 ? _a2 : {}).reduce((acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = value;
        }
        return acc;
      }, {});
      return message;
    },
    wrap(object) {
      const struct2 = createBaseStruct();
      if (object !== void 0) {
        Object.keys(object).forEach((key) => {
          struct2.fields[key] = object[key];
        });
      }
      return struct2;
    },
    unwrap(message) {
      const object = {};
      Object.keys(message.fields).forEach((key) => {
        object[key] = message.fields[key];
      });
      return object;
    }
  };
  function createBaseStruct_FieldsEntry() {
    return { key: "", value: void 0 };
  }
  exports2.Struct_FieldsEntry = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.key !== "") {
        writer2.uint32(10).string(message.key);
      }
      if (message.value !== void 0) {
        exports2.Value.encode(exports2.Value.wrap(message.value), writer2.uint32(18).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseStruct_FieldsEntry();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.key = reader2.string();
            break;
          case 2:
            message.value = exports2.Value.unwrap(exports2.Value.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        key: isSet2(object.key) ? String(object.key) : "",
        value: isSet2(object === null || object === void 0 ? void 0 : object.value) ? object.value : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.key !== void 0 && (obj.key = message.key);
      message.value !== void 0 && (obj.value = message.value);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseStruct_FieldsEntry();
      message.key = (_a2 = object.key) !== null && _a2 !== void 0 ? _a2 : "";
      message.value = (_b = object.value) !== null && _b !== void 0 ? _b : void 0;
      return message;
    }
  };
  function createBaseValue() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  exports2.Value = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.nullValue !== void 0) {
        writer2.uint32(8).int32(nullValueToNumber(message.nullValue));
      }
      if (message.numberValue !== void 0) {
        writer2.uint32(17).double(message.numberValue);
      }
      if (message.stringValue !== void 0) {
        writer2.uint32(26).string(message.stringValue);
      }
      if (message.boolValue !== void 0) {
        writer2.uint32(32).bool(message.boolValue);
      }
      if (message.structValue !== void 0) {
        exports2.Struct.encode(exports2.Struct.wrap(message.structValue), writer2.uint32(42).fork()).ldelim();
      }
      if (message.listValue !== void 0) {
        exports2.ListValue.encode(exports2.ListValue.wrap(message.listValue), writer2.uint32(50).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseValue();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.nullValue = nullValueFromJSON(reader2.int32());
            break;
          case 2:
            message.numberValue = reader2.double();
            break;
          case 3:
            message.stringValue = reader2.string();
            break;
          case 4:
            message.boolValue = reader2.bool();
            break;
          case 5:
            message.structValue = exports2.Struct.unwrap(exports2.Struct.decode(reader2, reader2.uint32()));
            break;
          case 6:
            message.listValue = exports2.ListValue.unwrap(exports2.ListValue.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        nullValue: isSet2(object.nullValue) ? nullValueFromJSON(object.nullValue) : void 0,
        numberValue: isSet2(object.numberValue) ? Number(object.numberValue) : void 0,
        stringValue: isSet2(object.stringValue) ? String(object.stringValue) : void 0,
        boolValue: isSet2(object.boolValue) ? Boolean(object.boolValue) : void 0,
        structValue: isObject2(object.structValue) ? object.structValue : void 0,
        listValue: Array.isArray(object.listValue) ? [...object.listValue] : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.nullValue !== void 0 && (obj.nullValue = message.nullValue !== void 0 ? nullValueToJSON(message.nullValue) : void 0);
      message.numberValue !== void 0 && (obj.numberValue = message.numberValue);
      message.stringValue !== void 0 && (obj.stringValue = message.stringValue);
      message.boolValue !== void 0 && (obj.boolValue = message.boolValue);
      message.structValue !== void 0 && (obj.structValue = message.structValue);
      message.listValue !== void 0 && (obj.listValue = message.listValue);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d, _e, _f;
      const message = createBaseValue();
      message.nullValue = (_a2 = object.nullValue) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.numberValue = (_b = object.numberValue) !== null && _b !== void 0 ? _b : void 0;
      message.stringValue = (_c = object.stringValue) !== null && _c !== void 0 ? _c : void 0;
      message.boolValue = (_d = object.boolValue) !== null && _d !== void 0 ? _d : void 0;
      message.structValue = (_e = object.structValue) !== null && _e !== void 0 ? _e : void 0;
      message.listValue = (_f = object.listValue) !== null && _f !== void 0 ? _f : void 0;
      return message;
    },
    wrap(value) {
      const result = createBaseValue();
      if (value === null) {
        result.nullValue = NullValue.NULL_VALUE;
      } else if (typeof value === "boolean") {
        result.boolValue = value;
      } else if (typeof value === "number") {
        result.numberValue = value;
      } else if (typeof value === "string") {
        result.stringValue = value;
      } else if (Array.isArray(value)) {
        result.listValue = value;
      } else if (typeof value === "object") {
        result.structValue = value;
      } else if (typeof value !== "undefined") {
        throw new Error("Unsupported any value type: " + typeof value);
      }
      return result;
    },
    unwrap(message) {
      if ((message === null || message === void 0 ? void 0 : message.stringValue) !== void 0) {
        return message.stringValue;
      } else if ((message === null || message === void 0 ? void 0 : message.numberValue) !== void 0) {
        return message.numberValue;
      } else if ((message === null || message === void 0 ? void 0 : message.boolValue) !== void 0) {
        return message.boolValue;
      } else if ((message === null || message === void 0 ? void 0 : message.structValue) !== void 0) {
        return message.structValue;
      } else if ((message === null || message === void 0 ? void 0 : message.listValue) !== void 0) {
        return message.listValue;
      } else if ((message === null || message === void 0 ? void 0 : message.nullValue) !== void 0) {
        return null;
      }
      return void 0;
    }
  };
  function createBaseListValue() {
    return { values: [] };
  }
  exports2.ListValue = {
    encode(message, writer2 = _m02.Writer.create()) {
      for (const v of message.values) {
        exports2.Value.encode(exports2.Value.wrap(v), writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseListValue();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.values.push(exports2.Value.unwrap(exports2.Value.decode(reader2, reader2.uint32())));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        values: Array.isArray(object === null || object === void 0 ? void 0 : object.values) ? [...object.values] : []
      };
    },
    toJSON(message) {
      const obj = {};
      if (message.values) {
        obj.values = message.values.map((e2) => e2);
      } else {
        obj.values = [];
      }
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseListValue();
      message.values = ((_a2 = object.values) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
      return message;
    },
    wrap(value) {
      const result = createBaseListValue();
      result.values = value !== null && value !== void 0 ? value : [];
      return result;
    },
    unwrap(message) {
      return message.values;
    }
  };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal$1 !== "undefined")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  if (_m02.util.Long !== long_12.default) {
    _m02.util.Long = long_12.default;
    _m02.configure();
  }
  function isObject2(value) {
    return typeof value === "object" && value !== null;
  }
  function isSet2(value) {
    return value !== null && value !== void 0;
  }
})(struct);
(function(exports2) {
  var __createBinding2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar2 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __importDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.EventServiceDefinition = exports2.EventServiceClientImpl = exports2.EventsStreamResponse = exports2.EventsStreamRequest = exports2.EventsStreamReconnectRequest = exports2.EventsStreamError = exports2.SubscribePayload = exports2.PublishEventResponse = exports2.PublishEventRequest = exports2.EventTarget = exports2.eventsStreamMessageTypeToNumber = exports2.eventsStreamMessageTypeToJSON = exports2.eventsStreamMessageTypeFromJSON = exports2.EventsStreamMessageType = exports2.protobufPackage = void 0;
  const long_12 = __importDefault2(umd.exports);
  const _m02 = __importStar2(minimal$2);
  const operators_1 = require$$2;
  const struct_1 = struct;
  exports2.protobufPackage = "apis.event.v2";
  var EventsStreamMessageType;
  (function(EventsStreamMessageType2) {
    EventsStreamMessageType2["EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED"] = "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED";
    EventsStreamMessageType2["EVENTS_STREAM_MESSAGE_TYPE_PING"] = "EVENTS_STREAM_MESSAGE_TYPE_PING";
    EventsStreamMessageType2["EVENTS_STREAM_MESSAGE_TYPE_ERROR"] = "EVENTS_STREAM_MESSAGE_TYPE_ERROR";
    EventsStreamMessageType2["EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED"] = "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED";
    EventsStreamMessageType2["EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED"] = "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED";
    EventsStreamMessageType2["EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED"] = "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED";
  })(EventsStreamMessageType = exports2.EventsStreamMessageType || (exports2.EventsStreamMessageType = {}));
  function eventsStreamMessageTypeFromJSON(object) {
    switch (object) {
      case 0:
      case "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED":
        return EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED;
      case 1:
      case "EVENTS_STREAM_MESSAGE_TYPE_PING":
        return EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_PING;
      case 2:
      case "EVENTS_STREAM_MESSAGE_TYPE_ERROR":
        return EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_ERROR;
      case 3:
      case "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED":
        return EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED;
      case 4:
      case "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED":
        return EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED;
      case 5:
      case "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED":
        return EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED;
      default:
        throw new globalThis2.Error("Unrecognized enum value " + object + " for enum EventsStreamMessageType");
    }
  }
  exports2.eventsStreamMessageTypeFromJSON = eventsStreamMessageTypeFromJSON;
  function eventsStreamMessageTypeToJSON(object) {
    switch (object) {
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED:
        return "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED";
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_PING:
        return "EVENTS_STREAM_MESSAGE_TYPE_PING";
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_ERROR:
        return "EVENTS_STREAM_MESSAGE_TYPE_ERROR";
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED:
        return "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED";
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED:
        return "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED";
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED:
        return "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED";
      default:
        return "UNKNOWN";
    }
  }
  exports2.eventsStreamMessageTypeToJSON = eventsStreamMessageTypeToJSON;
  function eventsStreamMessageTypeToNumber(object) {
    switch (object) {
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED:
        return 0;
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_PING:
        return 1;
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_ERROR:
        return 2;
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED:
        return 3;
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED:
        return 4;
      case EventsStreamMessageType.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED:
        return 5;
      default:
        return 0;
    }
  }
  exports2.eventsStreamMessageTypeToNumber = eventsStreamMessageTypeToNumber;
  function createBaseEventTarget() {
    return { collectionId: void 0, projectId: void 0, layoutId: void 0 };
  }
  exports2.EventTarget = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.collectionId !== void 0) {
        writer2.uint32(42).string(message.collectionId);
      }
      if (message.projectId !== void 0) {
        writer2.uint32(34).string(message.projectId);
      }
      if (message.layoutId !== void 0) {
        writer2.uint32(10).string(message.layoutId);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseEventTarget();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 5:
            message.collectionId = reader2.string();
            break;
          case 4:
            message.projectId = reader2.string();
            break;
          case 1:
            message.layoutId = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        collectionId: isSet2(object.collectionId) ? String(object.collectionId) : void 0,
        projectId: isSet2(object.projectId) ? String(object.projectId) : void 0,
        layoutId: isSet2(object.layoutId) ? String(object.layoutId) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.collectionId !== void 0 && (obj.collectionId = message.collectionId);
      message.projectId !== void 0 && (obj.projectId = message.projectId);
      message.layoutId !== void 0 && (obj.layoutId = message.layoutId);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseEventTarget();
      message.collectionId = (_a2 = object.collectionId) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.projectId = (_b = object.projectId) !== null && _b !== void 0 ? _b : void 0;
      message.layoutId = (_c = object.layoutId) !== null && _c !== void 0 ? _c : void 0;
      return message;
    }
  };
  function createBasePublishEventRequest() {
    return {
      name: "",
      payload: void 0,
      requestMetadata: void 0,
      target: void 0
    };
  }
  exports2.PublishEventRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.name !== "") {
        writer2.uint32(10).string(message.name);
      }
      if (message.payload !== void 0) {
        struct_1.Struct.encode(struct_1.Struct.wrap(message.payload), writer2.uint32(18).fork()).ldelim();
      }
      if (message.requestMetadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(34).fork()).ldelim();
      }
      if (message.target !== void 0) {
        exports2.EventTarget.encode(message.target, writer2.uint32(26).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBasePublishEventRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.name = reader2.string();
            break;
          case 2:
            message.payload = struct_1.Struct.unwrap(struct_1.Struct.decode(reader2, reader2.uint32()));
            break;
          case 4:
            message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 3:
            message.target = exports2.EventTarget.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        name: isSet2(object.name) ? String(object.name) : "",
        payload: isObject2(object.payload) ? object.payload : void 0,
        requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0,
        target: isSet2(object.target) ? exports2.EventTarget.fromJSON(object.target) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.name !== void 0 && (obj.name = message.name);
      message.payload !== void 0 && (obj.payload = message.payload);
      message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
      message.target !== void 0 && (obj.target = message.target ? exports2.EventTarget.toJSON(message.target) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBasePublishEventRequest();
      message.name = (_a2 = object.name) !== null && _a2 !== void 0 ? _a2 : "";
      message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : void 0;
      message.requestMetadata = (_c = object.requestMetadata) !== null && _c !== void 0 ? _c : void 0;
      message.target = object.target !== void 0 && object.target !== null ? exports2.EventTarget.fromPartial(object.target) : void 0;
      return message;
    }
  };
  function createBasePublishEventResponse() {
    return {
      name: "",
      payload: void 0,
      target: void 0,
      requestMetadata: void 0,
      id: ""
    };
  }
  exports2.PublishEventResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.name !== "") {
        writer2.uint32(10).string(message.name);
      }
      if (message.payload !== void 0) {
        struct_1.Struct.encode(struct_1.Struct.wrap(message.payload), writer2.uint32(18).fork()).ldelim();
      }
      if (message.target !== void 0) {
        exports2.EventTarget.encode(message.target, writer2.uint32(26).fork()).ldelim();
      }
      if (message.requestMetadata !== void 0) {
        struct_1.Value.encode(struct_1.Value.wrap(message.requestMetadata), writer2.uint32(34).fork()).ldelim();
      }
      if (message.id !== "") {
        writer2.uint32(42).string(message.id);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBasePublishEventResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.name = reader2.string();
            break;
          case 2:
            message.payload = struct_1.Struct.unwrap(struct_1.Struct.decode(reader2, reader2.uint32()));
            break;
          case 3:
            message.target = exports2.EventTarget.decode(reader2, reader2.uint32());
            break;
          case 4:
            message.requestMetadata = struct_1.Value.unwrap(struct_1.Value.decode(reader2, reader2.uint32()));
            break;
          case 5:
            message.id = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        name: isSet2(object.name) ? String(object.name) : "",
        payload: isObject2(object.payload) ? object.payload : void 0,
        target: isSet2(object.target) ? exports2.EventTarget.fromJSON(object.target) : void 0,
        requestMetadata: isSet2(object === null || object === void 0 ? void 0 : object.requestMetadata) ? object.requestMetadata : void 0,
        id: isSet2(object.id) ? String(object.id) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.name !== void 0 && (obj.name = message.name);
      message.payload !== void 0 && (obj.payload = message.payload);
      message.target !== void 0 && (obj.target = message.target ? exports2.EventTarget.toJSON(message.target) : void 0);
      message.requestMetadata !== void 0 && (obj.requestMetadata = message.requestMetadata);
      message.id !== void 0 && (obj.id = message.id);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c, _d;
      const message = createBasePublishEventResponse();
      message.name = (_a2 = object.name) !== null && _a2 !== void 0 ? _a2 : "";
      message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : void 0;
      message.target = object.target !== void 0 && object.target !== null ? exports2.EventTarget.fromPartial(object.target) : void 0;
      message.requestMetadata = (_c = object.requestMetadata) !== null && _c !== void 0 ? _c : void 0;
      message.id = (_d = object.id) !== null && _d !== void 0 ? _d : "";
      return message;
    }
  };
  function createBaseSubscribePayload() {
    return { name: "", target: void 0 };
  }
  exports2.SubscribePayload = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.name !== "") {
        writer2.uint32(10).string(message.name);
      }
      if (message.target !== void 0) {
        exports2.EventTarget.encode(message.target, writer2.uint32(18).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseSubscribePayload();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.name = reader2.string();
            break;
          case 2:
            message.target = exports2.EventTarget.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        name: isSet2(object.name) ? String(object.name) : "",
        target: isSet2(object.target) ? exports2.EventTarget.fromJSON(object.target) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.name !== void 0 && (obj.name = message.name);
      message.target !== void 0 && (obj.target = message.target ? exports2.EventTarget.toJSON(message.target) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2;
      const message = createBaseSubscribePayload();
      message.name = (_a2 = object.name) !== null && _a2 !== void 0 ? _a2 : "";
      message.target = object.target !== void 0 && object.target !== null ? exports2.EventTarget.fromPartial(object.target) : void 0;
      return message;
    }
  };
  function createBaseEventsStreamError() {
    return { code: 0, message: "" };
  }
  exports2.EventsStreamError = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.code !== 0) {
        writer2.uint32(8).int32(message.code);
      }
      if (message.message !== "") {
        writer2.uint32(18).string(message.message);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseEventsStreamError();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.code = reader2.int32();
            break;
          case 2:
            message.message = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        code: isSet2(object.code) ? Number(object.code) : 0,
        message: isSet2(object.message) ? String(object.message) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.code !== void 0 && (obj.code = Math.round(message.code));
      message.message !== void 0 && (obj.message = message.message);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseEventsStreamError();
      message.code = (_a2 = object.code) !== null && _a2 !== void 0 ? _a2 : 0;
      message.message = (_b = object.message) !== null && _b !== void 0 ? _b : "";
      return message;
    }
  };
  function createBaseEventsStreamReconnectRequest() {
    return { reauthenticate: false, beforeTimestamp: "" };
  }
  exports2.EventsStreamReconnectRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.reauthenticate === true) {
        writer2.uint32(8).bool(message.reauthenticate);
      }
      if (message.beforeTimestamp !== "") {
        writer2.uint32(18).string(message.beforeTimestamp);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseEventsStreamReconnectRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.reauthenticate = reader2.bool();
            break;
          case 2:
            message.beforeTimestamp = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        reauthenticate: isSet2(object.reauthenticate) ? Boolean(object.reauthenticate) : false,
        beforeTimestamp: isSet2(object.beforeTimestamp) ? String(object.beforeTimestamp) : ""
      };
    },
    toJSON(message) {
      const obj = {};
      message.reauthenticate !== void 0 && (obj.reauthenticate = message.reauthenticate);
      message.beforeTimestamp !== void 0 && (obj.beforeTimestamp = message.beforeTimestamp);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseEventsStreamReconnectRequest();
      message.reauthenticate = (_a2 = object.reauthenticate) !== null && _a2 !== void 0 ? _a2 : false;
      message.beforeTimestamp = (_b = object.beforeTimestamp) !== null && _b !== void 0 ? _b : "";
      return message;
    }
  };
  function createBaseEventsStreamRequest() {
    return {
      correlationId: void 0,
      subscribe: void 0,
      unsubscribe: void 0,
      publish: void 0,
      ping: void 0
    };
  }
  exports2.EventsStreamRequest = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.correlationId !== void 0) {
        writer2.uint32(10).string(message.correlationId);
      }
      if (message.subscribe !== void 0) {
        exports2.SubscribePayload.encode(message.subscribe, writer2.uint32(802).fork()).ldelim();
      }
      if (message.unsubscribe !== void 0) {
        exports2.SubscribePayload.encode(message.unsubscribe, writer2.uint32(810).fork()).ldelim();
      }
      if (message.publish !== void 0) {
        exports2.PublishEventRequest.encode(message.publish, writer2.uint32(818).fork()).ldelim();
      }
      if (message.ping !== void 0) {
        writer2.uint32(826).string(message.ping);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseEventsStreamRequest();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.correlationId = reader2.string();
            break;
          case 100:
            message.subscribe = exports2.SubscribePayload.decode(reader2, reader2.uint32());
            break;
          case 101:
            message.unsubscribe = exports2.SubscribePayload.decode(reader2, reader2.uint32());
            break;
          case 102:
            message.publish = exports2.PublishEventRequest.decode(reader2, reader2.uint32());
            break;
          case 103:
            message.ping = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        correlationId: isSet2(object.correlationId) ? String(object.correlationId) : void 0,
        subscribe: isSet2(object.subscribe) ? exports2.SubscribePayload.fromJSON(object.subscribe) : void 0,
        unsubscribe: isSet2(object.unsubscribe) ? exports2.SubscribePayload.fromJSON(object.unsubscribe) : void 0,
        publish: isSet2(object.publish) ? exports2.PublishEventRequest.fromJSON(object.publish) : void 0,
        ping: isSet2(object.ping) ? String(object.ping) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.correlationId !== void 0 && (obj.correlationId = message.correlationId);
      message.subscribe !== void 0 && (obj.subscribe = message.subscribe ? exports2.SubscribePayload.toJSON(message.subscribe) : void 0);
      message.unsubscribe !== void 0 && (obj.unsubscribe = message.unsubscribe ? exports2.SubscribePayload.toJSON(message.unsubscribe) : void 0);
      message.publish !== void 0 && (obj.publish = message.publish ? exports2.PublishEventRequest.toJSON(message.publish) : void 0);
      message.ping !== void 0 && (obj.ping = message.ping);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b;
      const message = createBaseEventsStreamRequest();
      message.correlationId = (_a2 = object.correlationId) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.subscribe = object.subscribe !== void 0 && object.subscribe !== null ? exports2.SubscribePayload.fromPartial(object.subscribe) : void 0;
      message.unsubscribe = object.unsubscribe !== void 0 && object.unsubscribe !== null ? exports2.SubscribePayload.fromPartial(object.unsubscribe) : void 0;
      message.publish = object.publish !== void 0 && object.publish !== null ? exports2.PublishEventRequest.fromPartial(object.publish) : void 0;
      message.ping = (_b = object.ping) !== null && _b !== void 0 ? _b : void 0;
      return message;
    }
  };
  function createBaseEventsStreamResponse() {
    return {
      correlationId: void 0,
      sessionId: void 0,
      event: void 0,
      pong: void 0,
      error: void 0,
      subscribed: void 0,
      unsubscribed: void 0,
      published: void 0,
      reconnectBefore: void 0
    };
  }
  exports2.EventsStreamResponse = {
    encode(message, writer2 = _m02.Writer.create()) {
      if (message.correlationId !== void 0) {
        writer2.uint32(18).string(message.correlationId);
      }
      if (message.sessionId !== void 0) {
        writer2.uint32(26).string(message.sessionId);
      }
      if (message.event !== void 0) {
        exports2.PublishEventResponse.encode(message.event, writer2.uint32(802).fork()).ldelim();
      }
      if (message.pong !== void 0) {
        writer2.uint32(1602).string(message.pong);
      }
      if (message.error !== void 0) {
        exports2.EventsStreamError.encode(message.error, writer2.uint32(1610).fork()).ldelim();
      }
      if (message.subscribed !== void 0) {
        exports2.SubscribePayload.encode(message.subscribed, writer2.uint32(1618).fork()).ldelim();
      }
      if (message.unsubscribed !== void 0) {
        exports2.SubscribePayload.encode(message.unsubscribed, writer2.uint32(1626).fork()).ldelim();
      }
      if (message.published !== void 0) {
        exports2.PublishEventResponse.encode(message.published, writer2.uint32(1634).fork()).ldelim();
      }
      if (message.reconnectBefore !== void 0) {
        exports2.EventsStreamReconnectRequest.encode(message.reconnectBefore, writer2.uint32(1642).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof _m02.Reader ? input : new _m02.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = createBaseEventsStreamResponse();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 2:
            message.correlationId = reader2.string();
            break;
          case 3:
            message.sessionId = reader2.string();
            break;
          case 100:
            message.event = exports2.PublishEventResponse.decode(reader2, reader2.uint32());
            break;
          case 200:
            message.pong = reader2.string();
            break;
          case 201:
            message.error = exports2.EventsStreamError.decode(reader2, reader2.uint32());
            break;
          case 202:
            message.subscribed = exports2.SubscribePayload.decode(reader2, reader2.uint32());
            break;
          case 203:
            message.unsubscribed = exports2.SubscribePayload.decode(reader2, reader2.uint32());
            break;
          case 204:
            message.published = exports2.PublishEventResponse.decode(reader2, reader2.uint32());
            break;
          case 205:
            message.reconnectBefore = exports2.EventsStreamReconnectRequest.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      return {
        correlationId: isSet2(object.correlationId) ? String(object.correlationId) : void 0,
        sessionId: isSet2(object.sessionId) ? String(object.sessionId) : void 0,
        event: isSet2(object.event) ? exports2.PublishEventResponse.fromJSON(object.event) : void 0,
        pong: isSet2(object.pong) ? String(object.pong) : void 0,
        error: isSet2(object.error) ? exports2.EventsStreamError.fromJSON(object.error) : void 0,
        subscribed: isSet2(object.subscribed) ? exports2.SubscribePayload.fromJSON(object.subscribed) : void 0,
        unsubscribed: isSet2(object.unsubscribed) ? exports2.SubscribePayload.fromJSON(object.unsubscribed) : void 0,
        published: isSet2(object.published) ? exports2.PublishEventResponse.fromJSON(object.published) : void 0,
        reconnectBefore: isSet2(object.reconnectBefore) ? exports2.EventsStreamReconnectRequest.fromJSON(object.reconnectBefore) : void 0
      };
    },
    toJSON(message) {
      const obj = {};
      message.correlationId !== void 0 && (obj.correlationId = message.correlationId);
      message.sessionId !== void 0 && (obj.sessionId = message.sessionId);
      message.event !== void 0 && (obj.event = message.event ? exports2.PublishEventResponse.toJSON(message.event) : void 0);
      message.pong !== void 0 && (obj.pong = message.pong);
      message.error !== void 0 && (obj.error = message.error ? exports2.EventsStreamError.toJSON(message.error) : void 0);
      message.subscribed !== void 0 && (obj.subscribed = message.subscribed ? exports2.SubscribePayload.toJSON(message.subscribed) : void 0);
      message.unsubscribed !== void 0 && (obj.unsubscribed = message.unsubscribed ? exports2.SubscribePayload.toJSON(message.unsubscribed) : void 0);
      message.published !== void 0 && (obj.published = message.published ? exports2.PublishEventResponse.toJSON(message.published) : void 0);
      message.reconnectBefore !== void 0 && (obj.reconnectBefore = message.reconnectBefore ? exports2.EventsStreamReconnectRequest.toJSON(message.reconnectBefore) : void 0);
      return obj;
    },
    fromPartial(object) {
      var _a2, _b, _c;
      const message = createBaseEventsStreamResponse();
      message.correlationId = (_a2 = object.correlationId) !== null && _a2 !== void 0 ? _a2 : void 0;
      message.sessionId = (_b = object.sessionId) !== null && _b !== void 0 ? _b : void 0;
      message.event = object.event !== void 0 && object.event !== null ? exports2.PublishEventResponse.fromPartial(object.event) : void 0;
      message.pong = (_c = object.pong) !== null && _c !== void 0 ? _c : void 0;
      message.error = object.error !== void 0 && object.error !== null ? exports2.EventsStreamError.fromPartial(object.error) : void 0;
      message.subscribed = object.subscribed !== void 0 && object.subscribed !== null ? exports2.SubscribePayload.fromPartial(object.subscribed) : void 0;
      message.unsubscribed = object.unsubscribed !== void 0 && object.unsubscribed !== null ? exports2.SubscribePayload.fromPartial(object.unsubscribed) : void 0;
      message.published = object.published !== void 0 && object.published !== null ? exports2.PublishEventResponse.fromPartial(object.published) : void 0;
      message.reconnectBefore = object.reconnectBefore !== void 0 && object.reconnectBefore !== null ? exports2.EventsStreamReconnectRequest.fromPartial(object.reconnectBefore) : void 0;
      return message;
    }
  };
  class EventServiceClientImpl {
    constructor(rpc2) {
      this.rpc = rpc2;
      this.Stream = this.Stream.bind(this);
      this.Publish = this.Publish.bind(this);
    }
    Stream(request3) {
      const data2 = request3.pipe(operators_1.map((request4) => exports2.EventsStreamRequest.encode(request4).finish()));
      const result = this.rpc.bidirectionalStreamingRequest("apis.event.v2.EventService", "Stream", data2);
      return result.pipe(operators_1.map((data3) => exports2.EventsStreamResponse.decode(new _m02.Reader(data3))));
    }
    Publish(request3) {
      const data2 = exports2.PublishEventRequest.encode(request3).finish();
      const promise = this.rpc.request("apis.event.v2.EventService", "Publish", data2);
      return promise.then((data3) => exports2.PublishEventResponse.decode(new _m02.Reader(data3)));
    }
  }
  exports2.EventServiceClientImpl = EventServiceClientImpl;
  exports2.EventServiceDefinition = {
    name: "EventService",
    fullName: "apis.event.v2.EventService",
    methods: {
      stream: {
        name: "Stream",
        requestType: exports2.EventsStreamRequest,
        requestStream: true,
        responseType: exports2.EventsStreamResponse,
        responseStream: true,
        options: {}
      },
      publish: {
        name: "Publish",
        requestType: exports2.PublishEventRequest,
        requestStream: false,
        responseType: exports2.PublishEventResponse,
        responseStream: false,
        options: {}
      }
    }
  };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal$1 !== "undefined")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  if (_m02.util.Long !== long_12.default) {
    _m02.util.Long = long_12.default;
    _m02.configure();
  }
  function isObject2(value) {
    return typeof value === "object" && value !== null;
  }
  function isSet2(value) {
    return value !== null && value !== void 0;
  }
})(api);
(function(exports2) {
  var __createBinding2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m[k];
  });
  var __exportStar = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !exports3.hasOwnProperty(p))
        __createBinding2(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.eventsApiSupportedEvents = exports2.eventsApiEventRpcCalls = void 0;
  __exportStar(api, exports2);
  exports2.eventsApiEventRpcCalls = {
    ping: "pong",
    publish: "published",
    subscribe: "subscribed",
    unsubscribe: "unsubscribed"
  };
  exports2.eventsApiSupportedEvents = [...Object.values(exports2.eventsApiEventRpcCalls), "error", "event", "reconnectBefore"];
})(dist$1);
var ws = null;
if (typeof WebSocket !== "undefined") {
  ws = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws = MozWebSocket;
} else if (typeof commonjsGlobal$1 !== "undefined") {
  ws = commonjsGlobal$1.WebSocket || commonjsGlobal$1.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws = self.WebSocket || self.MozWebSocket;
}
var browser$1 = ws;
var matcher = { exports: {} };
var escapeStringRegexp$1 = (string) => {
  if (typeof string !== "string") {
    throw new TypeError("Expected a string");
  }
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
const escapeStringRegexp = escapeStringRegexp$1;
const regexpCache = /* @__PURE__ */ new Map();
function sanitizeArray(input, inputName) {
  if (!Array.isArray(input)) {
    switch (typeof input) {
      case "string":
        input = [input];
        break;
      case "undefined":
        input = [];
        break;
      default:
        throw new TypeError(`Expected '${inputName}' to be a string or an array, but got a type of '${typeof input}'`);
    }
  }
  return input.filter((string) => {
    if (typeof string !== "string") {
      if (typeof string === "undefined") {
        return false;
      }
      throw new TypeError(`Expected '${inputName}' to be an array of strings, but found a type of '${typeof string}' in the array`);
    }
    return true;
  });
}
function makeRegexp(pattern, options) {
  options = {
    caseSensitive: false,
    ...options
  };
  const cacheKey = pattern + JSON.stringify(options);
  if (regexpCache.has(cacheKey)) {
    return regexpCache.get(cacheKey);
  }
  const negated = pattern[0] === "!";
  if (negated) {
    pattern = pattern.slice(1);
  }
  pattern = escapeStringRegexp(pattern).replace(/\\\*/g, "[\\s\\S]*");
  const regexp = new RegExp(`^${pattern}$`, options.caseSensitive ? "" : "i");
  regexp.negated = negated;
  regexpCache.set(cacheKey, regexp);
  return regexp;
}
matcher.exports = (inputs, patterns, options) => {
  inputs = sanitizeArray(inputs, "inputs");
  patterns = sanitizeArray(patterns, "patterns");
  if (patterns.length === 0) {
    return [];
  }
  const isFirstPatternNegated = patterns[0][0] === "!";
  patterns = patterns.map((pattern) => makeRegexp(pattern, options));
  const result = [];
  for (const input of inputs) {
    let matches = isFirstPatternNegated;
    for (const pattern of patterns) {
      if (pattern.test(input)) {
        matches = !pattern.negated;
      }
    }
    if (matches) {
      result.push(input);
    }
  }
  return result;
};
matcher.exports.isMatch = (inputs, patterns, options) => {
  inputs = sanitizeArray(inputs, "inputs");
  patterns = sanitizeArray(patterns, "patterns");
  if (patterns.length === 0) {
    return false;
  }
  return inputs.some((input) => {
    return patterns.every((pattern) => {
      const regexp = makeRegexp(pattern, options);
      const matches = regexp.test(input);
      return regexp.negated ? !matches : matches;
    });
  });
};
var __createBinding = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o2, k2, desc);
} : function(o2, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o2[k2] = m[k];
});
var __setModuleDefault = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(o2, v) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v });
} : function(o2, v) {
  o2["default"] = v;
});
var __importStar = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k in mod2)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
        __createBinding(result, mod2, k);
  }
  __setModuleDefault(result, mod2);
  return result;
};
var __importDefault$2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(eventapi, "__esModule", { value: true });
eventapi.EventApi = void 0;
const EventApiModel = __importStar(dist$1);
const isomorphic_ws_1 = __importDefault$2(browser$1);
const uuid_1 = require$$1$2;
const NiceGrpc = __importStar(lib$1);
const matcher_1 = matcher.exports;
const api_1 = api$2;
const clientVersion = version$3;
const WS_PING_INTERVAL = 2e4;
const WS_PING_TIMEOUT = 1e4;
const WS_RECONNECT_DELAY = 2e3;
const WS_MAX_BADAUTH_ATTEMPTS = 3;
const LOG_CATEGORY = "EventApi";
class EventApi extends api_1.ApiClient {
  constructor(sessionId, server, websocketServer, sdkVersion, apiLogCallback, eventLogCallback) {
    super(sessionId, server, sdkVersion, LOG_CATEGORY, apiLogCallback, eventLogCallback);
    this.websocketServer = websocketServer;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.eventHandlers = {};
    this.calls = {};
    this.messageQueue = [];
    this.websocketReady = false;
    this.reconnectionAttempts = 0;
    this.badAuthentication = false;
    this.eventsClient = null;
  }
  publish(...request3) {
    if (this.websocketReady) {
      return this.call("publish", request3[0]);
    } else {
      return this.eventsClient.publish(...request3);
    }
  }
  connect() {
    if (!this.ws) {
      this.cleanup();
      const currentAccessToken = this.accessToken;
      const query = [`version=${clientVersion}`, `sessionid=${this.sessionId}`];
      if (this.sdkVersion) {
        query.push(`sdkversion=${this.sdkVersion}`);
      }
      this.ws = new isomorphic_ws_1.default(`${this.websocketServer}/stream?${query.join("&")}`, [
        "Bearer",
        this.accessToken
      ]);
      let error;
      this.ws.addEventListener("message", (msg) => {
        const data2 = JSON.parse(msg.data.toString());
        const message = data2.result;
        if (data2.error) {
          error = data2.error;
          this.handleEvent("error", {
            error: {
              code: data2.code,
              message: data2.message
            }
          });
          if (["You do not have permission to this resource", "You do not have permission to this resource"].includes(data2.message)) {
            this.badAuthentication = true;
          }
        }
        if (!message) {
          return;
        }
        if (message.reconnectBefore && message.reconnectBefore.reauthenticate && this.accessToken === currentAccessToken) {
          this.badAuthentication = true;
        }
        const eventName = EventApiModel.eventsApiSupportedEvents.find((name2) => !!message[name2]);
        if (eventName) {
          this.handleEvent(eventName, message);
        }
      });
      this.ws.addEventListener("open", () => {
        this.log.info("websocket connected");
        this.call("ping", "hello", { timeout: WS_PING_TIMEOUT, skipQueue: true }).then(() => {
          this.ready();
        }).catch((e2) => {
          if (!error && e2.message !== "Stream connection closed") {
            this.disconnect("hello timeout");
          }
        });
      });
      this.ws.addEventListener("close", (event2) => {
        var _a2;
        if (error) {
          this.reconnect(`${(_a2 = error === null || error === void 0 ? void 0 : error.message) !== null && _a2 !== void 0 ? _a2 : "unknown"}`);
        } else {
          this.reconnect(`closed - ${event2.reason || event2.code}`);
        }
      });
      this.ws.addEventListener("error", (err) => {
        error = err;
      });
    }
  }
  async subscribe(name2, payload = {}) {
    return this.call("subscribe", { name: name2, ...payload }).then(() => {
      this.subscriptions.add(JSON.stringify({ name: name2, ...payload }));
    });
  }
  async unsubscribe(name2, payload = {}) {
    this.subscriptions.delete(JSON.stringify({ name: name2, payload }));
    await this.call("unsubscribe", { name: name2, ...payload });
  }
  on(type, dataOrFn, fn) {
    const handler = fn ? fn : dataOrFn;
    const options = {
      ignoreSessionEvents: false,
      allowedSessionEvents: [],
      ...fn ? dataOrFn : {}
    };
    if (!this.eventHandlers[type]) {
      this.eventHandlers[type] = [];
    }
    this.eventHandlers[type].push({
      ...options,
      handler
    });
  }
  off(type, dataOrFn, fn) {
    var _a2;
    const handler = fn ? fn : dataOrFn;
    const options = {
      ignoreSessionEvents: false,
      allowedSessionEvents: [],
      ...fn ? dataOrFn : {}
    };
    this.eventHandlers[type] = ((_a2 = this.eventHandlers[type]) !== null && _a2 !== void 0 ? _a2 : []).filter((eventHandler) => {
      if (eventHandler.ignoreSessionEvents === options.ignoreSessionEvents && eventHandler.allowedSessionEvents === options.allowedSessionEvents && eventHandler.handler === handler && eventHandler.name === options.name) {
        return false;
      }
      return true;
    });
  }
  disconnect(reason) {
    this.log.warn(`disconnected from events reason=${reason}`);
    Object.values(this.calls).forEach((i2) => {
      clearTimeout(i2.timeout);
      i2.reject(new Error("Stream connection closed"));
    });
    this.calls = {};
    this.cleanup();
  }
  _setup(options) {
    this.eventsClient = this.clientFactory.create(EventApiModel.EventServiceDefinition, this.channel, {
      "*": options
    });
    if (this.badAuthentication) {
      this.badAuthentication = false;
      this.reconnectionAttempts = 0;
      this.reconnect("updated token");
    }
  }
  ready() {
    this.reconnectionAttempts = 0;
    this.badAuthentication = false;
    this.websocketReady = true;
    this.handleEvent("connected", { connected: void 0 });
    for (const sub of this.subscriptions.values()) {
      this.send({ subscribe: JSON.parse(sub), correlationId: (0, uuid_1.v4)() });
    }
    for (const msg of this.messageQueue) {
      this.send(msg);
    }
    this.messageQueue = [];
    this.pingLoop = setInterval(() => {
      this.ping();
    }, WS_PING_INTERVAL);
  }
  ping() {
    this.call("ping", `${+new Date()}`, { timeout: WS_PING_TIMEOUT }).catch(() => {
      this.reconnect("connection stalled");
    });
  }
  reconnect(reason) {
    this.disconnect(reason);
    this.reconnectTimeout = setTimeout(() => {
      this.reconnectionAttempts++;
      if (this.badAuthentication && this.reconnectionAttempts >= WS_MAX_BADAUTH_ATTEMPTS) {
        this.log.warn("Maximum number of reconnection attempts reached with bad authentication, please re-authenticate the SDK");
        return;
      }
      this.connect();
    }, WS_RECONNECT_DELAY);
  }
  send(data2) {
    if (this.ws && this.ws.readyState === this.ws.OPEN) {
      this.ws.send(JSON.stringify(data2));
    } else {
      this.log.warn("Message sent to a disconnected stream");
    }
  }
  handleEvent(name2, payload) {
    var _a2;
    if (this.calls[payload.correlationId]) {
      const isMatchingResponse = EventApiModel.eventsApiEventRpcCalls[this.calls[payload.correlationId].method] === name2;
      const isError = !!payload.error;
      if (isMatchingResponse || isError) {
        this.resolveCall(name2, payload);
        return;
      }
    }
    for (const handler of (_a2 = this.eventHandlers[name2]) !== null && _a2 !== void 0 ? _a2 : []) {
      if (name2 === "event" && payload.event) {
        if (payload.sessionId === this.sessionId && handler.ignoreSessionEvents && !handler.allowedSessionEvents.includes(payload.event.name)) {
          this.log.trace("ignorning user event from self: " + payload.event.name + ", payload.sessionId=" + payload.sessionId + ", this.sessionId");
          continue;
        }
        if (handler.name && !(0, matcher_1.isMatch)(payload.event.name, handler.name)) {
          continue;
        }
        if (this.eventLogCallback) {
          let eventService = void 0;
          let eventType = payload.event.name;
          let eventSubType = void 0;
          if (payload.event.name.startsWith(EventApi.APISTREAM_EVENT_PREFIX)) {
            let parts = payload.event.name.split(":");
            if (parts.length == 4) {
              eventService = parts[1];
              eventType = parts[2];
              eventSubType = parts[3];
            }
            this.eventLogCallback(eventService, eventType, eventSubType, payload);
          }
        }
      } else {
        if (payload.sessionId === this.sessionId && handler.ignoreSessionEvents) {
          this.log.trace("ignorning event from self: " + payload.event.name + ", payload.sessionId=" + payload.sessionId + ", this.sessionId");
          continue;
        }
      }
      this.log.trace("processing event: payload.sessionId=" + payload.sessionId + ", this.sessionId");
      handler.handler(payload ? payload[name2] : void 0, { isFromCurrentSession: payload.sessionId === this.sessionId });
    }
  }
  async call(method, payload, opts = { timeout: 2e4, skipQueue: false }) {
    if (!this.ws) {
      this.connect();
    }
    const correlationId = (0, uuid_1.v4)();
    return new Promise((resolve, reject) => {
      const timeout2 = setTimeout(() => {
        delete this.calls[correlationId];
        reject(new Error("Request timed out"));
      }, opts.timeout);
      this.calls[correlationId] = { resolve, reject, timeout: timeout2, method };
      if (this.websocketReady || opts.skipQueue) {
        this.send({ [method]: payload, correlationId });
      } else {
        this.messageQueue.push({ [method]: payload, correlationId });
      }
    });
  }
  resolveCall(name2, payload) {
    const callHandler = this.calls[payload.correlationId];
    if (!callHandler) {
      return;
    }
    clearTimeout(callHandler.timeout);
    delete this.calls[payload.correlationId];
    if (name2 === "error" && payload.error) {
      callHandler.reject(new NiceGrpc.ClientError("error", payload.error.code, payload.error.message));
      return;
    }
    callHandler.resolve(payload[name2]);
  }
  cleanup() {
    clearTimeout(this.pingLoop);
    clearTimeout(this.reconnectTimeout);
    this.websocketReady = false;
    if (this.ws) {
      this.ws.onclose = function() {
      };
      this.ws.close();
      this.ws = null;
    }
  }
}
eventapi.EventApi = EventApi;
EventApi.APISTREAM_EVENT_PREFIX = "apistream";
var livekit = {};
var __importDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(livekit, "__esModule", { value: true });
livekit.LiveKitUtils = void 0;
const jwt_decode_1 = __importDefault$1(require$$0$1);
class LiveKitUtils {
  static decodeJwt(sfuToken) {
    return (0, jwt_decode_1.default)(sfuToken, { header: false });
  }
  static isRoomAdmin(sfuToken) {
    let grants2 = LiveKitUtils.decodeJwt(sfuToken);
    return grants2.video.roomAdmin;
  }
  static getRoomName(sfuToken) {
    let grants2 = LiveKitUtils.decodeJwt(sfuToken);
    return grants2.video.room;
  }
}
livekit.LiveKitUtils = LiveKitUtils;
(function(exports2) {
  var __createBinding2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar2 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding2(result, mod2, k);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  var __importDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ApiStream = exports2.LiveKitUtils = exports2.EventApiModel = exports2.LayoutApiModel = exports2.LiveApiModel = void 0;
  const jwt_decode_12 = __importDefault2(require$$0$1);
  const uuid_12 = require$$1$2;
  const typescript_logging_12 = require$$2$1;
  const layoutapi_1 = layoutapi;
  const liveapi_1 = liveapi;
  const eventapi_1 = eventapi;
  const LiveApiModel = __importStar2(api$1);
  exports2.LiveApiModel = LiveApiModel;
  const LayoutApiModel2 = __importStar2(dist$2);
  exports2.LayoutApiModel = LayoutApiModel2;
  const EventApiModel2 = __importStar2(dist$1);
  exports2.EventApiModel = EventApiModel2;
  const livekit_1 = livekit;
  Object.defineProperty(exports2, "LiveKitUtils", { enumerable: true, get: function() {
    return livekit_1.LiveKitUtils;
  } });
  const logger_12 = logger;
  const CLIENT_VERSION = version$3;
  const LIVEAPI_SERVERS = {
    "dev": "http://127.0.0.1:8081",
    "stage": "https://live.silly.horse/grpcweb/live/v2",
    "prod": "https://live.api.stream/grpcweb/live/v2"
  };
  const LAYOUTAPI_SERVERS = {
    "dev": "https://live.silly.horse/grpcweb/layout/v2",
    "stage": "https://live.silly.horse/grpcweb/layout/v2",
    "prod": "https://live.api.stream/grpcweb/layout/v2"
  };
  const EVENTAPI_WS_SERVERS = {
    "dev": "wss://live.silly.horse/event/v2",
    "stage": "wss://live.silly.horse/event/v2",
    "prod": "wss://live.api.stream/event/v2"
  };
  const EVENTAPI_SERVERS = {
    "dev": "https://live.silly.horse/grpcweb/event/v2",
    "stage": "https://live.silly.horse/grpcweb/event/v2",
    "prod": "https://live.api.stream/grpcweb/event/v2"
  };
  const LIVEKIT_SERVERS = {
    "dev": "wss://live.silly.horse/webrtc/v2",
    "stage": "wss://live.silly.horse/webrtc/v2",
    "prod": "wss://live.api.stream/webrtc/v2"
  };
  const LIVEKIT_ADMIN_SERVERS = {
    "dev": "https://live.silly.horse/webrtc/v2",
    "stage": "https://live.silly.horse/webrtc/v2",
    "prod": "https://live.api.stream/webrtc/v2"
  };
  class ApiStream {
    constructor(opts = {}) {
      var _a2;
      const options = {
        env: "prod",
        logLevel: "Warn",
        ...opts
      };
      this.env = options.env;
      let sessionId = (0, uuid_12.v4)();
      if (options.sessionId != void 0)
        sessionId = options.sessionId;
      this.log = logger_12.logger.getCategory("ApiStream");
      this.setLogLevel(options.env == "dev" ? "Trace" : options.logLevel);
      const overrideEndpoints = (_a2 = options.overrideEndpoints) !== null && _a2 !== void 0 ? _a2 : {};
      if (overrideEndpoints.liveApiServer == void 0)
        overrideEndpoints.liveApiServer = LIVEAPI_SERVERS[this.env];
      if (overrideEndpoints.layoutApiServer == void 0)
        overrideEndpoints.layoutApiServer = LAYOUTAPI_SERVERS[this.env];
      if (overrideEndpoints.eventApiServer == void 0)
        overrideEndpoints.eventApiServer = EVENTAPI_SERVERS[this.env];
      if (overrideEndpoints.eventApiWebSocketServer == void 0)
        overrideEndpoints.eventApiWebSocketServer = EVENTAPI_WS_SERVERS[this.env];
      this.eventApi = new eventapi_1.EventApi(sessionId, overrideEndpoints.eventApiServer, overrideEndpoints.eventApiWebSocketServer, options.sdkVersion, options.apiLogCallback, options.eventLogCallback);
      this.layoutApi = new layoutapi_1.LayoutApi(sessionId, this.eventApi, overrideEndpoints.layoutApiServer, options.sdkVersion, options.apiLogCallback);
      this.liveApi = new liveapi_1.LiveApi(sessionId, this.eventApi, overrideEndpoints.liveApiServer, this.setAccessToken.bind(this), options.apiKey, options.sdkVersion, options.apiLogCallback);
      this.eventApi.on("reconnectBefore", (evt) => {
        if (evt.reauthenticate) {
          this.liveApi.authentication.refreshAccessToken({}).catch(() => {
          });
        }
      });
      this.log.info("api.stream: sessionid=" + sessionId + ", version=" + CLIENT_VERSION + ", sdkVersion=" + options.sdkVersion);
    }
    LiveApi() {
      return this.liveApi;
    }
    LayoutApi() {
      return this.layoutApi;
    }
    EventApi() {
      return this.eventApi;
    }
    setLogLevel(level) {
      try {
        let logLevel = typescript_logging_12.LogLevel.toLogLevel(level);
        logger_12.logger.updateRuntimeSettings({
          level: logLevel
        });
      } catch (err) {
        this.log.warn(`unknown logging level ${level}`);
      }
    }
    setAccessToken(accessToken) {
      this.decodedAccessToken = ApiStream.decodeAccessToken(accessToken);
      this.log.debug("setting accessToken", accessToken, this.decodedAccessToken);
      this.layoutApi.setAccessToken(accessToken);
      this.liveApi.setAccessToken(accessToken);
      this.eventApi.setAccessToken(accessToken);
    }
    getAccessToken() {
      return this.decodedAccessToken;
    }
    getGuestProject() {
      return this.decodedAccessToken.guestControl;
    }
    async load(accessToken) {
      if (accessToken == void 0 && typeof window != "undefined") {
        let queryParameters = this.parseQuery();
        if (queryParameters.get(ApiStream.ACCESS_TOKEN_QUERY_PARAM) != null) {
          accessToken = queryParameters.get(ApiStream.ACCESS_TOKEN_QUERY_PARAM);
        }
      }
      if (accessToken != void 0) {
        this.setAccessToken(accessToken);
        if (this.decodedAccessToken.guestControl != void 0) {
          this.log.info("loading guest token and exchanging");
          await this.LiveApi().authentication.refreshAccessToken({});
          this.log.info("auto-loading project = " + JSON.stringify(this.decodedAccessToken.guestControl));
          return this.decodedAccessToken.guestControl;
        }
      }
      return null;
    }
    getLiveKitServer(admin = false) {
      if (admin)
        return LIVEKIT_ADMIN_SERVERS[this.env];
      else
        return LIVEKIT_SERVERS[this.env];
    }
    parseQuery() {
      let queryString = window.location.search;
      let query = /* @__PURE__ */ new Map();
      let pairs = (queryString[0] === "?" ? queryString.substr(1) : queryString).split("&");
      for (let i2 = 0; i2 < pairs.length; i2++) {
        let pair = pairs[i2].split("=");
        if (pair.length == 2) {
          query.set(decodeURIComponent(pair[0]), decodeURIComponent(pair[1] || ""));
          this.log.debug(`found query param: ${decodeURIComponent(pair[0])}=${decodeURIComponent(pair[1] || "")}`);
        }
      }
      return query;
    }
    static decodeAccessToken(accessToken) {
      let rawDecodedAccessToken = (0, jwt_decode_12.default)(accessToken, { header: false });
      let decodedAccessToken = {
        serviceUserId: rawDecodedAccessToken.user.serviceUserId,
        userId: rawDecodedAccessToken.user.userId,
        displayName: rawDecodedAccessToken.user.displayName,
        trial: rawDecodedAccessToken.user.trial,
        demo: rawDecodedAccessToken.user.demo
      };
      if (rawDecodedAccessToken.guestControl != null) {
        decodedAccessToken.guestControl = {
          collectionId: rawDecodedAccessToken.guestControl.collectionId,
          projectId: rawDecodedAccessToken.guestControl.projectId,
          role: LiveApiModel.roleFromJSON(rawDecodedAccessToken.guestControl.role)
        };
      }
      return decodedAccessToken;
    }
  }
  exports2.ApiStream = ApiStream;
  ApiStream.ACCESS_TOKEN_QUERY_PARAM = "at";
})(lib$2);
var dist = {};
var grants = {};
Object.defineProperty(grants, "__esModule", { value: true });
var livekit_models = {};
(function(exports2) {
  var __importDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ParticipantTracks = exports2.UserPacket = exports2.SpeakerInfo = exports2.ActiveSpeakerUpdate = exports2.DataPacket = exports2.VideoLayer = exports2.TrackInfo = exports2.ParticipantInfo = exports2.Codec = exports2.Room = exports2.dataPacket_KindToJSON = exports2.dataPacket_KindFromJSON = exports2.DataPacket_Kind = exports2.participantInfo_StateToJSON = exports2.participantInfo_StateFromJSON = exports2.ParticipantInfo_State = exports2.connectionQualityToJSON = exports2.connectionQualityFromJSON = exports2.ConnectionQuality = exports2.videoQualityToJSON = exports2.videoQualityFromJSON = exports2.VideoQuality = exports2.trackSourceToJSON = exports2.trackSourceFromJSON = exports2.TrackSource = exports2.trackTypeToJSON = exports2.trackTypeFromJSON = exports2.TrackType = exports2.protobufPackage = void 0;
  const long_12 = __importDefault2(umd.exports);
  const minimal_1 = __importDefault2(minimal$2);
  exports2.protobufPackage = "livekit";
  var TrackType2;
  (function(TrackType3) {
    TrackType3[TrackType3["AUDIO"] = 0] = "AUDIO";
    TrackType3[TrackType3["VIDEO"] = 1] = "VIDEO";
    TrackType3[TrackType3["DATA"] = 2] = "DATA";
    TrackType3[TrackType3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(TrackType2 = exports2.TrackType || (exports2.TrackType = {}));
  function trackTypeFromJSON2(object) {
    switch (object) {
      case 0:
      case "AUDIO":
        return TrackType2.AUDIO;
      case 1:
      case "VIDEO":
        return TrackType2.VIDEO;
      case 2:
      case "DATA":
        return TrackType2.DATA;
      case -1:
      case "UNRECOGNIZED":
      default:
        return TrackType2.UNRECOGNIZED;
    }
  }
  exports2.trackTypeFromJSON = trackTypeFromJSON2;
  function trackTypeToJSON2(object) {
    switch (object) {
      case TrackType2.AUDIO:
        return "AUDIO";
      case TrackType2.VIDEO:
        return "VIDEO";
      case TrackType2.DATA:
        return "DATA";
      default:
        return "UNKNOWN";
    }
  }
  exports2.trackTypeToJSON = trackTypeToJSON2;
  var TrackSource2;
  (function(TrackSource3) {
    TrackSource3[TrackSource3["UNKNOWN"] = 0] = "UNKNOWN";
    TrackSource3[TrackSource3["CAMERA"] = 1] = "CAMERA";
    TrackSource3[TrackSource3["MICROPHONE"] = 2] = "MICROPHONE";
    TrackSource3[TrackSource3["SCREEN_SHARE"] = 3] = "SCREEN_SHARE";
    TrackSource3[TrackSource3["SCREEN_SHARE_AUDIO"] = 4] = "SCREEN_SHARE_AUDIO";
    TrackSource3[TrackSource3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(TrackSource2 = exports2.TrackSource || (exports2.TrackSource = {}));
  function trackSourceFromJSON2(object) {
    switch (object) {
      case 0:
      case "UNKNOWN":
        return TrackSource2.UNKNOWN;
      case 1:
      case "CAMERA":
        return TrackSource2.CAMERA;
      case 2:
      case "MICROPHONE":
        return TrackSource2.MICROPHONE;
      case 3:
      case "SCREEN_SHARE":
        return TrackSource2.SCREEN_SHARE;
      case 4:
      case "SCREEN_SHARE_AUDIO":
        return TrackSource2.SCREEN_SHARE_AUDIO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return TrackSource2.UNRECOGNIZED;
    }
  }
  exports2.trackSourceFromJSON = trackSourceFromJSON2;
  function trackSourceToJSON2(object) {
    switch (object) {
      case TrackSource2.UNKNOWN:
        return "UNKNOWN";
      case TrackSource2.CAMERA:
        return "CAMERA";
      case TrackSource2.MICROPHONE:
        return "MICROPHONE";
      case TrackSource2.SCREEN_SHARE:
        return "SCREEN_SHARE";
      case TrackSource2.SCREEN_SHARE_AUDIO:
        return "SCREEN_SHARE_AUDIO";
      default:
        return "UNKNOWN";
    }
  }
  exports2.trackSourceToJSON = trackSourceToJSON2;
  var VideoQuality2;
  (function(VideoQuality3) {
    VideoQuality3[VideoQuality3["LOW"] = 0] = "LOW";
    VideoQuality3[VideoQuality3["MEDIUM"] = 1] = "MEDIUM";
    VideoQuality3[VideoQuality3["HIGH"] = 2] = "HIGH";
    VideoQuality3[VideoQuality3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(VideoQuality2 = exports2.VideoQuality || (exports2.VideoQuality = {}));
  function videoQualityFromJSON2(object) {
    switch (object) {
      case 0:
      case "LOW":
        return VideoQuality2.LOW;
      case 1:
      case "MEDIUM":
        return VideoQuality2.MEDIUM;
      case 2:
      case "HIGH":
        return VideoQuality2.HIGH;
      case -1:
      case "UNRECOGNIZED":
      default:
        return VideoQuality2.UNRECOGNIZED;
    }
  }
  exports2.videoQualityFromJSON = videoQualityFromJSON2;
  function videoQualityToJSON2(object) {
    switch (object) {
      case VideoQuality2.LOW:
        return "LOW";
      case VideoQuality2.MEDIUM:
        return "MEDIUM";
      case VideoQuality2.HIGH:
        return "HIGH";
      default:
        return "UNKNOWN";
    }
  }
  exports2.videoQualityToJSON = videoQualityToJSON2;
  var ConnectionQuality2;
  (function(ConnectionQuality3) {
    ConnectionQuality3[ConnectionQuality3["POOR"] = 0] = "POOR";
    ConnectionQuality3[ConnectionQuality3["GOOD"] = 1] = "GOOD";
    ConnectionQuality3[ConnectionQuality3["EXCELLENT"] = 2] = "EXCELLENT";
    ConnectionQuality3[ConnectionQuality3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(ConnectionQuality2 = exports2.ConnectionQuality || (exports2.ConnectionQuality = {}));
  function connectionQualityFromJSON2(object) {
    switch (object) {
      case 0:
      case "POOR":
        return ConnectionQuality2.POOR;
      case 1:
      case "GOOD":
        return ConnectionQuality2.GOOD;
      case 2:
      case "EXCELLENT":
        return ConnectionQuality2.EXCELLENT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ConnectionQuality2.UNRECOGNIZED;
    }
  }
  exports2.connectionQualityFromJSON = connectionQualityFromJSON2;
  function connectionQualityToJSON2(object) {
    switch (object) {
      case ConnectionQuality2.POOR:
        return "POOR";
      case ConnectionQuality2.GOOD:
        return "GOOD";
      case ConnectionQuality2.EXCELLENT:
        return "EXCELLENT";
      default:
        return "UNKNOWN";
    }
  }
  exports2.connectionQualityToJSON = connectionQualityToJSON2;
  var ParticipantInfo_State2;
  (function(ParticipantInfo_State3) {
    ParticipantInfo_State3[ParticipantInfo_State3["JOINING"] = 0] = "JOINING";
    ParticipantInfo_State3[ParticipantInfo_State3["JOINED"] = 1] = "JOINED";
    ParticipantInfo_State3[ParticipantInfo_State3["ACTIVE"] = 2] = "ACTIVE";
    ParticipantInfo_State3[ParticipantInfo_State3["DISCONNECTED"] = 3] = "DISCONNECTED";
    ParticipantInfo_State3[ParticipantInfo_State3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(ParticipantInfo_State2 = exports2.ParticipantInfo_State || (exports2.ParticipantInfo_State = {}));
  function participantInfo_StateFromJSON2(object) {
    switch (object) {
      case 0:
      case "JOINING":
        return ParticipantInfo_State2.JOINING;
      case 1:
      case "JOINED":
        return ParticipantInfo_State2.JOINED;
      case 2:
      case "ACTIVE":
        return ParticipantInfo_State2.ACTIVE;
      case 3:
      case "DISCONNECTED":
        return ParticipantInfo_State2.DISCONNECTED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ParticipantInfo_State2.UNRECOGNIZED;
    }
  }
  exports2.participantInfo_StateFromJSON = participantInfo_StateFromJSON2;
  function participantInfo_StateToJSON2(object) {
    switch (object) {
      case ParticipantInfo_State2.JOINING:
        return "JOINING";
      case ParticipantInfo_State2.JOINED:
        return "JOINED";
      case ParticipantInfo_State2.ACTIVE:
        return "ACTIVE";
      case ParticipantInfo_State2.DISCONNECTED:
        return "DISCONNECTED";
      default:
        return "UNKNOWN";
    }
  }
  exports2.participantInfo_StateToJSON = participantInfo_StateToJSON2;
  var DataPacket_Kind2;
  (function(DataPacket_Kind3) {
    DataPacket_Kind3[DataPacket_Kind3["RELIABLE"] = 0] = "RELIABLE";
    DataPacket_Kind3[DataPacket_Kind3["LOSSY"] = 1] = "LOSSY";
    DataPacket_Kind3[DataPacket_Kind3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  })(DataPacket_Kind2 = exports2.DataPacket_Kind || (exports2.DataPacket_Kind = {}));
  function dataPacket_KindFromJSON2(object) {
    switch (object) {
      case 0:
      case "RELIABLE":
        return DataPacket_Kind2.RELIABLE;
      case 1:
      case "LOSSY":
        return DataPacket_Kind2.LOSSY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return DataPacket_Kind2.UNRECOGNIZED;
    }
  }
  exports2.dataPacket_KindFromJSON = dataPacket_KindFromJSON2;
  function dataPacket_KindToJSON2(object) {
    switch (object) {
      case DataPacket_Kind2.RELIABLE:
        return "RELIABLE";
      case DataPacket_Kind2.LOSSY:
        return "LOSSY";
      default:
        return "UNKNOWN";
    }
  }
  exports2.dataPacket_KindToJSON = dataPacket_KindToJSON2;
  const baseRoom = {
    sid: "",
    name: "",
    emptyTimeout: 0,
    maxParticipants: 0,
    creationTime: 0,
    turnPassword: "",
    metadata: "",
    numParticipants: 0,
    activeRecording: false
  };
  exports2.Room = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.sid !== "") {
        writer2.uint32(10).string(message.sid);
      }
      if (message.name !== "") {
        writer2.uint32(18).string(message.name);
      }
      if (message.emptyTimeout !== 0) {
        writer2.uint32(24).uint32(message.emptyTimeout);
      }
      if (message.maxParticipants !== 0) {
        writer2.uint32(32).uint32(message.maxParticipants);
      }
      if (message.creationTime !== 0) {
        writer2.uint32(40).int64(message.creationTime);
      }
      if (message.turnPassword !== "") {
        writer2.uint32(50).string(message.turnPassword);
      }
      for (const v of message.enabledCodecs) {
        exports2.Codec.encode(v, writer2.uint32(58).fork()).ldelim();
      }
      if (message.metadata !== "") {
        writer2.uint32(66).string(message.metadata);
      }
      if (message.numParticipants !== 0) {
        writer2.uint32(72).uint32(message.numParticipants);
      }
      if (message.activeRecording === true) {
        writer2.uint32(80).bool(message.activeRecording);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseRoom);
      message.enabledCodecs = [];
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.sid = reader2.string();
            break;
          case 2:
            message.name = reader2.string();
            break;
          case 3:
            message.emptyTimeout = reader2.uint32();
            break;
          case 4:
            message.maxParticipants = reader2.uint32();
            break;
          case 5:
            message.creationTime = longToNumber2(reader2.int64());
            break;
          case 6:
            message.turnPassword = reader2.string();
            break;
          case 7:
            message.enabledCodecs.push(exports2.Codec.decode(reader2, reader2.uint32()));
            break;
          case 8:
            message.metadata = reader2.string();
            break;
          case 9:
            message.numParticipants = reader2.uint32();
            break;
          case 10:
            message.activeRecording = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseRoom);
      message.enabledCodecs = [];
      if (object.sid !== void 0 && object.sid !== null) {
        message.sid = String(object.sid);
      } else {
        message.sid = "";
      }
      if (object.name !== void 0 && object.name !== null) {
        message.name = String(object.name);
      } else {
        message.name = "";
      }
      if (object.emptyTimeout !== void 0 && object.emptyTimeout !== null) {
        message.emptyTimeout = Number(object.emptyTimeout);
      } else {
        message.emptyTimeout = 0;
      }
      if (object.maxParticipants !== void 0 && object.maxParticipants !== null) {
        message.maxParticipants = Number(object.maxParticipants);
      } else {
        message.maxParticipants = 0;
      }
      if (object.creationTime !== void 0 && object.creationTime !== null) {
        message.creationTime = Number(object.creationTime);
      } else {
        message.creationTime = 0;
      }
      if (object.turnPassword !== void 0 && object.turnPassword !== null) {
        message.turnPassword = String(object.turnPassword);
      } else {
        message.turnPassword = "";
      }
      if (object.enabledCodecs !== void 0 && object.enabledCodecs !== null) {
        for (const e2 of object.enabledCodecs) {
          message.enabledCodecs.push(exports2.Codec.fromJSON(e2));
        }
      }
      if (object.metadata !== void 0 && object.metadata !== null) {
        message.metadata = String(object.metadata);
      } else {
        message.metadata = "";
      }
      if (object.numParticipants !== void 0 && object.numParticipants !== null) {
        message.numParticipants = Number(object.numParticipants);
      } else {
        message.numParticipants = 0;
      }
      if (object.activeRecording !== void 0 && object.activeRecording !== null) {
        message.activeRecording = Boolean(object.activeRecording);
      } else {
        message.activeRecording = false;
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.sid !== void 0 && (obj.sid = message.sid);
      message.name !== void 0 && (obj.name = message.name);
      message.emptyTimeout !== void 0 && (obj.emptyTimeout = message.emptyTimeout);
      message.maxParticipants !== void 0 && (obj.maxParticipants = message.maxParticipants);
      message.creationTime !== void 0 && (obj.creationTime = message.creationTime);
      message.turnPassword !== void 0 && (obj.turnPassword = message.turnPassword);
      if (message.enabledCodecs) {
        obj.enabledCodecs = message.enabledCodecs.map((e2) => e2 ? exports2.Codec.toJSON(e2) : void 0);
      } else {
        obj.enabledCodecs = [];
      }
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.numParticipants !== void 0 && (obj.numParticipants = message.numParticipants);
      message.activeRecording !== void 0 && (obj.activeRecording = message.activeRecording);
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseRoom);
      message.enabledCodecs = [];
      if (object.sid !== void 0 && object.sid !== null) {
        message.sid = object.sid;
      } else {
        message.sid = "";
      }
      if (object.name !== void 0 && object.name !== null) {
        message.name = object.name;
      } else {
        message.name = "";
      }
      if (object.emptyTimeout !== void 0 && object.emptyTimeout !== null) {
        message.emptyTimeout = object.emptyTimeout;
      } else {
        message.emptyTimeout = 0;
      }
      if (object.maxParticipants !== void 0 && object.maxParticipants !== null) {
        message.maxParticipants = object.maxParticipants;
      } else {
        message.maxParticipants = 0;
      }
      if (object.creationTime !== void 0 && object.creationTime !== null) {
        message.creationTime = object.creationTime;
      } else {
        message.creationTime = 0;
      }
      if (object.turnPassword !== void 0 && object.turnPassword !== null) {
        message.turnPassword = object.turnPassword;
      } else {
        message.turnPassword = "";
      }
      if (object.enabledCodecs !== void 0 && object.enabledCodecs !== null) {
        for (const e2 of object.enabledCodecs) {
          message.enabledCodecs.push(exports2.Codec.fromPartial(e2));
        }
      }
      if (object.metadata !== void 0 && object.metadata !== null) {
        message.metadata = object.metadata;
      } else {
        message.metadata = "";
      }
      if (object.numParticipants !== void 0 && object.numParticipants !== null) {
        message.numParticipants = object.numParticipants;
      } else {
        message.numParticipants = 0;
      }
      if (object.activeRecording !== void 0 && object.activeRecording !== null) {
        message.activeRecording = object.activeRecording;
      } else {
        message.activeRecording = false;
      }
      return message;
    }
  };
  const baseCodec = { mime: "", fmtpLine: "" };
  exports2.Codec = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.mime !== "") {
        writer2.uint32(10).string(message.mime);
      }
      if (message.fmtpLine !== "") {
        writer2.uint32(18).string(message.fmtpLine);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseCodec);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.mime = reader2.string();
            break;
          case 2:
            message.fmtpLine = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseCodec);
      if (object.mime !== void 0 && object.mime !== null) {
        message.mime = String(object.mime);
      } else {
        message.mime = "";
      }
      if (object.fmtpLine !== void 0 && object.fmtpLine !== null) {
        message.fmtpLine = String(object.fmtpLine);
      } else {
        message.fmtpLine = "";
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.mime !== void 0 && (obj.mime = message.mime);
      message.fmtpLine !== void 0 && (obj.fmtpLine = message.fmtpLine);
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseCodec);
      if (object.mime !== void 0 && object.mime !== null) {
        message.mime = object.mime;
      } else {
        message.mime = "";
      }
      if (object.fmtpLine !== void 0 && object.fmtpLine !== null) {
        message.fmtpLine = object.fmtpLine;
      } else {
        message.fmtpLine = "";
      }
      return message;
    }
  };
  const baseParticipantInfo = {
    sid: "",
    identity: "",
    state: 0,
    metadata: "",
    joinedAt: 0,
    hidden: false,
    recorder: false,
    name: ""
  };
  exports2.ParticipantInfo = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.sid !== "") {
        writer2.uint32(10).string(message.sid);
      }
      if (message.identity !== "") {
        writer2.uint32(18).string(message.identity);
      }
      if (message.state !== 0) {
        writer2.uint32(24).int32(message.state);
      }
      for (const v of message.tracks) {
        exports2.TrackInfo.encode(v, writer2.uint32(34).fork()).ldelim();
      }
      if (message.metadata !== "") {
        writer2.uint32(42).string(message.metadata);
      }
      if (message.joinedAt !== 0) {
        writer2.uint32(48).int64(message.joinedAt);
      }
      if (message.hidden === true) {
        writer2.uint32(56).bool(message.hidden);
      }
      if (message.recorder === true) {
        writer2.uint32(64).bool(message.recorder);
      }
      if (message.name !== "") {
        writer2.uint32(74).string(message.name);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseParticipantInfo);
      message.tracks = [];
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.sid = reader2.string();
            break;
          case 2:
            message.identity = reader2.string();
            break;
          case 3:
            message.state = reader2.int32();
            break;
          case 4:
            message.tracks.push(exports2.TrackInfo.decode(reader2, reader2.uint32()));
            break;
          case 5:
            message.metadata = reader2.string();
            break;
          case 6:
            message.joinedAt = longToNumber2(reader2.int64());
            break;
          case 7:
            message.hidden = reader2.bool();
            break;
          case 8:
            message.recorder = reader2.bool();
            break;
          case 9:
            message.name = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseParticipantInfo);
      message.tracks = [];
      if (object.sid !== void 0 && object.sid !== null) {
        message.sid = String(object.sid);
      } else {
        message.sid = "";
      }
      if (object.identity !== void 0 && object.identity !== null) {
        message.identity = String(object.identity);
      } else {
        message.identity = "";
      }
      if (object.state !== void 0 && object.state !== null) {
        message.state = participantInfo_StateFromJSON2(object.state);
      } else {
        message.state = 0;
      }
      if (object.tracks !== void 0 && object.tracks !== null) {
        for (const e2 of object.tracks) {
          message.tracks.push(exports2.TrackInfo.fromJSON(e2));
        }
      }
      if (object.metadata !== void 0 && object.metadata !== null) {
        message.metadata = String(object.metadata);
      } else {
        message.metadata = "";
      }
      if (object.joinedAt !== void 0 && object.joinedAt !== null) {
        message.joinedAt = Number(object.joinedAt);
      } else {
        message.joinedAt = 0;
      }
      if (object.hidden !== void 0 && object.hidden !== null) {
        message.hidden = Boolean(object.hidden);
      } else {
        message.hidden = false;
      }
      if (object.recorder !== void 0 && object.recorder !== null) {
        message.recorder = Boolean(object.recorder);
      } else {
        message.recorder = false;
      }
      if (object.name !== void 0 && object.name !== null) {
        message.name = String(object.name);
      } else {
        message.name = "";
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.sid !== void 0 && (obj.sid = message.sid);
      message.identity !== void 0 && (obj.identity = message.identity);
      message.state !== void 0 && (obj.state = participantInfo_StateToJSON2(message.state));
      if (message.tracks) {
        obj.tracks = message.tracks.map((e2) => e2 ? exports2.TrackInfo.toJSON(e2) : void 0);
      } else {
        obj.tracks = [];
      }
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.joinedAt !== void 0 && (obj.joinedAt = message.joinedAt);
      message.hidden !== void 0 && (obj.hidden = message.hidden);
      message.recorder !== void 0 && (obj.recorder = message.recorder);
      message.name !== void 0 && (obj.name = message.name);
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseParticipantInfo);
      message.tracks = [];
      if (object.sid !== void 0 && object.sid !== null) {
        message.sid = object.sid;
      } else {
        message.sid = "";
      }
      if (object.identity !== void 0 && object.identity !== null) {
        message.identity = object.identity;
      } else {
        message.identity = "";
      }
      if (object.state !== void 0 && object.state !== null) {
        message.state = object.state;
      } else {
        message.state = 0;
      }
      if (object.tracks !== void 0 && object.tracks !== null) {
        for (const e2 of object.tracks) {
          message.tracks.push(exports2.TrackInfo.fromPartial(e2));
        }
      }
      if (object.metadata !== void 0 && object.metadata !== null) {
        message.metadata = object.metadata;
      } else {
        message.metadata = "";
      }
      if (object.joinedAt !== void 0 && object.joinedAt !== null) {
        message.joinedAt = object.joinedAt;
      } else {
        message.joinedAt = 0;
      }
      if (object.hidden !== void 0 && object.hidden !== null) {
        message.hidden = object.hidden;
      } else {
        message.hidden = false;
      }
      if (object.recorder !== void 0 && object.recorder !== null) {
        message.recorder = object.recorder;
      } else {
        message.recorder = false;
      }
      if (object.name !== void 0 && object.name !== null) {
        message.name = object.name;
      } else {
        message.name = "";
      }
      return message;
    }
  };
  const baseTrackInfo = {
    sid: "",
    type: 0,
    name: "",
    muted: false,
    width: 0,
    height: 0,
    simulcast: false,
    disableDtx: false,
    source: 0,
    mimeType: ""
  };
  exports2.TrackInfo = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.sid !== "") {
        writer2.uint32(10).string(message.sid);
      }
      if (message.type !== 0) {
        writer2.uint32(16).int32(message.type);
      }
      if (message.name !== "") {
        writer2.uint32(26).string(message.name);
      }
      if (message.muted === true) {
        writer2.uint32(32).bool(message.muted);
      }
      if (message.width !== 0) {
        writer2.uint32(40).uint32(message.width);
      }
      if (message.height !== 0) {
        writer2.uint32(48).uint32(message.height);
      }
      if (message.simulcast === true) {
        writer2.uint32(56).bool(message.simulcast);
      }
      if (message.disableDtx === true) {
        writer2.uint32(64).bool(message.disableDtx);
      }
      if (message.source !== 0) {
        writer2.uint32(72).int32(message.source);
      }
      for (const v of message.layers) {
        exports2.VideoLayer.encode(v, writer2.uint32(82).fork()).ldelim();
      }
      if (message.mimeType !== "") {
        writer2.uint32(90).string(message.mimeType);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseTrackInfo);
      message.layers = [];
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.sid = reader2.string();
            break;
          case 2:
            message.type = reader2.int32();
            break;
          case 3:
            message.name = reader2.string();
            break;
          case 4:
            message.muted = reader2.bool();
            break;
          case 5:
            message.width = reader2.uint32();
            break;
          case 6:
            message.height = reader2.uint32();
            break;
          case 7:
            message.simulcast = reader2.bool();
            break;
          case 8:
            message.disableDtx = reader2.bool();
            break;
          case 9:
            message.source = reader2.int32();
            break;
          case 10:
            message.layers.push(exports2.VideoLayer.decode(reader2, reader2.uint32()));
            break;
          case 11:
            message.mimeType = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseTrackInfo);
      message.layers = [];
      if (object.sid !== void 0 && object.sid !== null) {
        message.sid = String(object.sid);
      } else {
        message.sid = "";
      }
      if (object.type !== void 0 && object.type !== null) {
        message.type = trackTypeFromJSON2(object.type);
      } else {
        message.type = 0;
      }
      if (object.name !== void 0 && object.name !== null) {
        message.name = String(object.name);
      } else {
        message.name = "";
      }
      if (object.muted !== void 0 && object.muted !== null) {
        message.muted = Boolean(object.muted);
      } else {
        message.muted = false;
      }
      if (object.width !== void 0 && object.width !== null) {
        message.width = Number(object.width);
      } else {
        message.width = 0;
      }
      if (object.height !== void 0 && object.height !== null) {
        message.height = Number(object.height);
      } else {
        message.height = 0;
      }
      if (object.simulcast !== void 0 && object.simulcast !== null) {
        message.simulcast = Boolean(object.simulcast);
      } else {
        message.simulcast = false;
      }
      if (object.disableDtx !== void 0 && object.disableDtx !== null) {
        message.disableDtx = Boolean(object.disableDtx);
      } else {
        message.disableDtx = false;
      }
      if (object.source !== void 0 && object.source !== null) {
        message.source = trackSourceFromJSON2(object.source);
      } else {
        message.source = 0;
      }
      if (object.layers !== void 0 && object.layers !== null) {
        for (const e2 of object.layers) {
          message.layers.push(exports2.VideoLayer.fromJSON(e2));
        }
      }
      if (object.mimeType !== void 0 && object.mimeType !== null) {
        message.mimeType = String(object.mimeType);
      } else {
        message.mimeType = "";
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.sid !== void 0 && (obj.sid = message.sid);
      message.type !== void 0 && (obj.type = trackTypeToJSON2(message.type));
      message.name !== void 0 && (obj.name = message.name);
      message.muted !== void 0 && (obj.muted = message.muted);
      message.width !== void 0 && (obj.width = message.width);
      message.height !== void 0 && (obj.height = message.height);
      message.simulcast !== void 0 && (obj.simulcast = message.simulcast);
      message.disableDtx !== void 0 && (obj.disableDtx = message.disableDtx);
      message.source !== void 0 && (obj.source = trackSourceToJSON2(message.source));
      if (message.layers) {
        obj.layers = message.layers.map((e2) => e2 ? exports2.VideoLayer.toJSON(e2) : void 0);
      } else {
        obj.layers = [];
      }
      message.mimeType !== void 0 && (obj.mimeType = message.mimeType);
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseTrackInfo);
      message.layers = [];
      if (object.sid !== void 0 && object.sid !== null) {
        message.sid = object.sid;
      } else {
        message.sid = "";
      }
      if (object.type !== void 0 && object.type !== null) {
        message.type = object.type;
      } else {
        message.type = 0;
      }
      if (object.name !== void 0 && object.name !== null) {
        message.name = object.name;
      } else {
        message.name = "";
      }
      if (object.muted !== void 0 && object.muted !== null) {
        message.muted = object.muted;
      } else {
        message.muted = false;
      }
      if (object.width !== void 0 && object.width !== null) {
        message.width = object.width;
      } else {
        message.width = 0;
      }
      if (object.height !== void 0 && object.height !== null) {
        message.height = object.height;
      } else {
        message.height = 0;
      }
      if (object.simulcast !== void 0 && object.simulcast !== null) {
        message.simulcast = object.simulcast;
      } else {
        message.simulcast = false;
      }
      if (object.disableDtx !== void 0 && object.disableDtx !== null) {
        message.disableDtx = object.disableDtx;
      } else {
        message.disableDtx = false;
      }
      if (object.source !== void 0 && object.source !== null) {
        message.source = object.source;
      } else {
        message.source = 0;
      }
      if (object.layers !== void 0 && object.layers !== null) {
        for (const e2 of object.layers) {
          message.layers.push(exports2.VideoLayer.fromPartial(e2));
        }
      }
      if (object.mimeType !== void 0 && object.mimeType !== null) {
        message.mimeType = object.mimeType;
      } else {
        message.mimeType = "";
      }
      return message;
    }
  };
  const baseVideoLayer = { quality: 0, width: 0, height: 0, bitrate: 0 };
  exports2.VideoLayer = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.quality !== 0) {
        writer2.uint32(8).int32(message.quality);
      }
      if (message.width !== 0) {
        writer2.uint32(16).uint32(message.width);
      }
      if (message.height !== 0) {
        writer2.uint32(24).uint32(message.height);
      }
      if (message.bitrate !== 0) {
        writer2.uint32(32).uint32(message.bitrate);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseVideoLayer);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.quality = reader2.int32();
            break;
          case 2:
            message.width = reader2.uint32();
            break;
          case 3:
            message.height = reader2.uint32();
            break;
          case 4:
            message.bitrate = reader2.uint32();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseVideoLayer);
      if (object.quality !== void 0 && object.quality !== null) {
        message.quality = videoQualityFromJSON2(object.quality);
      } else {
        message.quality = 0;
      }
      if (object.width !== void 0 && object.width !== null) {
        message.width = Number(object.width);
      } else {
        message.width = 0;
      }
      if (object.height !== void 0 && object.height !== null) {
        message.height = Number(object.height);
      } else {
        message.height = 0;
      }
      if (object.bitrate !== void 0 && object.bitrate !== null) {
        message.bitrate = Number(object.bitrate);
      } else {
        message.bitrate = 0;
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.quality !== void 0 && (obj.quality = videoQualityToJSON2(message.quality));
      message.width !== void 0 && (obj.width = message.width);
      message.height !== void 0 && (obj.height = message.height);
      message.bitrate !== void 0 && (obj.bitrate = message.bitrate);
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseVideoLayer);
      if (object.quality !== void 0 && object.quality !== null) {
        message.quality = object.quality;
      } else {
        message.quality = 0;
      }
      if (object.width !== void 0 && object.width !== null) {
        message.width = object.width;
      } else {
        message.width = 0;
      }
      if (object.height !== void 0 && object.height !== null) {
        message.height = object.height;
      } else {
        message.height = 0;
      }
      if (object.bitrate !== void 0 && object.bitrate !== null) {
        message.bitrate = object.bitrate;
      } else {
        message.bitrate = 0;
      }
      return message;
    }
  };
  const baseDataPacket = { kind: 0 };
  exports2.DataPacket = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.kind !== 0) {
        writer2.uint32(8).int32(message.kind);
      }
      if (message.user !== void 0) {
        exports2.UserPacket.encode(message.user, writer2.uint32(18).fork()).ldelim();
      }
      if (message.speaker !== void 0) {
        exports2.ActiveSpeakerUpdate.encode(message.speaker, writer2.uint32(26).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseDataPacket);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.kind = reader2.int32();
            break;
          case 2:
            message.user = exports2.UserPacket.decode(reader2, reader2.uint32());
            break;
          case 3:
            message.speaker = exports2.ActiveSpeakerUpdate.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseDataPacket);
      if (object.kind !== void 0 && object.kind !== null) {
        message.kind = dataPacket_KindFromJSON2(object.kind);
      } else {
        message.kind = 0;
      }
      if (object.user !== void 0 && object.user !== null) {
        message.user = exports2.UserPacket.fromJSON(object.user);
      } else {
        message.user = void 0;
      }
      if (object.speaker !== void 0 && object.speaker !== null) {
        message.speaker = exports2.ActiveSpeakerUpdate.fromJSON(object.speaker);
      } else {
        message.speaker = void 0;
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.kind !== void 0 && (obj.kind = dataPacket_KindToJSON2(message.kind));
      message.user !== void 0 && (obj.user = message.user ? exports2.UserPacket.toJSON(message.user) : void 0);
      message.speaker !== void 0 && (obj.speaker = message.speaker ? exports2.ActiveSpeakerUpdate.toJSON(message.speaker) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseDataPacket);
      if (object.kind !== void 0 && object.kind !== null) {
        message.kind = object.kind;
      } else {
        message.kind = 0;
      }
      if (object.user !== void 0 && object.user !== null) {
        message.user = exports2.UserPacket.fromPartial(object.user);
      } else {
        message.user = void 0;
      }
      if (object.speaker !== void 0 && object.speaker !== null) {
        message.speaker = exports2.ActiveSpeakerUpdate.fromPartial(object.speaker);
      } else {
        message.speaker = void 0;
      }
      return message;
    }
  };
  const baseActiveSpeakerUpdate = {};
  exports2.ActiveSpeakerUpdate = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      for (const v of message.speakers) {
        exports2.SpeakerInfo.encode(v, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseActiveSpeakerUpdate);
      message.speakers = [];
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.speakers.push(exports2.SpeakerInfo.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseActiveSpeakerUpdate);
      message.speakers = [];
      if (object.speakers !== void 0 && object.speakers !== null) {
        for (const e2 of object.speakers) {
          message.speakers.push(exports2.SpeakerInfo.fromJSON(e2));
        }
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      if (message.speakers) {
        obj.speakers = message.speakers.map((e2) => e2 ? exports2.SpeakerInfo.toJSON(e2) : void 0);
      } else {
        obj.speakers = [];
      }
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseActiveSpeakerUpdate);
      message.speakers = [];
      if (object.speakers !== void 0 && object.speakers !== null) {
        for (const e2 of object.speakers) {
          message.speakers.push(exports2.SpeakerInfo.fromPartial(e2));
        }
      }
      return message;
    }
  };
  const baseSpeakerInfo = { sid: "", level: 0, active: false };
  exports2.SpeakerInfo = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.sid !== "") {
        writer2.uint32(10).string(message.sid);
      }
      if (message.level !== 0) {
        writer2.uint32(21).float(message.level);
      }
      if (message.active === true) {
        writer2.uint32(24).bool(message.active);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseSpeakerInfo);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.sid = reader2.string();
            break;
          case 2:
            message.level = reader2.float();
            break;
          case 3:
            message.active = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseSpeakerInfo);
      if (object.sid !== void 0 && object.sid !== null) {
        message.sid = String(object.sid);
      } else {
        message.sid = "";
      }
      if (object.level !== void 0 && object.level !== null) {
        message.level = Number(object.level);
      } else {
        message.level = 0;
      }
      if (object.active !== void 0 && object.active !== null) {
        message.active = Boolean(object.active);
      } else {
        message.active = false;
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.sid !== void 0 && (obj.sid = message.sid);
      message.level !== void 0 && (obj.level = message.level);
      message.active !== void 0 && (obj.active = message.active);
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseSpeakerInfo);
      if (object.sid !== void 0 && object.sid !== null) {
        message.sid = object.sid;
      } else {
        message.sid = "";
      }
      if (object.level !== void 0 && object.level !== null) {
        message.level = object.level;
      } else {
        message.level = 0;
      }
      if (object.active !== void 0 && object.active !== null) {
        message.active = object.active;
      } else {
        message.active = false;
      }
      return message;
    }
  };
  const baseUserPacket = { participantSid: "", destinationSids: "" };
  exports2.UserPacket = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.participantSid !== "") {
        writer2.uint32(10).string(message.participantSid);
      }
      if (message.payload.length !== 0) {
        writer2.uint32(18).bytes(message.payload);
      }
      for (const v of message.destinationSids) {
        writer2.uint32(26).string(v);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseUserPacket);
      message.destinationSids = [];
      message.payload = new Uint8Array();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.participantSid = reader2.string();
            break;
          case 2:
            message.payload = reader2.bytes();
            break;
          case 3:
            message.destinationSids.push(reader2.string());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseUserPacket);
      message.destinationSids = [];
      message.payload = new Uint8Array();
      if (object.participantSid !== void 0 && object.participantSid !== null) {
        message.participantSid = String(object.participantSid);
      } else {
        message.participantSid = "";
      }
      if (object.payload !== void 0 && object.payload !== null) {
        message.payload = bytesFromBase642(object.payload);
      }
      if (object.destinationSids !== void 0 && object.destinationSids !== null) {
        for (const e2 of object.destinationSids) {
          message.destinationSids.push(String(e2));
        }
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
      message.payload !== void 0 && (obj.payload = base64FromBytes2(message.payload !== void 0 ? message.payload : new Uint8Array()));
      if (message.destinationSids) {
        obj.destinationSids = message.destinationSids.map((e2) => e2);
      } else {
        obj.destinationSids = [];
      }
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseUserPacket);
      message.destinationSids = [];
      if (object.participantSid !== void 0 && object.participantSid !== null) {
        message.participantSid = object.participantSid;
      } else {
        message.participantSid = "";
      }
      if (object.payload !== void 0 && object.payload !== null) {
        message.payload = object.payload;
      } else {
        message.payload = new Uint8Array();
      }
      if (object.destinationSids !== void 0 && object.destinationSids !== null) {
        for (const e2 of object.destinationSids) {
          message.destinationSids.push(e2);
        }
      }
      return message;
    }
  };
  const baseParticipantTracks = { participantSid: "", trackSids: "" };
  exports2.ParticipantTracks = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.participantSid !== "") {
        writer2.uint32(10).string(message.participantSid);
      }
      for (const v of message.trackSids) {
        writer2.uint32(18).string(v);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseParticipantTracks);
      message.trackSids = [];
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.participantSid = reader2.string();
            break;
          case 2:
            message.trackSids.push(reader2.string());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseParticipantTracks);
      message.trackSids = [];
      if (object.participantSid !== void 0 && object.participantSid !== null) {
        message.participantSid = String(object.participantSid);
      } else {
        message.participantSid = "";
      }
      if (object.trackSids !== void 0 && object.trackSids !== null) {
        for (const e2 of object.trackSids) {
          message.trackSids.push(String(e2));
        }
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
      if (message.trackSids) {
        obj.trackSids = message.trackSids.map((e2) => e2);
      } else {
        obj.trackSids = [];
      }
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseParticipantTracks);
      message.trackSids = [];
      if (object.participantSid !== void 0 && object.participantSid !== null) {
        message.participantSid = object.participantSid;
      } else {
        message.participantSid = "";
      }
      if (object.trackSids !== void 0 && object.trackSids !== null) {
        for (const e2 of object.trackSids) {
          message.trackSids.push(e2);
        }
      }
      return message;
    }
  };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal$1 !== "undefined")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  const atob2 = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
  function bytesFromBase642(b64) {
    const bin = atob2(b64);
    const arr = new Uint8Array(bin.length);
    for (let i2 = 0; i2 < bin.length; ++i2) {
      arr[i2] = bin.charCodeAt(i2);
    }
    return arr;
  }
  const btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
  function base64FromBytes2(arr) {
    const bin = [];
    for (const byte of arr) {
      bin.push(String.fromCharCode(byte));
    }
    return btoa2(bin.join(""));
  }
  function longToNumber2(long2) {
    if (long2.gt(Number.MAX_SAFE_INTEGER)) {
      throw new globalThis2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long2.toNumber();
  }
  if (minimal_1.default.util.Long !== long_12.default) {
    minimal_1.default.util.Long = long_12.default;
    minimal_1.default.configure();
  }
})(livekit_models);
var RoomServiceClient$1 = {};
var livekit_room = {};
(function(exports2) {
  var __importDefault2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.UpdateRoomMetadataRequest = exports2.SendDataResponse = exports2.SendDataRequest = exports2.UpdateSubscriptionsResponse = exports2.UpdateSubscriptionsRequest = exports2.UpdateParticipantRequest = exports2.ParticipantPermission = exports2.MuteRoomTrackResponse = exports2.MuteRoomTrackRequest = exports2.RemoveParticipantResponse = exports2.RoomParticipantIdentity = exports2.ListParticipantsResponse = exports2.ListParticipantsRequest = exports2.DeleteRoomResponse = exports2.DeleteRoomRequest = exports2.ListRoomsResponse = exports2.ListRoomsRequest = exports2.CreateRoomRequest = exports2.protobufPackage = void 0;
  const long_12 = __importDefault2(umd.exports);
  const minimal_1 = __importDefault2(minimal$2);
  const livekit_models_12 = livekit_models;
  exports2.protobufPackage = "livekit";
  const baseCreateRoomRequest = {
    name: "",
    emptyTimeout: 0,
    maxParticipants: 0,
    nodeId: "",
    metadata: ""
  };
  exports2.CreateRoomRequest = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.name !== "") {
        writer2.uint32(10).string(message.name);
      }
      if (message.emptyTimeout !== 0) {
        writer2.uint32(16).uint32(message.emptyTimeout);
      }
      if (message.maxParticipants !== 0) {
        writer2.uint32(24).uint32(message.maxParticipants);
      }
      if (message.nodeId !== "") {
        writer2.uint32(34).string(message.nodeId);
      }
      if (message.metadata !== "") {
        writer2.uint32(42).string(message.metadata);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseCreateRoomRequest);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.name = reader2.string();
            break;
          case 2:
            message.emptyTimeout = reader2.uint32();
            break;
          case 3:
            message.maxParticipants = reader2.uint32();
            break;
          case 4:
            message.nodeId = reader2.string();
            break;
          case 5:
            message.metadata = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseCreateRoomRequest);
      if (object.name !== void 0 && object.name !== null) {
        message.name = String(object.name);
      } else {
        message.name = "";
      }
      if (object.emptyTimeout !== void 0 && object.emptyTimeout !== null) {
        message.emptyTimeout = Number(object.emptyTimeout);
      } else {
        message.emptyTimeout = 0;
      }
      if (object.maxParticipants !== void 0 && object.maxParticipants !== null) {
        message.maxParticipants = Number(object.maxParticipants);
      } else {
        message.maxParticipants = 0;
      }
      if (object.nodeId !== void 0 && object.nodeId !== null) {
        message.nodeId = String(object.nodeId);
      } else {
        message.nodeId = "";
      }
      if (object.metadata !== void 0 && object.metadata !== null) {
        message.metadata = String(object.metadata);
      } else {
        message.metadata = "";
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.name !== void 0 && (obj.name = message.name);
      message.emptyTimeout !== void 0 && (obj.emptyTimeout = message.emptyTimeout);
      message.maxParticipants !== void 0 && (obj.maxParticipants = message.maxParticipants);
      message.nodeId !== void 0 && (obj.nodeId = message.nodeId);
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseCreateRoomRequest);
      if (object.name !== void 0 && object.name !== null) {
        message.name = object.name;
      } else {
        message.name = "";
      }
      if (object.emptyTimeout !== void 0 && object.emptyTimeout !== null) {
        message.emptyTimeout = object.emptyTimeout;
      } else {
        message.emptyTimeout = 0;
      }
      if (object.maxParticipants !== void 0 && object.maxParticipants !== null) {
        message.maxParticipants = object.maxParticipants;
      } else {
        message.maxParticipants = 0;
      }
      if (object.nodeId !== void 0 && object.nodeId !== null) {
        message.nodeId = object.nodeId;
      } else {
        message.nodeId = "";
      }
      if (object.metadata !== void 0 && object.metadata !== null) {
        message.metadata = object.metadata;
      } else {
        message.metadata = "";
      }
      return message;
    }
  };
  const baseListRoomsRequest = { names: "" };
  exports2.ListRoomsRequest = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      for (const v of message.names) {
        writer2.uint32(10).string(v);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseListRoomsRequest);
      message.names = [];
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.names.push(reader2.string());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseListRoomsRequest);
      message.names = [];
      if (object.names !== void 0 && object.names !== null) {
        for (const e2 of object.names) {
          message.names.push(String(e2));
        }
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      if (message.names) {
        obj.names = message.names.map((e2) => e2);
      } else {
        obj.names = [];
      }
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseListRoomsRequest);
      message.names = [];
      if (object.names !== void 0 && object.names !== null) {
        for (const e2 of object.names) {
          message.names.push(e2);
        }
      }
      return message;
    }
  };
  const baseListRoomsResponse = {};
  exports2.ListRoomsResponse = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      for (const v of message.rooms) {
        livekit_models_12.Room.encode(v, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseListRoomsResponse);
      message.rooms = [];
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.rooms.push(livekit_models_12.Room.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseListRoomsResponse);
      message.rooms = [];
      if (object.rooms !== void 0 && object.rooms !== null) {
        for (const e2 of object.rooms) {
          message.rooms.push(livekit_models_12.Room.fromJSON(e2));
        }
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      if (message.rooms) {
        obj.rooms = message.rooms.map((e2) => e2 ? livekit_models_12.Room.toJSON(e2) : void 0);
      } else {
        obj.rooms = [];
      }
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseListRoomsResponse);
      message.rooms = [];
      if (object.rooms !== void 0 && object.rooms !== null) {
        for (const e2 of object.rooms) {
          message.rooms.push(livekit_models_12.Room.fromPartial(e2));
        }
      }
      return message;
    }
  };
  const baseDeleteRoomRequest = { room: "" };
  exports2.DeleteRoomRequest = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.room !== "") {
        writer2.uint32(10).string(message.room);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseDeleteRoomRequest);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.room = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseDeleteRoomRequest);
      if (object.room !== void 0 && object.room !== null) {
        message.room = String(object.room);
      } else {
        message.room = "";
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.room !== void 0 && (obj.room = message.room);
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseDeleteRoomRequest);
      if (object.room !== void 0 && object.room !== null) {
        message.room = object.room;
      } else {
        message.room = "";
      }
      return message;
    }
  };
  const baseDeleteRoomResponse = {};
  exports2.DeleteRoomResponse = {
    encode(_, writer2 = minimal_1.default.Writer.create()) {
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseDeleteRoomResponse);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(_) {
      const message = Object.assign({}, baseDeleteRoomResponse);
      return message;
    },
    toJSON(_) {
      const obj = {};
      return obj;
    },
    fromPartial(_) {
      const message = Object.assign({}, baseDeleteRoomResponse);
      return message;
    }
  };
  const baseListParticipantsRequest = { room: "" };
  exports2.ListParticipantsRequest = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.room !== "") {
        writer2.uint32(10).string(message.room);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseListParticipantsRequest);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.room = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseListParticipantsRequest);
      if (object.room !== void 0 && object.room !== null) {
        message.room = String(object.room);
      } else {
        message.room = "";
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.room !== void 0 && (obj.room = message.room);
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseListParticipantsRequest);
      if (object.room !== void 0 && object.room !== null) {
        message.room = object.room;
      } else {
        message.room = "";
      }
      return message;
    }
  };
  const baseListParticipantsResponse = {};
  exports2.ListParticipantsResponse = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      for (const v of message.participants) {
        livekit_models_12.ParticipantInfo.encode(v, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseListParticipantsResponse);
      message.participants = [];
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.participants.push(livekit_models_12.ParticipantInfo.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseListParticipantsResponse);
      message.participants = [];
      if (object.participants !== void 0 && object.participants !== null) {
        for (const e2 of object.participants) {
          message.participants.push(livekit_models_12.ParticipantInfo.fromJSON(e2));
        }
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      if (message.participants) {
        obj.participants = message.participants.map((e2) => e2 ? livekit_models_12.ParticipantInfo.toJSON(e2) : void 0);
      } else {
        obj.participants = [];
      }
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseListParticipantsResponse);
      message.participants = [];
      if (object.participants !== void 0 && object.participants !== null) {
        for (const e2 of object.participants) {
          message.participants.push(livekit_models_12.ParticipantInfo.fromPartial(e2));
        }
      }
      return message;
    }
  };
  const baseRoomParticipantIdentity = { room: "", identity: "" };
  exports2.RoomParticipantIdentity = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.room !== "") {
        writer2.uint32(10).string(message.room);
      }
      if (message.identity !== "") {
        writer2.uint32(18).string(message.identity);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseRoomParticipantIdentity);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.room = reader2.string();
            break;
          case 2:
            message.identity = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseRoomParticipantIdentity);
      if (object.room !== void 0 && object.room !== null) {
        message.room = String(object.room);
      } else {
        message.room = "";
      }
      if (object.identity !== void 0 && object.identity !== null) {
        message.identity = String(object.identity);
      } else {
        message.identity = "";
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.room !== void 0 && (obj.room = message.room);
      message.identity !== void 0 && (obj.identity = message.identity);
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseRoomParticipantIdentity);
      if (object.room !== void 0 && object.room !== null) {
        message.room = object.room;
      } else {
        message.room = "";
      }
      if (object.identity !== void 0 && object.identity !== null) {
        message.identity = object.identity;
      } else {
        message.identity = "";
      }
      return message;
    }
  };
  const baseRemoveParticipantResponse = {};
  exports2.RemoveParticipantResponse = {
    encode(_, writer2 = minimal_1.default.Writer.create()) {
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseRemoveParticipantResponse);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(_) {
      const message = Object.assign({}, baseRemoveParticipantResponse);
      return message;
    },
    toJSON(_) {
      const obj = {};
      return obj;
    },
    fromPartial(_) {
      const message = Object.assign({}, baseRemoveParticipantResponse);
      return message;
    }
  };
  const baseMuteRoomTrackRequest = {
    room: "",
    identity: "",
    trackSid: "",
    muted: false
  };
  exports2.MuteRoomTrackRequest = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.room !== "") {
        writer2.uint32(10).string(message.room);
      }
      if (message.identity !== "") {
        writer2.uint32(18).string(message.identity);
      }
      if (message.trackSid !== "") {
        writer2.uint32(26).string(message.trackSid);
      }
      if (message.muted === true) {
        writer2.uint32(32).bool(message.muted);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseMuteRoomTrackRequest);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.room = reader2.string();
            break;
          case 2:
            message.identity = reader2.string();
            break;
          case 3:
            message.trackSid = reader2.string();
            break;
          case 4:
            message.muted = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseMuteRoomTrackRequest);
      if (object.room !== void 0 && object.room !== null) {
        message.room = String(object.room);
      } else {
        message.room = "";
      }
      if (object.identity !== void 0 && object.identity !== null) {
        message.identity = String(object.identity);
      } else {
        message.identity = "";
      }
      if (object.trackSid !== void 0 && object.trackSid !== null) {
        message.trackSid = String(object.trackSid);
      } else {
        message.trackSid = "";
      }
      if (object.muted !== void 0 && object.muted !== null) {
        message.muted = Boolean(object.muted);
      } else {
        message.muted = false;
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.room !== void 0 && (obj.room = message.room);
      message.identity !== void 0 && (obj.identity = message.identity);
      message.trackSid !== void 0 && (obj.trackSid = message.trackSid);
      message.muted !== void 0 && (obj.muted = message.muted);
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseMuteRoomTrackRequest);
      if (object.room !== void 0 && object.room !== null) {
        message.room = object.room;
      } else {
        message.room = "";
      }
      if (object.identity !== void 0 && object.identity !== null) {
        message.identity = object.identity;
      } else {
        message.identity = "";
      }
      if (object.trackSid !== void 0 && object.trackSid !== null) {
        message.trackSid = object.trackSid;
      } else {
        message.trackSid = "";
      }
      if (object.muted !== void 0 && object.muted !== null) {
        message.muted = object.muted;
      } else {
        message.muted = false;
      }
      return message;
    }
  };
  const baseMuteRoomTrackResponse = {};
  exports2.MuteRoomTrackResponse = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.track !== void 0) {
        livekit_models_12.TrackInfo.encode(message.track, writer2.uint32(10).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseMuteRoomTrackResponse);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.track = livekit_models_12.TrackInfo.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseMuteRoomTrackResponse);
      if (object.track !== void 0 && object.track !== null) {
        message.track = livekit_models_12.TrackInfo.fromJSON(object.track);
      } else {
        message.track = void 0;
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.track !== void 0 && (obj.track = message.track ? livekit_models_12.TrackInfo.toJSON(message.track) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseMuteRoomTrackResponse);
      if (object.track !== void 0 && object.track !== null) {
        message.track = livekit_models_12.TrackInfo.fromPartial(object.track);
      } else {
        message.track = void 0;
      }
      return message;
    }
  };
  const baseParticipantPermission = {
    canSubscribe: false,
    canPublish: false,
    canPublishData: false
  };
  exports2.ParticipantPermission = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.canSubscribe === true) {
        writer2.uint32(8).bool(message.canSubscribe);
      }
      if (message.canPublish === true) {
        writer2.uint32(16).bool(message.canPublish);
      }
      if (message.canPublishData === true) {
        writer2.uint32(24).bool(message.canPublishData);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseParticipantPermission);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.canSubscribe = reader2.bool();
            break;
          case 2:
            message.canPublish = reader2.bool();
            break;
          case 3:
            message.canPublishData = reader2.bool();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseParticipantPermission);
      if (object.canSubscribe !== void 0 && object.canSubscribe !== null) {
        message.canSubscribe = Boolean(object.canSubscribe);
      } else {
        message.canSubscribe = false;
      }
      if (object.canPublish !== void 0 && object.canPublish !== null) {
        message.canPublish = Boolean(object.canPublish);
      } else {
        message.canPublish = false;
      }
      if (object.canPublishData !== void 0 && object.canPublishData !== null) {
        message.canPublishData = Boolean(object.canPublishData);
      } else {
        message.canPublishData = false;
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.canSubscribe !== void 0 && (obj.canSubscribe = message.canSubscribe);
      message.canPublish !== void 0 && (obj.canPublish = message.canPublish);
      message.canPublishData !== void 0 && (obj.canPublishData = message.canPublishData);
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseParticipantPermission);
      if (object.canSubscribe !== void 0 && object.canSubscribe !== null) {
        message.canSubscribe = object.canSubscribe;
      } else {
        message.canSubscribe = false;
      }
      if (object.canPublish !== void 0 && object.canPublish !== null) {
        message.canPublish = object.canPublish;
      } else {
        message.canPublish = false;
      }
      if (object.canPublishData !== void 0 && object.canPublishData !== null) {
        message.canPublishData = object.canPublishData;
      } else {
        message.canPublishData = false;
      }
      return message;
    }
  };
  const baseUpdateParticipantRequest = {
    room: "",
    identity: "",
    metadata: ""
  };
  exports2.UpdateParticipantRequest = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.room !== "") {
        writer2.uint32(10).string(message.room);
      }
      if (message.identity !== "") {
        writer2.uint32(18).string(message.identity);
      }
      if (message.metadata !== "") {
        writer2.uint32(26).string(message.metadata);
      }
      if (message.permission !== void 0) {
        exports2.ParticipantPermission.encode(message.permission, writer2.uint32(34).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseUpdateParticipantRequest);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.room = reader2.string();
            break;
          case 2:
            message.identity = reader2.string();
            break;
          case 3:
            message.metadata = reader2.string();
            break;
          case 4:
            message.permission = exports2.ParticipantPermission.decode(reader2, reader2.uint32());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseUpdateParticipantRequest);
      if (object.room !== void 0 && object.room !== null) {
        message.room = String(object.room);
      } else {
        message.room = "";
      }
      if (object.identity !== void 0 && object.identity !== null) {
        message.identity = String(object.identity);
      } else {
        message.identity = "";
      }
      if (object.metadata !== void 0 && object.metadata !== null) {
        message.metadata = String(object.metadata);
      } else {
        message.metadata = "";
      }
      if (object.permission !== void 0 && object.permission !== null) {
        message.permission = exports2.ParticipantPermission.fromJSON(object.permission);
      } else {
        message.permission = void 0;
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.room !== void 0 && (obj.room = message.room);
      message.identity !== void 0 && (obj.identity = message.identity);
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      message.permission !== void 0 && (obj.permission = message.permission ? exports2.ParticipantPermission.toJSON(message.permission) : void 0);
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseUpdateParticipantRequest);
      if (object.room !== void 0 && object.room !== null) {
        message.room = object.room;
      } else {
        message.room = "";
      }
      if (object.identity !== void 0 && object.identity !== null) {
        message.identity = object.identity;
      } else {
        message.identity = "";
      }
      if (object.metadata !== void 0 && object.metadata !== null) {
        message.metadata = object.metadata;
      } else {
        message.metadata = "";
      }
      if (object.permission !== void 0 && object.permission !== null) {
        message.permission = exports2.ParticipantPermission.fromPartial(object.permission);
      } else {
        message.permission = void 0;
      }
      return message;
    }
  };
  const baseUpdateSubscriptionsRequest = {
    room: "",
    identity: "",
    trackSids: "",
    subscribe: false
  };
  exports2.UpdateSubscriptionsRequest = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.room !== "") {
        writer2.uint32(10).string(message.room);
      }
      if (message.identity !== "") {
        writer2.uint32(18).string(message.identity);
      }
      for (const v of message.trackSids) {
        writer2.uint32(26).string(v);
      }
      if (message.subscribe === true) {
        writer2.uint32(32).bool(message.subscribe);
      }
      for (const v of message.participantTracks) {
        livekit_models_12.ParticipantTracks.encode(v, writer2.uint32(42).fork()).ldelim();
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseUpdateSubscriptionsRequest);
      message.trackSids = [];
      message.participantTracks = [];
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.room = reader2.string();
            break;
          case 2:
            message.identity = reader2.string();
            break;
          case 3:
            message.trackSids.push(reader2.string());
            break;
          case 4:
            message.subscribe = reader2.bool();
            break;
          case 5:
            message.participantTracks.push(livekit_models_12.ParticipantTracks.decode(reader2, reader2.uint32()));
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseUpdateSubscriptionsRequest);
      message.trackSids = [];
      message.participantTracks = [];
      if (object.room !== void 0 && object.room !== null) {
        message.room = String(object.room);
      } else {
        message.room = "";
      }
      if (object.identity !== void 0 && object.identity !== null) {
        message.identity = String(object.identity);
      } else {
        message.identity = "";
      }
      if (object.trackSids !== void 0 && object.trackSids !== null) {
        for (const e2 of object.trackSids) {
          message.trackSids.push(String(e2));
        }
      }
      if (object.subscribe !== void 0 && object.subscribe !== null) {
        message.subscribe = Boolean(object.subscribe);
      } else {
        message.subscribe = false;
      }
      if (object.participantTracks !== void 0 && object.participantTracks !== null) {
        for (const e2 of object.participantTracks) {
          message.participantTracks.push(livekit_models_12.ParticipantTracks.fromJSON(e2));
        }
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.room !== void 0 && (obj.room = message.room);
      message.identity !== void 0 && (obj.identity = message.identity);
      if (message.trackSids) {
        obj.trackSids = message.trackSids.map((e2) => e2);
      } else {
        obj.trackSids = [];
      }
      message.subscribe !== void 0 && (obj.subscribe = message.subscribe);
      if (message.participantTracks) {
        obj.participantTracks = message.participantTracks.map((e2) => e2 ? livekit_models_12.ParticipantTracks.toJSON(e2) : void 0);
      } else {
        obj.participantTracks = [];
      }
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseUpdateSubscriptionsRequest);
      message.trackSids = [];
      message.participantTracks = [];
      if (object.room !== void 0 && object.room !== null) {
        message.room = object.room;
      } else {
        message.room = "";
      }
      if (object.identity !== void 0 && object.identity !== null) {
        message.identity = object.identity;
      } else {
        message.identity = "";
      }
      if (object.trackSids !== void 0 && object.trackSids !== null) {
        for (const e2 of object.trackSids) {
          message.trackSids.push(e2);
        }
      }
      if (object.subscribe !== void 0 && object.subscribe !== null) {
        message.subscribe = object.subscribe;
      } else {
        message.subscribe = false;
      }
      if (object.participantTracks !== void 0 && object.participantTracks !== null) {
        for (const e2 of object.participantTracks) {
          message.participantTracks.push(livekit_models_12.ParticipantTracks.fromPartial(e2));
        }
      }
      return message;
    }
  };
  const baseUpdateSubscriptionsResponse = {};
  exports2.UpdateSubscriptionsResponse = {
    encode(_, writer2 = minimal_1.default.Writer.create()) {
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseUpdateSubscriptionsResponse);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(_) {
      const message = Object.assign({}, baseUpdateSubscriptionsResponse);
      return message;
    },
    toJSON(_) {
      const obj = {};
      return obj;
    },
    fromPartial(_) {
      const message = Object.assign({}, baseUpdateSubscriptionsResponse);
      return message;
    }
  };
  const baseSendDataRequest = { room: "", kind: 0, destinationSids: "" };
  exports2.SendDataRequest = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.room !== "") {
        writer2.uint32(10).string(message.room);
      }
      if (message.data.length !== 0) {
        writer2.uint32(18).bytes(message.data);
      }
      if (message.kind !== 0) {
        writer2.uint32(24).int32(message.kind);
      }
      for (const v of message.destinationSids) {
        writer2.uint32(34).string(v);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseSendDataRequest);
      message.destinationSids = [];
      message.data = new Uint8Array();
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.room = reader2.string();
            break;
          case 2:
            message.data = reader2.bytes();
            break;
          case 3:
            message.kind = reader2.int32();
            break;
          case 4:
            message.destinationSids.push(reader2.string());
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseSendDataRequest);
      message.destinationSids = [];
      message.data = new Uint8Array();
      if (object.room !== void 0 && object.room !== null) {
        message.room = String(object.room);
      } else {
        message.room = "";
      }
      if (object.data !== void 0 && object.data !== null) {
        message.data = bytesFromBase642(object.data);
      }
      if (object.kind !== void 0 && object.kind !== null) {
        message.kind = livekit_models_12.dataPacket_KindFromJSON(object.kind);
      } else {
        message.kind = 0;
      }
      if (object.destinationSids !== void 0 && object.destinationSids !== null) {
        for (const e2 of object.destinationSids) {
          message.destinationSids.push(String(e2));
        }
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.room !== void 0 && (obj.room = message.room);
      message.data !== void 0 && (obj.data = base64FromBytes2(message.data !== void 0 ? message.data : new Uint8Array()));
      message.kind !== void 0 && (obj.kind = livekit_models_12.dataPacket_KindToJSON(message.kind));
      if (message.destinationSids) {
        obj.destinationSids = message.destinationSids.map((e2) => e2);
      } else {
        obj.destinationSids = [];
      }
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseSendDataRequest);
      message.destinationSids = [];
      if (object.room !== void 0 && object.room !== null) {
        message.room = object.room;
      } else {
        message.room = "";
      }
      if (object.data !== void 0 && object.data !== null) {
        message.data = object.data;
      } else {
        message.data = new Uint8Array();
      }
      if (object.kind !== void 0 && object.kind !== null) {
        message.kind = object.kind;
      } else {
        message.kind = 0;
      }
      if (object.destinationSids !== void 0 && object.destinationSids !== null) {
        for (const e2 of object.destinationSids) {
          message.destinationSids.push(e2);
        }
      }
      return message;
    }
  };
  const baseSendDataResponse = {};
  exports2.SendDataResponse = {
    encode(_, writer2 = minimal_1.default.Writer.create()) {
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseSendDataResponse);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(_) {
      const message = Object.assign({}, baseSendDataResponse);
      return message;
    },
    toJSON(_) {
      const obj = {};
      return obj;
    },
    fromPartial(_) {
      const message = Object.assign({}, baseSendDataResponse);
      return message;
    }
  };
  const baseUpdateRoomMetadataRequest = { room: "", metadata: "" };
  exports2.UpdateRoomMetadataRequest = {
    encode(message, writer2 = minimal_1.default.Writer.create()) {
      if (message.room !== "") {
        writer2.uint32(10).string(message.room);
      }
      if (message.metadata !== "") {
        writer2.uint32(18).string(message.metadata);
      }
      return writer2;
    },
    decode(input, length2) {
      const reader2 = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
      let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
      const message = Object.assign({}, baseUpdateRoomMetadataRequest);
      while (reader2.pos < end3) {
        const tag = reader2.uint32();
        switch (tag >>> 3) {
          case 1:
            message.room = reader2.string();
            break;
          case 2:
            message.metadata = reader2.string();
            break;
          default:
            reader2.skipType(tag & 7);
            break;
        }
      }
      return message;
    },
    fromJSON(object) {
      const message = Object.assign({}, baseUpdateRoomMetadataRequest);
      if (object.room !== void 0 && object.room !== null) {
        message.room = String(object.room);
      } else {
        message.room = "";
      }
      if (object.metadata !== void 0 && object.metadata !== null) {
        message.metadata = String(object.metadata);
      } else {
        message.metadata = "";
      }
      return message;
    },
    toJSON(message) {
      const obj = {};
      message.room !== void 0 && (obj.room = message.room);
      message.metadata !== void 0 && (obj.metadata = message.metadata);
      return obj;
    },
    fromPartial(object) {
      const message = Object.assign({}, baseUpdateRoomMetadataRequest);
      if (object.room !== void 0 && object.room !== null) {
        message.room = object.room;
      } else {
        message.room = "";
      }
      if (object.metadata !== void 0 && object.metadata !== null) {
        message.metadata = object.metadata;
      } else {
        message.metadata = "";
      }
      return message;
    }
  };
  var globalThis2 = (() => {
    if (typeof globalThis2 !== "undefined")
      return globalThis2;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal$1 !== "undefined")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  const atob2 = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
  function bytesFromBase642(b64) {
    const bin = atob2(b64);
    const arr = new Uint8Array(bin.length);
    for (let i2 = 0; i2 < bin.length; ++i2) {
      arr[i2] = bin.charCodeAt(i2);
    }
    return arr;
  }
  const btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
  function base64FromBytes2(arr) {
    const bin = [];
    for (const byte of arr) {
      bin.push(String.fromCharCode(byte));
    }
    return btoa2(bin.join(""));
  }
  if (minimal_1.default.util.Long !== long_12.default) {
    minimal_1.default.util.Long = long_12.default;
    minimal_1.default.configure();
  }
})(livekit_room);
var TwirpRPC = {};
var axios$2 = { exports: {} };
var bind$2 = function bind2(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    return fn.apply(thisArg, args);
  };
};
var bind$1 = bind$2;
var toString = Object.prototype.toString;
function isArray$1(val) {
  return toString.call(val) === "[object Array]";
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return typeof FormData !== "undefined" && val instanceof FormData;
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}
function isString(val) {
  return typeof val === "string";
}
function isNumber(val) {
  return typeof val === "number";
}
function isObject$3(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (toString.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate(val) {
  return toString.call(val) === "[object Date]";
}
function isFile(val) {
  return toString.call(val) === "[object File]";
}
function isBlob(val) {
  return toString.call(val) === "[object Blob]";
}
function isFunction(val) {
  return toString.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$3(val) && isFunction(val.pipe);
}
function isURLSearchParams(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function trim$1(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj, fn) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$1(obj)) {
    for (var i2 = 0, l = obj.length; i2 < l; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
function merge() {
  var result = {};
  function assignValue2(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray$1(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }
  for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
    forEach(arguments[i2], assignValue2);
  }
  return result;
}
function extend(a, b, thisArg) {
  forEach(b, function assignValue2(val, key) {
    if (thisArg && typeof val === "function") {
      a[key] = bind$1(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
var utils$d = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isObject: isObject$3,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge,
  extend,
  trim: trim$1,
  stripBOM
};
var utils$c = utils$d;
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$2 = function buildURL2(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$c.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$c.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$c.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils$c.forEach(val, function parseValue(v) {
        if (utils$c.isDate(v)) {
          v = v.toISOString();
        } else if (utils$c.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + "=" + encode(v));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
var utils$b = utils$d;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn) {
  utils$b.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$a = utils$d;
var normalizeHeaderName$1 = function normalizeHeaderName2(headers, normalizedName) {
  utils$a.forEach(headers, function processHeader(value, name2) {
    if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name2];
    }
  });
};
var enhanceError$2 = function enhanceError2(error, config2, code, request3, response) {
  error.config = config2;
  if (code) {
    error.code = code;
  }
  error.request = request3;
  error.response = response;
  error.isAxiosError = true;
  error.toJSON = function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code
    };
  };
  return error;
};
var enhanceError$1 = enhanceError$2;
var createError$2 = function createError2(message, config2, code, request3, response) {
  var error = new Error(message);
  return enhanceError$1(error, config2, code, request3, response);
};
var createError$1 = createError$2;
var settle$1 = function settle2(resolve, reject, response) {
  var validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(createError$1("Request failed with status code " + response.status, response.config, null, response.request, response));
  }
};
var utils$9 = utils$d;
var cookies$1 = utils$9.isStandardBrowserEnv() ? function standardBrowserEnv() {
  return {
    write: function write2(name2, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name2 + "=" + encodeURIComponent(value));
      if (utils$9.isNumber(expires)) {
        cookie.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils$9.isString(path)) {
        cookie.push("path=" + path);
      }
      if (utils$9.isString(domain)) {
        cookie.push("domain=" + domain);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read(name2) {
      var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove2(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write2() {
    },
    read: function read() {
      return null;
    },
    remove: function remove2() {
    }
  };
}();
var isAbsoluteURL$1 = function isAbsoluteURL2(url) {
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};
var combineURLs$1 = function combineURLs2(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL = isAbsoluteURL$1;
var combineURLs = combineURLs$1;
var buildFullPath$1 = function buildFullPath2(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};
var utils$8 = utils$d;
var ignoreDuplicateOf = [
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
];
var parseHeaders$1 = function parseHeaders2(headers) {
  var parsed2 = {};
  var key;
  var val;
  var i2;
  if (!headers) {
    return parsed2;
  }
  utils$8.forEach(headers.split("\n"), function parser2(line) {
    i2 = line.indexOf(":");
    key = utils$8.trim(line.substr(0, i2)).toLowerCase();
    val = utils$8.trim(line.substr(i2 + 1));
    if (key) {
      if (parsed2[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === "set-cookie") {
        parsed2[key] = (parsed2[key] ? parsed2[key] : []).concat([val]);
      } else {
        parsed2[key] = parsed2[key] ? parsed2[key] + ", " + val : val;
      }
    }
  });
  return parsed2;
};
var utils$7 = utils$d;
var isURLSameOrigin$1 = utils$7.isStandardBrowserEnv() ? function standardBrowserEnv2() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement("a");
  var originURL;
  function resolveURL(url) {
    var href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    var parsed2 = utils$7.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed2.protocol === originURL.protocol && parsed2.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
var utils$6 = utils$d;
var settle = settle$1;
var cookies = cookies$1;
var buildURL$1 = buildURL$2;
var buildFullPath = buildFullPath$1;
var parseHeaders = parseHeaders$1;
var isURLSameOrigin = isURLSameOrigin$1;
var createError = createError$2;
var xhr = function xhrAdapter(config2) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config2.data;
    var requestHeaders = config2.headers;
    var responseType = config2.responseType;
    if (utils$6.isFormData(requestData)) {
      delete requestHeaders["Content-Type"];
    }
    var request3 = new XMLHttpRequest();
    if (config2.auth) {
      var username = config2.auth.username || "";
      var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
    }
    var fullPath = buildFullPath(config2.baseURL, config2.url);
    request3.open(config2.method.toUpperCase(), buildURL$1(fullPath, config2.params, config2.paramsSerializer), true);
    request3.timeout = config2.timeout;
    function onloadend() {
      if (!request3) {
        return;
      }
      var responseHeaders = "getAllResponseHeaders" in request3 ? parseHeaders(request3.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === "text" || responseType === "json" ? request3.responseText : request3.response;
      var response = {
        data: responseData,
        status: request3.status,
        statusText: request3.statusText,
        headers: responseHeaders,
        config: config2,
        request: request3
      };
      settle(resolve, reject, response);
      request3 = null;
    }
    if ("onloadend" in request3) {
      request3.onloadend = onloadend;
    } else {
      request3.onreadystatechange = function handleLoad() {
        if (!request3 || request3.readyState !== 4) {
          return;
        }
        if (request3.status === 0 && !(request3.responseURL && request3.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request3.onabort = function handleAbort() {
      if (!request3) {
        return;
      }
      reject(createError("Request aborted", config2, "ECONNABORTED", request3));
      request3 = null;
    };
    request3.onerror = function handleError() {
      reject(createError("Network Error", config2, null, request3));
      request3 = null;
    };
    request3.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = "timeout of " + config2.timeout + "ms exceeded";
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config2, config2.transitional && config2.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request3));
      request3 = null;
    };
    if (utils$6.isStandardBrowserEnv()) {
      var xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName ? cookies.read(config2.xsrfCookieName) : void 0;
      if (xsrfValue) {
        requestHeaders[config2.xsrfHeaderName] = xsrfValue;
      }
    }
    if ("setRequestHeader" in request3) {
      utils$6.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
          delete requestHeaders[key];
        } else {
          request3.setRequestHeader(key, val);
        }
      });
    }
    if (!utils$6.isUndefined(config2.withCredentials)) {
      request3.withCredentials = !!config2.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request3.responseType = config2.responseType;
    }
    if (typeof config2.onDownloadProgress === "function") {
      request3.addEventListener("progress", config2.onDownloadProgress);
    }
    if (typeof config2.onUploadProgress === "function" && request3.upload) {
      request3.upload.addEventListener("progress", config2.onUploadProgress);
    }
    if (config2.cancelToken) {
      config2.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request3) {
          return;
        }
        request3.abort();
        reject(cancel);
        request3 = null;
      });
    }
    if (!requestData) {
      requestData = null;
    }
    request3.send(requestData);
  });
};
var utils$5 = utils$d;
var normalizeHeaderName = normalizeHeaderName$1;
var enhanceError = enhanceError$2;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = xhr;
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = xhr;
  }
  return adapter;
}
function stringifySafely(rawValue, parser2, encoder2) {
  if (utils$5.isString(rawValue)) {
    try {
      (parser2 || JSON.parse)(rawValue);
      return utils$5.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder2 || JSON.stringify)(rawValue);
}
var defaults$3 = {
  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data2, headers) {
    normalizeHeaderName(headers, "Accept");
    normalizeHeaderName(headers, "Content-Type");
    if (utils$5.isFormData(data2) || utils$5.isArrayBuffer(data2) || utils$5.isBuffer(data2) || utils$5.isStream(data2) || utils$5.isFile(data2) || utils$5.isBlob(data2)) {
      return data2;
    }
    if (utils$5.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$5.isURLSearchParams(data2)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data2.toString();
    }
    if (utils$5.isObject(data2) || headers && headers["Content-Type"] === "application/json") {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    var transitional2 = this.transitional;
    var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
    var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$5.isString(data2) && data2.length) {
      try {
        return JSON.parse(data2);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw enhanceError(e2, this, "E_JSON_PARSE");
          }
          throw e2;
        }
      }
    }
    return data2;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults$3.headers = {
  common: {
    "Accept": "application/json, text/plain, */*"
  }
};
utils$5.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$3.headers[method] = {};
});
utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$3.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3;
var utils$4 = utils$d;
var defaults$2 = defaults_1;
var transformData$1 = function transformData2(data2, headers, fns) {
  var context2 = this || defaults$2;
  utils$4.forEach(fns, function transform(fn) {
    data2 = fn.call(context2, data2, headers);
  });
  return data2;
};
var isCancel$1 = function isCancel2(value) {
  return !!(value && value.__CANCEL__);
};
var utils$3 = utils$d;
var transformData = transformData$1;
var isCancel = isCancel$1;
var defaults$1 = defaults_1;
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
}
var dispatchRequest$1 = function dispatchRequest2(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = config2.headers || {};
  config2.data = transformData.call(config2, config2.data, config2.headers, config2.transformRequest);
  config2.headers = utils$3.merge(config2.headers.common || {}, config2.headers[config2.method] || {}, config2.headers);
  utils$3.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
    delete config2.headers[method];
  });
  var adapter = config2.adapter || defaults$1.adapter;
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(config2, response.data, response.headers, config2.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(config2, reason.response.data, reason.response.headers, config2.transformResponse);
      }
    }
    return Promise.reject(reason);
  });
};
var utils$2 = utils$d;
var mergeConfig$2 = function mergeConfig2(config1, config2) {
  config2 = config2 || {};
  var config3 = {};
  var valueFromConfig2Keys = ["url", "method", "data"];
  var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
  var defaultToConfig2Keys = [
    "baseURL",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "timeoutMessage",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "decompress",
    "maxContentLength",
    "maxBodyLength",
    "maxRedirects",
    "transport",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath",
    "responseEncoding"
  ];
  var directMergeKeys = ["validateStatus"];
  function getMergedValue(target, source2) {
    if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source2)) {
      return utils$2.merge(target, source2);
    } else if (utils$2.isPlainObject(source2)) {
      return utils$2.merge({}, source2);
    } else if (utils$2.isArray(source2)) {
      return source2.slice();
    }
    return source2;
  }
  function mergeDeepProperties(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  }
  utils$2.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(void 0, config2[prop]);
    }
  });
  utils$2.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils$2.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(void 0, config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  utils$2.forEach(directMergeKeys, function merge2(prop) {
    if (prop in config2) {
      config3[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils$2.forEach(otherKeys, mergeDeepProperties);
  return config3;
};
const name = "axios";
const version$2 = "0.21.4";
const description = "Promise based HTTP client for the browser and node.js";
const main = "index.js";
const scripts = {
  test: "grunt test",
  start: "node ./sandbox/server.js",
  build: "NODE_ENV=production grunt build",
  preversion: "npm test",
  version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
  postversion: "git push && git push --tags",
  examples: "node ./examples/server.js",
  coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
  fix: "eslint --fix lib/**/*.js"
};
const repository = {
  type: "git",
  url: "https://github.com/axios/axios.git"
};
const keywords = [
  "xhr",
  "http",
  "ajax",
  "promise",
  "node"
];
const author = "Matt Zabriskie";
const license = "MIT";
const bugs = {
  url: "https://github.com/axios/axios/issues"
};
const homepage = "https://axios-http.com";
const devDependencies = {
  coveralls: "^3.0.0",
  "es6-promise": "^4.2.4",
  grunt: "^1.3.0",
  "grunt-banner": "^0.6.0",
  "grunt-cli": "^1.2.0",
  "grunt-contrib-clean": "^1.1.0",
  "grunt-contrib-watch": "^1.0.0",
  "grunt-eslint": "^23.0.0",
  "grunt-karma": "^4.0.0",
  "grunt-mocha-test": "^0.13.3",
  "grunt-ts": "^6.0.0-beta.19",
  "grunt-webpack": "^4.0.2",
  "istanbul-instrumenter-loader": "^1.0.0",
  "jasmine-core": "^2.4.1",
  karma: "^6.3.2",
  "karma-chrome-launcher": "^3.1.0",
  "karma-firefox-launcher": "^2.1.0",
  "karma-jasmine": "^1.1.1",
  "karma-jasmine-ajax": "^0.1.13",
  "karma-safari-launcher": "^1.0.0",
  "karma-sauce-launcher": "^4.3.6",
  "karma-sinon": "^1.0.5",
  "karma-sourcemap-loader": "^0.3.8",
  "karma-webpack": "^4.0.2",
  "load-grunt-tasks": "^3.5.2",
  minimist: "^1.2.0",
  mocha: "^8.2.1",
  sinon: "^4.5.0",
  "terser-webpack-plugin": "^4.2.3",
  typescript: "^4.0.5",
  "url-search-params": "^0.10.0",
  webpack: "^4.44.2",
  "webpack-dev-server": "^3.11.0"
};
const browser = {
  "./lib/adapters/http.js": "./lib/adapters/xhr.js"
};
const jsdelivr = "dist/axios.min.js";
const unpkg = "dist/axios.min.js";
const typings = "./index.d.ts";
const dependencies = {
  "follow-redirects": "^1.14.0"
};
const bundlesize = [
  {
    path: "./dist/axios.min.js",
    threshold: "5kB"
  }
];
var require$$0 = {
  name,
  version: version$2,
  description,
  main,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  browser,
  jsdelivr,
  unpkg,
  typings,
  dependencies,
  bundlesize
};
var pkg = require$$0;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
var currentVerArr = pkg.version.split(".");
function isOlderVersion(version2, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
  var destVer = version2.split(".");
  for (var i2 = 0; i2 < 3; i2++) {
    if (pkgVersionArr[i2] > destVer[i2]) {
      return true;
    } else if (pkgVersionArr[i2] < destVer[i2]) {
      return false;
    }
  }
  return false;
}
validators$1.transitional = function transitional(validator2, version2, message) {
  var isDeprecated = version2 && isOlderVersion(version2);
  function formatMessage(opt, desc) {
    return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new Error(formatMessage(opt, " has been removed in " + version2));
    }
    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new TypeError("options must be an object");
  }
  var keys2 = Object.keys(options);
  var i2 = keys2.length;
  while (i2-- > 0) {
    var opt = keys2[i2];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new TypeError("option " + opt + " must be " + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error("Unknown option " + opt);
    }
  }
}
var validator$1 = {
  isOlderVersion,
  assertOptions,
  validators: validators$1
};
var utils$1 = utils$d;
var buildURL = buildURL$2;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request2(config2) {
  if (typeof config2 === "string") {
    config2 = arguments[1] || {};
    config2.url = arguments[0];
  } else {
    config2 = config2 || {};
  }
  config2 = mergeConfig$1(this.defaults, config2);
  if (config2.method) {
    config2.method = config2.method.toLowerCase();
  } else if (this.defaults.method) {
    config2.method = this.defaults.method.toLowerCase();
  } else {
    config2.method = "get";
  }
  var transitional2 = config2.transitional;
  if (transitional2 !== void 0) {
    validator.assertOptions(transitional2, {
      silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
      forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
      clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config2);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config2;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }
  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config2) {
  config2 = mergeConfig$1(this.defaults, config2);
  return buildURL(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
};
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios$1.prototype[method] = function(url, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  Axios$1.prototype[method] = function(url, data2, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: data2
    }));
  };
});
var Axios_1 = Axios$1;
function Cancel$1(message) {
  this.message = message;
}
Cancel$1.prototype.toString = function toString2() {
  return "Cancel" + (this.message ? ": " + this.message : "");
};
Cancel$1.prototype.__CANCEL__ = true;
var Cancel_1 = Cancel$1;
var Cancel = Cancel_1;
function CancelToken(executor) {
  if (typeof executor !== "function") {
    throw new TypeError("executor must be a function.");
  }
  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      return;
    }
    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token,
    cancel
  };
};
var CancelToken_1 = CancelToken;
var spread = function spread2(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};
var isAxiosError = function isAxiosError2(payload) {
  return typeof payload === "object" && payload.isAxiosError === true;
};
var utils = utils$d;
var bind = bind$2;
var Axios = Axios_1;
var mergeConfig = mergeConfig$2;
var defaults = defaults_1;
function createInstance(defaultConfig) {
  var context2 = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context2);
  utils.extend(instance, Axios.prototype, context2);
  utils.extend(instance, context2);
  return instance;
}
var axios$1 = createInstance(defaults);
axios$1.Axios = Axios;
axios$1.create = function create4(instanceConfig) {
  return createInstance(mergeConfig(axios$1.defaults, instanceConfig));
};
axios$1.Cancel = Cancel_1;
axios$1.CancelToken = CancelToken_1;
axios$1.isCancel = isCancel$1;
axios$1.all = function all2(promises) {
  return Promise.all(promises);
};
axios$1.spread = spread;
axios$1.isAxiosError = isAxiosError;
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
var axios = axios$2.exports;
var mapObj$1 = { exports: {} };
const isObject$2 = (value) => typeof value === "object" && value !== null;
const mapObjectSkip = Symbol("skip");
const isObjectCustom = (value) => isObject$2(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
const mapObject = (object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
  options = {
    deep: false,
    target: {},
    ...options
  };
  if (isSeen.has(object)) {
    return isSeen.get(object);
  }
  isSeen.set(object, options.target);
  const { target } = options;
  delete options.target;
  const mapArray = (array) => array.map((element) => isObjectCustom(element) ? mapObject(element, mapper, options, isSeen) : element);
  if (Array.isArray(object)) {
    return mapArray(object);
  }
  for (const [key, value] of Object.entries(object)) {
    const mapResult = mapper(key, value, object);
    if (mapResult === mapObjectSkip) {
      continue;
    }
    let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
    if (newKey === "__proto__") {
      continue;
    }
    if (options.deep && shouldRecurse && isObjectCustom(newValue)) {
      newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject(newValue, mapper, options, isSeen);
    }
    target[newKey] = newValue;
  }
  return target;
};
mapObj$1.exports = (object, mapper, options) => {
  if (!isObject$2(object)) {
    throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
  }
  return mapObject(object, mapper, options);
};
mapObj$1.exports.mapObjectSkip = mapObjectSkip;
var camelcase = { exports: {} };
const UPPERCASE = /[\p{Lu}]/u;
const LOWERCASE = /[\p{Ll}]/u;
const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
const SEPARATORS = /[_.\- ]+/;
const LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
const NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
const preserveCamelCase = (string, toLowerCase, toUpperCase) => {
  let isLastCharLower = false;
  let isLastCharUpper = false;
  let isLastLastCharUpper = false;
  for (let i2 = 0; i2 < string.length; i2++) {
    const character = string[i2];
    if (isLastCharLower && UPPERCASE.test(character)) {
      string = string.slice(0, i2) + "-" + string.slice(i2);
      isLastCharLower = false;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = true;
      i2++;
    } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
      string = string.slice(0, i2 - 1) + "-" + string.slice(i2 - 1);
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = false;
      isLastCharLower = true;
    } else {
      isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
    }
  }
  return string;
};
const preserveConsecutiveUppercase = (input, toLowerCase) => {
  LEADING_CAPITAL.lastIndex = 0;
  return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
};
const postProcess = (input, toUpperCase) => {
  SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
  NUMBERS_AND_IDENTIFIER.lastIndex = 0;
  return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
};
const camelCase$1 = (input, options) => {
  if (!(typeof input === "string" || Array.isArray(input))) {
    throw new TypeError("Expected the input to be `string | string[]`");
  }
  options = {
    pascalCase: false,
    preserveConsecutiveUppercase: false,
    ...options
  };
  if (Array.isArray(input)) {
    input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
  } else {
    input = input.trim();
  }
  if (input.length === 0) {
    return "";
  }
  const toLowerCase = options.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale);
  const toUpperCase = options.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
  if (input.length === 1) {
    return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
  }
  const hasUpperCase = input !== toLowerCase(input);
  if (hasUpperCase) {
    input = preserveCamelCase(input, toLowerCase, toUpperCase);
  }
  input = input.replace(LEADING_SEPARATORS, "");
  if (options.preserveConsecutiveUppercase) {
    input = preserveConsecutiveUppercase(input, toLowerCase);
  } else {
    input = toLowerCase(input);
  }
  if (options.pascalCase) {
    input = toUpperCase(input.charAt(0)) + input.slice(1);
  }
  return postProcess(input, toUpperCase);
};
camelcase.exports = camelCase$1;
camelcase.exports.default = camelCase$1;
class QuickLRU {
  constructor(options = {}) {
    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    this.maxSize = options.maxSize;
    this.onEviction = options.onEviction;
    this.cache = /* @__PURE__ */ new Map();
    this.oldCache = /* @__PURE__ */ new Map();
    this._size = 0;
  }
  _set(key, value) {
    this.cache.set(key, value);
    this._size++;
    if (this._size >= this.maxSize) {
      this._size = 0;
      if (typeof this.onEviction === "function") {
        for (const [key2, value2] of this.oldCache.entries()) {
          this.onEviction(key2, value2);
        }
      }
      this.oldCache = this.cache;
      this.cache = /* @__PURE__ */ new Map();
    }
  }
  get(key) {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    if (this.oldCache.has(key)) {
      const value = this.oldCache.get(key);
      this.oldCache.delete(key);
      this._set(key, value);
      return value;
    }
  }
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.set(key, value);
    } else {
      this._set(key, value);
    }
    return this;
  }
  has(key) {
    return this.cache.has(key) || this.oldCache.has(key);
  }
  peek(key) {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    if (this.oldCache.has(key)) {
      return this.oldCache.get(key);
    }
  }
  delete(key) {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this._size--;
    }
    return this.oldCache.delete(key) || deleted;
  }
  clear() {
    this.cache.clear();
    this.oldCache.clear();
    this._size = 0;
  }
  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }
  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }
  *[Symbol.iterator]() {
    for (const item of this.cache) {
      yield item;
    }
    for (const item of this.oldCache) {
      const [key] = item;
      if (!this.cache.has(key)) {
        yield item;
      }
    }
  }
  get size() {
    let oldCacheSize = 0;
    for (const key of this.oldCache.keys()) {
      if (!this.cache.has(key)) {
        oldCacheSize++;
      }
    }
    return Math.min(this._size + oldCacheSize, this.maxSize);
  }
}
var quickLru = QuickLRU;
const mapObj = mapObj$1.exports;
const camelCase = camelcase.exports;
const QuickLru = quickLru;
const has = (array, key) => array.some((x) => {
  if (typeof x === "string") {
    return x === key;
  }
  x.lastIndex = 0;
  return x.test(key);
});
const cache$1 = new QuickLru({ maxSize: 1e5 });
const isObject$1 = (value) => typeof value === "object" && value !== null && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
const camelCaseConvert = (input, options) => {
  if (!isObject$1(input)) {
    return input;
  }
  options = {
    deep: false,
    pascalCase: false,
    ...options
  };
  const { exclude, pascalCase, stopPaths, deep } = options;
  const stopPathsSet = new Set(stopPaths);
  const makeMapper = (parentPath) => (key, value) => {
    if (deep && isObject$1(value)) {
      const path = parentPath === void 0 ? key : `${parentPath}.${key}`;
      if (!stopPathsSet.has(path)) {
        value = mapObj(value, makeMapper(path));
      }
    }
    if (!(exclude && has(exclude, key))) {
      const cacheKey = pascalCase ? `${key}_` : key;
      if (cache$1.has(cacheKey)) {
        key = cache$1.get(cacheKey);
      } else {
        const returnValue = camelCase(key, { pascalCase, locale: false });
        if (key.length < 100) {
          cache$1.set(cacheKey, returnValue);
        }
        key = returnValue;
      }
    }
    return [key, value];
  };
  return mapObj(input, makeMapper(void 0));
};
var camelcaseKeys = (input, options) => {
  if (Array.isArray(input)) {
    return Object.keys(input).map((key) => camelCaseConvert(input[key], options));
  }
  return camelCaseConvert(input, options);
};
var __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(TwirpRPC, "__esModule", { value: true });
TwirpRPC.TwirpRpc = TwirpRPC.livekitPackage = void 0;
const axios_1 = __importDefault(axios);
const camelcase_keys_1 = __importDefault(camelcaseKeys);
const defaultPrefix = "/twirp";
TwirpRPC.livekitPackage = "livekit";
class TwirpRpc {
  constructor(host, pkg2, prefix, hostHeader) {
    this.host = host;
    this.pkg = pkg2;
    this.prefix = prefix || defaultPrefix;
    let config2 = { baseURL: host };
    if (hostHeader != void 0)
      config2.headers = { Host: hostHeader };
    this.instance = axios_1.default.create(config2);
  }
  request(service2, method, data2, headers) {
    return new Promise((resolve, reject) => {
      const path = `${this.prefix}/${this.pkg}.${service2}/${method}`;
      this.instance.post(path, data2, { headers }).then((res) => {
        resolve(camelcase_keys_1.default(res.data, { deep: true }));
      }).catch(reject);
    });
  }
}
TwirpRPC.TwirpRpc = TwirpRpc;
var __awaiter = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(RoomServiceClient$1, "__esModule", { value: true });
RoomServiceClient$1.RoomServiceClient = void 0;
const livekit_models_1 = livekit_models;
const livekit_room_1 = livekit_room;
const TwirpRPC_1 = TwirpRPC;
const svc = "RoomService";
class RoomServiceClient {
  constructor(host, apiKey, secret, jwt, hostHeader) {
    this.rpc = new TwirpRPC_1.TwirpRpc(host, TwirpRPC_1.livekitPackage, void 0, hostHeader);
    this.apiKey = apiKey;
    this.secret = secret;
    this.jwt = jwt;
  }
  createRoom(options) {
    return __awaiter(this, void 0, void 0, function* () {
      const data2 = yield this.rpc.request(svc, "CreateRoom", livekit_room_1.CreateRoomRequest.toJSON(livekit_room_1.CreateRoomRequest.fromPartial(options)), this.authHeader({ roomCreate: true }));
      return livekit_models_1.Room.fromJSON(data2);
    });
  }
  listRooms(names) {
    return __awaiter(this, void 0, void 0, function* () {
      const data2 = yield this.rpc.request(svc, "ListRooms", livekit_room_1.ListRoomsRequest.toJSON({ names: names !== null && names !== void 0 ? names : [] }), this.authHeader({ roomList: true }));
      const res = livekit_room_1.ListRoomsResponse.fromJSON(data2);
      return res.rooms;
    });
  }
  deleteRoom(room) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.rpc.request(svc, "DeleteRoom", livekit_room_1.DeleteRoomRequest.toJSON({ room }), this.authHeader({ roomCreate: true }));
    });
  }
  updateRoomMetadata(room, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const data2 = yield this.rpc.request(svc, "UpdateRoomMetadata", livekit_room_1.UpdateRoomMetadataRequest.toJSON({ room, metadata }), this.authHeader({ roomAdmin: true, room }));
      return livekit_models_1.Room.fromJSON(data2);
    });
  }
  listParticipants(room) {
    return __awaiter(this, void 0, void 0, function* () {
      const data2 = yield this.rpc.request(svc, "ListParticipants", livekit_room_1.ListParticipantsRequest.toJSON({ room }), this.authHeader({ roomAdmin: true, room }));
      const res = livekit_room_1.ListParticipantsResponse.fromJSON(data2);
      return res.participants;
    });
  }
  getParticipant(room, identity2) {
    return __awaiter(this, void 0, void 0, function* () {
      const data2 = yield this.rpc.request(svc, "GetParticipant", livekit_room_1.RoomParticipantIdentity.toJSON({ room, identity: identity2 }), this.authHeader({ roomAdmin: true, room }));
      return livekit_models_1.ParticipantInfo.fromJSON(data2);
    });
  }
  removeParticipant(room, identity2) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.rpc.request(svc, "RemoveParticipant", livekit_room_1.RoomParticipantIdentity.toJSON({ room, identity: identity2 }), this.authHeader({ roomAdmin: true, room }));
    });
  }
  mutePublishedTrack(room, identity2, trackSid, muted) {
    return __awaiter(this, void 0, void 0, function* () {
      const req = livekit_room_1.MuteRoomTrackRequest.toJSON({
        room,
        identity: identity2,
        trackSid,
        muted
      });
      const data2 = yield this.rpc.request(svc, "MutePublishedTrack", req, this.authHeader({ roomAdmin: true, room }));
      const res = livekit_room_1.MuteRoomTrackResponse.fromJSON(data2);
      return res.track;
    });
  }
  updateParticipant(room, identity2, metadata, permission) {
    return __awaiter(this, void 0, void 0, function* () {
      const req = {
        room,
        identity: identity2,
        metadata: metadata || "",
        permission
      };
      const data2 = yield this.rpc.request(svc, "UpdateParticipant", livekit_room_1.UpdateParticipantRequest.toJSON(req), this.authHeader({ roomAdmin: true, room }));
      return livekit_models_1.ParticipantInfo.fromJSON(data2);
    });
  }
  updateSubscriptions(room, identity2, trackSids, subscribe2) {
    return __awaiter(this, void 0, void 0, function* () {
      const req = livekit_room_1.UpdateSubscriptionsRequest.toJSON({
        room,
        identity: identity2,
        trackSids,
        subscribe: subscribe2,
        participantTracks: []
      });
      yield this.rpc.request(svc, "UpdateSubscriptions", req, this.authHeader({ roomAdmin: true, room }));
    });
  }
  sendData(room, data2, kind, destinationSids = []) {
    return __awaiter(this, void 0, void 0, function* () {
      const req = livekit_room_1.SendDataRequest.toJSON({
        room,
        data: data2,
        kind,
        destinationSids
      });
      yield this.rpc.request(svc, "SendData", req, this.authHeader({ roomAdmin: true, room }));
    });
  }
  authHeader(grant) {
    if (this.jwt != void 0) {
      return {
        Authorization: `Bearer ${this.jwt}`
      };
    }
  }
}
RoomServiceClient$1.RoomServiceClient = RoomServiceClient;
(function(exports2) {
  var __createBinding2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o2[k2] = m[k];
  });
  var __exportStar = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding2(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TrackType = exports2.TrackInfo = exports2.Room = exports2.ParticipantInfo_State = exports2.ParticipantInfo = exports2.DataPacket_Kind = void 0;
  __exportStar(grants, exports2);
  var livekit_models_12 = livekit_models;
  Object.defineProperty(exports2, "DataPacket_Kind", { enumerable: true, get: function() {
    return livekit_models_12.DataPacket_Kind;
  } });
  Object.defineProperty(exports2, "ParticipantInfo", { enumerable: true, get: function() {
    return livekit_models_12.ParticipantInfo;
  } });
  Object.defineProperty(exports2, "ParticipantInfo_State", { enumerable: true, get: function() {
    return livekit_models_12.ParticipantInfo_State;
  } });
  Object.defineProperty(exports2, "Room", { enumerable: true, get: function() {
    return livekit_models_12.Room;
  } });
  Object.defineProperty(exports2, "TrackInfo", { enumerable: true, get: function() {
    return livekit_models_12.TrackInfo;
  } });
  Object.defineProperty(exports2, "TrackType", { enumerable: true, get: function() {
    return livekit_models_12.TrackType;
  } });
  __exportStar(RoomServiceClient$1, exports2);
})(dist);
function _mergeNamespaces(n2, m) {
  m.forEach(function(e2) {
    e2 && typeof e2 !== "string" && !Array.isArray(e2) && Object.keys(e2).forEach(function(k) {
      if (k !== "default" && !(k in n2)) {
        var d = Object.getOwnPropertyDescriptor(e2, k);
        Object.defineProperty(n2, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return e2[k];
          }
        });
      }
    });
  });
  return Object.freeze(n2);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var loglevelExports = {};
var loglevel = {
  get exports() {
    return loglevelExports;
  },
  set exports(v) {
    loglevelExports = v;
  }
};
(function(module2) {
  (function(root2, definition) {
    if (module2.exports) {
      module2.exports = definition();
    } else {
      root2.log = definition();
    }
  })(commonjsGlobal, function() {
    var noop2 = function() {
    };
    var undefinedType = "undefined";
    var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
    var logMethods = ["trace", "debug", "info", "warn", "error"];
    function bindMethod(obj, methodName) {
      var method = obj[methodName];
      if (typeof method.bind === "function") {
        return method.bind(obj);
      } else {
        try {
          return Function.prototype.bind.call(method, obj);
        } catch (e2) {
          return function() {
            return Function.prototype.apply.apply(method, [obj, arguments]);
          };
        }
      }
    }
    function traceForIE() {
      if (console.log) {
        if (console.log.apply) {
          console.log.apply(console, arguments);
        } else {
          Function.prototype.apply.apply(console.log, [console, arguments]);
        }
      }
      if (console.trace)
        console.trace();
    }
    function realMethod(methodName) {
      if (methodName === "debug") {
        methodName = "log";
      }
      if (typeof console === undefinedType) {
        return false;
      } else if (methodName === "trace" && isIE) {
        return traceForIE;
      } else if (console[methodName] !== void 0) {
        return bindMethod(console, methodName);
      } else if (console.log !== void 0) {
        return bindMethod(console, "log");
      } else {
        return noop2;
      }
    }
    function replaceLoggingMethods(level, loggerName) {
      for (var i2 = 0; i2 < logMethods.length; i2++) {
        var methodName = logMethods[i2];
        this[methodName] = i2 < level ? noop2 : this.methodFactory(methodName, level, loggerName);
      }
      this.log = this.debug;
    }
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
      return function() {
        if (typeof console !== undefinedType) {
          replaceLoggingMethods.call(this, level, loggerName);
          this[methodName].apply(this, arguments);
        }
      };
    }
    function defaultMethodFactory(methodName, level, loggerName) {
      return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
    }
    function Logger(name2, defaultLevel, factory2) {
      var self2 = this;
      var currentLevel;
      defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;
      var storageKey = "loglevel";
      if (typeof name2 === "string") {
        storageKey += ":" + name2;
      } else if (typeof name2 === "symbol") {
        storageKey = void 0;
      }
      function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || "silent").toUpperCase();
        if (typeof window === undefinedType || !storageKey)
          return;
        try {
          window.localStorage[storageKey] = levelName;
          return;
        } catch (ignore) {
        }
        try {
          window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
        } catch (ignore) {
        }
      }
      function getPersistedLevel() {
        var storedLevel;
        if (typeof window === undefinedType || !storageKey)
          return;
        try {
          storedLevel = window.localStorage[storageKey];
        } catch (ignore) {
        }
        if (typeof storedLevel === undefinedType) {
          try {
            var cookie = window.document.cookie;
            var location = cookie.indexOf(encodeURIComponent(storageKey) + "=");
            if (location !== -1) {
              storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
            }
          } catch (ignore) {
          }
        }
        if (self2.levels[storedLevel] === void 0) {
          storedLevel = void 0;
        }
        return storedLevel;
      }
      function clearPersistedLevel() {
        if (typeof window === undefinedType || !storageKey)
          return;
        try {
          window.localStorage.removeItem(storageKey);
          return;
        } catch (ignore) {
        }
        try {
          window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
        } catch (ignore) {
        }
      }
      self2.name = name2;
      self2.levels = {
        "TRACE": 0,
        "DEBUG": 1,
        "INFO": 2,
        "WARN": 3,
        "ERROR": 4,
        "SILENT": 5
      };
      self2.methodFactory = factory2 || defaultMethodFactory;
      self2.getLevel = function() {
        return currentLevel;
      };
      self2.setLevel = function(level, persist) {
        if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
          level = self2.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
          currentLevel = level;
          if (persist !== false) {
            persistLevelIfPossible(level);
          }
          replaceLoggingMethods.call(self2, level, name2);
          if (typeof console === undefinedType && level < self2.levels.SILENT) {
            return "No console available for logging";
          }
        } else {
          throw "log.setLevel() called with invalid level: " + level;
        }
      };
      self2.setDefaultLevel = function(level) {
        defaultLevel = level;
        if (!getPersistedLevel()) {
          self2.setLevel(level, false);
        }
      };
      self2.resetLevel = function() {
        self2.setLevel(defaultLevel, false);
        clearPersistedLevel();
      };
      self2.enableAll = function(persist) {
        self2.setLevel(self2.levels.TRACE, persist);
      };
      self2.disableAll = function(persist) {
        self2.setLevel(self2.levels.SILENT, persist);
      };
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
        initialLevel = defaultLevel;
      }
      self2.setLevel(initialLevel, false);
    }
    var defaultLogger = new Logger();
    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name2) {
      if (typeof name2 !== "symbol" && typeof name2 !== "string" || name2 === "") {
        throw new TypeError("You must supply a name when creating a logger.");
      }
      var logger2 = _loggersByName[name2];
      if (!logger2) {
        logger2 = _loggersByName[name2] = new Logger(name2, defaultLogger.getLevel(), defaultLogger.methodFactory);
      }
      return logger2;
    };
    var _log = typeof window !== undefinedType ? window.log : void 0;
    defaultLogger.noConflict = function() {
      if (typeof window !== undefinedType && window.log === defaultLogger) {
        window.log = _log;
      }
      return defaultLogger;
    };
    defaultLogger.getLoggers = function getLoggers() {
      return _loggersByName;
    };
    defaultLogger["default"] = defaultLogger;
    return defaultLogger;
  });
})(loglevel);
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["trace"] = 0] = "trace";
  LogLevel2[LogLevel2["debug"] = 1] = "debug";
  LogLevel2[LogLevel2["info"] = 2] = "info";
  LogLevel2[LogLevel2["warn"] = 3] = "warn";
  LogLevel2[LogLevel2["error"] = 4] = "error";
  LogLevel2[LogLevel2["silent"] = 5] = "silent";
})(LogLevel || (LogLevel = {}));
const livekitLogger = loglevelExports.getLogger("livekit");
livekitLogger.setLevel(LogLevel.info);
function setLogLevel(level) {
  livekitLogger.setLevel(level);
}
var long = Long;
var wasm = null;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
} catch (e2) {
}
function Long(low, high, unsigned) {
  this.low = low | 0;
  this.high = high | 0;
  this.unsigned = !!unsigned;
}
Long.prototype.__isLong__;
Object.defineProperty(Long.prototype, "__isLong__", {
  value: true
});
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}
Long.isLong = isLong;
var INT_CACHE = {};
var UINT_CACHE = {};
function fromInt(value, unsigned) {
  var obj, cachedObj, cache2;
  if (unsigned) {
    value >>>= 0;
    if (cache2 = 0 <= value && value < 256) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
    if (cache2)
      UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache2 = -128 <= value && value < 128) {
      cachedObj = INT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache2)
      INT_CACHE[value] = obj;
    return obj;
  }
}
Long.fromInt = fromInt;
function fromNumber(value, unsigned) {
  if (isNaN(value))
    return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0)
      return UZERO;
    if (value >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL)
      return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  if (value < 0)
    return fromNumber(-value, unsigned).neg();
  return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
}
Long.fromNumber = fromNumber;
function fromBits(lowBits, highBits, unsigned) {
  return new Long(lowBits, highBits, unsigned);
}
Long.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(str, unsigned, radix) {
  if (str.length === 0)
    throw Error("empty string");
  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
    return ZERO;
  if (typeof unsigned === "number") {
    radix = unsigned, unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError("radix");
  var p;
  if ((p = str.indexOf("-")) > 0)
    throw Error("interior hyphen");
  else if (p === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  }
  var radixToPower = fromNumber(pow_dbl(radix, 8));
  var result = ZERO;
  for (var i2 = 0; i2 < str.length; i2 += 8) {
    var size = Math.min(8, str.length - i2), value = parseInt(str.substring(i2, i2 + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}
Long.fromString = fromString;
function fromValue(val, unsigned) {
  if (typeof val === "number")
    return fromNumber(val, unsigned);
  if (typeof val === "string")
    return fromString(val, unsigned);
  return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
}
Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
var ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, true);
Long.UZERO = UZERO;
var ONE = fromInt(1);
Long.ONE = ONE;
var UONE = fromInt(1, true);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function toNumber3() {
  if (this.unsigned)
    return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
LongPrototype.toString = function toString3(radix) {
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative()) {
    if (this.eq(MIN_VALUE)) {
      var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
      return div.toString(radix) + rem1.toInt().toString(radix);
    } else
      return "-" + this.neg().toString(radix);
  }
  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
  var result = "";
  while (true) {
    var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
    rem = remDiv;
    if (rem.isZero())
      return digits + result;
    else {
      while (digits.length < 6)
        digits = "0" + digits;
      result = "" + digits + result;
    }
  }
};
LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val = this.high != 0 ? this.high : this.low;
  for (var bit = 31; bit > 0; bit--)
    if ((val & 1 << bit) != 0)
      break;
  return this.high != 0 ? bit + 33 : bit + 1;
};
LongPrototype.isZero = function isZero() {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function isNegative() {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function isOdd() {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function isEven() {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function equals(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
    return false;
  return this.high === other.high && this.low === other.low;
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(other);
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function lessThan(other) {
  return this.comp(other) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(other) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(other) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(other) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function compare(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.eq(other))
    return 0;
  var thisNeg = this.isNegative(), otherNeg = other.isNegative();
  if (thisNeg && !otherNeg)
    return -1;
  if (!thisNeg && otherNeg)
    return 1;
  if (!this.unsigned)
    return this.sub(other).isNegative() ? -1 : 1;
  return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function negate() {
  if (!this.unsigned && this.eq(MIN_VALUE))
    return MIN_VALUE;
  return this.not().add(ONE);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function add(addend) {
  if (!isLong(addend))
    addend = fromValue(addend);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = addend.high >>> 16;
  var b32 = addend.high & 65535;
  var b16 = addend.low >>> 16;
  var b00 = addend.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 + b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.subtract = function subtract(subtrahend) {
  if (!isLong(subtrahend))
    subtrahend = fromValue(subtrahend);
  return this.add(subtrahend.neg());
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function multiply(multiplier) {
  if (this.isZero())
    return ZERO;
  if (!isLong(multiplier))
    multiplier = fromValue(multiplier);
  if (wasm) {
    var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
    return fromBits(low, wasm.get_high(), this.unsigned);
  }
  if (multiplier.isZero())
    return ZERO;
  if (this.eq(MIN_VALUE))
    return multiplier.isOdd() ? MIN_VALUE : ZERO;
  if (multiplier.eq(MIN_VALUE))
    return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative()) {
    if (multiplier.isNegative())
      return this.neg().mul(multiplier.neg());
    else
      return this.neg().mul(multiplier).neg();
  } else if (multiplier.isNegative())
    return this.mul(multiplier.neg()).neg();
  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = multiplier.high >>> 16;
  var b32 = multiplier.high & 65535;
  var b16 = multiplier.low >>> 16;
  var b00 = multiplier.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function divide(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);
  if (divisor.isZero())
    throw Error("division by zero");
  if (wasm) {
    if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
      return this;
    }
    var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
    return fromBits(low, wasm.get_high(), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? UZERO : ZERO;
  var approx, rem, res;
  if (!this.unsigned) {
    if (this.eq(MIN_VALUE)) {
      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
        return MIN_VALUE;
      else if (divisor.eq(MIN_VALUE))
        return ONE;
      else {
        var halfThis = this.shr(1);
        approx = halfThis.div(divisor).shl(1);
        if (approx.eq(ZERO)) {
          return divisor.isNegative() ? ONE : NEG_ONE;
        } else {
          rem = this.sub(divisor.mul(approx));
          res = approx.add(rem.div(divisor));
          return res;
        }
      }
    } else if (divisor.eq(MIN_VALUE))
      return this.unsigned ? UZERO : ZERO;
    if (this.isNegative()) {
      if (divisor.isNegative())
        return this.neg().div(divisor.neg());
      return this.neg().div(divisor).neg();
    } else if (divisor.isNegative())
      return this.div(divisor.neg()).neg();
    res = ZERO;
  } else {
    if (!divisor.unsigned)
      divisor = divisor.toUnsigned();
    if (divisor.gt(this))
      return UZERO;
    if (divisor.gt(this.shru(1)))
      return UONE;
    res = UZERO;
  }
  rem = this;
  while (rem.gte(divisor)) {
    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
    var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
    while (approxRem.isNegative() || approxRem.gt(rem)) {
      approx -= delta;
      approxRes = fromNumber(approx, this.unsigned);
      approxRem = approxRes.mul(divisor);
    }
    if (approxRes.isZero())
      approxRes = ONE;
    res = res.add(approxRes);
    rem = rem.sub(approxRem);
  }
  return res;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function modulo(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);
  if (wasm) {
    var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
    return fromBits(low, wasm.get_high(), this.unsigned);
  }
  return this.sub(this.div(divisor).mul(divisor));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function not2() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.and = function and(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};
LongPrototype.or = function or(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};
LongPrototype.xor = function xor(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};
LongPrototype.shiftLeft = function shiftLeft(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
  else
    return fromBits(0, this.low << numBits - 32, this.unsigned);
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function shiftRight(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
  else
    return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  numBits &= 63;
  if (numBits === 0)
    return this;
  else {
    var high = this.high;
    if (numBits < 32) {
      var low = this.low;
      return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
    } else if (numBits === 32)
      return fromBits(high, 0, this.unsigned);
    else
      return fromBits(high >>> numBits - 32, 0, this.unsigned);
  }
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned)
    return this;
  return fromBits(this.low, this.high, false);
};
LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned)
    return this;
  return fromBits(this.low, this.high, true);
};
LongPrototype.toBytes = function toBytes(le) {
  return le ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function toBytesLE() {
  var hi = this.high, lo = this.low;
  return [lo & 255, lo >>> 8 & 255, lo >>> 16 & 255, lo >>> 24, hi & 255, hi >>> 8 & 255, hi >>> 16 & 255, hi >>> 24];
};
LongPrototype.toBytesBE = function toBytesBE() {
  var hi = this.high, lo = this.low;
  return [hi >>> 24, hi >>> 16 & 255, hi >>> 8 & 255, hi & 255, lo >>> 24, lo >>> 16 & 255, lo >>> 8 & 255, lo & 255];
};
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
  return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
  return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
};
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
  return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
};
var minimalExports = {};
var minimal$1 = {
  get exports() {
    return minimalExports;
  },
  set exports(v) {
    minimalExports = v;
  }
};
var indexMinimal = {};
var minimal = {};
var aspromise;
var hasRequiredAspromise;
function requireAspromise() {
  if (hasRequiredAspromise)
    return aspromise;
  hasRequiredAspromise = 1;
  aspromise = asPromise2;
  function asPromise2(fn, ctx) {
    var params = new Array(arguments.length - 1), offset = 0, index2 = 2, pending = true;
    while (index2 < arguments.length)
      params[offset++] = arguments[index2++];
    return new Promise(function executor(resolve, reject) {
      params[offset] = function callback(err) {
        if (pending) {
          pending = false;
          if (err)
            reject(err);
          else {
            var params2 = new Array(arguments.length - 1), offset2 = 0;
            while (offset2 < params2.length)
              params2[offset2++] = arguments[offset2];
            resolve.apply(null, params2);
          }
        }
      };
      try {
        fn.apply(ctx || null, params);
      } catch (err) {
        if (pending) {
          pending = false;
          reject(err);
        }
      }
    });
  }
  return aspromise;
}
var base64$1 = {};
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64)
    return base64$1;
  hasRequiredBase64 = 1;
  (function(exports2) {
    var base642 = exports2;
    base642.length = function length2(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n2 = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n2;
      return Math.ceil(string.length * 3) / 4 - n2;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (var i2 = 0; i2 < 64; )
      s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
    base642.encode = function encode2(buffer2, start2, end3) {
      var parts = null, chunk = [];
      var i3 = 0, j = 0, t2;
      while (start2 < end3) {
        var b = buffer2[start2++];
        switch (j) {
          case 0:
            chunk[i3++] = b64[b >> 2];
            t2 = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i3++] = b64[t2 | b >> 4];
            t2 = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i3++] = b64[t2 | b >> 6];
            chunk[i3++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i3 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i3 = 0;
        }
      }
      if (j) {
        chunk[i3++] = b64[t2];
        chunk[i3++] = 61;
        if (j === 1)
          chunk[i3++] = 61;
      }
      if (parts) {
        if (i3)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i3));
    };
    var invalidEncoding = "invalid encoding";
    base642.decode = function decode(string, buffer2, offset) {
      var start2 = offset;
      var j = 0, t2;
      for (var i3 = 0; i3 < string.length; ) {
        var c = string.charCodeAt(i3++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t2 = c;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t2 << 2 | (c & 48) >> 4;
            t2 = c;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t2 & 15) << 4 | (c & 60) >> 2;
            t2 = c;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t2 & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start2;
    };
    base642.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  })(base64$1);
  return base64$1;
}
var eventemitter;
var hasRequiredEventemitter;
function requireEventemitter() {
  if (hasRequiredEventemitter)
    return eventemitter;
  hasRequiredEventemitter = 1;
  eventemitter = EventEmitter2;
  function EventEmitter2() {
    this._listeners = {};
  }
  EventEmitter2.prototype.on = function on3(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
      fn,
      ctx: ctx || this
    });
    return this;
  };
  EventEmitter2.prototype.off = function off2(evt, fn) {
    if (evt === void 0)
      this._listeners = {};
    else {
      if (fn === void 0)
        this._listeners[evt] = [];
      else {
        var listeners2 = this._listeners[evt];
        for (var i2 = 0; i2 < listeners2.length; )
          if (listeners2[i2].fn === fn)
            listeners2.splice(i2, 1);
          else
            ++i2;
      }
    }
    return this;
  };
  EventEmitter2.prototype.emit = function emit3(evt) {
    var listeners2 = this._listeners[evt];
    if (listeners2) {
      var args = [], i2 = 1;
      for (; i2 < arguments.length; )
        args.push(arguments[i2++]);
      for (i2 = 0; i2 < listeners2.length; )
        listeners2[i2].fn.apply(listeners2[i2++].ctx, args);
    }
    return this;
  };
  return eventemitter;
}
var float;
var hasRequiredFloat;
function requireFloat() {
  if (hasRequiredFloat)
    return float;
  hasRequiredFloat = 1;
  float = factory2(factory2);
  function factory2(exports2) {
    if (typeof Float32Array !== "undefined")
      (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        exports2.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports2.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        exports2.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports2.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
    else
      (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports2.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE2);
        exports2.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE2);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports2.readFloatLE = readFloat_ieee754.bind(null, readUintLE2);
        exports2.readFloatBE = readFloat_ieee754.bind(null, readUintBE2);
      })();
    if (typeof Float64Array !== "undefined")
      (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        exports2.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports2.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        exports2.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports2.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
    else
      (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf, pos + off0);
            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports2.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE2, 0, 4);
        exports2.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE2, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports2.readDoubleLE = readDouble_ieee754.bind(null, readUintLE2, 0, 4);
        exports2.readDoubleBE = readDouble_ieee754.bind(null, readUintBE2, 4, 0);
      })();
    return exports2;
  }
  function writeUintLE2(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  function writeUintBE2(val, buf, pos) {
    buf[pos] = val >>> 24;
    buf[pos + 1] = val >>> 16 & 255;
    buf[pos + 2] = val >>> 8 & 255;
    buf[pos + 3] = val & 255;
  }
  function readUintLE2(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
  }
  function readUintBE2(buf, pos) {
    return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
  }
  return float;
}
var inquire_1;
var hasRequiredInquire;
function requireInquire() {
  if (hasRequiredInquire)
    return inquire_1;
  hasRequiredInquire = 1;
  inquire_1 = inquire2;
  function inquire2(moduleName2) {
    try {
      var mod2 = void 0;
      if (mod2 && (mod2.length || Object.keys(mod2).length))
        return mod2;
    } catch (e2) {
    }
    return null;
  }
  return inquire_1;
}
var utf8$2 = {};
var hasRequiredUtf8;
function requireUtf8() {
  if (hasRequiredUtf8)
    return utf8$2;
  hasRequiredUtf8 = 1;
  (function(exports2) {
    var utf82 = exports2;
    utf82.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i2 = 0; i2 < string.length; ++i2) {
        c = string.charCodeAt(i2);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i2 + 1) & 64512) === 56320) {
          ++i2;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf82.read = function utf8_read(buffer2, start2, end3) {
      var len = end3 - start2;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i2 = 0, t2;
      while (start2 < end3) {
        t2 = buffer2[start2++];
        if (t2 < 128)
          chunk[i2++] = t2;
        else if (t2 > 191 && t2 < 224)
          chunk[i2++] = (t2 & 31) << 6 | buffer2[start2++] & 63;
        else if (t2 > 239 && t2 < 365) {
          t2 = ((t2 & 7) << 18 | (buffer2[start2++] & 63) << 12 | (buffer2[start2++] & 63) << 6 | buffer2[start2++] & 63) - 65536;
          chunk[i2++] = 55296 + (t2 >> 10);
          chunk[i2++] = 56320 + (t2 & 1023);
        } else
          chunk[i2++] = (t2 & 15) << 12 | (buffer2[start2++] & 63) << 6 | buffer2[start2++] & 63;
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    utf82.write = function utf8_write(string, buffer2, offset) {
      var start2 = offset, c1, c2;
      for (var i2 = 0; i2 < string.length; ++i2) {
        c1 = string.charCodeAt(i2);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i2 + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i2;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start2;
    };
  })(utf8$2);
  return utf8$2;
}
var pool_1;
var hasRequiredPool;
function requirePool() {
  if (hasRequiredPool)
    return pool_1;
  hasRequiredPool = 1;
  pool_1 = pool2;
  function pool2(alloc3, slice2, size) {
    var SIZE = size || 8192;
    var MAX = SIZE >>> 1;
    var slab = null;
    var offset = SIZE;
    return function pool_alloc(size2) {
      if (size2 < 1 || size2 > MAX)
        return alloc3(size2);
      if (offset + size2 > SIZE) {
        slab = alloc3(SIZE);
        offset = 0;
      }
      var buf = slice2.call(slab, offset, offset += size2);
      if (offset & 7)
        offset = (offset | 7) + 1;
      return buf;
    };
  }
  return pool_1;
}
var longbits;
var hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1;
  longbits = LongBits2;
  var util2 = requireMinimal();
  function LongBits2(lo, hi) {
    this.lo = lo >>> 0;
    this.hi = hi >>> 0;
  }
  var zero2 = LongBits2.zero = new LongBits2(0, 0);
  zero2.toNumber = function() {
    return 0;
  };
  zero2.zzEncode = zero2.zzDecode = function() {
    return this;
  };
  zero2.length = function() {
    return 1;
  };
  var zeroHash2 = LongBits2.zeroHash = "\0\0\0\0\0\0\0\0";
  LongBits2.fromNumber = function fromNumber3(value) {
    if (value === 0)
      return zero2;
    var sign = value < 0;
    if (sign)
      value = -value;
    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295)
          hi = 0;
      }
    }
    return new LongBits2(lo, hi);
  };
  LongBits2.from = function from3(value) {
    if (typeof value === "number")
      return LongBits2.fromNumber(value);
    if (util2.isString(value)) {
      if (util2.Long)
        value = util2.Long.fromString(value);
      else
        return LongBits2.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits2(value.low >>> 0, value.high >>> 0) : zero2;
  };
  LongBits2.prototype.toNumber = function toNumber4(unsigned) {
    if (!unsigned && this.hi >>> 31) {
      var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
      if (!lo)
        hi = hi + 1 >>> 0;
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits2.prototype.toLong = function toLong2(unsigned) {
    return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {
      low: this.lo | 0,
      high: this.hi | 0,
      unsigned: Boolean(unsigned)
    };
  };
  var charCodeAt2 = String.prototype.charCodeAt;
  LongBits2.fromHash = function fromHash2(hash) {
    if (hash === zeroHash2)
      return zero2;
    return new LongBits2((charCodeAt2.call(hash, 0) | charCodeAt2.call(hash, 1) << 8 | charCodeAt2.call(hash, 2) << 16 | charCodeAt2.call(hash, 3) << 24) >>> 0, (charCodeAt2.call(hash, 4) | charCodeAt2.call(hash, 5) << 8 | charCodeAt2.call(hash, 6) << 16 | charCodeAt2.call(hash, 7) << 24) >>> 0);
  };
  LongBits2.prototype.toHash = function toHash2() {
    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
  };
  LongBits2.prototype.zzEncode = function zzEncode2() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  };
  LongBits2.prototype.zzDecode = function zzDecode2() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  };
  LongBits2.prototype.length = function length2() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
  return longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  if (hasRequiredMinimal)
    return minimal;
  hasRequiredMinimal = 1;
  (function(exports2) {
    var util2 = exports2;
    util2.asPromise = requireAspromise();
    util2.base64 = requireBase64();
    util2.EventEmitter = requireEventemitter();
    util2.float = requireFloat();
    util2.inquire = requireInquire();
    util2.utf8 = requireUtf8();
    util2.pool = requirePool();
    util2.LongBits = requireLongbits();
    util2.isNode = Boolean(typeof commonjsGlobal !== "undefined" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node);
    util2.global = util2.isNode && commonjsGlobal || typeof window !== "undefined" && window || typeof self !== "undefined" && self || commonjsGlobal;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : [];
    util2.emptyObject = Object.freeze ? Object.freeze({}) : {};
    util2.isInteger = Number.isInteger || function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util2.isString = function isString2(value) {
      return typeof value === "string" || value instanceof String;
    };
    util2.isObject = function isObject2(value) {
      return value && typeof value === "object";
    };
    util2.isset = util2.isSet = function isSet2(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer2 = util2.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : null;
      } catch (e2) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = util2.global.dcodeIO && util2.global.dcodeIO.Long || util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value) {
      return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util2.LongBits.fromHash(hash);
      if (util2.Long)
        return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge2(dst, src, ifNotSet) {
      for (var keys2 = Object.keys(src), i2 = 0; i2 < keys2.length; ++i2)
        if (dst[keys2[i2]] === void 0 || !ifNotSet)
          dst[keys2[i2]] = src[keys2[i2]];
      return dst;
    }
    util2.merge = merge2;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name2) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", {
          get: function() {
            return message;
          }
        });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", {
            value: new Error().stack || ""
          });
        if (properties)
          merge2(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get() {
            return name2;
          },
          set: void 0,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys2 = Object.keys(this), i3 = keys2.length - 1; i3 > -1; --i3)
          if (fieldMap[keys2[i3]] === 1 && this[keys2[i3]] !== void 0 && this[keys2[i3]] !== null)
            return keys2[i3];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name2) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name2)
            delete this[fieldNames[i2]];
      };
    };
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer2 = util2.Buffer;
      if (!Buffer2) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  })(minimal);
  return minimal;
}
var writer$2 = Writer$1;
var util$4 = requireMinimal();
var BufferWriter$1;
var LongBits$1 = util$4.LongBits, base64 = util$4.base64, utf8$1 = util$4.utf8;
function Op(fn, len, val) {
  this.fn = fn;
  this.len = len;
  this.next = void 0;
  this.val = val;
}
function noop$1() {
}
function State(writer2) {
  this.head = writer2.head;
  this.tail = writer2.tail;
  this.len = writer2.len;
  this.next = writer2.states;
}
function Writer$1() {
  this.len = 0;
  this.head = new Op(noop$1, 0, 0);
  this.tail = this.head;
  this.states = null;
}
var create$1$1 = function create5() {
  return util$4.Buffer ? function create_buffer_setup() {
    return (Writer$1.create = function create_buffer() {
      return new BufferWriter$1();
    })();
  } : function create_array4() {
    return new Writer$1();
  };
};
Writer$1.create = create$1$1();
Writer$1.alloc = function alloc2(size) {
  return new util$4.Array(size);
};
if (util$4.Array !== Array)
  Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray);
Writer$1.prototype._push = function push2(fn, len, val) {
  this.tail = this.tail.next = new Op(fn, len, val);
  this.len += len;
  return this;
};
function writeByte(val, buf, pos) {
  buf[pos] = val & 255;
}
function writeVarint32(val, buf, pos) {
  while (val > 127) {
    buf[pos++] = val & 127 | 128;
    val >>>= 7;
  }
  buf[pos] = val;
}
function VarintOp(len, val) {
  this.len = len;
  this.next = void 0;
  this.val = val;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function write_uint322(value) {
  this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
  return this;
};
Writer$1.prototype.int32 = function write_int322(value) {
  return value < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(value)) : this.uint32(value);
};
Writer$1.prototype.sint32 = function write_sint322(value) {
  return this.uint32((value << 1 ^ value >> 31) >>> 0);
};
function writeVarint64(val, buf, pos) {
  while (val.hi) {
    buf[pos++] = val.lo & 127 | 128;
    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
    val.hi >>>= 7;
  }
  while (val.lo > 127) {
    buf[pos++] = val.lo & 127 | 128;
    val.lo = val.lo >>> 7;
  }
  buf[pos++] = val.lo;
}
Writer$1.prototype.uint64 = function write_uint642(value) {
  var bits = LongBits$1.from(value);
  return this._push(writeVarint64, bits.length(), bits);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function write_sint642(value) {
  var bits = LongBits$1.from(value).zzEncode();
  return this._push(writeVarint64, bits.length(), bits);
};
Writer$1.prototype.bool = function write_bool2(value) {
  return this._push(writeByte, 1, value ? 1 : 0);
};
function writeFixed32(val, buf, pos) {
  buf[pos] = val & 255;
  buf[pos + 1] = val >>> 8 & 255;
  buf[pos + 2] = val >>> 16 & 255;
  buf[pos + 3] = val >>> 24;
}
Writer$1.prototype.fixed32 = function write_fixed322(value) {
  return this._push(writeFixed32, 4, value >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function write_fixed642(value) {
  var bits = LongBits$1.from(value);
  return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function write_float2(value) {
  return this._push(util$4.float.writeFloatLE, 4, value);
};
Writer$1.prototype.double = function write_double2(value) {
  return this._push(util$4.float.writeDoubleLE, 8, value);
};
var writeBytes = util$4.Array.prototype.set ? function writeBytes_set2(val, buf, pos) {
  buf.set(val, pos);
} : function writeBytes_for2(val, buf, pos) {
  for (var i2 = 0; i2 < val.length; ++i2)
    buf[pos + i2] = val[i2];
};
Writer$1.prototype.bytes = function write_bytes2(value) {
  var len = value.length >>> 0;
  if (!len)
    return this._push(writeByte, 1, 0);
  if (util$4.isString(value)) {
    var buf = Writer$1.alloc(len = base64.length(value));
    base64.decode(value, buf, 0);
    value = buf;
  }
  return this.uint32(len)._push(writeBytes, len, value);
};
Writer$1.prototype.string = function write_string2(value) {
  var len = utf8$1.length(value);
  return len ? this.uint32(len)._push(utf8$1.write, len, value) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function fork2() {
  this.states = new State(this);
  this.head = this.tail = new Op(noop$1, 0, 0);
  this.len = 0;
  return this;
};
Writer$1.prototype.reset = function reset2() {
  if (this.states) {
    this.head = this.states.head;
    this.tail = this.states.tail;
    this.len = this.states.len;
    this.states = this.states.next;
  } else {
    this.head = this.tail = new Op(noop$1, 0, 0);
    this.len = 0;
  }
  return this;
};
Writer$1.prototype.ldelim = function ldelim2() {
  var head = this.head, tail = this.tail, len = this.len;
  this.reset().uint32(len);
  if (len) {
    this.tail.next = head.next;
    this.tail = tail;
    this.len += len;
  }
  return this;
};
Writer$1.prototype.finish = function finish2() {
  var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
  while (head) {
    head.fn(head.val, buf, pos);
    pos += head.len;
    head = head.next;
  }
  return buf;
};
Writer$1._configure = function(BufferWriter_) {
  BufferWriter$1 = BufferWriter_;
  Writer$1.create = create$1$1();
  BufferWriter$1._configure();
};
var writer_buffer = BufferWriter;
var Writer = writer$2;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$3 = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$3._Buffer_allocUnsafe;
  BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && util$3.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytesBuffer_copy(val, buf, pos) {
    if (val.copy)
      val.copy(buf, pos, 0, val.length);
    else
      for (var i2 = 0; i2 < val.length; )
        buf[pos++] = val[i2++];
  };
};
BufferWriter.prototype.bytes = function write_bytes_buffer2(value) {
  if (util$3.isString(value))
    value = util$3._Buffer_from(value, "base64");
  var len = value.length >>> 0;
  this.uint32(len);
  if (len)
    this._push(BufferWriter.writeBytesBuffer, len, value);
  return this;
};
function writeStringBuffer(val, buf, pos) {
  if (val.length < 40)
    util$3.utf8.write(val, buf, pos);
  else if (buf.utf8Write)
    buf.utf8Write(val, pos);
  else
    buf.write(val, pos);
}
BufferWriter.prototype.string = function write_string_buffer2(value) {
  var len = util$3.Buffer.byteLength(value);
  this.uint32(len);
  if (len)
    this._push(writeStringBuffer, len, value);
  return this;
};
BufferWriter._configure();
var reader = Reader$1;
var util$2 = requireMinimal();
var BufferReader$1;
var LongBits = util$2.LongBits, utf8 = util$2.utf8;
function indexOutOfRange(reader2, writeLength) {
  return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
}
function Reader$1(buffer2) {
  this.buf = buffer2;
  this.pos = 0;
  this.len = buffer2.length;
}
var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array2(buffer2) {
  if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
    return new Reader$1(buffer2);
  throw Error("illegal buffer");
} : function create_array3(buffer2) {
  if (Array.isArray(buffer2))
    return new Reader$1(buffer2);
  throw Error("illegal buffer");
};
var create$2 = function create6() {
  return util$2.Buffer ? function create_buffer_setup(buffer2) {
    return (Reader$1.create = function create_buffer(buffer3) {
      return util$2.Buffer.isBuffer(buffer3) ? new BufferReader$1(buffer3) : create_array(buffer3);
    })(buffer2);
  } : create_array;
};
Reader$1.create = create$2();
Reader$1.prototype._slice = util$2.Array.prototype.subarray || util$2.Array.prototype.slice;
Reader$1.prototype.uint32 = function read_uint32_setup2() {
  var value = 4294967295;
  return function read_uint32() {
    value = (this.buf[this.pos] & 127) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    if ((this.pos += 5) > this.len) {
      this.pos = this.len;
      throw indexOutOfRange(this, 10);
    }
    return value;
  };
}();
Reader$1.prototype.int32 = function read_int322() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function read_sint322() {
  var value = this.uint32();
  return value >>> 1 ^ -(value & 1) | 0;
};
function readLongVarint() {
  var bits = new LongBits(0, 0);
  var i2 = 0;
  if (this.len - this.pos > 4) {
    for (; i2 < 4; ++i2) {
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
    bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
    bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
    if (this.buf[this.pos++] < 128)
      return bits;
    i2 = 0;
  } else {
    for (; i2 < 3; ++i2) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
    bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
    return bits;
  }
  if (this.len - this.pos > 4) {
    for (; i2 < 5; ++i2) {
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
  } else {
    for (; i2 < 5; ++i2) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
  }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function read_bool2() {
  return this.uint32() !== 0;
};
function readFixed32_end(buf, end3) {
  return (buf[end3 - 4] | buf[end3 - 3] << 8 | buf[end3 - 2] << 16 | buf[end3 - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function read_fixed322() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function read_sfixed322() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function read_float2() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var value = util$2.float.readFloatLE(this.buf, this.pos);
  this.pos += 4;
  return value;
};
Reader$1.prototype.double = function read_double2() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var value = util$2.float.readDoubleLE(this.buf, this.pos);
  this.pos += 8;
  return value;
};
Reader$1.prototype.bytes = function read_bytes2() {
  var length2 = this.uint32(), start2 = this.pos, end3 = this.pos + length2;
  if (end3 > this.len)
    throw indexOutOfRange(this, length2);
  this.pos += length2;
  if (Array.isArray(this.buf))
    return this.buf.slice(start2, end3);
  return start2 === end3 ? new this.buf.constructor(0) : this._slice.call(this.buf, start2, end3);
};
Reader$1.prototype.string = function read_string2() {
  var bytes = this.bytes();
  return utf8.read(bytes, 0, bytes.length);
};
Reader$1.prototype.skip = function skip3(length2) {
  if (typeof length2 === "number") {
    if (this.pos + length2 > this.len)
      throw indexOutOfRange(this, length2);
    this.pos += length2;
  } else {
    do {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    } while (this.buf[this.pos++] & 128);
  }
  return this;
};
Reader$1.prototype.skipType = function(wireType) {
  switch (wireType) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      while ((wireType = this.uint32() & 7) !== 4) {
        this.skipType(wireType);
      }
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + wireType + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(BufferReader_) {
  BufferReader$1 = BufferReader_;
  Reader$1.create = create$2();
  BufferReader$1._configure();
  var fn = util$2.Long ? "toLong" : "toNumber";
  util$2.merge(Reader$1.prototype, {
    int64: function read_int64() {
      return readLongVarint.call(this)[fn](false);
    },
    uint64: function read_uint64() {
      return readLongVarint.call(this)[fn](true);
    },
    sint64: function read_sint64() {
      return readLongVarint.call(this).zzDecode()[fn](false);
    },
    fixed64: function read_fixed64() {
      return readFixed64.call(this)[fn](true);
    },
    sfixed64: function read_sfixed64() {
      return readFixed64.call(this)[fn](false);
    }
  });
};
var reader_buffer = BufferReader;
var Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$1 = requireMinimal();
function BufferReader(buffer2) {
  Reader.call(this, buffer2);
}
BufferReader._configure = function() {
  if (util$1.Buffer)
    BufferReader.prototype._slice = util$1.Buffer.prototype.slice;
};
BufferReader.prototype.string = function read_string_buffer2() {
  var len = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};
BufferReader._configure();
var rpc = {};
var service = Service;
var util = requireMinimal();
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
function Service(rpcImpl, requestDelimited, responseDelimited) {
  if (typeof rpcImpl !== "function")
    throw TypeError("rpcImpl must be a function");
  util.EventEmitter.call(this);
  this.rpcImpl = rpcImpl;
  this.requestDelimited = Boolean(requestDelimited);
  this.responseDelimited = Boolean(responseDelimited);
}
Service.prototype.rpcCall = function rpcCall2(method, requestCtor, responseCtor, request3, callback) {
  if (!request3)
    throw TypeError("request must be specified");
  var self2 = this;
  if (!callback)
    return util.asPromise(rpcCall2, self2, method, requestCtor, responseCtor, request3);
  if (!self2.rpcImpl) {
    setTimeout(function() {
      callback(Error("already ended"));
    }, 0);
    return void 0;
  }
  try {
    return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request3).finish(), function rpcCallback(err, response) {
      if (err) {
        self2.emit("error", err, method);
        return callback(err);
      }
      if (response === null) {
        self2.end(true);
        return void 0;
      }
      if (!(response instanceof responseCtor)) {
        try {
          response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
        } catch (err2) {
          self2.emit("error", err2, method);
          return callback(err2);
        }
      }
      self2.emit("data", response, method);
      return callback(null, response);
    });
  } catch (err) {
    self2.emit("error", err, method);
    setTimeout(function() {
      callback(err);
    }, 0);
    return void 0;
  }
};
Service.prototype.end = function end2(endedByRPC) {
  if (this.rpcImpl) {
    if (!endedByRPC)
      this.rpcImpl(null, null, null);
    this.rpcImpl = null;
    this.emit("end").off();
  }
  return this;
};
(function(exports2) {
  var rpc2 = exports2;
  rpc2.Service = service;
})(rpc);
var roots = {};
(function(exports2) {
  var protobuf = exports2;
  protobuf.build = "minimal";
  protobuf.Writer = writer$2;
  protobuf.BufferWriter = writer_buffer;
  protobuf.Reader = reader;
  protobuf.BufferReader = reader_buffer;
  protobuf.util = requireMinimal();
  protobuf.rpc = rpc;
  protobuf.roots = roots;
  protobuf.configure = configure;
  function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
  }
  configure();
})(indexMinimal);
(function(module2) {
  module2.exports = indexMinimal;
})(minimal$1);
var _m0 = /* @__PURE__ */ getDefaultExportFromCjs(minimalExports);
(() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
if (_m0.util.Long !== long) {
  _m0.util.Long = long;
  _m0.configure();
}
var TrackType;
(function(TrackType2) {
  TrackType2[TrackType2["AUDIO"] = 0] = "AUDIO";
  TrackType2[TrackType2["VIDEO"] = 1] = "VIDEO";
  TrackType2[TrackType2["DATA"] = 2] = "DATA";
  TrackType2[TrackType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TrackType || (TrackType = {}));
function trackTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "AUDIO":
      return TrackType.AUDIO;
    case 1:
    case "VIDEO":
      return TrackType.VIDEO;
    case 2:
    case "DATA":
      return TrackType.DATA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TrackType.UNRECOGNIZED;
  }
}
function trackTypeToJSON(object) {
  switch (object) {
    case TrackType.AUDIO:
      return "AUDIO";
    case TrackType.VIDEO:
      return "VIDEO";
    case TrackType.DATA:
      return "DATA";
    case TrackType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var TrackSource;
(function(TrackSource2) {
  TrackSource2[TrackSource2["UNKNOWN"] = 0] = "UNKNOWN";
  TrackSource2[TrackSource2["CAMERA"] = 1] = "CAMERA";
  TrackSource2[TrackSource2["MICROPHONE"] = 2] = "MICROPHONE";
  TrackSource2[TrackSource2["SCREEN_SHARE"] = 3] = "SCREEN_SHARE";
  TrackSource2[TrackSource2["SCREEN_SHARE_AUDIO"] = 4] = "SCREEN_SHARE_AUDIO";
  TrackSource2[TrackSource2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TrackSource || (TrackSource = {}));
function trackSourceFromJSON(object) {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return TrackSource.UNKNOWN;
    case 1:
    case "CAMERA":
      return TrackSource.CAMERA;
    case 2:
    case "MICROPHONE":
      return TrackSource.MICROPHONE;
    case 3:
    case "SCREEN_SHARE":
      return TrackSource.SCREEN_SHARE;
    case 4:
    case "SCREEN_SHARE_AUDIO":
      return TrackSource.SCREEN_SHARE_AUDIO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TrackSource.UNRECOGNIZED;
  }
}
function trackSourceToJSON(object) {
  switch (object) {
    case TrackSource.UNKNOWN:
      return "UNKNOWN";
    case TrackSource.CAMERA:
      return "CAMERA";
    case TrackSource.MICROPHONE:
      return "MICROPHONE";
    case TrackSource.SCREEN_SHARE:
      return "SCREEN_SHARE";
    case TrackSource.SCREEN_SHARE_AUDIO:
      return "SCREEN_SHARE_AUDIO";
    case TrackSource.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var VideoQuality;
(function(VideoQuality2) {
  VideoQuality2[VideoQuality2["LOW"] = 0] = "LOW";
  VideoQuality2[VideoQuality2["MEDIUM"] = 1] = "MEDIUM";
  VideoQuality2[VideoQuality2["HIGH"] = 2] = "HIGH";
  VideoQuality2[VideoQuality2["OFF"] = 3] = "OFF";
  VideoQuality2[VideoQuality2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(VideoQuality || (VideoQuality = {}));
function videoQualityFromJSON(object) {
  switch (object) {
    case 0:
    case "LOW":
      return VideoQuality.LOW;
    case 1:
    case "MEDIUM":
      return VideoQuality.MEDIUM;
    case 2:
    case "HIGH":
      return VideoQuality.HIGH;
    case 3:
    case "OFF":
      return VideoQuality.OFF;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VideoQuality.UNRECOGNIZED;
  }
}
function videoQualityToJSON(object) {
  switch (object) {
    case VideoQuality.LOW:
      return "LOW";
    case VideoQuality.MEDIUM:
      return "MEDIUM";
    case VideoQuality.HIGH:
      return "HIGH";
    case VideoQuality.OFF:
      return "OFF";
    case VideoQuality.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var ConnectionQuality$1;
(function(ConnectionQuality2) {
  ConnectionQuality2[ConnectionQuality2["POOR"] = 0] = "POOR";
  ConnectionQuality2[ConnectionQuality2["GOOD"] = 1] = "GOOD";
  ConnectionQuality2[ConnectionQuality2["EXCELLENT"] = 2] = "EXCELLENT";
  ConnectionQuality2[ConnectionQuality2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConnectionQuality$1 || (ConnectionQuality$1 = {}));
function connectionQualityFromJSON(object) {
  switch (object) {
    case 0:
    case "POOR":
      return ConnectionQuality$1.POOR;
    case 1:
    case "GOOD":
      return ConnectionQuality$1.GOOD;
    case 2:
    case "EXCELLENT":
      return ConnectionQuality$1.EXCELLENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectionQuality$1.UNRECOGNIZED;
  }
}
function connectionQualityToJSON(object) {
  switch (object) {
    case ConnectionQuality$1.POOR:
      return "POOR";
    case ConnectionQuality$1.GOOD:
      return "GOOD";
    case ConnectionQuality$1.EXCELLENT:
      return "EXCELLENT";
    case ConnectionQuality$1.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var ClientConfigSetting;
(function(ClientConfigSetting2) {
  ClientConfigSetting2[ClientConfigSetting2["UNSET"] = 0] = "UNSET";
  ClientConfigSetting2[ClientConfigSetting2["DISABLED"] = 1] = "DISABLED";
  ClientConfigSetting2[ClientConfigSetting2["ENABLED"] = 2] = "ENABLED";
  ClientConfigSetting2[ClientConfigSetting2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientConfigSetting || (ClientConfigSetting = {}));
function clientConfigSettingFromJSON(object) {
  switch (object) {
    case 0:
    case "UNSET":
      return ClientConfigSetting.UNSET;
    case 1:
    case "DISABLED":
      return ClientConfigSetting.DISABLED;
    case 2:
    case "ENABLED":
      return ClientConfigSetting.ENABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ClientConfigSetting.UNRECOGNIZED;
  }
}
function clientConfigSettingToJSON(object) {
  switch (object) {
    case ClientConfigSetting.UNSET:
      return "UNSET";
    case ClientConfigSetting.DISABLED:
      return "DISABLED";
    case ClientConfigSetting.ENABLED:
      return "ENABLED";
    case ClientConfigSetting.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var DisconnectReason;
(function(DisconnectReason2) {
  DisconnectReason2[DisconnectReason2["UNKNOWN_REASON"] = 0] = "UNKNOWN_REASON";
  DisconnectReason2[DisconnectReason2["CLIENT_INITIATED"] = 1] = "CLIENT_INITIATED";
  DisconnectReason2[DisconnectReason2["DUPLICATE_IDENTITY"] = 2] = "DUPLICATE_IDENTITY";
  DisconnectReason2[DisconnectReason2["SERVER_SHUTDOWN"] = 3] = "SERVER_SHUTDOWN";
  DisconnectReason2[DisconnectReason2["PARTICIPANT_REMOVED"] = 4] = "PARTICIPANT_REMOVED";
  DisconnectReason2[DisconnectReason2["ROOM_DELETED"] = 5] = "ROOM_DELETED";
  DisconnectReason2[DisconnectReason2["STATE_MISMATCH"] = 6] = "STATE_MISMATCH";
  DisconnectReason2[DisconnectReason2["JOIN_FAILURE"] = 7] = "JOIN_FAILURE";
  DisconnectReason2[DisconnectReason2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DisconnectReason || (DisconnectReason = {}));
function disconnectReasonFromJSON(object) {
  switch (object) {
    case 0:
    case "UNKNOWN_REASON":
      return DisconnectReason.UNKNOWN_REASON;
    case 1:
    case "CLIENT_INITIATED":
      return DisconnectReason.CLIENT_INITIATED;
    case 2:
    case "DUPLICATE_IDENTITY":
      return DisconnectReason.DUPLICATE_IDENTITY;
    case 3:
    case "SERVER_SHUTDOWN":
      return DisconnectReason.SERVER_SHUTDOWN;
    case 4:
    case "PARTICIPANT_REMOVED":
      return DisconnectReason.PARTICIPANT_REMOVED;
    case 5:
    case "ROOM_DELETED":
      return DisconnectReason.ROOM_DELETED;
    case 6:
    case "STATE_MISMATCH":
      return DisconnectReason.STATE_MISMATCH;
    case 7:
    case "JOIN_FAILURE":
      return DisconnectReason.JOIN_FAILURE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DisconnectReason.UNRECOGNIZED;
  }
}
function disconnectReasonToJSON(object) {
  switch (object) {
    case DisconnectReason.UNKNOWN_REASON:
      return "UNKNOWN_REASON";
    case DisconnectReason.CLIENT_INITIATED:
      return "CLIENT_INITIATED";
    case DisconnectReason.DUPLICATE_IDENTITY:
      return "DUPLICATE_IDENTITY";
    case DisconnectReason.SERVER_SHUTDOWN:
      return "SERVER_SHUTDOWN";
    case DisconnectReason.PARTICIPANT_REMOVED:
      return "PARTICIPANT_REMOVED";
    case DisconnectReason.ROOM_DELETED:
      return "ROOM_DELETED";
    case DisconnectReason.STATE_MISMATCH:
      return "STATE_MISMATCH";
    case DisconnectReason.JOIN_FAILURE:
      return "JOIN_FAILURE";
    case DisconnectReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var ReconnectReason;
(function(ReconnectReason2) {
  ReconnectReason2[ReconnectReason2["RR_UNKOWN"] = 0] = "RR_UNKOWN";
  ReconnectReason2[ReconnectReason2["RR_SIGNAL_DISCONNECTED"] = 1] = "RR_SIGNAL_DISCONNECTED";
  ReconnectReason2[ReconnectReason2["RR_PUBLISHER_FAILED"] = 2] = "RR_PUBLISHER_FAILED";
  ReconnectReason2[ReconnectReason2["RR_SUBSCRIBER_FAILED"] = 3] = "RR_SUBSCRIBER_FAILED";
  ReconnectReason2[ReconnectReason2["RR_SWITCH_CANDIDATE"] = 4] = "RR_SWITCH_CANDIDATE";
  ReconnectReason2[ReconnectReason2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ReconnectReason || (ReconnectReason = {}));
var ParticipantInfo_State;
(function(ParticipantInfo_State2) {
  ParticipantInfo_State2[ParticipantInfo_State2["JOINING"] = 0] = "JOINING";
  ParticipantInfo_State2[ParticipantInfo_State2["JOINED"] = 1] = "JOINED";
  ParticipantInfo_State2[ParticipantInfo_State2["ACTIVE"] = 2] = "ACTIVE";
  ParticipantInfo_State2[ParticipantInfo_State2["DISCONNECTED"] = 3] = "DISCONNECTED";
  ParticipantInfo_State2[ParticipantInfo_State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ParticipantInfo_State || (ParticipantInfo_State = {}));
function participantInfo_StateFromJSON(object) {
  switch (object) {
    case 0:
    case "JOINING":
      return ParticipantInfo_State.JOINING;
    case 1:
    case "JOINED":
      return ParticipantInfo_State.JOINED;
    case 2:
    case "ACTIVE":
      return ParticipantInfo_State.ACTIVE;
    case 3:
    case "DISCONNECTED":
      return ParticipantInfo_State.DISCONNECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ParticipantInfo_State.UNRECOGNIZED;
  }
}
function participantInfo_StateToJSON(object) {
  switch (object) {
    case ParticipantInfo_State.JOINING:
      return "JOINING";
    case ParticipantInfo_State.JOINED:
      return "JOINED";
    case ParticipantInfo_State.ACTIVE:
      return "ACTIVE";
    case ParticipantInfo_State.DISCONNECTED:
      return "DISCONNECTED";
    case ParticipantInfo_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var Encryption_Type;
(function(Encryption_Type2) {
  Encryption_Type2[Encryption_Type2["NONE"] = 0] = "NONE";
  Encryption_Type2[Encryption_Type2["GCM"] = 1] = "GCM";
  Encryption_Type2[Encryption_Type2["CUSTOM"] = 2] = "CUSTOM";
  Encryption_Type2[Encryption_Type2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Encryption_Type || (Encryption_Type = {}));
function encryption_TypeFromJSON(object) {
  switch (object) {
    case 0:
    case "NONE":
      return Encryption_Type.NONE;
    case 1:
    case "GCM":
      return Encryption_Type.GCM;
    case 2:
    case "CUSTOM":
      return Encryption_Type.CUSTOM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Encryption_Type.UNRECOGNIZED;
  }
}
function encryption_TypeToJSON(object) {
  switch (object) {
    case Encryption_Type.NONE:
      return "NONE";
    case Encryption_Type.GCM:
      return "GCM";
    case Encryption_Type.CUSTOM:
      return "CUSTOM";
    case Encryption_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var DataPacket_Kind;
(function(DataPacket_Kind2) {
  DataPacket_Kind2[DataPacket_Kind2["RELIABLE"] = 0] = "RELIABLE";
  DataPacket_Kind2[DataPacket_Kind2["LOSSY"] = 1] = "LOSSY";
  DataPacket_Kind2[DataPacket_Kind2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DataPacket_Kind || (DataPacket_Kind = {}));
function dataPacket_KindFromJSON(object) {
  switch (object) {
    case 0:
    case "RELIABLE":
      return DataPacket_Kind.RELIABLE;
    case 1:
    case "LOSSY":
      return DataPacket_Kind.LOSSY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataPacket_Kind.UNRECOGNIZED;
  }
}
function dataPacket_KindToJSON(object) {
  switch (object) {
    case DataPacket_Kind.RELIABLE:
      return "RELIABLE";
    case DataPacket_Kind.LOSSY:
      return "LOSSY";
    case DataPacket_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var ServerInfo_Edition;
(function(ServerInfo_Edition2) {
  ServerInfo_Edition2[ServerInfo_Edition2["Standard"] = 0] = "Standard";
  ServerInfo_Edition2[ServerInfo_Edition2["Cloud"] = 1] = "Cloud";
  ServerInfo_Edition2[ServerInfo_Edition2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ServerInfo_Edition || (ServerInfo_Edition = {}));
function serverInfo_EditionFromJSON(object) {
  switch (object) {
    case 0:
    case "Standard":
      return ServerInfo_Edition.Standard;
    case 1:
    case "Cloud":
      return ServerInfo_Edition.Cloud;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServerInfo_Edition.UNRECOGNIZED;
  }
}
function serverInfo_EditionToJSON(object) {
  switch (object) {
    case ServerInfo_Edition.Standard:
      return "Standard";
    case ServerInfo_Edition.Cloud:
      return "Cloud";
    case ServerInfo_Edition.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var ClientInfo_SDK;
(function(ClientInfo_SDK2) {
  ClientInfo_SDK2[ClientInfo_SDK2["UNKNOWN"] = 0] = "UNKNOWN";
  ClientInfo_SDK2[ClientInfo_SDK2["JS"] = 1] = "JS";
  ClientInfo_SDK2[ClientInfo_SDK2["SWIFT"] = 2] = "SWIFT";
  ClientInfo_SDK2[ClientInfo_SDK2["ANDROID"] = 3] = "ANDROID";
  ClientInfo_SDK2[ClientInfo_SDK2["FLUTTER"] = 4] = "FLUTTER";
  ClientInfo_SDK2[ClientInfo_SDK2["GO"] = 5] = "GO";
  ClientInfo_SDK2[ClientInfo_SDK2["UNITY"] = 6] = "UNITY";
  ClientInfo_SDK2[ClientInfo_SDK2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientInfo_SDK || (ClientInfo_SDK = {}));
function clientInfo_SDKFromJSON(object) {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return ClientInfo_SDK.UNKNOWN;
    case 1:
    case "JS":
      return ClientInfo_SDK.JS;
    case 2:
    case "SWIFT":
      return ClientInfo_SDK.SWIFT;
    case 3:
    case "ANDROID":
      return ClientInfo_SDK.ANDROID;
    case 4:
    case "FLUTTER":
      return ClientInfo_SDK.FLUTTER;
    case 5:
    case "GO":
      return ClientInfo_SDK.GO;
    case 6:
    case "UNITY":
      return ClientInfo_SDK.UNITY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ClientInfo_SDK.UNRECOGNIZED;
  }
}
function clientInfo_SDKToJSON(object) {
  switch (object) {
    case ClientInfo_SDK.UNKNOWN:
      return "UNKNOWN";
    case ClientInfo_SDK.JS:
      return "JS";
    case ClientInfo_SDK.SWIFT:
      return "SWIFT";
    case ClientInfo_SDK.ANDROID:
      return "ANDROID";
    case ClientInfo_SDK.FLUTTER:
      return "FLUTTER";
    case ClientInfo_SDK.GO:
      return "GO";
    case ClientInfo_SDK.UNITY:
      return "UNITY";
    case ClientInfo_SDK.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseRoom() {
  return {
    sid: "",
    name: "",
    emptyTimeout: 0,
    maxParticipants: 0,
    creationTime: 0,
    turnPassword: "",
    enabledCodecs: [],
    metadata: "",
    numParticipants: 0,
    activeRecording: false
  };
}
const Room$1 = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.sid !== "") {
      writer2.uint32(10).string(message.sid);
    }
    if (message.name !== "") {
      writer2.uint32(18).string(message.name);
    }
    if (message.emptyTimeout !== 0) {
      writer2.uint32(24).uint32(message.emptyTimeout);
    }
    if (message.maxParticipants !== 0) {
      writer2.uint32(32).uint32(message.maxParticipants);
    }
    if (message.creationTime !== 0) {
      writer2.uint32(40).int64(message.creationTime);
    }
    if (message.turnPassword !== "") {
      writer2.uint32(50).string(message.turnPassword);
    }
    for (const v of message.enabledCodecs) {
      Codec.encode(v, writer2.uint32(58).fork()).ldelim();
    }
    if (message.metadata !== "") {
      writer2.uint32(66).string(message.metadata);
    }
    if (message.numParticipants !== 0) {
      writer2.uint32(72).uint32(message.numParticipants);
    }
    if (message.activeRecording === true) {
      writer2.uint32(80).bool(message.activeRecording);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseRoom();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sid = reader2.string();
          break;
        case 2:
          message.name = reader2.string();
          break;
        case 3:
          message.emptyTimeout = reader2.uint32();
          break;
        case 4:
          message.maxParticipants = reader2.uint32();
          break;
        case 5:
          message.creationTime = longToNumber$1(reader2.int64());
          break;
        case 6:
          message.turnPassword = reader2.string();
          break;
        case 7:
          message.enabledCodecs.push(Codec.decode(reader2, reader2.uint32()));
          break;
        case 8:
          message.metadata = reader2.string();
          break;
        case 9:
          message.numParticipants = reader2.uint32();
          break;
        case 10:
          message.activeRecording = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sid: isSet$1(object.sid) ? String(object.sid) : "",
      name: isSet$1(object.name) ? String(object.name) : "",
      emptyTimeout: isSet$1(object.emptyTimeout) ? Number(object.emptyTimeout) : 0,
      maxParticipants: isSet$1(object.maxParticipants) ? Number(object.maxParticipants) : 0,
      creationTime: isSet$1(object.creationTime) ? Number(object.creationTime) : 0,
      turnPassword: isSet$1(object.turnPassword) ? String(object.turnPassword) : "",
      enabledCodecs: Array.isArray(object === null || object === void 0 ? void 0 : object.enabledCodecs) ? object.enabledCodecs.map((e2) => Codec.fromJSON(e2)) : [],
      metadata: isSet$1(object.metadata) ? String(object.metadata) : "",
      numParticipants: isSet$1(object.numParticipants) ? Number(object.numParticipants) : 0,
      activeRecording: isSet$1(object.activeRecording) ? Boolean(object.activeRecording) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.sid !== void 0 && (obj.sid = message.sid);
    message.name !== void 0 && (obj.name = message.name);
    message.emptyTimeout !== void 0 && (obj.emptyTimeout = Math.round(message.emptyTimeout));
    message.maxParticipants !== void 0 && (obj.maxParticipants = Math.round(message.maxParticipants));
    message.creationTime !== void 0 && (obj.creationTime = Math.round(message.creationTime));
    message.turnPassword !== void 0 && (obj.turnPassword = message.turnPassword);
    if (message.enabledCodecs) {
      obj.enabledCodecs = message.enabledCodecs.map((e2) => e2 ? Codec.toJSON(e2) : void 0);
    } else {
      obj.enabledCodecs = [];
    }
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.numParticipants !== void 0 && (obj.numParticipants = Math.round(message.numParticipants));
    message.activeRecording !== void 0 && (obj.activeRecording = message.activeRecording);
    return obj;
  },
  create(base) {
    return Room$1.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const message = createBaseRoom();
    message.sid = (_a2 = object.sid) !== null && _a2 !== void 0 ? _a2 : "";
    message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
    message.emptyTimeout = (_c = object.emptyTimeout) !== null && _c !== void 0 ? _c : 0;
    message.maxParticipants = (_d = object.maxParticipants) !== null && _d !== void 0 ? _d : 0;
    message.creationTime = (_e = object.creationTime) !== null && _e !== void 0 ? _e : 0;
    message.turnPassword = (_f = object.turnPassword) !== null && _f !== void 0 ? _f : "";
    message.enabledCodecs = ((_g = object.enabledCodecs) === null || _g === void 0 ? void 0 : _g.map((e2) => Codec.fromPartial(e2))) || [];
    message.metadata = (_h = object.metadata) !== null && _h !== void 0 ? _h : "";
    message.numParticipants = (_j = object.numParticipants) !== null && _j !== void 0 ? _j : 0;
    message.activeRecording = (_k = object.activeRecording) !== null && _k !== void 0 ? _k : false;
    return message;
  }
};
function createBaseCodec() {
  return {
    mime: "",
    fmtpLine: ""
  };
}
const Codec = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.mime !== "") {
      writer2.uint32(10).string(message.mime);
    }
    if (message.fmtpLine !== "") {
      writer2.uint32(18).string(message.fmtpLine);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCodec();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mime = reader2.string();
          break;
        case 2:
          message.fmtpLine = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      mime: isSet$1(object.mime) ? String(object.mime) : "",
      fmtpLine: isSet$1(object.fmtpLine) ? String(object.fmtpLine) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.mime !== void 0 && (obj.mime = message.mime);
    message.fmtpLine !== void 0 && (obj.fmtpLine = message.fmtpLine);
    return obj;
  },
  create(base) {
    return Codec.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseCodec();
    message.mime = (_a2 = object.mime) !== null && _a2 !== void 0 ? _a2 : "";
    message.fmtpLine = (_b = object.fmtpLine) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseParticipantPermission() {
  return {
    canSubscribe: false,
    canPublish: false,
    canPublishData: false,
    canPublishSources: [],
    hidden: false,
    recorder: false
  };
}
const ParticipantPermission = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.canSubscribe === true) {
      writer2.uint32(8).bool(message.canSubscribe);
    }
    if (message.canPublish === true) {
      writer2.uint32(16).bool(message.canPublish);
    }
    if (message.canPublishData === true) {
      writer2.uint32(24).bool(message.canPublishData);
    }
    writer2.uint32(74).fork();
    for (const v of message.canPublishSources) {
      writer2.int32(v);
    }
    writer2.ldelim();
    if (message.hidden === true) {
      writer2.uint32(56).bool(message.hidden);
    }
    if (message.recorder === true) {
      writer2.uint32(64).bool(message.recorder);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseParticipantPermission();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.canSubscribe = reader2.bool();
          break;
        case 2:
          message.canPublish = reader2.bool();
          break;
        case 3:
          message.canPublishData = reader2.bool();
          break;
        case 9:
          if ((tag & 7) === 2) {
            const end22 = reader2.uint32() + reader2.pos;
            while (reader2.pos < end22) {
              message.canPublishSources.push(reader2.int32());
            }
          } else {
            message.canPublishSources.push(reader2.int32());
          }
          break;
        case 7:
          message.hidden = reader2.bool();
          break;
        case 8:
          message.recorder = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      canSubscribe: isSet$1(object.canSubscribe) ? Boolean(object.canSubscribe) : false,
      canPublish: isSet$1(object.canPublish) ? Boolean(object.canPublish) : false,
      canPublishData: isSet$1(object.canPublishData) ? Boolean(object.canPublishData) : false,
      canPublishSources: Array.isArray(object === null || object === void 0 ? void 0 : object.canPublishSources) ? object.canPublishSources.map((e2) => trackSourceFromJSON(e2)) : [],
      hidden: isSet$1(object.hidden) ? Boolean(object.hidden) : false,
      recorder: isSet$1(object.recorder) ? Boolean(object.recorder) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.canSubscribe !== void 0 && (obj.canSubscribe = message.canSubscribe);
    message.canPublish !== void 0 && (obj.canPublish = message.canPublish);
    message.canPublishData !== void 0 && (obj.canPublishData = message.canPublishData);
    if (message.canPublishSources) {
      obj.canPublishSources = message.canPublishSources.map((e2) => trackSourceToJSON(e2));
    } else {
      obj.canPublishSources = [];
    }
    message.hidden !== void 0 && (obj.hidden = message.hidden);
    message.recorder !== void 0 && (obj.recorder = message.recorder);
    return obj;
  },
  create(base) {
    return ParticipantPermission.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f;
    const message = createBaseParticipantPermission();
    message.canSubscribe = (_a2 = object.canSubscribe) !== null && _a2 !== void 0 ? _a2 : false;
    message.canPublish = (_b = object.canPublish) !== null && _b !== void 0 ? _b : false;
    message.canPublishData = (_c = object.canPublishData) !== null && _c !== void 0 ? _c : false;
    message.canPublishSources = ((_d = object.canPublishSources) === null || _d === void 0 ? void 0 : _d.map((e2) => e2)) || [];
    message.hidden = (_e = object.hidden) !== null && _e !== void 0 ? _e : false;
    message.recorder = (_f = object.recorder) !== null && _f !== void 0 ? _f : false;
    return message;
  }
};
function createBaseParticipantInfo() {
  return {
    sid: "",
    identity: "",
    state: 0,
    tracks: [],
    metadata: "",
    joinedAt: 0,
    name: "",
    version: 0,
    permission: void 0,
    region: "",
    isPublisher: false
  };
}
const ParticipantInfo = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.sid !== "") {
      writer2.uint32(10).string(message.sid);
    }
    if (message.identity !== "") {
      writer2.uint32(18).string(message.identity);
    }
    if (message.state !== 0) {
      writer2.uint32(24).int32(message.state);
    }
    for (const v of message.tracks) {
      TrackInfo.encode(v, writer2.uint32(34).fork()).ldelim();
    }
    if (message.metadata !== "") {
      writer2.uint32(42).string(message.metadata);
    }
    if (message.joinedAt !== 0) {
      writer2.uint32(48).int64(message.joinedAt);
    }
    if (message.name !== "") {
      writer2.uint32(74).string(message.name);
    }
    if (message.version !== 0) {
      writer2.uint32(80).uint32(message.version);
    }
    if (message.permission !== void 0) {
      ParticipantPermission.encode(message.permission, writer2.uint32(90).fork()).ldelim();
    }
    if (message.region !== "") {
      writer2.uint32(98).string(message.region);
    }
    if (message.isPublisher === true) {
      writer2.uint32(104).bool(message.isPublisher);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseParticipantInfo();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sid = reader2.string();
          break;
        case 2:
          message.identity = reader2.string();
          break;
        case 3:
          message.state = reader2.int32();
          break;
        case 4:
          message.tracks.push(TrackInfo.decode(reader2, reader2.uint32()));
          break;
        case 5:
          message.metadata = reader2.string();
          break;
        case 6:
          message.joinedAt = longToNumber$1(reader2.int64());
          break;
        case 9:
          message.name = reader2.string();
          break;
        case 10:
          message.version = reader2.uint32();
          break;
        case 11:
          message.permission = ParticipantPermission.decode(reader2, reader2.uint32());
          break;
        case 12:
          message.region = reader2.string();
          break;
        case 13:
          message.isPublisher = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sid: isSet$1(object.sid) ? String(object.sid) : "",
      identity: isSet$1(object.identity) ? String(object.identity) : "",
      state: isSet$1(object.state) ? participantInfo_StateFromJSON(object.state) : 0,
      tracks: Array.isArray(object === null || object === void 0 ? void 0 : object.tracks) ? object.tracks.map((e2) => TrackInfo.fromJSON(e2)) : [],
      metadata: isSet$1(object.metadata) ? String(object.metadata) : "",
      joinedAt: isSet$1(object.joinedAt) ? Number(object.joinedAt) : 0,
      name: isSet$1(object.name) ? String(object.name) : "",
      version: isSet$1(object.version) ? Number(object.version) : 0,
      permission: isSet$1(object.permission) ? ParticipantPermission.fromJSON(object.permission) : void 0,
      region: isSet$1(object.region) ? String(object.region) : "",
      isPublisher: isSet$1(object.isPublisher) ? Boolean(object.isPublisher) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.sid !== void 0 && (obj.sid = message.sid);
    message.identity !== void 0 && (obj.identity = message.identity);
    message.state !== void 0 && (obj.state = participantInfo_StateToJSON(message.state));
    if (message.tracks) {
      obj.tracks = message.tracks.map((e2) => e2 ? TrackInfo.toJSON(e2) : void 0);
    } else {
      obj.tracks = [];
    }
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    message.joinedAt !== void 0 && (obj.joinedAt = Math.round(message.joinedAt));
    message.name !== void 0 && (obj.name = message.name);
    message.version !== void 0 && (obj.version = Math.round(message.version));
    message.permission !== void 0 && (obj.permission = message.permission ? ParticipantPermission.toJSON(message.permission) : void 0);
    message.region !== void 0 && (obj.region = message.region);
    message.isPublisher !== void 0 && (obj.isPublisher = message.isPublisher);
    return obj;
  },
  create(base) {
    return ParticipantInfo.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const message = createBaseParticipantInfo();
    message.sid = (_a2 = object.sid) !== null && _a2 !== void 0 ? _a2 : "";
    message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : "";
    message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;
    message.tracks = ((_d = object.tracks) === null || _d === void 0 ? void 0 : _d.map((e2) => TrackInfo.fromPartial(e2))) || [];
    message.metadata = (_e = object.metadata) !== null && _e !== void 0 ? _e : "";
    message.joinedAt = (_f = object.joinedAt) !== null && _f !== void 0 ? _f : 0;
    message.name = (_g = object.name) !== null && _g !== void 0 ? _g : "";
    message.version = (_h = object.version) !== null && _h !== void 0 ? _h : 0;
    message.permission = object.permission !== void 0 && object.permission !== null ? ParticipantPermission.fromPartial(object.permission) : void 0;
    message.region = (_j = object.region) !== null && _j !== void 0 ? _j : "";
    message.isPublisher = (_k = object.isPublisher) !== null && _k !== void 0 ? _k : false;
    return message;
  }
};
function createBaseSimulcastCodecInfo() {
  return {
    mimeType: "",
    mid: "",
    cid: "",
    layers: []
  };
}
const SimulcastCodecInfo = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.mimeType !== "") {
      writer2.uint32(10).string(message.mimeType);
    }
    if (message.mid !== "") {
      writer2.uint32(18).string(message.mid);
    }
    if (message.cid !== "") {
      writer2.uint32(26).string(message.cid);
    }
    for (const v of message.layers) {
      VideoLayer.encode(v, writer2.uint32(34).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSimulcastCodecInfo();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mimeType = reader2.string();
          break;
        case 2:
          message.mid = reader2.string();
          break;
        case 3:
          message.cid = reader2.string();
          break;
        case 4:
          message.layers.push(VideoLayer.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      mimeType: isSet$1(object.mimeType) ? String(object.mimeType) : "",
      mid: isSet$1(object.mid) ? String(object.mid) : "",
      cid: isSet$1(object.cid) ? String(object.cid) : "",
      layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e2) => VideoLayer.fromJSON(e2)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.mimeType !== void 0 && (obj.mimeType = message.mimeType);
    message.mid !== void 0 && (obj.mid = message.mid);
    message.cid !== void 0 && (obj.cid = message.cid);
    if (message.layers) {
      obj.layers = message.layers.map((e2) => e2 ? VideoLayer.toJSON(e2) : void 0);
    } else {
      obj.layers = [];
    }
    return obj;
  },
  create(base) {
    return SimulcastCodecInfo.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseSimulcastCodecInfo();
    message.mimeType = (_a2 = object.mimeType) !== null && _a2 !== void 0 ? _a2 : "";
    message.mid = (_b = object.mid) !== null && _b !== void 0 ? _b : "";
    message.cid = (_c = object.cid) !== null && _c !== void 0 ? _c : "";
    message.layers = ((_d = object.layers) === null || _d === void 0 ? void 0 : _d.map((e2) => VideoLayer.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseTrackInfo() {
  return {
    sid: "",
    type: 0,
    name: "",
    muted: false,
    width: 0,
    height: 0,
    simulcast: false,
    disableDtx: false,
    source: 0,
    layers: [],
    mimeType: "",
    mid: "",
    codecs: [],
    stereo: false,
    disableRed: false,
    encryption: 0
  };
}
const TrackInfo = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.sid !== "") {
      writer2.uint32(10).string(message.sid);
    }
    if (message.type !== 0) {
      writer2.uint32(16).int32(message.type);
    }
    if (message.name !== "") {
      writer2.uint32(26).string(message.name);
    }
    if (message.muted === true) {
      writer2.uint32(32).bool(message.muted);
    }
    if (message.width !== 0) {
      writer2.uint32(40).uint32(message.width);
    }
    if (message.height !== 0) {
      writer2.uint32(48).uint32(message.height);
    }
    if (message.simulcast === true) {
      writer2.uint32(56).bool(message.simulcast);
    }
    if (message.disableDtx === true) {
      writer2.uint32(64).bool(message.disableDtx);
    }
    if (message.source !== 0) {
      writer2.uint32(72).int32(message.source);
    }
    for (const v of message.layers) {
      VideoLayer.encode(v, writer2.uint32(82).fork()).ldelim();
    }
    if (message.mimeType !== "") {
      writer2.uint32(90).string(message.mimeType);
    }
    if (message.mid !== "") {
      writer2.uint32(98).string(message.mid);
    }
    for (const v of message.codecs) {
      SimulcastCodecInfo.encode(v, writer2.uint32(106).fork()).ldelim();
    }
    if (message.stereo === true) {
      writer2.uint32(112).bool(message.stereo);
    }
    if (message.disableRed === true) {
      writer2.uint32(120).bool(message.disableRed);
    }
    if (message.encryption !== 0) {
      writer2.uint32(128).int32(message.encryption);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTrackInfo();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sid = reader2.string();
          break;
        case 2:
          message.type = reader2.int32();
          break;
        case 3:
          message.name = reader2.string();
          break;
        case 4:
          message.muted = reader2.bool();
          break;
        case 5:
          message.width = reader2.uint32();
          break;
        case 6:
          message.height = reader2.uint32();
          break;
        case 7:
          message.simulcast = reader2.bool();
          break;
        case 8:
          message.disableDtx = reader2.bool();
          break;
        case 9:
          message.source = reader2.int32();
          break;
        case 10:
          message.layers.push(VideoLayer.decode(reader2, reader2.uint32()));
          break;
        case 11:
          message.mimeType = reader2.string();
          break;
        case 12:
          message.mid = reader2.string();
          break;
        case 13:
          message.codecs.push(SimulcastCodecInfo.decode(reader2, reader2.uint32()));
          break;
        case 14:
          message.stereo = reader2.bool();
          break;
        case 15:
          message.disableRed = reader2.bool();
          break;
        case 16:
          message.encryption = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sid: isSet$1(object.sid) ? String(object.sid) : "",
      type: isSet$1(object.type) ? trackTypeFromJSON(object.type) : 0,
      name: isSet$1(object.name) ? String(object.name) : "",
      muted: isSet$1(object.muted) ? Boolean(object.muted) : false,
      width: isSet$1(object.width) ? Number(object.width) : 0,
      height: isSet$1(object.height) ? Number(object.height) : 0,
      simulcast: isSet$1(object.simulcast) ? Boolean(object.simulcast) : false,
      disableDtx: isSet$1(object.disableDtx) ? Boolean(object.disableDtx) : false,
      source: isSet$1(object.source) ? trackSourceFromJSON(object.source) : 0,
      layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e2) => VideoLayer.fromJSON(e2)) : [],
      mimeType: isSet$1(object.mimeType) ? String(object.mimeType) : "",
      mid: isSet$1(object.mid) ? String(object.mid) : "",
      codecs: Array.isArray(object === null || object === void 0 ? void 0 : object.codecs) ? object.codecs.map((e2) => SimulcastCodecInfo.fromJSON(e2)) : [],
      stereo: isSet$1(object.stereo) ? Boolean(object.stereo) : false,
      disableRed: isSet$1(object.disableRed) ? Boolean(object.disableRed) : false,
      encryption: isSet$1(object.encryption) ? encryption_TypeFromJSON(object.encryption) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.sid !== void 0 && (obj.sid = message.sid);
    message.type !== void 0 && (obj.type = trackTypeToJSON(message.type));
    message.name !== void 0 && (obj.name = message.name);
    message.muted !== void 0 && (obj.muted = message.muted);
    message.width !== void 0 && (obj.width = Math.round(message.width));
    message.height !== void 0 && (obj.height = Math.round(message.height));
    message.simulcast !== void 0 && (obj.simulcast = message.simulcast);
    message.disableDtx !== void 0 && (obj.disableDtx = message.disableDtx);
    message.source !== void 0 && (obj.source = trackSourceToJSON(message.source));
    if (message.layers) {
      obj.layers = message.layers.map((e2) => e2 ? VideoLayer.toJSON(e2) : void 0);
    } else {
      obj.layers = [];
    }
    message.mimeType !== void 0 && (obj.mimeType = message.mimeType);
    message.mid !== void 0 && (obj.mid = message.mid);
    if (message.codecs) {
      obj.codecs = message.codecs.map((e2) => e2 ? SimulcastCodecInfo.toJSON(e2) : void 0);
    } else {
      obj.codecs = [];
    }
    message.stereo !== void 0 && (obj.stereo = message.stereo);
    message.disableRed !== void 0 && (obj.disableRed = message.disableRed);
    message.encryption !== void 0 && (obj.encryption = encryption_TypeToJSON(message.encryption));
    return obj;
  },
  create(base) {
    return TrackInfo.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    const message = createBaseTrackInfo();
    message.sid = (_a2 = object.sid) !== null && _a2 !== void 0 ? _a2 : "";
    message.type = (_b = object.type) !== null && _b !== void 0 ? _b : 0;
    message.name = (_c = object.name) !== null && _c !== void 0 ? _c : "";
    message.muted = (_d = object.muted) !== null && _d !== void 0 ? _d : false;
    message.width = (_e = object.width) !== null && _e !== void 0 ? _e : 0;
    message.height = (_f = object.height) !== null && _f !== void 0 ? _f : 0;
    message.simulcast = (_g = object.simulcast) !== null && _g !== void 0 ? _g : false;
    message.disableDtx = (_h = object.disableDtx) !== null && _h !== void 0 ? _h : false;
    message.source = (_j = object.source) !== null && _j !== void 0 ? _j : 0;
    message.layers = ((_k = object.layers) === null || _k === void 0 ? void 0 : _k.map((e2) => VideoLayer.fromPartial(e2))) || [];
    message.mimeType = (_l = object.mimeType) !== null && _l !== void 0 ? _l : "";
    message.mid = (_m = object.mid) !== null && _m !== void 0 ? _m : "";
    message.codecs = ((_o = object.codecs) === null || _o === void 0 ? void 0 : _o.map((e2) => SimulcastCodecInfo.fromPartial(e2))) || [];
    message.stereo = (_p = object.stereo) !== null && _p !== void 0 ? _p : false;
    message.disableRed = (_q = object.disableRed) !== null && _q !== void 0 ? _q : false;
    message.encryption = (_r = object.encryption) !== null && _r !== void 0 ? _r : 0;
    return message;
  }
};
function createBaseVideoLayer() {
  return {
    quality: 0,
    width: 0,
    height: 0,
    bitrate: 0,
    ssrc: 0
  };
}
const VideoLayer = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.quality !== 0) {
      writer2.uint32(8).int32(message.quality);
    }
    if (message.width !== 0) {
      writer2.uint32(16).uint32(message.width);
    }
    if (message.height !== 0) {
      writer2.uint32(24).uint32(message.height);
    }
    if (message.bitrate !== 0) {
      writer2.uint32(32).uint32(message.bitrate);
    }
    if (message.ssrc !== 0) {
      writer2.uint32(40).uint32(message.ssrc);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseVideoLayer();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.quality = reader2.int32();
          break;
        case 2:
          message.width = reader2.uint32();
          break;
        case 3:
          message.height = reader2.uint32();
          break;
        case 4:
          message.bitrate = reader2.uint32();
          break;
        case 5:
          message.ssrc = reader2.uint32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      quality: isSet$1(object.quality) ? videoQualityFromJSON(object.quality) : 0,
      width: isSet$1(object.width) ? Number(object.width) : 0,
      height: isSet$1(object.height) ? Number(object.height) : 0,
      bitrate: isSet$1(object.bitrate) ? Number(object.bitrate) : 0,
      ssrc: isSet$1(object.ssrc) ? Number(object.ssrc) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.quality !== void 0 && (obj.quality = videoQualityToJSON(message.quality));
    message.width !== void 0 && (obj.width = Math.round(message.width));
    message.height !== void 0 && (obj.height = Math.round(message.height));
    message.bitrate !== void 0 && (obj.bitrate = Math.round(message.bitrate));
    message.ssrc !== void 0 && (obj.ssrc = Math.round(message.ssrc));
    return obj;
  },
  create(base) {
    return VideoLayer.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d, _e;
    const message = createBaseVideoLayer();
    message.quality = (_a2 = object.quality) !== null && _a2 !== void 0 ? _a2 : 0;
    message.width = (_b = object.width) !== null && _b !== void 0 ? _b : 0;
    message.height = (_c = object.height) !== null && _c !== void 0 ? _c : 0;
    message.bitrate = (_d = object.bitrate) !== null && _d !== void 0 ? _d : 0;
    message.ssrc = (_e = object.ssrc) !== null && _e !== void 0 ? _e : 0;
    return message;
  }
};
function createBaseDataPacket() {
  return {
    kind: 0,
    value: void 0
  };
}
const DataPacket = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    var _a2;
    if (message.kind !== 0) {
      writer2.uint32(8).int32(message.kind);
    }
    switch ((_a2 = message.value) === null || _a2 === void 0 ? void 0 : _a2.$case) {
      case "user":
        UserPacket.encode(message.value.user, writer2.uint32(18).fork()).ldelim();
        break;
      case "speaker":
        ActiveSpeakerUpdate.encode(message.value.speaker, writer2.uint32(26).fork()).ldelim();
        break;
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDataPacket();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader2.int32();
          break;
        case 2:
          message.value = {
            $case: "user",
            user: UserPacket.decode(reader2, reader2.uint32())
          };
          break;
        case 3:
          message.value = {
            $case: "speaker",
            speaker: ActiveSpeakerUpdate.decode(reader2, reader2.uint32())
          };
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      kind: isSet$1(object.kind) ? dataPacket_KindFromJSON(object.kind) : 0,
      value: isSet$1(object.user) ? {
        $case: "user",
        user: UserPacket.fromJSON(object.user)
      } : isSet$1(object.speaker) ? {
        $case: "speaker",
        speaker: ActiveSpeakerUpdate.fromJSON(object.speaker)
      } : void 0
    };
  },
  toJSON(message) {
    var _a2, _b, _c, _d, _e, _f;
    const obj = {};
    message.kind !== void 0 && (obj.kind = dataPacket_KindToJSON(message.kind));
    ((_a2 = message.value) === null || _a2 === void 0 ? void 0 : _a2.$case) === "user" && (obj.user = ((_b = message.value) === null || _b === void 0 ? void 0 : _b.user) ? UserPacket.toJSON((_c = message.value) === null || _c === void 0 ? void 0 : _c.user) : void 0);
    ((_d = message.value) === null || _d === void 0 ? void 0 : _d.$case) === "speaker" && (obj.speaker = ((_e = message.value) === null || _e === void 0 ? void 0 : _e.speaker) ? ActiveSpeakerUpdate.toJSON((_f = message.value) === null || _f === void 0 ? void 0 : _f.speaker) : void 0);
    return obj;
  },
  create(base) {
    return DataPacket.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g;
    const message = createBaseDataPacket();
    message.kind = (_a2 = object.kind) !== null && _a2 !== void 0 ? _a2 : 0;
    if (((_b = object.value) === null || _b === void 0 ? void 0 : _b.$case) === "user" && ((_c = object.value) === null || _c === void 0 ? void 0 : _c.user) !== void 0 && ((_d = object.value) === null || _d === void 0 ? void 0 : _d.user) !== null) {
      message.value = {
        $case: "user",
        user: UserPacket.fromPartial(object.value.user)
      };
    }
    if (((_e = object.value) === null || _e === void 0 ? void 0 : _e.$case) === "speaker" && ((_f = object.value) === null || _f === void 0 ? void 0 : _f.speaker) !== void 0 && ((_g = object.value) === null || _g === void 0 ? void 0 : _g.speaker) !== null) {
      message.value = {
        $case: "speaker",
        speaker: ActiveSpeakerUpdate.fromPartial(object.value.speaker)
      };
    }
    return message;
  }
};
function createBaseActiveSpeakerUpdate() {
  return {
    speakers: []
  };
}
const ActiveSpeakerUpdate = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    for (const v of message.speakers) {
      SpeakerInfo.encode(v, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseActiveSpeakerUpdate();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.speakers.push(SpeakerInfo.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      speakers: Array.isArray(object === null || object === void 0 ? void 0 : object.speakers) ? object.speakers.map((e2) => SpeakerInfo.fromJSON(e2)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.speakers) {
      obj.speakers = message.speakers.map((e2) => e2 ? SpeakerInfo.toJSON(e2) : void 0);
    } else {
      obj.speakers = [];
    }
    return obj;
  },
  create(base) {
    return ActiveSpeakerUpdate.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2;
    const message = createBaseActiveSpeakerUpdate();
    message.speakers = ((_a2 = object.speakers) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => SpeakerInfo.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseSpeakerInfo() {
  return {
    sid: "",
    level: 0,
    active: false
  };
}
const SpeakerInfo = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.sid !== "") {
      writer2.uint32(10).string(message.sid);
    }
    if (message.level !== 0) {
      writer2.uint32(21).float(message.level);
    }
    if (message.active === true) {
      writer2.uint32(24).bool(message.active);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSpeakerInfo();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sid = reader2.string();
          break;
        case 2:
          message.level = reader2.float();
          break;
        case 3:
          message.active = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sid: isSet$1(object.sid) ? String(object.sid) : "",
      level: isSet$1(object.level) ? Number(object.level) : 0,
      active: isSet$1(object.active) ? Boolean(object.active) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.sid !== void 0 && (obj.sid = message.sid);
    message.level !== void 0 && (obj.level = message.level);
    message.active !== void 0 && (obj.active = message.active);
    return obj;
  },
  create(base) {
    return SpeakerInfo.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseSpeakerInfo();
    message.sid = (_a2 = object.sid) !== null && _a2 !== void 0 ? _a2 : "";
    message.level = (_b = object.level) !== null && _b !== void 0 ? _b : 0;
    message.active = (_c = object.active) !== null && _c !== void 0 ? _c : false;
    return message;
  }
};
function createBaseUserPacket() {
  return {
    participantSid: "",
    payload: new Uint8Array(),
    destinationSids: [],
    topic: void 0
  };
}
const UserPacket = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.participantSid !== "") {
      writer2.uint32(10).string(message.participantSid);
    }
    if (message.payload.length !== 0) {
      writer2.uint32(18).bytes(message.payload);
    }
    for (const v of message.destinationSids) {
      writer2.uint32(26).string(v);
    }
    if (message.topic !== void 0) {
      writer2.uint32(34).string(message.topic);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUserPacket();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participantSid = reader2.string();
          break;
        case 2:
          message.payload = reader2.bytes();
          break;
        case 3:
          message.destinationSids.push(reader2.string());
          break;
        case 4:
          message.topic = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      participantSid: isSet$1(object.participantSid) ? String(object.participantSid) : "",
      payload: isSet$1(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),
      destinationSids: Array.isArray(object === null || object === void 0 ? void 0 : object.destinationSids) ? object.destinationSids.map((e2) => String(e2)) : [],
      topic: isSet$1(object.topic) ? String(object.topic) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
    message.payload !== void 0 && (obj.payload = base64FromBytes(message.payload !== void 0 ? message.payload : new Uint8Array()));
    if (message.destinationSids) {
      obj.destinationSids = message.destinationSids.map((e2) => e2);
    } else {
      obj.destinationSids = [];
    }
    message.topic !== void 0 && (obj.topic = message.topic);
    return obj;
  },
  create(base) {
    return UserPacket.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseUserPacket();
    message.participantSid = (_a2 = object.participantSid) !== null && _a2 !== void 0 ? _a2 : "";
    message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : new Uint8Array();
    message.destinationSids = ((_c = object.destinationSids) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
    message.topic = (_d = object.topic) !== null && _d !== void 0 ? _d : void 0;
    return message;
  }
};
function createBaseParticipantTracks() {
  return {
    participantSid: "",
    trackSids: []
  };
}
const ParticipantTracks = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.participantSid !== "") {
      writer2.uint32(10).string(message.participantSid);
    }
    for (const v of message.trackSids) {
      writer2.uint32(18).string(v);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseParticipantTracks();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participantSid = reader2.string();
          break;
        case 2:
          message.trackSids.push(reader2.string());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      participantSid: isSet$1(object.participantSid) ? String(object.participantSid) : "",
      trackSids: Array.isArray(object === null || object === void 0 ? void 0 : object.trackSids) ? object.trackSids.map((e2) => String(e2)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
    if (message.trackSids) {
      obj.trackSids = message.trackSids.map((e2) => e2);
    } else {
      obj.trackSids = [];
    }
    return obj;
  },
  create(base) {
    return ParticipantTracks.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseParticipantTracks();
    message.participantSid = (_a2 = object.participantSid) !== null && _a2 !== void 0 ? _a2 : "";
    message.trackSids = ((_b = object.trackSids) === null || _b === void 0 ? void 0 : _b.map((e2) => e2)) || [];
    return message;
  }
};
function createBaseServerInfo() {
  return {
    edition: 0,
    version: "",
    protocol: 0,
    region: "",
    nodeId: "",
    debugInfo: ""
  };
}
const ServerInfo = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.edition !== 0) {
      writer2.uint32(8).int32(message.edition);
    }
    if (message.version !== "") {
      writer2.uint32(18).string(message.version);
    }
    if (message.protocol !== 0) {
      writer2.uint32(24).int32(message.protocol);
    }
    if (message.region !== "") {
      writer2.uint32(34).string(message.region);
    }
    if (message.nodeId !== "") {
      writer2.uint32(42).string(message.nodeId);
    }
    if (message.debugInfo !== "") {
      writer2.uint32(50).string(message.debugInfo);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseServerInfo();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.edition = reader2.int32();
          break;
        case 2:
          message.version = reader2.string();
          break;
        case 3:
          message.protocol = reader2.int32();
          break;
        case 4:
          message.region = reader2.string();
          break;
        case 5:
          message.nodeId = reader2.string();
          break;
        case 6:
          message.debugInfo = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      edition: isSet$1(object.edition) ? serverInfo_EditionFromJSON(object.edition) : 0,
      version: isSet$1(object.version) ? String(object.version) : "",
      protocol: isSet$1(object.protocol) ? Number(object.protocol) : 0,
      region: isSet$1(object.region) ? String(object.region) : "",
      nodeId: isSet$1(object.nodeId) ? String(object.nodeId) : "",
      debugInfo: isSet$1(object.debugInfo) ? String(object.debugInfo) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.edition !== void 0 && (obj.edition = serverInfo_EditionToJSON(message.edition));
    message.version !== void 0 && (obj.version = message.version);
    message.protocol !== void 0 && (obj.protocol = Math.round(message.protocol));
    message.region !== void 0 && (obj.region = message.region);
    message.nodeId !== void 0 && (obj.nodeId = message.nodeId);
    message.debugInfo !== void 0 && (obj.debugInfo = message.debugInfo);
    return obj;
  },
  create(base) {
    return ServerInfo.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f;
    const message = createBaseServerInfo();
    message.edition = (_a2 = object.edition) !== null && _a2 !== void 0 ? _a2 : 0;
    message.version = (_b = object.version) !== null && _b !== void 0 ? _b : "";
    message.protocol = (_c = object.protocol) !== null && _c !== void 0 ? _c : 0;
    message.region = (_d = object.region) !== null && _d !== void 0 ? _d : "";
    message.nodeId = (_e = object.nodeId) !== null && _e !== void 0 ? _e : "";
    message.debugInfo = (_f = object.debugInfo) !== null && _f !== void 0 ? _f : "";
    return message;
  }
};
function createBaseClientInfo() {
  return {
    sdk: 0,
    version: "",
    protocol: 0,
    os: "",
    osVersion: "",
    deviceModel: "",
    browser: "",
    browserVersion: "",
    address: "",
    network: ""
  };
}
const ClientInfo = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.sdk !== 0) {
      writer2.uint32(8).int32(message.sdk);
    }
    if (message.version !== "") {
      writer2.uint32(18).string(message.version);
    }
    if (message.protocol !== 0) {
      writer2.uint32(24).int32(message.protocol);
    }
    if (message.os !== "") {
      writer2.uint32(34).string(message.os);
    }
    if (message.osVersion !== "") {
      writer2.uint32(42).string(message.osVersion);
    }
    if (message.deviceModel !== "") {
      writer2.uint32(50).string(message.deviceModel);
    }
    if (message.browser !== "") {
      writer2.uint32(58).string(message.browser);
    }
    if (message.browserVersion !== "") {
      writer2.uint32(66).string(message.browserVersion);
    }
    if (message.address !== "") {
      writer2.uint32(74).string(message.address);
    }
    if (message.network !== "") {
      writer2.uint32(82).string(message.network);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseClientInfo();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sdk = reader2.int32();
          break;
        case 2:
          message.version = reader2.string();
          break;
        case 3:
          message.protocol = reader2.int32();
          break;
        case 4:
          message.os = reader2.string();
          break;
        case 5:
          message.osVersion = reader2.string();
          break;
        case 6:
          message.deviceModel = reader2.string();
          break;
        case 7:
          message.browser = reader2.string();
          break;
        case 8:
          message.browserVersion = reader2.string();
          break;
        case 9:
          message.address = reader2.string();
          break;
        case 10:
          message.network = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sdk: isSet$1(object.sdk) ? clientInfo_SDKFromJSON(object.sdk) : 0,
      version: isSet$1(object.version) ? String(object.version) : "",
      protocol: isSet$1(object.protocol) ? Number(object.protocol) : 0,
      os: isSet$1(object.os) ? String(object.os) : "",
      osVersion: isSet$1(object.osVersion) ? String(object.osVersion) : "",
      deviceModel: isSet$1(object.deviceModel) ? String(object.deviceModel) : "",
      browser: isSet$1(object.browser) ? String(object.browser) : "",
      browserVersion: isSet$1(object.browserVersion) ? String(object.browserVersion) : "",
      address: isSet$1(object.address) ? String(object.address) : "",
      network: isSet$1(object.network) ? String(object.network) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.sdk !== void 0 && (obj.sdk = clientInfo_SDKToJSON(message.sdk));
    message.version !== void 0 && (obj.version = message.version);
    message.protocol !== void 0 && (obj.protocol = Math.round(message.protocol));
    message.os !== void 0 && (obj.os = message.os);
    message.osVersion !== void 0 && (obj.osVersion = message.osVersion);
    message.deviceModel !== void 0 && (obj.deviceModel = message.deviceModel);
    message.browser !== void 0 && (obj.browser = message.browser);
    message.browserVersion !== void 0 && (obj.browserVersion = message.browserVersion);
    message.address !== void 0 && (obj.address = message.address);
    message.network !== void 0 && (obj.network = message.network);
    return obj;
  },
  create(base) {
    return ClientInfo.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const message = createBaseClientInfo();
    message.sdk = (_a2 = object.sdk) !== null && _a2 !== void 0 ? _a2 : 0;
    message.version = (_b = object.version) !== null && _b !== void 0 ? _b : "";
    message.protocol = (_c = object.protocol) !== null && _c !== void 0 ? _c : 0;
    message.os = (_d = object.os) !== null && _d !== void 0 ? _d : "";
    message.osVersion = (_e = object.osVersion) !== null && _e !== void 0 ? _e : "";
    message.deviceModel = (_f = object.deviceModel) !== null && _f !== void 0 ? _f : "";
    message.browser = (_g = object.browser) !== null && _g !== void 0 ? _g : "";
    message.browserVersion = (_h = object.browserVersion) !== null && _h !== void 0 ? _h : "";
    message.address = (_j = object.address) !== null && _j !== void 0 ? _j : "";
    message.network = (_k = object.network) !== null && _k !== void 0 ? _k : "";
    return message;
  }
};
function createBaseClientConfiguration() {
  return {
    video: void 0,
    screen: void 0,
    resumeConnection: 0,
    disabledCodecs: void 0,
    forceRelay: 0
  };
}
const ClientConfiguration = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.video !== void 0) {
      VideoConfiguration.encode(message.video, writer2.uint32(10).fork()).ldelim();
    }
    if (message.screen !== void 0) {
      VideoConfiguration.encode(message.screen, writer2.uint32(18).fork()).ldelim();
    }
    if (message.resumeConnection !== 0) {
      writer2.uint32(24).int32(message.resumeConnection);
    }
    if (message.disabledCodecs !== void 0) {
      DisabledCodecs.encode(message.disabledCodecs, writer2.uint32(34).fork()).ldelim();
    }
    if (message.forceRelay !== 0) {
      writer2.uint32(40).int32(message.forceRelay);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseClientConfiguration();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.video = VideoConfiguration.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.screen = VideoConfiguration.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.resumeConnection = reader2.int32();
          break;
        case 4:
          message.disabledCodecs = DisabledCodecs.decode(reader2, reader2.uint32());
          break;
        case 5:
          message.forceRelay = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      video: isSet$1(object.video) ? VideoConfiguration.fromJSON(object.video) : void 0,
      screen: isSet$1(object.screen) ? VideoConfiguration.fromJSON(object.screen) : void 0,
      resumeConnection: isSet$1(object.resumeConnection) ? clientConfigSettingFromJSON(object.resumeConnection) : 0,
      disabledCodecs: isSet$1(object.disabledCodecs) ? DisabledCodecs.fromJSON(object.disabledCodecs) : void 0,
      forceRelay: isSet$1(object.forceRelay) ? clientConfigSettingFromJSON(object.forceRelay) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.video !== void 0 && (obj.video = message.video ? VideoConfiguration.toJSON(message.video) : void 0);
    message.screen !== void 0 && (obj.screen = message.screen ? VideoConfiguration.toJSON(message.screen) : void 0);
    message.resumeConnection !== void 0 && (obj.resumeConnection = clientConfigSettingToJSON(message.resumeConnection));
    message.disabledCodecs !== void 0 && (obj.disabledCodecs = message.disabledCodecs ? DisabledCodecs.toJSON(message.disabledCodecs) : void 0);
    message.forceRelay !== void 0 && (obj.forceRelay = clientConfigSettingToJSON(message.forceRelay));
    return obj;
  },
  create(base) {
    return ClientConfiguration.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseClientConfiguration();
    message.video = object.video !== void 0 && object.video !== null ? VideoConfiguration.fromPartial(object.video) : void 0;
    message.screen = object.screen !== void 0 && object.screen !== null ? VideoConfiguration.fromPartial(object.screen) : void 0;
    message.resumeConnection = (_a2 = object.resumeConnection) !== null && _a2 !== void 0 ? _a2 : 0;
    message.disabledCodecs = object.disabledCodecs !== void 0 && object.disabledCodecs !== null ? DisabledCodecs.fromPartial(object.disabledCodecs) : void 0;
    message.forceRelay = (_b = object.forceRelay) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function createBaseVideoConfiguration() {
  return {
    hardwareEncoder: 0
  };
}
const VideoConfiguration = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.hardwareEncoder !== 0) {
      writer2.uint32(8).int32(message.hardwareEncoder);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseVideoConfiguration();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hardwareEncoder = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      hardwareEncoder: isSet$1(object.hardwareEncoder) ? clientConfigSettingFromJSON(object.hardwareEncoder) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.hardwareEncoder !== void 0 && (obj.hardwareEncoder = clientConfigSettingToJSON(message.hardwareEncoder));
    return obj;
  },
  create(base) {
    return VideoConfiguration.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2;
    const message = createBaseVideoConfiguration();
    message.hardwareEncoder = (_a2 = object.hardwareEncoder) !== null && _a2 !== void 0 ? _a2 : 0;
    return message;
  }
};
function createBaseDisabledCodecs() {
  return {
    codecs: []
  };
}
const DisabledCodecs = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    for (const v of message.codecs) {
      Codec.encode(v, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDisabledCodecs();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.codecs.push(Codec.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      codecs: Array.isArray(object === null || object === void 0 ? void 0 : object.codecs) ? object.codecs.map((e2) => Codec.fromJSON(e2)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.codecs) {
      obj.codecs = message.codecs.map((e2) => e2 ? Codec.toJSON(e2) : void 0);
    } else {
      obj.codecs = [];
    }
    return obj;
  },
  create(base) {
    return DisabledCodecs.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2;
    const message = createBaseDisabledCodecs();
    message.codecs = ((_a2 = object.codecs) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => Codec.fromPartial(e2))) || [];
    return message;
  }
};
var tsProtoGlobalThis$1 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
  if (tsProtoGlobalThis$1.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis$1.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis$1.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i2 = 0; i2 < bin.length; ++i2) {
      arr[i2] = bin.charCodeAt(i2);
    }
    return arr;
  }
}
function base64FromBytes(arr) {
  if (tsProtoGlobalThis$1.Buffer) {
    return tsProtoGlobalThis$1.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis$1.btoa(bin.join(""));
  }
}
function longToNumber$1(long2) {
  if (long2.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis$1.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long2.toNumber();
}
if (_m0.util.Long !== long) {
  _m0.util.Long = long;
  _m0.configure();
}
function isSet$1(value) {
  return value !== null && value !== void 0;
}
const maxRetryDelay = 7e3;
const DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];
class DefaultReconnectPolicy {
  constructor(retryDelays) {
    this._retryDelays = retryDelays !== void 0 ? [...retryDelays] : DEFAULT_RETRY_DELAYS_IN_MS;
  }
  nextRetryDelayInMs(context2) {
    if (context2.retryCount >= this._retryDelays.length)
      return null;
    const retryDelay = this._retryDelays[context2.retryCount];
    if (context2.retryCount <= 1)
      return retryDelay;
    return retryDelay + Math.random() * 1e3;
  }
}
function _asyncIterator(iterable) {
  var method, async2, sync, retry2 = 2;
  for ("undefined" != typeof Symbol && (async2 = Symbol.asyncIterator, sync = Symbol.iterator); retry2--; ) {
    if (async2 && null != (method = iterable[async2]))
      return method.call(iterable);
    if (sync && null != (method = iterable[sync]))
      return new AsyncFromSyncIterator(method.call(iterable));
    async2 = "@@asyncIterator", sync = "@@iterator";
  }
  throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(s) {
  function AsyncFromSyncIteratorContinuation(r2) {
    if (Object(r2) !== r2)
      return Promise.reject(new TypeError(r2 + " is not an object."));
    var done = r2.done;
    return Promise.resolve(r2.value).then(function(value) {
      return {
        value,
        done
      };
    });
  }
  return AsyncFromSyncIterator = function(s2) {
    this.s = s2, this.n = s2.next;
  }, AsyncFromSyncIterator.prototype = {
    s: null,
    n: null,
    next: function() {
      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
    },
    return: function(value) {
      var ret = this.s.return;
      return void 0 === ret ? Promise.resolve({
        value,
        done: true
      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
    },
    throw: function(value) {
      var thr = this.s.return;
      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
    }
  }, new AsyncFromSyncIterator(s);
}
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source2), true).forEach(function(key) {
      _defineProperty(target, key, source2[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys(Object(source2)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
let logDisabled_ = true;
let deprecationWarnings_ = true;
function extractVersion(uastring, expr, pos) {
  const match = uastring.match(expr);
  return match && match.length >= pos && parseInt(match[pos], 10);
}
function wrapPeerConnectionEvent(window2, eventNameToWrap, wrapper) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  const proto = window2.RTCPeerConnection.prototype;
  const nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    const wrappedCallback = (e2) => {
      const modifiedEvent = wrapper(e2);
      if (modifiedEvent) {
        if (cb.handleEvent) {
          cb.handleEvent(modifiedEvent);
        } else {
          cb(modifiedEvent);
        }
      }
    };
    this._eventMap = this._eventMap || {};
    if (!this._eventMap[eventNameToWrap]) {
      this._eventMap[eventNameToWrap] = /* @__PURE__ */ new Map();
    }
    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
  };
  const nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    if (!this._eventMap[eventNameToWrap].has(cb)) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
    this._eventMap[eventNameToWrap].delete(cb);
    if (this._eventMap[eventNameToWrap].size === 0) {
      delete this._eventMap[eventNameToWrap];
    }
    if (Object.keys(this._eventMap).length === 0) {
      delete this._eventMap;
    }
    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
  };
  Object.defineProperty(proto, "on" + eventNameToWrap, {
    get() {
      return this["_on" + eventNameToWrap];
    },
    set(cb) {
      if (this["_on" + eventNameToWrap]) {
        this.removeEventListener(eventNameToWrap, this["_on" + eventNameToWrap]);
        delete this["_on" + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(eventNameToWrap, this["_on" + eventNameToWrap] = cb);
      }
    },
    enumerable: true,
    configurable: true
  });
}
function disableLog(bool) {
  if (typeof bool !== "boolean") {
    return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
  }
  logDisabled_ = bool;
  return bool ? "adapter.js logging disabled" : "adapter.js logging enabled";
}
function disableWarnings(bool) {
  if (typeof bool !== "boolean") {
    return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
  }
  deprecationWarnings_ = !bool;
  return "adapter.js deprecation warnings " + (bool ? "disabled" : "enabled");
}
function log() {
  if (typeof window === "object") {
    if (logDisabled_) {
      return;
    }
    if (typeof console !== "undefined" && typeof console.log === "function") {
      console.log.apply(console, arguments);
    }
  }
}
function deprecated(oldMethod, newMethod) {
  if (!deprecationWarnings_) {
    return;
  }
  console.warn(oldMethod + " is deprecated, please use " + newMethod + " instead.");
}
function detectBrowser(window2) {
  const result = {
    browser: null,
    version: null
  };
  if (typeof window2 === "undefined" || !window2.navigator) {
    result.browser = "Not a browser.";
    return result;
  }
  const {
    navigator: navigator2
  } = window2;
  if (navigator2.mozGetUserMedia) {
    result.browser = "firefox";
    result.version = extractVersion(navigator2.userAgent, /Firefox\/(\d+)\./, 1);
  } else if (navigator2.webkitGetUserMedia || window2.isSecureContext === false && window2.webkitRTCPeerConnection && !window2.RTCIceGatherer) {
    result.browser = "chrome";
    result.version = extractVersion(navigator2.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
  } else if (window2.RTCPeerConnection && navigator2.userAgent.match(/AppleWebKit\/(\d+)\./)) {
    result.browser = "safari";
    result.version = extractVersion(navigator2.userAgent, /AppleWebKit\/(\d+)\./, 1);
    result.supportsUnifiedPlan = window2.RTCRtpTransceiver && "currentDirection" in window2.RTCRtpTransceiver.prototype;
  } else {
    result.browser = "Not a supported browser.";
    return result;
  }
  return result;
}
function isObject(val) {
  return Object.prototype.toString.call(val) === "[object Object]";
}
function compactObject(data2) {
  if (!isObject(data2)) {
    return data2;
  }
  return Object.keys(data2).reduce(function(accumulator, key) {
    const isObj = isObject(data2[key]);
    const value = isObj ? compactObject(data2[key]) : data2[key];
    const isEmptyObject = isObj && !Object.keys(value).length;
    if (value === void 0 || isEmptyObject) {
      return accumulator;
    }
    return Object.assign(accumulator, {
      [key]: value
    });
  }, {});
}
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach((name2) => {
    if (name2.endsWith("Id")) {
      walkStats(stats, stats.get(base[name2]), resultSet);
    } else if (name2.endsWith("Ids")) {
      base[name2].forEach((id) => {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}
function filterStats(result, track, outbound) {
  const streamStatsType = outbound ? "outbound-rtp" : "inbound-rtp";
  const filteredResult = /* @__PURE__ */ new Map();
  if (track === null) {
    return filteredResult;
  }
  const trackStats = [];
  result.forEach((value) => {
    if (value.type === "track" && value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach((trackStat) => {
    result.forEach((stats) => {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}
const logging = log;
function shimGetUserMedia$2(window2, browserDetails) {
  const navigator2 = window2 && window2.navigator;
  if (!navigator2.mediaDevices) {
    return;
  }
  const constraintsToChrome_ = function(c) {
    if (typeof c !== "object" || c.mandatory || c.optional) {
      return c;
    }
    const cc = {};
    Object.keys(c).forEach((key) => {
      if (key === "require" || key === "advanced" || key === "mediaSource") {
        return;
      }
      const r2 = typeof c[key] === "object" ? c[key] : {
        ideal: c[key]
      };
      if (r2.exact !== void 0 && typeof r2.exact === "number") {
        r2.min = r2.max = r2.exact;
      }
      const oldname_ = function(prefix, name2) {
        if (prefix) {
          return prefix + name2.charAt(0).toUpperCase() + name2.slice(1);
        }
        return name2 === "deviceId" ? "sourceId" : name2;
      };
      if (r2.ideal !== void 0) {
        cc.optional = cc.optional || [];
        let oc = {};
        if (typeof r2.ideal === "number") {
          oc[oldname_("min", key)] = r2.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_("max", key)] = r2.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_("", key)] = r2.ideal;
          cc.optional.push(oc);
        }
      }
      if (r2.exact !== void 0 && typeof r2.exact !== "number") {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_("", key)] = r2.exact;
      } else {
        ["min", "max"].forEach((mix) => {
          if (r2[mix] !== void 0) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r2[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };
  const shimConstraints_ = function(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === "object") {
      const remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, "autoGainControl", "googAutoGainControl");
      remap(constraints.audio, "noiseSuppression", "googNoiseSuppression");
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === "object") {
      let face = constraints.video.facingMode;
      face = face && (typeof face === "object" ? face : {
        ideal: face
      });
      const getSupportedFacingModeLies = browserDetails.version < 66;
      if (face && (face.exact === "user" || face.exact === "environment" || face.ideal === "user" || face.ideal === "environment") && !(navigator2.mediaDevices.getSupportedConstraints && navigator2.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        let matches;
        if (face.exact === "environment" || face.ideal === "environment") {
          matches = ["back", "rear"];
        } else if (face.exact === "user" || face.ideal === "user") {
          matches = ["front"];
        }
        if (matches) {
          return navigator2.mediaDevices.enumerateDevices().then((devices) => {
            devices = devices.filter((d) => d.kind === "videoinput");
            let dev = devices.find((d) => matches.some((match) => d.label.toLowerCase().includes(match)));
            if (!dev && devices.length && matches.includes("back")) {
              dev = devices[devices.length - 1];
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? {
                exact: dev.deviceId
              } : {
                ideal: dev.deviceId
              };
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging("chrome: " + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging("chrome: " + JSON.stringify(constraints));
    return func(constraints);
  };
  const shimError_ = function(e2) {
    if (browserDetails.version >= 64) {
      return e2;
    }
    return {
      name: {
        PermissionDeniedError: "NotAllowedError",
        PermissionDismissedError: "NotAllowedError",
        InvalidStateError: "NotAllowedError",
        DevicesNotFoundError: "NotFoundError",
        ConstraintNotSatisfiedError: "OverconstrainedError",
        TrackStartError: "NotReadableError",
        MediaDeviceFailedDueToShutdown: "NotAllowedError",
        MediaDeviceKillSwitchOn: "NotAllowedError",
        TabCaptureError: "AbortError",
        ScreenCaptureError: "AbortError",
        DeviceCaptureError: "AbortError"
      }[e2.name] || e2.name,
      message: e2.message,
      constraint: e2.constraint || e2.constraintName,
      toString() {
        return this.name + (this.message && ": ") + this.message;
      }
    };
  };
  const getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, (c) => {
      navigator2.webkitGetUserMedia(c, onSuccess, (e2) => {
        if (onError) {
          onError(shimError_(e2));
        }
      });
    });
  };
  navigator2.getUserMedia = getUserMedia_.bind(navigator2);
  if (navigator2.mediaDevices.getUserMedia) {
    const origGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, (c) => origGetUserMedia(c).then((stream) => {
        if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach((track) => {
            track.stop();
          });
          throw new DOMException("", "NotFoundError");
        }
        return stream;
      }, (e2) => Promise.reject(shimError_(e2))));
    };
  }
}
function shimGetDisplayMedia$1(window2, getSourceId) {
  if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
    return;
  }
  if (!window2.navigator.mediaDevices) {
    return;
  }
  if (typeof getSourceId !== "function") {
    console.error("shimGetDisplayMedia: getSourceId argument is not a function");
    return;
  }
  window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    return getSourceId(constraints).then((sourceId) => {
      const widthSpecified = constraints.video && constraints.video.width;
      const heightSpecified = constraints.video && constraints.video.height;
      const frameRateSpecified = constraints.video && constraints.video.frameRate;
      constraints.video = {
        mandatory: {
          chromeMediaSource: "desktop",
          chromeMediaSourceId: sourceId,
          maxFrameRate: frameRateSpecified || 3
        }
      };
      if (widthSpecified) {
        constraints.video.mandatory.maxWidth = widthSpecified;
      }
      if (heightSpecified) {
        constraints.video.mandatory.maxHeight = heightSpecified;
      }
      return window2.navigator.mediaDevices.getUserMedia(constraints);
    });
  };
}
function shimMediaStream(window2) {
  window2.MediaStream = window2.MediaStream || window2.webkitMediaStream;
}
function shimOnTrack$1(window2) {
  if (typeof window2 === "object" && window2.RTCPeerConnection && !("ontrack" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "ontrack", {
      get() {
        return this._ontrack;
      },
      set(f2) {
        if (this._ontrack) {
          this.removeEventListener("track", this._ontrack);
        }
        this.addEventListener("track", this._ontrack = f2);
      },
      enumerable: true,
      configurable: true
    });
    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      if (!this._ontrackpoly) {
        this._ontrackpoly = (e2) => {
          e2.stream.addEventListener("addtrack", (te) => {
            let receiver;
            if (window2.RTCPeerConnection.prototype.getReceivers) {
              receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === te.track.id);
            } else {
              receiver = {
                track: te.track
              };
            }
            const event2 = new Event("track");
            event2.track = te.track;
            event2.receiver = receiver;
            event2.transceiver = {
              receiver
            };
            event2.streams = [e2.stream];
            this.dispatchEvent(event2);
          });
          e2.stream.getTracks().forEach((track) => {
            let receiver;
            if (window2.RTCPeerConnection.prototype.getReceivers) {
              receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === track.id);
            } else {
              receiver = {
                track
              };
            }
            const event2 = new Event("track");
            event2.track = track;
            event2.receiver = receiver;
            event2.transceiver = {
              receiver
            };
            event2.streams = [e2.stream];
            this.dispatchEvent(event2);
          });
        };
        this.addEventListener("addstream", this._ontrackpoly);
      }
      return origSetRemoteDescription.apply(this, arguments);
    };
  } else {
    wrapPeerConnectionEvent(window2, "track", (e2) => {
      if (!e2.transceiver) {
        Object.defineProperty(e2, "transceiver", {
          value: {
            receiver: e2.receiver
          }
        });
      }
      return e2;
    });
  }
}
function shimGetSendersWithDtmf(window2) {
  if (typeof window2 === "object" && window2.RTCPeerConnection && !("getSenders" in window2.RTCPeerConnection.prototype) && "createDTMFSender" in window2.RTCPeerConnection.prototype) {
    const shimSenderWithDtmf = function(pc, track) {
      return {
        track,
        get dtmf() {
          if (this._dtmf === void 0) {
            if (track.kind === "audio") {
              this._dtmf = pc.createDTMFSender(track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        },
        _pc: pc
      };
    };
    if (!window2.RTCPeerConnection.prototype.getSenders) {
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        this._senders = this._senders || [];
        return this._senders.slice();
      };
      const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
      window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
        let sender = origAddTrack.apply(this, arguments);
        if (!sender) {
          sender = shimSenderWithDtmf(this, track);
          this._senders.push(sender);
        }
        return sender;
      };
      const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
      window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
        origRemoveTrack.apply(this, arguments);
        const idx = this._senders.indexOf(sender);
        if (idx !== -1) {
          this._senders.splice(idx, 1);
        }
      };
    }
    const origAddStream = window2.RTCPeerConnection.prototype.addStream;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._senders = this._senders || [];
      origAddStream.apply(this, [stream]);
      stream.getTracks().forEach((track) => {
        this._senders.push(shimSenderWithDtmf(this, track));
      });
    };
    const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      this._senders = this._senders || [];
      origRemoveStream.apply(this, [stream]);
      stream.getTracks().forEach((track) => {
        const sender = this._senders.find((s) => s.track === track);
        if (sender) {
          this._senders.splice(this._senders.indexOf(sender), 1);
        }
      });
    };
  } else if (typeof window2 === "object" && window2.RTCPeerConnection && "getSenders" in window2.RTCPeerConnection.prototype && "createDTMFSender" in window2.RTCPeerConnection.prototype && window2.RTCRtpSender && !("dtmf" in window2.RTCRtpSender.prototype)) {
    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
    window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach((sender) => sender._pc = this);
      return senders;
    };
    Object.defineProperty(window2.RTCRtpSender.prototype, "dtmf", {
      get() {
        if (this._dtmf === void 0) {
          if (this.track.kind === "audio") {
            this._dtmf = this._pc.createDTMFSender(this.track);
          } else {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
}
function shimGetStats(window2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  const origGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = function getStats() {
    const [selector, onSucc, onErr] = arguments;
    if (arguments.length > 0 && typeof selector === "function") {
      return origGetStats.apply(this, arguments);
    }
    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== "function")) {
      return origGetStats.apply(this, []);
    }
    const fixChromeStats_ = function(response) {
      const standardReport = {};
      const reports = response.result();
      reports.forEach((report) => {
        const standardStats = {
          id: report.id,
          timestamp: report.timestamp,
          type: {
            localcandidate: "local-candidate",
            remotecandidate: "remote-candidate"
          }[report.type] || report.type
        };
        report.names().forEach((name2) => {
          standardStats[name2] = report.stat(name2);
        });
        standardReport[standardStats.id] = standardStats;
      });
      return standardReport;
    };
    const makeMapStats = function(stats) {
      return new Map(Object.keys(stats).map((key) => [key, stats[key]]));
    };
    if (arguments.length >= 2) {
      const successCallbackWrapper_ = function(response) {
        onSucc(makeMapStats(fixChromeStats_(response)));
      };
      return origGetStats.apply(this, [successCallbackWrapper_, selector]);
    }
    return new Promise((resolve, reject) => {
      origGetStats.apply(this, [function(response) {
        resolve(makeMapStats(fixChromeStats_(response)));
      }, reject]);
    }).then(onSucc, onErr);
  };
}
function shimSenderReceiverGetStats(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender && window2.RTCRtpReceiver)) {
    return;
  }
  if (!("getStats" in window2.RTCRtpSender.prototype)) {
    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => sender._pc = this);
        return senders;
      };
    }
    const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
        const sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window2.RTCRtpSender.prototype.getStats = function getStats() {
      const sender = this;
      return this._pc.getStats().then((result) => filterStats(result, sender.track, true));
    };
  }
  if (!("getStats" in window2.RTCRtpReceiver.prototype)) {
    const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        const receivers = origGetReceivers.apply(this, []);
        receivers.forEach((receiver) => receiver._pc = this);
        return receivers;
      };
    }
    wrapPeerConnectionEvent(window2, "track", (e2) => {
      e2.receiver._pc = e2.srcElement;
      return e2;
    });
    window2.RTCRtpReceiver.prototype.getStats = function getStats() {
      const receiver = this;
      return this._pc.getStats().then((result) => filterStats(result, receiver.track, false));
    };
  }
  if (!("getStats" in window2.RTCRtpSender.prototype && "getStats" in window2.RTCRtpReceiver.prototype)) {
    return;
  }
  const origGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = function getStats() {
    if (arguments.length > 0 && arguments[0] instanceof window2.MediaStreamTrack) {
      const track = arguments[0];
      let sender;
      let receiver;
      let err;
      this.getSenders().forEach((s) => {
        if (s.track === track) {
          if (sender) {
            err = true;
          } else {
            sender = s;
          }
        }
      });
      this.getReceivers().forEach((r2) => {
        if (r2.track === track) {
          if (receiver) {
            err = true;
          } else {
            receiver = r2;
          }
        }
        return r2.track === track;
      });
      if (err || sender && receiver) {
        return Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError"));
      } else if (sender) {
        return sender.getStats();
      } else if (receiver) {
        return receiver.getStats();
      }
      return Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
    }
    return origGetStats.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrackWithNative(window2) {
  window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    return Object.keys(this._shimmedLocalStreams).map((streamId) => this._shimmedLocalStreams[streamId][0]);
  };
  const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
  window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    if (!stream) {
      return origAddTrack.apply(this, arguments);
    }
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const sender = origAddTrack.apply(this, arguments);
    if (!this._shimmedLocalStreams[stream.id]) {
      this._shimmedLocalStreams[stream.id] = [stream, sender];
    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
      this._shimmedLocalStreams[stream.id].push(sender);
    }
    return sender;
  };
  const origAddStream = window2.RTCPeerConnection.prototype.addStream;
  window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    stream.getTracks().forEach((track) => {
      const alreadyExists = this.getSenders().find((s) => s.track === track);
      if (alreadyExists) {
        throw new DOMException("Track already exists.", "InvalidAccessError");
      }
    });
    const existingSenders = this.getSenders();
    origAddStream.apply(this, arguments);
    const newSenders = this.getSenders().filter((newSender) => existingSenders.indexOf(newSender) === -1);
    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
  };
  const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    delete this._shimmedLocalStreams[stream.id];
    return origRemoveStream.apply(this, arguments);
  };
  const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
  window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    if (sender) {
      Object.keys(this._shimmedLocalStreams).forEach((streamId) => {
        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
        if (idx !== -1) {
          this._shimmedLocalStreams[streamId].splice(idx, 1);
        }
        if (this._shimmedLocalStreams[streamId].length === 1) {
          delete this._shimmedLocalStreams[streamId];
        }
      });
    }
    return origRemoveTrack.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrack(window2, browserDetails) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (window2.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
    return shimAddTrackRemoveTrackWithNative(window2);
  }
  const origGetLocalStreams = window2.RTCPeerConnection.prototype.getLocalStreams;
  window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    const nativeStreams = origGetLocalStreams.apply(this);
    this._reverseStreams = this._reverseStreams || {};
    return nativeStreams.map((stream) => this._reverseStreams[stream.id]);
  };
  const origAddStream = window2.RTCPeerConnection.prototype.addStream;
  window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    stream.getTracks().forEach((track) => {
      const alreadyExists = this.getSenders().find((s) => s.track === track);
      if (alreadyExists) {
        throw new DOMException("Track already exists.", "InvalidAccessError");
      }
    });
    if (!this._reverseStreams[stream.id]) {
      const newStream = new window2.MediaStream(stream.getTracks());
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      stream = newStream;
    }
    origAddStream.apply(this, [stream]);
  };
  const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
    delete this._streams[stream.id];
  };
  window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    if (this.signalingState === "closed") {
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    }
    const streams = [].slice.call(arguments, 1);
    if (streams.length !== 1 || !streams[0].getTracks().find((t2) => t2 === track)) {
      throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
    }
    const alreadyExists = this.getSenders().find((s) => s.track === track);
    if (alreadyExists) {
      throw new DOMException("Track already exists.", "InvalidAccessError");
    }
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    const oldStream = this._streams[stream.id];
    if (oldStream) {
      oldStream.addTrack(track);
      Promise.resolve().then(() => {
        this.dispatchEvent(new Event("negotiationneeded"));
      });
    } else {
      const newStream = new window2.MediaStream([track]);
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      this.addStream(newStream);
    }
    return this.getSenders().find((s) => s.track === track);
  };
  function replaceInternalStreamId(pc, description2) {
    let sdp2 = description2.sdp;
    Object.keys(pc._reverseStreams || []).forEach((internalId) => {
      const externalStream = pc._reverseStreams[internalId];
      const internalStream = pc._streams[externalStream.id];
      sdp2 = sdp2.replace(new RegExp(internalStream.id, "g"), externalStream.id);
    });
    return new RTCSessionDescription({
      type: description2.type,
      sdp: sdp2
    });
  }
  function replaceExternalStreamId(pc, description2) {
    let sdp2 = description2.sdp;
    Object.keys(pc._reverseStreams || []).forEach((internalId) => {
      const externalStream = pc._reverseStreams[internalId];
      const internalStream = pc._streams[externalStream.id];
      sdp2 = sdp2.replace(new RegExp(externalStream.id, "g"), internalStream.id);
    });
    return new RTCSessionDescription({
      type: description2.type,
      sdp: sdp2
    });
  }
  ["createOffer", "createAnswer"].forEach(function(method) {
    const nativeMethod = window2.RTCPeerConnection.prototype[method];
    const methodObj = {
      [method]() {
        const args = arguments;
        const isLegacyCall = arguments.length && typeof arguments[0] === "function";
        if (isLegacyCall) {
          return nativeMethod.apply(this, [(description2) => {
            const desc = replaceInternalStreamId(this, description2);
            args[0].apply(null, [desc]);
          }, (err) => {
            if (args[1]) {
              args[1].apply(null, err);
            }
          }, arguments[2]]);
        }
        return nativeMethod.apply(this, arguments).then((description2) => replaceInternalStreamId(this, description2));
      }
    };
    window2.RTCPeerConnection.prototype[method] = methodObj[method];
  });
  const origSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
  window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    if (!arguments.length || !arguments[0].type) {
      return origSetLocalDescription.apply(this, arguments);
    }
    arguments[0] = replaceExternalStreamId(this, arguments[0]);
    return origSetLocalDescription.apply(this, arguments);
  };
  const origLocalDescription = Object.getOwnPropertyDescriptor(window2.RTCPeerConnection.prototype, "localDescription");
  Object.defineProperty(window2.RTCPeerConnection.prototype, "localDescription", {
    get() {
      const description2 = origLocalDescription.get.apply(this);
      if (description2.type === "") {
        return description2;
      }
      return replaceInternalStreamId(this, description2);
    }
  });
  window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    if (this.signalingState === "closed") {
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    }
    if (!sender._pc) {
      throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    }
    const isLocal = sender._pc === this;
    if (!isLocal) {
      throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
    }
    this._streams = this._streams || {};
    let stream;
    Object.keys(this._streams).forEach((streamid) => {
      const hasTrack = this._streams[streamid].getTracks().find((track) => sender.track === track);
      if (hasTrack) {
        stream = this._streams[streamid];
      }
    });
    if (stream) {
      if (stream.getTracks().length === 1) {
        this.removeStream(this._reverseStreams[stream.id]);
      } else {
        stream.removeTrack(sender.track);
      }
      this.dispatchEvent(new Event("negotiationneeded"));
    }
  };
}
function shimPeerConnection$1(window2, browserDetails) {
  if (!window2.RTCPeerConnection && window2.webkitRTCPeerConnection) {
    window2.RTCPeerConnection = window2.webkitRTCPeerConnection;
  }
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (browserDetails.version < 53) {
    ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
      const nativeMethod = window2.RTCPeerConnection.prototype[method];
      const methodObj = {
        [method]() {
          arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
          return nativeMethod.apply(this, arguments);
        }
      };
      window2.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }
}
function fixNegotiationNeeded(window2, browserDetails) {
  wrapPeerConnectionEvent(window2, "negotiationneeded", (e2) => {
    const pc = e2.target;
    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === "plan-b") {
      if (pc.signalingState !== "stable") {
        return;
      }
    }
    return e2;
  });
}
var chromeShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fixNegotiationNeeded,
  shimAddTrackRemoveTrack,
  shimAddTrackRemoveTrackWithNative,
  shimGetDisplayMedia: shimGetDisplayMedia$1,
  shimGetSendersWithDtmf,
  shimGetStats,
  shimGetUserMedia: shimGetUserMedia$2,
  shimMediaStream,
  shimOnTrack: shimOnTrack$1,
  shimPeerConnection: shimPeerConnection$1,
  shimSenderReceiverGetStats
});
function shimGetUserMedia$1(window2, browserDetails) {
  const navigator2 = window2 && window2.navigator;
  const MediaStreamTrack2 = window2 && window2.MediaStreamTrack;
  navigator2.getUserMedia = function(constraints, onSuccess, onError) {
    deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia");
    navigator2.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
  if (!(browserDetails.version > 55 && "autoGainControl" in navigator2.mediaDevices.getSupportedConstraints())) {
    const remap = function(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };
    const nativeGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(c) {
      if (typeof c === "object" && typeof c.audio === "object") {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, "autoGainControl", "mozAutoGainControl");
        remap(c.audio, "noiseSuppression", "mozNoiseSuppression");
      }
      return nativeGetUserMedia(c);
    };
    if (MediaStreamTrack2 && MediaStreamTrack2.prototype.getSettings) {
      const nativeGetSettings = MediaStreamTrack2.prototype.getSettings;
      MediaStreamTrack2.prototype.getSettings = function() {
        const obj = nativeGetSettings.apply(this, arguments);
        remap(obj, "mozAutoGainControl", "autoGainControl");
        remap(obj, "mozNoiseSuppression", "noiseSuppression");
        return obj;
      };
    }
    if (MediaStreamTrack2 && MediaStreamTrack2.prototype.applyConstraints) {
      const nativeApplyConstraints = MediaStreamTrack2.prototype.applyConstraints;
      MediaStreamTrack2.prototype.applyConstraints = function(c) {
        if (this.kind === "audio" && typeof c === "object") {
          c = JSON.parse(JSON.stringify(c));
          remap(c, "autoGainControl", "mozAutoGainControl");
          remap(c, "noiseSuppression", "mozNoiseSuppression");
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
}
function shimGetDisplayMedia(window2, preferredMediaSource) {
  if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
    return;
  }
  if (!window2.navigator.mediaDevices) {
    return;
  }
  window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    if (!(constraints && constraints.video)) {
      const err = new DOMException("getDisplayMedia without video constraints is undefined");
      err.name = "NotFoundError";
      err.code = 8;
      return Promise.reject(err);
    }
    if (constraints.video === true) {
      constraints.video = {
        mediaSource: preferredMediaSource
      };
    } else {
      constraints.video.mediaSource = preferredMediaSource;
    }
    return window2.navigator.mediaDevices.getUserMedia(constraints);
  };
}
function shimOnTrack(window2) {
  if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
    Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
      get() {
        return {
          receiver: this.receiver
        };
      }
    });
  }
}
function shimPeerConnection(window2, browserDetails) {
  if (typeof window2 !== "object" || !(window2.RTCPeerConnection || window2.mozRTCPeerConnection)) {
    return;
  }
  if (!window2.RTCPeerConnection && window2.mozRTCPeerConnection) {
    window2.RTCPeerConnection = window2.mozRTCPeerConnection;
  }
  if (browserDetails.version < 53) {
    ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
      const nativeMethod = window2.RTCPeerConnection.prototype[method];
      const methodObj = {
        [method]() {
          arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
          return nativeMethod.apply(this, arguments);
        }
      };
      window2.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }
  const modernStatsTypes = {
    inboundrtp: "inbound-rtp",
    outboundrtp: "outbound-rtp",
    candidatepair: "candidate-pair",
    localcandidate: "local-candidate",
    remotecandidate: "remote-candidate"
  };
  const nativeGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = function getStats() {
    const [selector, onSucc, onErr] = arguments;
    return nativeGetStats.apply(this, [selector || null]).then((stats) => {
      if (browserDetails.version < 53 && !onSucc) {
        try {
          stats.forEach((stat) => {
            stat.type = modernStatsTypes[stat.type] || stat.type;
          });
        } catch (e2) {
          if (e2.name !== "TypeError") {
            throw e2;
          }
          stats.forEach((stat, i2) => {
            stats.set(i2, Object.assign({}, stat, {
              type: modernStatsTypes[stat.type] || stat.type
            }));
          });
        }
      }
      return stats;
    }).then(onSucc, onErr);
  };
}
function shimSenderGetStats(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
    return;
  }
  if (window2.RTCRtpSender && "getStats" in window2.RTCRtpSender.prototype) {
    return;
  }
  const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
  if (origGetSenders) {
    window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach((sender) => sender._pc = this);
      return senders;
    };
  }
  const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
  if (origAddTrack) {
    window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
      const sender = origAddTrack.apply(this, arguments);
      sender._pc = this;
      return sender;
    };
  }
  window2.RTCRtpSender.prototype.getStats = function getStats() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  };
}
function shimReceiverGetStats(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
    return;
  }
  if (window2.RTCRtpSender && "getStats" in window2.RTCRtpReceiver.prototype) {
    return;
  }
  const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
  if (origGetReceivers) {
    window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
      const receivers = origGetReceivers.apply(this, []);
      receivers.forEach((receiver) => receiver._pc = this);
      return receivers;
    };
  }
  wrapPeerConnectionEvent(window2, "track", (e2) => {
    e2.receiver._pc = e2.srcElement;
    return e2;
  });
  window2.RTCRtpReceiver.prototype.getStats = function getStats() {
    return this._pc.getStats(this.track);
  };
}
function shimRemoveStream(window2) {
  if (!window2.RTCPeerConnection || "removeStream" in window2.RTCPeerConnection.prototype) {
    return;
  }
  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    deprecated("removeStream", "removeTrack");
    this.getSenders().forEach((sender) => {
      if (sender.track && stream.getTracks().includes(sender.track)) {
        this.removeTrack(sender);
      }
    });
  };
}
function shimRTCDataChannel(window2) {
  if (window2.DataChannel && !window2.RTCDataChannel) {
    window2.RTCDataChannel = window2.DataChannel;
  }
}
function shimAddTransceiver(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
    return;
  }
  const origAddTransceiver = window2.RTCPeerConnection.prototype.addTransceiver;
  if (origAddTransceiver) {
    window2.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
      this.setParametersPromises = [];
      const initParameters = arguments[1];
      const shouldPerformCheck = initParameters && "sendEncodings" in initParameters;
      if (shouldPerformCheck) {
        initParameters.sendEncodings.forEach((encodingParam) => {
          if ("rid" in encodingParam) {
            const ridRegex = /^[a-z0-9]{0,16}$/i;
            if (!ridRegex.test(encodingParam.rid)) {
              throw new TypeError("Invalid RID value provided.");
            }
          }
          if ("scaleResolutionDownBy" in encodingParam) {
            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1)) {
              throw new RangeError("scale_resolution_down_by must be >= 1.0");
            }
          }
          if ("maxFramerate" in encodingParam) {
            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
              throw new RangeError("max_framerate must be >= 0.0");
            }
          }
        });
      }
      const transceiver = origAddTransceiver.apply(this, arguments);
      if (shouldPerformCheck) {
        const {
          sender
        } = transceiver;
        const params = sender.getParameters();
        if (!("encodings" in params) || params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {
          params.encodings = initParameters.sendEncodings;
          sender.sendEncodings = initParameters.sendEncodings;
          this.setParametersPromises.push(sender.setParameters(params).then(() => {
            delete sender.sendEncodings;
          }).catch(() => {
            delete sender.sendEncodings;
          }));
        }
      }
      return transceiver;
    };
  }
}
function shimGetParameters(window2) {
  if (!(typeof window2 === "object" && window2.RTCRtpSender)) {
    return;
  }
  const origGetParameters = window2.RTCRtpSender.prototype.getParameters;
  if (origGetParameters) {
    window2.RTCRtpSender.prototype.getParameters = function getParameters() {
      const params = origGetParameters.apply(this, arguments);
      if (!("encodings" in params)) {
        params.encodings = [].concat(this.sendEncodings || [{}]);
      }
      return params;
    };
  }
}
function shimCreateOffer(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
    return;
  }
  const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
  window2.RTCPeerConnection.prototype.createOffer = function createOffer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(() => {
        return origCreateOffer.apply(this, arguments);
      }).finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateOffer.apply(this, arguments);
  };
}
function shimCreateAnswer(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
    return;
  }
  const origCreateAnswer = window2.RTCPeerConnection.prototype.createAnswer;
  window2.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(() => {
        return origCreateAnswer.apply(this, arguments);
      }).finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateAnswer.apply(this, arguments);
  };
}
var firefoxShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  shimAddTransceiver,
  shimCreateAnswer,
  shimCreateOffer,
  shimGetDisplayMedia,
  shimGetParameters,
  shimGetUserMedia: shimGetUserMedia$1,
  shimOnTrack,
  shimPeerConnection,
  shimRTCDataChannel,
  shimReceiverGetStats,
  shimRemoveStream,
  shimSenderGetStats
});
function shimLocalStreamsAPI(window2) {
  if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  if (!("getLocalStreams" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      return this._localStreams;
    };
  }
  if (!("addStream" in window2.RTCPeerConnection.prototype)) {
    const _addTrack = window2.RTCPeerConnection.prototype.addTrack;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      if (!this._localStreams.includes(stream)) {
        this._localStreams.push(stream);
      }
      stream.getAudioTracks().forEach((track) => _addTrack.call(this, track, stream));
      stream.getVideoTracks().forEach((track) => _addTrack.call(this, track, stream));
    };
    window2.RTCPeerConnection.prototype.addTrack = function addTrack(track) {
      for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        streams[_key - 1] = arguments[_key];
      }
      if (streams) {
        streams.forEach((stream) => {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (!this._localStreams.includes(stream)) {
            this._localStreams.push(stream);
          }
        });
      }
      return _addTrack.apply(this, arguments);
    };
  }
  if (!("removeStream" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      const index2 = this._localStreams.indexOf(stream);
      if (index2 === -1) {
        return;
      }
      this._localStreams.splice(index2, 1);
      const tracks = stream.getTracks();
      this.getSenders().forEach((sender) => {
        if (tracks.includes(sender.track)) {
          this.removeTrack(sender);
        }
      });
    };
  }
}
function shimRemoteStreamsAPI(window2) {
  if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  if (!("getRemoteStreams" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
      return this._remoteStreams ? this._remoteStreams : [];
    };
  }
  if (!("onaddstream" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "onaddstream", {
      get() {
        return this._onaddstream;
      },
      set(f2) {
        if (this._onaddstream) {
          this.removeEventListener("addstream", this._onaddstream);
          this.removeEventListener("track", this._onaddstreampoly);
        }
        this.addEventListener("addstream", this._onaddstream = f2);
        this.addEventListener("track", this._onaddstreampoly = (e2) => {
          e2.streams.forEach((stream) => {
            if (!this._remoteStreams) {
              this._remoteStreams = [];
            }
            if (this._remoteStreams.includes(stream)) {
              return;
            }
            this._remoteStreams.push(stream);
            const event2 = new Event("addstream");
            event2.stream = stream;
            this.dispatchEvent(event2);
          });
        });
      }
    });
    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      const pc = this;
      if (!this._onaddstreampoly) {
        this.addEventListener("track", this._onaddstreampoly = function(e2) {
          e2.streams.forEach((stream) => {
            if (!pc._remoteStreams) {
              pc._remoteStreams = [];
            }
            if (pc._remoteStreams.indexOf(stream) >= 0) {
              return;
            }
            pc._remoteStreams.push(stream);
            const event2 = new Event("addstream");
            event2.stream = stream;
            pc.dispatchEvent(event2);
          });
        });
      }
      return origSetRemoteDescription.apply(pc, arguments);
    };
  }
}
function shimCallbacksAPI(window2) {
  if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  const prototype = window2.RTCPeerConnection.prototype;
  const origCreateOffer = prototype.createOffer;
  const origCreateAnswer = prototype.createAnswer;
  const setLocalDescription = prototype.setLocalDescription;
  const setRemoteDescription = prototype.setRemoteDescription;
  const addIceCandidate = prototype.addIceCandidate;
  prototype.createOffer = function createOffer(successCallback, failureCallback) {
    const options = arguments.length >= 2 ? arguments[2] : arguments[0];
    const promise = origCreateOffer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
    const options = arguments.length >= 2 ? arguments[2] : arguments[0];
    const promise = origCreateAnswer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  let withCallback = function(description2, successCallback, failureCallback) {
    const promise = setLocalDescription.apply(this, [description2]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setLocalDescription = withCallback;
  withCallback = function(description2, successCallback, failureCallback) {
    const promise = setRemoteDescription.apply(this, [description2]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setRemoteDescription = withCallback;
  withCallback = function(candidate, successCallback, failureCallback) {
    const promise = addIceCandidate.apply(this, [candidate]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.addIceCandidate = withCallback;
}
function shimGetUserMedia(window2) {
  const navigator2 = window2 && window2.navigator;
  if (navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
    const mediaDevices = navigator2.mediaDevices;
    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
    navigator2.mediaDevices.getUserMedia = (constraints) => {
      return _getUserMedia(shimConstraints(constraints));
    };
  }
  if (!navigator2.getUserMedia && navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
    navigator2.getUserMedia = function getUserMedia2(constraints, cb, errcb) {
      navigator2.mediaDevices.getUserMedia(constraints).then(cb, errcb);
    }.bind(navigator2);
  }
}
function shimConstraints(constraints) {
  if (constraints && constraints.video !== void 0) {
    return Object.assign({}, constraints, {
      video: compactObject(constraints.video)
    });
  }
  return constraints;
}
function shimRTCIceServerUrls(window2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  const OrigPeerConnection = window2.RTCPeerConnection;
  window2.RTCPeerConnection = function RTCPeerConnection2(pcConfig, pcConstraints) {
    if (pcConfig && pcConfig.iceServers) {
      const newIceServers = [];
      for (let i2 = 0; i2 < pcConfig.iceServers.length; i2++) {
        let server = pcConfig.iceServers[i2];
        if (!server.hasOwnProperty("urls") && server.hasOwnProperty("url")) {
          deprecated("RTCIceServer.url", "RTCIceServer.urls");
          server = JSON.parse(JSON.stringify(server));
          server.urls = server.url;
          delete server.url;
          newIceServers.push(server);
        } else {
          newIceServers.push(pcConfig.iceServers[i2]);
        }
      }
      pcConfig.iceServers = newIceServers;
    }
    return new OrigPeerConnection(pcConfig, pcConstraints);
  };
  window2.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
  if ("generateCertificate" in OrigPeerConnection) {
    Object.defineProperty(window2.RTCPeerConnection, "generateCertificate", {
      get() {
        return OrigPeerConnection.generateCertificate;
      }
    });
  }
}
function shimTrackEventTransceiver(window2) {
  if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
    Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
      get() {
        return {
          receiver: this.receiver
        };
      }
    });
  }
}
function shimCreateOfferLegacy(window2) {
  const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
  window2.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
    if (offerOptions) {
      if (typeof offerOptions.offerToReceiveAudio !== "undefined") {
        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
      }
      const audioTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "audio");
      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
        if (audioTransceiver.direction === "sendrecv") {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection("sendonly");
          } else {
            audioTransceiver.direction = "sendonly";
          }
        } else if (audioTransceiver.direction === "recvonly") {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection("inactive");
          } else {
            audioTransceiver.direction = "inactive";
          }
        }
      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
        this.addTransceiver("audio", {
          direction: "recvonly"
        });
      }
      if (typeof offerOptions.offerToReceiveVideo !== "undefined") {
        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
      }
      const videoTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "video");
      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
        if (videoTransceiver.direction === "sendrecv") {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection("sendonly");
          } else {
            videoTransceiver.direction = "sendonly";
          }
        } else if (videoTransceiver.direction === "recvonly") {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection("inactive");
          } else {
            videoTransceiver.direction = "inactive";
          }
        }
      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
        this.addTransceiver("video", {
          direction: "recvonly"
        });
      }
    }
    return origCreateOffer.apply(this, arguments);
  };
}
function shimAudioContext(window2) {
  if (typeof window2 !== "object" || window2.AudioContext) {
    return;
  }
  window2.AudioContext = window2.webkitAudioContext;
}
var safariShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  shimAudioContext,
  shimCallbacksAPI,
  shimConstraints,
  shimCreateOfferLegacy,
  shimGetUserMedia,
  shimLocalStreamsAPI,
  shimRTCIceServerUrls,
  shimRemoteStreamsAPI,
  shimTrackEventTransceiver
});
var sdpExports = {};
var sdp$1 = {
  get exports() {
    return sdpExports;
  },
  set exports(v) {
    sdpExports = v;
  }
};
(function(module2) {
  const SDPUtils2 = {};
  SDPUtils2.generateIdentifier = function() {
    return Math.random().toString(36).substr(2, 10);
  };
  SDPUtils2.localCName = SDPUtils2.generateIdentifier();
  SDPUtils2.splitLines = function(blob) {
    return blob.trim().split("\n").map((line) => line.trim());
  };
  SDPUtils2.splitSections = function(blob) {
    const parts = blob.split("\nm=");
    return parts.map((part, index2) => (index2 > 0 ? "m=" + part : part).trim() + "\r\n");
  };
  SDPUtils2.getDescription = function(blob) {
    const sections = SDPUtils2.splitSections(blob);
    return sections && sections[0];
  };
  SDPUtils2.getMediaSections = function(blob) {
    const sections = SDPUtils2.splitSections(blob);
    sections.shift();
    return sections;
  };
  SDPUtils2.matchPrefix = function(blob, prefix) {
    return SDPUtils2.splitLines(blob).filter((line) => line.indexOf(prefix) === 0);
  };
  SDPUtils2.parseCandidate = function(line) {
    let parts;
    if (line.indexOf("a=candidate:") === 0) {
      parts = line.substring(12).split(" ");
    } else {
      parts = line.substring(10).split(" ");
    }
    const candidate = {
      foundation: parts[0],
      component: {
        1: "rtp",
        2: "rtcp"
      }[parts[1]] || parts[1],
      protocol: parts[2].toLowerCase(),
      priority: parseInt(parts[3], 10),
      ip: parts[4],
      address: parts[4],
      port: parseInt(parts[5], 10),
      type: parts[7]
    };
    for (let i2 = 8; i2 < parts.length; i2 += 2) {
      switch (parts[i2]) {
        case "raddr":
          candidate.relatedAddress = parts[i2 + 1];
          break;
        case "rport":
          candidate.relatedPort = parseInt(parts[i2 + 1], 10);
          break;
        case "tcptype":
          candidate.tcpType = parts[i2 + 1];
          break;
        case "ufrag":
          candidate.ufrag = parts[i2 + 1];
          candidate.usernameFragment = parts[i2 + 1];
          break;
        default:
          if (candidate[parts[i2]] === void 0) {
            candidate[parts[i2]] = parts[i2 + 1];
          }
          break;
      }
    }
    return candidate;
  };
  SDPUtils2.writeCandidate = function(candidate) {
    const sdp2 = [];
    sdp2.push(candidate.foundation);
    const component = candidate.component;
    if (component === "rtp") {
      sdp2.push(1);
    } else if (component === "rtcp") {
      sdp2.push(2);
    } else {
      sdp2.push(component);
    }
    sdp2.push(candidate.protocol.toUpperCase());
    sdp2.push(candidate.priority);
    sdp2.push(candidate.address || candidate.ip);
    sdp2.push(candidate.port);
    const type = candidate.type;
    sdp2.push("typ");
    sdp2.push(type);
    if (type !== "host" && candidate.relatedAddress && candidate.relatedPort) {
      sdp2.push("raddr");
      sdp2.push(candidate.relatedAddress);
      sdp2.push("rport");
      sdp2.push(candidate.relatedPort);
    }
    if (candidate.tcpType && candidate.protocol.toLowerCase() === "tcp") {
      sdp2.push("tcptype");
      sdp2.push(candidate.tcpType);
    }
    if (candidate.usernameFragment || candidate.ufrag) {
      sdp2.push("ufrag");
      sdp2.push(candidate.usernameFragment || candidate.ufrag);
    }
    return "candidate:" + sdp2.join(" ");
  };
  SDPUtils2.parseIceOptions = function(line) {
    return line.substr(14).split(" ");
  };
  SDPUtils2.parseRtpMap = function(line) {
    let parts = line.substr(9).split(" ");
    const parsed2 = {
      payloadType: parseInt(parts.shift(), 10)
    };
    parts = parts[0].split("/");
    parsed2.name = parts[0];
    parsed2.clockRate = parseInt(parts[1], 10);
    parsed2.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
    parsed2.numChannels = parsed2.channels;
    return parsed2;
  };
  SDPUtils2.writeRtpMap = function(codec) {
    let pt = codec.payloadType;
    if (codec.preferredPayloadType !== void 0) {
      pt = codec.preferredPayloadType;
    }
    const channels = codec.channels || codec.numChannels || 1;
    return "a=rtpmap:" + pt + " " + codec.name + "/" + codec.clockRate + (channels !== 1 ? "/" + channels : "") + "\r\n";
  };
  SDPUtils2.parseExtmap = function(line) {
    const parts = line.substr(9).split(" ");
    return {
      id: parseInt(parts[0], 10),
      direction: parts[0].indexOf("/") > 0 ? parts[0].split("/")[1] : "sendrecv",
      uri: parts[1]
    };
  };
  SDPUtils2.writeExtmap = function(headerExtension) {
    return "a=extmap:" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== "sendrecv" ? "/" + headerExtension.direction : "") + " " + headerExtension.uri + "\r\n";
  };
  SDPUtils2.parseFmtp = function(line) {
    const parsed2 = {};
    let kv;
    const parts = line.substr(line.indexOf(" ") + 1).split(";");
    for (let j = 0; j < parts.length; j++) {
      kv = parts[j].trim().split("=");
      parsed2[kv[0].trim()] = kv[1];
    }
    return parsed2;
  };
  SDPUtils2.writeFmtp = function(codec) {
    let line = "";
    let pt = codec.payloadType;
    if (codec.preferredPayloadType !== void 0) {
      pt = codec.preferredPayloadType;
    }
    if (codec.parameters && Object.keys(codec.parameters).length) {
      const params = [];
      Object.keys(codec.parameters).forEach((param) => {
        if (codec.parameters[param] !== void 0) {
          params.push(param + "=" + codec.parameters[param]);
        } else {
          params.push(param);
        }
      });
      line += "a=fmtp:" + pt + " " + params.join(";") + "\r\n";
    }
    return line;
  };
  SDPUtils2.parseRtcpFb = function(line) {
    const parts = line.substr(line.indexOf(" ") + 1).split(" ");
    return {
      type: parts.shift(),
      parameter: parts.join(" ")
    };
  };
  SDPUtils2.writeRtcpFb = function(codec) {
    let lines = "";
    let pt = codec.payloadType;
    if (codec.preferredPayloadType !== void 0) {
      pt = codec.preferredPayloadType;
    }
    if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
      codec.rtcpFeedback.forEach((fb) => {
        lines += "a=rtcp-fb:" + pt + " " + fb.type + (fb.parameter && fb.parameter.length ? " " + fb.parameter : "") + "\r\n";
      });
    }
    return lines;
  };
  SDPUtils2.parseSsrcMedia = function(line) {
    const sp = line.indexOf(" ");
    const parts = {
      ssrc: parseInt(line.substr(7, sp - 7), 10)
    };
    const colon = line.indexOf(":", sp);
    if (colon > -1) {
      parts.attribute = line.substr(sp + 1, colon - sp - 1);
      parts.value = line.substr(colon + 1);
    } else {
      parts.attribute = line.substr(sp + 1);
    }
    return parts;
  };
  SDPUtils2.parseSsrcGroup = function(line) {
    const parts = line.substr(13).split(" ");
    return {
      semantics: parts.shift(),
      ssrcs: parts.map((ssrc) => parseInt(ssrc, 10))
    };
  };
  SDPUtils2.getMid = function(mediaSection) {
    const mid = SDPUtils2.matchPrefix(mediaSection, "a=mid:")[0];
    if (mid) {
      return mid.substr(6);
    }
  };
  SDPUtils2.parseFingerprint = function(line) {
    const parts = line.substr(14).split(" ");
    return {
      algorithm: parts[0].toLowerCase(),
      value: parts[1].toUpperCase()
    };
  };
  SDPUtils2.getDtlsParameters = function(mediaSection, sessionpart) {
    const lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=fingerprint:");
    return {
      role: "auto",
      fingerprints: lines.map(SDPUtils2.parseFingerprint)
    };
  };
  SDPUtils2.writeDtlsParameters = function(params, setupType) {
    let sdp2 = "a=setup:" + setupType + "\r\n";
    params.fingerprints.forEach((fp) => {
      sdp2 += "a=fingerprint:" + fp.algorithm + " " + fp.value + "\r\n";
    });
    return sdp2;
  };
  SDPUtils2.parseCryptoLine = function(line) {
    const parts = line.substr(9).split(" ");
    return {
      tag: parseInt(parts[0], 10),
      cryptoSuite: parts[1],
      keyParams: parts[2],
      sessionParams: parts.slice(3)
    };
  };
  SDPUtils2.writeCryptoLine = function(parameters) {
    return "a=crypto:" + parameters.tag + " " + parameters.cryptoSuite + " " + (typeof parameters.keyParams === "object" ? SDPUtils2.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? " " + parameters.sessionParams.join(" ") : "") + "\r\n";
  };
  SDPUtils2.parseCryptoKeyParams = function(keyParams) {
    if (keyParams.indexOf("inline:") !== 0) {
      return null;
    }
    const parts = keyParams.substr(7).split("|");
    return {
      keyMethod: "inline",
      keySalt: parts[0],
      lifeTime: parts[1],
      mkiValue: parts[2] ? parts[2].split(":")[0] : void 0,
      mkiLength: parts[2] ? parts[2].split(":")[1] : void 0
    };
  };
  SDPUtils2.writeCryptoKeyParams = function(keyParams) {
    return keyParams.keyMethod + ":" + keyParams.keySalt + (keyParams.lifeTime ? "|" + keyParams.lifeTime : "") + (keyParams.mkiValue && keyParams.mkiLength ? "|" + keyParams.mkiValue + ":" + keyParams.mkiLength : "");
  };
  SDPUtils2.getCryptoParameters = function(mediaSection, sessionpart) {
    const lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=crypto:");
    return lines.map(SDPUtils2.parseCryptoLine);
  };
  SDPUtils2.getIceParameters = function(mediaSection, sessionpart) {
    const ufrag = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=ice-ufrag:")[0];
    const pwd = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=ice-pwd:")[0];
    if (!(ufrag && pwd)) {
      return null;
    }
    return {
      usernameFragment: ufrag.substr(12),
      password: pwd.substr(10)
    };
  };
  SDPUtils2.writeIceParameters = function(params) {
    let sdp2 = "a=ice-ufrag:" + params.usernameFragment + "\r\na=ice-pwd:" + params.password + "\r\n";
    if (params.iceLite) {
      sdp2 += "a=ice-lite\r\n";
    }
    return sdp2;
  };
  SDPUtils2.parseRtpParameters = function(mediaSection) {
    const description2 = {
      codecs: [],
      headerExtensions: [],
      fecMechanisms: [],
      rtcp: []
    };
    const lines = SDPUtils2.splitLines(mediaSection);
    const mline = lines[0].split(" ");
    for (let i2 = 3; i2 < mline.length; i2++) {
      const pt = mline[i2];
      const rtpmapline = SDPUtils2.matchPrefix(mediaSection, "a=rtpmap:" + pt + " ")[0];
      if (rtpmapline) {
        const codec = SDPUtils2.parseRtpMap(rtpmapline);
        const fmtps = SDPUtils2.matchPrefix(mediaSection, "a=fmtp:" + pt + " ");
        codec.parameters = fmtps.length ? SDPUtils2.parseFmtp(fmtps[0]) : {};
        codec.rtcpFeedback = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-fb:" + pt + " ").map(SDPUtils2.parseRtcpFb);
        description2.codecs.push(codec);
        switch (codec.name.toUpperCase()) {
          case "RED":
          case "ULPFEC":
            description2.fecMechanisms.push(codec.name.toUpperCase());
            break;
        }
      }
    }
    SDPUtils2.matchPrefix(mediaSection, "a=extmap:").forEach((line) => {
      description2.headerExtensions.push(SDPUtils2.parseExtmap(line));
    });
    return description2;
  };
  SDPUtils2.writeRtpDescription = function(kind, caps) {
    let sdp2 = "";
    sdp2 += "m=" + kind + " ";
    sdp2 += caps.codecs.length > 0 ? "9" : "0";
    sdp2 += " UDP/TLS/RTP/SAVPF ";
    sdp2 += caps.codecs.map((codec) => {
      if (codec.preferredPayloadType !== void 0) {
        return codec.preferredPayloadType;
      }
      return codec.payloadType;
    }).join(" ") + "\r\n";
    sdp2 += "c=IN IP4 0.0.0.0\r\n";
    sdp2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n";
    caps.codecs.forEach((codec) => {
      sdp2 += SDPUtils2.writeRtpMap(codec);
      sdp2 += SDPUtils2.writeFmtp(codec);
      sdp2 += SDPUtils2.writeRtcpFb(codec);
    });
    let maxptime = 0;
    caps.codecs.forEach((codec) => {
      if (codec.maxptime > maxptime) {
        maxptime = codec.maxptime;
      }
    });
    if (maxptime > 0) {
      sdp2 += "a=maxptime:" + maxptime + "\r\n";
    }
    if (caps.headerExtensions) {
      caps.headerExtensions.forEach((extension) => {
        sdp2 += SDPUtils2.writeExtmap(extension);
      });
    }
    return sdp2;
  };
  SDPUtils2.parseRtpEncodingParameters = function(mediaSection) {
    const encodingParameters = [];
    const description2 = SDPUtils2.parseRtpParameters(mediaSection);
    const hasRed = description2.fecMechanisms.indexOf("RED") !== -1;
    const hasUlpfec = description2.fecMechanisms.indexOf("ULPFEC") !== -1;
    const ssrcs = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((parts) => parts.attribute === "cname");
    const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
    let secondarySsrc;
    const flows = SDPUtils2.matchPrefix(mediaSection, "a=ssrc-group:FID").map((line) => {
      const parts = line.substr(17).split(" ");
      return parts.map((part) => parseInt(part, 10));
    });
    if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
      secondarySsrc = flows[0][1];
    }
    description2.codecs.forEach((codec) => {
      if (codec.name.toUpperCase() === "RTX" && codec.parameters.apt) {
        let encParam = {
          ssrc: primarySsrc,
          codecPayloadType: parseInt(codec.parameters.apt, 10)
        };
        if (primarySsrc && secondarySsrc) {
          encParam.rtx = {
            ssrc: secondarySsrc
          };
        }
        encodingParameters.push(encParam);
        if (hasRed) {
          encParam = JSON.parse(JSON.stringify(encParam));
          encParam.fec = {
            ssrc: primarySsrc,
            mechanism: hasUlpfec ? "red+ulpfec" : "red"
          };
          encodingParameters.push(encParam);
        }
      }
    });
    if (encodingParameters.length === 0 && primarySsrc) {
      encodingParameters.push({
        ssrc: primarySsrc
      });
    }
    let bandwidth = SDPUtils2.matchPrefix(mediaSection, "b=");
    if (bandwidth.length) {
      if (bandwidth[0].indexOf("b=TIAS:") === 0) {
        bandwidth = parseInt(bandwidth[0].substr(7), 10);
      } else if (bandwidth[0].indexOf("b=AS:") === 0) {
        bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1e3 * 0.95 - 50 * 40 * 8;
      } else {
        bandwidth = void 0;
      }
      encodingParameters.forEach((params) => {
        params.maxBitrate = bandwidth;
      });
    }
    return encodingParameters;
  };
  SDPUtils2.parseRtcpParameters = function(mediaSection) {
    const rtcpParameters = {};
    const remoteSsrc = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((obj) => obj.attribute === "cname")[0];
    if (remoteSsrc) {
      rtcpParameters.cname = remoteSsrc.value;
      rtcpParameters.ssrc = remoteSsrc.ssrc;
    }
    const rsize = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-rsize");
    rtcpParameters.reducedSize = rsize.length > 0;
    rtcpParameters.compound = rsize.length === 0;
    const mux = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-mux");
    rtcpParameters.mux = mux.length > 0;
    return rtcpParameters;
  };
  SDPUtils2.writeRtcpParameters = function(rtcpParameters) {
    let sdp2 = "";
    if (rtcpParameters.reducedSize) {
      sdp2 += "a=rtcp-rsize\r\n";
    }
    if (rtcpParameters.mux) {
      sdp2 += "a=rtcp-mux\r\n";
    }
    if (rtcpParameters.ssrc !== void 0 && rtcpParameters.cname) {
      sdp2 += "a=ssrc:" + rtcpParameters.ssrc + " cname:" + rtcpParameters.cname + "\r\n";
    }
    return sdp2;
  };
  SDPUtils2.parseMsid = function(mediaSection) {
    let parts;
    const spec = SDPUtils2.matchPrefix(mediaSection, "a=msid:");
    if (spec.length === 1) {
      parts = spec[0].substr(7).split(" ");
      return {
        stream: parts[0],
        track: parts[1]
      };
    }
    const planB = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((msidParts) => msidParts.attribute === "msid");
    if (planB.length > 0) {
      parts = planB[0].value.split(" ");
      return {
        stream: parts[0],
        track: parts[1]
      };
    }
  };
  SDPUtils2.parseSctpDescription = function(mediaSection) {
    const mline = SDPUtils2.parseMLine(mediaSection);
    const maxSizeLine = SDPUtils2.matchPrefix(mediaSection, "a=max-message-size:");
    let maxMessageSize;
    if (maxSizeLine.length > 0) {
      maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
    }
    if (isNaN(maxMessageSize)) {
      maxMessageSize = 65536;
    }
    const sctpPort = SDPUtils2.matchPrefix(mediaSection, "a=sctp-port:");
    if (sctpPort.length > 0) {
      return {
        port: parseInt(sctpPort[0].substr(12), 10),
        protocol: mline.fmt,
        maxMessageSize
      };
    }
    const sctpMapLines = SDPUtils2.matchPrefix(mediaSection, "a=sctpmap:");
    if (sctpMapLines.length > 0) {
      const parts = sctpMapLines[0].substr(10).split(" ");
      return {
        port: parseInt(parts[0], 10),
        protocol: parts[1],
        maxMessageSize
      };
    }
  };
  SDPUtils2.writeSctpDescription = function(media, sctp) {
    let output = [];
    if (media.protocol !== "DTLS/SCTP") {
      output = ["m=" + media.kind + " 9 " + media.protocol + " " + sctp.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + sctp.port + "\r\n"];
    } else {
      output = ["m=" + media.kind + " 9 " + media.protocol + " " + sctp.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + sctp.port + " " + sctp.protocol + " 65535\r\n"];
    }
    if (sctp.maxMessageSize !== void 0) {
      output.push("a=max-message-size:" + sctp.maxMessageSize + "\r\n");
    }
    return output.join("");
  };
  SDPUtils2.generateSessionId = function() {
    return Math.random().toString().substr(2, 21);
  };
  SDPUtils2.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
    let sessionId;
    const version2 = sessVer !== void 0 ? sessVer : 2;
    if (sessId) {
      sessionId = sessId;
    } else {
      sessionId = SDPUtils2.generateSessionId();
    }
    const user = sessUser || "thisisadapterortc";
    return "v=0\r\no=" + user + " " + sessionId + " " + version2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
  };
  SDPUtils2.getDirection = function(mediaSection, sessionpart) {
    const lines = SDPUtils2.splitLines(mediaSection);
    for (let i2 = 0; i2 < lines.length; i2++) {
      switch (lines[i2]) {
        case "a=sendrecv":
        case "a=sendonly":
        case "a=recvonly":
        case "a=inactive":
          return lines[i2].substr(2);
      }
    }
    if (sessionpart) {
      return SDPUtils2.getDirection(sessionpart);
    }
    return "sendrecv";
  };
  SDPUtils2.getKind = function(mediaSection) {
    const lines = SDPUtils2.splitLines(mediaSection);
    const mline = lines[0].split(" ");
    return mline[0].substr(2);
  };
  SDPUtils2.isRejected = function(mediaSection) {
    return mediaSection.split(" ", 2)[1] === "0";
  };
  SDPUtils2.parseMLine = function(mediaSection) {
    const lines = SDPUtils2.splitLines(mediaSection);
    const parts = lines[0].substr(2).split(" ");
    return {
      kind: parts[0],
      port: parseInt(parts[1], 10),
      protocol: parts[2],
      fmt: parts.slice(3).join(" ")
    };
  };
  SDPUtils2.parseOLine = function(mediaSection) {
    const line = SDPUtils2.matchPrefix(mediaSection, "o=")[0];
    const parts = line.substr(2).split(" ");
    return {
      username: parts[0],
      sessionId: parts[1],
      sessionVersion: parseInt(parts[2], 10),
      netType: parts[3],
      addressType: parts[4],
      address: parts[5]
    };
  };
  SDPUtils2.isValidSDP = function(blob) {
    if (typeof blob !== "string" || blob.length === 0) {
      return false;
    }
    const lines = SDPUtils2.splitLines(blob);
    for (let i2 = 0; i2 < lines.length; i2++) {
      if (lines[i2].length < 2 || lines[i2].charAt(1) !== "=") {
        return false;
      }
    }
    return true;
  };
  {
    module2.exports = SDPUtils2;
  }
})(sdp$1);
var SDPUtils = sdpExports;
var sdp = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: SDPUtils
}, [sdpExports]);
function shimRTCIceCandidate(window2) {
  if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "foundation" in window2.RTCIceCandidate.prototype) {
    return;
  }
  const NativeRTCIceCandidate = window2.RTCIceCandidate;
  window2.RTCIceCandidate = function RTCIceCandidate(args) {
    if (typeof args === "object" && args.candidate && args.candidate.indexOf("a=") === 0) {
      args = JSON.parse(JSON.stringify(args));
      args.candidate = args.candidate.substr(2);
    }
    if (args.candidate && args.candidate.length) {
      const nativeCandidate = new NativeRTCIceCandidate(args);
      const parsedCandidate = SDPUtils.parseCandidate(args.candidate);
      const augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate);
      augmentedCandidate.toJSON = function toJSON() {
        return {
          candidate: augmentedCandidate.candidate,
          sdpMid: augmentedCandidate.sdpMid,
          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
          usernameFragment: augmentedCandidate.usernameFragment
        };
      };
      return augmentedCandidate;
    }
    return new NativeRTCIceCandidate(args);
  };
  window2.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;
  wrapPeerConnectionEvent(window2, "icecandidate", (e2) => {
    if (e2.candidate) {
      Object.defineProperty(e2, "candidate", {
        value: new window2.RTCIceCandidate(e2.candidate),
        writable: "false"
      });
    }
    return e2;
  });
}
function shimMaxMessageSize(window2, browserDetails) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (!("sctp" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "sctp", {
      get() {
        return typeof this._sctp === "undefined" ? null : this._sctp;
      }
    });
  }
  const sctpInDescription = function(description2) {
    if (!description2 || !description2.sdp) {
      return false;
    }
    const sections = SDPUtils.splitSections(description2.sdp);
    sections.shift();
    return sections.some((mediaSection) => {
      const mLine = SDPUtils.parseMLine(mediaSection);
      return mLine && mLine.kind === "application" && mLine.protocol.indexOf("SCTP") !== -1;
    });
  };
  const getRemoteFirefoxVersion = function(description2) {
    const match = description2.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (match === null || match.length < 2) {
      return -1;
    }
    const version2 = parseInt(match[1], 10);
    return version2 !== version2 ? -1 : version2;
  };
  const getCanSendMaxMessageSize = function(remoteIsFirefox) {
    let canSendMaxMessageSize = 65536;
    if (browserDetails.browser === "firefox") {
      if (browserDetails.version < 57) {
        if (remoteIsFirefox === -1) {
          canSendMaxMessageSize = 16384;
        } else {
          canSendMaxMessageSize = 2147483637;
        }
      } else if (browserDetails.version < 60) {
        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
      } else {
        canSendMaxMessageSize = 2147483637;
      }
    }
    return canSendMaxMessageSize;
  };
  const getMaxMessageSize = function(description2, remoteIsFirefox) {
    let maxMessageSize = 65536;
    if (browserDetails.browser === "firefox" && browserDetails.version === 57) {
      maxMessageSize = 65535;
    }
    const match = SDPUtils.matchPrefix(description2.sdp, "a=max-message-size:");
    if (match.length > 0) {
      maxMessageSize = parseInt(match[0].substr(19), 10);
    } else if (browserDetails.browser === "firefox" && remoteIsFirefox !== -1) {
      maxMessageSize = 2147483637;
    }
    return maxMessageSize;
  };
  const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
  window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
    this._sctp = null;
    if (browserDetails.browser === "chrome" && browserDetails.version >= 76) {
      const {
        sdpSemantics
      } = this.getConfiguration();
      if (sdpSemantics === "plan-b") {
        Object.defineProperty(this, "sctp", {
          get() {
            return typeof this._sctp === "undefined" ? null : this._sctp;
          },
          enumerable: true,
          configurable: true
        });
      }
    }
    if (sctpInDescription(arguments[0])) {
      const isFirefox = getRemoteFirefoxVersion(arguments[0]);
      const canSendMMS = getCanSendMaxMessageSize(isFirefox);
      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);
      let maxMessageSize;
      if (canSendMMS === 0 && remoteMMS === 0) {
        maxMessageSize = Number.POSITIVE_INFINITY;
      } else if (canSendMMS === 0 || remoteMMS === 0) {
        maxMessageSize = Math.max(canSendMMS, remoteMMS);
      } else {
        maxMessageSize = Math.min(canSendMMS, remoteMMS);
      }
      const sctp = {};
      Object.defineProperty(sctp, "maxMessageSize", {
        get() {
          return maxMessageSize;
        }
      });
      this._sctp = sctp;
    }
    return origSetRemoteDescription.apply(this, arguments);
  };
}
function shimSendThrowTypeError(window2) {
  if (!(window2.RTCPeerConnection && "createDataChannel" in window2.RTCPeerConnection.prototype)) {
    return;
  }
  function wrapDcSend(dc, pc) {
    const origDataChannelSend = dc.send;
    dc.send = function send() {
      const data2 = arguments[0];
      const length2 = data2.length || data2.size || data2.byteLength;
      if (dc.readyState === "open" && pc.sctp && length2 > pc.sctp.maxMessageSize) {
        throw new TypeError("Message too large (can send a maximum of " + pc.sctp.maxMessageSize + " bytes)");
      }
      return origDataChannelSend.apply(dc, arguments);
    };
  }
  const origCreateDataChannel = window2.RTCPeerConnection.prototype.createDataChannel;
  window2.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
    const dataChannel = origCreateDataChannel.apply(this, arguments);
    wrapDcSend(dataChannel, this);
    return dataChannel;
  };
  wrapPeerConnectionEvent(window2, "datachannel", (e2) => {
    wrapDcSend(e2.channel, e2.target);
    return e2;
  });
}
function shimConnectionState(window2) {
  if (!window2.RTCPeerConnection || "connectionState" in window2.RTCPeerConnection.prototype) {
    return;
  }
  const proto = window2.RTCPeerConnection.prototype;
  Object.defineProperty(proto, "connectionState", {
    get() {
      return {
        completed: "connected",
        checking: "connecting"
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(proto, "onconnectionstatechange", {
    get() {
      return this._onconnectionstatechange || null;
    },
    set(cb) {
      if (this._onconnectionstatechange) {
        this.removeEventListener("connectionstatechange", this._onconnectionstatechange);
        delete this._onconnectionstatechange;
      }
      if (cb) {
        this.addEventListener("connectionstatechange", this._onconnectionstatechange = cb);
      }
    },
    enumerable: true,
    configurable: true
  });
  ["setLocalDescription", "setRemoteDescription"].forEach((method) => {
    const origMethod = proto[method];
    proto[method] = function() {
      if (!this._connectionstatechangepoly) {
        this._connectionstatechangepoly = (e2) => {
          const pc = e2.target;
          if (pc._lastConnectionState !== pc.connectionState) {
            pc._lastConnectionState = pc.connectionState;
            const newEvent = new Event("connectionstatechange", e2);
            pc.dispatchEvent(newEvent);
          }
          return e2;
        };
        this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly);
      }
      return origMethod.apply(this, arguments);
    };
  });
}
function removeExtmapAllowMixed(window2, browserDetails) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (browserDetails.browser === "chrome" && browserDetails.version >= 71) {
    return;
  }
  if (browserDetails.browser === "safari" && browserDetails.version >= 605) {
    return;
  }
  const nativeSRD = window2.RTCPeerConnection.prototype.setRemoteDescription;
  window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
    if (desc && desc.sdp && desc.sdp.indexOf("\na=extmap-allow-mixed") !== -1) {
      const sdp2 = desc.sdp.split("\n").filter((line) => {
        return line.trim() !== "a=extmap-allow-mixed";
      }).join("\n");
      if (window2.RTCSessionDescription && desc instanceof window2.RTCSessionDescription) {
        arguments[0] = new window2.RTCSessionDescription({
          type: desc.type,
          sdp: sdp2
        });
      } else {
        desc.sdp = sdp2;
      }
    }
    return nativeSRD.apply(this, arguments);
  };
}
function shimAddIceCandidateNullOrEmpty(window2, browserDetails) {
  if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeAddIceCandidate = window2.RTCPeerConnection.prototype.addIceCandidate;
  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
    return;
  }
  window2.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
    if (!arguments[0]) {
      if (arguments[1]) {
        arguments[1].apply(null);
      }
      return Promise.resolve();
    }
    if ((browserDetails.browser === "chrome" && browserDetails.version < 78 || browserDetails.browser === "firefox" && browserDetails.version < 68 || browserDetails.browser === "safari") && arguments[0] && arguments[0].candidate === "") {
      return Promise.resolve();
    }
    return nativeAddIceCandidate.apply(this, arguments);
  };
}
function shimParameterlessSetLocalDescription(window2, browserDetails) {
  if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
    return;
  }
  window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    let desc = arguments[0] || {};
    if (typeof desc !== "object" || desc.type && desc.sdp) {
      return nativeSetLocalDescription.apply(this, arguments);
    }
    desc = {
      type: desc.type,
      sdp: desc.sdp
    };
    if (!desc.type) {
      switch (this.signalingState) {
        case "stable":
        case "have-local-offer":
        case "have-remote-pranswer":
          desc.type = "offer";
          break;
        default:
          desc.type = "answer";
          break;
      }
    }
    if (desc.sdp || desc.type !== "offer" && desc.type !== "answer") {
      return nativeSetLocalDescription.apply(this, [desc]);
    }
    const func = desc.type === "offer" ? this.createOffer : this.createAnswer;
    return func.apply(this).then((d) => nativeSetLocalDescription.apply(this, [d]));
  };
}
var commonShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  removeExtmapAllowMixed,
  shimAddIceCandidateNullOrEmpty,
  shimConnectionState,
  shimMaxMessageSize,
  shimParameterlessSetLocalDescription,
  shimRTCIceCandidate,
  shimSendThrowTypeError
});
function adapterFactory() {
  let {
    window: window2
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    shimChrome: true,
    shimFirefox: true,
    shimSafari: true
  };
  const logging2 = log;
  const browserDetails = detectBrowser(window2);
  const adapter = {
    browserDetails,
    commonShim,
    extractVersion,
    disableLog,
    disableWarnings,
    sdp
  };
  switch (browserDetails.browser) {
    case "chrome":
      if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {
        logging2("Chrome shim is not included in this adapter release.");
        return adapter;
      }
      if (browserDetails.version === null) {
        logging2("Chrome shim can not determine version, not shimming.");
        return adapter;
      }
      logging2("adapter.js shimming chrome.");
      adapter.browserShim = chromeShim;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails);
      shimParameterlessSetLocalDescription(window2);
      shimGetUserMedia$2(window2, browserDetails);
      shimMediaStream(window2);
      shimPeerConnection$1(window2, browserDetails);
      shimOnTrack$1(window2);
      shimAddTrackRemoveTrack(window2, browserDetails);
      shimGetSendersWithDtmf(window2);
      shimGetStats(window2);
      shimSenderReceiverGetStats(window2);
      fixNegotiationNeeded(window2, browserDetails);
      shimRTCIceCandidate(window2);
      shimConnectionState(window2);
      shimMaxMessageSize(window2, browserDetails);
      shimSendThrowTypeError(window2);
      removeExtmapAllowMixed(window2, browserDetails);
      break;
    case "firefox":
      if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {
        logging2("Firefox shim is not included in this adapter release.");
        return adapter;
      }
      logging2("adapter.js shimming firefox.");
      adapter.browserShim = firefoxShim;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails);
      shimParameterlessSetLocalDescription(window2);
      shimGetUserMedia$1(window2, browserDetails);
      shimPeerConnection(window2, browserDetails);
      shimOnTrack(window2);
      shimRemoveStream(window2);
      shimSenderGetStats(window2);
      shimReceiverGetStats(window2);
      shimRTCDataChannel(window2);
      shimAddTransceiver(window2);
      shimGetParameters(window2);
      shimCreateOffer(window2);
      shimCreateAnswer(window2);
      shimRTCIceCandidate(window2);
      shimConnectionState(window2);
      shimMaxMessageSize(window2, browserDetails);
      shimSendThrowTypeError(window2);
      break;
    case "safari":
      if (!safariShim || !options.shimSafari) {
        logging2("Safari shim is not included in this adapter release.");
        return adapter;
      }
      logging2("adapter.js shimming safari.");
      adapter.browserShim = safariShim;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails);
      shimParameterlessSetLocalDescription(window2);
      shimRTCIceServerUrls(window2);
      shimCreateOfferLegacy(window2);
      shimCallbacksAPI(window2);
      shimLocalStreamsAPI(window2);
      shimRemoteStreamsAPI(window2);
      shimTrackEventTransceiver(window2);
      shimGetUserMedia(window2);
      shimAudioContext(window2);
      shimRTCIceCandidate(window2);
      shimMaxMessageSize(window2, browserDetails);
      shimSendThrowTypeError(window2);
      removeExtmapAllowMixed(window2, browserDetails);
      break;
    default:
      logging2("Unsupported browser!");
      break;
  }
  return adapter;
}
adapterFactory({
  window: typeof window === "undefined" ? void 0 : window
});
var SignalTarget;
(function(SignalTarget2) {
  SignalTarget2[SignalTarget2["PUBLISHER"] = 0] = "PUBLISHER";
  SignalTarget2[SignalTarget2["SUBSCRIBER"] = 1] = "SUBSCRIBER";
  SignalTarget2[SignalTarget2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SignalTarget || (SignalTarget = {}));
function signalTargetFromJSON(object) {
  switch (object) {
    case 0:
    case "PUBLISHER":
      return SignalTarget.PUBLISHER;
    case 1:
    case "SUBSCRIBER":
      return SignalTarget.SUBSCRIBER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SignalTarget.UNRECOGNIZED;
  }
}
function signalTargetToJSON(object) {
  switch (object) {
    case SignalTarget.PUBLISHER:
      return "PUBLISHER";
    case SignalTarget.SUBSCRIBER:
      return "SUBSCRIBER";
    case SignalTarget.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var StreamState;
(function(StreamState2) {
  StreamState2[StreamState2["ACTIVE"] = 0] = "ACTIVE";
  StreamState2[StreamState2["PAUSED"] = 1] = "PAUSED";
  StreamState2[StreamState2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(StreamState || (StreamState = {}));
function streamStateFromJSON(object) {
  switch (object) {
    case 0:
    case "ACTIVE":
      return StreamState.ACTIVE;
    case 1:
    case "PAUSED":
      return StreamState.PAUSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StreamState.UNRECOGNIZED;
  }
}
function streamStateToJSON(object) {
  switch (object) {
    case StreamState.ACTIVE:
      return "ACTIVE";
    case StreamState.PAUSED:
      return "PAUSED";
    case StreamState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var CandidateProtocol;
(function(CandidateProtocol2) {
  CandidateProtocol2[CandidateProtocol2["UDP"] = 0] = "UDP";
  CandidateProtocol2[CandidateProtocol2["TCP"] = 1] = "TCP";
  CandidateProtocol2[CandidateProtocol2["TLS"] = 2] = "TLS";
  CandidateProtocol2[CandidateProtocol2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CandidateProtocol || (CandidateProtocol = {}));
function candidateProtocolFromJSON(object) {
  switch (object) {
    case 0:
    case "UDP":
      return CandidateProtocol.UDP;
    case 1:
    case "TCP":
      return CandidateProtocol.TCP;
    case 2:
    case "TLS":
      return CandidateProtocol.TLS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CandidateProtocol.UNRECOGNIZED;
  }
}
function candidateProtocolToJSON(object) {
  switch (object) {
    case CandidateProtocol.UDP:
      return "UDP";
    case CandidateProtocol.TCP:
      return "TCP";
    case CandidateProtocol.TLS:
      return "TLS";
    case CandidateProtocol.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseSignalRequest() {
  return {
    message: void 0
  };
}
const SignalRequest = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    var _a2;
    switch ((_a2 = message.message) === null || _a2 === void 0 ? void 0 : _a2.$case) {
      case "offer":
        SessionDescription.encode(message.message.offer, writer2.uint32(10).fork()).ldelim();
        break;
      case "answer":
        SessionDescription.encode(message.message.answer, writer2.uint32(18).fork()).ldelim();
        break;
      case "trickle":
        TrickleRequest.encode(message.message.trickle, writer2.uint32(26).fork()).ldelim();
        break;
      case "addTrack":
        AddTrackRequest.encode(message.message.addTrack, writer2.uint32(34).fork()).ldelim();
        break;
      case "mute":
        MuteTrackRequest.encode(message.message.mute, writer2.uint32(42).fork()).ldelim();
        break;
      case "subscription":
        UpdateSubscription.encode(message.message.subscription, writer2.uint32(50).fork()).ldelim();
        break;
      case "trackSetting":
        UpdateTrackSettings.encode(message.message.trackSetting, writer2.uint32(58).fork()).ldelim();
        break;
      case "leave":
        LeaveRequest.encode(message.message.leave, writer2.uint32(66).fork()).ldelim();
        break;
      case "updateLayers":
        UpdateVideoLayers.encode(message.message.updateLayers, writer2.uint32(82).fork()).ldelim();
        break;
      case "subscriptionPermission":
        SubscriptionPermission.encode(message.message.subscriptionPermission, writer2.uint32(90).fork()).ldelim();
        break;
      case "syncState":
        SyncState.encode(message.message.syncState, writer2.uint32(98).fork()).ldelim();
        break;
      case "simulate":
        SimulateScenario.encode(message.message.simulate, writer2.uint32(106).fork()).ldelim();
        break;
      case "ping":
        writer2.uint32(112).int64(message.message.ping);
        break;
      case "updateMetadata":
        UpdateParticipantMetadata.encode(message.message.updateMetadata, writer2.uint32(122).fork()).ldelim();
        break;
      case "pingReq":
        Ping.encode(message.message.pingReq, writer2.uint32(130).fork()).ldelim();
        break;
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSignalRequest();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.message = {
            $case: "offer",
            offer: SessionDescription.decode(reader2, reader2.uint32())
          };
          break;
        case 2:
          message.message = {
            $case: "answer",
            answer: SessionDescription.decode(reader2, reader2.uint32())
          };
          break;
        case 3:
          message.message = {
            $case: "trickle",
            trickle: TrickleRequest.decode(reader2, reader2.uint32())
          };
          break;
        case 4:
          message.message = {
            $case: "addTrack",
            addTrack: AddTrackRequest.decode(reader2, reader2.uint32())
          };
          break;
        case 5:
          message.message = {
            $case: "mute",
            mute: MuteTrackRequest.decode(reader2, reader2.uint32())
          };
          break;
        case 6:
          message.message = {
            $case: "subscription",
            subscription: UpdateSubscription.decode(reader2, reader2.uint32())
          };
          break;
        case 7:
          message.message = {
            $case: "trackSetting",
            trackSetting: UpdateTrackSettings.decode(reader2, reader2.uint32())
          };
          break;
        case 8:
          message.message = {
            $case: "leave",
            leave: LeaveRequest.decode(reader2, reader2.uint32())
          };
          break;
        case 10:
          message.message = {
            $case: "updateLayers",
            updateLayers: UpdateVideoLayers.decode(reader2, reader2.uint32())
          };
          break;
        case 11:
          message.message = {
            $case: "subscriptionPermission",
            subscriptionPermission: SubscriptionPermission.decode(reader2, reader2.uint32())
          };
          break;
        case 12:
          message.message = {
            $case: "syncState",
            syncState: SyncState.decode(reader2, reader2.uint32())
          };
          break;
        case 13:
          message.message = {
            $case: "simulate",
            simulate: SimulateScenario.decode(reader2, reader2.uint32())
          };
          break;
        case 14:
          message.message = {
            $case: "ping",
            ping: longToNumber(reader2.int64())
          };
          break;
        case 15:
          message.message = {
            $case: "updateMetadata",
            updateMetadata: UpdateParticipantMetadata.decode(reader2, reader2.uint32())
          };
          break;
        case 16:
          message.message = {
            $case: "pingReq",
            pingReq: Ping.decode(reader2, reader2.uint32())
          };
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      message: isSet(object.offer) ? {
        $case: "offer",
        offer: SessionDescription.fromJSON(object.offer)
      } : isSet(object.answer) ? {
        $case: "answer",
        answer: SessionDescription.fromJSON(object.answer)
      } : isSet(object.trickle) ? {
        $case: "trickle",
        trickle: TrickleRequest.fromJSON(object.trickle)
      } : isSet(object.addTrack) ? {
        $case: "addTrack",
        addTrack: AddTrackRequest.fromJSON(object.addTrack)
      } : isSet(object.mute) ? {
        $case: "mute",
        mute: MuteTrackRequest.fromJSON(object.mute)
      } : isSet(object.subscription) ? {
        $case: "subscription",
        subscription: UpdateSubscription.fromJSON(object.subscription)
      } : isSet(object.trackSetting) ? {
        $case: "trackSetting",
        trackSetting: UpdateTrackSettings.fromJSON(object.trackSetting)
      } : isSet(object.leave) ? {
        $case: "leave",
        leave: LeaveRequest.fromJSON(object.leave)
      } : isSet(object.updateLayers) ? {
        $case: "updateLayers",
        updateLayers: UpdateVideoLayers.fromJSON(object.updateLayers)
      } : isSet(object.subscriptionPermission) ? {
        $case: "subscriptionPermission",
        subscriptionPermission: SubscriptionPermission.fromJSON(object.subscriptionPermission)
      } : isSet(object.syncState) ? {
        $case: "syncState",
        syncState: SyncState.fromJSON(object.syncState)
      } : isSet(object.simulate) ? {
        $case: "simulate",
        simulate: SimulateScenario.fromJSON(object.simulate)
      } : isSet(object.ping) ? {
        $case: "ping",
        ping: Number(object.ping)
      } : isSet(object.updateMetadata) ? {
        $case: "updateMetadata",
        updateMetadata: UpdateParticipantMetadata.fromJSON(object.updateMetadata)
      } : isSet(object.pingReq) ? {
        $case: "pingReq",
        pingReq: Ping.fromJSON(object.pingReq)
      } : void 0
    };
  },
  toJSON(message) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19;
    const obj = {};
    ((_a2 = message.message) === null || _a2 === void 0 ? void 0 : _a2.$case) === "offer" && (obj.offer = ((_b = message.message) === null || _b === void 0 ? void 0 : _b.offer) ? SessionDescription.toJSON((_c = message.message) === null || _c === void 0 ? void 0 : _c.offer) : void 0);
    ((_d = message.message) === null || _d === void 0 ? void 0 : _d.$case) === "answer" && (obj.answer = ((_e = message.message) === null || _e === void 0 ? void 0 : _e.answer) ? SessionDescription.toJSON((_f = message.message) === null || _f === void 0 ? void 0 : _f.answer) : void 0);
    ((_g = message.message) === null || _g === void 0 ? void 0 : _g.$case) === "trickle" && (obj.trickle = ((_h = message.message) === null || _h === void 0 ? void 0 : _h.trickle) ? TrickleRequest.toJSON((_j = message.message) === null || _j === void 0 ? void 0 : _j.trickle) : void 0);
    ((_k = message.message) === null || _k === void 0 ? void 0 : _k.$case) === "addTrack" && (obj.addTrack = ((_l = message.message) === null || _l === void 0 ? void 0 : _l.addTrack) ? AddTrackRequest.toJSON((_m = message.message) === null || _m === void 0 ? void 0 : _m.addTrack) : void 0);
    ((_o = message.message) === null || _o === void 0 ? void 0 : _o.$case) === "mute" && (obj.mute = ((_p = message.message) === null || _p === void 0 ? void 0 : _p.mute) ? MuteTrackRequest.toJSON((_q = message.message) === null || _q === void 0 ? void 0 : _q.mute) : void 0);
    ((_r = message.message) === null || _r === void 0 ? void 0 : _r.$case) === "subscription" && (obj.subscription = ((_s = message.message) === null || _s === void 0 ? void 0 : _s.subscription) ? UpdateSubscription.toJSON((_t = message.message) === null || _t === void 0 ? void 0 : _t.subscription) : void 0);
    ((_u = message.message) === null || _u === void 0 ? void 0 : _u.$case) === "trackSetting" && (obj.trackSetting = ((_v = message.message) === null || _v === void 0 ? void 0 : _v.trackSetting) ? UpdateTrackSettings.toJSON((_w = message.message) === null || _w === void 0 ? void 0 : _w.trackSetting) : void 0);
    ((_x = message.message) === null || _x === void 0 ? void 0 : _x.$case) === "leave" && (obj.leave = ((_y = message.message) === null || _y === void 0 ? void 0 : _y.leave) ? LeaveRequest.toJSON((_z = message.message) === null || _z === void 0 ? void 0 : _z.leave) : void 0);
    ((_0 = message.message) === null || _0 === void 0 ? void 0 : _0.$case) === "updateLayers" && (obj.updateLayers = ((_1 = message.message) === null || _1 === void 0 ? void 0 : _1.updateLayers) ? UpdateVideoLayers.toJSON((_2 = message.message) === null || _2 === void 0 ? void 0 : _2.updateLayers) : void 0);
    ((_3 = message.message) === null || _3 === void 0 ? void 0 : _3.$case) === "subscriptionPermission" && (obj.subscriptionPermission = ((_4 = message.message) === null || _4 === void 0 ? void 0 : _4.subscriptionPermission) ? SubscriptionPermission.toJSON((_5 = message.message) === null || _5 === void 0 ? void 0 : _5.subscriptionPermission) : void 0);
    ((_6 = message.message) === null || _6 === void 0 ? void 0 : _6.$case) === "syncState" && (obj.syncState = ((_7 = message.message) === null || _7 === void 0 ? void 0 : _7.syncState) ? SyncState.toJSON((_8 = message.message) === null || _8 === void 0 ? void 0 : _8.syncState) : void 0);
    ((_9 = message.message) === null || _9 === void 0 ? void 0 : _9.$case) === "simulate" && (obj.simulate = ((_10 = message.message) === null || _10 === void 0 ? void 0 : _10.simulate) ? SimulateScenario.toJSON((_11 = message.message) === null || _11 === void 0 ? void 0 : _11.simulate) : void 0);
    ((_12 = message.message) === null || _12 === void 0 ? void 0 : _12.$case) === "ping" && (obj.ping = Math.round((_13 = message.message) === null || _13 === void 0 ? void 0 : _13.ping));
    ((_14 = message.message) === null || _14 === void 0 ? void 0 : _14.$case) === "updateMetadata" && (obj.updateMetadata = ((_15 = message.message) === null || _15 === void 0 ? void 0 : _15.updateMetadata) ? UpdateParticipantMetadata.toJSON((_16 = message.message) === null || _16 === void 0 ? void 0 : _16.updateMetadata) : void 0);
    ((_17 = message.message) === null || _17 === void 0 ? void 0 : _17.$case) === "pingReq" && (obj.pingReq = ((_18 = message.message) === null || _18 === void 0 ? void 0 : _18.pingReq) ? Ping.toJSON((_19 = message.message) === null || _19 === void 0 ? void 0 : _19.pingReq) : void 0);
    return obj;
  },
  create(base) {
    return SignalRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20;
    const message = createBaseSignalRequest();
    if (((_a2 = object.message) === null || _a2 === void 0 ? void 0 : _a2.$case) === "offer" && ((_b = object.message) === null || _b === void 0 ? void 0 : _b.offer) !== void 0 && ((_c = object.message) === null || _c === void 0 ? void 0 : _c.offer) !== null) {
      message.message = {
        $case: "offer",
        offer: SessionDescription.fromPartial(object.message.offer)
      };
    }
    if (((_d = object.message) === null || _d === void 0 ? void 0 : _d.$case) === "answer" && ((_e = object.message) === null || _e === void 0 ? void 0 : _e.answer) !== void 0 && ((_f = object.message) === null || _f === void 0 ? void 0 : _f.answer) !== null) {
      message.message = {
        $case: "answer",
        answer: SessionDescription.fromPartial(object.message.answer)
      };
    }
    if (((_g = object.message) === null || _g === void 0 ? void 0 : _g.$case) === "trickle" && ((_h = object.message) === null || _h === void 0 ? void 0 : _h.trickle) !== void 0 && ((_j = object.message) === null || _j === void 0 ? void 0 : _j.trickle) !== null) {
      message.message = {
        $case: "trickle",
        trickle: TrickleRequest.fromPartial(object.message.trickle)
      };
    }
    if (((_k = object.message) === null || _k === void 0 ? void 0 : _k.$case) === "addTrack" && ((_l = object.message) === null || _l === void 0 ? void 0 : _l.addTrack) !== void 0 && ((_m = object.message) === null || _m === void 0 ? void 0 : _m.addTrack) !== null) {
      message.message = {
        $case: "addTrack",
        addTrack: AddTrackRequest.fromPartial(object.message.addTrack)
      };
    }
    if (((_o = object.message) === null || _o === void 0 ? void 0 : _o.$case) === "mute" && ((_p = object.message) === null || _p === void 0 ? void 0 : _p.mute) !== void 0 && ((_q = object.message) === null || _q === void 0 ? void 0 : _q.mute) !== null) {
      message.message = {
        $case: "mute",
        mute: MuteTrackRequest.fromPartial(object.message.mute)
      };
    }
    if (((_r = object.message) === null || _r === void 0 ? void 0 : _r.$case) === "subscription" && ((_s = object.message) === null || _s === void 0 ? void 0 : _s.subscription) !== void 0 && ((_t = object.message) === null || _t === void 0 ? void 0 : _t.subscription) !== null) {
      message.message = {
        $case: "subscription",
        subscription: UpdateSubscription.fromPartial(object.message.subscription)
      };
    }
    if (((_u = object.message) === null || _u === void 0 ? void 0 : _u.$case) === "trackSetting" && ((_v = object.message) === null || _v === void 0 ? void 0 : _v.trackSetting) !== void 0 && ((_w = object.message) === null || _w === void 0 ? void 0 : _w.trackSetting) !== null) {
      message.message = {
        $case: "trackSetting",
        trackSetting: UpdateTrackSettings.fromPartial(object.message.trackSetting)
      };
    }
    if (((_x = object.message) === null || _x === void 0 ? void 0 : _x.$case) === "leave" && ((_y = object.message) === null || _y === void 0 ? void 0 : _y.leave) !== void 0 && ((_z = object.message) === null || _z === void 0 ? void 0 : _z.leave) !== null) {
      message.message = {
        $case: "leave",
        leave: LeaveRequest.fromPartial(object.message.leave)
      };
    }
    if (((_0 = object.message) === null || _0 === void 0 ? void 0 : _0.$case) === "updateLayers" && ((_1 = object.message) === null || _1 === void 0 ? void 0 : _1.updateLayers) !== void 0 && ((_2 = object.message) === null || _2 === void 0 ? void 0 : _2.updateLayers) !== null) {
      message.message = {
        $case: "updateLayers",
        updateLayers: UpdateVideoLayers.fromPartial(object.message.updateLayers)
      };
    }
    if (((_3 = object.message) === null || _3 === void 0 ? void 0 : _3.$case) === "subscriptionPermission" && ((_4 = object.message) === null || _4 === void 0 ? void 0 : _4.subscriptionPermission) !== void 0 && ((_5 = object.message) === null || _5 === void 0 ? void 0 : _5.subscriptionPermission) !== null) {
      message.message = {
        $case: "subscriptionPermission",
        subscriptionPermission: SubscriptionPermission.fromPartial(object.message.subscriptionPermission)
      };
    }
    if (((_6 = object.message) === null || _6 === void 0 ? void 0 : _6.$case) === "syncState" && ((_7 = object.message) === null || _7 === void 0 ? void 0 : _7.syncState) !== void 0 && ((_8 = object.message) === null || _8 === void 0 ? void 0 : _8.syncState) !== null) {
      message.message = {
        $case: "syncState",
        syncState: SyncState.fromPartial(object.message.syncState)
      };
    }
    if (((_9 = object.message) === null || _9 === void 0 ? void 0 : _9.$case) === "simulate" && ((_10 = object.message) === null || _10 === void 0 ? void 0 : _10.simulate) !== void 0 && ((_11 = object.message) === null || _11 === void 0 ? void 0 : _11.simulate) !== null) {
      message.message = {
        $case: "simulate",
        simulate: SimulateScenario.fromPartial(object.message.simulate)
      };
    }
    if (((_12 = object.message) === null || _12 === void 0 ? void 0 : _12.$case) === "ping" && ((_13 = object.message) === null || _13 === void 0 ? void 0 : _13.ping) !== void 0 && ((_14 = object.message) === null || _14 === void 0 ? void 0 : _14.ping) !== null) {
      message.message = {
        $case: "ping",
        ping: object.message.ping
      };
    }
    if (((_15 = object.message) === null || _15 === void 0 ? void 0 : _15.$case) === "updateMetadata" && ((_16 = object.message) === null || _16 === void 0 ? void 0 : _16.updateMetadata) !== void 0 && ((_17 = object.message) === null || _17 === void 0 ? void 0 : _17.updateMetadata) !== null) {
      message.message = {
        $case: "updateMetadata",
        updateMetadata: UpdateParticipantMetadata.fromPartial(object.message.updateMetadata)
      };
    }
    if (((_18 = object.message) === null || _18 === void 0 ? void 0 : _18.$case) === "pingReq" && ((_19 = object.message) === null || _19 === void 0 ? void 0 : _19.pingReq) !== void 0 && ((_20 = object.message) === null || _20 === void 0 ? void 0 : _20.pingReq) !== null) {
      message.message = {
        $case: "pingReq",
        pingReq: Ping.fromPartial(object.message.pingReq)
      };
    }
    return message;
  }
};
function createBaseSignalResponse() {
  return {
    message: void 0
  };
}
const SignalResponse = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    var _a2;
    switch ((_a2 = message.message) === null || _a2 === void 0 ? void 0 : _a2.$case) {
      case "join":
        JoinResponse.encode(message.message.join, writer2.uint32(10).fork()).ldelim();
        break;
      case "answer":
        SessionDescription.encode(message.message.answer, writer2.uint32(18).fork()).ldelim();
        break;
      case "offer":
        SessionDescription.encode(message.message.offer, writer2.uint32(26).fork()).ldelim();
        break;
      case "trickle":
        TrickleRequest.encode(message.message.trickle, writer2.uint32(34).fork()).ldelim();
        break;
      case "update":
        ParticipantUpdate.encode(message.message.update, writer2.uint32(42).fork()).ldelim();
        break;
      case "trackPublished":
        TrackPublishedResponse.encode(message.message.trackPublished, writer2.uint32(50).fork()).ldelim();
        break;
      case "leave":
        LeaveRequest.encode(message.message.leave, writer2.uint32(66).fork()).ldelim();
        break;
      case "mute":
        MuteTrackRequest.encode(message.message.mute, writer2.uint32(74).fork()).ldelim();
        break;
      case "speakersChanged":
        SpeakersChanged.encode(message.message.speakersChanged, writer2.uint32(82).fork()).ldelim();
        break;
      case "roomUpdate":
        RoomUpdate.encode(message.message.roomUpdate, writer2.uint32(90).fork()).ldelim();
        break;
      case "connectionQuality":
        ConnectionQualityUpdate.encode(message.message.connectionQuality, writer2.uint32(98).fork()).ldelim();
        break;
      case "streamStateUpdate":
        StreamStateUpdate.encode(message.message.streamStateUpdate, writer2.uint32(106).fork()).ldelim();
        break;
      case "subscribedQualityUpdate":
        SubscribedQualityUpdate.encode(message.message.subscribedQualityUpdate, writer2.uint32(114).fork()).ldelim();
        break;
      case "subscriptionPermissionUpdate":
        SubscriptionPermissionUpdate.encode(message.message.subscriptionPermissionUpdate, writer2.uint32(122).fork()).ldelim();
        break;
      case "refreshToken":
        writer2.uint32(130).string(message.message.refreshToken);
        break;
      case "trackUnpublished":
        TrackUnpublishedResponse.encode(message.message.trackUnpublished, writer2.uint32(138).fork()).ldelim();
        break;
      case "pong":
        writer2.uint32(144).int64(message.message.pong);
        break;
      case "reconnect":
        ReconnectResponse.encode(message.message.reconnect, writer2.uint32(154).fork()).ldelim();
        break;
      case "pongResp":
        Pong.encode(message.message.pongResp, writer2.uint32(162).fork()).ldelim();
        break;
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSignalResponse();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.message = {
            $case: "join",
            join: JoinResponse.decode(reader2, reader2.uint32())
          };
          break;
        case 2:
          message.message = {
            $case: "answer",
            answer: SessionDescription.decode(reader2, reader2.uint32())
          };
          break;
        case 3:
          message.message = {
            $case: "offer",
            offer: SessionDescription.decode(reader2, reader2.uint32())
          };
          break;
        case 4:
          message.message = {
            $case: "trickle",
            trickle: TrickleRequest.decode(reader2, reader2.uint32())
          };
          break;
        case 5:
          message.message = {
            $case: "update",
            update: ParticipantUpdate.decode(reader2, reader2.uint32())
          };
          break;
        case 6:
          message.message = {
            $case: "trackPublished",
            trackPublished: TrackPublishedResponse.decode(reader2, reader2.uint32())
          };
          break;
        case 8:
          message.message = {
            $case: "leave",
            leave: LeaveRequest.decode(reader2, reader2.uint32())
          };
          break;
        case 9:
          message.message = {
            $case: "mute",
            mute: MuteTrackRequest.decode(reader2, reader2.uint32())
          };
          break;
        case 10:
          message.message = {
            $case: "speakersChanged",
            speakersChanged: SpeakersChanged.decode(reader2, reader2.uint32())
          };
          break;
        case 11:
          message.message = {
            $case: "roomUpdate",
            roomUpdate: RoomUpdate.decode(reader2, reader2.uint32())
          };
          break;
        case 12:
          message.message = {
            $case: "connectionQuality",
            connectionQuality: ConnectionQualityUpdate.decode(reader2, reader2.uint32())
          };
          break;
        case 13:
          message.message = {
            $case: "streamStateUpdate",
            streamStateUpdate: StreamStateUpdate.decode(reader2, reader2.uint32())
          };
          break;
        case 14:
          message.message = {
            $case: "subscribedQualityUpdate",
            subscribedQualityUpdate: SubscribedQualityUpdate.decode(reader2, reader2.uint32())
          };
          break;
        case 15:
          message.message = {
            $case: "subscriptionPermissionUpdate",
            subscriptionPermissionUpdate: SubscriptionPermissionUpdate.decode(reader2, reader2.uint32())
          };
          break;
        case 16:
          message.message = {
            $case: "refreshToken",
            refreshToken: reader2.string()
          };
          break;
        case 17:
          message.message = {
            $case: "trackUnpublished",
            trackUnpublished: TrackUnpublishedResponse.decode(reader2, reader2.uint32())
          };
          break;
        case 18:
          message.message = {
            $case: "pong",
            pong: longToNumber(reader2.int64())
          };
          break;
        case 19:
          message.message = {
            $case: "reconnect",
            reconnect: ReconnectResponse.decode(reader2, reader2.uint32())
          };
          break;
        case 20:
          message.message = {
            $case: "pongResp",
            pongResp: Pong.decode(reader2, reader2.uint32())
          };
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      message: isSet(object.join) ? {
        $case: "join",
        join: JoinResponse.fromJSON(object.join)
      } : isSet(object.answer) ? {
        $case: "answer",
        answer: SessionDescription.fromJSON(object.answer)
      } : isSet(object.offer) ? {
        $case: "offer",
        offer: SessionDescription.fromJSON(object.offer)
      } : isSet(object.trickle) ? {
        $case: "trickle",
        trickle: TrickleRequest.fromJSON(object.trickle)
      } : isSet(object.update) ? {
        $case: "update",
        update: ParticipantUpdate.fromJSON(object.update)
      } : isSet(object.trackPublished) ? {
        $case: "trackPublished",
        trackPublished: TrackPublishedResponse.fromJSON(object.trackPublished)
      } : isSet(object.leave) ? {
        $case: "leave",
        leave: LeaveRequest.fromJSON(object.leave)
      } : isSet(object.mute) ? {
        $case: "mute",
        mute: MuteTrackRequest.fromJSON(object.mute)
      } : isSet(object.speakersChanged) ? {
        $case: "speakersChanged",
        speakersChanged: SpeakersChanged.fromJSON(object.speakersChanged)
      } : isSet(object.roomUpdate) ? {
        $case: "roomUpdate",
        roomUpdate: RoomUpdate.fromJSON(object.roomUpdate)
      } : isSet(object.connectionQuality) ? {
        $case: "connectionQuality",
        connectionQuality: ConnectionQualityUpdate.fromJSON(object.connectionQuality)
      } : isSet(object.streamStateUpdate) ? {
        $case: "streamStateUpdate",
        streamStateUpdate: StreamStateUpdate.fromJSON(object.streamStateUpdate)
      } : isSet(object.subscribedQualityUpdate) ? {
        $case: "subscribedQualityUpdate",
        subscribedQualityUpdate: SubscribedQualityUpdate.fromJSON(object.subscribedQualityUpdate)
      } : isSet(object.subscriptionPermissionUpdate) ? {
        $case: "subscriptionPermissionUpdate",
        subscriptionPermissionUpdate: SubscriptionPermissionUpdate.fromJSON(object.subscriptionPermissionUpdate)
      } : isSet(object.refreshToken) ? {
        $case: "refreshToken",
        refreshToken: String(object.refreshToken)
      } : isSet(object.trackUnpublished) ? {
        $case: "trackUnpublished",
        trackUnpublished: TrackUnpublishedResponse.fromJSON(object.trackUnpublished)
      } : isSet(object.pong) ? {
        $case: "pong",
        pong: Number(object.pong)
      } : isSet(object.reconnect) ? {
        $case: "reconnect",
        reconnect: ReconnectResponse.fromJSON(object.reconnect)
      } : isSet(object.pongResp) ? {
        $case: "pongResp",
        pongResp: Pong.fromJSON(object.pongResp)
      } : void 0
    };
  },
  toJSON(message) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30;
    const obj = {};
    ((_a2 = message.message) === null || _a2 === void 0 ? void 0 : _a2.$case) === "join" && (obj.join = ((_b = message.message) === null || _b === void 0 ? void 0 : _b.join) ? JoinResponse.toJSON((_c = message.message) === null || _c === void 0 ? void 0 : _c.join) : void 0);
    ((_d = message.message) === null || _d === void 0 ? void 0 : _d.$case) === "answer" && (obj.answer = ((_e = message.message) === null || _e === void 0 ? void 0 : _e.answer) ? SessionDescription.toJSON((_f = message.message) === null || _f === void 0 ? void 0 : _f.answer) : void 0);
    ((_g = message.message) === null || _g === void 0 ? void 0 : _g.$case) === "offer" && (obj.offer = ((_h = message.message) === null || _h === void 0 ? void 0 : _h.offer) ? SessionDescription.toJSON((_j = message.message) === null || _j === void 0 ? void 0 : _j.offer) : void 0);
    ((_k = message.message) === null || _k === void 0 ? void 0 : _k.$case) === "trickle" && (obj.trickle = ((_l = message.message) === null || _l === void 0 ? void 0 : _l.trickle) ? TrickleRequest.toJSON((_m = message.message) === null || _m === void 0 ? void 0 : _m.trickle) : void 0);
    ((_o = message.message) === null || _o === void 0 ? void 0 : _o.$case) === "update" && (obj.update = ((_p = message.message) === null || _p === void 0 ? void 0 : _p.update) ? ParticipantUpdate.toJSON((_q = message.message) === null || _q === void 0 ? void 0 : _q.update) : void 0);
    ((_r = message.message) === null || _r === void 0 ? void 0 : _r.$case) === "trackPublished" && (obj.trackPublished = ((_s = message.message) === null || _s === void 0 ? void 0 : _s.trackPublished) ? TrackPublishedResponse.toJSON((_t = message.message) === null || _t === void 0 ? void 0 : _t.trackPublished) : void 0);
    ((_u = message.message) === null || _u === void 0 ? void 0 : _u.$case) === "leave" && (obj.leave = ((_v = message.message) === null || _v === void 0 ? void 0 : _v.leave) ? LeaveRequest.toJSON((_w = message.message) === null || _w === void 0 ? void 0 : _w.leave) : void 0);
    ((_x = message.message) === null || _x === void 0 ? void 0 : _x.$case) === "mute" && (obj.mute = ((_y = message.message) === null || _y === void 0 ? void 0 : _y.mute) ? MuteTrackRequest.toJSON((_z = message.message) === null || _z === void 0 ? void 0 : _z.mute) : void 0);
    ((_0 = message.message) === null || _0 === void 0 ? void 0 : _0.$case) === "speakersChanged" && (obj.speakersChanged = ((_1 = message.message) === null || _1 === void 0 ? void 0 : _1.speakersChanged) ? SpeakersChanged.toJSON((_2 = message.message) === null || _2 === void 0 ? void 0 : _2.speakersChanged) : void 0);
    ((_3 = message.message) === null || _3 === void 0 ? void 0 : _3.$case) === "roomUpdate" && (obj.roomUpdate = ((_4 = message.message) === null || _4 === void 0 ? void 0 : _4.roomUpdate) ? RoomUpdate.toJSON((_5 = message.message) === null || _5 === void 0 ? void 0 : _5.roomUpdate) : void 0);
    ((_6 = message.message) === null || _6 === void 0 ? void 0 : _6.$case) === "connectionQuality" && (obj.connectionQuality = ((_7 = message.message) === null || _7 === void 0 ? void 0 : _7.connectionQuality) ? ConnectionQualityUpdate.toJSON((_8 = message.message) === null || _8 === void 0 ? void 0 : _8.connectionQuality) : void 0);
    ((_9 = message.message) === null || _9 === void 0 ? void 0 : _9.$case) === "streamStateUpdate" && (obj.streamStateUpdate = ((_10 = message.message) === null || _10 === void 0 ? void 0 : _10.streamStateUpdate) ? StreamStateUpdate.toJSON((_11 = message.message) === null || _11 === void 0 ? void 0 : _11.streamStateUpdate) : void 0);
    ((_12 = message.message) === null || _12 === void 0 ? void 0 : _12.$case) === "subscribedQualityUpdate" && (obj.subscribedQualityUpdate = ((_13 = message.message) === null || _13 === void 0 ? void 0 : _13.subscribedQualityUpdate) ? SubscribedQualityUpdate.toJSON((_14 = message.message) === null || _14 === void 0 ? void 0 : _14.subscribedQualityUpdate) : void 0);
    ((_15 = message.message) === null || _15 === void 0 ? void 0 : _15.$case) === "subscriptionPermissionUpdate" && (obj.subscriptionPermissionUpdate = ((_16 = message.message) === null || _16 === void 0 ? void 0 : _16.subscriptionPermissionUpdate) ? SubscriptionPermissionUpdate.toJSON((_17 = message.message) === null || _17 === void 0 ? void 0 : _17.subscriptionPermissionUpdate) : void 0);
    ((_18 = message.message) === null || _18 === void 0 ? void 0 : _18.$case) === "refreshToken" && (obj.refreshToken = (_19 = message.message) === null || _19 === void 0 ? void 0 : _19.refreshToken);
    ((_20 = message.message) === null || _20 === void 0 ? void 0 : _20.$case) === "trackUnpublished" && (obj.trackUnpublished = ((_21 = message.message) === null || _21 === void 0 ? void 0 : _21.trackUnpublished) ? TrackUnpublishedResponse.toJSON((_22 = message.message) === null || _22 === void 0 ? void 0 : _22.trackUnpublished) : void 0);
    ((_23 = message.message) === null || _23 === void 0 ? void 0 : _23.$case) === "pong" && (obj.pong = Math.round((_24 = message.message) === null || _24 === void 0 ? void 0 : _24.pong));
    ((_25 = message.message) === null || _25 === void 0 ? void 0 : _25.$case) === "reconnect" && (obj.reconnect = ((_26 = message.message) === null || _26 === void 0 ? void 0 : _26.reconnect) ? ReconnectResponse.toJSON((_27 = message.message) === null || _27 === void 0 ? void 0 : _27.reconnect) : void 0);
    ((_28 = message.message) === null || _28 === void 0 ? void 0 : _28.$case) === "pongResp" && (obj.pongResp = ((_29 = message.message) === null || _29 === void 0 ? void 0 : _29.pongResp) ? Pong.toJSON((_30 = message.message) === null || _30 === void 0 ? void 0 : _30.pongResp) : void 0);
    return obj;
  },
  create(base) {
    return SignalResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32;
    const message = createBaseSignalResponse();
    if (((_a2 = object.message) === null || _a2 === void 0 ? void 0 : _a2.$case) === "join" && ((_b = object.message) === null || _b === void 0 ? void 0 : _b.join) !== void 0 && ((_c = object.message) === null || _c === void 0 ? void 0 : _c.join) !== null) {
      message.message = {
        $case: "join",
        join: JoinResponse.fromPartial(object.message.join)
      };
    }
    if (((_d = object.message) === null || _d === void 0 ? void 0 : _d.$case) === "answer" && ((_e = object.message) === null || _e === void 0 ? void 0 : _e.answer) !== void 0 && ((_f = object.message) === null || _f === void 0 ? void 0 : _f.answer) !== null) {
      message.message = {
        $case: "answer",
        answer: SessionDescription.fromPartial(object.message.answer)
      };
    }
    if (((_g = object.message) === null || _g === void 0 ? void 0 : _g.$case) === "offer" && ((_h = object.message) === null || _h === void 0 ? void 0 : _h.offer) !== void 0 && ((_j = object.message) === null || _j === void 0 ? void 0 : _j.offer) !== null) {
      message.message = {
        $case: "offer",
        offer: SessionDescription.fromPartial(object.message.offer)
      };
    }
    if (((_k = object.message) === null || _k === void 0 ? void 0 : _k.$case) === "trickle" && ((_l = object.message) === null || _l === void 0 ? void 0 : _l.trickle) !== void 0 && ((_m = object.message) === null || _m === void 0 ? void 0 : _m.trickle) !== null) {
      message.message = {
        $case: "trickle",
        trickle: TrickleRequest.fromPartial(object.message.trickle)
      };
    }
    if (((_o = object.message) === null || _o === void 0 ? void 0 : _o.$case) === "update" && ((_p = object.message) === null || _p === void 0 ? void 0 : _p.update) !== void 0 && ((_q = object.message) === null || _q === void 0 ? void 0 : _q.update) !== null) {
      message.message = {
        $case: "update",
        update: ParticipantUpdate.fromPartial(object.message.update)
      };
    }
    if (((_r = object.message) === null || _r === void 0 ? void 0 : _r.$case) === "trackPublished" && ((_s = object.message) === null || _s === void 0 ? void 0 : _s.trackPublished) !== void 0 && ((_t = object.message) === null || _t === void 0 ? void 0 : _t.trackPublished) !== null) {
      message.message = {
        $case: "trackPublished",
        trackPublished: TrackPublishedResponse.fromPartial(object.message.trackPublished)
      };
    }
    if (((_u = object.message) === null || _u === void 0 ? void 0 : _u.$case) === "leave" && ((_v = object.message) === null || _v === void 0 ? void 0 : _v.leave) !== void 0 && ((_w = object.message) === null || _w === void 0 ? void 0 : _w.leave) !== null) {
      message.message = {
        $case: "leave",
        leave: LeaveRequest.fromPartial(object.message.leave)
      };
    }
    if (((_x = object.message) === null || _x === void 0 ? void 0 : _x.$case) === "mute" && ((_y = object.message) === null || _y === void 0 ? void 0 : _y.mute) !== void 0 && ((_z = object.message) === null || _z === void 0 ? void 0 : _z.mute) !== null) {
      message.message = {
        $case: "mute",
        mute: MuteTrackRequest.fromPartial(object.message.mute)
      };
    }
    if (((_0 = object.message) === null || _0 === void 0 ? void 0 : _0.$case) === "speakersChanged" && ((_1 = object.message) === null || _1 === void 0 ? void 0 : _1.speakersChanged) !== void 0 && ((_2 = object.message) === null || _2 === void 0 ? void 0 : _2.speakersChanged) !== null) {
      message.message = {
        $case: "speakersChanged",
        speakersChanged: SpeakersChanged.fromPartial(object.message.speakersChanged)
      };
    }
    if (((_3 = object.message) === null || _3 === void 0 ? void 0 : _3.$case) === "roomUpdate" && ((_4 = object.message) === null || _4 === void 0 ? void 0 : _4.roomUpdate) !== void 0 && ((_5 = object.message) === null || _5 === void 0 ? void 0 : _5.roomUpdate) !== null) {
      message.message = {
        $case: "roomUpdate",
        roomUpdate: RoomUpdate.fromPartial(object.message.roomUpdate)
      };
    }
    if (((_6 = object.message) === null || _6 === void 0 ? void 0 : _6.$case) === "connectionQuality" && ((_7 = object.message) === null || _7 === void 0 ? void 0 : _7.connectionQuality) !== void 0 && ((_8 = object.message) === null || _8 === void 0 ? void 0 : _8.connectionQuality) !== null) {
      message.message = {
        $case: "connectionQuality",
        connectionQuality: ConnectionQualityUpdate.fromPartial(object.message.connectionQuality)
      };
    }
    if (((_9 = object.message) === null || _9 === void 0 ? void 0 : _9.$case) === "streamStateUpdate" && ((_10 = object.message) === null || _10 === void 0 ? void 0 : _10.streamStateUpdate) !== void 0 && ((_11 = object.message) === null || _11 === void 0 ? void 0 : _11.streamStateUpdate) !== null) {
      message.message = {
        $case: "streamStateUpdate",
        streamStateUpdate: StreamStateUpdate.fromPartial(object.message.streamStateUpdate)
      };
    }
    if (((_12 = object.message) === null || _12 === void 0 ? void 0 : _12.$case) === "subscribedQualityUpdate" && ((_13 = object.message) === null || _13 === void 0 ? void 0 : _13.subscribedQualityUpdate) !== void 0 && ((_14 = object.message) === null || _14 === void 0 ? void 0 : _14.subscribedQualityUpdate) !== null) {
      message.message = {
        $case: "subscribedQualityUpdate",
        subscribedQualityUpdate: SubscribedQualityUpdate.fromPartial(object.message.subscribedQualityUpdate)
      };
    }
    if (((_15 = object.message) === null || _15 === void 0 ? void 0 : _15.$case) === "subscriptionPermissionUpdate" && ((_16 = object.message) === null || _16 === void 0 ? void 0 : _16.subscriptionPermissionUpdate) !== void 0 && ((_17 = object.message) === null || _17 === void 0 ? void 0 : _17.subscriptionPermissionUpdate) !== null) {
      message.message = {
        $case: "subscriptionPermissionUpdate",
        subscriptionPermissionUpdate: SubscriptionPermissionUpdate.fromPartial(object.message.subscriptionPermissionUpdate)
      };
    }
    if (((_18 = object.message) === null || _18 === void 0 ? void 0 : _18.$case) === "refreshToken" && ((_19 = object.message) === null || _19 === void 0 ? void 0 : _19.refreshToken) !== void 0 && ((_20 = object.message) === null || _20 === void 0 ? void 0 : _20.refreshToken) !== null) {
      message.message = {
        $case: "refreshToken",
        refreshToken: object.message.refreshToken
      };
    }
    if (((_21 = object.message) === null || _21 === void 0 ? void 0 : _21.$case) === "trackUnpublished" && ((_22 = object.message) === null || _22 === void 0 ? void 0 : _22.trackUnpublished) !== void 0 && ((_23 = object.message) === null || _23 === void 0 ? void 0 : _23.trackUnpublished) !== null) {
      message.message = {
        $case: "trackUnpublished",
        trackUnpublished: TrackUnpublishedResponse.fromPartial(object.message.trackUnpublished)
      };
    }
    if (((_24 = object.message) === null || _24 === void 0 ? void 0 : _24.$case) === "pong" && ((_25 = object.message) === null || _25 === void 0 ? void 0 : _25.pong) !== void 0 && ((_26 = object.message) === null || _26 === void 0 ? void 0 : _26.pong) !== null) {
      message.message = {
        $case: "pong",
        pong: object.message.pong
      };
    }
    if (((_27 = object.message) === null || _27 === void 0 ? void 0 : _27.$case) === "reconnect" && ((_28 = object.message) === null || _28 === void 0 ? void 0 : _28.reconnect) !== void 0 && ((_29 = object.message) === null || _29 === void 0 ? void 0 : _29.reconnect) !== null) {
      message.message = {
        $case: "reconnect",
        reconnect: ReconnectResponse.fromPartial(object.message.reconnect)
      };
    }
    if (((_30 = object.message) === null || _30 === void 0 ? void 0 : _30.$case) === "pongResp" && ((_31 = object.message) === null || _31 === void 0 ? void 0 : _31.pongResp) !== void 0 && ((_32 = object.message) === null || _32 === void 0 ? void 0 : _32.pongResp) !== null) {
      message.message = {
        $case: "pongResp",
        pongResp: Pong.fromPartial(object.message.pongResp)
      };
    }
    return message;
  }
};
function createBaseSimulcastCodec() {
  return {
    codec: "",
    cid: "",
    enableSimulcastLayers: false
  };
}
const SimulcastCodec = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.codec !== "") {
      writer2.uint32(10).string(message.codec);
    }
    if (message.cid !== "") {
      writer2.uint32(18).string(message.cid);
    }
    if (message.enableSimulcastLayers === true) {
      writer2.uint32(24).bool(message.enableSimulcastLayers);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSimulcastCodec();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.codec = reader2.string();
          break;
        case 2:
          message.cid = reader2.string();
          break;
        case 3:
          message.enableSimulcastLayers = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      codec: isSet(object.codec) ? String(object.codec) : "",
      cid: isSet(object.cid) ? String(object.cid) : "",
      enableSimulcastLayers: isSet(object.enableSimulcastLayers) ? Boolean(object.enableSimulcastLayers) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.codec !== void 0 && (obj.codec = message.codec);
    message.cid !== void 0 && (obj.cid = message.cid);
    message.enableSimulcastLayers !== void 0 && (obj.enableSimulcastLayers = message.enableSimulcastLayers);
    return obj;
  },
  create(base) {
    return SimulcastCodec.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseSimulcastCodec();
    message.codec = (_a2 = object.codec) !== null && _a2 !== void 0 ? _a2 : "";
    message.cid = (_b = object.cid) !== null && _b !== void 0 ? _b : "";
    message.enableSimulcastLayers = (_c = object.enableSimulcastLayers) !== null && _c !== void 0 ? _c : false;
    return message;
  }
};
function createBaseAddTrackRequest() {
  return {
    cid: "",
    name: "",
    type: 0,
    width: 0,
    height: 0,
    muted: false,
    disableDtx: false,
    source: 0,
    layers: [],
    simulcastCodecs: [],
    sid: "",
    stereo: false,
    disableRed: false,
    encryption: 0
  };
}
const AddTrackRequest = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.cid !== "") {
      writer2.uint32(10).string(message.cid);
    }
    if (message.name !== "") {
      writer2.uint32(18).string(message.name);
    }
    if (message.type !== 0) {
      writer2.uint32(24).int32(message.type);
    }
    if (message.width !== 0) {
      writer2.uint32(32).uint32(message.width);
    }
    if (message.height !== 0) {
      writer2.uint32(40).uint32(message.height);
    }
    if (message.muted === true) {
      writer2.uint32(48).bool(message.muted);
    }
    if (message.disableDtx === true) {
      writer2.uint32(56).bool(message.disableDtx);
    }
    if (message.source !== 0) {
      writer2.uint32(64).int32(message.source);
    }
    for (const v of message.layers) {
      VideoLayer.encode(v, writer2.uint32(74).fork()).ldelim();
    }
    for (const v of message.simulcastCodecs) {
      SimulcastCodec.encode(v, writer2.uint32(82).fork()).ldelim();
    }
    if (message.sid !== "") {
      writer2.uint32(90).string(message.sid);
    }
    if (message.stereo === true) {
      writer2.uint32(96).bool(message.stereo);
    }
    if (message.disableRed === true) {
      writer2.uint32(104).bool(message.disableRed);
    }
    if (message.encryption !== 0) {
      writer2.uint32(112).int32(message.encryption);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseAddTrackRequest();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.cid = reader2.string();
          break;
        case 2:
          message.name = reader2.string();
          break;
        case 3:
          message.type = reader2.int32();
          break;
        case 4:
          message.width = reader2.uint32();
          break;
        case 5:
          message.height = reader2.uint32();
          break;
        case 6:
          message.muted = reader2.bool();
          break;
        case 7:
          message.disableDtx = reader2.bool();
          break;
        case 8:
          message.source = reader2.int32();
          break;
        case 9:
          message.layers.push(VideoLayer.decode(reader2, reader2.uint32()));
          break;
        case 10:
          message.simulcastCodecs.push(SimulcastCodec.decode(reader2, reader2.uint32()));
          break;
        case 11:
          message.sid = reader2.string();
          break;
        case 12:
          message.stereo = reader2.bool();
          break;
        case 13:
          message.disableRed = reader2.bool();
          break;
        case 14:
          message.encryption = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      cid: isSet(object.cid) ? String(object.cid) : "",
      name: isSet(object.name) ? String(object.name) : "",
      type: isSet(object.type) ? trackTypeFromJSON(object.type) : 0,
      width: isSet(object.width) ? Number(object.width) : 0,
      height: isSet(object.height) ? Number(object.height) : 0,
      muted: isSet(object.muted) ? Boolean(object.muted) : false,
      disableDtx: isSet(object.disableDtx) ? Boolean(object.disableDtx) : false,
      source: isSet(object.source) ? trackSourceFromJSON(object.source) : 0,
      layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e2) => VideoLayer.fromJSON(e2)) : [],
      simulcastCodecs: Array.isArray(object === null || object === void 0 ? void 0 : object.simulcastCodecs) ? object.simulcastCodecs.map((e2) => SimulcastCodec.fromJSON(e2)) : [],
      sid: isSet(object.sid) ? String(object.sid) : "",
      stereo: isSet(object.stereo) ? Boolean(object.stereo) : false,
      disableRed: isSet(object.disableRed) ? Boolean(object.disableRed) : false,
      encryption: isSet(object.encryption) ? encryption_TypeFromJSON(object.encryption) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.cid !== void 0 && (obj.cid = message.cid);
    message.name !== void 0 && (obj.name = message.name);
    message.type !== void 0 && (obj.type = trackTypeToJSON(message.type));
    message.width !== void 0 && (obj.width = Math.round(message.width));
    message.height !== void 0 && (obj.height = Math.round(message.height));
    message.muted !== void 0 && (obj.muted = message.muted);
    message.disableDtx !== void 0 && (obj.disableDtx = message.disableDtx);
    message.source !== void 0 && (obj.source = trackSourceToJSON(message.source));
    if (message.layers) {
      obj.layers = message.layers.map((e2) => e2 ? VideoLayer.toJSON(e2) : void 0);
    } else {
      obj.layers = [];
    }
    if (message.simulcastCodecs) {
      obj.simulcastCodecs = message.simulcastCodecs.map((e2) => e2 ? SimulcastCodec.toJSON(e2) : void 0);
    } else {
      obj.simulcastCodecs = [];
    }
    message.sid !== void 0 && (obj.sid = message.sid);
    message.stereo !== void 0 && (obj.stereo = message.stereo);
    message.disableRed !== void 0 && (obj.disableRed = message.disableRed);
    message.encryption !== void 0 && (obj.encryption = encryption_TypeToJSON(message.encryption));
    return obj;
  },
  create(base) {
    return AddTrackRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    const message = createBaseAddTrackRequest();
    message.cid = (_a2 = object.cid) !== null && _a2 !== void 0 ? _a2 : "";
    message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
    message.type = (_c = object.type) !== null && _c !== void 0 ? _c : 0;
    message.width = (_d = object.width) !== null && _d !== void 0 ? _d : 0;
    message.height = (_e = object.height) !== null && _e !== void 0 ? _e : 0;
    message.muted = (_f = object.muted) !== null && _f !== void 0 ? _f : false;
    message.disableDtx = (_g = object.disableDtx) !== null && _g !== void 0 ? _g : false;
    message.source = (_h = object.source) !== null && _h !== void 0 ? _h : 0;
    message.layers = ((_j = object.layers) === null || _j === void 0 ? void 0 : _j.map((e2) => VideoLayer.fromPartial(e2))) || [];
    message.simulcastCodecs = ((_k = object.simulcastCodecs) === null || _k === void 0 ? void 0 : _k.map((e2) => SimulcastCodec.fromPartial(e2))) || [];
    message.sid = (_l = object.sid) !== null && _l !== void 0 ? _l : "";
    message.stereo = (_m = object.stereo) !== null && _m !== void 0 ? _m : false;
    message.disableRed = (_o = object.disableRed) !== null && _o !== void 0 ? _o : false;
    message.encryption = (_p = object.encryption) !== null && _p !== void 0 ? _p : 0;
    return message;
  }
};
function createBaseTrickleRequest() {
  return {
    candidateInit: "",
    target: 0
  };
}
const TrickleRequest = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.candidateInit !== "") {
      writer2.uint32(10).string(message.candidateInit);
    }
    if (message.target !== 0) {
      writer2.uint32(16).int32(message.target);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTrickleRequest();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.candidateInit = reader2.string();
          break;
        case 2:
          message.target = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      candidateInit: isSet(object.candidateInit) ? String(object.candidateInit) : "",
      target: isSet(object.target) ? signalTargetFromJSON(object.target) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.candidateInit !== void 0 && (obj.candidateInit = message.candidateInit);
    message.target !== void 0 && (obj.target = signalTargetToJSON(message.target));
    return obj;
  },
  create(base) {
    return TrickleRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseTrickleRequest();
    message.candidateInit = (_a2 = object.candidateInit) !== null && _a2 !== void 0 ? _a2 : "";
    message.target = (_b = object.target) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function createBaseMuteTrackRequest() {
  return {
    sid: "",
    muted: false
  };
}
const MuteTrackRequest = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.sid !== "") {
      writer2.uint32(10).string(message.sid);
    }
    if (message.muted === true) {
      writer2.uint32(16).bool(message.muted);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseMuteTrackRequest();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sid = reader2.string();
          break;
        case 2:
          message.muted = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sid: isSet(object.sid) ? String(object.sid) : "",
      muted: isSet(object.muted) ? Boolean(object.muted) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.sid !== void 0 && (obj.sid = message.sid);
    message.muted !== void 0 && (obj.muted = message.muted);
    return obj;
  },
  create(base) {
    return MuteTrackRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseMuteTrackRequest();
    message.sid = (_a2 = object.sid) !== null && _a2 !== void 0 ? _a2 : "";
    message.muted = (_b = object.muted) !== null && _b !== void 0 ? _b : false;
    return message;
  }
};
function createBaseJoinResponse() {
  return {
    room: void 0,
    participant: void 0,
    otherParticipants: [],
    serverVersion: "",
    iceServers: [],
    subscriberPrimary: false,
    alternativeUrl: "",
    clientConfiguration: void 0,
    serverRegion: "",
    pingTimeout: 0,
    pingInterval: 0,
    serverInfo: void 0
  };
}
const JoinResponse = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.room !== void 0) {
      Room$1.encode(message.room, writer2.uint32(10).fork()).ldelim();
    }
    if (message.participant !== void 0) {
      ParticipantInfo.encode(message.participant, writer2.uint32(18).fork()).ldelim();
    }
    for (const v of message.otherParticipants) {
      ParticipantInfo.encode(v, writer2.uint32(26).fork()).ldelim();
    }
    if (message.serverVersion !== "") {
      writer2.uint32(34).string(message.serverVersion);
    }
    for (const v of message.iceServers) {
      ICEServer.encode(v, writer2.uint32(42).fork()).ldelim();
    }
    if (message.subscriberPrimary === true) {
      writer2.uint32(48).bool(message.subscriberPrimary);
    }
    if (message.alternativeUrl !== "") {
      writer2.uint32(58).string(message.alternativeUrl);
    }
    if (message.clientConfiguration !== void 0) {
      ClientConfiguration.encode(message.clientConfiguration, writer2.uint32(66).fork()).ldelim();
    }
    if (message.serverRegion !== "") {
      writer2.uint32(74).string(message.serverRegion);
    }
    if (message.pingTimeout !== 0) {
      writer2.uint32(80).int32(message.pingTimeout);
    }
    if (message.pingInterval !== 0) {
      writer2.uint32(88).int32(message.pingInterval);
    }
    if (message.serverInfo !== void 0) {
      ServerInfo.encode(message.serverInfo, writer2.uint32(98).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseJoinResponse();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.room = Room$1.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.participant = ParticipantInfo.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.otherParticipants.push(ParticipantInfo.decode(reader2, reader2.uint32()));
          break;
        case 4:
          message.serverVersion = reader2.string();
          break;
        case 5:
          message.iceServers.push(ICEServer.decode(reader2, reader2.uint32()));
          break;
        case 6:
          message.subscriberPrimary = reader2.bool();
          break;
        case 7:
          message.alternativeUrl = reader2.string();
          break;
        case 8:
          message.clientConfiguration = ClientConfiguration.decode(reader2, reader2.uint32());
          break;
        case 9:
          message.serverRegion = reader2.string();
          break;
        case 10:
          message.pingTimeout = reader2.int32();
          break;
        case 11:
          message.pingInterval = reader2.int32();
          break;
        case 12:
          message.serverInfo = ServerInfo.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      room: isSet(object.room) ? Room$1.fromJSON(object.room) : void 0,
      participant: isSet(object.participant) ? ParticipantInfo.fromJSON(object.participant) : void 0,
      otherParticipants: Array.isArray(object === null || object === void 0 ? void 0 : object.otherParticipants) ? object.otherParticipants.map((e2) => ParticipantInfo.fromJSON(e2)) : [],
      serverVersion: isSet(object.serverVersion) ? String(object.serverVersion) : "",
      iceServers: Array.isArray(object === null || object === void 0 ? void 0 : object.iceServers) ? object.iceServers.map((e2) => ICEServer.fromJSON(e2)) : [],
      subscriberPrimary: isSet(object.subscriberPrimary) ? Boolean(object.subscriberPrimary) : false,
      alternativeUrl: isSet(object.alternativeUrl) ? String(object.alternativeUrl) : "",
      clientConfiguration: isSet(object.clientConfiguration) ? ClientConfiguration.fromJSON(object.clientConfiguration) : void 0,
      serverRegion: isSet(object.serverRegion) ? String(object.serverRegion) : "",
      pingTimeout: isSet(object.pingTimeout) ? Number(object.pingTimeout) : 0,
      pingInterval: isSet(object.pingInterval) ? Number(object.pingInterval) : 0,
      serverInfo: isSet(object.serverInfo) ? ServerInfo.fromJSON(object.serverInfo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.room !== void 0 && (obj.room = message.room ? Room$1.toJSON(message.room) : void 0);
    message.participant !== void 0 && (obj.participant = message.participant ? ParticipantInfo.toJSON(message.participant) : void 0);
    if (message.otherParticipants) {
      obj.otherParticipants = message.otherParticipants.map((e2) => e2 ? ParticipantInfo.toJSON(e2) : void 0);
    } else {
      obj.otherParticipants = [];
    }
    message.serverVersion !== void 0 && (obj.serverVersion = message.serverVersion);
    if (message.iceServers) {
      obj.iceServers = message.iceServers.map((e2) => e2 ? ICEServer.toJSON(e2) : void 0);
    } else {
      obj.iceServers = [];
    }
    message.subscriberPrimary !== void 0 && (obj.subscriberPrimary = message.subscriberPrimary);
    message.alternativeUrl !== void 0 && (obj.alternativeUrl = message.alternativeUrl);
    message.clientConfiguration !== void 0 && (obj.clientConfiguration = message.clientConfiguration ? ClientConfiguration.toJSON(message.clientConfiguration) : void 0);
    message.serverRegion !== void 0 && (obj.serverRegion = message.serverRegion);
    message.pingTimeout !== void 0 && (obj.pingTimeout = Math.round(message.pingTimeout));
    message.pingInterval !== void 0 && (obj.pingInterval = Math.round(message.pingInterval));
    message.serverInfo !== void 0 && (obj.serverInfo = message.serverInfo ? ServerInfo.toJSON(message.serverInfo) : void 0);
    return obj;
  },
  create(base) {
    return JoinResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    const message = createBaseJoinResponse();
    message.room = object.room !== void 0 && object.room !== null ? Room$1.fromPartial(object.room) : void 0;
    message.participant = object.participant !== void 0 && object.participant !== null ? ParticipantInfo.fromPartial(object.participant) : void 0;
    message.otherParticipants = ((_a2 = object.otherParticipants) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => ParticipantInfo.fromPartial(e2))) || [];
    message.serverVersion = (_b = object.serverVersion) !== null && _b !== void 0 ? _b : "";
    message.iceServers = ((_c = object.iceServers) === null || _c === void 0 ? void 0 : _c.map((e2) => ICEServer.fromPartial(e2))) || [];
    message.subscriberPrimary = (_d = object.subscriberPrimary) !== null && _d !== void 0 ? _d : false;
    message.alternativeUrl = (_e = object.alternativeUrl) !== null && _e !== void 0 ? _e : "";
    message.clientConfiguration = object.clientConfiguration !== void 0 && object.clientConfiguration !== null ? ClientConfiguration.fromPartial(object.clientConfiguration) : void 0;
    message.serverRegion = (_f = object.serverRegion) !== null && _f !== void 0 ? _f : "";
    message.pingTimeout = (_g = object.pingTimeout) !== null && _g !== void 0 ? _g : 0;
    message.pingInterval = (_h = object.pingInterval) !== null && _h !== void 0 ? _h : 0;
    message.serverInfo = object.serverInfo !== void 0 && object.serverInfo !== null ? ServerInfo.fromPartial(object.serverInfo) : void 0;
    return message;
  }
};
function createBaseReconnectResponse() {
  return {
    iceServers: [],
    clientConfiguration: void 0
  };
}
const ReconnectResponse = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    for (const v of message.iceServers) {
      ICEServer.encode(v, writer2.uint32(10).fork()).ldelim();
    }
    if (message.clientConfiguration !== void 0) {
      ClientConfiguration.encode(message.clientConfiguration, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseReconnectResponse();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.iceServers.push(ICEServer.decode(reader2, reader2.uint32()));
          break;
        case 2:
          message.clientConfiguration = ClientConfiguration.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      iceServers: Array.isArray(object === null || object === void 0 ? void 0 : object.iceServers) ? object.iceServers.map((e2) => ICEServer.fromJSON(e2)) : [],
      clientConfiguration: isSet(object.clientConfiguration) ? ClientConfiguration.fromJSON(object.clientConfiguration) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.iceServers) {
      obj.iceServers = message.iceServers.map((e2) => e2 ? ICEServer.toJSON(e2) : void 0);
    } else {
      obj.iceServers = [];
    }
    message.clientConfiguration !== void 0 && (obj.clientConfiguration = message.clientConfiguration ? ClientConfiguration.toJSON(message.clientConfiguration) : void 0);
    return obj;
  },
  create(base) {
    return ReconnectResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2;
    const message = createBaseReconnectResponse();
    message.iceServers = ((_a2 = object.iceServers) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => ICEServer.fromPartial(e2))) || [];
    message.clientConfiguration = object.clientConfiguration !== void 0 && object.clientConfiguration !== null ? ClientConfiguration.fromPartial(object.clientConfiguration) : void 0;
    return message;
  }
};
function createBaseTrackPublishedResponse() {
  return {
    cid: "",
    track: void 0
  };
}
const TrackPublishedResponse = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.cid !== "") {
      writer2.uint32(10).string(message.cid);
    }
    if (message.track !== void 0) {
      TrackInfo.encode(message.track, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTrackPublishedResponse();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.cid = reader2.string();
          break;
        case 2:
          message.track = TrackInfo.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      cid: isSet(object.cid) ? String(object.cid) : "",
      track: isSet(object.track) ? TrackInfo.fromJSON(object.track) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.cid !== void 0 && (obj.cid = message.cid);
    message.track !== void 0 && (obj.track = message.track ? TrackInfo.toJSON(message.track) : void 0);
    return obj;
  },
  create(base) {
    return TrackPublishedResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2;
    const message = createBaseTrackPublishedResponse();
    message.cid = (_a2 = object.cid) !== null && _a2 !== void 0 ? _a2 : "";
    message.track = object.track !== void 0 && object.track !== null ? TrackInfo.fromPartial(object.track) : void 0;
    return message;
  }
};
function createBaseTrackUnpublishedResponse() {
  return {
    trackSid: ""
  };
}
const TrackUnpublishedResponse = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.trackSid !== "") {
      writer2.uint32(10).string(message.trackSid);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTrackUnpublishedResponse();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trackSid = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      trackSid: isSet(object.trackSid) ? String(object.trackSid) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);
    return obj;
  },
  create(base) {
    return TrackUnpublishedResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2;
    const message = createBaseTrackUnpublishedResponse();
    message.trackSid = (_a2 = object.trackSid) !== null && _a2 !== void 0 ? _a2 : "";
    return message;
  }
};
function createBaseSessionDescription() {
  return {
    type: "",
    sdp: ""
  };
}
const SessionDescription = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.type !== "") {
      writer2.uint32(10).string(message.type);
    }
    if (message.sdp !== "") {
      writer2.uint32(18).string(message.sdp);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSessionDescription();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader2.string();
          break;
        case 2:
          message.sdp = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet(object.type) ? String(object.type) : "",
      sdp: isSet(object.sdp) ? String(object.sdp) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = message.type);
    message.sdp !== void 0 && (obj.sdp = message.sdp);
    return obj;
  },
  create(base) {
    return SessionDescription.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseSessionDescription();
    message.type = (_a2 = object.type) !== null && _a2 !== void 0 ? _a2 : "";
    message.sdp = (_b = object.sdp) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseParticipantUpdate() {
  return {
    participants: []
  };
}
const ParticipantUpdate = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    for (const v of message.participants) {
      ParticipantInfo.encode(v, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseParticipantUpdate();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participants.push(ParticipantInfo.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      participants: Array.isArray(object === null || object === void 0 ? void 0 : object.participants) ? object.participants.map((e2) => ParticipantInfo.fromJSON(e2)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.participants) {
      obj.participants = message.participants.map((e2) => e2 ? ParticipantInfo.toJSON(e2) : void 0);
    } else {
      obj.participants = [];
    }
    return obj;
  },
  create(base) {
    return ParticipantUpdate.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2;
    const message = createBaseParticipantUpdate();
    message.participants = ((_a2 = object.participants) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => ParticipantInfo.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseUpdateSubscription() {
  return {
    trackSids: [],
    subscribe: false,
    participantTracks: []
  };
}
const UpdateSubscription = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    for (const v of message.trackSids) {
      writer2.uint32(10).string(v);
    }
    if (message.subscribe === true) {
      writer2.uint32(16).bool(message.subscribe);
    }
    for (const v of message.participantTracks) {
      ParticipantTracks.encode(v, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUpdateSubscription();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trackSids.push(reader2.string());
          break;
        case 2:
          message.subscribe = reader2.bool();
          break;
        case 3:
          message.participantTracks.push(ParticipantTracks.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      trackSids: Array.isArray(object === null || object === void 0 ? void 0 : object.trackSids) ? object.trackSids.map((e2) => String(e2)) : [],
      subscribe: isSet(object.subscribe) ? Boolean(object.subscribe) : false,
      participantTracks: Array.isArray(object === null || object === void 0 ? void 0 : object.participantTracks) ? object.participantTracks.map((e2) => ParticipantTracks.fromJSON(e2)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.trackSids) {
      obj.trackSids = message.trackSids.map((e2) => e2);
    } else {
      obj.trackSids = [];
    }
    message.subscribe !== void 0 && (obj.subscribe = message.subscribe);
    if (message.participantTracks) {
      obj.participantTracks = message.participantTracks.map((e2) => e2 ? ParticipantTracks.toJSON(e2) : void 0);
    } else {
      obj.participantTracks = [];
    }
    return obj;
  },
  create(base) {
    return UpdateSubscription.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseUpdateSubscription();
    message.trackSids = ((_a2 = object.trackSids) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
    message.subscribe = (_b = object.subscribe) !== null && _b !== void 0 ? _b : false;
    message.participantTracks = ((_c = object.participantTracks) === null || _c === void 0 ? void 0 : _c.map((e2) => ParticipantTracks.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseUpdateTrackSettings() {
  return {
    trackSids: [],
    disabled: false,
    quality: 0,
    width: 0,
    height: 0,
    fps: 0,
    priority: 0
  };
}
const UpdateTrackSettings = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    for (const v of message.trackSids) {
      writer2.uint32(10).string(v);
    }
    if (message.disabled === true) {
      writer2.uint32(24).bool(message.disabled);
    }
    if (message.quality !== 0) {
      writer2.uint32(32).int32(message.quality);
    }
    if (message.width !== 0) {
      writer2.uint32(40).uint32(message.width);
    }
    if (message.height !== 0) {
      writer2.uint32(48).uint32(message.height);
    }
    if (message.fps !== 0) {
      writer2.uint32(56).uint32(message.fps);
    }
    if (message.priority !== 0) {
      writer2.uint32(64).uint32(message.priority);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUpdateTrackSettings();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trackSids.push(reader2.string());
          break;
        case 3:
          message.disabled = reader2.bool();
          break;
        case 4:
          message.quality = reader2.int32();
          break;
        case 5:
          message.width = reader2.uint32();
          break;
        case 6:
          message.height = reader2.uint32();
          break;
        case 7:
          message.fps = reader2.uint32();
          break;
        case 8:
          message.priority = reader2.uint32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      trackSids: Array.isArray(object === null || object === void 0 ? void 0 : object.trackSids) ? object.trackSids.map((e2) => String(e2)) : [],
      disabled: isSet(object.disabled) ? Boolean(object.disabled) : false,
      quality: isSet(object.quality) ? videoQualityFromJSON(object.quality) : 0,
      width: isSet(object.width) ? Number(object.width) : 0,
      height: isSet(object.height) ? Number(object.height) : 0,
      fps: isSet(object.fps) ? Number(object.fps) : 0,
      priority: isSet(object.priority) ? Number(object.priority) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.trackSids) {
      obj.trackSids = message.trackSids.map((e2) => e2);
    } else {
      obj.trackSids = [];
    }
    message.disabled !== void 0 && (obj.disabled = message.disabled);
    message.quality !== void 0 && (obj.quality = videoQualityToJSON(message.quality));
    message.width !== void 0 && (obj.width = Math.round(message.width));
    message.height !== void 0 && (obj.height = Math.round(message.height));
    message.fps !== void 0 && (obj.fps = Math.round(message.fps));
    message.priority !== void 0 && (obj.priority = Math.round(message.priority));
    return obj;
  },
  create(base) {
    return UpdateTrackSettings.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g;
    const message = createBaseUpdateTrackSettings();
    message.trackSids = ((_a2 = object.trackSids) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
    message.disabled = (_b = object.disabled) !== null && _b !== void 0 ? _b : false;
    message.quality = (_c = object.quality) !== null && _c !== void 0 ? _c : 0;
    message.width = (_d = object.width) !== null && _d !== void 0 ? _d : 0;
    message.height = (_e = object.height) !== null && _e !== void 0 ? _e : 0;
    message.fps = (_f = object.fps) !== null && _f !== void 0 ? _f : 0;
    message.priority = (_g = object.priority) !== null && _g !== void 0 ? _g : 0;
    return message;
  }
};
function createBaseLeaveRequest() {
  return {
    canReconnect: false,
    reason: 0
  };
}
const LeaveRequest = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.canReconnect === true) {
      writer2.uint32(8).bool(message.canReconnect);
    }
    if (message.reason !== 0) {
      writer2.uint32(16).int32(message.reason);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseLeaveRequest();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.canReconnect = reader2.bool();
          break;
        case 2:
          message.reason = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      canReconnect: isSet(object.canReconnect) ? Boolean(object.canReconnect) : false,
      reason: isSet(object.reason) ? disconnectReasonFromJSON(object.reason) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.canReconnect !== void 0 && (obj.canReconnect = message.canReconnect);
    message.reason !== void 0 && (obj.reason = disconnectReasonToJSON(message.reason));
    return obj;
  },
  create(base) {
    return LeaveRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseLeaveRequest();
    message.canReconnect = (_a2 = object.canReconnect) !== null && _a2 !== void 0 ? _a2 : false;
    message.reason = (_b = object.reason) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function createBaseUpdateVideoLayers() {
  return {
    trackSid: "",
    layers: []
  };
}
const UpdateVideoLayers = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.trackSid !== "") {
      writer2.uint32(10).string(message.trackSid);
    }
    for (const v of message.layers) {
      VideoLayer.encode(v, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUpdateVideoLayers();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trackSid = reader2.string();
          break;
        case 2:
          message.layers.push(VideoLayer.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      trackSid: isSet(object.trackSid) ? String(object.trackSid) : "",
      layers: Array.isArray(object === null || object === void 0 ? void 0 : object.layers) ? object.layers.map((e2) => VideoLayer.fromJSON(e2)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);
    if (message.layers) {
      obj.layers = message.layers.map((e2) => e2 ? VideoLayer.toJSON(e2) : void 0);
    } else {
      obj.layers = [];
    }
    return obj;
  },
  create(base) {
    return UpdateVideoLayers.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseUpdateVideoLayers();
    message.trackSid = (_a2 = object.trackSid) !== null && _a2 !== void 0 ? _a2 : "";
    message.layers = ((_b = object.layers) === null || _b === void 0 ? void 0 : _b.map((e2) => VideoLayer.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseUpdateParticipantMetadata() {
  return {
    metadata: ""
  };
}
const UpdateParticipantMetadata = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.metadata !== "") {
      writer2.uint32(10).string(message.metadata);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseUpdateParticipantMetadata();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.metadata = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      metadata: isSet(object.metadata) ? String(object.metadata) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.metadata !== void 0 && (obj.metadata = message.metadata);
    return obj;
  },
  create(base) {
    return UpdateParticipantMetadata.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2;
    const message = createBaseUpdateParticipantMetadata();
    message.metadata = (_a2 = object.metadata) !== null && _a2 !== void 0 ? _a2 : "";
    return message;
  }
};
function createBaseICEServer() {
  return {
    urls: [],
    username: "",
    credential: ""
  };
}
const ICEServer = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    for (const v of message.urls) {
      writer2.uint32(10).string(v);
    }
    if (message.username !== "") {
      writer2.uint32(18).string(message.username);
    }
    if (message.credential !== "") {
      writer2.uint32(26).string(message.credential);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseICEServer();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.urls.push(reader2.string());
          break;
        case 2:
          message.username = reader2.string();
          break;
        case 3:
          message.credential = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      urls: Array.isArray(object === null || object === void 0 ? void 0 : object.urls) ? object.urls.map((e2) => String(e2)) : [],
      username: isSet(object.username) ? String(object.username) : "",
      credential: isSet(object.credential) ? String(object.credential) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.urls) {
      obj.urls = message.urls.map((e2) => e2);
    } else {
      obj.urls = [];
    }
    message.username !== void 0 && (obj.username = message.username);
    message.credential !== void 0 && (obj.credential = message.credential);
    return obj;
  },
  create(base) {
    return ICEServer.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseICEServer();
    message.urls = ((_a2 = object.urls) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2)) || [];
    message.username = (_b = object.username) !== null && _b !== void 0 ? _b : "";
    message.credential = (_c = object.credential) !== null && _c !== void 0 ? _c : "";
    return message;
  }
};
function createBaseSpeakersChanged() {
  return {
    speakers: []
  };
}
const SpeakersChanged = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    for (const v of message.speakers) {
      SpeakerInfo.encode(v, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSpeakersChanged();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.speakers.push(SpeakerInfo.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      speakers: Array.isArray(object === null || object === void 0 ? void 0 : object.speakers) ? object.speakers.map((e2) => SpeakerInfo.fromJSON(e2)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.speakers) {
      obj.speakers = message.speakers.map((e2) => e2 ? SpeakerInfo.toJSON(e2) : void 0);
    } else {
      obj.speakers = [];
    }
    return obj;
  },
  create(base) {
    return SpeakersChanged.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2;
    const message = createBaseSpeakersChanged();
    message.speakers = ((_a2 = object.speakers) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => SpeakerInfo.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseRoomUpdate() {
  return {
    room: void 0
  };
}
const RoomUpdate = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.room !== void 0) {
      Room$1.encode(message.room, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseRoomUpdate();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.room = Room$1.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      room: isSet(object.room) ? Room$1.fromJSON(object.room) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.room !== void 0 && (obj.room = message.room ? Room$1.toJSON(message.room) : void 0);
    return obj;
  },
  create(base) {
    return RoomUpdate.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    const message = createBaseRoomUpdate();
    message.room = object.room !== void 0 && object.room !== null ? Room$1.fromPartial(object.room) : void 0;
    return message;
  }
};
function createBaseConnectionQualityInfo() {
  return {
    participantSid: "",
    quality: 0,
    score: 0
  };
}
const ConnectionQualityInfo = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.participantSid !== "") {
      writer2.uint32(10).string(message.participantSid);
    }
    if (message.quality !== 0) {
      writer2.uint32(16).int32(message.quality);
    }
    if (message.score !== 0) {
      writer2.uint32(29).float(message.score);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseConnectionQualityInfo();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participantSid = reader2.string();
          break;
        case 2:
          message.quality = reader2.int32();
          break;
        case 3:
          message.score = reader2.float();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      participantSid: isSet(object.participantSid) ? String(object.participantSid) : "",
      quality: isSet(object.quality) ? connectionQualityFromJSON(object.quality) : 0,
      score: isSet(object.score) ? Number(object.score) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
    message.quality !== void 0 && (obj.quality = connectionQualityToJSON(message.quality));
    message.score !== void 0 && (obj.score = message.score);
    return obj;
  },
  create(base) {
    return ConnectionQualityInfo.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseConnectionQualityInfo();
    message.participantSid = (_a2 = object.participantSid) !== null && _a2 !== void 0 ? _a2 : "";
    message.quality = (_b = object.quality) !== null && _b !== void 0 ? _b : 0;
    message.score = (_c = object.score) !== null && _c !== void 0 ? _c : 0;
    return message;
  }
};
function createBaseConnectionQualityUpdate() {
  return {
    updates: []
  };
}
const ConnectionQualityUpdate = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    for (const v of message.updates) {
      ConnectionQualityInfo.encode(v, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseConnectionQualityUpdate();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.updates.push(ConnectionQualityInfo.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      updates: Array.isArray(object === null || object === void 0 ? void 0 : object.updates) ? object.updates.map((e2) => ConnectionQualityInfo.fromJSON(e2)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.updates) {
      obj.updates = message.updates.map((e2) => e2 ? ConnectionQualityInfo.toJSON(e2) : void 0);
    } else {
      obj.updates = [];
    }
    return obj;
  },
  create(base) {
    return ConnectionQualityUpdate.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2;
    const message = createBaseConnectionQualityUpdate();
    message.updates = ((_a2 = object.updates) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => ConnectionQualityInfo.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseStreamStateInfo() {
  return {
    participantSid: "",
    trackSid: "",
    state: 0
  };
}
const StreamStateInfo = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.participantSid !== "") {
      writer2.uint32(10).string(message.participantSid);
    }
    if (message.trackSid !== "") {
      writer2.uint32(18).string(message.trackSid);
    }
    if (message.state !== 0) {
      writer2.uint32(24).int32(message.state);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStreamStateInfo();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participantSid = reader2.string();
          break;
        case 2:
          message.trackSid = reader2.string();
          break;
        case 3:
          message.state = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      participantSid: isSet(object.participantSid) ? String(object.participantSid) : "",
      trackSid: isSet(object.trackSid) ? String(object.trackSid) : "",
      state: isSet(object.state) ? streamStateFromJSON(object.state) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);
    message.state !== void 0 && (obj.state = streamStateToJSON(message.state));
    return obj;
  },
  create(base) {
    return StreamStateInfo.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseStreamStateInfo();
    message.participantSid = (_a2 = object.participantSid) !== null && _a2 !== void 0 ? _a2 : "";
    message.trackSid = (_b = object.trackSid) !== null && _b !== void 0 ? _b : "";
    message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;
    return message;
  }
};
function createBaseStreamStateUpdate() {
  return {
    streamStates: []
  };
}
const StreamStateUpdate = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    for (const v of message.streamStates) {
      StreamStateInfo.encode(v, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStreamStateUpdate();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.streamStates.push(StreamStateInfo.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      streamStates: Array.isArray(object === null || object === void 0 ? void 0 : object.streamStates) ? object.streamStates.map((e2) => StreamStateInfo.fromJSON(e2)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.streamStates) {
      obj.streamStates = message.streamStates.map((e2) => e2 ? StreamStateInfo.toJSON(e2) : void 0);
    } else {
      obj.streamStates = [];
    }
    return obj;
  },
  create(base) {
    return StreamStateUpdate.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2;
    const message = createBaseStreamStateUpdate();
    message.streamStates = ((_a2 = object.streamStates) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => StreamStateInfo.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseSubscribedQuality() {
  return {
    quality: 0,
    enabled: false
  };
}
const SubscribedQuality = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.quality !== 0) {
      writer2.uint32(8).int32(message.quality);
    }
    if (message.enabled === true) {
      writer2.uint32(16).bool(message.enabled);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSubscribedQuality();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.quality = reader2.int32();
          break;
        case 2:
          message.enabled = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      quality: isSet(object.quality) ? videoQualityFromJSON(object.quality) : 0,
      enabled: isSet(object.enabled) ? Boolean(object.enabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.quality !== void 0 && (obj.quality = videoQualityToJSON(message.quality));
    message.enabled !== void 0 && (obj.enabled = message.enabled);
    return obj;
  },
  create(base) {
    return SubscribedQuality.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseSubscribedQuality();
    message.quality = (_a2 = object.quality) !== null && _a2 !== void 0 ? _a2 : 0;
    message.enabled = (_b = object.enabled) !== null && _b !== void 0 ? _b : false;
    return message;
  }
};
function createBaseSubscribedCodec() {
  return {
    codec: "",
    qualities: []
  };
}
const SubscribedCodec = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.codec !== "") {
      writer2.uint32(10).string(message.codec);
    }
    for (const v of message.qualities) {
      SubscribedQuality.encode(v, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSubscribedCodec();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.codec = reader2.string();
          break;
        case 2:
          message.qualities.push(SubscribedQuality.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      codec: isSet(object.codec) ? String(object.codec) : "",
      qualities: Array.isArray(object === null || object === void 0 ? void 0 : object.qualities) ? object.qualities.map((e2) => SubscribedQuality.fromJSON(e2)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.codec !== void 0 && (obj.codec = message.codec);
    if (message.qualities) {
      obj.qualities = message.qualities.map((e2) => e2 ? SubscribedQuality.toJSON(e2) : void 0);
    } else {
      obj.qualities = [];
    }
    return obj;
  },
  create(base) {
    return SubscribedCodec.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseSubscribedCodec();
    message.codec = (_a2 = object.codec) !== null && _a2 !== void 0 ? _a2 : "";
    message.qualities = ((_b = object.qualities) === null || _b === void 0 ? void 0 : _b.map((e2) => SubscribedQuality.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseSubscribedQualityUpdate() {
  return {
    trackSid: "",
    subscribedQualities: [],
    subscribedCodecs: []
  };
}
const SubscribedQualityUpdate = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.trackSid !== "") {
      writer2.uint32(10).string(message.trackSid);
    }
    for (const v of message.subscribedQualities) {
      SubscribedQuality.encode(v, writer2.uint32(18).fork()).ldelim();
    }
    for (const v of message.subscribedCodecs) {
      SubscribedCodec.encode(v, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSubscribedQualityUpdate();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.trackSid = reader2.string();
          break;
        case 2:
          message.subscribedQualities.push(SubscribedQuality.decode(reader2, reader2.uint32()));
          break;
        case 3:
          message.subscribedCodecs.push(SubscribedCodec.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      trackSid: isSet(object.trackSid) ? String(object.trackSid) : "",
      subscribedQualities: Array.isArray(object === null || object === void 0 ? void 0 : object.subscribedQualities) ? object.subscribedQualities.map((e2) => SubscribedQuality.fromJSON(e2)) : [],
      subscribedCodecs: Array.isArray(object === null || object === void 0 ? void 0 : object.subscribedCodecs) ? object.subscribedCodecs.map((e2) => SubscribedCodec.fromJSON(e2)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);
    if (message.subscribedQualities) {
      obj.subscribedQualities = message.subscribedQualities.map((e2) => e2 ? SubscribedQuality.toJSON(e2) : void 0);
    } else {
      obj.subscribedQualities = [];
    }
    if (message.subscribedCodecs) {
      obj.subscribedCodecs = message.subscribedCodecs.map((e2) => e2 ? SubscribedCodec.toJSON(e2) : void 0);
    } else {
      obj.subscribedCodecs = [];
    }
    return obj;
  },
  create(base) {
    return SubscribedQualityUpdate.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseSubscribedQualityUpdate();
    message.trackSid = (_a2 = object.trackSid) !== null && _a2 !== void 0 ? _a2 : "";
    message.subscribedQualities = ((_b = object.subscribedQualities) === null || _b === void 0 ? void 0 : _b.map((e2) => SubscribedQuality.fromPartial(e2))) || [];
    message.subscribedCodecs = ((_c = object.subscribedCodecs) === null || _c === void 0 ? void 0 : _c.map((e2) => SubscribedCodec.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseTrackPermission() {
  return {
    participantSid: "",
    allTracks: false,
    trackSids: [],
    participantIdentity: ""
  };
}
const TrackPermission = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.participantSid !== "") {
      writer2.uint32(10).string(message.participantSid);
    }
    if (message.allTracks === true) {
      writer2.uint32(16).bool(message.allTracks);
    }
    for (const v of message.trackSids) {
      writer2.uint32(26).string(v);
    }
    if (message.participantIdentity !== "") {
      writer2.uint32(34).string(message.participantIdentity);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTrackPermission();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participantSid = reader2.string();
          break;
        case 2:
          message.allTracks = reader2.bool();
          break;
        case 3:
          message.trackSids.push(reader2.string());
          break;
        case 4:
          message.participantIdentity = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      participantSid: isSet(object.participantSid) ? String(object.participantSid) : "",
      allTracks: isSet(object.allTracks) ? Boolean(object.allTracks) : false,
      trackSids: Array.isArray(object === null || object === void 0 ? void 0 : object.trackSids) ? object.trackSids.map((e2) => String(e2)) : [],
      participantIdentity: isSet(object.participantIdentity) ? String(object.participantIdentity) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
    message.allTracks !== void 0 && (obj.allTracks = message.allTracks);
    if (message.trackSids) {
      obj.trackSids = message.trackSids.map((e2) => e2);
    } else {
      obj.trackSids = [];
    }
    message.participantIdentity !== void 0 && (obj.participantIdentity = message.participantIdentity);
    return obj;
  },
  create(base) {
    return TrackPermission.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d;
    const message = createBaseTrackPermission();
    message.participantSid = (_a2 = object.participantSid) !== null && _a2 !== void 0 ? _a2 : "";
    message.allTracks = (_b = object.allTracks) !== null && _b !== void 0 ? _b : false;
    message.trackSids = ((_c = object.trackSids) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
    message.participantIdentity = (_d = object.participantIdentity) !== null && _d !== void 0 ? _d : "";
    return message;
  }
};
function createBaseSubscriptionPermission() {
  return {
    allParticipants: false,
    trackPermissions: []
  };
}
const SubscriptionPermission = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.allParticipants === true) {
      writer2.uint32(8).bool(message.allParticipants);
    }
    for (const v of message.trackPermissions) {
      TrackPermission.encode(v, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSubscriptionPermission();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.allParticipants = reader2.bool();
          break;
        case 2:
          message.trackPermissions.push(TrackPermission.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      allParticipants: isSet(object.allParticipants) ? Boolean(object.allParticipants) : false,
      trackPermissions: Array.isArray(object === null || object === void 0 ? void 0 : object.trackPermissions) ? object.trackPermissions.map((e2) => TrackPermission.fromJSON(e2)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.allParticipants !== void 0 && (obj.allParticipants = message.allParticipants);
    if (message.trackPermissions) {
      obj.trackPermissions = message.trackPermissions.map((e2) => e2 ? TrackPermission.toJSON(e2) : void 0);
    } else {
      obj.trackPermissions = [];
    }
    return obj;
  },
  create(base) {
    return SubscriptionPermission.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseSubscriptionPermission();
    message.allParticipants = (_a2 = object.allParticipants) !== null && _a2 !== void 0 ? _a2 : false;
    message.trackPermissions = ((_b = object.trackPermissions) === null || _b === void 0 ? void 0 : _b.map((e2) => TrackPermission.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseSubscriptionPermissionUpdate() {
  return {
    participantSid: "",
    trackSid: "",
    allowed: false
  };
}
const SubscriptionPermissionUpdate = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.participantSid !== "") {
      writer2.uint32(10).string(message.participantSid);
    }
    if (message.trackSid !== "") {
      writer2.uint32(18).string(message.trackSid);
    }
    if (message.allowed === true) {
      writer2.uint32(24).bool(message.allowed);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSubscriptionPermissionUpdate();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.participantSid = reader2.string();
          break;
        case 2:
          message.trackSid = reader2.string();
          break;
        case 3:
          message.allowed = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      participantSid: isSet(object.participantSid) ? String(object.participantSid) : "",
      trackSid: isSet(object.trackSid) ? String(object.trackSid) : "",
      allowed: isSet(object.allowed) ? Boolean(object.allowed) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.participantSid !== void 0 && (obj.participantSid = message.participantSid);
    message.trackSid !== void 0 && (obj.trackSid = message.trackSid);
    message.allowed !== void 0 && (obj.allowed = message.allowed);
    return obj;
  },
  create(base) {
    return SubscriptionPermissionUpdate.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseSubscriptionPermissionUpdate();
    message.participantSid = (_a2 = object.participantSid) !== null && _a2 !== void 0 ? _a2 : "";
    message.trackSid = (_b = object.trackSid) !== null && _b !== void 0 ? _b : "";
    message.allowed = (_c = object.allowed) !== null && _c !== void 0 ? _c : false;
    return message;
  }
};
function createBaseSyncState() {
  return {
    answer: void 0,
    subscription: void 0,
    publishTracks: [],
    dataChannels: [],
    offer: void 0
  };
}
const SyncState = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.answer !== void 0) {
      SessionDescription.encode(message.answer, writer2.uint32(10).fork()).ldelim();
    }
    if (message.subscription !== void 0) {
      UpdateSubscription.encode(message.subscription, writer2.uint32(18).fork()).ldelim();
    }
    for (const v of message.publishTracks) {
      TrackPublishedResponse.encode(v, writer2.uint32(26).fork()).ldelim();
    }
    for (const v of message.dataChannels) {
      DataChannelInfo.encode(v, writer2.uint32(34).fork()).ldelim();
    }
    if (message.offer !== void 0) {
      SessionDescription.encode(message.offer, writer2.uint32(42).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSyncState();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.answer = SessionDescription.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.subscription = UpdateSubscription.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.publishTracks.push(TrackPublishedResponse.decode(reader2, reader2.uint32()));
          break;
        case 4:
          message.dataChannels.push(DataChannelInfo.decode(reader2, reader2.uint32()));
          break;
        case 5:
          message.offer = SessionDescription.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      answer: isSet(object.answer) ? SessionDescription.fromJSON(object.answer) : void 0,
      subscription: isSet(object.subscription) ? UpdateSubscription.fromJSON(object.subscription) : void 0,
      publishTracks: Array.isArray(object === null || object === void 0 ? void 0 : object.publishTracks) ? object.publishTracks.map((e2) => TrackPublishedResponse.fromJSON(e2)) : [],
      dataChannels: Array.isArray(object === null || object === void 0 ? void 0 : object.dataChannels) ? object.dataChannels.map((e2) => DataChannelInfo.fromJSON(e2)) : [],
      offer: isSet(object.offer) ? SessionDescription.fromJSON(object.offer) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.answer !== void 0 && (obj.answer = message.answer ? SessionDescription.toJSON(message.answer) : void 0);
    message.subscription !== void 0 && (obj.subscription = message.subscription ? UpdateSubscription.toJSON(message.subscription) : void 0);
    if (message.publishTracks) {
      obj.publishTracks = message.publishTracks.map((e2) => e2 ? TrackPublishedResponse.toJSON(e2) : void 0);
    } else {
      obj.publishTracks = [];
    }
    if (message.dataChannels) {
      obj.dataChannels = message.dataChannels.map((e2) => e2 ? DataChannelInfo.toJSON(e2) : void 0);
    } else {
      obj.dataChannels = [];
    }
    message.offer !== void 0 && (obj.offer = message.offer ? SessionDescription.toJSON(message.offer) : void 0);
    return obj;
  },
  create(base) {
    return SyncState.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBaseSyncState();
    message.answer = object.answer !== void 0 && object.answer !== null ? SessionDescription.fromPartial(object.answer) : void 0;
    message.subscription = object.subscription !== void 0 && object.subscription !== null ? UpdateSubscription.fromPartial(object.subscription) : void 0;
    message.publishTracks = ((_a2 = object.publishTracks) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => TrackPublishedResponse.fromPartial(e2))) || [];
    message.dataChannels = ((_b = object.dataChannels) === null || _b === void 0 ? void 0 : _b.map((e2) => DataChannelInfo.fromPartial(e2))) || [];
    message.offer = object.offer !== void 0 && object.offer !== null ? SessionDescription.fromPartial(object.offer) : void 0;
    return message;
  }
};
function createBaseDataChannelInfo() {
  return {
    label: "",
    id: 0,
    target: 0
  };
}
const DataChannelInfo = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.label !== "") {
      writer2.uint32(10).string(message.label);
    }
    if (message.id !== 0) {
      writer2.uint32(16).uint32(message.id);
    }
    if (message.target !== 0) {
      writer2.uint32(24).int32(message.target);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDataChannelInfo();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.label = reader2.string();
          break;
        case 2:
          message.id = reader2.uint32();
          break;
        case 3:
          message.target = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      label: isSet(object.label) ? String(object.label) : "",
      id: isSet(object.id) ? Number(object.id) : 0,
      target: isSet(object.target) ? signalTargetFromJSON(object.target) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.label !== void 0 && (obj.label = message.label);
    message.id !== void 0 && (obj.id = Math.round(message.id));
    message.target !== void 0 && (obj.target = signalTargetToJSON(message.target));
    return obj;
  },
  create(base) {
    return DataChannelInfo.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c;
    const message = createBaseDataChannelInfo();
    message.label = (_a2 = object.label) !== null && _a2 !== void 0 ? _a2 : "";
    message.id = (_b = object.id) !== null && _b !== void 0 ? _b : 0;
    message.target = (_c = object.target) !== null && _c !== void 0 ? _c : 0;
    return message;
  }
};
function createBaseSimulateScenario() {
  return {
    scenario: void 0
  };
}
const SimulateScenario = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    var _a2;
    switch ((_a2 = message.scenario) === null || _a2 === void 0 ? void 0 : _a2.$case) {
      case "speakerUpdate":
        writer2.uint32(8).int32(message.scenario.speakerUpdate);
        break;
      case "nodeFailure":
        writer2.uint32(16).bool(message.scenario.nodeFailure);
        break;
      case "migration":
        writer2.uint32(24).bool(message.scenario.migration);
        break;
      case "serverLeave":
        writer2.uint32(32).bool(message.scenario.serverLeave);
        break;
      case "switchCandidateProtocol":
        writer2.uint32(40).int32(message.scenario.switchCandidateProtocol);
        break;
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSimulateScenario();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.scenario = {
            $case: "speakerUpdate",
            speakerUpdate: reader2.int32()
          };
          break;
        case 2:
          message.scenario = {
            $case: "nodeFailure",
            nodeFailure: reader2.bool()
          };
          break;
        case 3:
          message.scenario = {
            $case: "migration",
            migration: reader2.bool()
          };
          break;
        case 4:
          message.scenario = {
            $case: "serverLeave",
            serverLeave: reader2.bool()
          };
          break;
        case 5:
          message.scenario = {
            $case: "switchCandidateProtocol",
            switchCandidateProtocol: reader2.int32()
          };
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      scenario: isSet(object.speakerUpdate) ? {
        $case: "speakerUpdate",
        speakerUpdate: Number(object.speakerUpdate)
      } : isSet(object.nodeFailure) ? {
        $case: "nodeFailure",
        nodeFailure: Boolean(object.nodeFailure)
      } : isSet(object.migration) ? {
        $case: "migration",
        migration: Boolean(object.migration)
      } : isSet(object.serverLeave) ? {
        $case: "serverLeave",
        serverLeave: Boolean(object.serverLeave)
      } : isSet(object.switchCandidateProtocol) ? {
        $case: "switchCandidateProtocol",
        switchCandidateProtocol: candidateProtocolFromJSON(object.switchCandidateProtocol)
      } : void 0
    };
  },
  toJSON(message) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const obj = {};
    ((_a2 = message.scenario) === null || _a2 === void 0 ? void 0 : _a2.$case) === "speakerUpdate" && (obj.speakerUpdate = Math.round((_b = message.scenario) === null || _b === void 0 ? void 0 : _b.speakerUpdate));
    ((_c = message.scenario) === null || _c === void 0 ? void 0 : _c.$case) === "nodeFailure" && (obj.nodeFailure = (_d = message.scenario) === null || _d === void 0 ? void 0 : _d.nodeFailure);
    ((_e = message.scenario) === null || _e === void 0 ? void 0 : _e.$case) === "migration" && (obj.migration = (_f = message.scenario) === null || _f === void 0 ? void 0 : _f.migration);
    ((_g = message.scenario) === null || _g === void 0 ? void 0 : _g.$case) === "serverLeave" && (obj.serverLeave = (_h = message.scenario) === null || _h === void 0 ? void 0 : _h.serverLeave);
    ((_j = message.scenario) === null || _j === void 0 ? void 0 : _j.$case) === "switchCandidateProtocol" && (obj.switchCandidateProtocol = ((_k = message.scenario) === null || _k === void 0 ? void 0 : _k.switchCandidateProtocol) !== void 0 ? candidateProtocolToJSON((_l = message.scenario) === null || _l === void 0 ? void 0 : _l.switchCandidateProtocol) : void 0);
    return obj;
  },
  create(base) {
    return SimulateScenario.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    const message = createBaseSimulateScenario();
    if (((_a2 = object.scenario) === null || _a2 === void 0 ? void 0 : _a2.$case) === "speakerUpdate" && ((_b = object.scenario) === null || _b === void 0 ? void 0 : _b.speakerUpdate) !== void 0 && ((_c = object.scenario) === null || _c === void 0 ? void 0 : _c.speakerUpdate) !== null) {
      message.scenario = {
        $case: "speakerUpdate",
        speakerUpdate: object.scenario.speakerUpdate
      };
    }
    if (((_d = object.scenario) === null || _d === void 0 ? void 0 : _d.$case) === "nodeFailure" && ((_e = object.scenario) === null || _e === void 0 ? void 0 : _e.nodeFailure) !== void 0 && ((_f = object.scenario) === null || _f === void 0 ? void 0 : _f.nodeFailure) !== null) {
      message.scenario = {
        $case: "nodeFailure",
        nodeFailure: object.scenario.nodeFailure
      };
    }
    if (((_g = object.scenario) === null || _g === void 0 ? void 0 : _g.$case) === "migration" && ((_h = object.scenario) === null || _h === void 0 ? void 0 : _h.migration) !== void 0 && ((_j = object.scenario) === null || _j === void 0 ? void 0 : _j.migration) !== null) {
      message.scenario = {
        $case: "migration",
        migration: object.scenario.migration
      };
    }
    if (((_k = object.scenario) === null || _k === void 0 ? void 0 : _k.$case) === "serverLeave" && ((_l = object.scenario) === null || _l === void 0 ? void 0 : _l.serverLeave) !== void 0 && ((_m = object.scenario) === null || _m === void 0 ? void 0 : _m.serverLeave) !== null) {
      message.scenario = {
        $case: "serverLeave",
        serverLeave: object.scenario.serverLeave
      };
    }
    if (((_o = object.scenario) === null || _o === void 0 ? void 0 : _o.$case) === "switchCandidateProtocol" && ((_p = object.scenario) === null || _p === void 0 ? void 0 : _p.switchCandidateProtocol) !== void 0 && ((_q = object.scenario) === null || _q === void 0 ? void 0 : _q.switchCandidateProtocol) !== null) {
      message.scenario = {
        $case: "switchCandidateProtocol",
        switchCandidateProtocol: object.scenario.switchCandidateProtocol
      };
    }
    return message;
  }
};
function createBasePing() {
  return {
    timestamp: 0,
    rtt: 0
  };
}
const Ping = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.timestamp !== 0) {
      writer2.uint32(8).int64(message.timestamp);
    }
    if (message.rtt !== 0) {
      writer2.uint32(16).int64(message.rtt);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBasePing();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.timestamp = longToNumber(reader2.int64());
          break;
        case 2:
          message.rtt = longToNumber(reader2.int64());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      timestamp: isSet(object.timestamp) ? Number(object.timestamp) : 0,
      rtt: isSet(object.rtt) ? Number(object.rtt) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));
    message.rtt !== void 0 && (obj.rtt = Math.round(message.rtt));
    return obj;
  },
  create(base) {
    return Ping.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBasePing();
    message.timestamp = (_a2 = object.timestamp) !== null && _a2 !== void 0 ? _a2 : 0;
    message.rtt = (_b = object.rtt) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function createBasePong() {
  return {
    lastPingTimestamp: 0,
    timestamp: 0
  };
}
const Pong = {
  encode(message) {
    let writer2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _m0.Writer.create();
    if (message.lastPingTimestamp !== 0) {
      writer2.uint32(8).int64(message.lastPingTimestamp);
    }
    if (message.timestamp !== 0) {
      writer2.uint32(16).int64(message.timestamp);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end3 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBasePong();
    while (reader2.pos < end3) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.lastPingTimestamp = longToNumber(reader2.int64());
          break;
        case 2:
          message.timestamp = longToNumber(reader2.int64());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      lastPingTimestamp: isSet(object.lastPingTimestamp) ? Number(object.lastPingTimestamp) : 0,
      timestamp: isSet(object.timestamp) ? Number(object.timestamp) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.lastPingTimestamp !== void 0 && (obj.lastPingTimestamp = Math.round(message.lastPingTimestamp));
    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));
    return obj;
  },
  create(base) {
    return Pong.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a2, _b;
    const message = createBasePong();
    message.lastPingTimestamp = (_a2 = object.lastPingTimestamp) !== null && _a2 !== void 0 ? _a2 : 0;
    message.timestamp = (_b = object.timestamp) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
var tsProtoGlobalThis = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function longToNumber(long2) {
  if (long2.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long2.toNumber();
}
if (_m0.util.Long !== long) {
  _m0.util.Long = long;
  _m0.configure();
}
function isSet(value) {
  return value !== null && value !== void 0;
}
class LivekitError extends Error {
  constructor(code, message) {
    super(message || "an error has occured");
    this.code = code;
  }
}
class ConnectionError extends LivekitError {
  constructor(message, reason, status) {
    super(1, message);
    this.status = status;
    this.reason = reason;
  }
}
class DeviceUnsupportedError extends LivekitError {
  constructor(message) {
    super(21, message !== null && message !== void 0 ? message : "device is unsupported");
  }
}
class TrackInvalidError extends LivekitError {
  constructor(message) {
    super(20, message !== null && message !== void 0 ? message : "track is invalid");
  }
}
class UnsupportedServer extends LivekitError {
  constructor(message) {
    super(10, message !== null && message !== void 0 ? message : "unsupported server");
  }
}
class UnexpectedConnectionState extends LivekitError {
  constructor(message) {
    super(12, message !== null && message !== void 0 ? message : "unexpected connection state");
  }
}
class NegotiationError extends LivekitError {
  constructor(message) {
    super(13, message !== null && message !== void 0 ? message : "unable to negotiate");
  }
}
var MediaDeviceFailure;
(function(MediaDeviceFailure2) {
  MediaDeviceFailure2["PermissionDenied"] = "PermissionDenied";
  MediaDeviceFailure2["NotFound"] = "NotFound";
  MediaDeviceFailure2["DeviceInUse"] = "DeviceInUse";
  MediaDeviceFailure2["Other"] = "Other";
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
(function(MediaDeviceFailure2) {
  function getFailure(error) {
    if (error && "name" in error) {
      if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") {
        return MediaDeviceFailure2.NotFound;
      }
      if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
        return MediaDeviceFailure2.PermissionDenied;
      }
      if (error.name === "NotReadableError" || error.name === "TrackStartError") {
        return MediaDeviceFailure2.DeviceInUse;
      }
      return MediaDeviceFailure2.Other;
    }
  }
  MediaDeviceFailure2.getFailure = getFailure;
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
var RoomEvent;
(function(RoomEvent2) {
  RoomEvent2["Connected"] = "connected";
  RoomEvent2["Reconnecting"] = "reconnecting";
  RoomEvent2["Reconnected"] = "reconnected";
  RoomEvent2["Disconnected"] = "disconnected";
  RoomEvent2["ConnectionStateChanged"] = "connectionStateChanged";
  RoomEvent2["StateChanged"] = "connectionStateChanged";
  RoomEvent2["MediaDevicesChanged"] = "mediaDevicesChanged";
  RoomEvent2["ParticipantConnected"] = "participantConnected";
  RoomEvent2["ParticipantDisconnected"] = "participantDisconnected";
  RoomEvent2["TrackPublished"] = "trackPublished";
  RoomEvent2["TrackSubscribed"] = "trackSubscribed";
  RoomEvent2["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
  RoomEvent2["TrackUnpublished"] = "trackUnpublished";
  RoomEvent2["TrackUnsubscribed"] = "trackUnsubscribed";
  RoomEvent2["TrackMuted"] = "trackMuted";
  RoomEvent2["TrackUnmuted"] = "trackUnmuted";
  RoomEvent2["LocalTrackPublished"] = "localTrackPublished";
  RoomEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
  RoomEvent2["ActiveSpeakersChanged"] = "activeSpeakersChanged";
  RoomEvent2["ParticipantMetadataChanged"] = "participantMetadataChanged";
  RoomEvent2["RoomMetadataChanged"] = "roomMetadataChanged";
  RoomEvent2["DataReceived"] = "dataReceived";
  RoomEvent2["ConnectionQualityChanged"] = "connectionQualityChanged";
  RoomEvent2["TrackStreamStateChanged"] = "trackStreamStateChanged";
  RoomEvent2["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";
  RoomEvent2["TrackSubscriptionStatusChanged"] = "trackSubscriptionStatusChanged";
  RoomEvent2["AudioPlaybackStatusChanged"] = "audioPlaybackChanged";
  RoomEvent2["MediaDevicesError"] = "mediaDevicesError";
  RoomEvent2["ParticipantPermissionsChanged"] = "participantPermissionsChanged";
  RoomEvent2["SignalConnected"] = "signalConnected";
  RoomEvent2["RecordingStatusChanged"] = "recordingStatusChanged";
})(RoomEvent || (RoomEvent = {}));
var ParticipantEvent;
(function(ParticipantEvent2) {
  ParticipantEvent2["TrackPublished"] = "trackPublished";
  ParticipantEvent2["TrackSubscribed"] = "trackSubscribed";
  ParticipantEvent2["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
  ParticipantEvent2["TrackUnpublished"] = "trackUnpublished";
  ParticipantEvent2["TrackUnsubscribed"] = "trackUnsubscribed";
  ParticipantEvent2["TrackMuted"] = "trackMuted";
  ParticipantEvent2["TrackUnmuted"] = "trackUnmuted";
  ParticipantEvent2["LocalTrackPublished"] = "localTrackPublished";
  ParticipantEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
  ParticipantEvent2["ParticipantMetadataChanged"] = "participantMetadataChanged";
  ParticipantEvent2["DataReceived"] = "dataReceived";
  ParticipantEvent2["IsSpeakingChanged"] = "isSpeakingChanged";
  ParticipantEvent2["ConnectionQualityChanged"] = "connectionQualityChanged";
  ParticipantEvent2["TrackStreamStateChanged"] = "trackStreamStateChanged";
  ParticipantEvent2["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";
  ParticipantEvent2["TrackSubscriptionStatusChanged"] = "trackSubscriptionStatusChanged";
  ParticipantEvent2["MediaDevicesError"] = "mediaDevicesError";
  ParticipantEvent2["ParticipantPermissionsChanged"] = "participantPermissionsChanged";
})(ParticipantEvent || (ParticipantEvent = {}));
var EngineEvent;
(function(EngineEvent2) {
  EngineEvent2["TransportsCreated"] = "transportsCreated";
  EngineEvent2["Connected"] = "connected";
  EngineEvent2["Disconnected"] = "disconnected";
  EngineEvent2["Resuming"] = "resuming";
  EngineEvent2["Resumed"] = "resumed";
  EngineEvent2["Restarting"] = "restarting";
  EngineEvent2["Restarted"] = "restarted";
  EngineEvent2["SignalResumed"] = "signalResumed";
  EngineEvent2["Closing"] = "closing";
  EngineEvent2["MediaTrackAdded"] = "mediaTrackAdded";
  EngineEvent2["ActiveSpeakersUpdate"] = "activeSpeakersUpdate";
  EngineEvent2["DataPacketReceived"] = "dataPacketReceived";
})(EngineEvent || (EngineEvent = {}));
var TrackEvent;
(function(TrackEvent2) {
  TrackEvent2["Message"] = "message";
  TrackEvent2["Muted"] = "muted";
  TrackEvent2["Unmuted"] = "unmuted";
  TrackEvent2["Restarted"] = "restarted";
  TrackEvent2["Ended"] = "ended";
  TrackEvent2["Subscribed"] = "subscribed";
  TrackEvent2["Unsubscribed"] = "unsubscribed";
  TrackEvent2["UpdateSettings"] = "updateSettings";
  TrackEvent2["UpdateSubscription"] = "updateSubscription";
  TrackEvent2["AudioPlaybackStarted"] = "audioPlaybackStarted";
  TrackEvent2["AudioPlaybackFailed"] = "audioPlaybackFailed";
  TrackEvent2["AudioSilenceDetected"] = "audioSilenceDetected";
  TrackEvent2["VisibilityChanged"] = "visibilityChanged";
  TrackEvent2["VideoDimensionsChanged"] = "videoDimensionsChanged";
  TrackEvent2["ElementAttached"] = "elementAttached";
  TrackEvent2["ElementDetached"] = "elementDetached";
  TrackEvent2["UpstreamPaused"] = "upstreamPaused";
  TrackEvent2["UpstreamResumed"] = "upstreamResumed";
  TrackEvent2["SubscriptionPermissionChanged"] = "subscriptionPermissionChanged";
  TrackEvent2["SubscriptionStatusChanged"] = "subscriptionStatusChanged";
})(TrackEvent || (TrackEvent = {}));
const monitorFrequency = 2e3;
function computeBitrate(currentStats, prevStats) {
  if (!prevStats) {
    return 0;
  }
  let bytesNow;
  let bytesPrev;
  if ("bytesReceived" in currentStats) {
    bytesNow = currentStats.bytesReceived;
    bytesPrev = prevStats.bytesReceived;
  } else if ("bytesSent" in currentStats) {
    bytesNow = currentStats.bytesSent;
    bytesPrev = prevStats.bytesSent;
  }
  if (bytesNow === void 0 || bytesPrev === void 0 || currentStats.timestamp === void 0 || prevStats.timestamp === void 0) {
    return 0;
  }
  return (bytesNow - bytesPrev) * 8 * 1e3 / (currentStats.timestamp - prevStats.timestamp);
}
var uaParserExports = {};
var uaParser = {
  get exports() {
    return uaParserExports;
  },
  set exports(v) {
    uaParserExports = v;
  }
};
(function(module2, exports2) {
  (function(window2, undefined$1) {
    var LIBVERSION = "1.0.33", EMPTY2 = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 350;
    var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook";
    var extend2 = function(regexes2, extensions) {
      var mergedRegexes = {};
      for (var i2 in regexes2) {
        if (extensions[i2] && extensions[i2].length % 2 === 0) {
          mergedRegexes[i2] = extensions[i2].concat(regexes2[i2]);
        } else {
          mergedRegexes[i2] = regexes2[i2];
        }
      }
      return mergedRegexes;
    }, enumerize = function(arr) {
      var enums = {};
      for (var i2 = 0; i2 < arr.length; i2++) {
        enums[arr[i2].toUpperCase()] = arr[i2];
      }
      return enums;
    }, has2 = function(str1, str2) {
      return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
    }, lowerize = function(str) {
      return str.toLowerCase();
    }, majorize = function(version2) {
      return typeof version2 === STR_TYPE ? version2.replace(/[^\d\.]/g, EMPTY2).split(".")[0] : undefined$1;
    }, trim2 = function(str, len) {
      if (typeof str === STR_TYPE) {
        str = str.replace(/^\s\s*/, EMPTY2);
        return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
      }
    };
    var rgxMapper = function(ua, arrays) {
      var i2 = 0, j, k, p, q, matches, match;
      while (i2 < arrays.length && !matches) {
        var regex = arrays[i2], props = arrays[i2 + 1];
        j = k = 0;
        while (j < regex.length && !matches) {
          matches = regex[j++].exec(ua);
          if (!!matches) {
            for (p = 0; p < props.length; p++) {
              match = matches[++k];
              q = props[p];
              if (typeof q === OBJ_TYPE && q.length > 0) {
                if (q.length === 2) {
                  if (typeof q[1] == FUNC_TYPE) {
                    this[q[0]] = q[1].call(this, match);
                  } else {
                    this[q[0]] = q[1];
                  }
                } else if (q.length === 3) {
                  if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                    this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined$1;
                  } else {
                    this[q[0]] = match ? match.replace(q[1], q[2]) : undefined$1;
                  }
                } else if (q.length === 4) {
                  this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined$1;
                }
              } else {
                this[q] = match ? match : undefined$1;
              }
            }
          }
        }
        i2 += 2;
      }
    }, strMapper = function(str, map2) {
      for (var i2 in map2) {
        if (typeof map2[i2] === OBJ_TYPE && map2[i2].length > 0) {
          for (var j = 0; j < map2[i2].length; j++) {
            if (has2(map2[i2][j], str)) {
              return i2 === UNKNOWN ? undefined$1 : i2;
            }
          }
        } else if (has2(map2[i2], str)) {
          return i2 === UNKNOWN ? undefined$1 : i2;
        }
      }
      return str;
    };
    var oldSafariMap = {
      "1.0": "/8",
      "1.2": "/1",
      "1.3": "/3",
      "2.0": "/412",
      "2.0.2": "/416",
      "2.0.3": "/417",
      "2.0.4": "/419",
      "?": "/"
    }, windowsVersionMap = {
      "ME": "4.90",
      "NT 3.11": "NT3.51",
      "NT 4.0": "NT4.0",
      "2000": "NT 5.0",
      "XP": ["NT 5.1", "NT 5.2"],
      "Vista": "NT 6.0",
      "7": "NT 6.1",
      "8": "NT 6.2",
      "8.1": "NT 6.3",
      "10": ["NT 6.4", "NT 10.0"],
      "RT": "ARM"
    };
    var regexes = {
      browser: [[
        /\b(?:crmo|crios)\/([\w\.]+)/i
      ], [VERSION, [NAME, "Chrome"]], [
        /edg(?:e|ios|a)?\/([\w\.]+)/i
      ], [VERSION, [NAME, "Edge"]], [
        /(opera mini)\/([-\w\.]+)/i,
        /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
        /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
      ], [NAME, VERSION], [
        /opios[\/ ]+([\w\.]+)/i
      ], [VERSION, [NAME, OPERA + " Mini"]], [
        /\bopr\/([\w\.]+)/i
      ], [VERSION, [NAME, OPERA]], [
        /(kindle)\/([\w\.]+)/i,
        /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
        /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,
        /(ba?idubrowser)[\/ ]?([\w\.]+)/i,
        /(?:ms|\()(ie) ([\w\.]+)/i,
        /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
        /(weibo)__([\d\.]+)/i
      ], [NAME, VERSION], [
        /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
      ], [VERSION, [NAME, "UC" + BROWSER]], [
        /microm.+\bqbcore\/([\w\.]+)/i,
        /\bqbcore\/([\w\.]+).+microm/i
      ], [VERSION, [NAME, "WeChat(Win) Desktop"]], [
        /micromessenger\/([\w\.]+)/i
      ], [VERSION, [NAME, "WeChat"]], [
        /konqueror\/([\w\.]+)/i
      ], [VERSION, [NAME, "Konqueror"]], [
        /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
      ], [VERSION, [NAME, "IE"]], [
        /yabrowser\/([\w\.]+)/i
      ], [VERSION, [NAME, "Yandex"]], [
        /(avast|avg)\/([\w\.]+)/i
      ], [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION], [
        /\bfocus\/([\w\.]+)/i
      ], [VERSION, [NAME, FIREFOX + " Focus"]], [
        /\bopt\/([\w\.]+)/i
      ], [VERSION, [NAME, OPERA + " Touch"]], [
        /coc_coc\w+\/([\w\.]+)/i
      ], [VERSION, [NAME, "Coc Coc"]], [
        /dolfin\/([\w\.]+)/i
      ], [VERSION, [NAME, "Dolphin"]], [
        /coast\/([\w\.]+)/i
      ], [VERSION, [NAME, OPERA + " Coast"]], [
        /miuibrowser\/([\w\.]+)/i
      ], [VERSION, [NAME, "MIUI " + BROWSER]], [
        /fxios\/([-\w\.]+)/i
      ], [VERSION, [NAME, FIREFOX]], [
        /\bqihu|(qi?ho?o?|360)browser/i
      ], [[NAME, "360 " + BROWSER]], [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i], [[NAME, /(.+)/, "$1 " + BROWSER], VERSION], [
        /(comodo_dragon)\/([\w\.]+)/i
      ], [[NAME, /_/g, " "], VERSION], [
        /(electron)\/([\w\.]+) safari/i,
        /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
        /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i
      ], [NAME, VERSION], [
        /(metasr)[\/ ]?([\w\.]+)/i,
        /(lbbrowser)/i,
        /\[(linkedin)app\]/i
      ], [NAME], [
        /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
      ], [[NAME, FACEBOOK], VERSION], [
        /safari (line)\/([\w\.]+)/i,
        /\b(line)\/([\w\.]+)\/iab/i,
        /(chromium|instagram)[\/ ]([-\w\.]+)/i
      ], [NAME, VERSION], [
        /\bgsa\/([\w\.]+) .*safari\//i
      ], [VERSION, [NAME, "GSA"]], [
        /headlesschrome(?:\/([\w\.]+)| )/i
      ], [VERSION, [NAME, CHROME + " Headless"]], [
        / wv\).+(chrome)\/([\w\.]+)/i
      ], [[NAME, CHROME + " WebView"], VERSION], [
        /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
      ], [VERSION, [NAME, "Android " + BROWSER]], [
        /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
      ], [NAME, VERSION], [
        /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
      ], [VERSION, [NAME, "Mobile Safari"]], [
        /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
      ], [VERSION, NAME], [
        /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
      ], [NAME, [VERSION, strMapper, oldSafariMap]], [/(webkit|khtml)\/([\w\.]+)/i], [NAME, VERSION], [
        /(navigator|netscape\d?)\/([-\w\.]+)/i
      ], [[NAME, "Netscape"], VERSION], [
        /mobile vr; rv:([\w\.]+)\).+firefox/i
      ], [VERSION, [NAME, FIREFOX + " Reality"]], [
        /ekiohf.+(flow)\/([\w\.]+)/i,
        /(swiftfox)/i,
        /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
        /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
        /(firefox)\/([\w\.]+)/i,
        /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
        /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
        /(links) \(([\w\.]+)/i
      ], [NAME, VERSION], [
        /(cobalt)\/([\w\.]+)/i
      ], [NAME, [VERSION, /master.|lts./, ""]]],
      cpu: [[
        /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i
      ], [[ARCHITECTURE, "amd64"]], [
        /(ia32(?=;))/i
      ], [[ARCHITECTURE, lowerize]], [
        /((?:i[346]|x)86)[;\)]/i
      ], [[ARCHITECTURE, "ia32"]], [
        /\b(aarch64|arm(v?8e?l?|_?64))\b/i
      ], [[ARCHITECTURE, "arm64"]], [
        /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i
      ], [[ARCHITECTURE, "armhf"]], [
        /windows (ce|mobile); ppc;/i
      ], [[ARCHITECTURE, "arm"]], [
        /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i
      ], [[ARCHITECTURE, /ower/, EMPTY2, lowerize]], [
        /(sun4\w)[;\)]/i
      ], [[ARCHITECTURE, "sparc"]], [
        /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
      ], [[ARCHITECTURE, lowerize]]],
      device: [[
        /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
      ], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [/\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [
        /\((ip(?:hone|od)[\w ]*);/i
      ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [
        /\((ipad);[-\w\),; ]+apple/i,
        /applecoremedia\/[\w\.]+ \((ipad)/i,
        /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
      ], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [/(macintosh);/i], [MODEL, [VENDOR, APPLE]], [
        /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
      ], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [
        /\b(poco[\w ]+)(?: bui|\))/i,
        /\b; (\w+) build\/hm\1/i,
        /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
        /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
        /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i
      ], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]], [
        /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i
      ], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]], [
        /; (\w+) bui.+ oppo/i,
        /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
      ], [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]], [
        /vivo (\w+)(?: bui|\))/i,
        /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
      ], [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]], [
        /\b(rmx[12]\d{3})(?: bui|;|\))/i
      ], [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]], [
        /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
        /\bmot(?:orola)?[- ](\w*)/i,
        /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
      ], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [
        /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
      ], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [
        /(ideatab[-\w ]+)/i,
        /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
      ], [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]], [
        /(?:maemo|nokia).*(n900|lumia \d+)/i,
        /nokia[-_ ]?([-\w\.]*)/i
      ], [[MODEL, /_/g, " "], [VENDOR, "Nokia"], [TYPE, MOBILE]], [
        /(pixel c)\b/i
      ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [
        /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
      ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [
        /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
      ], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]], [
        / (kb2005|in20[12]5|be20[12][59])\b/i,
        /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
      ], [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]], [
        /(alexa)webm/i,
        /(kf[a-z]{2}wi)( bui|\))/i,
        /(kf[a-z]+)( bui|\)).+silk\//i
      ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [
        /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
      ], [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]], [
        /(playbook);[-\w\),; ]+(rim)/i
      ], [MODEL, VENDOR, [TYPE, TABLET]], [
        /\b((?:bb[a-f]|st[hv])100-\d)/i,
        /\(bb10; (\w+)/i
      ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [
        /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
      ], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [
        /(nexus 9)/i
      ], [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]], [
        /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
        /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
        /(alcatel|geeksphone|nexian|panasonic|sony(?!-bra))[-_ ]?([-\w]*)/i
      ], [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]], [
        /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
      ], [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]], [
        /droid.+; (m[1-5] note) bui/i,
        /\bmz-([-\w]{2,})/i
      ], [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]], [
        /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
      ], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [
        /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
        /(hp) ([\w ]+\w)/i,
        /(asus)-?(\w+)/i,
        /(microsoft); (lumia[\w ]+)/i,
        /(lenovo)[-_ ]?([-\w]+)/i,
        /(jolla)/i,
        /(oppo) ?([\w ]+) bui/i
      ], [VENDOR, MODEL, [TYPE, MOBILE]], [
        /(archos) (gamepad2?)/i,
        /(hp).+(touchpad(?!.+tablet)|tablet)/i,
        /(kindle)\/([\w\.]+)/i,
        /(nook)[\w ]+build\/(\w+)/i,
        /(dell) (strea[kpr\d ]*[\dko])/i,
        /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
        /(trinity)[- ]*(t\d{3}) bui/i,
        /(gigaset)[- ]+(q\w{1,9}) bui/i,
        /(vodafone) ([\w ]+)(?:\)| bui)/i
      ], [VENDOR, MODEL, [TYPE, TABLET]], [
        /(surface duo)/i
      ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [
        /droid [\d\.]+; (fp\du?)(?: b|\))/i
      ], [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]], [
        /(u304aa)/i
      ], [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]], [
        /\bsie-(\w*)/i
      ], [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]], [
        /\b(rct\w+) b/i
      ], [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]], [
        /\b(venue[\d ]{2,7}) b/i
      ], [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]], [
        /\b(q(?:mv|ta)\w+) b/i
      ], [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]], [
        /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
      ], [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]], [/\b(tm\d{3}\w+) b/i], [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]], [
        /\b(k88) b/i
      ], [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]], [
        /\b(nx\d{3}j) b/i
      ], [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]], [
        /\b(gen\d{3}) b.+49h/i
      ], [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]], [
        /\b(zur\d{3}) b/i
      ], [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]], [
        /\b((zeki)?tb.*\b) b/i
      ], [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]], [
        /\b([yr]\d{2}) b/i,
        /\b(dragon[- ]+touch |dt)(\w{5}) b/i
      ], [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]], [
        /\b(ns-?\w{0,9}) b/i
      ], [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]], [
        /\b((nxa|next)-?\w{0,9}) b/i
      ], [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]], [
        /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
      ], [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]], [
        /\b(lvtel\-)?(v1[12]) b/i
      ], [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]], [
        /\b(ph-1) /i
      ], [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]], [
        /\b(v(100md|700na|7011|917g).*\b) b/i
      ], [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]], [
        /\b(trio[-\w\. ]+) b/i
      ], [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]], [
        /\btu_(1491) b/i
      ], [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]], [
        /(shield[\w ]+) b/i
      ], [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]], [
        /(sprint) (\w+)/i
      ], [VENDOR, MODEL, [TYPE, MOBILE]], [
        /(kin\.[onetw]{3})/i
      ], [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [
        /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
      ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [
        /(ouya)/i,
        /(nintendo) ([wids3utch]+)/i
      ], [VENDOR, MODEL, [TYPE, CONSOLE]], [
        /droid.+; (shield) bui/i
      ], [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]], [
        /(playstation [345portablevi]+)/i
      ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [
        /\b(xbox(?: one)?(?!; xbox))[\); ]/i
      ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [
        /smart-tv.+(samsung)/i
      ], [VENDOR, [TYPE, SMARTTV]], [/hbbtv.+maple;(\d+)/i], [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [
        /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
      ], [[VENDOR, LG], [TYPE, SMARTTV]], [
        /(apple) ?tv/i
      ], [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]], [
        /crkey/i
      ], [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [
        /droid.+aft(\w)( bui|\))/i
      ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [
        /\(dtv[\);].+(aquos)/i,
        /(aquos-tv[\w ]+)\)/i
      ], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]], [
        /(bravia[\w ]+)( bui|\))/i
      ], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [
        /(mitv-\w{5}) bui/i
      ], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [
        /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
        /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i
      ], [[VENDOR, trim2], [MODEL, trim2], [TYPE, SMARTTV]], [
        /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i
      ], [[TYPE, SMARTTV]], [
        /((pebble))app/i
      ], [VENDOR, MODEL, [TYPE, WEARABLE]], [
        /droid.+; (glass) \d/i
      ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [/droid.+; (wt63?0{2,3})\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [
        /(quest( 2)?)/i
      ], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [
        /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
      ], [VENDOR, [TYPE, EMBEDDED]], [
        /droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i
      ], [MODEL, [TYPE, MOBILE]], [
        /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
      ], [MODEL, [TYPE, TABLET]], [
        /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
      ], [[TYPE, TABLET]], [
        /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
      ], [[TYPE, MOBILE]], [
        /(android[-\w\. ]{0,9});.+buil/i
      ], [MODEL, [VENDOR, "Generic"]]],
      engine: [[
        /windows.+ edge\/([\w\.]+)/i
      ], [VERSION, [NAME, EDGE + "HTML"]], [
        /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
      ], [VERSION, [NAME, "Blink"]], [
        /(presto)\/([\w\.]+)/i,
        /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
        /ekioh(flow)\/([\w\.]+)/i,
        /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
        /(icab)[\/ ]([23]\.[\d\.]+)/i
      ], [NAME, VERSION], [
        /rv\:([\w\.]{1,9})\b.+(gecko)/i
      ], [VERSION, NAME]],
      os: [[
        /microsoft (windows) (vista|xp)/i
      ], [NAME, VERSION], [
        /(windows) nt 6\.2; (arm)/i,
        /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,
        /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i
      ], [NAME, [VERSION, strMapper, windowsVersionMap]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[NAME, "Windows"], [VERSION, strMapper, windowsVersionMap]], [
        /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
        /cfnetwork\/.+darwin/i
      ], [[VERSION, /_/g, "."], [NAME, "iOS"]], [
        /(mac os x) ?([\w\. ]*)/i,
        /(macintosh|mac_powerpc\b)(?!.+haiku)/i
      ], [[NAME, "Mac OS"], [VERSION, /_/g, "."]], [
        /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
      ], [VERSION, NAME], [
        /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
        /(blackberry)\w*\/([\w\.]*)/i,
        /(tizen|kaios)[\/ ]([\w\.]+)/i,
        /\((series40);/i
      ], [NAME, VERSION], [
        /\(bb(10);/i
      ], [VERSION, [NAME, BLACKBERRY]], [
        /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i
      ], [VERSION, [NAME, "Symbian"]], [
        /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
      ], [VERSION, [NAME, FIREFOX + " OS"]], [
        /web0s;.+rt(tv)/i,
        /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
      ], [VERSION, [NAME, "webOS"]], [
        /crkey\/([\d\.]+)/i
      ], [VERSION, [NAME, CHROME + "cast"]], [
        /(cros) [\w]+ ([\w\.]+\w)/i
      ], [[NAME, "Chromium OS"], VERSION], [
        /(nintendo|playstation) ([wids345portablevuch]+)/i,
        /(xbox); +xbox ([^\);]+)/i,
        /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
        /(mint)[\/\(\) ]?(\w*)/i,
        /(mageia|vectorlinux)[; ]/i,
        /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
        /(hurd|linux) ?([\w\.]*)/i,
        /(gnu) ?([\w\.]*)/i,
        /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
        /(haiku) (\w+)/i
      ], [NAME, VERSION], [
        /(sunos) ?([\w\.\d]*)/i
      ], [[NAME, "Solaris"], VERSION], [
        /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
        /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
        /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i,
        /(unix) ?([\w\.]*)/i
      ], [NAME, VERSION]]
    };
    var UAParser2 = function(ua, extensions) {
      if (typeof ua === OBJ_TYPE) {
        extensions = ua;
        ua = undefined$1;
      }
      if (!(this instanceof UAParser2)) {
        return new UAParser2(ua, extensions).getResult();
      }
      var _ua = ua || (typeof window2 !== UNDEF_TYPE && window2.navigator && window2.navigator.userAgent ? window2.navigator.userAgent : EMPTY2);
      var _rgxmap = extensions ? extend2(regexes, extensions) : regexes;
      this.getBrowser = function() {
        var _browser = {};
        _browser[NAME] = undefined$1;
        _browser[VERSION] = undefined$1;
        rgxMapper.call(_browser, _ua, _rgxmap.browser);
        _browser.major = majorize(_browser.version);
        return _browser;
      };
      this.getCPU = function() {
        var _cpu = {};
        _cpu[ARCHITECTURE] = undefined$1;
        rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
        return _cpu;
      };
      this.getDevice = function() {
        var _device = {};
        _device[VENDOR] = undefined$1;
        _device[MODEL] = undefined$1;
        _device[TYPE] = undefined$1;
        rgxMapper.call(_device, _ua, _rgxmap.device);
        return _device;
      };
      this.getEngine = function() {
        var _engine = {};
        _engine[NAME] = undefined$1;
        _engine[VERSION] = undefined$1;
        rgxMapper.call(_engine, _ua, _rgxmap.engine);
        return _engine;
      };
      this.getOS = function() {
        var _os = {};
        _os[NAME] = undefined$1;
        _os[VERSION] = undefined$1;
        rgxMapper.call(_os, _ua, _rgxmap.os);
        return _os;
      };
      this.getResult = function() {
        return {
          ua: this.getUA(),
          browser: this.getBrowser(),
          engine: this.getEngine(),
          os: this.getOS(),
          device: this.getDevice(),
          cpu: this.getCPU()
        };
      };
      this.getUA = function() {
        return _ua;
      };
      this.setUA = function(ua2) {
        _ua = typeof ua2 === STR_TYPE && ua2.length > UA_MAX_LENGTH ? trim2(ua2, UA_MAX_LENGTH) : ua2;
        return this;
      };
      this.setUA(_ua);
      return this;
    };
    UAParser2.VERSION = LIBVERSION;
    UAParser2.BROWSER = enumerize([NAME, VERSION, MAJOR]);
    UAParser2.CPU = enumerize([ARCHITECTURE]);
    UAParser2.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
    UAParser2.ENGINE = UAParser2.OS = enumerize([NAME, VERSION]);
    {
      if (module2.exports) {
        exports2 = module2.exports = UAParser2;
      }
      exports2.UAParser = UAParser2;
    }
    var $ = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);
    if ($ && !$.ua) {
      var parser2 = new UAParser2();
      $.ua = parser2.getResult();
      $.ua.get = function() {
        return parser2.getUA();
      };
      $.ua.set = function(ua) {
        parser2.setUA(ua);
        var result = parser2.getResult();
        for (var prop in result) {
          $.ua[prop] = result[prop];
        }
      };
    }
  })(typeof window === "object" ? window : commonjsGlobal);
})(uaParser, uaParserExports);
var UAParser = uaParserExports;
var version$1 = "1.7.0";
const version = version$1;
const protocolVersion = 9;
function mergeDefaultOptions(options, audioDefaults2, videoDefaults2) {
  const opts = _objectSpread2({}, options);
  if (opts.audio === true)
    opts.audio = {};
  if (opts.video === true)
    opts.video = {};
  if (opts.audio) {
    mergeObjectWithoutOverwriting(opts.audio, audioDefaults2);
  }
  if (opts.video) {
    mergeObjectWithoutOverwriting(opts.video, videoDefaults2);
  }
  return opts;
}
function mergeObjectWithoutOverwriting(mainObject, objectToMerge) {
  Object.keys(objectToMerge).forEach((key) => {
    if (mainObject[key] === void 0)
      mainObject[key] = objectToMerge[key];
  });
  return mainObject;
}
function constraintsForOptions(options) {
  const constraints = {};
  if (options.video) {
    if (typeof options.video === "object") {
      const videoOptions = {};
      const target = videoOptions;
      const source2 = options.video;
      Object.keys(source2).forEach((key) => {
        switch (key) {
          case "resolution":
            mergeObjectWithoutOverwriting(target, source2.resolution);
            break;
          default:
            target[key] = source2[key];
        }
      });
      constraints.video = videoOptions;
    } else {
      constraints.video = options.video;
    }
  } else {
    constraints.video = false;
  }
  if (options.audio) {
    if (typeof options.audio === "object") {
      constraints.audio = options.audio;
    } else {
      constraints.audio = true;
    }
  } else {
    constraints.audio = false;
  }
  return constraints;
}
async function detectSilence(track) {
  let timeOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  const ctx = getNewAudioContext();
  if (ctx) {
    const analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    const source2 = ctx.createMediaStreamSource(new MediaStream([track.mediaStreamTrack]));
    source2.connect(analyser);
    await sleep(timeOffset);
    analyser.getByteTimeDomainData(dataArray);
    const someNoise = dataArray.some((sample2) => sample2 !== 128 && sample2 !== 0);
    ctx.close();
    return !someNoise;
  }
  return false;
}
function getNewAudioContext() {
  const AudioContext2 = window.AudioContext || window.webkitAudioContext;
  if (AudioContext2) {
    return new AudioContext2({
      latencyHint: "interactive"
    });
  }
}
const separator = "|";
function unpackStreamId(packed) {
  const parts = packed.split(separator);
  if (parts.length > 1) {
    return [parts[0], packed.substr(parts[0].length + 1)];
  }
  return [packed, ""];
}
async function sleep(duration) {
  return new Promise((resolve) => setTimeout(resolve, duration));
}
function supportsTransceiver() {
  return "addTransceiver" in RTCPeerConnection.prototype;
}
function supportsAddTrack() {
  return "addTrack" in RTCPeerConnection.prototype;
}
function supportsAV1() {
  const capabilities = RTCRtpReceiver.getCapabilities("video");
  let hasAV1 = false;
  let hasDDExt = false;
  if (capabilities) {
    for (const codec of capabilities.codecs) {
      if (codec.mimeType === "video/AV1") {
        hasAV1 = true;
        break;
      }
    }
    for (const ext of capabilities.headerExtensions) {
      if (ext.uri === "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension") {
        hasDDExt = true;
        break;
      }
    }
  }
  return hasAV1 && hasDDExt;
}
function supportsSetSinkId(elm) {
  if (!document) {
    return false;
  }
  if (!elm) {
    elm = document.createElement("audio");
  }
  return "setSinkId" in elm;
}
const setCodecPreferencesVersions = {
  Chrome: "100",
  Chromium: "100",
  Safari: "15",
  Firefox: "100",
  Edge: "100",
  Brave: "1.40"
};
function supportsSetCodecPreferences(transceiver) {
  if (!isWeb()) {
    return false;
  }
  if (!("setCodecPreferences" in transceiver)) {
    return false;
  }
  const uap = UAParser();
  if (!uap.browser.name || !uap.browser.version) {
    return false;
  }
  const v = setCodecPreferencesVersions[uap.browser.name];
  if (v) {
    return compareVersions(uap.browser.version, v) >= 0;
  }
  return false;
}
function isFireFox() {
  if (!isWeb())
    return false;
  return navigator.userAgent.indexOf("Firefox") !== -1;
}
function isSafari() {
  if (!isWeb())
    return false;
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function isMobile() {
  if (!isWeb())
    return false;
  return /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent);
}
function isWeb() {
  return typeof document !== "undefined";
}
function compareVersions(v12, v2) {
  const parts1 = v12.split(".");
  const parts2 = v2.split(".");
  const k = Math.min(v12.length, v2.length);
  for (let i2 = 0; i2 < k; ++i2) {
    const p1 = parseInt(parts1[i2], 10);
    const p2 = parseInt(parts2[i2], 10);
    if (p1 > p2)
      return 1;
    if (p1 < p2)
      return -1;
  }
  return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;
}
function roDispatchCallback(entries) {
  for (const entry of entries) {
    entry.target.handleResize(entry);
  }
}
function ioDispatchCallback(entries) {
  for (const entry of entries) {
    entry.target.handleVisibilityChanged(entry);
  }
}
let resizeObserver = null;
const getResizeObserver = () => {
  if (!resizeObserver)
    resizeObserver = new ResizeObserver(roDispatchCallback);
  return resizeObserver;
};
let intersectionObserver = null;
const getIntersectionObserver = () => {
  if (!intersectionObserver)
    intersectionObserver = new IntersectionObserver(ioDispatchCallback, {
      root: document,
      rootMargin: "0px"
    });
  return intersectionObserver;
};
function getClientInfo() {
  const info = ClientInfo.fromPartial({
    sdk: ClientInfo_SDK.JS,
    protocol: protocolVersion,
    version
  });
  return info;
}
let emptyVideoStreamTrack;
function getEmptyVideoStreamTrack() {
  if (!emptyVideoStreamTrack) {
    emptyVideoStreamTrack = createDummyVideoStreamTrack();
  }
  return emptyVideoStreamTrack;
}
function createDummyVideoStreamTrack() {
  let width = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;
  let height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16;
  let enabled = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  let paintContent = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);
  if (paintContent && ctx) {
    ctx.beginPath();
    ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fillStyle = "grey";
    ctx.fill();
  }
  const dummyStream = canvas.captureStream();
  const [dummyTrack] = dummyStream.getTracks();
  if (!dummyTrack) {
    throw Error("Could not get empty media stream video track");
  }
  dummyTrack.enabled = enabled;
  return dummyTrack;
}
let emptyAudioStreamTrack;
function getEmptyAudioStreamTrack() {
  if (!emptyAudioStreamTrack) {
    const ctx = new AudioContext();
    const oscillator = ctx.createOscillator();
    const dst = ctx.createMediaStreamDestination();
    oscillator.connect(dst);
    oscillator.start();
    [emptyAudioStreamTrack] = dst.stream.getAudioTracks();
    if (!emptyAudioStreamTrack) {
      throw Error("Could not get empty media stream audio track");
    }
    emptyAudioStreamTrack.enabled = false;
  }
  return emptyAudioStreamTrack;
}
class Future {
  constructor(futureBase, onFinally) {
    this.onFinally = onFinally;
    this.promise = new Promise(async (resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
      if (futureBase) {
        await futureBase(resolve, reject);
      }
    }).finally(() => {
      var _a2;
      return (_a2 = this.onFinally) === null || _a2 === void 0 ? void 0 : _a2.call(this);
    });
  }
}
class Mutex {
  constructor() {
    this._locking = Promise.resolve();
    this._locks = 0;
  }
  isLocked() {
    return this._locks > 0;
  }
  lock() {
    this._locks += 1;
    let unlockNext;
    const willLock = new Promise((resolve) => unlockNext = () => {
      this._locks -= 1;
      resolve();
    });
    const willUnlock = this._locking.then(() => unlockNext);
    this._locking = this._locking.then(() => willLock);
    return willUnlock;
  }
}
class Queue {
  constructor(_maxConcurrent, _minCycle) {
    this.maxConcurrent = _maxConcurrent || 1;
    this.minCycle = _minCycle || 0;
    this.queueRunning = [];
    this.queueWaiting = {};
    this.lastRun = 0;
  }
  dequeue(hash) {
    const q = this.queueRunning;
    const idx = q.findIndex((x) => x.hash === hash);
    if (idx == -1)
      throw "queue desync";
    const o2 = q[idx];
    q.splice(idx, 1);
    return o2;
  }
  getFirstWaiting() {
    for (let p of Object.keys(this.queueWaiting).sort((a, b) => a - b))
      if (this.queueWaiting[p] !== void 0 && this.queueWaiting[p].length > 0)
        return this.queueWaiting[p];
    return void 0;
  }
  end(hash) {
    const me = this.dequeue(hash);
    me.resolve();
    const q = this.getFirstWaiting();
    if (q !== void 0) {
      const next = q.shift();
      next.resolve();
    }
  }
  async wait(hash, _priority) {
    const priority = _priority === void 0 ? 0 : _priority;
    let me = {
      hash,
      priority
    };
    if (this.queueWaiting[priority] == void 0)
      this.queueWaiting[priority] = [];
    if (this.queueRunning.length >= this.maxConcurrent) {
      me.promise = new Promise((resolve) => {
        me.resolve = resolve;
      });
      this.queueWaiting[priority].push(me);
      await me.promise;
    }
    this.queueRunning.push(me);
    me.promise = new Promise((resolve) => {
      me.resolve = resolve;
    });
    while (Date.now() - this.lastRun < this.minCycle) {
      await new Promise((resolve) => setTimeout(resolve, this.minCycle - Date.now() + this.lastRun));
    }
    this.lastRun = Date.now();
  }
  run(job, _priority) {
    const priority = _priority === void 0 ? 0 : _priority;
    const id = Symbol();
    return this.wait(id, priority).then(() => job()).finally(() => {
      this.end(id);
    });
  }
  stat() {
    return {
      running: this.queueRunning.length,
      waiting: Object.keys(this.queueWaiting).reduce((t2, x) => t2 += this.queueWaiting[x].length, 0),
      last: this.lastRun
    };
  }
  async flush() {
    while (this.stat().waiting > 0) {
      for (let p of Object.keys(this.queueWaiting).sort((a, b) => b - a)) {
        const qp = this.queueWaiting[p];
        if (qp !== void 0 && qp.length > 0) {
          await qp[qp.length - 1].promise;
        }
      }
    }
    while (this.queueRunning.length > 0) {
      await Promise.allSettled(this.queueRunning.map((x) => x.promise));
    }
  }
}
const defaultId = "default";
class DeviceManager {
  static getInstance() {
    if (this.instance === void 0) {
      this.instance = new DeviceManager();
    }
    return this.instance;
  }
  async getDevices(kind) {
    let requestPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    var _a2;
    if (((_a2 = DeviceManager.userMediaPromiseMap) === null || _a2 === void 0 ? void 0 : _a2.size) > 0) {
      livekitLogger.debug("awaiting getUserMedia promise");
      try {
        if (kind) {
          await DeviceManager.userMediaPromiseMap.get(kind);
        } else {
          await Promise.all(DeviceManager.userMediaPromiseMap.values());
        }
      } catch (e2) {
        livekitLogger.warn("error waiting for media permissons");
      }
    }
    let devices = await navigator.mediaDevices.enumerateDevices();
    if (requestPermissions && kind && (!DeviceManager.userMediaPromiseMap.get(kind) || !isSafari())) {
      const isDummyDeviceOrEmpty = devices.length === 0 || devices.some((device) => {
        const noLabel = device.label === "";
        const isRelevant = kind ? device.kind === kind : true;
        return noLabel && isRelevant;
      });
      if (isDummyDeviceOrEmpty) {
        const permissionsToAcquire = {
          video: kind !== "audioinput" && kind !== "audiooutput",
          audio: kind !== "videoinput"
        };
        const stream = await navigator.mediaDevices.getUserMedia(permissionsToAcquire);
        devices = await navigator.mediaDevices.enumerateDevices();
        stream.getTracks().forEach((track) => {
          track.stop();
        });
      }
    }
    if (kind) {
      devices = devices.filter((device) => device.kind === kind);
    }
    return devices;
  }
  async normalizeDeviceId(kind, deviceId, groupId) {
    if (deviceId !== defaultId) {
      return deviceId;
    }
    const devices = await this.getDevices(kind);
    const device = devices.find((d) => d.groupId === groupId && d.deviceId !== defaultId);
    return device === null || device === void 0 ? void 0 : device.deviceId;
  }
}
DeviceManager.mediaDeviceKinds = ["audioinput", "audiooutput", "videoinput"];
DeviceManager.userMediaPromiseMap = /* @__PURE__ */ new Map();
var eventsExports = {};
var events = {
  get exports() {
    return eventsExports;
  },
  set exports(v) {
    eventsExports = v;
  }
};
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning2) {
  if (console && console.warn)
    console.warn(warning2);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
eventsExports.once = once;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
  if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
  }
  this._maxListeners = n2;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit2(type) {
  var args = [];
  for (var i2 = 1; i2 < arguments.length; i2++)
    args.push(arguments[i2]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      ReflectApply(listeners2[i2], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w.name = "MaxListenersExceededWarning";
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state2 = {
    fired: false,
    wrapFn: void 0,
    target,
    type,
    listener
  };
  var wrapped = onceWrapper.bind(state2);
  wrapped.listener = listener;
  state2.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once2(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events2, position, i2, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i2 = list.length - 1; i2 >= 0; i2--) {
      if (list[i2] === listener || list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1)
      events2[type] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2, i2;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    var key;
    for (i2 = 0; i2 < keys2.length; ++i2) {
      key = keys2[i2];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (i2 = listeners2.length - 1; i2 >= 0; i2--) {
      this.removeListener(type, listeners2[i2]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n2) {
  var copy = new Array(n2);
  for (var i2 = 0; i2 < n2; ++i2)
    copy[i2] = arr[i2];
  return copy;
}
function spliceOne(list, index2) {
  for (; index2 + 1 < list.length; index2++)
    list[index2] = list[index2 + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr[i2].listener || arr[i2];
  }
  return ret;
}
function once(emitter, name2) {
  return new Promise(function(resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name2, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name2, resolver, {
      once: true
    });
    if (name2 !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name2, listener);
    } else {
      emitter.on(name2, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name2, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name2, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
const BACKGROUND_REACTION_DELAY = 5e3;
const recycledElements = [];
class Track extends eventsExports.EventEmitter {
  constructor(mediaTrack, kind) {
    super();
    this.attachedElements = [];
    this.isMuted = false;
    this.streamState = Track.StreamState.Active;
    this._currentBitrate = 0;
    this.appVisibilityChangedListener = () => {
      if (this.backgroundTimeout) {
        clearTimeout(this.backgroundTimeout);
      }
      if (document.visibilityState === "hidden") {
        this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);
      } else {
        this.handleAppVisibilityChanged();
      }
    };
    this.setMaxListeners(100);
    this.kind = kind;
    this._mediaStreamTrack = mediaTrack;
    this._mediaStreamID = mediaTrack.id;
    this.source = Track.Source.Unknown;
    if (isWeb()) {
      this.isInBackground = document.visibilityState === "hidden";
      document.addEventListener("visibilitychange", this.appVisibilityChangedListener);
    } else {
      this.isInBackground = false;
    }
  }
  get currentBitrate() {
    return this._currentBitrate;
  }
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  get mediaStreamID() {
    return this._mediaStreamID;
  }
  attach(element) {
    let elementType = "audio";
    if (this.kind === Track.Kind.Video) {
      elementType = "video";
    }
    if (!element) {
      if (elementType === "audio") {
        recycledElements.forEach((e2) => {
          if (e2.parentElement === null && !element) {
            element = e2;
          }
        });
        if (element) {
          recycledElements.splice(recycledElements.indexOf(element), 1);
        }
      }
      if (!element) {
        element = document.createElement(elementType);
      }
    }
    if (!this.attachedElements.includes(element)) {
      this.attachedElements.push(element);
    }
    attachToElement(this._mediaStreamTrack, element);
    const allMediaStreamTracks = element.srcObject.getTracks();
    if (allMediaStreamTracks.some((tr) => tr.kind === "audio")) {
      element.play().then(() => {
        this.emit(TrackEvent.AudioPlaybackStarted);
      }).catch((e2) => {
        if (e2.name === "NotAllowedError") {
          this.emit(TrackEvent.AudioPlaybackFailed, e2);
        } else {
          livekitLogger.warn("could not playback audio", e2);
        }
        if (element && allMediaStreamTracks.some((tr) => tr.kind === "video") && e2.name === "NotAllowedError") {
          element.muted = true;
          element.play().catch(() => {
          });
        }
      });
    }
    this.emit(TrackEvent.ElementAttached, element);
    return element;
  }
  detach(element) {
    if (element) {
      detachTrack(this._mediaStreamTrack, element);
      const idx = this.attachedElements.indexOf(element);
      if (idx >= 0) {
        this.attachedElements.splice(idx, 1);
        this.recycleElement(element);
        this.emit(TrackEvent.ElementDetached, element);
      }
      return element;
    }
    const detached = [];
    this.attachedElements.forEach((elm) => {
      detachTrack(this._mediaStreamTrack, elm);
      detached.push(elm);
      this.recycleElement(elm);
      this.emit(TrackEvent.ElementDetached, elm);
    });
    this.attachedElements = [];
    return detached;
  }
  stop() {
    this.stopMonitor();
    this._mediaStreamTrack.stop();
    if (isWeb()) {
      document.removeEventListener("visibilitychange", this.appVisibilityChangedListener);
    }
  }
  enable() {
    this._mediaStreamTrack.enabled = true;
  }
  disable() {
    this._mediaStreamTrack.enabled = false;
  }
  stopMonitor() {
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
    }
  }
  recycleElement(element) {
    if (element instanceof HTMLAudioElement) {
      let shouldCache = true;
      element.pause();
      recycledElements.forEach((e2) => {
        if (!e2.parentElement) {
          shouldCache = false;
        }
      });
      if (shouldCache) {
        recycledElements.push(element);
      }
    }
  }
  async handleAppVisibilityChanged() {
    this.isInBackground = document.visibilityState === "hidden";
  }
}
function attachToElement(track, element) {
  let mediaStream;
  if (element.srcObject instanceof MediaStream) {
    mediaStream = element.srcObject;
  } else {
    mediaStream = new MediaStream();
  }
  let existingTracks;
  if (track.kind === "audio") {
    existingTracks = mediaStream.getAudioTracks();
  } else {
    existingTracks = mediaStream.getVideoTracks();
  }
  if (!existingTracks.includes(track)) {
    existingTracks.forEach((et) => {
      mediaStream.removeTrack(et);
    });
    mediaStream.addTrack(track);
  }
  element.autoplay = true;
  element.muted = mediaStream.getAudioTracks().length === 0;
  if (element instanceof HTMLVideoElement) {
    element.playsInline = true;
  }
  if (element.srcObject !== mediaStream) {
    element.srcObject = mediaStream;
    if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {
      setTimeout(() => {
        element.srcObject = mediaStream;
        element.play().catch(() => {
        });
      }, 0);
    }
  }
}
function detachTrack(track, element) {
  if (element.srcObject instanceof MediaStream) {
    const mediaStream = element.srcObject;
    mediaStream.removeTrack(track);
    if (mediaStream.getTracks().length > 0) {
      element.srcObject = mediaStream;
    } else {
      element.srcObject = null;
    }
  }
}
(function(Track2) {
  let Kind;
  (function(Kind2) {
    Kind2["Audio"] = "audio";
    Kind2["Video"] = "video";
    Kind2["Unknown"] = "unknown";
  })(Kind = Track2.Kind || (Track2.Kind = {}));
  let Source;
  (function(Source2) {
    Source2["Camera"] = "camera";
    Source2["Microphone"] = "microphone";
    Source2["ScreenShare"] = "screen_share";
    Source2["ScreenShareAudio"] = "screen_share_audio";
    Source2["Unknown"] = "unknown";
  })(Source = Track2.Source || (Track2.Source = {}));
  let StreamState$1;
  (function(StreamState2) {
    StreamState2["Active"] = "active";
    StreamState2["Paused"] = "paused";
    StreamState2["Unknown"] = "unknown";
  })(StreamState$1 = Track2.StreamState || (Track2.StreamState = {}));
  function kindToProto(k) {
    switch (k) {
      case Kind.Audio:
        return TrackType.AUDIO;
      case Kind.Video:
        return TrackType.VIDEO;
      default:
        return TrackType.UNRECOGNIZED;
    }
  }
  Track2.kindToProto = kindToProto;
  function kindFromProto(t2) {
    switch (t2) {
      case TrackType.AUDIO:
        return Kind.Audio;
      case TrackType.VIDEO:
        return Kind.Video;
      default:
        return Kind.Unknown;
    }
  }
  Track2.kindFromProto = kindFromProto;
  function sourceToProto(s) {
    switch (s) {
      case Source.Camera:
        return TrackSource.CAMERA;
      case Source.Microphone:
        return TrackSource.MICROPHONE;
      case Source.ScreenShare:
        return TrackSource.SCREEN_SHARE;
      case Source.ScreenShareAudio:
        return TrackSource.SCREEN_SHARE_AUDIO;
      default:
        return TrackSource.UNRECOGNIZED;
    }
  }
  Track2.sourceToProto = sourceToProto;
  function sourceFromProto(s) {
    switch (s) {
      case TrackSource.CAMERA:
        return Source.Camera;
      case TrackSource.MICROPHONE:
        return Source.Microphone;
      case TrackSource.SCREEN_SHARE:
        return Source.ScreenShare;
      case TrackSource.SCREEN_SHARE_AUDIO:
        return Source.ScreenShareAudio;
      default:
        return Source.Unknown;
    }
  }
  Track2.sourceFromProto = sourceFromProto;
  function streamStateFromProto(s) {
    switch (s) {
      case StreamState.ACTIVE:
        return StreamState$1.Active;
      case StreamState.PAUSED:
        return StreamState$1.Paused;
      default:
        return StreamState$1.Unknown;
    }
  }
  Track2.streamStateFromProto = streamStateFromProto;
})(Track || (Track = {}));
const defaultDimensionsTimeout = 2 * 1e3;
class LocalTrack extends Track {
  constructor(mediaTrack, kind, constraints) {
    let userProvidedTrack = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    super(mediaTrack, kind);
    this._isUpstreamPaused = false;
    this.handleEnded = () => {
      if (this.isInBackground) {
        this.reacquireTrack = true;
      }
      this.emit(TrackEvent.Ended, this);
    };
    this._mediaStreamTrack.addEventListener("ended", this.handleEnded);
    this.constraints = constraints !== null && constraints !== void 0 ? constraints : mediaTrack.getConstraints();
    this.reacquireTrack = false;
    this.providedByUser = userProvidedTrack;
    this.muteQueue = new Queue();
  }
  get id() {
    return this._mediaStreamTrack.id;
  }
  get dimensions() {
    if (this.kind !== Track.Kind.Video) {
      return void 0;
    }
    const {
      width,
      height
    } = this._mediaStreamTrack.getSettings();
    if (width && height) {
      return {
        width,
        height
      };
    }
    return void 0;
  }
  get isUpstreamPaused() {
    return this._isUpstreamPaused;
  }
  get isUserProvided() {
    return this.providedByUser;
  }
  async waitForDimensions() {
    let timeout2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDimensionsTimeout;
    if (this.kind === Track.Kind.Audio) {
      throw new Error("cannot get dimensions for audio tracks");
    }
    const started = Date.now();
    while (Date.now() - started < timeout2) {
      const dims = this.dimensions;
      if (dims) {
        return dims;
      }
      await sleep(50);
    }
    throw new TrackInvalidError("unable to get track dimensions after timeout");
  }
  async getDeviceId() {
    if (this.source === Track.Source.ScreenShare) {
      return;
    }
    const {
      deviceId,
      groupId
    } = this._mediaStreamTrack.getSettings();
    const kind = this.kind === Track.Kind.Audio ? "audioinput" : "videoinput";
    return DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId);
  }
  async mute() {
    this.setTrackMuted(true);
    return this;
  }
  async unmute() {
    this.setTrackMuted(false);
    return this;
  }
  async replaceTrack(track) {
    let userProvidedTrack = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (!this.sender) {
      throw new TrackInvalidError("unable to replace an unpublished track");
    }
    this.attachedElements.forEach((el) => {
      detachTrack(this._mediaStreamTrack, el);
    });
    this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
    if (!this.providedByUser) {
      this._mediaStreamTrack.stop();
    }
    track.addEventListener("ended", this.handleEnded);
    livekitLogger.debug("replace MediaStreamTrack");
    if (this.sender) {
      await this.sender.replaceTrack(track);
    }
    this._mediaStreamTrack = track;
    this._mediaStreamTrack.enabled = !this.isMuted;
    await this.resumeUpstream();
    this.attachedElements.forEach((el) => {
      attachToElement(track, el);
    });
    this.mediaStream = new MediaStream([track]);
    this.providedByUser = userProvidedTrack;
    return this;
  }
  async restart(constraints) {
    if (!constraints) {
      constraints = this.constraints;
    }
    livekitLogger.debug("restarting track with constraints", constraints);
    const streamConstraints = {
      audio: false,
      video: false
    };
    if (this.kind === Track.Kind.Video) {
      streamConstraints.video = constraints;
    } else {
      streamConstraints.audio = constraints;
    }
    this.attachedElements.forEach((el) => {
      detachTrack(this._mediaStreamTrack, el);
    });
    this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
    this._mediaStreamTrack.stop();
    const mediaStream = await navigator.mediaDevices.getUserMedia(streamConstraints);
    const newTrack = mediaStream.getTracks()[0];
    newTrack.addEventListener("ended", this.handleEnded);
    livekitLogger.debug("re-acquired MediaStreamTrack");
    if (this.sender) {
      await this.sender.replaceTrack(newTrack);
    }
    this._mediaStreamTrack = newTrack;
    await this.resumeUpstream();
    this.attachedElements.forEach((el) => {
      attachToElement(newTrack, el);
    });
    this.mediaStream = mediaStream;
    this.constraints = constraints;
    this.emit(TrackEvent.Restarted, this);
    return this;
  }
  setTrackMuted(muted) {
    livekitLogger.debug("setting ".concat(this.kind, " track ").concat(muted ? "muted" : "unmuted"));
    if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {
      return;
    }
    this.isMuted = muted;
    this._mediaStreamTrack.enabled = !muted;
    this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);
  }
  get needsReAcquisition() {
    return this._mediaStreamTrack.readyState !== "live" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;
  }
  async handleAppVisibilityChanged() {
    await super.handleAppVisibilityChanged();
    if (!isMobile())
      return;
    livekitLogger.debug("visibility changed, is in Background: ".concat(this.isInBackground));
    if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {
      livekitLogger.debug("track needs to be reaquired, restarting ".concat(this.source));
      await this.restart();
      this.reacquireTrack = false;
    }
  }
  async pauseUpstream() {
    this.muteQueue.run(async () => {
      if (this._isUpstreamPaused === true) {
        return;
      }
      if (!this.sender) {
        livekitLogger.warn("unable to pause upstream for an unpublished track");
        return;
      }
      this._isUpstreamPaused = true;
      this.emit(TrackEvent.UpstreamPaused, this);
      const emptyTrack = this.kind === Track.Kind.Audio ? getEmptyAudioStreamTrack() : getEmptyVideoStreamTrack();
      await this.sender.replaceTrack(emptyTrack);
    });
  }
  async resumeUpstream() {
    this.muteQueue.run(async () => {
      if (this._isUpstreamPaused === false) {
        return;
      }
      if (!this.sender) {
        livekitLogger.warn("unable to resume upstream for an unpublished track");
        return;
      }
      this._isUpstreamPaused = false;
      this.emit(TrackEvent.UpstreamResumed, this);
      await this.sender.replaceTrack(this._mediaStreamTrack);
    });
  }
}
class LocalAudioTrack extends LocalTrack {
  constructor(mediaTrack, constraints) {
    let userProvidedTrack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack);
    this.stopOnMute = false;
    this.monitorSender = async () => {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      let stats;
      try {
        stats = await this.getSenderStats();
      } catch (e2) {
        livekitLogger.error("could not get audio sender stats", {
          error: e2
        });
        return;
      }
      if (stats && this.prevStats) {
        this._currentBitrate = computeBitrate(stats, this.prevStats);
      }
      this.prevStats = stats;
    };
    this.checkForSilence();
  }
  async setDeviceId(deviceId) {
    if (this.constraints.deviceId === deviceId) {
      return;
    }
    this.constraints.deviceId = deviceId;
    if (!this.isMuted) {
      await this.restartTrack();
    }
  }
  async mute() {
    await this.muteQueue.run(async () => {
      if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {
        livekitLogger.debug("stopping mic track");
        this._mediaStreamTrack.stop();
      }
      await super.mute();
    });
    return this;
  }
  async unmute() {
    await this.muteQueue.run(async () => {
      if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === "ended") && !this.isUserProvided) {
        livekitLogger.debug("reacquiring mic track");
        await this.restartTrack();
      }
      await super.unmute();
    });
    return this;
  }
  async restartTrack(options) {
    let constraints;
    if (options) {
      const streamConstraints = constraintsForOptions({
        audio: options
      });
      if (typeof streamConstraints.audio !== "boolean") {
        constraints = streamConstraints.audio;
      }
    }
    await this.restart(constraints);
  }
  async restart(constraints) {
    const track = await super.restart(constraints);
    this.checkForSilence();
    return track;
  }
  startMonitor() {
    if (!isWeb()) {
      return;
    }
    if (this.monitorInterval) {
      return;
    }
    this.monitorInterval = setInterval(() => {
      this.monitorSender();
    }, monitorFrequency);
  }
  async getSenderStats() {
    var _a2;
    if (!((_a2 = this.sender) === null || _a2 === void 0 ? void 0 : _a2.getStats)) {
      return void 0;
    }
    const stats = await this.sender.getStats();
    let audioStats;
    stats.forEach((v) => {
      if (v.type === "outbound-rtp") {
        audioStats = {
          type: "audio",
          streamId: v.id,
          packetsSent: v.packetsSent,
          packetsLost: v.packetsLost,
          bytesSent: v.bytesSent,
          timestamp: v.timestamp,
          roundTripTime: v.roundTripTime,
          jitter: v.jitter
        };
      }
    });
    return audioStats;
  }
  async checkForSilence() {
    const trackIsSilent = await detectSilence(this);
    if (trackIsSilent) {
      if (!this.isMuted) {
        livekitLogger.warn("silence detected on local audio track");
      }
      this.emit(TrackEvent.AudioSilenceDetected);
    }
  }
}
const refreshSubscribedCodecAfterNewCodec = 5e3;
class LocalVideoTrack extends LocalTrack {
  constructor(mediaTrack, constraints) {
    let userProvidedTrack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack);
    this.simulcastCodecs = /* @__PURE__ */ new Map();
    this.monitorSender = async () => {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      let stats;
      try {
        stats = await this.getSenderStats();
      } catch (e2) {
        livekitLogger.error("could not get audio sender stats", {
          error: e2
        });
        return;
      }
      const statsMap = new Map(stats.map((s) => [s.rid, s]));
      if (this.prevStats) {
        let totalBitrate = 0;
        statsMap.forEach((s, key) => {
          var _a2;
          const prev = (_a2 = this.prevStats) === null || _a2 === void 0 ? void 0 : _a2.get(key);
          totalBitrate += computeBitrate(s, prev);
        });
        this._currentBitrate = totalBitrate;
      }
      this.prevStats = statsMap;
    };
    this.senderLock = new Mutex();
  }
  get isSimulcast() {
    if (this.sender && this.sender.getParameters().encodings.length > 1) {
      return true;
    }
    return false;
  }
  startMonitor(signalClient) {
    var _a2;
    this.signalClient = signalClient;
    if (!isWeb()) {
      return;
    }
    const params = (_a2 = this.sender) === null || _a2 === void 0 ? void 0 : _a2.getParameters();
    if (params) {
      this.encodings = params.encodings;
    }
    if (this.monitorInterval) {
      return;
    }
    this.monitorInterval = setInterval(() => {
      this.monitorSender();
    }, monitorFrequency);
  }
  stop() {
    this._mediaStreamTrack.getConstraints();
    this.simulcastCodecs.forEach((trackInfo) => {
      trackInfo.mediaStreamTrack.stop();
    });
    super.stop();
  }
  async mute() {
    await this.muteQueue.run(async () => {
      if (this.source === Track.Source.Camera && !this.isUserProvided) {
        livekitLogger.debug("stopping camera track");
        this._mediaStreamTrack.stop();
      }
      await super.mute();
    });
    return this;
  }
  async unmute() {
    await this.muteQueue.run(async () => {
      if (this.source === Track.Source.Camera && !this.isUserProvided) {
        livekitLogger.debug("reacquiring camera track");
        await this.restartTrack();
      }
      await super.unmute();
    });
    return this;
  }
  async getSenderStats() {
    var _a2;
    if (!((_a2 = this.sender) === null || _a2 === void 0 ? void 0 : _a2.getStats)) {
      return [];
    }
    const items = [];
    const stats = await this.sender.getStats();
    stats.forEach((v) => {
      var _a3;
      if (v.type === "outbound-rtp") {
        const vs = {
          type: "video",
          streamId: v.id,
          frameHeight: v.frameHeight,
          frameWidth: v.frameWidth,
          firCount: v.firCount,
          pliCount: v.pliCount,
          nackCount: v.nackCount,
          packetsSent: v.packetsSent,
          bytesSent: v.bytesSent,
          framesSent: v.framesSent,
          timestamp: v.timestamp,
          rid: (_a3 = v.rid) !== null && _a3 !== void 0 ? _a3 : v.id,
          retransmittedPacketsSent: v.retransmittedPacketsSent,
          qualityLimitationReason: v.qualityLimitationReason,
          qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges
        };
        const r2 = stats.get(v.remoteId);
        if (r2) {
          vs.jitter = r2.jitter;
          vs.packetsLost = r2.packetsLost;
          vs.roundTripTime = r2.roundTripTime;
        }
        items.push(vs);
      }
    });
    return items;
  }
  setPublishingQuality(maxQuality) {
    const qualities = [];
    for (let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1) {
      qualities.push({
        quality: q,
        enabled: q <= maxQuality
      });
    }
    livekitLogger.debug("setting publishing quality. max quality ".concat(maxQuality));
    this.setPublishingLayers(qualities);
  }
  async setDeviceId(deviceId) {
    if (this.constraints.deviceId === deviceId) {
      return;
    }
    this.constraints.deviceId = deviceId;
    if (!this.isMuted) {
      await this.restartTrack();
    }
  }
  async restartTrack(options) {
    let constraints;
    if (options) {
      const streamConstraints = constraintsForOptions({
        video: options
      });
      if (typeof streamConstraints.video !== "boolean") {
        constraints = streamConstraints.video;
      }
    }
    await this.restart(constraints);
  }
  addSimulcastTrack(codec, encodings) {
    if (this.simulcastCodecs.has(codec)) {
      throw new Error("".concat(codec, " already added"));
    }
    const simulcastCodecInfo = {
      codec,
      mediaStreamTrack: this.mediaStreamTrack.clone(),
      sender: void 0,
      encodings
    };
    this.simulcastCodecs.set(codec, simulcastCodecInfo);
    return simulcastCodecInfo;
  }
  setSimulcastTrackSender(codec, sender) {
    const simulcastCodecInfo = this.simulcastCodecs.get(codec);
    if (!simulcastCodecInfo) {
      return;
    }
    simulcastCodecInfo.sender = sender;
    setTimeout(() => {
      if (this.subscribedCodecs) {
        this.setPublishingCodecs(this.subscribedCodecs);
      }
    }, refreshSubscribedCodecAfterNewCodec);
  }
  async setPublishingCodecs(codecs) {
    livekitLogger.debug("setting publishing codecs", {
      codecs,
      currentCodec: this.codec
    });
    if (!this.codec && codecs.length > 0) {
      await this.setPublishingLayers(codecs[0].qualities);
      return [];
    }
    this.subscribedCodecs = codecs;
    const newCodecs = [];
    var _iteratorAbruptCompletion = false;
    var _didIteratorError = false;
    var _iteratorError;
    try {
      for (var _iterator = _asyncIterator(codecs), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {
        const codec = _step.value;
        {
          if (!this.codec || this.codec === codec.codec) {
            await this.setPublishingLayers(codec.qualities);
          } else {
            const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);
            livekitLogger.debug("try setPublishingCodec for ".concat(codec.codec), simulcastCodecInfo);
            if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {
              for (const q of codec.qualities) {
                if (q.enabled) {
                  newCodecs.push(codec.codec);
                  break;
                }
              }
            } else if (simulcastCodecInfo.encodings) {
              livekitLogger.debug("try setPublishingLayersForSender ".concat(codec.codec));
              await setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock);
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (_iteratorAbruptCompletion && _iterator.return != null) {
          await _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return newCodecs;
  }
  async setPublishingLayers(qualities) {
    livekitLogger.debug("setting publishing layers", qualities);
    if (!this.sender || !this.encodings) {
      return;
    }
    await setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock);
  }
  async handleAppVisibilityChanged() {
    await super.handleAppVisibilityChanged();
    if (!isMobile())
      return;
    if (this.isInBackground && this.source === Track.Source.Camera) {
      this._mediaStreamTrack.enabled = false;
    }
  }
}
async function setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock) {
  const unlock = await senderLock.lock();
  livekitLogger.debug("setPublishingLayersForSender", {
    sender,
    qualities,
    senderEncodings
  });
  try {
    const params = sender.getParameters();
    const {
      encodings
    } = params;
    if (!encodings) {
      return;
    }
    if (encodings.length !== senderEncodings.length) {
      livekitLogger.warn("cannot set publishing layers, encodings mismatch");
      return;
    }
    let hasChanged = false;
    encodings.forEach((encoding, idx) => {
      var _a2;
      let rid = (_a2 = encoding.rid) !== null && _a2 !== void 0 ? _a2 : "";
      if (rid === "") {
        rid = "q";
      }
      const quality = videoQualityForRid(rid);
      const subscribedQuality = qualities.find((q) => q.quality === quality);
      if (!subscribedQuality) {
        return;
      }
      if (encoding.active !== subscribedQuality.enabled) {
        hasChanged = true;
        encoding.active = subscribedQuality.enabled;
        livekitLogger.debug("setting layer ".concat(subscribedQuality.quality, " to ").concat(encoding.active ? "enabled" : "disabled"));
        if (isFireFox()) {
          if (subscribedQuality.enabled) {
            encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;
            encoding.maxBitrate = senderEncodings[idx].maxBitrate;
            encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;
          } else {
            encoding.scaleResolutionDownBy = 4;
            encoding.maxBitrate = 10;
            encoding.maxFrameRate = 2;
          }
        }
      }
    });
    if (hasChanged) {
      params.encodings = encodings;
      await sender.setParameters(params);
    }
  } finally {
    unlock();
  }
}
function videoQualityForRid(rid) {
  switch (rid) {
    case "f":
      return VideoQuality.HIGH;
    case "h":
      return VideoQuality.MEDIUM;
    case "q":
      return VideoQuality.LOW;
    default:
      return VideoQuality.UNRECOGNIZED;
  }
}
function videoLayersFromEncodings(width, height, encodings) {
  if (!encodings) {
    return [{
      quality: VideoQuality.HIGH,
      width,
      height,
      bitrate: 0,
      ssrc: 0
    }];
  }
  return encodings.map((encoding) => {
    var _a2, _b, _c;
    const scale = (_a2 = encoding.scaleResolutionDownBy) !== null && _a2 !== void 0 ? _a2 : 1;
    let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : "");
    if (quality === VideoQuality.UNRECOGNIZED && encodings.length === 1) {
      quality = VideoQuality.HIGH;
    }
    return {
      quality,
      width: width / scale,
      height: height / scale,
      bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,
      ssrc: 0
    };
  });
}
class RemoteTrack extends Track {
  constructor(mediaTrack, sid, kind, receiver) {
    super(mediaTrack, kind);
    this.sid = sid;
    this.receiver = receiver;
  }
  setMuted(muted) {
    if (this.isMuted !== muted) {
      this.isMuted = muted;
      this._mediaStreamTrack.enabled = !muted;
      this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);
    }
  }
  setMediaStream(stream) {
    this.mediaStream = stream;
    stream.onremovetrack = () => {
      this.receiver = void 0;
      this._currentBitrate = 0;
      this.emit(TrackEvent.Ended, this);
    };
  }
  start() {
    this.startMonitor();
    super.enable();
  }
  stop() {
    this.stopMonitor();
    super.disable();
  }
  startMonitor() {
    if (!this.monitorInterval) {
      this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency);
    }
  }
}
class RemoteAudioTrack extends RemoteTrack {
  constructor(mediaTrack, sid, receiver, audioContext, audioOutput) {
    super(mediaTrack, sid, Track.Kind.Audio, receiver);
    this.monitorReceiver = async () => {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const stats = await this.getReceiverStats();
      if (stats && this.prevStats && this.receiver) {
        this._currentBitrate = computeBitrate(stats, this.prevStats);
      }
      this.prevStats = stats;
    };
    this.audioContext = audioContext;
    this.webAudioPluginNodes = [];
    if (audioOutput) {
      this.sinkId = audioOutput.deviceId;
    }
  }
  setVolume(volume) {
    var _a2;
    for (const el of this.attachedElements) {
      if (this.audioContext) {
        (_a2 = this.gainNode) === null || _a2 === void 0 ? void 0 : _a2.gain.setTargetAtTime(volume, 0, 0.1);
      } else {
        el.volume = volume;
      }
    }
    this.elementVolume = volume;
  }
  getVolume() {
    if (this.elementVolume) {
      return this.elementVolume;
    }
    let highestVolume = 0;
    this.attachedElements.forEach((element) => {
      if (element.volume > highestVolume) {
        highestVolume = element.volume;
      }
    });
    return highestVolume;
  }
  async setSinkId(deviceId) {
    this.sinkId = deviceId;
    await Promise.all(this.attachedElements.map((elm) => {
      if (!supportsSetSinkId(elm)) {
        return;
      }
      return elm.setSinkId(deviceId);
    }));
  }
  attach(element) {
    const needsNewWebAudioConnection = this.attachedElements.length === 0;
    if (!element) {
      element = super.attach();
    } else {
      super.attach(element);
    }
    if (this.elementVolume) {
      element.volume = this.elementVolume;
    }
    if (this.sinkId && supportsSetSinkId(element)) {
      element.setSinkId(this.sinkId);
    }
    if (this.audioContext && needsNewWebAudioConnection) {
      livekitLogger.debug("using audio context mapping");
      this.connectWebAudio(this.audioContext, element);
      element.volume = 0;
      element.muted = true;
    }
    return element;
  }
  detach(element) {
    let detached;
    if (!element) {
      detached = super.detach();
      this.disconnectWebAudio();
    } else {
      detached = super.detach(element);
      if (this.audioContext) {
        if (this.attachedElements.length > 0) {
          this.connectWebAudio(this.audioContext, this.attachedElements[0]);
        } else {
          this.disconnectWebAudio();
        }
      }
    }
    return detached;
  }
  setAudioContext(audioContext) {
    this.audioContext = audioContext;
    if (audioContext && this.attachedElements.length > 0) {
      this.connectWebAudio(audioContext, this.attachedElements[0]);
    } else if (!audioContext) {
      this.disconnectWebAudio();
    }
  }
  setWebAudioPlugins(nodes) {
    this.webAudioPluginNodes = nodes;
    if (this.attachedElements.length > 0 && this.audioContext) {
      this.connectWebAudio(this.audioContext, this.attachedElements[0]);
    }
  }
  connectWebAudio(context2, element) {
    this.disconnectWebAudio();
    this.sourceNode = context2.createMediaStreamSource(element.srcObject);
    let lastNode = this.sourceNode;
    this.webAudioPluginNodes.forEach((node) => {
      lastNode.connect(node);
      lastNode = node;
    });
    this.gainNode = context2.createGain();
    lastNode.connect(this.gainNode);
    this.gainNode.connect(context2.destination);
    if (this.elementVolume) {
      this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);
    }
    if (context2.state !== "running") {
      context2.resume().then(() => {
        if (context2.state !== "running") {
          this.emit(TrackEvent.AudioPlaybackFailed, new Error("Audio Context couldn't be started automatically"));
        }
      }).catch((e2) => {
        this.emit(TrackEvent.AudioPlaybackFailed, e2);
      });
    }
  }
  disconnectWebAudio() {
    var _a2, _b;
    (_a2 = this.gainNode) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
    (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();
    this.gainNode = void 0;
    this.sourceNode = void 0;
  }
  async getReceiverStats() {
    if (!this.receiver || !this.receiver.getStats) {
      return;
    }
    const stats = await this.receiver.getStats();
    let receiverStats;
    stats.forEach((v) => {
      if (v.type === "inbound-rtp") {
        receiverStats = {
          type: "audio",
          timestamp: v.timestamp,
          jitter: v.jitter,
          bytesReceived: v.bytesReceived,
          concealedSamples: v.concealedSamples,
          concealmentEvents: v.concealmentEvents,
          silentConcealedSamples: v.silentConcealedSamples,
          silentConcealmentEvents: v.silentConcealmentEvents,
          totalAudioEnergy: v.totalAudioEnergy,
          totalSamplesDuration: v.totalSamplesDuration
        };
      }
    });
    return receiverStats;
  }
}
function r(r2, e2, n2) {
  var i2, t2, o2;
  void 0 === e2 && (e2 = 50), void 0 === n2 && (n2 = {});
  var a = null != (i2 = n2.isImmediate) && i2, u = null != (t2 = n2.callback) && t2, c = n2.maxWait, v = Date.now(), l = [];
  function f2() {
    if (void 0 !== c) {
      var r3 = Date.now() - v;
      if (r3 + e2 >= c)
        return c - r3;
    }
    return e2;
  }
  var d = function() {
    var e3 = [].slice.call(arguments), n3 = this;
    return new Promise(function(i3, t3) {
      var c2 = a && void 0 === o2;
      if (void 0 !== o2 && clearTimeout(o2), o2 = setTimeout(function() {
        if (o2 = void 0, v = Date.now(), !a) {
          var i4 = r2.apply(n3, e3);
          u && u(i4), l.forEach(function(r3) {
            return (0, r3.resolve)(i4);
          }), l = [];
        }
      }, f2()), c2) {
        var d2 = r2.apply(n3, e3);
        return u && u(d2), i3(d2);
      }
      l.push({
        resolve: i3,
        reject: t3
      });
    });
  };
  return d.cancel = function(r3) {
    void 0 !== o2 && clearTimeout(o2), l.forEach(function(e3) {
      return (0, e3.reject)(r3);
    }), l = [];
  }, d;
}
class CriticalTimers {
}
CriticalTimers.setTimeout = function() {
  return setTimeout(...arguments);
};
CriticalTimers.setInterval = function() {
  return setInterval(...arguments);
};
CriticalTimers.clearTimeout = function() {
  return clearTimeout(...arguments);
};
CriticalTimers.clearInterval = function() {
  return clearInterval(...arguments);
};
const REACTION_DELAY = 100;
class RemoteVideoTrack extends RemoteTrack {
  constructor(mediaTrack, sid, receiver, adaptiveStreamSettings) {
    super(mediaTrack, sid, Track.Kind.Video, receiver);
    this.elementInfos = [];
    this.hasUsedAttach = false;
    this.monitorReceiver = async () => {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const stats = await this.getReceiverStats();
      if (stats && this.prevStats && this.receiver) {
        this._currentBitrate = computeBitrate(stats, this.prevStats);
      }
      this.prevStats = stats;
    };
    this.debouncedHandleResize = r(() => {
      this.updateDimensions();
    }, REACTION_DELAY);
    this.adaptiveStreamSettings = adaptiveStreamSettings;
  }
  get isAdaptiveStream() {
    return this.adaptiveStreamSettings !== void 0;
  }
  get mediaStreamTrack() {
    if (this.isAdaptiveStream && !this.hasUsedAttach) {
      livekitLogger.warn("When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start");
    }
    return this._mediaStreamTrack;
  }
  setMuted(muted) {
    super.setMuted(muted);
    this.attachedElements.forEach((element) => {
      if (muted) {
        detachTrack(this._mediaStreamTrack, element);
      } else {
        attachToElement(this._mediaStreamTrack, element);
      }
    });
  }
  attach(element) {
    if (!element) {
      element = super.attach();
    } else {
      super.attach(element);
    }
    if (this.adaptiveStreamSettings && this.elementInfos.find((info) => info.element === element) === void 0) {
      const elementInfo = new HTMLElementInfo(element);
      this.observeElementInfo(elementInfo);
    }
    this.hasUsedAttach = true;
    return element;
  }
  observeElementInfo(elementInfo) {
    if (this.adaptiveStreamSettings && this.elementInfos.find((info) => info === elementInfo) === void 0) {
      elementInfo.handleResize = () => {
        this.debouncedHandleResize();
      };
      elementInfo.handleVisibilityChanged = () => {
        this.updateVisibility();
      };
      this.elementInfos.push(elementInfo);
      elementInfo.observe();
      this.debouncedHandleResize();
      this.updateVisibility();
    } else {
      livekitLogger.warn("visibility resize observer not triggered");
    }
  }
  stopObservingElementInfo(elementInfo) {
    if (!this.isAdaptiveStream) {
      livekitLogger.warn("stopObservingElementInfo ignored");
      return;
    }
    const stopElementInfos = this.elementInfos.filter((info) => info === elementInfo);
    for (const info of stopElementInfos) {
      info.stopObserving();
    }
    this.elementInfos = this.elementInfos.filter((info) => info !== elementInfo);
    this.updateVisibility();
  }
  detach(element) {
    let detachedElements = [];
    if (element) {
      this.stopObservingElement(element);
      return super.detach(element);
    }
    detachedElements = super.detach();
    for (const e2 of detachedElements) {
      this.stopObservingElement(e2);
    }
    return detachedElements;
  }
  getDecoderImplementation() {
    var _a2;
    return (_a2 = this.prevStats) === null || _a2 === void 0 ? void 0 : _a2.decoderImplementation;
  }
  async getReceiverStats() {
    if (!this.receiver || !this.receiver.getStats) {
      return;
    }
    const stats = await this.receiver.getStats();
    let receiverStats;
    stats.forEach((v) => {
      if (v.type === "inbound-rtp") {
        receiverStats = {
          type: "video",
          framesDecoded: v.framesDecoded,
          framesDropped: v.framesDropped,
          framesReceived: v.framesReceived,
          packetsReceived: v.packetsReceived,
          packetsLost: v.packetsLost,
          frameWidth: v.frameWidth,
          frameHeight: v.frameHeight,
          pliCount: v.pliCount,
          firCount: v.firCount,
          nackCount: v.nackCount,
          jitter: v.jitter,
          timestamp: v.timestamp,
          bytesReceived: v.bytesReceived,
          decoderImplementation: v.decoderImplementation
        };
      }
    });
    return receiverStats;
  }
  stopObservingElement(element) {
    const stopElementInfos = this.elementInfos.filter((info) => info.element === element);
    for (const info of stopElementInfos) {
      info.stopObserving();
    }
    this.elementInfos = this.elementInfos.filter((info) => info.element !== element);
  }
  async handleAppVisibilityChanged() {
    await super.handleAppVisibilityChanged();
    if (!this.isAdaptiveStream)
      return;
    this.updateVisibility();
  }
  updateVisibility() {
    var _a2, _b;
    const lastVisibilityChange = this.elementInfos.reduce((prev, info) => Math.max(prev, info.visibilityChangedAt || 0), 0);
    const backgroundPause = ((_b = (_a2 = this.adaptiveStreamSettings) === null || _a2 === void 0 ? void 0 : _a2.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true) ? this.isInBackground : false;
    const isVisible = this.elementInfos.some((info) => info.visible) && !backgroundPause;
    if (this.lastVisible === isVisible) {
      return;
    }
    if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {
      CriticalTimers.setTimeout(() => {
        this.updateVisibility();
      }, REACTION_DELAY);
      return;
    }
    this.lastVisible = isVisible;
    this.emit(TrackEvent.VisibilityChanged, isVisible, this);
  }
  updateDimensions() {
    var _a2, _b, _c, _d;
    let maxWidth = 0;
    let maxHeight = 0;
    for (const info of this.elementInfos) {
      const pixelDensity = (_b = (_a2 = this.adaptiveStreamSettings) === null || _a2 === void 0 ? void 0 : _a2.pixelDensity) !== null && _b !== void 0 ? _b : 1;
      const pixelDensityValue = pixelDensity === "screen" ? window.devicePixelRatio : pixelDensity;
      const currentElementWidth = info.width() * pixelDensityValue;
      const currentElementHeight = info.height() * pixelDensityValue;
      if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {
        maxWidth = currentElementWidth;
        maxHeight = currentElementHeight;
      }
    }
    if (((_c = this.lastDimensions) === null || _c === void 0 ? void 0 : _c.width) === maxWidth && ((_d = this.lastDimensions) === null || _d === void 0 ? void 0 : _d.height) === maxHeight) {
      return;
    }
    this.lastDimensions = {
      width: maxWidth,
      height: maxHeight
    };
    this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);
  }
}
class HTMLElementInfo {
  constructor(element, visible) {
    this.onVisibilityChanged = (entry) => {
      var _a2;
      const {
        target,
        isIntersecting
      } = entry;
      if (target === this.element) {
        this.visible = isIntersecting;
        this.visibilityChangedAt = Date.now();
        (_a2 = this.handleVisibilityChanged) === null || _a2 === void 0 ? void 0 : _a2.call(this);
      }
    };
    this.element = element;
    this.visible = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);
    this.visibilityChangedAt = 0;
  }
  width() {
    return this.element.clientWidth;
  }
  height() {
    return this.element.clientHeight;
  }
  observe() {
    this.element.handleResize = () => {
      var _a2;
      (_a2 = this.handleResize) === null || _a2 === void 0 ? void 0 : _a2.call(this);
    };
    this.element.handleVisibilityChanged = this.onVisibilityChanged;
    getIntersectionObserver().observe(this.element);
    getResizeObserver().observe(this.element);
  }
  stopObserving() {
    var _a2, _b;
    (_a2 = getIntersectionObserver()) === null || _a2 === void 0 ? void 0 : _a2.unobserve(this.element);
    (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);
  }
}
function isElementInViewport(el) {
  let top = el.offsetTop;
  let left = el.offsetLeft;
  const width = el.offsetWidth;
  const height = el.offsetHeight;
  const {
    hidden
  } = el;
  const {
    opacity,
    display
  } = getComputedStyle(el);
  while (el.offsetParent) {
    el = el.offsetParent;
    top += el.offsetTop;
    left += el.offsetLeft;
  }
  return top < window.pageYOffset + window.innerHeight && left < window.pageXOffset + window.innerWidth && top + height > window.pageYOffset && left + width > window.pageXOffset && !hidden && (opacity !== "" ? parseFloat(opacity) > 0 : true) && display !== "none";
}
class TrackPublication extends eventsExports.EventEmitter {
  constructor(kind, id, name2) {
    super();
    this.metadataMuted = false;
    this.handleMuted = () => {
      this.emit(TrackEvent.Muted);
    };
    this.handleUnmuted = () => {
      this.emit(TrackEvent.Unmuted);
    };
    this.setMaxListeners(100);
    this.kind = kind;
    this.trackSid = id;
    this.trackName = name2;
    this.source = Track.Source.Unknown;
  }
  setTrack(track) {
    if (this.track) {
      this.track.off(TrackEvent.Muted, this.handleMuted);
      this.track.off(TrackEvent.Unmuted, this.handleUnmuted);
    }
    this.track = track;
    if (track) {
      track.on(TrackEvent.Muted, this.handleMuted);
      track.on(TrackEvent.Unmuted, this.handleUnmuted);
    }
  }
  get isMuted() {
    return this.metadataMuted;
  }
  get isEnabled() {
    return true;
  }
  get isSubscribed() {
    return this.track !== void 0;
  }
  get audioTrack() {
    if (this.track instanceof LocalAudioTrack || this.track instanceof RemoteAudioTrack) {
      return this.track;
    }
  }
  get videoTrack() {
    if (this.track instanceof LocalVideoTrack || this.track instanceof RemoteVideoTrack) {
      return this.track;
    }
  }
  updateInfo(info) {
    this.trackSid = info.sid;
    this.trackName = info.name;
    this.source = Track.sourceFromProto(info.source);
    this.mimeType = info.mimeType;
    if (this.kind === Track.Kind.Video && info.width > 0) {
      this.dimensions = {
        width: info.width,
        height: info.height
      };
      this.simulcasted = info.simulcast;
    }
    this.trackInfo = info;
    livekitLogger.trace("update publication info", {
      info
    });
  }
}
(function(TrackPublication2) {
  (function(SubscriptionStatus) {
    SubscriptionStatus["Desired"] = "desired";
    SubscriptionStatus["Subscribed"] = "subscribed";
    SubscriptionStatus["Unsubscribed"] = "unsubscribed";
  })(TrackPublication2.SubscriptionStatus || (TrackPublication2.SubscriptionStatus = {}));
  (function(PermissionStatus) {
    PermissionStatus["Allowed"] = "allowed";
    PermissionStatus["NotAllowed"] = "not_allowed";
  })(TrackPublication2.PermissionStatus || (TrackPublication2.PermissionStatus = {}));
})(TrackPublication || (TrackPublication = {}));
class LocalTrackPublication extends TrackPublication {
  get isUpstreamPaused() {
    var _a2;
    return (_a2 = this.track) === null || _a2 === void 0 ? void 0 : _a2.isUpstreamPaused;
  }
  constructor(kind, ti, track) {
    super(kind, ti.sid, ti.name);
    this.track = void 0;
    this.handleTrackEnded = () => {
      this.emit(TrackEvent.Ended);
    };
    this.updateInfo(ti);
    this.setTrack(track);
  }
  setTrack(track) {
    if (this.track) {
      this.track.off(TrackEvent.Ended, this.handleTrackEnded);
    }
    super.setTrack(track);
    if (track) {
      track.on(TrackEvent.Ended, this.handleTrackEnded);
    }
  }
  get isMuted() {
    if (this.track) {
      return this.track.isMuted;
    }
    return super.isMuted;
  }
  get audioTrack() {
    return super.audioTrack;
  }
  get videoTrack() {
    return super.videoTrack;
  }
  async mute() {
    var _a2;
    return (_a2 = this.track) === null || _a2 === void 0 ? void 0 : _a2.mute();
  }
  async unmute() {
    var _a2;
    return (_a2 = this.track) === null || _a2 === void 0 ? void 0 : _a2.unmute();
  }
  async pauseUpstream() {
    var _a2;
    await ((_a2 = this.track) === null || _a2 === void 0 ? void 0 : _a2.pauseUpstream());
  }
  async resumeUpstream() {
    var _a2;
    await ((_a2 = this.track) === null || _a2 === void 0 ? void 0 : _a2.resumeUpstream());
  }
}
class VideoPreset {
  constructor(width, height, maxBitrate, maxFramerate) {
    this.width = width;
    this.height = height;
    this.encoding = {
      maxBitrate,
      maxFramerate
    };
  }
  get resolution() {
    return {
      width: this.width,
      height: this.height,
      frameRate: this.encoding.maxFramerate,
      aspectRatio: this.width / this.height
    };
  }
}
const backupCodecs = ["vp8", "h264"];
function isBackupCodec(codec) {
  return !!backupCodecs.find((backup) => backup === codec);
}
var AudioPresets;
(function(AudioPresets2) {
  AudioPresets2.telephone = {
    maxBitrate: 12e3
  };
  AudioPresets2.speech = {
    maxBitrate: 2e4
  };
  AudioPresets2.music = {
    maxBitrate: 32e3
  };
  AudioPresets2.musicStereo = {
    maxBitrate: 48e3
  };
  AudioPresets2.musicHighQuality = {
    maxBitrate: 64e3
  };
  AudioPresets2.musicHighQualityStereo = {
    maxBitrate: 96e3
  };
})(AudioPresets || (AudioPresets = {}));
const VideoPresets = {
  h90: new VideoPreset(160, 90, 6e4, 15),
  h180: new VideoPreset(320, 180, 12e4, 15),
  h216: new VideoPreset(384, 216, 18e4, 15),
  h360: new VideoPreset(640, 360, 3e5, 20),
  h540: new VideoPreset(960, 540, 6e5, 25),
  h720: new VideoPreset(1280, 720, 17e5, 30),
  h1080: new VideoPreset(1920, 1080, 3e6, 30),
  h1440: new VideoPreset(2560, 1440, 5e6, 30),
  h2160: new VideoPreset(3840, 2160, 8e6, 30)
};
const VideoPresets43 = {
  h120: new VideoPreset(160, 120, 8e4, 15),
  h180: new VideoPreset(240, 180, 1e5, 15),
  h240: new VideoPreset(320, 240, 15e4, 15),
  h360: new VideoPreset(480, 360, 225e3, 20),
  h480: new VideoPreset(640, 480, 3e5, 20),
  h540: new VideoPreset(720, 540, 45e4, 25),
  h720: new VideoPreset(960, 720, 15e5, 30),
  h1080: new VideoPreset(1440, 1080, 25e5, 30),
  h1440: new VideoPreset(1920, 1440, 35e5, 30)
};
const ScreenSharePresets = {
  h360fps3: new VideoPreset(640, 360, 2e5, 3),
  h720fps5: new VideoPreset(1280, 720, 4e5, 5),
  h720fps15: new VideoPreset(1280, 720, 1e6, 15),
  h1080fps15: new VideoPreset(1920, 1080, 15e5, 15),
  h1080fps30: new VideoPreset(1920, 1080, 3e6, 30)
};
var ConnectionQuality;
(function(ConnectionQuality2) {
  ConnectionQuality2["Excellent"] = "excellent";
  ConnectionQuality2["Good"] = "good";
  ConnectionQuality2["Poor"] = "poor";
  ConnectionQuality2["Unknown"] = "unknown";
})(ConnectionQuality || (ConnectionQuality = {}));
function qualityFromProto(q) {
  switch (q) {
    case ConnectionQuality$1.EXCELLENT:
      return ConnectionQuality.Excellent;
    case ConnectionQuality$1.GOOD:
      return ConnectionQuality.Good;
    case ConnectionQuality$1.POOR:
      return ConnectionQuality.Poor;
    default:
      return ConnectionQuality.Unknown;
  }
}
class Participant extends eventsExports.EventEmitter {
  constructor(sid, identity2, name2, metadata) {
    super();
    this.audioLevel = 0;
    this.isSpeaking = false;
    this._connectionQuality = ConnectionQuality.Unknown;
    this.setMaxListeners(100);
    this.sid = sid;
    this.identity = identity2;
    this.name = name2;
    this.metadata = metadata;
    this.audioTracks = /* @__PURE__ */ new Map();
    this.videoTracks = /* @__PURE__ */ new Map();
    this.tracks = /* @__PURE__ */ new Map();
  }
  getTracks() {
    return Array.from(this.tracks.values());
  }
  getTrack(source2) {
    for (const [, pub] of this.tracks) {
      if (pub.source === source2) {
        return pub;
      }
    }
  }
  getTrackByName(name2) {
    for (const [, pub] of this.tracks) {
      if (pub.trackName === name2) {
        return pub;
      }
    }
  }
  get connectionQuality() {
    return this._connectionQuality;
  }
  get isCameraEnabled() {
    var _a2;
    const track = this.getTrack(Track.Source.Camera);
    return !((_a2 = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a2 !== void 0 ? _a2 : true);
  }
  get isMicrophoneEnabled() {
    var _a2;
    const track = this.getTrack(Track.Source.Microphone);
    return !((_a2 = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a2 !== void 0 ? _a2 : true);
  }
  get isScreenShareEnabled() {
    const track = this.getTrack(Track.Source.ScreenShare);
    return !!track;
  }
  get isLocal() {
    return false;
  }
  get joinedAt() {
    if (this.participantInfo) {
      return new Date(this.participantInfo.joinedAt * 1e3);
    }
    return new Date();
  }
  updateInfo(info) {
    this.identity = info.identity;
    this.sid = info.sid;
    this.name = info.name;
    this.setMetadata(info.metadata);
    if (info.permission) {
      this.setPermissions(info.permission);
    }
    this.participantInfo = info;
    livekitLogger.trace("update participant info", {
      info
    });
  }
  setMetadata(md) {
    const changed = this.metadata !== md;
    const prevMetadata = this.metadata;
    this.metadata = md;
    if (changed) {
      this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);
    }
  }
  setPermissions(permissions2) {
    var _a2, _b, _c, _d, _e;
    const prevPermissions = this.permissions;
    const changed = permissions2.canPublish !== ((_a2 = this.permissions) === null || _a2 === void 0 ? void 0 : _a2.canPublish) || permissions2.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions2.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions2.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions2.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions2.canPublishSources.length !== this.permissions.canPublishSources.length || permissions2.canPublishSources.some((value, index2) => {
      var _a3;
      return value !== ((_a3 = this.permissions) === null || _a3 === void 0 ? void 0 : _a3.canPublishSources[index2]);
    });
    this.permissions = permissions2;
    if (changed) {
      this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);
    }
    return changed;
  }
  setIsSpeaking(speaking) {
    if (speaking === this.isSpeaking) {
      return;
    }
    this.isSpeaking = speaking;
    if (speaking) {
      this.lastSpokeAt = new Date();
    }
    this.emit(ParticipantEvent.IsSpeakingChanged, speaking);
  }
  setConnectionQuality(q) {
    const prevQuality = this._connectionQuality;
    this._connectionQuality = qualityFromProto(q);
    if (prevQuality !== this._connectionQuality) {
      this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);
    }
  }
  addTrackPublication(publication) {
    publication.on(TrackEvent.Muted, () => {
      this.emit(ParticipantEvent.TrackMuted, publication);
    });
    publication.on(TrackEvent.Unmuted, () => {
      this.emit(ParticipantEvent.TrackUnmuted, publication);
    });
    const pub = publication;
    if (pub.track) {
      pub.track.sid = publication.trackSid;
    }
    this.tracks.set(publication.trackSid, publication);
    switch (publication.kind) {
      case Track.Kind.Audio:
        this.audioTracks.set(publication.trackSid, publication);
        break;
      case Track.Kind.Video:
        this.videoTracks.set(publication.trackSid, publication);
        break;
    }
  }
}
function trackPermissionToProto(perms) {
  var _a2, _b, _c;
  if (!perms.participantSid && !perms.participantIdentity) {
    throw new Error("Invalid track permission, must provide at least one of participantIdentity and participantSid");
  }
  return {
    participantIdentity: (_a2 = perms.participantIdentity) !== null && _a2 !== void 0 ? _a2 : "",
    participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : "",
    allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,
    trackSids: perms.allowedTrackSids || []
  };
}
function mediaTrackToLocalTrack(mediaStreamTrack, constraints) {
  switch (mediaStreamTrack.kind) {
    case "audio":
      return new LocalAudioTrack(mediaStreamTrack, constraints, false);
    case "video":
      return new LocalVideoTrack(mediaStreamTrack, constraints, false);
    default:
      throw new TrackInvalidError("unsupported track type: ".concat(mediaStreamTrack.kind));
  }
}
const presets169 = Object.values(VideoPresets);
const presets43 = Object.values(VideoPresets43);
const presetsScreenShare = Object.values(ScreenSharePresets);
const defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360];
const defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360];
const computeDefaultScreenShareSimulcastPresets = (fromPreset) => {
  const layers = [{
    scaleResolutionDownBy: 2,
    fps: 3
  }];
  return layers.map((t2) => {
    var _a2;
    return new VideoPreset(Math.floor(fromPreset.width / t2.scaleResolutionDownBy), Math.floor(fromPreset.height / t2.scaleResolutionDownBy), Math.max(15e4, Math.floor(fromPreset.encoding.maxBitrate / (t2.scaleResolutionDownBy ** 2 * (((_a2 = fromPreset.encoding.maxFramerate) !== null && _a2 !== void 0 ? _a2 : 30) / t2.fps)))), t2.fps);
  });
};
const videoRids = ["q", "h", "f"];
function computeVideoEncodings(isScreenShare, width, height, options) {
  var _a2, _b;
  let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;
  if (isScreenShare) {
    videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;
  }
  const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;
  const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;
  const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;
  if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {
    return [{}];
  }
  if (!videoEncoding) {
    videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);
    livekitLogger.debug("using video encoding", videoEncoding);
  }
  const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate);
  if (scalabilityMode && videoCodec === "av1") {
    livekitLogger.debug("using svc with scalabilityMode ".concat(scalabilityMode));
    const encodings = [];
    switch (scalabilityMode) {
      case "L3T3":
        for (let i2 = 0; i2 < 3; i2 += 1) {
          encodings.push({
            rid: videoRids[2 - i2],
            scaleResolutionDownBy: 2 ** i2,
            maxBitrate: videoEncoding.maxBitrate / 3 ** i2,
            maxFramerate: original.encoding.maxFramerate,
            scalabilityMode: "L3T3"
          });
        }
        livekitLogger.debug("encodings", encodings);
        return encodings;
      default:
        throw new Error("unsupported scalabilityMode: ".concat(scalabilityMode));
    }
  }
  if (!useSimulcast) {
    return [videoEncoding];
  }
  let presets = [];
  if (isScreenShare) {
    presets = (_a2 = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a2 !== void 0 ? _a2 : defaultSimulcastLayers(isScreenShare, original);
  } else {
    presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);
  }
  let midPreset;
  if (presets.length > 0) {
    const lowPreset = presets[0];
    if (presets.length > 1) {
      [, midPreset] = presets;
    }
    const size = Math.max(width, height);
    if (size >= 960 && midPreset) {
      return encodingsFromPresets(width, height, [lowPreset, midPreset, original]);
    }
    if (size >= 480) {
      return encodingsFromPresets(width, height, [lowPreset, original]);
    }
  }
  return encodingsFromPresets(width, height, [original]);
}
function computeTrackBackupEncodings(track, videoCodec, opts) {
  var _a2, _b, _c, _d;
  if (!opts.backupCodec || opts.backupCodec.codec === opts.videoCodec) {
    return;
  }
  if (videoCodec !== opts.backupCodec.codec) {
    livekitLogger.warn("requested a different codec than specified as backup", {
      serverRequested: videoCodec,
      backup: opts.backupCodec.codec
    });
  }
  opts.videoCodec = videoCodec;
  opts.videoEncoding = opts.backupCodec.encoding;
  const settings = track.mediaStreamTrack.getSettings();
  const width = (_a2 = settings.width) !== null && _a2 !== void 0 ? _a2 : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;
  const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;
  const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);
  return encodings;
}
function determineAppropriateEncoding(isScreenShare, width, height, codec) {
  const presets = presetsForResolution(isScreenShare, width, height);
  let {
    encoding
  } = presets[0];
  const size = Math.max(width, height);
  for (let i2 = 0; i2 < presets.length; i2 += 1) {
    const preset = presets[i2];
    encoding = preset.encoding;
    if (preset.width >= size) {
      break;
    }
  }
  if (codec) {
    switch (codec) {
      case "av1":
        encoding.maxBitrate = encoding.maxBitrate * 0.7;
        break;
    }
  }
  return encoding;
}
function presetsForResolution(isScreenShare, width, height) {
  if (isScreenShare) {
    return presetsScreenShare;
  }
  const aspect = width > height ? width / height : height / width;
  if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
    return presets169;
  }
  return presets43;
}
function defaultSimulcastLayers(isScreenShare, original) {
  if (isScreenShare) {
    return computeDefaultScreenShareSimulcastPresets(original);
  }
  const {
    width,
    height
  } = original;
  const aspect = width > height ? width / height : height / width;
  if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
    return defaultSimulcastPresets169;
  }
  return defaultSimulcastPresets43;
}
function encodingsFromPresets(width, height, presets) {
  const encodings = [];
  presets.forEach((preset, idx) => {
    if (idx >= videoRids.length) {
      return;
    }
    const size = Math.min(width, height);
    const rid = videoRids[idx];
    encodings.push({
      rid,
      scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),
      maxBitrate: preset.encoding.maxBitrate,
      maxFramerate: preset.encoding.maxFramerate
    });
  });
  return encodings;
}
function sortPresets(presets) {
  if (!presets)
    return;
  return presets.sort((a, b) => {
    const {
      encoding: aEnc
    } = a;
    const {
      encoding: bEnc
    } = b;
    if (aEnc.maxBitrate > bEnc.maxBitrate) {
      return 1;
    }
    if (aEnc.maxBitrate < bEnc.maxBitrate)
      return -1;
    if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {
      return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;
    }
    return 0;
  });
}
class RemoteTrackPublication extends TrackPublication {
  constructor(kind, ti, autoSubscribe) {
    super(kind, ti.sid, ti.name);
    this.track = void 0;
    this.allowed = true;
    this.disabled = false;
    this.currentVideoQuality = VideoQuality.HIGH;
    this.handleEnded = (track) => {
      this.setTrack(void 0);
      this.emit(TrackEvent.Ended, track);
    };
    this.handleVisibilityChange = (visible) => {
      livekitLogger.debug("adaptivestream video visibility ".concat(this.trackSid, ", visible=").concat(visible), {
        trackSid: this.trackSid
      });
      this.disabled = !visible;
      this.emitTrackUpdate();
    };
    this.handleVideoDimensionsChange = (dimensions) => {
      livekitLogger.debug("adaptivestream video dimensions ".concat(dimensions.width, "x").concat(dimensions.height), {
        trackSid: this.trackSid
      });
      this.videoDimensions = dimensions;
      this.emitTrackUpdate();
    };
    this.subscribed = autoSubscribe;
    this.updateInfo(ti);
  }
  setSubscribed(subscribed) {
    const prevStatus = this.subscriptionStatus;
    const prevPermission = this.permissionStatus;
    this.subscribed = subscribed;
    if (subscribed) {
      this.allowed = true;
    }
    const sub = {
      trackSids: [this.trackSid],
      subscribe: this.subscribed,
      participantTracks: [{
        participantSid: "",
        trackSids: [this.trackSid]
      }]
    };
    this.emit(TrackEvent.UpdateSubscription, sub);
    this.emitSubscriptionUpdateIfChanged(prevStatus);
    this.emitPermissionUpdateIfChanged(prevPermission);
  }
  get subscriptionStatus() {
    if (this.subscribed === false) {
      return TrackPublication.SubscriptionStatus.Unsubscribed;
    }
    if (!super.isSubscribed) {
      return TrackPublication.SubscriptionStatus.Desired;
    }
    return TrackPublication.SubscriptionStatus.Subscribed;
  }
  get permissionStatus() {
    return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;
  }
  get isSubscribed() {
    if (this.subscribed === false) {
      return false;
    }
    return super.isSubscribed;
  }
  get isDesired() {
    return this.subscribed !== false;
  }
  get isEnabled() {
    return !this.disabled;
  }
  setEnabled(enabled) {
    if (!this.isManualOperationAllowed() || this.disabled === !enabled) {
      return;
    }
    this.disabled = !enabled;
    this.emitTrackUpdate();
  }
  setVideoQuality(quality) {
    if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {
      return;
    }
    this.currentVideoQuality = quality;
    this.videoDimensions = void 0;
    this.emitTrackUpdate();
  }
  setVideoDimensions(dimensions) {
    var _a2, _b;
    if (!this.isManualOperationAllowed()) {
      return;
    }
    if (((_a2 = this.videoDimensions) === null || _a2 === void 0 ? void 0 : _a2.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {
      return;
    }
    if (this.track instanceof RemoteVideoTrack) {
      this.videoDimensions = dimensions;
    }
    this.currentVideoQuality = void 0;
    this.emitTrackUpdate();
  }
  setVideoFPS(fps) {
    if (!this.isManualOperationAllowed()) {
      return;
    }
    if (!(this.track instanceof RemoteVideoTrack)) {
      return;
    }
    if (this.fps === fps) {
      return;
    }
    this.fps = fps;
    this.emitTrackUpdate();
  }
  get videoQuality() {
    return this.currentVideoQuality;
  }
  setTrack(track) {
    const prevStatus = this.subscriptionStatus;
    const prevPermission = this.permissionStatus;
    const prevTrack = this.track;
    if (prevTrack === track) {
      return;
    }
    if (prevTrack) {
      prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
      prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);
      prevTrack.off(TrackEvent.Ended, this.handleEnded);
      prevTrack.detach();
      this.emit(TrackEvent.Unsubscribed, prevTrack);
    }
    super.setTrack(track);
    if (track) {
      track.sid = this.trackSid;
      track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
      track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);
      track.on(TrackEvent.Ended, this.handleEnded);
      this.emit(TrackEvent.Subscribed, track);
    }
    this.emitPermissionUpdateIfChanged(prevPermission);
    this.emitSubscriptionUpdateIfChanged(prevStatus);
  }
  setAllowed(allowed) {
    const prevStatus = this.subscriptionStatus;
    const prevPermission = this.permissionStatus;
    this.allowed = allowed;
    this.emitPermissionUpdateIfChanged(prevPermission);
    this.emitSubscriptionUpdateIfChanged(prevStatus);
  }
  updateInfo(info) {
    var _a2;
    super.updateInfo(info);
    this.metadataMuted = info.muted;
    (_a2 = this.track) === null || _a2 === void 0 ? void 0 : _a2.setMuted(info.muted);
  }
  emitSubscriptionUpdateIfChanged(previousStatus) {
    const currentStatus = this.subscriptionStatus;
    if (previousStatus === currentStatus) {
      return;
    }
    this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);
  }
  emitPermissionUpdateIfChanged(previousPermissionStatus) {
    const currentPermissionStatus = this.permissionStatus;
    if (currentPermissionStatus !== previousPermissionStatus) {
      this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);
    }
  }
  isManualOperationAllowed() {
    if (this.isAdaptiveStream) {
      livekitLogger.warn("adaptive stream is enabled, cannot change track settings", {
        trackSid: this.trackSid
      });
      return false;
    }
    if (!this.isDesired) {
      livekitLogger.warn("cannot update track settings when not subscribed", {
        trackSid: this.trackSid
      });
      return false;
    }
    return true;
  }
  get isAdaptiveStream() {
    return this.track instanceof RemoteVideoTrack && this.track.isAdaptiveStream;
  }
  emitTrackUpdate() {
    const settings = UpdateTrackSettings.fromPartial({
      trackSids: [this.trackSid],
      disabled: this.disabled,
      fps: this.fps
    });
    if (this.videoDimensions) {
      settings.width = this.videoDimensions.width;
      settings.height = this.videoDimensions.height;
    } else if (this.currentVideoQuality !== void 0) {
      settings.quality = this.currentVideoQuality;
    } else {
      settings.quality = VideoQuality.HIGH;
    }
    this.emit(TrackEvent.UpdateSettings, settings);
  }
}
class RemoteParticipant extends Participant {
  static fromParticipantInfo(signalClient, pi) {
    return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata);
  }
  constructor(signalClient, sid, identity2, name2, metadata) {
    super(sid, identity2 || "", name2, metadata);
    this.signalClient = signalClient;
    this.tracks = /* @__PURE__ */ new Map();
    this.audioTracks = /* @__PURE__ */ new Map();
    this.videoTracks = /* @__PURE__ */ new Map();
  }
  addTrackPublication(publication) {
    super.addTrackPublication(publication);
    publication.on(TrackEvent.UpdateSettings, (settings) => {
      livekitLogger.debug("send update settings", settings);
      this.signalClient.sendUpdateTrackSettings(settings);
    });
    publication.on(TrackEvent.UpdateSubscription, (sub) => {
      sub.participantTracks.forEach((pt) => {
        pt.participantSid = this.sid;
      });
      this.signalClient.sendUpdateSubscription(sub);
    });
    publication.on(TrackEvent.SubscriptionPermissionChanged, (status) => {
      this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);
    });
    publication.on(TrackEvent.SubscriptionStatusChanged, (status) => {
      this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);
    });
    publication.on(TrackEvent.Subscribed, (track) => {
      this.emit(ParticipantEvent.TrackSubscribed, track, publication);
    });
    publication.on(TrackEvent.Unsubscribed, (previousTrack) => {
      this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);
    });
  }
  getTrack(source2) {
    const track = super.getTrack(source2);
    if (track) {
      return track;
    }
  }
  getTrackByName(name2) {
    const track = super.getTrackByName(name2);
    if (track) {
      return track;
    }
  }
  setVolume(volume) {
    this.volume = volume;
    const audioPublication = this.getTrack(Track.Source.Microphone);
    if (audioPublication && audioPublication.track) {
      audioPublication.track.setVolume(volume);
    }
  }
  getVolume() {
    const audioPublication = this.getTrack(Track.Source.Microphone);
    if (audioPublication && audioPublication.track) {
      return audioPublication.track.getVolume();
    }
    return this.volume;
  }
  addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {
    let publication = this.getTrackPublication(sid);
    if (!publication) {
      if (!sid.startsWith("TR")) {
        this.tracks.forEach((p) => {
          if (!publication && mediaTrack.kind === p.kind.toString()) {
            publication = p;
          }
        });
      }
    }
    if (!publication) {
      if (triesLeft === 0) {
        livekitLogger.error("could not find published track", {
          participant: this.sid,
          trackSid: sid
        });
        this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);
        return;
      }
      if (triesLeft === void 0)
        triesLeft = 20;
      setTimeout(() => {
        this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);
      }, 150);
      return;
    }
    if (mediaTrack.readyState === "ended") {
      livekitLogger.error("unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()", {
        participant: this.sid,
        trackSid: sid
      });
      this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);
      return;
    }
    const isVideo = mediaTrack.kind === "video";
    let track;
    if (isVideo) {
      track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);
    } else {
      track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);
    }
    track.source = publication.source;
    track.isMuted = publication.isMuted;
    track.setMediaStream(mediaStream);
    track.start();
    publication.setTrack(track);
    if (this.volume !== void 0 && track instanceof RemoteAudioTrack && track.source === Track.Source.Microphone) {
      track.setVolume(this.volume);
    }
    return publication;
  }
  get hasMetadata() {
    return !!this.participantInfo;
  }
  getTrackPublication(sid) {
    return this.tracks.get(sid);
  }
  updateInfo(info) {
    super.updateInfo(info);
    const validTracks = /* @__PURE__ */ new Map();
    const newTracks = /* @__PURE__ */ new Map();
    info.tracks.forEach((ti) => {
      var _a2;
      let publication = this.getTrackPublication(ti.sid);
      if (!publication) {
        const kind = Track.kindFromProto(ti.type);
        if (!kind) {
          return;
        }
        publication = new RemoteTrackPublication(kind, ti, (_a2 = this.signalClient.connectOptions) === null || _a2 === void 0 ? void 0 : _a2.autoSubscribe);
        publication.updateInfo(ti);
        newTracks.set(ti.sid, publication);
        const existingTrackOfSource = Array.from(this.tracks.values()).find((publishedTrack) => publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));
        if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {
          livekitLogger.debug("received a second track publication for ".concat(this.identity, " with the same source: ").concat(publication.source), {
            oldTrack: existingTrackOfSource,
            newTrack: publication,
            participant: this,
            participantInfo: info
          });
        }
        this.addTrackPublication(publication);
      } else {
        publication.updateInfo(ti);
      }
      validTracks.set(ti.sid, publication);
    });
    this.tracks.forEach((publication) => {
      if (!validTracks.has(publication.trackSid)) {
        livekitLogger.trace("detected removed track on remote participant, unpublishing", {
          publication,
          participantSid: this.sid
        });
        this.unpublishTrack(publication.trackSid, true);
      }
    });
    newTracks.forEach((publication) => {
      this.emit(ParticipantEvent.TrackPublished, publication);
    });
  }
  unpublishTrack(sid, sendUnpublish) {
    const publication = this.tracks.get(sid);
    if (!publication) {
      return;
    }
    this.tracks.delete(sid);
    switch (publication.kind) {
      case Track.Kind.Audio:
        this.audioTracks.delete(sid);
        break;
      case Track.Kind.Video:
        this.videoTracks.delete(sid);
        break;
    }
    const {
      track
    } = publication;
    if (track) {
      track.stop();
      publication.setTrack(void 0);
    }
    if (sendUnpublish) {
      this.emit(ParticipantEvent.TrackUnpublished, publication);
    }
  }
  setAudioContext(ctx) {
    this.audioContext = ctx;
    this.audioTracks.forEach((track) => track.track instanceof RemoteAudioTrack && track.track.setAudioContext(ctx));
  }
  async setAudioOutput(output) {
    this.audioOutput = output;
    const promises = [];
    this.audioTracks.forEach((pub) => {
      var _a2;
      if (pub.track instanceof RemoteAudioTrack) {
        promises.push(pub.track.setSinkId((_a2 = output.deviceId) !== null && _a2 !== void 0 ? _a2 : "default"));
      }
    });
    await Promise.all(promises);
  }
  emit(event2) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    livekitLogger.trace("participant event", {
      participant: this.sid,
      event: event2,
      args
    });
    return super.emit(event2, ...args);
  }
}
class LocalParticipant extends Participant {
  constructor(sid, identity2, engine, options) {
    super(sid, identity2);
    this.pendingPublishing = /* @__PURE__ */ new Set();
    this.pendingPublishPromises = /* @__PURE__ */ new Map();
    this.participantTrackPermissions = [];
    this.allParticipantsAllowedToSubscribe = true;
    this.handleReconnecting = () => {
      if (!this.reconnectFuture) {
        this.reconnectFuture = new Future();
      }
    };
    this.handleReconnected = () => {
      var _a2, _b;
      (_b = (_a2 = this.reconnectFuture) === null || _a2 === void 0 ? void 0 : _a2.resolve) === null || _b === void 0 ? void 0 : _b.call(_a2);
      this.reconnectFuture = void 0;
      this.updateTrackSubscriptionPermissions();
    };
    this.handleDisconnected = () => {
      var _a2, _b;
      (_b = (_a2 = this.reconnectFuture) === null || _a2 === void 0 ? void 0 : _a2.reject) === null || _b === void 0 ? void 0 : _b.call(_a2, "Got disconnected during publishing attempt");
      this.reconnectFuture = void 0;
    };
    this.updateTrackSubscriptionPermissions = () => {
      livekitLogger.debug("updating track subscription permissions", {
        allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,
        participantTrackPermissions: this.participantTrackPermissions
      });
      this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p) => trackPermissionToProto(p)));
    };
    this.onTrackUnmuted = (track) => {
      this.onTrackMuted(track, track.isUpstreamPaused);
    };
    this.onTrackMuted = (track, muted) => {
      if (muted === void 0) {
        muted = true;
      }
      if (!track.sid) {
        livekitLogger.error("could not update mute status for unpublished track", track);
        return;
      }
      this.engine.updateMuteStatus(track.sid, muted);
    };
    this.onTrackUpstreamPaused = (track) => {
      livekitLogger.debug("upstream paused");
      this.onTrackMuted(track, true);
    };
    this.onTrackUpstreamResumed = (track) => {
      livekitLogger.debug("upstream resumed");
      this.onTrackMuted(track, track.isMuted);
    };
    this.handleSubscribedQualityUpdate = async (update) => {
      var _a2, _b;
      if (!((_a2 = this.roomOptions) === null || _a2 === void 0 ? void 0 : _a2.dynacast)) {
        return;
      }
      const pub = this.videoTracks.get(update.trackSid);
      if (!pub) {
        livekitLogger.warn("received subscribed quality update for unknown track", {
          method: "handleSubscribedQualityUpdate",
          sid: update.trackSid
        });
        return;
      }
      if (update.subscribedCodecs.length > 0) {
        if (!pub.videoTrack) {
          return;
        }
        const newCodecs = await pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);
        var _iteratorAbruptCompletion = false;
        var _didIteratorError = false;
        var _iteratorError;
        try {
          for (var _iterator = _asyncIterator(newCodecs), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {
            const codec = _step.value;
            {
              if (isBackupCodec(codec)) {
                livekitLogger.debug("publish ".concat(codec, " for ").concat(pub.videoTrack.sid));
                await this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);
              }
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (_iteratorAbruptCompletion && _iterator.return != null) {
              await _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else if (update.subscribedQualities.length > 0) {
        await ((_b = pub.videoTrack) === null || _b === void 0 ? void 0 : _b.setPublishingLayers(update.subscribedQualities));
      }
    };
    this.handleLocalTrackUnpublished = (unpublished) => {
      const track = this.tracks.get(unpublished.trackSid);
      if (!track) {
        livekitLogger.warn("received unpublished event for unknown track", {
          method: "handleLocalTrackUnpublished",
          trackSid: unpublished.trackSid
        });
        return;
      }
      this.unpublishTrack(track.track);
    };
    this.handleTrackEnded = async (track) => {
      if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {
        livekitLogger.debug("unpublishing local track due to TrackEnded", {
          track: track.sid
        });
        this.unpublishTrack(track);
      } else if (track.isUserProvided) {
        await track.mute();
      } else if (track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) {
        try {
          if (isWeb()) {
            try {
              const currentPermissions = await (navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({
                name: track.source === Track.Source.Camera ? "camera" : "microphone"
              }));
              if (currentPermissions && currentPermissions.state === "denied") {
                livekitLogger.warn("user has revoked access to ".concat(track.source));
                currentPermissions.onchange = () => {
                  if (currentPermissions.state !== "denied") {
                    if (!track.isMuted) {
                      track.restartTrack();
                    }
                    currentPermissions.onchange = null;
                  }
                };
                throw new Error("GetUserMedia Permission denied");
              }
            } catch (e2) {
            }
          }
          if (!track.isMuted) {
            livekitLogger.debug("track ended, attempting to use a different device");
            await track.restartTrack();
          }
        } catch (e2) {
          livekitLogger.warn("could not restart track, muting instead");
          await track.mute();
        }
      }
    };
    this.audioTracks = /* @__PURE__ */ new Map();
    this.videoTracks = /* @__PURE__ */ new Map();
    this.tracks = /* @__PURE__ */ new Map();
    this.engine = engine;
    this.roomOptions = options;
    this.setupEngine(engine);
  }
  get lastCameraError() {
    return this.cameraError;
  }
  get lastMicrophoneError() {
    return this.microphoneError;
  }
  getTrack(source2) {
    const track = super.getTrack(source2);
    if (track) {
      return track;
    }
  }
  getTrackByName(name2) {
    const track = super.getTrackByName(name2);
    if (track) {
      return track;
    }
  }
  setupEngine(engine) {
    this.engine = engine;
    this.engine.client.onRemoteMuteChanged = (trackSid, muted) => {
      const pub = this.tracks.get(trackSid);
      if (!pub || !pub.track) {
        return;
      }
      if (muted) {
        pub.mute();
      } else {
        pub.unmute();
      }
    };
    this.engine.client.onSubscribedQualityUpdate = this.handleSubscribedQualityUpdate;
    this.engine.client.onLocalTrackUnpublished = this.handleLocalTrackUnpublished;
    this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.Restarted, this.handleReconnected).on(EngineEvent.Resumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.Disconnected, this.handleDisconnected);
  }
  setCameraEnabled(enabled, options, publishOptions) {
    return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);
  }
  setMicrophoneEnabled(enabled, options, publishOptions) {
    return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);
  }
  setScreenShareEnabled(enabled, options, publishOptions) {
    return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);
  }
  async setTrackEnabled(source2, enabled, options, publishOptions) {
    var _a2, _b;
    livekitLogger.debug("setTrackEnabled", {
      source: source2,
      enabled
    });
    let track = this.getTrack(source2);
    if (enabled) {
      if (track) {
        await track.unmute();
      } else {
        let localTracks;
        if (this.pendingPublishing.has(source2)) {
          livekitLogger.info("skipping duplicate published source", {
            source: source2
          });
          return;
        }
        this.pendingPublishing.add(source2);
        try {
          switch (source2) {
            case Track.Source.Camera:
              localTracks = await this.createTracks({
                video: (_a2 = options) !== null && _a2 !== void 0 ? _a2 : true
              });
              break;
            case Track.Source.Microphone:
              localTracks = await this.createTracks({
                audio: (_b = options) !== null && _b !== void 0 ? _b : true
              });
              break;
            case Track.Source.ScreenShare:
              localTracks = await this.createScreenTracks(_objectSpread2({}, options));
              break;
            default:
              throw new TrackInvalidError(source2);
          }
          const publishPromises = [];
          for (const localTrack of localTracks) {
            livekitLogger.info("publishing track", {
              localTrack
            });
            publishPromises.push(this.publishTrack(localTrack, publishOptions));
          }
          const publishedTracks = await Promise.all(publishPromises);
          [track] = publishedTracks;
        } catch (e2) {
          if (e2 instanceof Error && !(e2 instanceof TrackInvalidError)) {
            this.emit(ParticipantEvent.MediaDevicesError, e2);
          }
          throw e2;
        } finally {
          this.pendingPublishing.delete(source2);
        }
      }
    } else if (track && track.track) {
      if (source2 === Track.Source.ScreenShare) {
        track = await this.unpublishTrack(track.track);
        const screenAudioTrack = this.getTrack(Track.Source.ScreenShareAudio);
        if (screenAudioTrack && screenAudioTrack.track) {
          this.unpublishTrack(screenAudioTrack.track);
        }
      } else {
        await track.mute();
      }
    }
    return track;
  }
  async enableCameraAndMicrophone() {
    if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {
      return;
    }
    this.pendingPublishing.add(Track.Source.Camera);
    this.pendingPublishing.add(Track.Source.Microphone);
    try {
      const tracks = await this.createTracks({
        audio: true,
        video: true
      });
      await Promise.all(tracks.map((track) => this.publishTrack(track)));
    } finally {
      this.pendingPublishing.delete(Track.Source.Camera);
      this.pendingPublishing.delete(Track.Source.Microphone);
    }
  }
  async createTracks(options) {
    var _a2, _b;
    const opts = mergeDefaultOptions(options, (_a2 = this.roomOptions) === null || _a2 === void 0 ? void 0 : _a2.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);
    const constraints = constraintsForOptions(opts);
    let stream;
    try {
      stream = await navigator.mediaDevices.getUserMedia(constraints);
    } catch (err) {
      if (err instanceof Error) {
        if (constraints.audio) {
          this.microphoneError = err;
        }
        if (constraints.video) {
          this.cameraError = err;
        }
      }
      throw err;
    }
    if (constraints.audio) {
      this.microphoneError = void 0;
    }
    if (constraints.video) {
      this.cameraError = void 0;
    }
    return stream.getTracks().map((mediaStreamTrack) => {
      const isAudio = mediaStreamTrack.kind === "audio";
      isAudio ? options.audio : options.video;
      let trackConstraints;
      const conOrBool = isAudio ? constraints.audio : constraints.video;
      if (typeof conOrBool !== "boolean") {
        trackConstraints = conOrBool;
      }
      const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);
      if (track.kind === Track.Kind.Video) {
        track.source = Track.Source.Camera;
      } else if (track.kind === Track.Kind.Audio) {
        track.source = Track.Source.Microphone;
      }
      track.mediaStream = stream;
      return track;
    });
  }
  async createScreenTracks(options) {
    var _a2;
    if (options === void 0) {
      options = {};
    }
    if (options.resolution === void 0) {
      options.resolution = ScreenSharePresets.h1080fps15.resolution;
    }
    let videoConstraints = true;
    if (options.resolution) {
      if (isSafari()) {
        videoConstraints = {
          width: {
            max: options.resolution.width
          },
          height: {
            max: options.resolution.height
          },
          frameRate: options.resolution.frameRate
        };
      } else {
        videoConstraints = {
          width: {
            ideal: options.resolution.width
          },
          height: {
            ideal: options.resolution.height
          },
          frameRate: options.resolution.frameRate
        };
      }
    }
    if (navigator.mediaDevices.getDisplayMedia === void 0) {
      throw new DeviceUnsupportedError("getDisplayMedia not supported");
    }
    const stream = await navigator.mediaDevices.getDisplayMedia({
      audio: (_a2 = options.audio) !== null && _a2 !== void 0 ? _a2 : false,
      video: videoConstraints,
      controller: options.controller,
      selfBrowserSurface: options.selfBrowserSurface,
      surfaceSwitching: options.surfaceSwitching,
      systemAudio: options.systemAudio
    });
    const tracks = stream.getVideoTracks();
    if (tracks.length === 0) {
      throw new TrackInvalidError("no video track found");
    }
    const screenVideo = new LocalVideoTrack(tracks[0], void 0, false);
    screenVideo.source = Track.Source.ScreenShare;
    const localTracks = [screenVideo];
    if (stream.getAudioTracks().length > 0) {
      const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], void 0, false);
      screenAudio.source = Track.Source.ScreenShareAudio;
      localTracks.push(screenAudio);
    }
    return localTracks;
  }
  async publishTrack(track, options) {
    var _a2, _b, _c;
    await ((_a2 = this.reconnectFuture) === null || _a2 === void 0 ? void 0 : _a2.promise);
    if (track instanceof LocalTrack && this.pendingPublishPromises.has(track)) {
      await this.pendingPublishPromises.get(track);
    }
    if (track instanceof MediaStreamTrack) {
      switch (track.kind) {
        case "audio":
          track = new LocalAudioTrack(track, void 0, true);
          break;
        case "video":
          track = new LocalVideoTrack(track, void 0, true);
          break;
        default:
          throw new TrackInvalidError("unsupported MediaStreamTrack kind ".concat(track.kind));
      }
    }
    let existingPublication;
    this.tracks.forEach((publication) => {
      if (!publication.track) {
        return;
      }
      if (publication.track === track) {
        existingPublication = publication;
      }
    });
    if (existingPublication) {
      livekitLogger.warn("track has already been published, skipping");
      return existingPublication;
    }
    const isStereo = (options === null || options === void 0 ? void 0 : options.forceStereo) || "channelCount" in track.mediaStreamTrack.getSettings() && track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;
    if (isStereo) {
      if (!options) {
        options = {};
      }
      if (options.dtx === void 0) {
        livekitLogger.info("Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.");
      }
      if (options.red === void 0) {
        livekitLogger.info("Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.");
      }
      (_b = options.dtx) !== null && _b !== void 0 ? _b : options.dtx = false;
      (_c = options.red) !== null && _c !== void 0 ? _c : options.red = false;
    }
    const opts = _objectSpread2(_objectSpread2({}, this.roomOptions.publishDefaults), options);
    if (opts.source) {
      track.source = opts.source;
    }
    const publishPromise = this.publish(track, opts, options, isStereo);
    this.pendingPublishPromises.set(track, publishPromise);
    try {
      const publication = await publishPromise;
      return publication;
    } catch (e2) {
      throw e2;
    } finally {
      this.pendingPublishPromises.delete(track);
    }
  }
  async publish(track, opts, options, isStereo) {
    var _a2, _b, _c, _d;
    const existingTrackOfSource = Array.from(this.tracks.values()).find((publishedTrack) => track instanceof LocalTrack && publishedTrack.source === track.source);
    if (existingTrackOfSource && track.source !== Track.Source.Unknown) {
      try {
        throw Error("publishing a second track with the same source: ".concat(track.source));
      } catch (e2) {
        if (e2 instanceof Error) {
          livekitLogger.warn(e2.message, {
            oldTrack: existingTrackOfSource,
            newTrack: track,
            trace: e2.stack
          });
        }
      }
    }
    if (opts.stopMicTrackOnMute && track instanceof LocalAudioTrack) {
      track.stopOnMute = true;
    }
    if (track.source === Track.Source.ScreenShare && isFireFox()) {
      opts.simulcast = false;
    }
    if (opts.videoCodec === "av1" && !supportsAV1()) {
      opts.videoCodec = void 0;
    }
    track.on(TrackEvent.Muted, this.onTrackMuted);
    track.on(TrackEvent.Unmuted, this.onTrackUnmuted);
    track.on(TrackEvent.Ended, this.handleTrackEnded);
    track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);
    track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
    const req = AddTrackRequest.fromPartial({
      cid: track.mediaStreamTrack.id,
      name: options === null || options === void 0 ? void 0 : options.name,
      type: Track.kindToProto(track.kind),
      muted: track.isMuted,
      source: Track.sourceToProto(track.source),
      disableDtx: !((_a2 = opts.dtx) !== null && _a2 !== void 0 ? _a2 : true),
      stereo: isStereo,
      disableRed: !((_b = opts.red) !== null && _b !== void 0 ? _b : true)
    });
    let encodings;
    let simEncodings;
    if (track.kind === Track.Kind.Video) {
      let dims = {
        width: 0,
        height: 0
      };
      try {
        dims = await track.waitForDimensions();
      } catch (e2) {
        livekitLogger.error("could not determine track dimensions");
      }
      req.width = dims.width;
      req.height = dims.height;
      if (track instanceof LocalVideoTrack) {
        if ((opts === null || opts === void 0 ? void 0 : opts.videoCodec) === "av1") {
          opts.scalabilityMode = (_c = opts.scalabilityMode) !== null && _c !== void 0 ? _c : "L3T3";
        }
        if (opts.videoCodec && opts.backupCodec && opts.videoCodec !== opts.backupCodec.codec) {
          const simOpts = _objectSpread2({}, opts);
          simOpts.simulcast = true;
          simEncodings = computeTrackBackupEncodings(track, opts.backupCodec.codec, simOpts);
          req.simulcastCodecs = [{
            codec: opts.videoCodec,
            cid: track.mediaStreamTrack.id,
            enableSimulcastLayers: true
          }, {
            codec: opts.backupCodec.codec,
            cid: "",
            enableSimulcastLayers: true
          }];
        }
      }
      encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, dims.width, dims.height, opts);
      req.layers = videoLayersFromEncodings(req.width, req.height, simEncodings !== null && simEncodings !== void 0 ? simEncodings : encodings);
    } else if (track.kind === Track.Kind.Audio && opts.audioBitrate) {
      encodings = [{
        maxBitrate: opts.audioBitrate
      }];
    }
    if (!this.engine || this.engine.isClosed) {
      throw new UnexpectedConnectionState("cannot publish track when not connected");
    }
    const ti = await this.engine.addTrack(req);
    const publication = new LocalTrackPublication(track.kind, ti, track);
    publication.options = opts;
    track.sid = ti.sid;
    if (!this.engine.publisher) {
      throw new UnexpectedConnectionState("publisher is closed");
    }
    livekitLogger.debug("publishing ".concat(track.kind, " with encodings"), {
      encodings,
      trackInfo: ti
    });
    track.sender = await this.engine.createSender(track, opts, encodings);
    if (track.codec === "av1" && encodings && ((_d = encodings[0]) === null || _d === void 0 ? void 0 : _d.maxBitrate)) {
      this.engine.publisher.setTrackCodecBitrate(req.cid, track.codec, encodings[0].maxBitrate / 1e3);
    }
    this.engine.negotiate();
    if (track instanceof LocalVideoTrack) {
      track.startMonitor(this.engine.client);
    } else if (track instanceof LocalAudioTrack) {
      track.startMonitor();
    }
    this.addTrackPublication(publication);
    this.emit(ParticipantEvent.LocalTrackPublished, publication);
    return publication;
  }
  get isLocal() {
    return true;
  }
  async publishAdditionalCodecForTrack(track, videoCodec, options) {
    var _a2;
    let existingPublication;
    this.tracks.forEach((publication) => {
      if (!publication.track) {
        return;
      }
      if (publication.track === track) {
        existingPublication = publication;
      }
    });
    if (!existingPublication) {
      throw new TrackInvalidError("track is not published");
    }
    if (!(track instanceof LocalVideoTrack)) {
      throw new TrackInvalidError("track is not a video track");
    }
    const opts = _objectSpread2(_objectSpread2({}, (_a2 = this.roomOptions) === null || _a2 === void 0 ? void 0 : _a2.publishDefaults), options);
    const encodings = computeTrackBackupEncodings(track, videoCodec, opts);
    if (!encodings) {
      livekitLogger.info("backup codec has been disabled, ignoring request to add additional codec for track");
      return;
    }
    const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);
    const req = AddTrackRequest.fromPartial({
      cid: simulcastTrack.mediaStreamTrack.id,
      type: Track.kindToProto(track.kind),
      muted: track.isMuted,
      source: Track.sourceToProto(track.source),
      sid: track.sid,
      simulcastCodecs: [{
        codec: opts.videoCodec,
        cid: simulcastTrack.mediaStreamTrack.id,
        enableSimulcastLayers: opts.simulcast
      }]
    });
    req.layers = videoLayersFromEncodings(req.width, req.height, encodings);
    if (!this.engine || this.engine.isClosed) {
      throw new UnexpectedConnectionState("cannot publish track when not connected");
    }
    const ti = await this.engine.addTrack(req);
    await this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);
    this.engine.negotiate();
    livekitLogger.debug("published ".concat(videoCodec, " for track ").concat(track.sid), {
      encodings,
      trackInfo: ti
    });
  }
  async unpublishTrack(track, stopOnUnpublish) {
    var _a2, _b;
    const publication = this.getPublicationForTrack(track);
    livekitLogger.debug("unpublishing track", {
      track,
      method: "unpublishTrack"
    });
    if (!publication || !publication.track) {
      livekitLogger.warn("track was not unpublished because no publication was found", {
        track,
        method: "unpublishTrack"
      });
      return void 0;
    }
    track = publication.track;
    track.off(TrackEvent.Muted, this.onTrackMuted);
    track.off(TrackEvent.Unmuted, this.onTrackUnmuted);
    track.off(TrackEvent.Ended, this.handleTrackEnded);
    track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);
    track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
    if (stopOnUnpublish === void 0) {
      stopOnUnpublish = (_b = (_a2 = this.roomOptions) === null || _a2 === void 0 ? void 0 : _a2.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;
    }
    if (stopOnUnpublish) {
      track.stop();
    }
    let negotiationNeeded = false;
    const trackSender = track.sender;
    track.sender = void 0;
    if (this.engine.publisher && this.engine.publisher.pc.connectionState !== "closed" && trackSender) {
      try {
        if (this.engine.removeTrack(trackSender)) {
          negotiationNeeded = true;
        }
        if (track instanceof LocalVideoTrack) {
          for (const [, trackInfo] of track.simulcastCodecs) {
            if (trackInfo.sender) {
              if (this.engine.removeTrack(trackInfo.sender)) {
                negotiationNeeded = true;
              }
              trackInfo.sender = void 0;
            }
          }
          track.simulcastCodecs.clear();
        }
      } catch (e2) {
        livekitLogger.warn("failed to unpublish track", {
          error: e2,
          method: "unpublishTrack"
        });
      }
    }
    this.tracks.delete(publication.trackSid);
    switch (publication.kind) {
      case Track.Kind.Audio:
        this.audioTracks.delete(publication.trackSid);
        break;
      case Track.Kind.Video:
        this.videoTracks.delete(publication.trackSid);
        break;
    }
    this.emit(ParticipantEvent.LocalTrackUnpublished, publication);
    publication.setTrack(void 0);
    if (negotiationNeeded) {
      await this.engine.negotiate();
    }
    return publication;
  }
  async unpublishTracks(tracks) {
    const results = await Promise.all(tracks.map((track) => this.unpublishTrack(track)));
    return results.filter((track) => track instanceof LocalTrackPublication);
  }
  async republishAllTracks(options) {
    const localPubs = [];
    this.tracks.forEach((pub) => {
      if (pub.track) {
        if (options) {
          pub.options = _objectSpread2(_objectSpread2({}, pub.options), options);
        }
        localPubs.push(pub);
      }
    });
    await Promise.all(localPubs.map(async (pub) => {
      const track = pub.track;
      await this.unpublishTrack(track, false);
      await this.publishTrack(track, pub.options);
    }));
  }
  async publishData(data2, kind) {
    let publishOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const destination = Array.isArray(publishOptions) ? publishOptions : publishOptions === null || publishOptions === void 0 ? void 0 : publishOptions.destination;
    const destinationSids = [];
    const topic = !Array.isArray(publishOptions) ? publishOptions.topic : void 0;
    if (destination !== void 0) {
      destination.forEach((val) => {
        if (val instanceof RemoteParticipant) {
          destinationSids.push(val.sid);
        } else {
          destinationSids.push(val);
        }
      });
    }
    const packet = {
      kind,
      value: {
        $case: "user",
        user: {
          participantSid: this.sid,
          payload: data2,
          destinationSids,
          topic
        }
      }
    };
    await this.engine.sendDataPacket(packet, kind);
  }
  setTrackSubscriptionPermissions(allParticipantsAllowed) {
    let participantTrackPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    this.participantTrackPermissions = participantTrackPermissions;
    this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;
    if (this.engine.client.isConnected) {
      this.updateTrackSubscriptionPermissions();
    }
  }
  updateInfo(info) {
    if (info.sid !== this.sid) {
      return;
    }
    super.updateInfo(info);
    info.tracks.forEach((ti) => {
      var _a2, _b;
      const pub = this.tracks.get(ti.sid);
      if (pub) {
        const mutedOnServer = pub.isMuted || ((_b = (_a2 = pub.track) === null || _a2 === void 0 ? void 0 : _a2.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);
        if (mutedOnServer !== ti.muted) {
          livekitLogger.debug("updating server mute state after reconcile", {
            sid: ti.sid,
            muted: mutedOnServer
          });
          this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);
        }
      }
    });
  }
  getPublicationForTrack(track) {
    let publication;
    this.tracks.forEach((pub) => {
      const localTrack = pub.track;
      if (!localTrack) {
        return;
      }
      if (track instanceof MediaStreamTrack) {
        if (localTrack instanceof LocalAudioTrack || localTrack instanceof LocalVideoTrack) {
          if (localTrack.mediaStreamTrack === track) {
            publication = pub;
          }
        }
      } else if (track === localTrack) {
        publication = pub;
      }
    });
    return publication;
  }
  publishedTracksInfo() {
    const infos = [];
    this.tracks.forEach((track) => {
      if (track.track !== void 0) {
        infos.push({
          cid: track.track.mediaStreamID,
          track: track.trackInfo
        });
      }
    });
    return infos;
  }
  dataChannelsInfo() {
    const infos = [];
    const getInfo = (dc, target) => {
      if ((dc === null || dc === void 0 ? void 0 : dc.id) !== void 0 && dc.id !== null) {
        infos.push({
          label: dc.label,
          id: dc.id,
          target
        });
      }
    };
    getInfo(this.engine.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);
    getInfo(this.engine.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);
    getInfo(this.engine.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);
    getInfo(this.engine.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);
    return infos;
  }
}
const passThroughQueueSignals = ["syncState", "trickle", "offer", "answer", "simulate", "leave"];
function canPassThroughQueue(req) {
  const canPass = passThroughQueueSignals.includes(req.$case);
  livekitLogger.trace("request allowed to bypass queue:", {
    canPass,
    req
  });
  return canPass;
}
class SignalClient {
  constructor() {
    let useJSON = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    this.rtt = 0;
    this.isConnected = false;
    this.isReconnecting = false;
    this.useJSON = useJSON;
    this.requestQueue = new Queue();
    this.queuedRequests = [];
    this.closingLock = new Mutex();
  }
  async join(url, token, opts, abortSignal) {
    this.isConnected = false;
    this.options = opts;
    const res = await this.connect(url, token, opts, abortSignal);
    return res;
  }
  async reconnect(url, token, sid, reason) {
    if (!this.options) {
      livekitLogger.warn("attempted to reconnect without signal options being set, ignoring");
      return;
    }
    this.isReconnecting = true;
    this.clearPingInterval();
    const res = await this.connect(url, token, _objectSpread2(_objectSpread2({}, this.options), {}, {
      reconnect: true,
      sid,
      reconnectReason: reason
    }));
    return res;
  }
  connect(url, token, opts, abortSignal) {
    this.connectOptions = opts;
    if (url.startsWith("http")) {
      url = url.replace("http", "ws");
    }
    url = url.replace(/\/$/, "");
    url += "/rtc";
    const clientInfo = getClientInfo();
    const params = createConnectionParams(token, clientInfo, opts);
    return new Promise(async (resolve, reject) => {
      const abortHandler = async () => {
        await this.close();
        reject(new ConnectionError("room connection has been cancelled"));
      };
      if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
        abortHandler();
      }
      abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener("abort", abortHandler);
      livekitLogger.debug("connecting to ".concat(url + params));
      if (this.ws) {
        await this.close();
      }
      this.ws = new WebSocket(url + params);
      this.ws.binaryType = "arraybuffer";
      this.ws.onerror = async (ev) => {
        if (!this.isConnected) {
          try {
            const resp = await fetch("http".concat(url.substring(2), "/validate").concat(params));
            if (!resp.ok) {
              const msg = await resp.text();
              reject(new ConnectionError(msg, 0, resp.status));
            } else {
              reject(new ConnectionError("Internal error", 2, resp.status));
            }
          } catch (e2) {
            reject(new ConnectionError("server was not reachable", 1));
          }
          return;
        }
        this.handleWSError(ev);
      };
      this.ws.onmessage = async (ev) => {
        var _a2, _b, _c, _d;
        let resp;
        if (typeof ev.data === "string") {
          const json = JSON.parse(ev.data);
          resp = SignalResponse.fromJSON(json);
        } else if (ev.data instanceof ArrayBuffer) {
          resp = SignalResponse.decode(new Uint8Array(ev.data));
        } else {
          livekitLogger.error("could not decode websocket message: ".concat(typeof ev.data));
          return;
        }
        if (!this.isConnected) {
          let shouldProcessMessage = false;
          if (((_a2 = resp.message) === null || _a2 === void 0 ? void 0 : _a2.$case) === "join") {
            this.isConnected = true;
            abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", abortHandler);
            this.pingTimeoutDuration = resp.message.join.pingTimeout;
            this.pingIntervalDuration = resp.message.join.pingInterval;
            if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {
              livekitLogger.debug("ping config", {
                timeout: this.pingTimeoutDuration,
                interval: this.pingIntervalDuration
              });
              this.startPingInterval();
            }
            resolve(resp.message.join);
          } else if (opts.reconnect) {
            this.isConnected = true;
            abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", abortHandler);
            this.startPingInterval();
            if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.$case) === "reconnect") {
              resolve((_c = resp.message) === null || _c === void 0 ? void 0 : _c.reconnect);
            } else {
              resolve();
              shouldProcessMessage = true;
            }
          } else if (!opts.reconnect) {
            reject(new ConnectionError("did not receive join response, got ".concat((_d = resp.message) === null || _d === void 0 ? void 0 : _d.$case, " instead")));
          }
          if (!shouldProcessMessage) {
            return;
          }
        }
        if (this.signalLatency) {
          await sleep(this.signalLatency);
        }
        this.handleSignalResponse(resp);
      };
      this.ws.onclose = (ev) => {
        if (!this.isConnected)
          return;
        livekitLogger.debug("websocket connection closed: ".concat(ev.reason));
        this.isConnected = false;
        if (this.onClose) {
          this.onClose(ev.reason);
        }
        this.ws = void 0;
      };
    });
  }
  async close() {
    const unlock = await this.closingLock.lock();
    try {
      this.isConnected = false;
      if (this.ws) {
        this.ws.onclose = null;
        this.ws.onmessage = null;
        this.ws.onopen = null;
        const closePromise = new Promise((resolve) => {
          if (this.ws) {
            this.ws.onclose = resolve;
          } else {
            resolve(true);
          }
        });
        this.ws.close();
        await Promise.race([closePromise, sleep(250)]);
      }
      this.ws = void 0;
      this.clearPingInterval();
    } finally {
      unlock();
    }
  }
  sendOffer(offer) {
    livekitLogger.debug("sending offer", offer);
    this.sendRequest({
      $case: "offer",
      offer: toProtoSessionDescription(offer)
    });
  }
  sendAnswer(answer) {
    livekitLogger.debug("sending answer");
    this.sendRequest({
      $case: "answer",
      answer: toProtoSessionDescription(answer)
    });
  }
  sendIceCandidate(candidate, target) {
    livekitLogger.trace("sending ice candidate", candidate);
    this.sendRequest({
      $case: "trickle",
      trickle: {
        candidateInit: JSON.stringify(candidate),
        target
      }
    });
  }
  sendMuteTrack(trackSid, muted) {
    this.sendRequest({
      $case: "mute",
      mute: {
        sid: trackSid,
        muted
      }
    });
  }
  sendAddTrack(req) {
    this.sendRequest({
      $case: "addTrack",
      addTrack: AddTrackRequest.fromPartial(req)
    });
  }
  sendUpdateTrackSettings(settings) {
    this.sendRequest({
      $case: "trackSetting",
      trackSetting: settings
    });
  }
  sendUpdateSubscription(sub) {
    this.sendRequest({
      $case: "subscription",
      subscription: sub
    });
  }
  sendSyncState(sync) {
    this.sendRequest({
      $case: "syncState",
      syncState: sync
    });
  }
  sendUpdateVideoLayers(trackSid, layers) {
    this.sendRequest({
      $case: "updateLayers",
      updateLayers: {
        trackSid,
        layers
      }
    });
  }
  sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {
    this.sendRequest({
      $case: "subscriptionPermission",
      subscriptionPermission: {
        allParticipants,
        trackPermissions
      }
    });
  }
  sendSimulateScenario(scenario) {
    this.sendRequest({
      $case: "simulate",
      simulate: scenario
    });
  }
  sendPing() {
    this.sendRequest({
      $case: "ping",
      ping: Date.now()
    });
    this.sendRequest({
      $case: "pingReq",
      pingReq: {
        timestamp: Date.now(),
        rtt: this.rtt
      }
    });
  }
  async sendLeave() {
    await this.sendRequest({
      $case: "leave",
      leave: {
        canReconnect: false,
        reason: DisconnectReason.CLIENT_INITIATED
      }
    });
  }
  async sendRequest(message) {
    let fromQueue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const canQueue = !fromQueue && !canPassThroughQueue(message);
    if (canQueue && this.isReconnecting) {
      this.queuedRequests.push(async () => {
        await this.sendRequest(message, true);
      });
      return;
    }
    if (!fromQueue) {
      await this.requestQueue.flush();
    }
    if (this.signalLatency) {
      await sleep(this.signalLatency);
    }
    if (!this.ws || this.ws.readyState !== this.ws.OPEN) {
      livekitLogger.error("cannot send signal request before connected, type: ".concat(message === null || message === void 0 ? void 0 : message.$case));
      return;
    }
    const req = {
      message
    };
    try {
      if (this.useJSON) {
        this.ws.send(JSON.stringify(SignalRequest.toJSON(req)));
      } else {
        this.ws.send(SignalRequest.encode(req).finish());
      }
    } catch (e2) {
      livekitLogger.error("error sending signal message", {
        error: e2
      });
    }
  }
  handleSignalResponse(res) {
    var _a2, _b;
    const msg = res.message;
    if (msg == void 0) {
      livekitLogger.debug("received unsupported message");
      return;
    }
    if (msg.$case === "answer") {
      const sd = fromProtoSessionDescription(msg.answer);
      if (this.onAnswer) {
        this.onAnswer(sd);
      }
    } else if (msg.$case === "offer") {
      const sd = fromProtoSessionDescription(msg.offer);
      if (this.onOffer) {
        this.onOffer(sd);
      }
    } else if (msg.$case === "trickle") {
      const candidate = JSON.parse(msg.trickle.candidateInit);
      if (this.onTrickle) {
        this.onTrickle(candidate, msg.trickle.target);
      }
    } else if (msg.$case === "update") {
      if (this.onParticipantUpdate) {
        this.onParticipantUpdate((_a2 = msg.update.participants) !== null && _a2 !== void 0 ? _a2 : []);
      }
    } else if (msg.$case === "trackPublished") {
      if (this.onLocalTrackPublished) {
        this.onLocalTrackPublished(msg.trackPublished);
      }
    } else if (msg.$case === "speakersChanged") {
      if (this.onSpeakersChanged) {
        this.onSpeakersChanged((_b = msg.speakersChanged.speakers) !== null && _b !== void 0 ? _b : []);
      }
    } else if (msg.$case === "leave") {
      if (this.onLeave) {
        this.onLeave(msg.leave);
      }
    } else if (msg.$case === "mute") {
      if (this.onRemoteMuteChanged) {
        this.onRemoteMuteChanged(msg.mute.sid, msg.mute.muted);
      }
    } else if (msg.$case === "roomUpdate") {
      if (this.onRoomUpdate && msg.roomUpdate.room) {
        this.onRoomUpdate(msg.roomUpdate.room);
      }
    } else if (msg.$case === "connectionQuality") {
      if (this.onConnectionQuality) {
        this.onConnectionQuality(msg.connectionQuality);
      }
    } else if (msg.$case === "streamStateUpdate") {
      if (this.onStreamStateUpdate) {
        this.onStreamStateUpdate(msg.streamStateUpdate);
      }
    } else if (msg.$case === "subscribedQualityUpdate") {
      if (this.onSubscribedQualityUpdate) {
        this.onSubscribedQualityUpdate(msg.subscribedQualityUpdate);
      }
    } else if (msg.$case === "subscriptionPermissionUpdate") {
      if (this.onSubscriptionPermissionUpdate) {
        this.onSubscriptionPermissionUpdate(msg.subscriptionPermissionUpdate);
      }
    } else if (msg.$case === "refreshToken") {
      if (this.onTokenRefresh) {
        this.onTokenRefresh(msg.refreshToken);
      }
    } else if (msg.$case === "trackUnpublished") {
      if (this.onLocalTrackUnpublished) {
        this.onLocalTrackUnpublished(msg.trackUnpublished);
      }
    } else if (msg.$case === "pong") {
      this.resetPingTimeout();
    } else if (msg.$case === "pongResp") {
      this.rtt = Date.now() - msg.pongResp.lastPingTimestamp;
      this.resetPingTimeout();
    } else {
      livekitLogger.debug("unsupported message", msg);
    }
  }
  setReconnected() {
    while (this.queuedRequests.length > 0) {
      const req = this.queuedRequests.shift();
      if (req) {
        this.requestQueue.run(req);
      }
    }
    this.isReconnecting = false;
  }
  handleWSError(ev) {
    livekitLogger.error("websocket error", ev);
  }
  resetPingTimeout() {
    this.clearPingTimeout();
    if (!this.pingTimeoutDuration) {
      livekitLogger.warn("ping timeout duration not set");
      return;
    }
    this.pingTimeout = CriticalTimers.setTimeout(() => {
      livekitLogger.warn("ping timeout triggered. last pong received at: ".concat(new Date(Date.now() - this.pingTimeoutDuration * 1e3).toUTCString()));
      if (this.onClose) {
        this.onClose("ping timeout");
      }
    }, this.pingTimeoutDuration * 1e3);
  }
  clearPingTimeout() {
    if (this.pingTimeout) {
      CriticalTimers.clearTimeout(this.pingTimeout);
    }
  }
  startPingInterval() {
    this.clearPingInterval();
    this.resetPingTimeout();
    if (!this.pingIntervalDuration) {
      livekitLogger.warn("ping interval duration not set");
      return;
    }
    livekitLogger.debug("start ping interval");
    this.pingInterval = CriticalTimers.setInterval(() => {
      this.sendPing();
    }, this.pingIntervalDuration * 1e3);
  }
  clearPingInterval() {
    livekitLogger.debug("clearing ping interval");
    this.clearPingTimeout();
    if (this.pingInterval) {
      CriticalTimers.clearInterval(this.pingInterval);
    }
  }
}
function fromProtoSessionDescription(sd) {
  const rsd = {
    type: "offer",
    sdp: sd.sdp
  };
  switch (sd.type) {
    case "answer":
    case "offer":
    case "pranswer":
    case "rollback":
      rsd.type = sd.type;
      break;
  }
  return rsd;
}
function toProtoSessionDescription(rsd) {
  const sd = {
    sdp: rsd.sdp,
    type: rsd.type
  };
  return sd;
}
function createConnectionParams(token, info, opts) {
  var _a2;
  const params = new URLSearchParams();
  params.set("access_token", token);
  if (opts.reconnect) {
    params.set("reconnect", "1");
    if (opts.sid) {
      params.set("sid", opts.sid);
    }
  }
  params.set("auto_subscribe", opts.autoSubscribe ? "1" : "0");
  params.set("sdk", "js");
  params.set("version", info.version);
  params.set("protocol", info.protocol.toString());
  if (info.deviceModel) {
    params.set("device_model", info.deviceModel);
  }
  if (info.os) {
    params.set("os", info.os);
  }
  if (info.osVersion) {
    params.set("os_version", info.osVersion);
  }
  if (info.browser) {
    params.set("browser", info.browser);
  }
  if (info.browserVersion) {
    params.set("browser_version", info.browserVersion);
  }
  if (opts.publishOnly !== void 0) {
    params.set("publish", opts.publishOnly);
  }
  if (opts.adaptiveStream) {
    params.set("adaptive_stream", "1");
  }
  if (opts.reconnectReason) {
    params.set("reconnect_reason", opts.reconnectReason.toString());
  }
  if ((_a2 = navigator.connection) === null || _a2 === void 0 ? void 0 : _a2.type) {
    params.set("network", navigator.connection.type);
  }
  return "?".concat(params.toString());
}
const publishDefaults = {
  audioBitrate: AudioPresets.music.maxBitrate,
  dtx: true,
  red: true,
  forceStereo: false,
  simulcast: true,
  screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,
  stopMicTrackOnMute: false,
  videoCodec: "vp8",
  backupCodec: {
    codec: "vp8",
    encoding: VideoPresets.h540.encoding
  }
};
const audioDefaults = {
  autoGainControl: true,
  echoCancellation: true,
  noiseSuppression: true
};
const videoDefaults = {
  resolution: VideoPresets.h720.resolution
};
const roomOptionDefaults = {
  adaptiveStream: false,
  dynacast: false,
  stopLocalTrackOnUnpublish: true,
  reconnectPolicy: new DefaultReconnectPolicy(),
  expWebAudioMix: false
};
const roomConnectOptionDefaults = {
  autoSubscribe: true,
  maxRetries: 1,
  peerConnectionTimeout: 15e3
};
var parser$1 = {};
var grammarExports = {};
var grammar$2 = {
  get exports() {
    return grammarExports;
  },
  set exports(v) {
    grammarExports = v;
  }
};
var grammar$1 = grammar$2.exports = {
  v: [{
    name: "version",
    reg: /^(\d*)$/
  }],
  o: [{
    name: "origin",
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
    format: "%s %s %d %s IP%d %s"
  }],
  s: [{
    name: "name"
  }],
  i: [{
    name: "description"
  }],
  u: [{
    name: "uri"
  }],
  e: [{
    name: "email"
  }],
  p: [{
    name: "phone"
  }],
  z: [{
    name: "timezones"
  }],
  r: [{
    name: "repeats"
  }],
  t: [{
    name: "timing",
    reg: /^(\d*) (\d*)/,
    names: ["start", "stop"],
    format: "%d %d"
  }],
  c: [{
    name: "connection",
    reg: /^IN IP(\d) (\S*)/,
    names: ["version", "ip"],
    format: "IN IP%d %s"
  }],
  b: [{
    push: "bandwidth",
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ["type", "limit"],
    format: "%s:%s"
  }],
  m: [{
    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
    names: ["type", "port", "protocol", "payloads"],
    format: "%s %d %s %s"
  }],
  a: [
    {
      push: "rtp",
      reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ["payload", "codec", "rate", "encoding"],
      format: function(o2) {
        return o2.encoding ? "rtpmap:%d %s/%s/%s" : o2.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
      }
    },
    {
      push: "fmtp",
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ["payload", "config"],
      format: "fmtp:%d %s"
    },
    {
      name: "control",
      reg: /^control:(.*)/,
      format: "control:%s"
    },
    {
      name: "rtcp",
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ["port", "netType", "ipVer", "address"],
      format: function(o2) {
        return o2.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
      }
    },
    {
      push: "rtcpFbTrrInt",
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ["payload", "value"],
      format: "rtcp-fb:%s trr-int %d"
    },
    {
      push: "rtcpFb",
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ["payload", "type", "subtype"],
      format: function(o2) {
        return o2.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
      }
    },
    {
      push: "ext",
      reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
      names: ["value", "direction", "encrypt-uri", "uri", "config"],
      format: function(o2) {
        return "extmap:%d" + (o2.direction ? "/%s" : "%v") + (o2["encrypt-uri"] ? " %s" : "%v") + " %s" + (o2.config ? " %s" : "");
      }
    },
    {
      name: "extmapAllowMixed",
      reg: /^(extmap-allow-mixed)/
    },
    {
      push: "crypto",
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ["id", "suite", "config", "sessionConfig"],
      format: function(o2) {
        return o2.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
      }
    },
    {
      name: "setup",
      reg: /^setup:(\w*)/,
      format: "setup:%s"
    },
    {
      name: "connectionType",
      reg: /^connection:(new|existing)/,
      format: "connection:%s"
    },
    {
      name: "mid",
      reg: /^mid:([^\s]*)/,
      format: "mid:%s"
    },
    {
      name: "msid",
      reg: /^msid:(.*)/,
      format: "msid:%s"
    },
    {
      name: "ptime",
      reg: /^ptime:(\d*(?:\.\d*)*)/,
      format: "ptime:%d"
    },
    {
      name: "maxptime",
      reg: /^maxptime:(\d*(?:\.\d*)*)/,
      format: "maxptime:%d"
    },
    {
      name: "direction",
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    {
      name: "icelite",
      reg: /^(ice-lite)/
    },
    {
      name: "iceUfrag",
      reg: /^ice-ufrag:(\S*)/,
      format: "ice-ufrag:%s"
    },
    {
      name: "icePwd",
      reg: /^ice-pwd:(\S*)/,
      format: "ice-pwd:%s"
    },
    {
      name: "fingerprint",
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ["type", "hash"],
      format: "fingerprint:%s %s"
    },
    {
      push: "candidates",
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
      format: function(o2) {
        var str = "candidate:%s %d %s %d %s %d typ %s";
        str += o2.raddr != null ? " raddr %s rport %d" : "%v%v";
        str += o2.tcptype != null ? " tcptype %s" : "%v";
        if (o2.generation != null) {
          str += " generation %d";
        }
        str += o2["network-id"] != null ? " network-id %d" : "%v";
        str += o2["network-cost"] != null ? " network-cost %d" : "%v";
        return str;
      }
    },
    {
      name: "endOfCandidates",
      reg: /^(end-of-candidates)/
    },
    {
      name: "remoteCandidates",
      reg: /^remote-candidates:(.*)/,
      format: "remote-candidates:%s"
    },
    {
      name: "iceOptions",
      reg: /^ice-options:(\S*)/,
      format: "ice-options:%s"
    },
    {
      push: "ssrcs",
      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
      names: ["id", "attribute", "value"],
      format: function(o2) {
        var str = "ssrc:%d";
        if (o2.attribute != null) {
          str += " %s";
          if (o2.value != null) {
            str += ":%s";
          }
        }
        return str;
      }
    },
    {
      push: "ssrcGroups",
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ["semantics", "ssrcs"],
      format: "ssrc-group:%s %s"
    },
    {
      name: "msidSemantic",
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ["semantic", "token"],
      format: "msid-semantic: %s %s"
    },
    {
      push: "groups",
      reg: /^group:(\w*) (.*)/,
      names: ["type", "mids"],
      format: "group:%s %s"
    },
    {
      name: "rtcpMux",
      reg: /^(rtcp-mux)/
    },
    {
      name: "rtcpRsize",
      reg: /^(rtcp-rsize)/
    },
    {
      name: "sctpmap",
      reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
      names: ["sctpmapNumber", "app", "maxMessageSize"],
      format: function(o2) {
        return o2.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
      }
    },
    {
      name: "xGoogleFlag",
      reg: /^x-google-flag:([^\s]*)/,
      format: "x-google-flag:%s"
    },
    {
      push: "rids",
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ["id", "direction", "params"],
      format: function(o2) {
        return o2.params ? "rid:%s %s %s" : "rid:%s %s";
      }
    },
    {
      push: "imageattrs",
      reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"),
      names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
      format: function(o2) {
        return "imageattr:%s %s %s" + (o2.dir2 ? " %s %s" : "");
      }
    },
    {
      name: "simulcast",
      reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"),
      names: ["dir1", "list1", "dir2", "list2"],
      format: function(o2) {
        return "simulcast:%s %s" + (o2.dir2 ? " %s %s" : "");
      }
    },
    {
      name: "simulcast_03",
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ["value"],
      format: "simulcast: %s"
    },
    {
      name: "framerate",
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: "framerate:%s"
    },
    {
      name: "sourceFilter",
      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
      names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
      format: "source-filter: %s %s %s %s %s"
    },
    {
      name: "bundleOnly",
      reg: /^(bundle-only)/
    },
    {
      name: "label",
      reg: /^label:(.+)/,
      format: "label:%s"
    },
    {
      name: "sctpPort",
      reg: /^sctp-port:(\d+)$/,
      format: "sctp-port:%s"
    },
    {
      name: "maxMessageSize",
      reg: /^max-message-size:(\d+)$/,
      format: "max-message-size:%s"
    },
    {
      push: "tsRefClocks",
      reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
      names: ["clksrc", "clksrcExt"],
      format: function(o2) {
        return "ts-refclk:%s" + (o2.clksrcExt != null ? "=%s" : "");
      }
    },
    {
      name: "mediaClk",
      reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
      names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
      format: function(o2) {
        var str = "mediaclk:";
        str += o2.id != null ? "id=%s %s" : "%v%s";
        str += o2.mediaClockValue != null ? "=%s" : "";
        str += o2.rateNumerator != null ? " rate=%s" : "";
        str += o2.rateDenominator != null ? "/%s" : "";
        return str;
      }
    },
    {
      name: "keywords",
      reg: /^keywds:(.+)$/,
      format: "keywds:%s"
    },
    {
      name: "content",
      reg: /^content:(.+)/,
      format: "content:%s"
    },
    {
      name: "bfcpFloorCtrl",
      reg: /^floorctrl:(c-only|s-only|c-s)/,
      format: "floorctrl:%s"
    },
    {
      name: "bfcpConfId",
      reg: /^confid:(\d+)/,
      format: "confid:%s"
    },
    {
      name: "bfcpUserId",
      reg: /^userid:(\d+)/,
      format: "userid:%s"
    },
    {
      name: "bfcpFloorId",
      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
      names: ["id", "mStream"],
      format: "floorid:%s mstrm:%s"
    },
    {
      push: "invalid",
      names: ["value"]
    }
  ]
};
Object.keys(grammar$1).forEach(function(key) {
  var objs = grammar$1[key];
  objs.forEach(function(obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = "%s";
    }
  });
});
(function(exports2) {
  var toIntIfInt = function(v) {
    return String(Number(v)) === v ? Number(v) : v;
  };
  var attachProperties = function(match, location, names, rawName) {
    if (rawName && !names) {
      location[rawName] = toIntIfInt(match[1]);
    } else {
      for (var i2 = 0; i2 < names.length; i2 += 1) {
        if (match[i2 + 1] != null) {
          location[names[i2]] = toIntIfInt(match[i2 + 1]);
        }
      }
    }
  };
  var parseReg = function(obj, location, content) {
    var needsBlank = obj.name && obj.names;
    if (obj.push && !location[obj.push]) {
      location[obj.push] = [];
    } else if (needsBlank && !location[obj.name]) {
      location[obj.name] = {};
    }
    var keyLocation = obj.push ? {} : needsBlank ? location[obj.name] : location;
    attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
    if (obj.push) {
      location[obj.push].push(keyLocation);
    }
  };
  var grammar2 = grammarExports;
  var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
  exports2.parse = function(sdp2) {
    var session = {}, media = [], location = session;
    sdp2.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l) {
      var type = l[0];
      var content = l.slice(2);
      if (type === "m") {
        media.push({
          rtp: [],
          fmtp: []
        });
        location = media[media.length - 1];
      }
      for (var j = 0; j < (grammar2[type] || []).length; j += 1) {
        var obj = grammar2[type][j];
        if (obj.reg.test(content)) {
          return parseReg(obj, location, content);
        }
      }
    });
    session.media = media;
    return session;
  };
  var paramReducer = function(acc, expr) {
    var s = expr.split(/=(.+)/, 2);
    if (s.length === 2) {
      acc[s[0]] = toIntIfInt(s[1]);
    } else if (s.length === 1 && expr.length > 1) {
      acc[s[0]] = void 0;
    }
    return acc;
  };
  exports2.parseParams = function(str) {
    return str.split(/;\s?/).reduce(paramReducer, {});
  };
  exports2.parseFmtpConfig = exports2.parseParams;
  exports2.parsePayloads = function(str) {
    return str.toString().split(" ").map(Number);
  };
  exports2.parseRemoteCandidates = function(str) {
    var candidates = [];
    var parts = str.split(" ").map(toIntIfInt);
    for (var i2 = 0; i2 < parts.length; i2 += 3) {
      candidates.push({
        component: parts[i2],
        ip: parts[i2 + 1],
        port: parts[i2 + 2]
      });
    }
    return candidates;
  };
  exports2.parseImageAttributes = function(str) {
    return str.split(" ").map(function(item) {
      return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
    });
  };
  exports2.parseSimulcastStreamList = function(str) {
    return str.split(";").map(function(stream) {
      return stream.split(",").map(function(format2) {
        var scid, paused = false;
        if (format2[0] !== "~") {
          scid = toIntIfInt(format2);
        } else {
          scid = toIntIfInt(format2.substring(1, format2.length));
          paused = true;
        }
        return {
          scid,
          paused
        };
      });
    });
  };
})(parser$1);
var grammar = grammarExports;
var formatRegExp = /%[sdv%]/g;
var format = function(formatStr) {
  var i2 = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function(x) {
    if (i2 >= len) {
      return x;
    }
    var arg = args[i2];
    i2 += 1;
    switch (x) {
      case "%%":
        return "%";
      case "%s":
        return String(arg);
      case "%d":
        return Number(arg);
      case "%v":
        return "";
    }
  });
};
var makeLine = function(type, obj, location) {
  var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
  var args = [type + "=" + str];
  if (obj.names) {
    for (var i2 = 0; i2 < obj.names.length; i2 += 1) {
      var n2 = obj.names[i2];
      if (obj.name) {
        args.push(location[obj.name][n2]);
      } else {
        args.push(location[obj.names[i2]]);
      }
    }
  } else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};
var defaultOuterOrder = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"];
var defaultInnerOrder = ["i", "c", "b", "a"];
var writer$1 = function(session, opts) {
  opts = opts || {};
  if (session.version == null) {
    session.version = 0;
  }
  if (session.name == null) {
    session.name = " ";
  }
  session.media.forEach(function(mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = "";
    }
  });
  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp2 = [];
  outerOrder.forEach(function(type) {
    grammar[type].forEach(function(obj) {
      if (obj.name in session && session[obj.name] != null) {
        sdp2.push(makeLine(type, obj, session));
      } else if (obj.push in session && session[obj.push] != null) {
        session[obj.push].forEach(function(el) {
          sdp2.push(makeLine(type, obj, el));
        });
      }
    });
  });
  session.media.forEach(function(mLine) {
    sdp2.push(makeLine("m", grammar.m[0], mLine));
    innerOrder.forEach(function(type) {
      grammar[type].forEach(function(obj) {
        if (obj.name in mLine && mLine[obj.name] != null) {
          sdp2.push(makeLine(type, obj, mLine));
        } else if (obj.push in mLine && mLine[obj.push] != null) {
          mLine[obj.push].forEach(function(el) {
            sdp2.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });
  return sdp2.join("\r\n") + "\r\n";
};
var parser = parser$1;
var writer = writer$1;
var write = writer;
var parse$1 = parser.parse;
parser.parseParams;
parser.parseFmtpConfig;
parser.parsePayloads;
parser.parseRemoteCandidates;
parser.parseImageAttributes;
parser.parseSimulcastStreamList;
const PCEvents = {
  NegotiationStarted: "negotiationStarted",
  NegotiationComplete: "negotiationComplete"
};
class PCTransport extends eventsExports {
  constructor(config2) {
    super();
    this.pendingCandidates = [];
    this.restartingIce = false;
    this.renegotiate = false;
    this.trackBitrates = [];
    this.remoteStereoMids = [];
    this.remoteNackMids = [];
    this.negotiate = r((onError) => {
      this.emit(PCEvents.NegotiationStarted);
      try {
        this.createAndSendOffer();
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          throw e2;
        }
      }
    }, 100);
    this.pc = new RTCPeerConnection(config2);
  }
  get isICEConnected() {
    return this.pc.iceConnectionState === "connected" || this.pc.iceConnectionState === "completed";
  }
  async addIceCandidate(candidate) {
    if (this.pc.remoteDescription && !this.restartingIce) {
      return this.pc.addIceCandidate(candidate);
    }
    this.pendingCandidates.push(candidate);
  }
  async setRemoteDescription(sd) {
    if (sd.type === "offer") {
      let {
        stereoMids,
        nackMids
      } = extractStereoAndNackAudioFromOffer(sd);
      this.remoteStereoMids = stereoMids;
      this.remoteNackMids = nackMids;
    }
    await this.pc.setRemoteDescription(sd);
    this.pendingCandidates.forEach((candidate) => {
      this.pc.addIceCandidate(candidate);
    });
    this.pendingCandidates = [];
    this.restartingIce = false;
    if (this.renegotiate) {
      this.renegotiate = false;
      this.createAndSendOffer();
    } else if (sd.type === "answer") {
      this.emit(PCEvents.NegotiationComplete);
    }
  }
  async createAndSendOffer(options) {
    var _a2;
    if (this.onOffer === void 0) {
      return;
    }
    if (options === null || options === void 0 ? void 0 : options.iceRestart) {
      livekitLogger.debug("restarting ICE");
      this.restartingIce = true;
    }
    if (this.pc.signalingState === "have-local-offer") {
      const currentSD = this.pc.remoteDescription;
      if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {
        await this.pc.setRemoteDescription(currentSD);
      } else {
        this.renegotiate = true;
        return;
      }
    } else if (this.pc.signalingState === "closed") {
      livekitLogger.warn("could not createOffer with closed peer connection");
      return;
    }
    livekitLogger.debug("starting to negotiate");
    const offer = await this.pc.createOffer(options);
    const sdpParsed = parse$1((_a2 = offer.sdp) !== null && _a2 !== void 0 ? _a2 : "");
    sdpParsed.media.forEach((media) => {
      if (media.type === "audio") {
        ensureAudioNackAndStereo(media, [], []);
      } else if (media.type === "video") {
        this.trackBitrates.some((trackbr) => {
          if (!media.msid || !media.msid.includes(trackbr.sid)) {
            return false;
          }
          let codecPayload = 0;
          media.rtp.some((rtp) => {
            if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {
              codecPayload = rtp.payload;
              return true;
            }
            return false;
          });
          if (codecPayload > 0) {
            if (!media.fmtp.some((fmtp) => {
              if (fmtp.payload === codecPayload) {
                if (!fmtp.config.includes("x-google-max-bitrate")) {
                  fmtp.config += ";x-google-max-bitrate=".concat(trackbr.maxbr);
                }
                return true;
              }
              return false;
            })) {
              media.fmtp.push({
                payload: codecPayload,
                config: "x-google-max-bitrate=".concat(trackbr.maxbr)
              });
            }
          }
          return true;
        });
      }
    });
    this.trackBitrates = [];
    await this.setMungedLocalDescription(offer, write(sdpParsed));
    this.onOffer(offer);
  }
  async createAndSetAnswer() {
    var _a2;
    const answer = await this.pc.createAnswer();
    const sdpParsed = parse$1((_a2 = answer.sdp) !== null && _a2 !== void 0 ? _a2 : "");
    sdpParsed.media.forEach((media) => {
      if (media.type === "audio") {
        ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);
      }
    });
    await this.setMungedLocalDescription(answer, write(sdpParsed));
    return answer;
  }
  setTrackCodecBitrate(sid, codec, maxbr) {
    this.trackBitrates.push({
      sid,
      codec,
      maxbr
    });
  }
  close() {
    this.pc.onconnectionstatechange = null;
    this.pc.oniceconnectionstatechange = null;
    this.pc.close();
  }
  async setMungedLocalDescription(sd, munged) {
    const originalSdp = sd.sdp;
    sd.sdp = munged;
    try {
      livekitLogger.debug("setting munged local description");
      await this.pc.setLocalDescription(sd);
      return;
    } catch (e2) {
      livekitLogger.warn("not able to set ".concat(sd.type, ", falling back to unmodified sdp"), {
        error: e2
      });
      sd.sdp = originalSdp;
    }
    try {
      await this.pc.setLocalDescription(sd);
    } catch (e2) {
      let msg = "unknown error";
      if (e2 instanceof Error) {
        msg = e2.message;
      } else if (typeof e2 === "string") {
        msg = e2;
      }
      throw new NegotiationError(msg);
    }
  }
}
function ensureAudioNackAndStereo(media, stereoMids, nackMids) {
  let opusPayload = 0;
  media.rtp.some((rtp) => {
    if (rtp.codec === "opus") {
      opusPayload = rtp.payload;
      return true;
    }
    return false;
  });
  if (opusPayload > 0) {
    if (!media.rtcpFb) {
      media.rtcpFb = [];
    }
    if (nackMids.includes(media.mid) && !media.rtcpFb.some((fb) => fb.payload === opusPayload && fb.type === "nack")) {
      media.rtcpFb.push({
        payload: opusPayload,
        type: "nack"
      });
    }
    if (stereoMids.includes(media.mid)) {
      media.fmtp.some((fmtp) => {
        if (fmtp.payload === opusPayload) {
          if (!fmtp.config.includes("stereo=1")) {
            fmtp.config += ";stereo=1";
          }
          return true;
        }
        return false;
      });
    }
  }
}
function extractStereoAndNackAudioFromOffer(offer) {
  var _a2;
  const stereoMids = [];
  const nackMids = [];
  const sdpParsed = parse$1((_a2 = offer.sdp) !== null && _a2 !== void 0 ? _a2 : "");
  let opusPayload = 0;
  sdpParsed.media.forEach((media) => {
    var _a3;
    if (media.type === "audio") {
      media.rtp.some((rtp) => {
        if (rtp.codec === "opus") {
          opusPayload = rtp.payload;
          return true;
        }
        return false;
      });
      if ((_a3 = media.rtcpFb) === null || _a3 === void 0 ? void 0 : _a3.some((fb) => fb.payload === opusPayload && fb.type === "nack")) {
        nackMids.push(media.mid);
      }
      media.fmtp.some((fmtp) => {
        if (fmtp.payload === opusPayload) {
          if (fmtp.config.includes("sprop-stereo=1")) {
            stereoMids.push(media.mid);
          }
          return true;
        }
        return false;
      });
    }
  });
  return {
    stereoMids,
    nackMids
  };
}
const lossyDataChannel = "_lossy";
const reliableDataChannel = "_reliable";
const minReconnectWait = 2 * 1e3;
const leaveReconnect = "leave-reconnect";
var PCState;
(function(PCState2) {
  PCState2[PCState2["New"] = 0] = "New";
  PCState2[PCState2["Connected"] = 1] = "Connected";
  PCState2[PCState2["Disconnected"] = 2] = "Disconnected";
  PCState2[PCState2["Reconnecting"] = 3] = "Reconnecting";
  PCState2[PCState2["Closed"] = 4] = "Closed";
})(PCState || (PCState = {}));
class RTCEngine extends eventsExports.EventEmitter {
  get isClosed() {
    return this._isClosed;
  }
  constructor(options) {
    super();
    this.options = options;
    this.rtcConfig = {};
    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;
    this.subscriberPrimary = false;
    this.pcState = PCState.New;
    this._isClosed = true;
    this.pendingTrackResolvers = {};
    this.hasPublished = false;
    this.reconnectAttempts = 0;
    this.reconnectStart = 0;
    this.fullReconnectOnNext = false;
    this.attemptingReconnect = false;
    this.joinAttempts = 0;
    this.maxJoinAttempts = 1;
    this.shouldFailNext = false;
    this.handleDataChannel = async (_ref) => {
      let {
        channel: channel2
      } = _ref;
      if (!channel2) {
        return;
      }
      if (channel2.label === reliableDataChannel) {
        this.reliableDCSub = channel2;
      } else if (channel2.label === lossyDataChannel) {
        this.lossyDCSub = channel2;
      } else {
        return;
      }
      livekitLogger.debug("on data channel ".concat(channel2.id, ", ").concat(channel2.label));
      channel2.onmessage = this.handleDataMessage;
    };
    this.handleDataMessage = async (message) => {
      var _a2, _b;
      let buffer2;
      if (message.data instanceof ArrayBuffer) {
        buffer2 = message.data;
      } else if (message.data instanceof Blob) {
        buffer2 = await message.data.arrayBuffer();
      } else {
        livekitLogger.error("unsupported data type", message.data);
        return;
      }
      const dp = DataPacket.decode(new Uint8Array(buffer2));
      if (((_a2 = dp.value) === null || _a2 === void 0 ? void 0 : _a2.$case) === "speaker") {
        this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.speaker.speakers);
      } else if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.$case) === "user") {
        this.emit(EngineEvent.DataPacketReceived, dp.value.user, dp.kind);
      }
    };
    this.handleDataError = (event2) => {
      const channel2 = event2.currentTarget;
      const channelKind = channel2.maxRetransmits === 0 ? "lossy" : "reliable";
      if (event2 instanceof ErrorEvent) {
        const {
          error
        } = event2.error;
        livekitLogger.error("DataChannel error on ".concat(channelKind, ": ").concat(event2.message), error);
      } else {
        livekitLogger.error("Unknown DataChannel Error on ".concat(channelKind), event2);
      }
    };
    this.handleDisconnect = (connection, disconnectReason) => {
      if (this._isClosed) {
        return;
      }
      livekitLogger.warn("".concat(connection, " disconnected"));
      if (this.reconnectAttempts === 0) {
        this.reconnectStart = Date.now();
      }
      const disconnect = (duration2) => {
        livekitLogger.warn("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(duration2, "ms. giving up"));
        this.emit(EngineEvent.Disconnected);
        this.close();
      };
      const duration = Date.now() - this.reconnectStart;
      let delay2 = this.getNextRetryDelay({
        elapsedMs: duration,
        retryCount: this.reconnectAttempts
      });
      if (delay2 === null) {
        disconnect(duration);
        return;
      }
      if (connection === leaveReconnect) {
        delay2 = 0;
      }
      livekitLogger.debug("reconnecting in ".concat(delay2, "ms"));
      this.clearReconnectTimeout();
      this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(disconnectReason), delay2);
    };
    this.handleBrowserOnLine = () => {
      if (this.client.isReconnecting) {
        this.clearReconnectTimeout();
        this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);
      }
    };
    this.client = new SignalClient();
    this.client.signalLatency = this.options.expSignalLatency;
    this.reconnectPolicy = this.options.reconnectPolicy;
    this.registerOnLineListener();
    this.closingLock = new Mutex();
  }
  async join(url, token, opts, abortSignal) {
    this.url = url;
    this.token = token;
    this.signalOpts = opts;
    try {
      this.joinAttempts += 1;
      const joinResponse = await this.client.join(url, token, opts, abortSignal);
      this._isClosed = false;
      this.subscriberPrimary = joinResponse.subscriberPrimary;
      if (!this.publisher) {
        this.configure(joinResponse);
      }
      if (!this.subscriberPrimary) {
        this.negotiate();
      }
      this.clientConfiguration = joinResponse.clientConfiguration;
      return joinResponse;
    } catch (e2) {
      if (e2 instanceof ConnectionError) {
        if (e2.reason === 1) {
          livekitLogger.warn("Couldn't connect to server, attempt ".concat(this.joinAttempts, " of ").concat(this.maxJoinAttempts));
          if (this.joinAttempts < this.maxJoinAttempts) {
            return this.join(url, token, opts, abortSignal);
          }
        }
      }
      throw e2;
    }
  }
  async close() {
    const unlock = await this.closingLock.lock();
    if (this.isClosed) {
      unlock();
      return;
    }
    try {
      this._isClosed = true;
      this.emit(EngineEvent.Closing);
      this.removeAllListeners();
      this.deregisterOnLineListener();
      this.clearPendingReconnect();
      if (this.publisher && this.publisher.pc.signalingState !== "closed") {
        this.publisher.pc.getSenders().forEach((sender) => {
          var _a2, _b;
          try {
            if ((_a2 = this.publisher) === null || _a2 === void 0 ? void 0 : _a2.pc.removeTrack) {
              (_b = this.publisher) === null || _b === void 0 ? void 0 : _b.pc.removeTrack(sender);
            }
          } catch (e2) {
            livekitLogger.warn("could not removeTrack", {
              error: e2
            });
          }
        });
        this.publisher.close();
        this.publisher = void 0;
      }
      if (this.subscriber) {
        this.subscriber.close();
        this.subscriber = void 0;
      }
      await this.client.close();
    } finally {
      unlock();
    }
  }
  addTrack(req) {
    if (this.pendingTrackResolvers[req.cid]) {
      throw new TrackInvalidError("a track with the same ID has already been published");
    }
    return new Promise((resolve, reject) => {
      const publicationTimeout = setTimeout(() => {
        delete this.pendingTrackResolvers[req.cid];
        reject(new ConnectionError("publication of local track timed out, no response from server"));
      }, 1e4);
      this.pendingTrackResolvers[req.cid] = {
        resolve: (info) => {
          clearTimeout(publicationTimeout);
          resolve(info);
        },
        reject: () => {
          clearTimeout(publicationTimeout);
          reject(new Error("Cancelled publication by calling unpublish"));
        }
      };
      this.client.sendAddTrack(req);
    });
  }
  removeTrack(sender) {
    var _a2;
    if (sender.track && this.pendingTrackResolvers[sender.track.id]) {
      const {
        reject
      } = this.pendingTrackResolvers[sender.track.id];
      if (reject) {
        reject();
      }
      delete this.pendingTrackResolvers[sender.track.id];
    }
    try {
      (_a2 = this.publisher) === null || _a2 === void 0 ? void 0 : _a2.pc.removeTrack(sender);
      return true;
    } catch (e2) {
      livekitLogger.warn("failed to remove track", {
        error: e2,
        method: "removeTrack"
      });
    }
    return false;
  }
  updateMuteStatus(trackSid, muted) {
    this.client.sendMuteTrack(trackSid, muted);
  }
  get dataSubscriberReadyState() {
    var _a2;
    return (_a2 = this.reliableDCSub) === null || _a2 === void 0 ? void 0 : _a2.readyState;
  }
  async getConnectedServerAddress() {
    if (this.primaryPC === void 0) {
      return void 0;
    }
    return getConnectedAddress(this.primaryPC);
  }
  configure(joinResponse) {
    var _a2;
    if (this.publisher || this.subscriber) {
      return;
    }
    this.participantSid = (_a2 = joinResponse.participant) === null || _a2 === void 0 ? void 0 : _a2.sid;
    const rtcConfig = this.makeRTCConfiguration(joinResponse);
    this.publisher = new PCTransport(rtcConfig);
    this.subscriber = new PCTransport(rtcConfig);
    this.emit(EngineEvent.TransportsCreated, this.publisher, this.subscriber);
    this.publisher.pc.onicecandidate = (ev) => {
      if (!ev.candidate)
        return;
      livekitLogger.trace("adding ICE candidate for peer", ev.candidate);
      this.client.sendIceCandidate(ev.candidate, SignalTarget.PUBLISHER);
    };
    this.subscriber.pc.onicecandidate = (ev) => {
      if (!ev.candidate)
        return;
      this.client.sendIceCandidate(ev.candidate, SignalTarget.SUBSCRIBER);
    };
    this.publisher.onOffer = (offer) => {
      this.client.sendOffer(offer);
    };
    let primaryPC = this.publisher.pc;
    let secondaryPC = this.subscriber.pc;
    let subscriberPrimary = joinResponse.subscriberPrimary;
    if (subscriberPrimary) {
      primaryPC = this.subscriber.pc;
      secondaryPC = this.publisher.pc;
      this.subscriber.pc.ondatachannel = this.handleDataChannel;
    }
    this.primaryPC = primaryPC;
    primaryPC.onconnectionstatechange = async () => {
      livekitLogger.debug("primary PC state changed ".concat(primaryPC.connectionState));
      if (primaryPC.connectionState === "connected") {
        const shouldEmit = this.pcState === PCState.New;
        this.pcState = PCState.Connected;
        if (shouldEmit) {
          this.emit(EngineEvent.Connected, joinResponse);
        }
      } else if (primaryPC.connectionState === "failed") {
        if (this.pcState === PCState.Connected) {
          this.pcState = PCState.Disconnected;
          this.handleDisconnect("primary peerconnection", subscriberPrimary ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);
        }
      }
    };
    secondaryPC.onconnectionstatechange = async () => {
      livekitLogger.debug("secondary PC state changed ".concat(secondaryPC.connectionState));
      if (secondaryPC.connectionState === "failed") {
        this.handleDisconnect("secondary peerconnection", subscriberPrimary ? ReconnectReason.RR_PUBLISHER_FAILED : ReconnectReason.RR_SUBSCRIBER_FAILED);
      }
    };
    this.subscriber.pc.ontrack = (ev) => {
      this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);
    };
    this.createDataChannels();
    this.client.onAnswer = async (sd) => {
      if (!this.publisher) {
        return;
      }
      livekitLogger.debug("received server answer", {
        RTCSdpType: sd.type,
        signalingState: this.publisher.pc.signalingState
      });
      await this.publisher.setRemoteDescription(sd);
    };
    this.client.onTrickle = (candidate, target) => {
      if (!this.publisher || !this.subscriber) {
        return;
      }
      livekitLogger.trace("got ICE candidate from peer", {
        candidate,
        target
      });
      if (target === SignalTarget.PUBLISHER) {
        this.publisher.addIceCandidate(candidate);
      } else {
        this.subscriber.addIceCandidate(candidate);
      }
    };
    this.client.onOffer = async (sd) => {
      if (!this.subscriber) {
        return;
      }
      livekitLogger.debug("received server offer", {
        RTCSdpType: sd.type,
        signalingState: this.subscriber.pc.signalingState
      });
      await this.subscriber.setRemoteDescription(sd);
      const answer = await this.subscriber.createAndSetAnswer();
      this.client.sendAnswer(answer);
    };
    this.client.onLocalTrackPublished = (res) => {
      livekitLogger.debug("received trackPublishedResponse", res);
      const {
        resolve
      } = this.pendingTrackResolvers[res.cid];
      if (!resolve) {
        livekitLogger.error("missing track resolver for ".concat(res.cid));
        return;
      }
      delete this.pendingTrackResolvers[res.cid];
      resolve(res.track);
    };
    this.client.onTokenRefresh = (token) => {
      this.token = token;
    };
    this.client.onClose = () => {
      this.handleDisconnect("signal", ReconnectReason.RR_SIGNAL_DISCONNECTED);
    };
    this.client.onLeave = (leave) => {
      if (leave === null || leave === void 0 ? void 0 : leave.canReconnect) {
        this.fullReconnectOnNext = true;
        this.primaryPC = void 0;
        this.handleDisconnect(leaveReconnect);
      } else {
        this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);
        this.close();
      }
      livekitLogger.trace("leave request", {
        leave
      });
    };
  }
  makeRTCConfiguration(serverResponse) {
    const rtcConfig = _objectSpread2({}, this.rtcConfig);
    if (serverResponse.iceServers && !rtcConfig.iceServers) {
      const rtcIceServers = [];
      serverResponse.iceServers.forEach((iceServer) => {
        const rtcIceServer = {
          urls: iceServer.urls
        };
        if (iceServer.username)
          rtcIceServer.username = iceServer.username;
        if (iceServer.credential) {
          rtcIceServer.credential = iceServer.credential;
        }
        rtcIceServers.push(rtcIceServer);
      });
      rtcConfig.iceServers = rtcIceServers;
    }
    if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {
      rtcConfig.iceTransportPolicy = "relay";
    }
    rtcConfig.sdpSemantics = "unified-plan";
    rtcConfig.continualGatheringPolicy = "gather_continually";
    return rtcConfig;
  }
  createDataChannels() {
    if (!this.publisher) {
      return;
    }
    if (this.lossyDC) {
      this.lossyDC.onmessage = null;
      this.lossyDC.onerror = null;
    }
    if (this.reliableDC) {
      this.reliableDC.onmessage = null;
      this.reliableDC.onerror = null;
    }
    this.lossyDC = this.publisher.pc.createDataChannel(lossyDataChannel, {
      ordered: true,
      maxRetransmits: 0
    });
    this.reliableDC = this.publisher.pc.createDataChannel(reliableDataChannel, {
      ordered: true
    });
    this.lossyDC.onmessage = this.handleDataMessage;
    this.reliableDC.onmessage = this.handleDataMessage;
    this.lossyDC.onerror = this.handleDataError;
    this.reliableDC.onerror = this.handleDataError;
  }
  setPreferredCodec(transceiver, kind, videoCodec) {
    if (!("getCapabilities" in RTCRtpSender)) {
      return;
    }
    const cap = RTCRtpSender.getCapabilities(kind);
    if (!cap)
      return;
    livekitLogger.debug("get capabilities", cap);
    const matched = [];
    const partialMatched = [];
    const unmatched = [];
    cap.codecs.forEach((c) => {
      const codec = c.mimeType.toLowerCase();
      if (codec === "audio/opus") {
        matched.push(c);
        return;
      }
      const matchesVideoCodec = codec === "video/".concat(videoCodec);
      if (!matchesVideoCodec) {
        unmatched.push(c);
        return;
      }
      if (videoCodec === "h264") {
        if (c.sdpFmtpLine && c.sdpFmtpLine.includes("profile-level-id=42e01f")) {
          matched.push(c);
        } else {
          partialMatched.push(c);
        }
        return;
      }
      matched.push(c);
    });
    if (supportsSetCodecPreferences(transceiver)) {
      transceiver.setCodecPreferences(matched.concat(partialMatched, unmatched));
    }
  }
  async createSender(track, opts, encodings) {
    if (supportsTransceiver()) {
      return this.createTransceiverRTCRtpSender(track, opts, encodings);
    }
    if (supportsAddTrack()) {
      livekitLogger.debug("using add-track fallback");
      return this.createRTCRtpSender(track.mediaStreamTrack);
    }
    throw new UnexpectedConnectionState("Required webRTC APIs not supported on this device");
  }
  async createSimulcastSender(track, simulcastTrack, opts, encodings) {
    if (supportsTransceiver()) {
      return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);
    }
    if (supportsAddTrack()) {
      livekitLogger.debug("using add-track fallback");
      return this.createRTCRtpSender(track.mediaStreamTrack);
    }
    throw new UnexpectedConnectionState("Cannot stream on this device");
  }
  async createTransceiverRTCRtpSender(track, opts, encodings) {
    if (!this.publisher) {
      throw new UnexpectedConnectionState("publisher is closed");
    }
    const transceiverInit = {
      direction: "sendonly"
    };
    if (encodings) {
      transceiverInit.sendEncodings = encodings;
    }
    const transceiver = await this.publisher.pc.addTransceiver(track.mediaStreamTrack, transceiverInit);
    if (track.kind === Track.Kind.Video && opts.videoCodec) {
      this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);
      track.codec = opts.videoCodec;
    }
    return transceiver.sender;
  }
  async createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {
    if (!this.publisher) {
      throw new UnexpectedConnectionState("publisher is closed");
    }
    const transceiverInit = {
      direction: "sendonly"
    };
    if (encodings) {
      transceiverInit.sendEncodings = encodings;
    }
    const transceiver = await this.publisher.pc.addTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);
    if (!opts.videoCodec) {
      return;
    }
    this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);
    track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);
    return transceiver.sender;
  }
  async createRTCRtpSender(track) {
    if (!this.publisher) {
      throw new UnexpectedConnectionState("publisher is closed");
    }
    return this.publisher.pc.addTrack(track);
  }
  async attemptReconnect(reason) {
    var _a2, _b, _c;
    if (this._isClosed) {
      return;
    }
    if (this.attemptingReconnect) {
      return;
    }
    if (((_a2 = this.clientConfiguration) === null || _a2 === void 0 ? void 0 : _a2.resumeConnection) === ClientConfigSetting.DISABLED || ((_c = (_b = this.primaryPC) === null || _b === void 0 ? void 0 : _b.signalingState) !== null && _c !== void 0 ? _c : "closed") === "closed") {
      this.fullReconnectOnNext = true;
    }
    try {
      this.attemptingReconnect = true;
      if (this.fullReconnectOnNext) {
        await this.restartConnection();
      } else {
        await this.resumeConnection(reason);
      }
      this.clearPendingReconnect();
      this.fullReconnectOnNext = false;
    } catch (e2) {
      this.reconnectAttempts += 1;
      let recoverable = true;
      if (e2 instanceof UnexpectedConnectionState) {
        livekitLogger.debug("received unrecoverable error", {
          error: e2
        });
        recoverable = false;
      } else if (!(e2 instanceof SignalReconnectError)) {
        this.fullReconnectOnNext = true;
      }
      if (recoverable) {
        this.handleDisconnect("reconnect", ReconnectReason.RR_UNKOWN);
      } else {
        livekitLogger.info("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(Date.now() - this.reconnectStart, "ms. giving up"));
        this.emit(EngineEvent.Disconnected);
        this.close();
      }
    } finally {
      this.attemptingReconnect = false;
    }
  }
  getNextRetryDelay(context2) {
    try {
      return this.reconnectPolicy.nextRetryDelayInMs(context2);
    } catch (e2) {
      livekitLogger.warn("encountered error in reconnect policy", {
        error: e2
      });
    }
    return null;
  }
  async restartConnection() {
    var _a2, _b;
    if (!this.url || !this.token) {
      throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
    }
    livekitLogger.info("reconnecting, attempt: ".concat(this.reconnectAttempts));
    this.emit(EngineEvent.Restarting);
    if (this.client.isConnected) {
      await this.client.sendLeave();
    }
    await this.client.close();
    this.primaryPC = void 0;
    (_a2 = this.publisher) === null || _a2 === void 0 ? void 0 : _a2.close();
    this.publisher = void 0;
    (_b = this.subscriber) === null || _b === void 0 ? void 0 : _b.close();
    this.subscriber = void 0;
    let joinResponse;
    try {
      if (!this.signalOpts) {
        livekitLogger.warn("attempted connection restart, without signal options present");
        throw new SignalReconnectError();
      }
      joinResponse = await this.join(this.url, this.token, this.signalOpts);
    } catch (e2) {
      throw new SignalReconnectError();
    }
    if (this.shouldFailNext) {
      this.shouldFailNext = false;
      throw new Error("simulated failure");
    }
    await this.waitForPCConnected();
    this.client.setReconnected();
    this.emit(EngineEvent.Restarted, joinResponse);
  }
  async resumeConnection(reason) {
    var _a2;
    if (!this.url || !this.token) {
      throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
    }
    if (!this.publisher || !this.subscriber) {
      throw new UnexpectedConnectionState("publisher and subscriber connections unset");
    }
    livekitLogger.info("resuming signal connection, attempt ".concat(this.reconnectAttempts));
    this.emit(EngineEvent.Resuming);
    try {
      const res = await this.client.reconnect(this.url, this.token, this.participantSid, reason);
      if (res) {
        const rtcConfig = this.makeRTCConfiguration(res);
        this.publisher.pc.setConfiguration(rtcConfig);
        this.subscriber.pc.setConfiguration(rtcConfig);
      }
    } catch (e2) {
      let message = "";
      if (e2 instanceof Error) {
        message = e2.message;
      }
      throw new SignalReconnectError(message);
    }
    this.emit(EngineEvent.SignalResumed);
    if (this.shouldFailNext) {
      this.shouldFailNext = false;
      throw new Error("simulated failure");
    }
    this.subscriber.restartingIce = true;
    if (this.hasPublished) {
      await this.publisher.createAndSendOffer({
        iceRestart: true
      });
    }
    await this.waitForPCConnected();
    this.client.setReconnected();
    if (((_a2 = this.reliableDC) === null || _a2 === void 0 ? void 0 : _a2.readyState) === "open" && this.reliableDC.id === null) {
      this.createDataChannels();
    }
    this.emit(EngineEvent.Resumed);
  }
  async waitForPCConnected() {
    var _a2;
    const startTime = Date.now();
    let now2 = startTime;
    this.pcState = PCState.Reconnecting;
    livekitLogger.debug("waiting for peer connection to reconnect");
    while (now2 - startTime < this.peerConnectionTimeout) {
      if (this.primaryPC === void 0) {
        break;
      } else if (now2 - startTime > minReconnectWait && ((_a2 = this.primaryPC) === null || _a2 === void 0 ? void 0 : _a2.connectionState) === "connected") {
        this.pcState = PCState.Connected;
      }
      if (this.pcState === PCState.Connected) {
        return;
      }
      await sleep(100);
      now2 = Date.now();
    }
    throw new ConnectionError("could not establish PC connection");
  }
  async sendDataPacket(packet, kind) {
    const msg = DataPacket.encode(packet).finish();
    await this.ensurePublisherConnected(kind);
    if (kind === DataPacket_Kind.LOSSY && this.lossyDC) {
      this.lossyDC.send(msg);
    } else if (kind === DataPacket_Kind.RELIABLE && this.reliableDC) {
      this.reliableDC.send(msg);
    }
  }
  async ensureDataTransportConnected(kind) {
    let subscriber = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.subscriberPrimary;
    var _a2, _b, _c;
    const transport = subscriber ? this.subscriber : this.publisher;
    const transportName = subscriber ? "Subscriber" : "Publisher";
    if (!transport) {
      throw new ConnectionError("".concat(transportName, " connection not set"));
    }
    if (!subscriber && !((_a2 = this.publisher) === null || _a2 === void 0 ? void 0 : _a2.isICEConnected) && ((_b = this.publisher) === null || _b === void 0 ? void 0 : _b.pc.iceConnectionState) !== "checking") {
      this.negotiate();
    }
    const targetChannel = this.dataChannelForKind(kind, subscriber);
    if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === "open") {
      return;
    }
    const endTime = new Date().getTime() + this.peerConnectionTimeout;
    while (new Date().getTime() < endTime) {
      if (transport.isICEConnected && ((_c = this.dataChannelForKind(kind, subscriber)) === null || _c === void 0 ? void 0 : _c.readyState) === "open") {
        return;
      }
      await sleep(50);
    }
    throw new ConnectionError("could not establish ".concat(transportName, " connection, state: ").concat(transport.pc.iceConnectionState));
  }
  async ensurePublisherConnected(kind) {
    await this.ensureDataTransportConnected(kind, false);
  }
  negotiate() {
    return new Promise((resolve, reject) => {
      if (!this.publisher) {
        reject(new NegotiationError("publisher is not defined"));
        return;
      }
      this.hasPublished = true;
      const handleClosed = () => {
        livekitLogger.debug("engine disconnected while negotiation was ongoing");
        cleanup();
        resolve();
        return;
      };
      this.on(EngineEvent.Closing, handleClosed);
      const negotiationTimeout = setTimeout(() => {
        reject("negotiation timed out");
        this.handleDisconnect("negotiation", ReconnectReason.RR_SIGNAL_DISCONNECTED);
      }, this.peerConnectionTimeout);
      const cleanup = () => {
        clearTimeout(negotiationTimeout);
        this.off(EngineEvent.Closing, handleClosed);
      };
      this.publisher.once(PCEvents.NegotiationStarted, () => {
        var _a2;
        (_a2 = this.publisher) === null || _a2 === void 0 ? void 0 : _a2.once(PCEvents.NegotiationComplete, () => {
          cleanup();
          resolve();
        });
      });
      this.publisher.negotiate((e2) => {
        cleanup();
        reject(e2);
        if (e2 instanceof NegotiationError) {
          this.fullReconnectOnNext = true;
        }
        this.handleDisconnect("negotiation", ReconnectReason.RR_UNKOWN);
      });
    });
  }
  dataChannelForKind(kind, sub) {
    if (!sub) {
      if (kind === DataPacket_Kind.LOSSY) {
        return this.lossyDC;
      }
      if (kind === DataPacket_Kind.RELIABLE) {
        return this.reliableDC;
      }
    } else {
      if (kind === DataPacket_Kind.LOSSY) {
        return this.lossyDCSub;
      }
      if (kind === DataPacket_Kind.RELIABLE) {
        return this.reliableDCSub;
      }
    }
  }
  failNext() {
    this.shouldFailNext = true;
  }
  clearReconnectTimeout() {
    if (this.reconnectTimeout) {
      CriticalTimers.clearTimeout(this.reconnectTimeout);
    }
  }
  clearPendingReconnect() {
    this.clearReconnectTimeout();
    this.reconnectAttempts = 0;
  }
  registerOnLineListener() {
    if (isWeb()) {
      window.addEventListener("online", this.handleBrowserOnLine);
    }
  }
  deregisterOnLineListener() {
    if (isWeb()) {
      window.removeEventListener("online", this.handleBrowserOnLine);
    }
  }
}
async function getConnectedAddress(pc) {
  var _a2;
  let selectedCandidatePairId = "";
  const candidatePairs = /* @__PURE__ */ new Map();
  const candidates = /* @__PURE__ */ new Map();
  const stats = await pc.getStats();
  stats.forEach((v) => {
    switch (v.type) {
      case "transport":
        selectedCandidatePairId = v.selectedCandidatePairId;
        break;
      case "candidate-pair":
        if (selectedCandidatePairId === "" && v.selected) {
          selectedCandidatePairId = v.id;
        }
        candidatePairs.set(v.id, v);
        break;
      case "remote-candidate":
        candidates.set(v.id, "".concat(v.address, ":").concat(v.port));
        break;
    }
  });
  if (selectedCandidatePairId === "") {
    return void 0;
  }
  const selectedID = (_a2 = candidatePairs.get(selectedCandidatePairId)) === null || _a2 === void 0 ? void 0 : _a2.remoteCandidateId;
  if (selectedID === void 0) {
    return void 0;
  }
  return candidates.get(selectedID);
}
class SignalReconnectError extends Error {
}
var ConnectionState;
(function(ConnectionState2) {
  ConnectionState2["Disconnected"] = "disconnected";
  ConnectionState2["Connecting"] = "connecting";
  ConnectionState2["Connected"] = "connected";
  ConnectionState2["Reconnecting"] = "reconnecting";
})(ConnectionState || (ConnectionState = {}));
class Room extends eventsExports.EventEmitter {
  constructor(options) {
    var _this;
    super();
    _this = this;
    this.state = ConnectionState.Disconnected;
    this.activeSpeakers = [];
    this.sid = "";
    this.name = "";
    this.metadata = void 0;
    this._isRecording = false;
    this.audioEnabled = true;
    this.connect = async (url, token, opts) => {
      const unlockDisconnect = await this.disconnectLock.lock();
      if (this.state === ConnectionState.Connected) {
        livekitLogger.info("already connected to room ".concat(this.name));
        unlockDisconnect();
        return Promise.resolve();
      }
      if (this.connectFuture) {
        unlockDisconnect();
        return this.connectFuture.promise;
      }
      this.setAndEmitConnectionState(ConnectionState.Connecting);
      const connectFn = async (resolve, reject) => {
        var _a2, _b;
        if (!this.abortController || this.abortController.signal.aborted) {
          this.abortController = new AbortController();
        }
        unlockDisconnect();
        if (this.state === ConnectionState.Reconnecting) {
          livekitLogger.info("Reconnection attempt replaced by new connection attempt");
          this.recreateEngine();
        } else {
          this.maybeCreateEngine();
        }
        this.acquireAudioContext();
        this.connOptions = _objectSpread2(_objectSpread2({}, roomConnectOptionDefaults), opts);
        if (this.connOptions.rtcConfig) {
          this.engine.rtcConfig = this.connOptions.rtcConfig;
        }
        if (this.connOptions.peerConnectionTimeout) {
          this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;
        }
        try {
          const joinResponse = await this.engine.join(url, token, {
            autoSubscribe: this.connOptions.autoSubscribe,
            publishOnly: this.connOptions.publishOnly,
            adaptiveStream: typeof this.options.adaptiveStream === "object" ? true : this.options.adaptiveStream,
            maxRetries: this.connOptions.maxRetries
          }, this.abortController.signal);
          let serverInfo = joinResponse.serverInfo;
          if (!serverInfo) {
            serverInfo = {
              version: joinResponse.serverVersion,
              region: joinResponse.serverRegion
            };
          }
          livekitLogger.debug("connected to Livekit Server ".concat(Object.entries(serverInfo).map((_ref) => {
            let [key, value] = _ref;
            return "".concat(key, ": ").concat(value);
          }).join(", ")));
          if (!joinResponse.serverVersion) {
            throw new UnsupportedServer("unknown server version");
          }
          if (joinResponse.serverVersion === "0.15.1" && this.options.dynacast) {
            livekitLogger.debug("disabling dynacast due to server version");
            this.options.dynacast = false;
          }
          const pi = joinResponse.participant;
          this.localParticipant.sid = pi.sid;
          this.localParticipant.identity = pi.identity;
          this.localParticipant.updateInfo(pi);
          this.setupLocalParticipantEvents();
          joinResponse.otherParticipants.forEach((info) => {
            if (info.sid !== this.localParticipant.sid && info.identity !== this.localParticipant.identity) {
              this.getOrCreateParticipant(info.sid, info);
            } else {
              livekitLogger.warn("received info to create local participant as remote participant", {
                info,
                localParticipant: this.localParticipant
              });
            }
          });
          this.name = joinResponse.room.name;
          this.sid = joinResponse.room.sid;
          this.metadata = joinResponse.room.metadata;
          if (this._isRecording !== joinResponse.room.activeRecording) {
            this._isRecording = joinResponse.room.activeRecording;
            this.emit(RoomEvent.RecordingStatusChanged, joinResponse.room.activeRecording);
          }
          this.emit(RoomEvent.SignalConnected);
        } catch (err) {
          this.recreateEngine();
          this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);
          const resultingError = new ConnectionError("could not establish signal connection");
          if (err instanceof Error) {
            resultingError.message = "".concat(resultingError.message, ": ").concat(err.message);
          }
          if (err instanceof ConnectionError) {
            resultingError.reason = err.reason;
            resultingError.status = err.status;
          }
          livekitLogger.debug("error trying to establish signal connection", {
            error: err
          });
          reject(resultingError);
          return;
        }
        const connectTimeout = CriticalTimers.setTimeout(() => {
          this.recreateEngine();
          this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);
          reject(new ConnectionError("could not connect PeerConnection after timeout"));
        }, this.connOptions.peerConnectionTimeout);
        const abortHandler = () => {
          livekitLogger.warn("closing engine");
          CriticalTimers.clearTimeout(connectTimeout);
          this.recreateEngine();
          this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);
          reject(new ConnectionError("room connection has been cancelled"));
        };
        if ((_a2 = this.abortController) === null || _a2 === void 0 ? void 0 : _a2.signal.aborted) {
          abortHandler();
        }
        (_b = this.abortController) === null || _b === void 0 ? void 0 : _b.signal.addEventListener("abort", abortHandler);
        this.engine.once(EngineEvent.Connected, () => {
          var _a3, _b2;
          CriticalTimers.clearTimeout(connectTimeout);
          (_a3 = this.abortController) === null || _a3 === void 0 ? void 0 : _a3.signal.removeEventListener("abort", abortHandler);
          if (isWeb()) {
            window.addEventListener("beforeunload", this.onBeforeUnload);
            (_b2 = navigator.mediaDevices) === null || _b2 === void 0 ? void 0 : _b2.addEventListener("devicechange", this.handleDeviceChange);
          }
          this.setAndEmitConnectionState(ConnectionState.Connected);
          this.emit(RoomEvent.Connected);
          resolve();
        });
      };
      this.connectFuture = new Future(connectFn, () => {
        this.clearConnectionFutures();
      });
      return this.connectFuture.promise;
    };
    this.disconnect = async function() {
      let stopTracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var _a2, _b, _c, _d;
      const unlock = await _this.disconnectLock.lock();
      try {
        if (_this.state === ConnectionState.Disconnected) {
          livekitLogger.debug("already disconnected");
          return;
        }
        livekitLogger.info("disconnect from room", {
          identity: _this.localParticipant.identity
        });
        if (_this.state === ConnectionState.Connecting || _this.state === ConnectionState.Reconnecting) {
          livekitLogger.warn("abort connection attempt");
          (_a2 = _this.abortController) === null || _a2 === void 0 ? void 0 : _a2.abort();
          (_c = (_b = _this.connectFuture) === null || _b === void 0 ? void 0 : _b.reject) === null || _c === void 0 ? void 0 : _c.call(_b, new ConnectionError("Client initiated disconnect"));
          _this.connectFuture = void 0;
        }
        if ((_d = _this.engine) === null || _d === void 0 ? void 0 : _d.client.isConnected) {
          await _this.engine.client.sendLeave();
        }
        if (_this.engine) {
          await _this.engine.close();
        }
        _this.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);
        _this.engine = void 0;
      } finally {
        unlock();
      }
    };
    this.onBeforeUnload = async () => {
      await this.disconnect();
    };
    this.handleRestarting = () => {
      for (const p of this.participants.values()) {
        this.handleParticipantDisconnected(p.sid, p);
      }
      if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {
        this.emit(RoomEvent.Reconnecting);
      }
    };
    this.handleRestarted = async (joinResponse) => {
      livekitLogger.debug("reconnected to server", {
        region: joinResponse.serverRegion
      });
      try {
        if (joinResponse.participant) {
          this.localParticipant.sid = joinResponse.participant.sid;
          this.handleParticipantUpdates([joinResponse.participant]);
        }
        this.handleParticipantUpdates(joinResponse.otherParticipants);
        const localPubs = [];
        this.localParticipant.tracks.forEach((pub) => {
          if (pub.track) {
            localPubs.push(pub);
          }
        });
        await Promise.all(localPubs.map(async (pub) => {
          const track = pub.track;
          this.localParticipant.unpublishTrack(track, false);
          if (!track.isMuted) {
            if ((track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) && !track.isUserProvided) {
              livekitLogger.debug("restarting existing track", {
                track: pub.trackSid
              });
              await track.restartTrack();
            }
            livekitLogger.debug("publishing new track", {
              track: pub.trackSid
            });
            await this.localParticipant.publishTrack(track, pub.options);
          }
        }));
      } catch (error) {
        livekitLogger.error("error trying to re-publish tracks after reconnection", {
          error
        });
      } finally {
        this.setAndEmitConnectionState(ConnectionState.Connected);
        this.emit(RoomEvent.Reconnected);
      }
    };
    this.handleParticipantUpdates = (participantInfos) => {
      participantInfos.forEach((info) => {
        if (info.identity === this.localParticipant.identity) {
          this.localParticipant.updateInfo(info);
          return;
        }
        const sid = this.identityToSid.get(info.identity);
        if (sid && sid !== info.sid) {
          this.handleParticipantDisconnected(sid, this.participants.get(sid));
        }
        let remoteParticipant = this.participants.get(info.sid);
        const isNewParticipant = !remoteParticipant;
        if (info.state === ParticipantInfo_State.DISCONNECTED) {
          this.handleParticipantDisconnected(info.sid, remoteParticipant);
        } else {
          remoteParticipant = this.getOrCreateParticipant(info.sid, info);
          if (!isNewParticipant) {
            remoteParticipant.updateInfo(info);
          }
        }
      });
    };
    this.handleActiveSpeakersUpdate = (speakers) => {
      const activeSpeakers = [];
      const seenSids = {};
      speakers.forEach((speaker) => {
        seenSids[speaker.sid] = true;
        if (speaker.sid === this.localParticipant.sid) {
          this.localParticipant.audioLevel = speaker.level;
          this.localParticipant.setIsSpeaking(true);
          activeSpeakers.push(this.localParticipant);
        } else {
          const p = this.participants.get(speaker.sid);
          if (p) {
            p.audioLevel = speaker.level;
            p.setIsSpeaking(true);
            activeSpeakers.push(p);
          }
        }
      });
      if (!seenSids[this.localParticipant.sid]) {
        this.localParticipant.audioLevel = 0;
        this.localParticipant.setIsSpeaking(false);
      }
      this.participants.forEach((p) => {
        if (!seenSids[p.sid]) {
          p.audioLevel = 0;
          p.setIsSpeaking(false);
        }
      });
      this.activeSpeakers = activeSpeakers;
      this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);
    };
    this.handleSpeakersChanged = (speakerUpdates) => {
      const lastSpeakers = /* @__PURE__ */ new Map();
      this.activeSpeakers.forEach((p) => {
        lastSpeakers.set(p.sid, p);
      });
      speakerUpdates.forEach((speaker) => {
        let p = this.participants.get(speaker.sid);
        if (speaker.sid === this.localParticipant.sid) {
          p = this.localParticipant;
        }
        if (!p) {
          return;
        }
        p.audioLevel = speaker.level;
        p.setIsSpeaking(speaker.active);
        if (speaker.active) {
          lastSpeakers.set(speaker.sid, p);
        } else {
          lastSpeakers.delete(speaker.sid);
        }
      });
      const activeSpeakers = Array.from(lastSpeakers.values());
      activeSpeakers.sort((a, b) => b.audioLevel - a.audioLevel);
      this.activeSpeakers = activeSpeakers;
      this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);
    };
    this.handleStreamStateUpdate = (streamStateUpdate) => {
      streamStateUpdate.streamStates.forEach((streamState) => {
        const participant = this.participants.get(streamState.participantSid);
        if (!participant) {
          return;
        }
        const pub = participant.getTrackPublication(streamState.trackSid);
        if (!pub || !pub.track) {
          return;
        }
        pub.track.streamState = Track.streamStateFromProto(streamState.state);
        participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);
        this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);
      });
    };
    this.handleSubscriptionPermissionUpdate = (update) => {
      const participant = this.participants.get(update.participantSid);
      if (!participant) {
        return;
      }
      const pub = participant.getTrackPublication(update.trackSid);
      if (!pub) {
        return;
      }
      pub.setAllowed(update.allowed);
    };
    this.handleDataPacket = (userPacket, kind) => {
      const participant = this.participants.get(userPacket.participantSid);
      this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);
      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);
    };
    this.handleAudioPlaybackStarted = () => {
      if (this.canPlaybackAudio) {
        return;
      }
      this.audioEnabled = true;
      this.emit(RoomEvent.AudioPlaybackStatusChanged, true);
    };
    this.handleAudioPlaybackFailed = (e2) => {
      livekitLogger.warn("could not playback audio", e2);
      if (!this.canPlaybackAudio) {
        return;
      }
      this.audioEnabled = false;
      this.emit(RoomEvent.AudioPlaybackStatusChanged, false);
    };
    this.handleDeviceChange = async () => {
      this.emit(RoomEvent.MediaDevicesChanged);
    };
    this.handleRoomUpdate = (r2) => {
      if (this._isRecording !== r2.activeRecording) {
        this._isRecording = r2.activeRecording;
        this.emit(RoomEvent.RecordingStatusChanged, r2.activeRecording);
      }
      if (this.metadata !== r2.metadata) {
        this.metadata = r2.metadata;
        this.emitWhenConnected(RoomEvent.RoomMetadataChanged, r2.metadata);
      }
    };
    this.handleConnectionQualityUpdate = (update) => {
      update.updates.forEach((info) => {
        if (info.participantSid === this.localParticipant.sid) {
          this.localParticipant.setConnectionQuality(info.quality);
          return;
        }
        const participant = this.participants.get(info.participantSid);
        if (participant) {
          participant.setConnectionQuality(info.quality);
        }
      });
    };
    this.onLocalParticipantMetadataChanged = (metadata) => {
      this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);
    };
    this.onLocalTrackMuted = (pub) => {
      this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);
    };
    this.onLocalTrackUnmuted = (pub) => {
      this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);
    };
    this.onLocalTrackPublished = (pub) => {
      this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);
    };
    this.onLocalTrackUnpublished = (pub) => {
      this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);
    };
    this.onLocalConnectionQualityChanged = (quality) => {
      this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);
    };
    this.onMediaDevicesError = (e2) => {
      this.emit(RoomEvent.MediaDevicesError, e2);
    };
    this.onLocalParticipantPermissionsChanged = (prevPermissions) => {
      this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);
    };
    this.setMaxListeners(100);
    this.participants = /* @__PURE__ */ new Map();
    this.identityToSid = /* @__PURE__ */ new Map();
    this.options = _objectSpread2(_objectSpread2({}, roomOptionDefaults), options);
    this.options.audioCaptureDefaults = _objectSpread2(_objectSpread2({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);
    this.options.videoCaptureDefaults = _objectSpread2(_objectSpread2({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);
    this.options.publishDefaults = _objectSpread2(_objectSpread2({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);
    this.maybeCreateEngine();
    this.disconnectLock = new Mutex();
    this.localParticipant = new LocalParticipant("", "", this.engine, this.options);
  }
  maybeCreateEngine() {
    if (this.engine) {
      return;
    }
    this.engine = new RTCEngine(this.options);
    this.engine.client.onParticipantUpdate = this.handleParticipantUpdates;
    this.engine.client.onRoomUpdate = this.handleRoomUpdate;
    this.engine.client.onSpeakersChanged = this.handleSpeakersChanged;
    this.engine.client.onStreamStateUpdate = this.handleStreamStateUpdate;
    this.engine.client.onSubscriptionPermissionUpdate = this.handleSubscriptionPermissionUpdate;
    this.engine.client.onConnectionQuality = this.handleConnectionQualityUpdate;
    this.engine.on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver) => {
      this.onTrackAdded(mediaTrack, stream, receiver);
    }).on(EngineEvent.Disconnected, (reason) => {
      this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);
    }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {
      if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {
        this.emit(RoomEvent.Reconnecting);
      }
    }).on(EngineEvent.Resumed, () => {
      this.setAndEmitConnectionState(ConnectionState.Connected);
      this.emit(RoomEvent.Reconnected);
      this.updateSubscriptions();
    }).on(EngineEvent.SignalResumed, () => {
      if (this.state === ConnectionState.Reconnecting) {
        this.sendSyncState();
      }
    }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.Restarted, this.handleRestarted);
    if (this.localParticipant) {
      this.localParticipant.setupEngine(this.engine);
    }
  }
  static getLocalDevices(kind) {
    let requestPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    return DeviceManager.getInstance().getDevices(kind, requestPermissions);
  }
  async prepareConnection(url) {
    await fetch("http".concat(url.substring(2)), {
      method: "HEAD"
    });
  }
  getParticipantByIdentity(identity2) {
    if (this.localParticipant.identity === identity2) {
      return this.localParticipant;
    }
    const sid = this.identityToSid.get(identity2);
    if (sid) {
      return this.participants.get(sid);
    }
  }
  clearConnectionFutures() {
    this.connectFuture = void 0;
  }
  get isRecording() {
    return this._isRecording;
  }
  async simulateScenario(scenario) {
    let postAction = () => {
    };
    let req;
    switch (scenario) {
      case "signal-reconnect":
        await this.engine.client.close();
        if (this.engine.client.onClose) {
          this.engine.client.onClose("simulate disconnect");
        }
        break;
      case "speaker":
        req = SimulateScenario.fromPartial({
          scenario: {
            $case: "speakerUpdate",
            speakerUpdate: 3
          }
        });
        break;
      case "node-failure":
        req = SimulateScenario.fromPartial({
          scenario: {
            $case: "nodeFailure",
            nodeFailure: true
          }
        });
        break;
      case "server-leave":
        req = SimulateScenario.fromPartial({
          scenario: {
            $case: "serverLeave",
            serverLeave: true
          }
        });
        break;
      case "migration":
        req = SimulateScenario.fromPartial({
          scenario: {
            $case: "migration",
            migration: true
          }
        });
        break;
      case "resume-reconnect":
        this.engine.failNext();
        await this.engine.client.close();
        if (this.engine.client.onClose) {
          this.engine.client.onClose("simulate resume-reconnect");
        }
        break;
      case "force-tcp":
      case "force-tls":
        req = SimulateScenario.fromPartial({
          scenario: {
            $case: "switchCandidateProtocol",
            switchCandidateProtocol: scenario === "force-tls" ? 2 : 1
          }
        });
        postAction = async () => {
          const onLeave = this.engine.client.onLeave;
          if (onLeave) {
            onLeave({
              reason: DisconnectReason.CLIENT_INITIATED,
              canReconnect: true
            });
          }
        };
        break;
    }
    if (req) {
      this.engine.client.sendSimulateScenario(req);
      postAction();
    }
  }
  async startAudio() {
    await this.acquireAudioContext();
    const elements = [];
    this.participants.forEach((p) => {
      p.audioTracks.forEach((t2) => {
        if (t2.track) {
          t2.track.attachedElements.forEach((e2) => {
            elements.push(e2);
          });
        }
      });
    });
    try {
      await Promise.all(elements.map((e2) => {
        e2.muted = false;
        return e2.play();
      }));
      this.handleAudioPlaybackStarted();
    } catch (err) {
      this.handleAudioPlaybackFailed(err);
      throw err;
    }
  }
  get canPlaybackAudio() {
    return this.audioEnabled;
  }
  getActiveAudioOutputDevice() {
    var _a2, _b;
    return (_b = (_a2 = this.options.audioOutput) === null || _a2 === void 0 ? void 0 : _a2.deviceId) !== null && _b !== void 0 ? _b : "";
  }
  async switchActiveDevice(kind, deviceId) {
    let exact = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var _a2;
    var _b;
    const deviceConstraint = exact ? {
      exact: deviceId
    } : deviceId;
    if (kind === "audioinput") {
      const prevDeviceId = this.options.audioCaptureDefaults.deviceId;
      this.options.audioCaptureDefaults.deviceId = deviceConstraint;
      const tracks = Array.from(this.localParticipant.audioTracks.values()).filter((track) => track.source === Track.Source.Microphone);
      try {
        await Promise.all(tracks.map((t2) => {
          var _a3;
          return (_a3 = t2.audioTrack) === null || _a3 === void 0 ? void 0 : _a3.setDeviceId(deviceConstraint);
        }));
      } catch (e2) {
        this.options.audioCaptureDefaults.deviceId = prevDeviceId;
        throw e2;
      }
    } else if (kind === "videoinput") {
      const prevDeviceId = this.options.videoCaptureDefaults.deviceId;
      this.options.videoCaptureDefaults.deviceId = deviceConstraint;
      const tracks = Array.from(this.localParticipant.videoTracks.values()).filter((track) => track.source === Track.Source.Camera);
      try {
        await Promise.all(tracks.map((t2) => {
          var _a3;
          return (_a3 = t2.videoTrack) === null || _a3 === void 0 ? void 0 : _a3.setDeviceId(deviceConstraint);
        }));
      } catch (e2) {
        this.options.videoCaptureDefaults.deviceId = prevDeviceId;
        throw e2;
      }
    } else if (kind === "audiooutput") {
      if (!supportsSetSinkId()) {
        throw new Error("cannot switch audio output, setSinkId not supported");
      }
      (_a2 = (_b = this.options).audioOutput) !== null && _a2 !== void 0 ? _a2 : _b.audioOutput = {};
      const prevDeviceId = this.options.audioOutput.deviceId;
      this.options.audioOutput.deviceId = deviceId;
      try {
        await Promise.all(Array.from(this.participants.values()).map((p) => p.setAudioOutput({
          deviceId
        })));
      } catch (e2) {
        this.options.audioOutput.deviceId = prevDeviceId;
        throw e2;
      }
    }
  }
  setupLocalParticipantEvents() {
    this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
  }
  recreateEngine() {
    var _a2;
    (_a2 = this.engine) === null || _a2 === void 0 ? void 0 : _a2.close();
    this.engine = void 0;
    this.participants.clear();
    this.maybeCreateEngine();
  }
  onTrackAdded(mediaTrack, stream, receiver) {
    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {
      const reconnectedHandler = () => {
        this.onTrackAdded(mediaTrack, stream, receiver);
        cleanup();
      };
      const cleanup = () => {
        this.off(RoomEvent.Reconnected, reconnectedHandler);
        this.off(RoomEvent.Connected, reconnectedHandler);
        this.off(RoomEvent.Disconnected, cleanup);
      };
      this.once(RoomEvent.Reconnected, reconnectedHandler);
      this.once(RoomEvent.Connected, reconnectedHandler);
      this.once(RoomEvent.Disconnected, cleanup);
      return;
    }
    if (this.state === ConnectionState.Disconnected) {
      livekitLogger.warn("skipping incoming track after Room disconnected");
      return;
    }
    const parts = unpackStreamId(stream.id);
    const participantId = parts[0];
    let trackId = parts[1];
    if (!trackId || trackId === "")
      trackId = mediaTrack.id;
    if (participantId === this.localParticipant.sid) {
      livekitLogger.warn("tried to create RemoteParticipant for local participant");
      return;
    }
    const participant = this.getOrCreateParticipant(participantId);
    let adaptiveStreamSettings;
    if (this.options.adaptiveStream) {
      if (typeof this.options.adaptiveStream === "object") {
        adaptiveStreamSettings = this.options.adaptiveStream;
      } else {
        adaptiveStreamSettings = {};
      }
    }
    participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);
  }
  handleDisconnect() {
    let shouldStopTracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    let reason = arguments.length > 1 ? arguments[1] : void 0;
    var _a2;
    if (this.state === ConnectionState.Disconnected) {
      return;
    }
    this.participants.forEach((p) => {
      p.tracks.forEach((pub) => {
        p.unpublishTrack(pub.trackSid);
      });
    });
    this.localParticipant.tracks.forEach((pub) => {
      var _a3, _b;
      if (pub.track) {
        this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);
      }
      if (shouldStopTracks) {
        (_a3 = pub.track) === null || _a3 === void 0 ? void 0 : _a3.detach();
        (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();
      }
    });
    this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
    this.localParticipant.tracks.clear();
    this.localParticipant.videoTracks.clear();
    this.localParticipant.audioTracks.clear();
    this.participants.clear();
    this.activeSpeakers = [];
    if (this.audioContext && typeof this.options.expWebAudioMix === "boolean") {
      this.audioContext.close();
      this.audioContext = void 0;
    }
    if (isWeb()) {
      window.removeEventListener("beforeunload", this.onBeforeUnload);
      (_a2 = navigator.mediaDevices) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener("devicechange", this.handleDeviceChange);
    }
    this.setAndEmitConnectionState(ConnectionState.Disconnected);
    this.emit(RoomEvent.Disconnected, reason);
  }
  handleParticipantDisconnected(sid, participant) {
    this.participants.delete(sid);
    if (!participant) {
      return;
    }
    this.identityToSid.delete(participant.identity);
    participant.tracks.forEach((publication) => {
      participant.unpublishTrack(publication.trackSid, true);
    });
    this.emit(RoomEvent.ParticipantDisconnected, participant);
  }
  async acquireAudioContext() {
    var _a2, _b;
    if (typeof this.options.expWebAudioMix !== "boolean" && this.options.expWebAudioMix.audioContext) {
      this.audioContext = this.options.expWebAudioMix.audioContext;
      await this.audioContext.resume();
    } else {
      this.audioContext = (_a2 = getNewAudioContext()) !== null && _a2 !== void 0 ? _a2 : void 0;
    }
    if (this.options.expWebAudioMix) {
      this.participants.forEach((participant) => participant.setAudioContext(this.audioContext));
    }
    const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === "running";
    if (newContextIsRunning !== this.canPlaybackAudio) {
      this.audioEnabled = newContextIsRunning;
      this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);
    }
  }
  createParticipant(id, info) {
    let participant;
    if (info) {
      participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info);
    } else {
      participant = new RemoteParticipant(this.engine.client, id, "", void 0, void 0);
    }
    if (this.options.expWebAudioMix) {
      participant.setAudioContext(this.audioContext);
    }
    return participant;
  }
  getOrCreateParticipant(id, info) {
    if (this.participants.has(id)) {
      return this.participants.get(id);
    }
    const participant = this.createParticipant(id, info);
    this.participants.set(id, participant);
    if (info) {
      this.identityToSid.set(info.identity, info.sid);
      this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);
    }
    participant.on(ParticipantEvent.TrackPublished, (trackPublication) => {
      this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);
    }).on(ParticipantEvent.TrackSubscribed, (track, publication) => {
      if (track.kind === Track.Kind.Audio) {
        track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);
        track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);
      }
      this.emit(RoomEvent.TrackSubscribed, track, publication, participant);
    }).on(ParticipantEvent.TrackUnpublished, (publication) => {
      this.emit(RoomEvent.TrackUnpublished, publication, participant);
    }).on(ParticipantEvent.TrackUnsubscribed, (track, publication) => {
      this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);
    }).on(ParticipantEvent.TrackSubscriptionFailed, (sid) => {
      this.emit(RoomEvent.TrackSubscriptionFailed, sid, participant);
    }).on(ParticipantEvent.TrackMuted, (pub) => {
      this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);
    }).on(ParticipantEvent.TrackUnmuted, (pub) => {
      this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);
    }).on(ParticipantEvent.ParticipantMetadataChanged, (metadata) => {
      this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);
    }).on(ParticipantEvent.ConnectionQualityChanged, (quality) => {
      this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);
    }).on(ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions) => {
      this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);
    }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status) => {
      this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);
    }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status) => {
      this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);
    });
    if (info) {
      participant.updateInfo(info);
    }
    return participant;
  }
  sendSyncState() {
    var _a2, _b;
    if (this.engine.subscriber === void 0 || this.engine.subscriber.pc.localDescription === null) {
      return;
    }
    const previousAnswer = this.engine.subscriber.pc.localDescription;
    const previousOffer = this.engine.subscriber.pc.remoteDescription;
    const autoSubscribe = (_b = (_a2 = this.connOptions) === null || _a2 === void 0 ? void 0 : _a2.autoSubscribe) !== null && _b !== void 0 ? _b : true;
    const trackSids = new Array();
    this.participants.forEach((participant) => {
      participant.tracks.forEach((track) => {
        if (track.isDesired !== autoSubscribe) {
          trackSids.push(track.trackSid);
        }
      });
    });
    this.engine.client.sendSyncState({
      answer: toProtoSessionDescription({
        sdp: previousAnswer.sdp,
        type: previousAnswer.type
      }),
      offer: previousOffer ? toProtoSessionDescription({
        sdp: previousOffer.sdp,
        type: previousOffer.type
      }) : void 0,
      subscription: {
        trackSids,
        subscribe: !autoSubscribe,
        participantTracks: []
      },
      publishTracks: this.localParticipant.publishedTracksInfo(),
      dataChannels: this.localParticipant.dataChannelsInfo()
    });
  }
  updateSubscriptions() {
    for (const p of this.participants.values()) {
      for (const pub of p.videoTracks.values()) {
        if (pub.isSubscribed && pub instanceof RemoteTrackPublication) {
          pub.emitTrackUpdate();
        }
      }
    }
  }
  setAndEmitConnectionState(state2) {
    if (state2 === this.state) {
      return false;
    }
    this.state = state2;
    this.emit(RoomEvent.ConnectionStateChanged, this.state);
    return true;
  }
  emitWhenConnected(event2) {
    if (this.state === ConnectionState.Connected) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return this.emit(event2, ...args);
    }
    return false;
  }
  async simulateParticipants(options) {
    var _a2, _b;
    const publishOptions = _objectSpread2({
      audio: true,
      video: true,
      useRealTracks: false
    }, options.publish);
    const participantOptions = _objectSpread2({
      count: 9,
      audio: false,
      video: true,
      aspectRatios: [1.66, 1.7, 1.3]
    }, options.participants);
    this.handleDisconnect();
    this.name = "simulated-room";
    this.localParticipant.updateInfo(ParticipantInfo.fromPartial({
      identity: "simulated-local",
      name: "local-name"
    }));
    this.setupLocalParticipantEvents();
    this.emit(RoomEvent.SignalConnected);
    this.emit(RoomEvent.Connected);
    this.setAndEmitConnectionState(ConnectionState.Connected);
    if (publishOptions.video) {
      const camPub = new LocalTrackPublication(Track.Kind.Video, TrackInfo.fromPartial({
        source: TrackSource.CAMERA,
        sid: Math.floor(Math.random() * 1e4).toString(),
        type: TrackType.AUDIO,
        name: "video-dummy"
      }), new LocalVideoTrack(publishOptions.useRealTracks ? (await navigator.mediaDevices.getUserMedia({
        video: true
      })).getVideoTracks()[0] : createDummyVideoStreamTrack((_a2 = 160 * participantOptions.aspectRatios[0]) !== null && _a2 !== void 0 ? _a2 : 1, 160, true, true)));
      this.localParticipant.addTrackPublication(camPub);
      this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);
    }
    if (publishOptions.audio) {
      const audioPub = new LocalTrackPublication(Track.Kind.Audio, TrackInfo.fromPartial({
        source: TrackSource.MICROPHONE,
        sid: Math.floor(Math.random() * 1e4).toString(),
        type: TrackType.AUDIO
      }), new LocalAudioTrack(publishOptions.useRealTracks ? (await navigator.mediaDevices.getUserMedia({
        audio: true
      })).getAudioTracks()[0] : getEmptyAudioStreamTrack()));
      this.localParticipant.addTrackPublication(audioPub);
      this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);
    }
    for (let i2 = 0; i2 < participantOptions.count - 1; i2 += 1) {
      let info = ParticipantInfo.fromPartial({
        sid: Math.floor(Math.random() * 1e4).toString(),
        identity: "simulated-".concat(i2),
        state: ParticipantInfo_State.ACTIVE,
        tracks: [],
        joinedAt: Date.now()
      });
      const p = this.getOrCreateParticipant(info.identity, info);
      if (participantOptions.video) {
        const dummyVideo = createDummyVideoStreamTrack((_b = 160 * participantOptions.aspectRatios[i2 % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1, 160, false, true);
        const videoTrack = TrackInfo.fromPartial({
          source: TrackSource.CAMERA,
          sid: Math.floor(Math.random() * 1e4).toString(),
          type: TrackType.AUDIO
        });
        p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([dummyVideo]));
        info.tracks = [...info.tracks, videoTrack];
      }
      if (participantOptions.audio) {
        const dummyTrack = getEmptyAudioStreamTrack();
        const audioTrack = TrackInfo.fromPartial({
          source: TrackSource.MICROPHONE,
          sid: Math.floor(Math.random() * 1e4).toString(),
          type: TrackType.AUDIO
        });
        p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([dummyTrack]));
        info.tracks = [...info.tracks, audioTrack];
      }
      p.updateInfo(info);
    }
  }
  emit(event2) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    if (event2 !== RoomEvent.ActiveSpeakersChanged) {
      livekitLogger.debug("room event ".concat(event2), {
        event: event2,
        args
      });
    }
    return super.emit(event2, ...args);
  }
}
var CheckStatus;
(function(CheckStatus2) {
  CheckStatus2[CheckStatus2["IDLE"] = 0] = "IDLE";
  CheckStatus2[CheckStatus2["RUNNING"] = 1] = "RUNNING";
  CheckStatus2[CheckStatus2["SKIPPED"] = 2] = "SKIPPED";
  CheckStatus2[CheckStatus2["SUCCESS"] = 3] = "SUCCESS";
  CheckStatus2[CheckStatus2["FAILED"] = 4] = "FAILED";
})(CheckStatus || (CheckStatus = {}));
class Checker extends eventsExports.EventEmitter {
  constructor(url, token) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    super();
    this.status = CheckStatus.IDLE;
    this.logs = [];
    this.errorsAsWarnings = false;
    this.url = url;
    this.token = token;
    this.name = this.constructor.name;
    this.room = new Room(options.roomOptions);
    this.connectOptions = options.connectOptions;
    if (options.errorsAsWarnings) {
      this.errorsAsWarnings = options.errorsAsWarnings;
    }
  }
  async run(onComplete) {
    if (this.status !== CheckStatus.IDLE) {
      throw Error("check is running already");
    }
    this.setStatus(CheckStatus.RUNNING);
    this.appendMessage("".concat(this.name, " started."));
    try {
      await this.perform();
    } catch (err) {
      if (err instanceof Error) {
        if (this.errorsAsWarnings) {
          this.appendWarning(err.message);
        } else {
          this.appendError(err.message);
        }
      }
    }
    await this.disconnect();
    await new Promise((resolve) => setTimeout(resolve, 500));
    if (this.status !== CheckStatus.SKIPPED) {
      this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);
    }
    if (onComplete) {
      onComplete();
    }
    return this.getInfo();
  }
  isSuccess() {
    return !this.logs.some((l) => l.level === "error");
  }
  async connect() {
    if (this.room.state === ConnectionState.Connected) {
      return this.room;
    }
    await this.room.connect(this.url, this.token);
    return this.room;
  }
  async disconnect() {
    if (this.room && this.room.state !== ConnectionState.Disconnected) {
      await this.room.disconnect();
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
  }
  skip() {
    this.setStatus(CheckStatus.SKIPPED);
  }
  appendMessage(message) {
    this.logs.push({
      level: "info",
      message
    });
    this.emit("update", this.getInfo());
  }
  appendWarning(message) {
    this.logs.push({
      level: "warning",
      message
    });
    this.emit("update", this.getInfo());
  }
  appendError(message) {
    this.logs.push({
      level: "error",
      message
    });
    this.emit("update", this.getInfo());
  }
  setStatus(status) {
    this.status = status;
    this.emit("update", this.getInfo());
  }
  get engine() {
    var _a2;
    return (_a2 = this.room) === null || _a2 === void 0 ? void 0 : _a2.engine;
  }
  getInfo() {
    return {
      logs: this.logs,
      name: this.name,
      status: this.status,
      description: this.description
    };
  }
}
const Rendering = lib$2.LiveApiModel.Rendering;
const VideoRendering = lib$2.LiveApiModel.VideoRendering;
const AudioRendering = lib$2.LiveApiModel.AudioRendering;
const RenderingQuality = lib$2.LiveApiModel.RenderingQuality;
const Encoding = lib$2.LiveApiModel.Encoding;
const VideoEncoding = lib$2.LiveApiModel.VideoEncoding;
const AudioEncoding = lib$2.LiveApiModel.AudioEncoding;
const ProjectBroadcastPhase = lib$2.LiveApiModel.ProjectBroadcastPhase;
const Role = lib$2.LiveApiModel.Role;
const DestinationAddress = lib$2.LiveApiModel.DestinationAddress;
const VideoCodec = lib$2.LiveApiModel.VideoCodec;
const AudioCodec = lib$2.LiveApiModel.AudioCodec;
const VideoCodecRateControl = lib$2.LiveApiModel.VideoCodecRateControl;
const VideoCodecProfile = lib$2.LiveApiModel.VideoCodecProfile;
var types$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Rendering,
  VideoRendering,
  AudioRendering,
  RenderingQuality,
  Encoding,
  Role,
  DestinationAddress,
  VideoEncoding,
  AudioEncoding,
  VideoCodec,
  AudioCodec,
  VideoCodecRateControl,
  VideoCodecProfile,
  ProjectBroadcastPhase
}, Symbol.toStringTag, { value: "Module" }));
var Permission = /* @__PURE__ */ ((Permission2) => {
  Permission2[Permission2["ReadProject"] = 0] = "ReadProject";
  Permission2[Permission2["UpdateProject"] = 1] = "UpdateProject";
  Permission2[Permission2["JoinRoom"] = 2] = "JoinRoom";
  Permission2[Permission2["InviteGuests"] = 3] = "InviteGuests";
  Permission2[Permission2["ManageGuests"] = 4] = "ManageGuests";
  Permission2[Permission2["ManageBroadcast"] = 5] = "ManageBroadcast";
  Permission2[Permission2["ManageSelf"] = 6] = "ManageSelf";
  return Permission2;
})(Permission || {});
const permissions = {
  [Role.ROLE_HOST]: [
    0,
    1,
    2,
    3,
    4,
    5
  ],
  [Role.ROLE_COHOST]: [
    0,
    1,
    2,
    3,
    4,
    5
  ],
  [Role.ROLE_CONTRIBUTOR]: [
    0,
    1,
    2,
    3
  ],
  [Role.ROLE_GUEST]: [
    0,
    2,
    6
  ],
  [Role.ROLE_VIEWER]: [
    0,
    2
  ],
  [Role.ROLE_IMPERSONATE]: [
    0,
    1,
    3,
    4,
    5
  ]
};
const hasPermission = (role, permission) => {
  var _a2;
  return role ? Boolean((_a2 = permissions[role]) == null ? void 0 : _a2.find((x) => x === permission)) : false;
};
var DataType = /* @__PURE__ */ ((DataType2) => {
  DataType2["ChatMessage"] = "ChatMessage";
  DataType2["ParticipantMetadataUpdate"] = "ParticipantMetadataUpdate";
  return DataType2;
})(DataType || {});
var SpecialEvent = /* @__PURE__ */ ((SpecialEvent2) => {
  SpecialEvent2["Chat"] = "Chat";
  return SpecialEvent2;
})(SpecialEvent || {});
const decoder$1 = new TextDecoder();
const encoder$1 = new TextEncoder();
class RoomsManager {
  constructor() {
    this.rooms = /* @__PURE__ */ new Map();
    this.addRoom = this.addRoom.bind(this);
    this.ensureRoom = this.ensureRoom.bind(this);
    this.removeRoom = this.removeRoom.bind(this);
  }
  addRoom(baseUrl, roomName, token) {
    const roomContext = new RoomContext(baseUrl, roomName, token, this);
    this.rooms.set(roomName, roomContext);
    return roomContext;
  }
  ensureRoom(baseUrl, roomName, token) {
    if (this.rooms.get(roomName)) {
      this.rooms.get(roomName).token = token;
      return this.rooms.get(roomName);
    } else {
      return this.addRoom(baseUrl, roomName, token);
    }
  }
  async removeRoom(roomName) {
    const room = this.rooms.get(roomName);
    if (!Room) {
      throw new Error("room not found!");
    }
    if (room.isConnecting) {
      throw new Error("Cannot remove room: Room is in connecting state");
    }
    if (room.livekitRoom) {
      await room.livekitRoom.disconnect(true);
    }
    this.rooms.delete(roomName);
  }
}
class RoomContext {
  constructor(baseUrl, roomName, token, manager) {
    let logLevel = CoreContext.logLevel.toLowerCase();
    setLogLevel(logLevel);
    this.livekitRoom = new Room({
      dynacast: true,
      videoCaptureDefaults: {
        resolution: VideoPresets.h720.resolution
      }
    });
    this._baseUrl = baseUrl;
    this._connectListeners = [];
    this._roomEventListenerRegistry = {};
    this._jwt = token;
    Object.values(RoomEvent).forEach((value) => {
      this._roomEventListenerRegistry[value] = /* @__PURE__ */ new Set();
    });
    this._localParticipantEventListenerRegistry = {};
    Object.values(ParticipantEvent).forEach((value) => {
      this._localParticipantEventListenerRegistry[value] = /* @__PURE__ */ new Set();
    });
    this._specialEventListenerRegistry = {};
    this._manager = manager;
    this._chatHistory = [];
    this.roomName = roomName;
    this.audioTracks = [];
    this.participants = [];
    this.guestParticipantMetadata = [];
    this.isConnecting = false;
    this.subscribeToRoomEvent(RoomEvent.DataReceived, (payload, participant, kind) => {
      var _a2;
      const strData = decoder$1.decode(payload);
      const data2 = JSON.parse(strData);
      switch (data2.type) {
        case "ChatMessage": {
          return this._appendChat(payload, participant, kind);
        }
        case "ParticipantMetadataUpdate": {
          const strData2 = decoder$1.decode(payload);
          const data22 = JSON.parse(strData2);
          if (hasPermission((_a2 = data22 == null ? void 0 : data22.metadata) == null ? void 0 : _a2.participantRole, Permission.ManageSelf)) {
            this._updateGuestParticipantsStore(data22);
          }
          return;
        }
        default:
          return;
      }
    });
    this.connect = this.connect.bind(this);
    this.subscribeToRoomEvent = this.subscribeToRoomEvent.bind(this);
    this.subscribeToConnect = this.subscribeToConnect.bind(this);
    this.subscribeToLocalParticipantEvent = this.subscribeToLocalParticipantEvent.bind(this);
    this.subscribeToSpecialEvent = this.subscribeToSpecialEvent.bind(this);
    this.unsubscribeFromRoomEvent = this.unsubscribeFromRoomEvent.bind(this);
    this.unsubscribeFromSpecialEvent = this.unsubscribeFromSpecialEvent.bind(this);
    this.unsubscribeFromConnect = this.unsubscribeFromConnect.bind(this);
    this.unsubscribeFromLocalParticipantEvent = this.unsubscribeFromLocalParticipantEvent.bind(this);
    this.sendChatMessage = this.sendChatMessage.bind(this);
    this.kickParticipant = this.kickParticipant.bind(this);
    this.updateParticipant = this.updateParticipant.bind(this);
    this.muteTrackAsAdmin = this.muteTrackAsAdmin.bind(this);
    this._updateParticipants = this._updateParticipants.bind(this);
    this.subscribeToRoomEvent(RoomEvent.ParticipantConnected, this._updateParticipants);
    this.subscribeToRoomEvent(RoomEvent.ParticipantDisconnected, this._updateParticipants);
    this.subscribeToRoomEvent(RoomEvent.TrackSubscribed, this._updateParticipants);
    this.subscribeToRoomEvent(RoomEvent.TrackUnsubscribed, this._updateParticipants);
    this.subscribeToRoomEvent(RoomEvent.LocalTrackPublished, this._updateParticipants);
    this.subscribeToRoomEvent(RoomEvent.LocalTrackUnpublished, this._updateParticipants);
    this.subscribeToRoomEvent(RoomEvent.Disconnected, () => {
      this._updateParticipants();
    });
    this.subscribeToRoomEvent(RoomEvent.ParticipantMetadataChanged, (metadata, participant) => {
      if (metadata !== (participant == null ? void 0 : participant.metadata)) {
        const meta = JSON.parse(participant == null ? void 0 : participant.metadata);
        if (hasPermission(meta == null ? void 0 : meta.participantRole, Permission.ManageSelf)) {
          if (meta.hasOwnProperty("isMirrored")) {
            const data2 = {
              participantId: participant == null ? void 0 : participant.identity,
              metadata: meta,
              type: "ParticipantMetadataUpdate"
            };
            this._updateGuestParticipantsStore(data2);
          }
          return;
        }
      }
    });
  }
  bindApiClient(client) {
    this._apiClient = client;
  }
  get isAdmin() {
    const tokenData = o(this._jwt);
    return tokenData.video.roomAdmin;
  }
  set isAdmin(value) {
    log$1.warn("isAdmin cannot be set");
  }
  get token() {
    return this._jwt;
  }
  set token(value) {
    this._jwt = value;
  }
  get url() {
    return this._baseUrl;
  }
  set url(value) {
  }
  get chatHistory() {
    return this._chatHistory;
  }
  set chatHistory(value) {
    this._chatHistory = value;
  }
  _updateGuestParticipantsStore(data2) {
    if (!this.guestParticipantMetadata.length) {
      this.guestParticipantMetadata.push(data2);
    } else {
      const existingGuestIndex = this.guestParticipantMetadata.findIndex((g) => g.participantId === (data2 == null ? void 0 : data2.participantId));
      if (existingGuestIndex > -1) {
        this.guestParticipantMetadata[existingGuestIndex] = data2;
      } else {
        this.guestParticipantMetadata.push(data2);
      }
    }
  }
  _updateParticipants() {
    if (!this.livekitRoom || this.livekitRoom.state === ConnectionState.Disconnected) {
      this.participants = [];
      return;
    } else {
      const remotes = Array.from(this.livekitRoom.participants.values());
      const parts = [this.livekitRoom.localParticipant];
      parts.push(...remotes);
      this.guestParticipantMetadata = this.guestParticipantMetadata.filter((gp) => parts.find((p) => (p == null ? void 0 : p.identity) === (gp == null ? void 0 : gp.participantId)));
      this.participants = parts;
    }
  }
  async kickParticipant(identity2) {
    if (this._admin) {
      this._admin.removeParticipant(this.roomName, identity2);
    } else {
      throw new Error("no admin permissions");
    }
  }
  updateParticipant(identity2, metadata) {
    if (this._admin) {
      const data2 = JSON.stringify(metadata);
      this._admin.updateParticipant(this.roomName, identity2, data2);
    } else {
      throw new Error("no admin permissions");
    }
  }
  muteTrackAsAdmin(trackSid, mute = true) {
    if (this._admin) {
      const participant = this.participants.find((p) => [...p.audioTracks.values(), ...p.videoTracks.values()].find((pub) => pub.trackSid === trackSid));
      if (!participant) {
        log$1.warn("Could not find participant for track:", {
          trackSid
        });
        return;
      }
      this._admin.mutePublishedTrack(this.roomName, participant == null ? void 0 : participant.identity, trackSid, mute);
    } else {
      throw new Error("no admin permissions");
    }
  }
  _appendChat(payload, participant, kind) {
    const strData = decoder$1.decode(payload);
    const data2 = JSON.parse(strData);
    const sender = participant.identity;
    const displayName = participant.name;
    const fullData = {
      ...data2,
      displayName,
      sender
    };
    this.chatHistory = [...this.chatHistory, fullData];
    this._triggerSpecialEvents("Chat", fullData);
  }
  subscribeToConnect(listener) {
    this._connectListeners.push(listener);
    return () => this.unsubscribeFromConnect(listener);
  }
  unsubscribeFromConnect(listener) {
    this._connectListeners = this._connectListeners.filter((cb) => cb !== listener);
  }
  subscribeToSpecialEvent(evt, listener) {
    if (!this._specialEventListenerRegistry[evt]) {
      this._specialEventListenerRegistry[evt] = /* @__PURE__ */ new Set();
    }
    this._specialEventListenerRegistry[evt].add(listener);
    return () => {
      this.unsubscribeFromSpecialEvent(evt, listener);
    };
  }
  unsubscribeFromSpecialEvent(evt, listener) {
    if (!this._specialEventListenerRegistry[evt]) {
      this._specialEventListenerRegistry[evt] = /* @__PURE__ */ new Set();
    }
    this._specialEventListenerRegistry[evt].delete(listener);
  }
  _triggerSpecialEvents(evt, ...args) {
    if (!this._specialEventListenerRegistry[evt]) {
      this._specialEventListenerRegistry[evt] = /* @__PURE__ */ new Set();
    }
    this._specialEventListenerRegistry[evt].forEach((listener) => {
      listener(...args);
    });
  }
  async connect(options = {}) {
    var _a2, _b;
    try {
      if (this.livekitRoom.state === "connected")
        return;
      if (this.isConnecting)
        return;
      this.isConnecting = true;
      await this.livekitRoom.connect(`wss://${this._baseUrl}`, this._jwt, {
        ...options
      });
      this.isConnecting = false;
      Object.values(RoomEvent).forEach((eventName) => {
        this.livekitRoom.on(eventName, (...args) => {
          this._roomEventListenerRegistry[eventName].forEach((cb) => {
            cb(...args);
          });
        });
      });
      Object.values(ParticipantEvent).forEach((eventName) => {
        this.livekitRoom.localParticipant.on(eventName, (...args) => {
          this._localParticipantEventListenerRegistry[eventName].forEach((cb) => {
            cb(...args);
          });
        });
      });
      this._updateParticipants();
      this._connectListeners.forEach((cb) => cb(this.livekitRoom));
      if (lib$2.LiveKitUtils.isRoomAdmin(this._jwt)) {
        log$1.info("Room: Granting admin permissions");
        log$1.debug("Livekit server: ", (_a2 = this._apiClient) == null ? void 0 : _a2.getLiveKitServer(true));
        this._admin = new dist.RoomServiceClient((_b = this._apiClient) == null ? void 0 : _b.getLiveKitServer(true), void 0, void 0, this._jwt);
      } else {
        log$1.debug("Room: Not an admin");
      }
    } catch (err) {
      this.isConnecting = false;
      log$1.error(err);
    }
  }
  subscribeToLocalParticipantEvent(evt, listener) {
    if (!this._localParticipantEventListenerRegistry[evt]) {
      this._localParticipantEventListenerRegistry[evt] = /* @__PURE__ */ new Set();
    }
    this._localParticipantEventListenerRegistry[evt].add(listener);
    return () => {
      this.unsubscribeFromLocalParticipantEvent(evt, listener);
    };
  }
  unsubscribeFromLocalParticipantEvent(evt, listener) {
    if (!this._localParticipantEventListenerRegistry[evt]) {
      this._localParticipantEventListenerRegistry[evt] = /* @__PURE__ */ new Set();
    }
    this._localParticipantEventListenerRegistry[evt].delete(listener);
  }
  subscribeToRoomEvent(evt, listener) {
    if (!this._roomEventListenerRegistry[evt]) {
      this._roomEventListenerRegistry[evt] = /* @__PURE__ */ new Set();
    }
    this._roomEventListenerRegistry[evt].add(listener);
    return () => {
      this.unsubscribeFromRoomEvent(evt, listener);
    };
  }
  unsubscribeFromRoomEvent(evt, listener) {
    if (!this._roomEventListenerRegistry[evt]) {
      this._roomEventListenerRegistry[evt] = /* @__PURE__ */ new Set();
    }
    this._roomEventListenerRegistry[evt].delete(listener);
  }
  sendChatMessage(data2) {
    const {
      message,
      recipients,
      metadata
    } = data2;
    if (!this.livekitRoom || this.livekitRoom.state !== "connected") {
      return;
    }
    const messageObject = {
      type: "ChatMessage",
      recipients,
      metadata,
      content: message,
      timestamp: Date.now()
    };
    const strData = JSON.stringify(messageObject);
    const encodedData = encoder$1.encode(strData);
    ({
      ...messageObject,
      sender: this.livekitRoom.localParticipant.identity,
      displayName: this.livekitRoom.localParticipant.identity
    });
    if (Boolean(recipients)) {
      const participants = recipients.map(this.livekitRoom.getParticipantByIdentity);
      return this.livekitRoom.localParticipant.publishData(encodedData, DataPacket_Kind.RELIABLE, participants).then(() => {
        this._appendChat(encodedData, this.livekitRoom.localParticipant, DataPacket_Kind.RELIABLE);
      });
    } else {
      return this.livekitRoom.localParticipant.publishData(encodedData, DataPacket_Kind.RELIABLE).then(() => {
        this._appendChat(encodedData, this.livekitRoom.localParticipant, DataPacket_Kind.RELIABLE);
      });
    }
  }
}
const webrtcManager = new RoomsManager();
var index$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  webrtcManager
}, Symbol.toStringTag, { value: "Module" }));
const encoder = new TextEncoder();
const decoder = new TextDecoder();
const simpleRooms = /* @__PURE__ */ new Map();
const getRoom = (id) => {
  if (!id)
    return null;
  if (simpleRooms.get(id))
    return simpleRooms.get(id);
  const room = webrtcManager.rooms.get(id);
  if (!room)
    return null;
  const livekit2 = room.livekitRoom;
  const localParticipant = livekit2 == null ? void 0 : livekit2.localParticipant;
  window.__StudioRoom = livekit2;
  if (!localParticipant)
    log$1.warn("No local participant!");
  const listeners2 = {
    useTracks: /* @__PURE__ */ new Set(),
    useTrack: /* @__PURE__ */ new Map(),
    useParticipants: /* @__PURE__ */ new Set(),
    useParticipant: /* @__PURE__ */ new Map(),
    useChatHistory: /* @__PURE__ */ new Set()
  };
  let latest = {
    tracks: [],
    participants: [],
    result: {
      participants: [],
      tracks: []
    },
    chat: room.chatHistory
  };
  const update = () => {
    const participants = room.participants;
    const guestParticipantMetadata = room.guestParticipantMetadata;
    const tracks = participants.flatMap((participant) => participant.getTracks().map((pub) => ({
      ...pub,
      participant
    })));
    const result = {
      participants: participants.map((x) => {
        const existingGuestParticipantMetadata = guestParticipantMetadata.find((g) => g.participantId === x.identity);
        if (existingGuestParticipantMetadata) {
          let participantMetadataJson = JSON.parse(x.metadata);
          participantMetadataJson = {
            ...participantMetadataJson,
            ...existingGuestParticipantMetadata.metadata
          };
          x.metadata = JSON.stringify(participantMetadataJson);
        }
        const meta = JSON.parse(x.metadata);
        return {
          id: x.identity,
          isSelf: x === localParticipant,
          connectionQuality: x.connectionQuality,
          displayName: meta.displayName || x.name,
          joinedAt: x.joinedAt,
          role: meta.participantRole,
          meta,
          trackIds: tracks.filter((p) => p.participant.sid === x.sid).map((x2) => x2.trackSid)
        };
      }),
      tracks: tracks.map((x) => {
        var _a2, _b, _c, _d;
        const meta = JSON.parse((_a2 = x == null ? void 0 : x.participant) == null ? void 0 : _a2.metadata);
        return {
          mediaStreamTrack: (_b = x.track) == null ? void 0 : _b.mediaStreamTrack,
          id: x.trackSid,
          participantId: (_c = x.participant) == null ? void 0 : _c.identity,
          isMuted: (_d = x.track) == null ? void 0 : _d.isMuted,
          type: x.source,
          isExternal: Boolean(meta == null ? void 0 : meta[x.trackSid])
        };
      })
    };
    latest = {
      tracks,
      participants,
      result,
      chat: room.chatHistory
    };
    listeners2.useTracks.forEach((cb) => cb(result.tracks));
    listeners2.useTrack.forEach((id2, cb) => {
      cb(getTrack(id2));
    });
    listeners2.useParticipants.forEach((cb) => cb(result.participants));
    listeners2.useParticipant.forEach((id2, cb) => {
      cb(getParticipant(id2));
    });
    listeners2.useChatHistory.forEach((cb) => {
      cb(latest.chat);
    });
  };
  const updateEvents = [RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ParticipantMetadataChanged, RoomEvent.Disconnected, RoomEvent.TrackSubscribed, RoomEvent.TrackUnsubscribed, RoomEvent.LocalTrackPublished, RoomEvent.LocalTrackUnpublished, RoomEvent.ConnectionQualityChanged, RoomEvent.TrackMuted, RoomEvent.TrackUnmuted, RoomEvent.TrackStreamStateChanged];
  room.subscribeToRoomEvent(RoomEvent.DataReceived, (payload, participant, kind) => {
    const strData = decoder.decode(payload);
    const data2 = JSON.parse(strData);
    if (data2.type === DataType.ParticipantMetadataUpdate) {
      update();
    }
  });
  const unsubscribers = updateEvents.map((evt) => room.subscribeToRoomEvent(evt, () => update()));
  unsubscribers.push(room.subscribeToSpecialEvent(SpecialEvent.Chat, update));
  const getTrack = (id2) => {
    return latest.result.tracks.find((x) => x.id === id2);
  };
  const getParticipant = (id2) => {
    return latest.result.participants.find((x) => x.id === id2);
  };
  const setTrackEnabled = (id2, enabled) => {
    const track = localParticipant.getTracks().find((x) => {
      return x.trackSid === id2;
    });
    if (track) {
      if (enabled) {
        track.mute();
      } else {
        track.unmute();
      }
    }
  };
  let settingCamera;
  let settingMic;
  const simpleRoom = {
    id: room.roomName,
    participantId: localParticipant.identity,
    setTrackEnabled,
    setCameraEnabled: (enabled = true) => {
      return localParticipant.setCameraEnabled(enabled);
    },
    setMicrophoneEnabled: (enabled = true) => {
      return localParticipant.setMicrophoneEnabled(enabled);
    },
    setCamera: async (options = {}) => {
      var _a2;
      if (settingCamera) {
        log$1.warn("Cannot set camera until previous has resolved");
        return;
      }
      settingCamera = true;
      let published;
      try {
        const existingWebcams = localParticipant.getTracks().filter((x) => {
          return (x == null ? void 0 : x.source) === Track.Source.Camera;
        });
        const existingPrimaryWebCam = existingWebcams.find((x) => {
          const track = getTrack(x == null ? void 0 : x.trackSid);
          return !track.isExternal;
        });
        const tracks = await localParticipant.createTracks({
          video: {
            deviceId: options.deviceId,
            resolution: options.resolution || {
              width: 1280,
              height: 720,
              frameRate: 30,
              aspectRatio: 16 / 9
            }
          }
        });
        if (existingPrimaryWebCam == null ? void 0 : existingPrimaryWebCam.isMuted) {
          tracks.forEach((x) => {
            x.mute();
          });
        }
        published = await Promise.all(tracks.map((x) => localParticipant.publishTrack(x)));
        if (existingPrimaryWebCam) {
          localParticipant.unpublishTrack(existingPrimaryWebCam.track);
        }
      } catch (e2) {
        throw e2;
      } finally {
        settingCamera = false;
        return getTrack((_a2 = published[0]) == null ? void 0 : _a2.trackSid);
      }
    },
    setMicrophone: async (options) => {
      var _a2;
      if (settingMic) {
        log$1.warn("Cannot set microphone until previous has resolved");
        return;
      }
      settingMic = true;
      let published;
      try {
        const existingMicroPhones = localParticipant.getTracks().filter((x) => {
          return x.source === Track.Source.Microphone;
        });
        const existingPrimaryMicrophone = existingMicroPhones.find((x) => {
          const track = getTrack(x == null ? void 0 : x.trackSid);
          return !track.isExternal;
        });
        const tracks = await localParticipant.createTracks({
          audio: options || true
        });
        if (existingPrimaryMicrophone == null ? void 0 : existingPrimaryMicrophone.isMuted) {
          tracks.forEach((x) => {
            x.mute();
          });
        }
        published = await Promise.all(tracks.map((x) => localParticipant.publishTrack(x)));
        if (existingPrimaryMicrophone) {
          localParticipant.unpublishTrack(existingPrimaryMicrophone.track);
        }
      } catch (e2) {
        throw e2;
      } finally {
        settingMic = false;
        return getTrack((_a2 = published[0]) == null ? void 0 : _a2.trackSid);
      }
    },
    addMicrophone: async (options) => {
      var _a2;
      if (settingMic) {
        log$1.warn("Cannot set microphone until previous has resolved");
        return;
      }
      settingMic = true;
      const tracks = await localParticipant.createTracks({
        audio: options || true
      });
      const audioTracks = localParticipant.getTracks().filter((track) => {
        return track.source === Track.Source.Microphone;
      });
      const inUseTrack = audioTracks.find((x) => {
        var _a3, _b;
        const track = getTrack(x == null ? void 0 : x.trackSid);
        ((_b = (_a3 = track == null ? void 0 : track.mediaStreamTrack) == null ? void 0 : _a3.getSettings()) == null ? void 0 : _b.deviceId) === options.deviceId && (track == null ? void 0 : track.isExternal);
      });
      if (inUseTrack == null ? void 0 : inUseTrack.isMuted) {
        tracks.forEach((x) => {
          x.mute();
        });
      }
      const published = await Promise.all(tracks.map((x) => localParticipant.publishTrack(x)));
      if (inUseTrack) {
        localParticipant.unpublishTrack(inUseTrack.track);
      }
      settingMic = false;
      return getTrack((_a2 = published[0]) == null ? void 0 : _a2.trackSid);
    },
    addCamera: async (options = {}) => {
      var _a2;
      const tracks = await localParticipant.createTracks({
        video: {
          deviceId: options.deviceId,
          resolution: options.resolution || {
            width: 1280,
            height: 720,
            frameRate: 30,
            aspectRatio: 16 / 9
          }
        }
      });
      const inUseTrack = localParticipant.getTracks().find((x) => {
        var _a3, _b, _c;
        return (x == null ? void 0 : x.source) === Track.Source.Camera && ((_c = (_b = (_a3 = x == null ? void 0 : x.track) == null ? void 0 : _a3.mediaStreamTrack) == null ? void 0 : _b.getSettings()) == null ? void 0 : _c.deviceId) === options.deviceId;
      });
      if (inUseTrack == null ? void 0 : inUseTrack.isMuted) {
        tracks.forEach((x) => {
          x.mute();
        });
      }
      const published = await Promise.all(tracks.map((x) => localParticipant.publishTrack(x)));
      if (inUseTrack) {
        localParticipant.unpublishTrack(inUseTrack.track);
      }
      settingMic = false;
      return getTrack((_a2 = published[0]) == null ? void 0 : _a2.trackSid);
    },
    addScreen: async (options = {
      audio: false
    }) => {
      const tracks = await localParticipant.createScreenTracks(options);
      const published = await Promise.all(tracks.map((x) => localParticipant.publishTrack(x)));
      const screen = published.find((x) => x.kind === "video");
      const audio = published.find((x) => x.kind === "audio");
      return {
        screen: getTrack(screen == null ? void 0 : screen.trackSid),
        audio: getTrack(audio == null ? void 0 : audio.trackSid)
      };
    },
    removeTrack: async (id2) => {
      const track = latest.tracks.find((x) => x.trackSid === id2);
      localParticipant.unpublishTrack(track.track);
    },
    setLocalParticipantMetadata: async (id2, meta) => {
      const data2 = JSON.stringify(meta);
      const encoded = encoder.encode(JSON.stringify({
        metadata: meta,
        type: DataType.ParticipantMetadataUpdate,
        participantId: id2
      }));
      localParticipant.setMetadata(data2);
      return await localParticipant.publishData(encoded, DataPacket_Kind.RELIABLE);
    },
    setParticipantMetadata: (id2, meta) => {
      return room.updateParticipant(id2, meta);
    },
    kickParticipant: room.kickParticipant,
    muteTrackAsAdmin: room.muteTrackAsAdmin,
    sendChatMessage: room.sendChatMessage,
    getTracks: () => latest.result.tracks,
    useTracks: (cb) => {
      listeners2.useTracks.add(cb);
      cb(latest.result.tracks);
      return () => {
        listeners2.useTracks.delete(cb);
      };
    },
    getTrack,
    useTrack: (id2, cb) => {
      listeners2.useTrack.set(cb, id2);
      cb(getTrack(id2));
      return () => {
        listeners2.useTrack.delete(cb);
      };
    },
    getParticipant,
    getParticipants: () => latest.result.participants,
    useParticipants: (cb) => {
      listeners2.useParticipants.add(cb);
      cb(latest.result.participants);
      return () => {
        listeners2.useParticipants.delete(cb);
      };
    },
    useParticipant: (id2, cb) => {
      listeners2.useParticipant.set(cb, id2);
      cb(getParticipant(id2));
      return () => {
        listeners2.useTrack.delete(cb);
      };
    },
    useChatHistory: (cb) => {
      listeners2.useChatHistory.add(cb);
      cb(latest.chat);
      return () => {
        listeners2.useChatHistory.delete(cb);
      };
    },
    useActiveSpeakers: (cb) => {
      var _a2, _b;
      const fn = (activeSpeakers) => {
        cb(activeSpeakers.map((x) => x.identity));
      };
      (_a2 = room.livekitRoom) == null ? void 0 : _a2.on(RoomEvent.ActiveSpeakersChanged, fn);
      fn((_b = room.livekitRoom) == null ? void 0 : _b.activeSpeakers);
      return () => {
        var _a3;
        (_a3 = room.livekitRoom) == null ? void 0 : _a3.off(RoomEvent.ActiveSpeakersChanged, fn);
      };
    },
    sendData: (data2, recipientIds) => {
      const encoded = encoder.encode(JSON.stringify(data2));
      const participants = recipientIds == null ? void 0 : recipientIds.map((x) => {
        var _a2, _b;
        return (_b = (_a2 = room.livekitRoom) == null ? void 0 : _a2.getParticipantByIdentity(x)) == null ? void 0 : _b.sid;
      }).filter(Boolean);
      return localParticipant.publishData(encoded, DataPacket_Kind.RELIABLE, participants);
    },
    onData: (cb) => {
      var _a2;
      const fn = (encoded, participant) => {
        const data2 = JSON.parse(decoder.decode(encoded));
        cb(data2, participant == null ? void 0 : participant.identity);
      };
      (_a2 = room.livekitRoom) == null ? void 0 : _a2.on(RoomEvent.DataReceived, fn);
      return () => {
        var _a3;
        (_a3 = room.livekitRoom) == null ? void 0 : _a3.off(RoomEvent.DataReceived, fn);
      };
    },
    connect: () => {
      return room.connect();
    },
    disconnect: () => {
      var _a2;
      return (_a2 = room.livekitRoom) == null ? void 0 : _a2.disconnect();
    },
    onDisconnected: (cb) => {
      var _a2;
      (_a2 = room.livekitRoom) == null ? void 0 : _a2.on(RoomEvent.Disconnected, cb);
      return () => {
        var _a3;
        (_a3 = room.livekitRoom) == null ? void 0 : _a3.off(RoomEvent.DataReceived, cb);
      };
    },
    setAudioOutput: (deviceId) => {
      var _a2;
      return (_a2 = room.livekitRoom) == null ? void 0 : _a2.switchActiveDevice("audiooutput", deviceId);
    }
  };
  update();
  simpleRooms.set(id, simpleRoom);
  return simpleRoom;
};
const {
  state: state$2
} = CoreContext;
const getAccessTokenData = () => {
  var _a2;
  return ((_a2 = CoreContext.clients.accessTokenClaims) == null ? void 0 : _a2.user) || {};
};
const getBaseUser = () => {
  if (!state$2.user)
    return null;
  return {
    id: state$2.user.id,
    props: state$2.user.props,
    name: state$2.user.name,
    projects: state$2.projects.map(toBaseProject),
    sources: state$2.sources.map(toBaseSource)
  };
};
const toBaseProject = (project) => {
  const {
    compositor: compositor2,
    videoApi,
    props = {},
    role
  } = project;
  const {
    destinations,
    encoding,
    rendering,
    sources: sources2
  } = videoApi.project;
  const scene = {
    get: compositor2.get,
    getRoot: compositor2.getRoot,
    getParent: compositor2.getParent
  };
  Object.defineProperty(scene, "nodes", {
    get() {
      return compositor2.nodes.filter((x) => !x._deleted);
    }
  });
  const broadcastPhase = project.videoApi.phase;
  const broadcastId = project.videoApi.broadcastId || null;
  return {
    broadcastPhase,
    role,
    broadcastId,
    isLive: [ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING, ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STOPPING].includes(broadcastPhase),
    scene,
    joinRoom: async (settings = {}) => {
      return CoreContext.Command.joinRoom({
        projectId: project.id,
        ...settings
      });
    },
    subscribe: (cb) => CoreContext.subscribe((event2, payload) => {
      if (payload.projectId && (payload == null ? void 0 : payload.projectId) === project.id) {
        cb(event2, payload);
      }
    }),
    ...{
      destinations: destinations.map(toBaseDestination),
      sources: sources2.map(toBaseSource),
      encoding,
      rendering
    },
    id: project.id,
    hostDisplayName: project.props.hostDisplayName,
    props
  };
};
const toBaseDestination = (destination) => {
  var _a2;
  return {
    id: destination.destinationId,
    enabled: destination.enabled,
    address: destination.address,
    props: ((_a2 = destination.metadata) == null ? void 0 : _a2.props) || (destination == null ? void 0 : destination.metadata) || {}
  };
};
const toBaseSource = (source2) => {
  var _a2;
  return {
    id: source2.sourceId,
    address: source2.address,
    props: ((_a2 = source2.metadata) == null ? void 0 : _a2.props) || {}
  };
};
const hydrateProject = async (project, role, size) => {
  const metadata = project.metadata || {};
  const updateRequest = {
    collectionId: project.collectionId,
    projectId: project.projectId,
    updateMask: []
  };
  const canBroadcast = hasPermission(role, Permission.ManageBroadcast);
  if (canBroadcast && project.composition.studioSdk.version !== CoreContext.rendererVersion) {
    updateRequest.composition = {
      studioSdk: {
        version: CoreContext.rendererVersion
      }
    };
    updateRequest.updateMask.push("composition.studioSdk.version");
  }
  if (size) {
    updateRequest.rendering = {
      video: {
        width: size.x,
        height: size.y,
        framerate: 30
      }
    };
    updateRequest.updateMask.push("rendering");
  }
  if (updateRequest.updateMask.length) {
    await CoreContext.clients.LiveApi().project.updateProject(updateRequest);
  }
  const compositorProject = await layoutToProject(metadata.layoutId, size);
  return {
    id: project.projectId,
    compositor: compositorProject,
    role,
    videoApi: {
      project,
      phase: ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_UNSPECIFIED
    },
    layoutApi: {
      layoutId: metadata.layoutId
    },
    props: (metadata == null ? void 0 : metadata.props) || metadata
  };
};
const sceneNodeToLayer = (node) => {
  const {
    id,
    props = {},
    children = []
  } = node;
  return {
    ...id ? {
      id
    } : {},
    type: props.type,
    data: {
      ...props
    },
    children: children.map((x) => x.id)
  };
};
const nodeToLayer = (node) => {
  return {
    id: node.id,
    type: node.props.type,
    data: {
      ...node.props
    },
    children: node.childIds.map((x) => x)
  };
};
const layerToNode = (layer) => {
  return {
    id: String(layer.id),
    props: {
      type: layer.type,
      ...layer.data
    },
    childIds: layer.children.map((x) => String(x))
  };
};
const layoutToProject = async (layoutId, size) => {
  const {
    layers
  } = await CoreContext.clients.LayoutApi().layer.listLayers({
    layoutId
  });
  if (size && layers) {
    const {
      x,
      y
    } = size;
    const rootLayer = layers == null ? void 0 : layers.reduce((acc, x2) => {
      if (!acc)
        return x2;
      if (acc.data.isRoot)
        return acc;
      if (x2.data.isRoot)
        return x2;
      if (!layers.some((y2) => y2.children.includes(x2.id)))
        return x2;
      return acc;
    }, null);
    if (rootLayer) {
      const layer = await CoreContext.clients.LayoutApi().layer.updateLayer({
        layoutId: rootLayer.layoutId,
        layerId: rootLayer.id,
        layer: {
          x,
          y,
          data: {
            ...rootLayer.data,
            size: {
              x,
              y
            }
          }
        }
      });
      const layerIndex = layers.findIndex((l) => l.id === layer.id);
      layers[layerIndex] = layer;
    }
  }
  const dataNodes = layers.map(layerToNode);
  const rootNode = dataNodes.reduce((acc, x) => {
    if (!acc)
      return x;
    if (acc.props.isRoot)
      return acc;
    if (x.props.isRoot)
      return x;
    if (!dataNodes.some((y) => y.childIds.includes(x.id)))
      return x;
    return acc;
  }, null);
  const tree = rootNode ? toSceneTree(dataNodes, rootNode.id) : null;
  return CoreContext.compositor.loadProject(tree, layoutId);
};
const getUser = () => {
  const user = state$2.user;
  if (!user) {
    throw new Error("User not loaded");
  }
  return user;
};
const getProject = (id) => {
  return state$2.projects.find((x) => x.id === id);
};
const getProjectByLayoutId = (id) => {
  return state$2.projects.find((x) => x.compositor.id === id);
};
const getProjectRoom = (id) => {
  var _a2;
  return getRoom((_a2 = getProject(id)) == null ? void 0 : _a2.roomId);
};
const {
  connectionId
} = CoreContext;
const latestUpdateVersion = {};
const getNextNodeVersion = (id) => {
  if (!latestUpdateVersion[id])
    latestUpdateVersion[id] = 0;
  return ++latestUpdateVersion[id];
};
const request = (layoutId, actions) => {
  const layers = actions.map((action) => {
    const [type, layer] = action;
    return {
      [type]: layer
    };
  });
  log$1.debug("Batch request", layers);
  return CoreContext.clients.LayoutApi().layer.batch({
    layoutId,
    layers,
    requestMetadata: {
      connectionId,
      layoutId,
      updateVersions: actions.filter(([type]) => type === "update").map(([_, layer]) => ({
        [layer.id]: getNextNodeVersion(layer.id)
      })).reduce((x, acc) => ({
        ...acc,
        ...x
      }), {})
    }
  });
};
const compositorAdapter = (layoutId, methods) => ({
  async insert(props = {}, parentId, index2) {
    const layer = nodeToLayer({
      id: null,
      props,
      childIds: []
    });
    if (!parentId) {
      layer.type = "root";
    } else {
      layer.type = "child";
    }
    log$1.debug("Insert layer", layer);
    const result = await CoreContext.clients.LayoutApi().layer.createLayer({
      layoutId,
      layer: {
        ...layer,
        requestMetadata: {
          connectionId,
          layoutId
        }
      }
    });
    if (result.code)
      throw new Error(result.message);
    const parentNode = await methods.get(parentId);
    if (parentId && !parentNode)
      throw Error("Parent not found with ID");
    if (parentNode) {
      const parent2 = nodeToLayer(parentNode);
      const children = insertAt$1(index2, result.id, parent2.children);
      const update = {
        layoutId,
        layerId: parent2.id,
        layer: {
          children,
          requestMetadata: {
            connectionId,
            layoutId,
            updateVersion: {
              [layer.id]: getNextNodeVersion(layer.id)
            }
          }
        }
      };
      await CoreContext.clients.LayoutApi().layer.updateLayer(update);
    }
    return String(result.id);
  },
  async update(id, props = {}) {
    const node = methods.get(id);
    const layer = nodeToLayer({
      ...node,
      props: {
        ...node.props,
        ...props
      }
    });
    const update = {
      layoutId,
      layerId: layer.id,
      layer: {
        ...layer,
        requestMetadata: {
          connectionId,
          layoutId,
          updateVersions: {
            [layer.id]: getNextNodeVersion(layer.id)
          }
        }
      }
    };
    log$1.debug("Update layer", update);
    await CoreContext.clients.LayoutApi().layer.updateLayer(update);
  },
  async remove(id) {
    const parentNode = await methods.getParent(id);
    if (parentNode) {
      const parent2 = nodeToLayer(parentNode);
      const children = parent2.children.filter((x) => x !== id);
      const update = {
        layoutId,
        layerId: parent2.id,
        layer: {
          children,
          requestMetadata: {
            connectionId,
            layoutId,
            updateVersions: {
              [parent2.id]: getNextNodeVersion(parent2.id)
            }
          }
        }
      };
      await CoreContext.clients.LayoutApi().layer.updateLayer(update);
    }
    await CoreContext.clients.LayoutApi().layer.deleteLayer({
      layoutId,
      layerId: id,
      payload: {
        requestMetadata: {
          connectionId,
          layoutId
        }
      }
    });
  },
  async reorder(id, childIds) {
    const node = methods.get(id);
    const layer = nodeToLayer({
      ...node,
      childIds
    });
    log$1.debug("Reorder layer children", layer);
    await CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId,
      layerId: layer.id,
      layer: {
        children: layer.children,
        requestMetadata: {
          connectionId,
          layoutId,
          updateVersions: {
            [layer.id]: getNextNodeVersion(layer.id)
          }
        }
      }
    });
  },
  async move(id, newParentId, index2) {
    const node = methods.get(id);
    const prevParentNode = methods.get(methods.getParent(id).id);
    const prevParentLayer = nodeToLayer({
      ...prevParentNode,
      childIds: pull$2(prevParentNode.childIds, node.id)
    });
    const newParentNode = methods.get(newParentId);
    const newParentLayer = nodeToLayer({
      ...newParentNode,
      childIds: insertAt$1(index2, node.id, newParentNode.childIds)
    });
    log$1.debug("Move layers");
    await Promise.all([CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId,
      layerId: prevParentLayer.id,
      layer: {
        children: prevParentLayer.children,
        requestMetadata: {
          connectionId,
          layoutId,
          updateVersions: {
            [prevParentLayer.id]: getNextNodeVersion(prevParentLayer.id)
          }
        }
      }
    }), CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId,
      layerId: newParentLayer.id,
      layer: {
        children: newParentLayer.children,
        requestMetadata: {
          connectionId,
          layoutId,
          updateVersions: {
            [newParentLayer.id]: getNextNodeVersion(newParentLayer.id)
          }
        }
      }
    })]);
  },
  async batch(batch) {
    const layerBatch = batch.map(([type, node]) => [type, sceneNodeToLayer(node)]);
    const response = await request(layoutId, layerBatch);
    log$1.debug("Batch response", response);
    return response;
  }
});
var config$1 = (env) => ({
  defaults: {
    previewTokenDuration: 1e3 * 60 * 60,
    guestTokenDuration: 1e3 * 60 * 60 * 12,
    transforms: {
      RoomParticipant: "LS-Room-Participant",
      Image: "LS-Image",
      Banner: "LS-Banner",
      Text: "LS-Text"
    }
  }
});
const RoomParticipant$1 = {
  name: "LS-Room-Participant",
  sourceType: "RoomParticipant",
  props: {
    isMuted: {
      type: Boolean,
      required: false,
      default: false
    },
    volume: {
      type: Number,
      required: false,
      default: 1
    }
  },
  useSource(sources2, props) {
    return sources2.find((x) => isMatch(x.props, props.sourceProps));
  },
  create({
    onUpdate,
    onNewSource,
    onRemove
  }, initialProps) {
    const root2 = document.createElement("div");
    const project = getProject(CoreContext.state.activeProjectId);
    const room = getProjectRoom(CoreContext.state.activeProjectId);
    Object.assign(root2.style, {
      position: "relative"
    });
    let source2;
    let props = initialProps;
    const getSize = (width, canvas) => {
      const widthAsPercentage = width / canvas.width;
      if (widthAsPercentage >= 0.5) {
        return 3;
      } else if (widthAsPercentage > 0.25) {
        return 2;
      } else if (widthAsPercentage > 0.15) {
        return 1;
      }
      return 0;
    };
    const Participant2 = ({
      props: props2,
      source: source22
    }) => {
      var _a2, _b, _c;
      const ref2 = useRef();
      const {
        volume = 1,
        isHidden = false
      } = props2 || {};
      const [labelSize, setLabelSize] = useState(0);
      const isSelf = (source22 == null ? void 0 : source22.id) === (room == null ? void 0 : room.participantId) || ((_a2 = source22 == null ? void 0 : source22.props) == null ? void 0 : _a2.participantId) === (room == null ? void 0 : room.participantId);
      const muteAudio = isSelf || (props2 == null ? void 0 : props2.isMuted);
      const hasVideo = !(props2 == null ? void 0 : props2.isHidden) && ((_b = source22 == null ? void 0 : source22.props) == null ? void 0 : _b.videoEnabled);
      useEffect(() => {
        if (!ref2.current)
          return;
        ref2.current.play().catch((e2) => {
          document.addEventListener("click", () => {
            var _a3;
            return (_a3 = ref2.current) == null ? void 0 : _a3.play();
          }, {
            once: true
          });
        });
        if ((source22 == null ? void 0 : source22.value) && (source22 == null ? void 0 : source22.value) !== ref2.current.srcObject) {
          ref2.current.srcObject = source22 == null ? void 0 : source22.value;
        } else if (!(source22 == null ? void 0 : source22.value)) {
          ref2.current.srcObject = null;
        }
      }, [ref2.current, source22 == null ? void 0 : source22.value]);
      useEffect(() => {
        if (!props2 && ref2.current) {
          ref2.current.srcObject = null;
          ref2.current = null;
        }
      }, [props2]);
      useLayoutEffect(() => {
        if (!ref2.current)
          return;
        const calculate = () => {
          const rect = ref2.current;
          if (rect) {
            setLabelSize(getSize(rect.clientWidth, {
              width: project.compositor.getRoot().props.size.x,
              height: project.compositor.getRoot().props.size.y
            }));
          }
        };
        const resizeObserver2 = new ResizeObserver((entries) => {
          calculate();
        });
        calculate();
        resizeObserver2 == null ? void 0 : resizeObserver2.observe(ref2.current);
        return () => {
          if (ref2.current) {
            resizeObserver2 == null ? void 0 : resizeObserver2.unobserve(ref2.current);
            ref2.current.srcObject = null;
          }
        };
      }, [ref2.current, project]);
      useEffect(() => {
        if (!ref2.current)
          return;
        ref2.current.volume = volume;
      }, [ref2.current, volume]);
      return /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#222",
          position: "absolute",
          height: "100%",
          width: "100%",
          fontSize: "43px",
          color: "rgba(255,255,255,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: hasVideo ? "0" : "1"
        }
      }, (source22 == null ? void 0 : source22.props.displayName) && /* @__PURE__ */ React.createElement("div", {
        style: {
          borderRadius: "50%",
          background: "#555",
          width: "70px",
          height: "70px",
          textTransform: "uppercase",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          lineHeight: "1em"
        }
      }, (source22 == null ? void 0 : source22.props.displayName.slice(0, 1)) || "")), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%",
          ...Boolean((_c = source22 == null ? void 0 : source22.props) == null ? void 0 : _c.mirrored) && {
            transform: "scaleX(-1)"
          }
        }
      }, /* @__PURE__ */ React.createElement("video", {
        ref: ref2,
        autoPlay: true,
        muted: muteAudio,
        disablePictureInPicture: true,
        playsInline: true,
        style: {
          left: "50%",
          top: "50%",
          position: "relative",
          transform: "translate3d(-50%, -50%, 0)",
          height: "100%",
          opacity: hasVideo ? "1" : "0",
          objectFit: (source22 == null ? void 0 : source22.props.type) === "screen" ? "contain" : "cover",
          background: "rgba(0,0,0,0.6)"
        }
      })), (source22 == null ? void 0 : source22.props.displayName) && /* @__PURE__ */ React.createElement("div", {
        className: "NameBannerContainer",
        style: {
          width: "100%",
          height: "100%",
          position: "absolute"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner",
        "data-size": labelSize,
        style: {
          padding: "12px 30px",
          width: "fit-content",
          height: "fit-content",
          top: "100%",
          transform: "translateY(-100%)",
          left: 0
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner-body"
      }, source22.props.displayName))));
    };
    const render2 = () => ReactDOM.render(/* @__PURE__ */ React.createElement(Participant2, {
      source: source2,
      props
    }), root2);
    onUpdate((_props) => {
      props = _props;
      render2();
    });
    onNewSource((_source) => {
      source2 = _source;
      render2();
    });
    onRemove((_props) => {
      props = _props;
      render2();
    });
    return {
      root: root2
    };
  }
};
const Square = {
  name: "LS-Square",
  props: {
    color: {
      default: "green"
    }
  },
  create({
    onUpdate
  }) {
    const el = document.createElement("div");
    onUpdate(({
      color: color2
    }) => {
      Object.assign(el.style, {
        width: "100%",
        height: "100%",
        background: color2 || "red"
      });
    });
    return {
      root: el
    };
  }
};
const Image$1 = {
  name: "LS-Image",
  props: {
    src: {},
    fit: {}
  },
  create({
    onUpdate
  }) {
    const el = document.createElement("img");
    onUpdate(({
      src,
      fit
    }) => {
      el.setAttribute("src", src);
      Object.assign(el.style, {
        width: "100%",
        height: "100%",
        objectFit: fit
      });
    });
    return {
      root: el
    };
  }
};
const Element = {
  name: "Element",
  sourceType: "Element",
  create({
    onUpdate
  }, {
    tagName: tagName2
  }) {
    const el = document.createElement(tagName2);
    onUpdate(({
      tagName: tagName22,
      attributes = {},
      fields = {}
    }) => {
      if (tagName22 === "img") {
        if ((el == null ? void 0 : el.src) !== attributes["src"]) {
          Object.keys(attributes).forEach((attr) => {
            el.setAttribute(attr, attributes[attr]);
          });
        }
      } else {
        Object.keys(attributes).forEach((attr) => {
          el.setAttribute(attr, attributes[attr]);
        });
      }
      Object.keys(fields).forEach((field) => {
        Object.assign(el[field], fields[field]);
      });
    });
    return {
      root: el
    };
  }
};
const Video = {
  name: "LS-Video",
  sourceType: "LS-Video",
  create({
    onUpdate,
    onEvent,
    onRemove
  }) {
    onRemove(() => {
      clearInterval(interval);
    });
    const el = document.createElement("video");
    let interval;
    onUpdate(({
      attributes = {},
      fields = {},
      sourceProps = {},
      id
    }) => {
      if (el.src !== attributes["src"] || el.id !== attributes["id"] && attributes["id"]) {
        if (interval) {
          clearInterval(interval);
        }
        Object.keys(attributes).forEach((attr) => {
          el.setAttribute(attr, attributes[attr]);
        });
        el.onloadedmetadata = () => {
          if (attributes["muted"]) {
            el.muted = true;
            el.play();
          } else {
            el.muted = false;
          }
        };
        interval = setInterval(() => {
          if (el.duration) {
            const timePending = el.duration - el.currentTime;
            trigger$1("VideoTimeUpdate", {
              category: id,
              id: sourceProps == null ? void 0 : sourceProps.id,
              time: Math.floor(timePending)
            });
          }
        }, 1e3);
        el.loop = Boolean(attributes["loop"]);
        el.onended = () => {
          if (interval) {
            clearInterval(interval);
          }
          trigger$1("VideoEnded", {
            id: sourceProps == null ? void 0 : sourceProps.id,
            category: id
          });
        };
        Object.keys(fields).forEach((field) => {
          Object.assign(el[field], fields[field]);
        });
      }
    });
    return {
      root: el
    };
  }
};
const Banner$1 = {
  name: "LS-Banner",
  sourceType: "Banner",
  props: {
    bannerId: {
      type: String,
      required: true
    }
  },
  useSource(sources2, props) {
    return sources2.find((x) => x.id === props.bannerId);
  },
  create({
    onUpdate,
    onNewSource
  }, initialProps) {
    const root2 = document.createElement("div");
    let source2;
    let latestSource;
    let previousSource;
    const Banner2 = ({
      currentSource,
      latestSource: latestSource2
    }) => {
      const [rendered, setRendered] = useState(false);
      const {
        headerText,
        bodyText
      } = (latestSource2 == null ? void 0 : latestSource2.value) || {};
      useEffect(() => {
        window.setTimeout(() => {
          setRendered(Boolean(currentSource));
        });
        if (!currentSource)
          setRendered(false);
      }, [currentSource]);
      return /* @__PURE__ */ React.createElement("div", {
        className: "BannerContainer",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "flex-start",
          alignItems: "flex-end",
          transition: "200ms ease all",
          ...!rendered ? {
            zIndex: 1,
            opacity: 0,
            transform: "translateX(-200px)"
          } : {
            zIndex: 2,
            opacity: 1,
            transform: "translateX(0)"
          }
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "Banner",
        style: {
          padding: 10,
          background: "orange",
          width: "fit-content",
          height: "fit-content",
          maxWidth: "84%",
          position: "relative"
        }
      }, headerText && /* @__PURE__ */ React.createElement("div", {
        className: "Banner-header",
        style: {
          marginBottom: 6
        }
      }, headerText), bodyText && /* @__PURE__ */ React.createElement("div", {
        className: "Banner-body"
      }, bodyText)));
    };
    const render2 = () => ReactDOM.render(/* @__PURE__ */ React.createElement(React.Fragment, null, previousSource && previousSource.id !== latestSource.id && /* @__PURE__ */ React.createElement(Banner2, {
      key: previousSource == null ? void 0 : previousSource.id,
      currentSource: null,
      latestSource: previousSource
    }), /* @__PURE__ */ React.createElement(Banner2, {
      key: latestSource == null ? void 0 : latestSource.id,
      currentSource: source2,
      latestSource
    })), root2);
    onUpdate(() => {
      render2();
    });
    onNewSource((_source) => {
      previousSource = source2;
      source2 = _source;
      if (source2) {
        latestSource = source2;
      }
      render2();
    });
    return {
      root: root2
    };
  }
};
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source2 = arguments[i2];
      for (var key in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source2);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source2[key];
  }
  return target;
}
function _setPrototypeOf(o2, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p2) {
    o3.__proto__ = p2;
    return o3;
  };
  return _setPrototypeOf(o2, p);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function hasClass(element, className) {
  if (element.classList)
    return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
function addClass(element, className) {
  if (element.classList)
    element.classList.add(className);
  else if (!hasClass(element, className))
    if (typeof element.className === "string")
      element.className = element.className + " " + className;
    else
      element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}
var config = {
  disabled: false
};
var TransitionGroupContext = React.createContext(null);
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context2) {
    var _this;
    _this = _React$Component.call(this, props, context2) || this;
    var parentGroup = context2;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event2) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event2);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render2() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: null
    }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps));
  };
  return Transition2;
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition$1 = Transition;
var _addClass = function addClass$1(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return addClass(node, c);
  });
};
var removeClass = function removeClass2(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return removeClass$1(node, c);
  });
};
var CSSTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node, "exit");
      _this.addClass(node, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node, type);
      _this.addClass(node, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
      _this.removeClasses(node, "appear");
      _this.removeClasses(node, "enter");
      _this.addClass(node, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
      _this.addClass(node, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
      _this.removeClasses(node, "exit");
      _this.addClass(node, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === "string";
      var prefix = isStringClassNames && classNames ? classNames + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass2(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      node && node.scrollTop;
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node, className);
    }
  };
  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass(node, baseClassName);
    }
    if (activeClassName) {
      removeClass(node, activeClassName);
    }
    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };
  _proto.render = function render2() {
    var _this$props = this.props;
    _this$props.classNames;
    var props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
    return /* @__PURE__ */ React.createElement(Transition$1, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(React.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = {};
var CSSTransition$1 = CSSTransition;
var _leaveRenders, _enterRenders;
function areChildrenDifferent(oldChildren, newChildren) {
  if (oldChildren === newChildren)
    return false;
  if (React.isValidElement(oldChildren) && React.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
    return false;
  }
  return true;
}
var modes = {
  out: "out-in",
  in: "in-out"
};
var callHook = function callHook2(element, name2, cb) {
  return function() {
    var _element$props;
    element.props[name2] && (_element$props = element.props)[name2].apply(_element$props, arguments);
    cb();
  };
};
var leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(_ref) {
  var current = _ref.current, changeState = _ref.changeState;
  return React.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERING, null);
    })
  });
}, _leaveRenders[modes.in] = function(_ref2) {
  var current = _ref2.current, changeState = _ref2.changeState, children = _ref2.children;
  return [current, React.cloneElement(children, {
    in: true,
    onEntered: callHook(children, "onEntered", function() {
      changeState(ENTERING);
    })
  })];
}, _leaveRenders);
var enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(_ref3) {
  var children = _ref3.children, changeState = _ref3.changeState;
  return React.cloneElement(children, {
    in: true,
    onEntered: callHook(children, "onEntered", function() {
      changeState(ENTERED, React.cloneElement(children, {
        in: true
      }));
    })
  });
}, _enterRenders[modes.in] = function(_ref4) {
  var current = _ref4.current, children = _ref4.children, changeState = _ref4.changeState;
  return [React.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERED, React.cloneElement(children, {
        in: true
      }));
    })
  }), React.cloneElement(children, {
    in: true
  })];
}, _enterRenders);
var SwitchTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(SwitchTransition2, _React$Component);
  function SwitchTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      status: ENTERED,
      current: null
    };
    _this.appeared = false;
    _this.changeState = function(status, current) {
      if (current === void 0) {
        current = _this.state.current;
      }
      _this.setState({
        status,
        current
      });
    };
    return _this;
  }
  var _proto = SwitchTransition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
  };
  SwitchTransition2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state2) {
    if (props.children == null) {
      return {
        current: null
      };
    }
    if (state2.status === ENTERING && props.mode === modes.in) {
      return {
        status: ENTERING
      };
    }
    if (state2.current && areChildrenDifferent(state2.current, props.children)) {
      return {
        status: EXITING
      };
    }
    return {
      current: React.cloneElement(props.children, {
        in: true
      })
    };
  };
  _proto.render = function render2() {
    var _this$props = this.props, children = _this$props.children, mode = _this$props.mode, _this$state = this.state, status = _this$state.status, current = _this$state.current;
    var data2 = {
      children,
      current,
      changeState: this.changeState,
      status
    };
    var component;
    switch (status) {
      case ENTERING:
        component = enterRenders[mode](data2);
        break;
      case EXITING:
        component = leaveRenders[mode](data2);
        break;
      case ENTERED:
        component = current;
    }
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, component);
  };
  return SwitchTransition2;
}(React.Component);
SwitchTransition.propTypes = {};
SwitchTransition.defaultProps = {
  mode: modes.out
};
var SwitchTransition$1 = SwitchTransition;
const Animations = {
  "fade-in": ".fade-in{-webkit-animation:fade-in;animation:fade-in}@-webkit-keyframes fade-in{0%{opacity:0}100%{opacity:1}}@keyframes fade-in{0%{opacity:0}100%{opacity:1}}",
  "fade-out": ".fade-out{-webkit-animation:fade-out;animation:fade-out}@-webkit-keyframes fade-out{0%{opacity:1}100%{opacity:0}}@keyframes fade-out{0%{opacity:1}100%{opacity:0}}",
  "slide-in-blurred-top": ".slide-in-blurred-top{-webkit-animation:slide-in-blurred-top .6s cubic-bezier(.23,1.000,.32,1.000) both;animation:slide-in-blurred-top .6s cubic-bezier(.23,1.000,.32,1.000) both}@-webkit-keyframes slide-in-blurred-top{0%{-webkit-transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform:translateY(-1000px) scaleY(2.5) scaleX(.2);-webkit-transform-origin:50% 0;transform-origin:50% 0;-webkit-filter:blur(40px);filter:blur(40px);opacity:0}100%{-webkit-transform:translateY(0) scaleY(1) scaleX(1);transform:translateY(0) scaleY(1) scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-filter:blur(0);filter:blur(0);opacity:1}}@keyframes slide-in-blurred-top{0%{-webkit-transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform:translateY(-1000px) scaleY(2.5) scaleX(.2);-webkit-transform-origin:50% 0;transform-origin:50% 0;-webkit-filter:blur(40px);filter:blur(40px);opacity:0}100%{-webkit-transform:translateY(0) scaleY(1) scaleX(1);transform:translateY(0) scaleY(1) scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-filter:blur(0);filter:blur(0);opacity:1}}",
  "slide-in-left": ".slide-in-left{-webkit-animation:slide-in-left .5s cubic-bezier(.25,.46,.45,.94) both;animation:slide-in-left .5s cubic-bezier(.25,.46,.45,.94) both}@-webkit-keyframes slide-in-left{0%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}100%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}}@keyframes slide-in-left{0%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}100%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}}",
  "slide-out-left": ".slide-out-left{-webkit-animation:slide-out-left .5s cubic-bezier(.55,.085,.68,.53) both;animation:slide-out-left .5s cubic-bezier(.55,.085,.68,.53) both}@-webkit-keyframes slide-out-left{0%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}100%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}}@keyframes slide-out-left{0%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}100%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}}"
};
const APIKitAnimation = (props) => {
  const {
    enter,
    exit,
    children,
    tag = "div",
    direction = "normal",
    duration = 500,
    id,
    type
  } = props;
  const keyId = id ? `${type}-${id}` : `${type}-api-kit-animation`;
  return /* @__PURE__ */ React.createElement("div", {
    style: {
      height: "100%",
      width: "100%"
    }
  }, /* @__PURE__ */ React.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: renderStyle(type, enter, exit, duration, direction)
    }
  }), /* @__PURE__ */ React.createElement(SwitchTransition$1, {
    mode: "out-in"
  }, /* @__PURE__ */ React.createElement(CSSTransition$1, {
    key: keyId,
    addEndListener: (node, done) => {
      node.addEventListener("transitionend", done, false);
    },
    classNames: {
      enter: `${type}-default-enter`,
      enterActive: enter,
      exit: `${type}-default-leave`,
      exitActive: exit
    },
    timeout: duration
  }, /* @__PURE__ */ React.createElement("div", {
    style: {
      height: "100%",
      width: "100%"
    }
  }, children))));
};
const renderStyle = (type, enter, exit, duration, direction) => {
  return `
        body {
          margin: 0;
          padding: 0;
        }
        
        ${Animations[enter]}
        
        ${Animations[exit]}

        .${type}-transition {
          transition: opacity ${duration}ms ease-out};
        }

        .${type}-default-enter {
          opacity: 0;
        }

        .${type}-default-enter.${enter} {
          animation-direction: ${direction};
          animation-duration: ${duration / 1e3}s;
          animation-fill-mode: both;
          animation-timing-function: ease-out;
        }

        .${type}-default-leave {
          opacity: 1;
        }

        .${type}-default-leave.${exit} {
          animation-direction: ${direction};
          animation-duration: ${duration / 1e3}s;
          animation-timing-function: ease-out;
          animation-fill-mode: both;
        }
        `;
};
var APIKitAnimationTypes = /* @__PURE__ */ ((APIKitAnimationTypes2) => {
  APIKitAnimationTypes2["FADE_IN"] = "fade-in";
  APIKitAnimationTypes2["FADE_OUT"] = "fade-out";
  APIKitAnimationTypes2["SLIDE_IN_BLURRED_TOP"] = "slide-in-blurred-top";
  APIKitAnimationTypes2["SLIDE_IN_LEFT"] = "slide-in-left";
  APIKitAnimationTypes2["SLIDE_OUT_LEFT"] = "slide-out-left";
  return APIKitAnimationTypes2;
})(APIKitAnimationTypes || {});
const Logo$1 = {
  name: "LS-Logo",
  sourceType: "Logo",
  create({
    onUpdate
  }, {
    sourceProps
  }) {
    const root2 = document.createElement("div");
    const project = getProject(CoreContext.state.activeProjectId);
    const projectRoot = project.compositor.getRoot();
    const {
      x: rootWidth
    } = projectRoot.props.size;
    const scalar = (rootWidth != null ? rootWidth : 1280) / 1920;
    const scale = (px) => px * scalar + "px";
    const Logo2 = ({
      source: source2
    }) => {
      var _a2;
      const {
        src,
        meta
      } = (source2 == null ? void 0 : source2.sourceProps) || {};
      const {
        id
      } = source2 || {};
      const [startAnimation, setStartAnimation] = React.useState(false);
      useEffect(() => {
        setStartAnimation(false);
      }, [id]);
      const {
        offsetX = 40,
        offsetY = 40,
        height = 135,
        width = 240
      } = (meta == null ? void 0 : meta.style) || {};
      return /* @__PURE__ */ React.createElement(APIKitAnimation, {
        type: "logo",
        id,
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: startAnimation ? 1 : 0,
          width: "100%",
          height: "100%"
        },
        className: `logo-transition`
      }, src && /* @__PURE__ */ React.createElement("div", {
        className: "logo wrapper",
        style: {
          padding: `${scale(offsetY)} ${scale(offsetX)}`
        }
      }, /* @__PURE__ */ React.createElement("img", {
        style: {
          height: "100%",
          width: "100%",
          maxHeight: height ? scale(height) : "none",
          maxWidth: width ? scale(width) : "none",
          ...(_a2 = sourceProps == null ? void 0 : sourceProps.meta) == null ? void 0 : _a2.style,
          ...meta == null ? void 0 : meta.style
        },
        src,
        onLoad: () => setStartAnimation(true)
      }))));
    };
    const render2 = (source2) => ReactDOM.render(/* @__PURE__ */ React.createElement(Logo2, {
      source: source2
    }), root2);
    onUpdate((props) => {
      render2({
        ...props
      });
    });
    return {
      root: root2
    };
  }
};
const Iframe = ({
  url,
  allowFullScreen,
  position,
  display,
  height,
  width,
  overflow,
  styles,
  onLoad,
  id,
  frameBorder,
  className,
  name: name2,
  target,
  iframeRef,
  children,
  src
}) => {
  const defaultProps = Object.assign({
    src: src || url,
    target: target || null,
    style: {
      position: position || null,
      display: display || "block",
      overflow: overflow || null,
      ...styles
    },
    name: name2 || null,
    className: className || null,
    id: id || null,
    onLoad: onLoad || null,
    height: height || "100%",
    width: width || "100%",
    allow: "autoplay"
  });
  let props = /* @__PURE__ */ Object.create(null);
  for (let prop of Object.keys(defaultProps)) {
    if (defaultProps[prop] != null) {
      props[prop] = defaultProps[prop];
    }
  }
  for (let i2 of Object.keys(props.style)) {
    if (props.style[i2] == null) {
      delete props.style[i2];
    }
  }
  if (allowFullScreen) {
    if ("allow" in props) {
      const currentAllow = props.allow.replace("fullscreen", "");
      props.allow = `fullscreen ${currentAllow.trim()}`.trim();
    } else {
      props.allow = "fullscreen";
    }
  }
  if (frameBorder >= 0) {
    if (!props.style.hasOwnProperty("border")) {
      props.style.border = frameBorder;
    }
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, children ? /* @__PURE__ */ React.createElement("iframe", {
    ref: iframeRef,
    ...props
  }, children) : /* @__PURE__ */ React.createElement("iframe", {
    ref: iframeRef,
    ...props
  }));
};
const Overlay = {
  name: "LS-Overlay",
  sourceType: "Overlay",
  create({
    onUpdate,
    onRemove
  }, {
    sourceProps
  }) {
    onRemove(() => {
      clearInterval(interval);
    });
    const root2 = document.createElement("div");
    const role = getProject(CoreContext.state.activeProjectId).role;
    let interval;
    const IFrame = ({
      source: source2,
      setStartAnimation
    }) => {
      const {
        src,
        meta,
        height,
        width
      } = (source2 == null ? void 0 : source2.sourceProps) || {};
      const iframeRef = React.useRef(null);
      useEffect(() => {
        if (iframeRef.current) {
          iframeRef.current.style.removeProperty("transformOrigin");
          iframeRef.current.style.removeProperty("transform");
        }
      }, [src]);
      const resizeIframe = () => {
        if (iframeRef.current) {
          const project = getProject(CoreContext.state.activeProjectId);
          const root22 = project.compositor.getRoot();
          const {
            x: rootWidth,
            y: rootHeight
          } = root22.props.size;
          let iframeWidth = iframeRef.current.clientWidth;
          let iframeHeight = iframeRef.current.clientHeight;
          let scale;
          if (iframeWidth && iframeHeight) {
            scale = Math.min(rootWidth / iframeWidth, rootHeight / iframeHeight);
          } else {
            scale = 1;
          }
          iframeRef.current.style.willChange = `transform`;
          iframeRef.current.style.transformOrigin = "0 0";
          iframeRef.current.style.transform = `scale(${scale}) translateZ(0)`;
          setStartAnimation(true);
        }
      };
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Iframe, {
        key: source2.id,
        url: src,
        frameBorder: 0,
        iframeRef,
        height,
        width,
        onLoad: resizeIframe,
        styles: {
          ...meta == null ? void 0 : meta.style
        }
      }));
    };
    const Video3 = ({
      source: source2,
      setStartAnimation
    }) => {
      var _a2;
      const {
        src,
        type,
        meta,
        loop
      } = (source2 == null ? void 0 : source2.sourceProps) || {};
      const {
        id,
        sourceType
      } = source2 || {};
      const [refId, setRefId] = React.useState(null);
      const videoRef = React.useRef(null);
      console.log("Updated current time", (_a2 = videoRef == null ? void 0 : videoRef.current) == null ? void 0 : _a2.currentTime);
      const handleRect = React.useCallback((node) => {
        videoRef.current = node;
        setRefId(node ? node.id : null);
      }, []);
      const onLoadedData = React.useCallback(() => {
        if (videoRef == null ? void 0 : videoRef.current) {
          videoRef.current.play().catch(() => {
            var _a3;
            videoRef.current.muted = true;
            (_a3 = videoRef.current) == null ? void 0 : _a3.play();
          });
        }
      }, [src]);
      const onEnded = React.useCallback(() => {
        if (interval) {
          clearInterval(interval);
        }
        if (hasPermission(role, Permission.UpdateProject)) {
          trigger$1("VideoEnded", {
            id,
            category: type
          });
        }
      }, [src]);
      React.useEffect(() => {
        if (meta && (videoRef == null ? void 0 : videoRef.current) && refId) {
          if (hasPermission(role, Permission.ManageSelf)) {
            if (meta == null ? void 0 : meta.time) {
              videoRef.current.currentTime = Number(meta == null ? void 0 : meta.time);
            }
          }
        }
      }, [meta == null ? void 0 : meta.time, refId]);
      React.useEffect(() => {
        return () => {
          if (interval) {
            clearInterval(interval);
          }
        };
      }, [id]);
      React.useEffect(() => {
        if (!refId) {
          if (interval) {
            clearInterval(interval);
          }
        } else {
          if (videoRef.current) {
            videoRef.current.src = src;
            videoRef.current.play().catch(() => {
              videoRef.current.muted = true;
              videoRef.current.play();
            });
            if (hasPermission(role, Permission.UpdateProject)) {
              interval = setInterval(() => {
                if (videoRef.current.duration) {
                  const timePending = videoRef.current.duration - videoRef.current.currentTime;
                  trigger$1("VideoTimeUpdate", {
                    category: sourceType,
                    id,
                    time: Math.floor(timePending)
                  });
                }
              }, 1e3);
            }
          }
        }
      }, [refId]);
      return /* @__PURE__ */ React.createElement(React.Fragment, {
        key: id
      }, src && /* @__PURE__ */ React.createElement("video", {
        loop,
        id,
        ref: handleRect,
        style: {
          ...sourceProps.meta.style,
          ...meta.style
        },
        onLoadedData,
        onEnded,
        onCanPlay: () => setStartAnimation(true)
      }));
    };
    const Image3 = ({
      source: source2,
      setStartAnimation
    }) => {
      const {
        src,
        meta
      } = (source2 == null ? void 0 : source2.sourceProps) || {};
      const {
        id
      } = source2 || {};
      return /* @__PURE__ */ React.createElement(React.Fragment, {
        key: id
      }, src && /* @__PURE__ */ React.createElement("img", {
        style: {
          ...sourceProps.meta.style,
          ...meta.style
        },
        src,
        onLoad: () => setStartAnimation(true)
      }));
    };
    const Overlay2 = ({
      source: source2
    }) => {
      const {
        type
      } = (source2 == null ? void 0 : source2.sourceProps) || {};
      const {
        id
      } = source2 || {};
      const [startAnimation, setStartAnimation] = React.useState(false);
      useEffect(() => {
        setStartAnimation(false);
      }, [id]);
      return /* @__PURE__ */ React.createElement(APIKitAnimation, {
        id,
        type: "overlay",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: startAnimation ? 1 : 0,
          width: "100%",
          height: "100%"
        },
        className: `overlayContainer overlay-transition`
      }, id && type === "image" && /* @__PURE__ */ React.createElement(Image3, {
        source: source2,
        setStartAnimation
      }), id && type === "video" && /* @__PURE__ */ React.createElement(Video3, {
        source: source2,
        setStartAnimation
      }), id && type === "custom" && /* @__PURE__ */ React.createElement(IFrame, {
        source: source2,
        setStartAnimation
      })));
    };
    const render2 = (source2) => ReactDOM.render(/* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Overlay2, {
      source: source2
    })), root2);
    onUpdate((props) => {
      render2({
        ...props
      });
    });
    return {
      root: root2
    };
  }
};
var functionExpression = /[\s]*([a-z-]+)[\s]*\([\s]*([^\)]+)[\s]*\)[\s]*/i;
var floatExpression = /^(\-?\d+\.?\d{0,5})/;
var toFloat = parseFloat;
function ensurePercent(value) {
  return typeof value === "number" ? value : toFloat(value) * 0.01;
}
function formatPercent(value) {
  return formatFloat(value * 100) + "%";
}
function formatFloat(n2) {
  return floatExpression.exec(n2.toString())[1];
}
function parseCSSFunction(stringValue) {
  var matches = functionExpression.exec(stringValue);
  if (!matches || !matches.length) {
    return void 0;
  }
  return [matches[1]].concat(matches[2].split(","));
}
function cssFunction(functionName, params) {
  var parts = Array.prototype.join.call(params, ", ");
  return functionName + "(" + parts + ")";
}
var math = Math;
var round = math.round;
function roundFloat(n2, factor) {
  return round(n2 * factor) / factor;
}
var _a;
var RGB = "rgb", HSL = "hsl";
var converters = (_a = {}, _a[RGB + HSL] = RGBtoHSL, _a[HSL + RGB] = HSLtoRGB, _a);
var maxChannelValues = {
  r: 255,
  g: 255,
  b: 255,
  h: 360,
  s: 1,
  l: 1,
  a: 1
};
function color(value) {
  return parseHexCode(value) || parseColorFunction(value) || rgb(255, 0, 0);
}
function rgb(red, blue, green, alpha) {
  return new ColorHelper(RGB, red, blue, green, alpha === void 0 ? 1 : ensurePercent(alpha), alpha !== void 0);
}
function convertHelper(toFormat, helper, forceAlpha) {
  var fromFormat = helper.f, r2 = helper.r, g = helper.g, b = helper.b, a = helper.a;
  var newAlpha = forceAlpha === void 0 ? helper.o : forceAlpha;
  if (fromFormat !== toFormat) {
    return converters[fromFormat + toFormat](r2, g, b, a, newAlpha);
  }
  return forceAlpha === void 0 ? helper : new ColorHelper(fromFormat, r2, g, b, a, newAlpha);
}
var ColorHelper = function() {
  function ColorHelper2(format2, r2, g, b, a, hasAlpha) {
    var self2 = this;
    self2.f = format2;
    self2.o = hasAlpha;
    var isHSL = format2 === HSL;
    self2.r = clampColor(isHSL ? "h" : "r", r2);
    self2.g = clampColor(isHSL ? "s" : "g", g);
    self2.b = clampColor(isHSL ? "l" : "b", b);
    self2.a = clampColor("a", a);
  }
  ColorHelper2.prototype.toString = function() {
    var _a2 = this, hasAlpha = _a2.o, format2 = _a2.f, r2 = _a2.r, g = _a2.g, b = _a2.b, a = _a2.a;
    var fnName;
    var params;
    if (format2 === RGB) {
      fnName = hasAlpha ? "rgba" : RGB;
      params = [round(r2), round(g), round(b)];
    } else if (format2 === HSL) {
      fnName = hasAlpha ? "hsla" : HSL;
      params = [round(r2), formatPercent(roundFloat(g, 100)), formatPercent(roundFloat(b, 100))];
    } else {
      throw new Error("Invalid color format");
    }
    if (hasAlpha) {
      params.push(formatFloat(roundFloat(a, 1e5)));
    }
    return cssFunction(fnName, params);
  };
  ColorHelper2.prototype.toHexString = function() {
    var color2 = convertHelper(RGB, this);
    return "#" + (toHex(color2.r) + toHex(color2.g) + toHex(color2.b)).toUpperCase();
  };
  ColorHelper2.prototype.toHSL = function() {
    return convertHelper(HSL, this, false);
  };
  ColorHelper2.prototype.toHSLA = function() {
    return convertHelper(HSL, this, true);
  };
  ColorHelper2.prototype.toRGB = function() {
    return convertHelper(RGB, this, false);
  };
  ColorHelper2.prototype.toRGBA = function() {
    return convertHelper(RGB, this, true);
  };
  ColorHelper2.prototype.red = function() {
    var _ = this;
    return (_.f === RGB ? _ : _.toRGB()).r;
  };
  ColorHelper2.prototype.green = function() {
    var _ = this;
    return (_.f === RGB ? _ : _.toRGB()).g;
  };
  ColorHelper2.prototype.blue = function() {
    var _ = this;
    return (_.f === RGB ? _ : _.toRGB()).b;
  };
  ColorHelper2.prototype.hue = function() {
    var _ = this;
    return (_.f === HSL ? _ : _.toHSL()).r;
  };
  ColorHelper2.prototype.saturation = function() {
    var _ = this;
    return (_.f === HSL ? _ : _.toHSL()).g;
  };
  ColorHelper2.prototype.lightness = function() {
    var _ = this;
    return (_.f === HSL ? _ : _.toHSL()).b;
  };
  ColorHelper2.prototype.alpha = function() {
    return this.a;
  };
  ColorHelper2.prototype.opacity = function() {
    return this.a;
  };
  ColorHelper2.prototype.invert = function() {
    var _ = this;
    var color2 = convertHelper(RGB, _);
    return convertHelper(_.f, new ColorHelper2(RGB, 255 - color2.r, 255 - color2.g, 255 - color2.b, _.a, _.o));
  };
  ColorHelper2.prototype.lighten = function(percent, relative) {
    var _ = this;
    var color2 = convertHelper(HSL, _);
    var max2 = maxChannelValues.l;
    var l = color2.b + (relative ? max2 - color2.b : max2) * ensurePercent(percent);
    return convertHelper(_.f, new ColorHelper2(HSL, color2.r, color2.g, l, _.a, _.o));
  };
  ColorHelper2.prototype.darken = function(percent, relative) {
    var _ = this;
    var color2 = convertHelper(HSL, _);
    var l = color2.b - (relative ? color2.b : maxChannelValues.l) * ensurePercent(percent);
    return convertHelper(_.f, new ColorHelper2(HSL, color2.r, color2.g, l, _.a, _.o));
  };
  ColorHelper2.prototype.saturate = function(percent, relative) {
    var _ = this;
    var color2 = convertHelper(HSL, _);
    var max2 = maxChannelValues.s;
    var s = color2.g + (relative ? max2 - color2.g : max2) * ensurePercent(percent);
    return convertHelper(_.f, new ColorHelper2(HSL, color2.r, s, color2.b, _.a, _.o));
  };
  ColorHelper2.prototype.desaturate = function(percent, relative) {
    var _ = this;
    var color2 = convertHelper(HSL, _);
    var max2 = maxChannelValues.s;
    var s = color2.g - (relative ? color2.g : max2) * ensurePercent(percent);
    return convertHelper(_.f, new ColorHelper2(HSL, color2.r, s, color2.b, _.a, _.o));
  };
  ColorHelper2.prototype.grayscale = function() {
    return this.desaturate(1);
  };
  ColorHelper2.prototype.fade = function(percent) {
    var _ = this;
    var a = clampColor("a", ensurePercent(percent));
    return convertHelper(_.f, new ColorHelper2(_.f, _.r, _.g, _.b, a, true));
  };
  ColorHelper2.prototype.fadeOut = function(percent, relative) {
    var _ = this;
    var max2 = 1;
    var a = clampColor("a", _.a - (relative ? _.a : max2) * ensurePercent(percent));
    return convertHelper(_.f, new ColorHelper2(_.f, _.r, _.g, _.b, a, true));
  };
  ColorHelper2.prototype.fadeIn = function(percent, relative) {
    var _ = this;
    var max2 = 1;
    var a = clampColor("a", _.a + (relative ? _.a : max2) * ensurePercent(percent));
    return convertHelper(_.f, new ColorHelper2(_.f, _.r, _.g, _.b, a, true));
  };
  ColorHelper2.prototype.mix = function(mixin, weight2) {
    var _ = this;
    var color2 = ensureColor(mixin);
    var g = convertHelper(RGB, _);
    var b = convertHelper(RGB, color2);
    var p = weight2 === void 0 ? 0.5 : weight2;
    var w = 2 * p - 1;
    var a = Math.abs(g.a - b.a);
    var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
    var w2 = 1 - w1;
    var helper = new ColorHelper2(RGB, round(g.r * w1 + b.r * w2), round(g.g * w1 + b.g * w2), round(g.b * w1 + b.b * w2), g.a * p + b.a * (1 - p), _.o || color2.o);
    return convertHelper(this.f, helper);
  };
  ColorHelper2.prototype.tint = function(weight2) {
    return rgb(255, 255, 255).mix(this, weight2);
  };
  ColorHelper2.prototype.shade = function(weight2) {
    return rgb(0, 0, 0).mix(this, weight2);
  };
  ColorHelper2.prototype.spin = function(degrees) {
    var _ = this;
    var color2 = convertHelper(HSL, _);
    return convertHelper(_.f, new ColorHelper2(HSL, modDegrees(color2.r + degrees), color2.g, color2.b, _.a, _.o));
  };
  return ColorHelper2;
}();
function toHex(n2) {
  var i2 = round(n2);
  return (i2 < 16 ? "0" : "") + i2.toString(16);
}
function modDegrees(n2) {
  return ((n2 < 0 ? 360 : 0) + n2 % 360) % 360;
}
function RGBtoHSL(r2, g, b, a, hasAlpha) {
  var newR = r2 / 255;
  var newG = g / 255;
  var newB = b / 255;
  var min2 = Math.min(newR, newG, newB);
  var max2 = Math.max(newR, newG, newB);
  var l = (min2 + max2) / 2;
  var delta = max2 - min2;
  var h;
  if (max2 === min2) {
    h = 0;
  } else if (newR === max2) {
    h = (newG - newB) / delta;
  } else if (newG === max2) {
    h = 2 + (newB - newR) / delta;
  } else if (newB === max2) {
    h = 4 + (newR - newG) / delta;
  } else {
    h = 0;
  }
  h = Math.min(h * 60, 360);
  if (h < 0) {
    h += 360;
  }
  var s;
  if (max2 === min2) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max2 + min2);
  } else {
    s = delta / (2 - max2 - min2);
  }
  return new ColorHelper(HSL, h, s, l, a, hasAlpha);
}
function HSLtoRGB(r2, g, b, a, hasAlpha) {
  var newH = r2 / 360;
  var newS = g;
  var newL = b;
  if (newS === 0) {
    var val = newL * 255;
    return new ColorHelper(RGB, val, val, val, a, hasAlpha);
  }
  var t2 = newL < 0.5 ? newL * (1 + newS) : newL + newS - newL * newS;
  var t1 = 2 * newL - t2;
  var newR = 0, newG = 0, newB = 0;
  for (var i2 = 0; i2 < 3; i2++) {
    var t3 = newH + 1 / 3 * -(i2 - 1);
    if (t3 < 0) {
      t3++;
    }
    if (t3 > 1) {
      t3--;
    }
    var val = void 0;
    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }
    val *= 255;
    if (i2 === 0) {
      newR = val;
    } else if (i2 === 1) {
      newG = val;
    } else {
      newB = val;
    }
  }
  return new ColorHelper(RGB, newR, newG, newB, a, hasAlpha);
}
function clampColor(channel2, value) {
  var min2 = 0;
  var max2 = maxChannelValues[channel2];
  return value < min2 ? min2 : value > max2 ? max2 : value;
}
function ensureColor(c) {
  return c instanceof ColorHelper ? c : color(c);
}
function parseHexCode(stringValue) {
  var match = stringValue.match(/#(([a-f0-9]{6})|([a-f0-9]{3}))$/i);
  if (!match) {
    return void 0;
  }
  var hex = match[1];
  var hexColor = parseInt(hex.length === 3 ? hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] : hex, 16);
  var r2 = hexColor >> 16 & 255;
  var b = hexColor >> 8 & 255;
  var g = hexColor & 255;
  return new ColorHelper(RGB, r2, b, g, 1, false);
}
function parseColorFunction(colorString) {
  var cssParts = parseCSSFunction(colorString);
  if (!cssParts || !(cssParts.length === 4 || cssParts.length === 5)) {
    return void 0;
  }
  var fn = cssParts[0];
  var isRGBA = fn === "rgba";
  var isHSLA = fn === "hsla";
  var isRGB = fn === RGB;
  var isHSL = fn === HSL;
  var hasAlpha = isHSLA || isRGBA;
  var type;
  if (isRGB || isRGBA) {
    type = RGB;
  } else if (isHSL || isHSLA) {
    type = HSL;
  } else {
    throw new Error("unsupported color string");
  }
  var r2 = toFloat(cssParts[1]);
  var g = isRGB || isRGBA ? toFloat(cssParts[2]) : ensurePercent(cssParts[2]);
  var b = isRGB || isRGBA ? toFloat(cssParts[3]) : ensurePercent(cssParts[3]);
  var a = hasAlpha ? toFloat(cssParts[4]) : 1;
  return new ColorHelper(type, r2, g, b, a, hasAlpha);
}
const of = color;
const transparent = color("rgba(0,0,0,0)");
const white = color("#ffffff");
const black = color("#000000");
const weights = {
  primary: {
    50: "#EAFAF5",
    100: "#D5F6EB",
    200: "#ABEDD7",
    300: "#82E3C3",
    400: "#58DAAF",
    500: "#26AD80",
    600: "#25A77C",
    700: "#1C7D5D",
    800: "#12543E"
  },
  secondary: {
    50: "#FBEAEA",
    100: "#F7D4D4",
    200: "#EFA9A9",
    300: "#E77E7E",
    400: "#FF6F64",
    500: "#E9554A",
    600: "#CB362B",
    700: "#811818",
    800: "#561010"
  },
  neutral: {
    0: "#ffffff",
    10: "#f5f5f5",
    200: "#d9d9d9",
    300: "#bababa",
    350: "#999999",
    400: "#9e9e9e",
    500: "#808080",
    600: "#666666",
    700: "#4d4d4d",
    800: "#303030",
    900: "#141414",
    1e3: "#000000"
  },
  warning: {
    400: "#FFC28A",
    500: "#FFAE64",
    600: "#F29540"
  }
};
const types = Object.keys(weights);
const weight = (type) => (weight2) => {
  const map2 = weights[type];
  if (map2[weight2])
    return map2[weight2];
  const keys2 = Object.keys(weights.primary).map(Number);
  const result = keys2.find((x) => weight2 <= x);
  if (result) {
    return map2[result];
  } else {
    return map2[keys2.slice(keys2.length - 1)[0]];
  }
};
const primary = weight("primary");
const neutral = weight("neutral");
const secondary = weight("secondary");
const warning = weight("warning");
const lightstream = color("#26ad80");
const twitch = color("#9156ff");
const linkedin = color("#2867b2");
const youtube = color("#ff0000");
const facebook = color("#1877f2");
const twitter = color("#1da1f2");
var Color = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  color,
  of,
  transparent,
  white,
  black,
  types,
  primary,
  neutral,
  secondary,
  warning,
  lightstream,
  twitch,
  linkedin,
  youtube,
  facebook,
  twitter
}, Symbol.toStringTag, { value: "Module" }));
const YouTube = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.6465 8.53711C19.4707 7.83398 18.9141 7.27734 18.2402 7.10156C16.9805 6.75 12 6.75 12 6.75C12 6.75 6.99023 6.75 5.73047 7.10156C5.05664 7.27734 4.5 7.83398 4.32422 8.53711C3.97266 9.76758 3.97266 12.4043 3.97266 12.4043C3.97266 12.4043 3.97266 15.0117 4.32422 16.2715C4.5 16.9746 5.05664 17.502 5.73047 17.6777C6.99023 18 12 18 12 18C12 18 16.9805 18 18.2402 17.6777C18.9141 17.502 19.4707 16.9746 19.6465 16.2715C19.998 15.0117 19.998 12.4043 19.998 12.4043C19.998 12.4043 19.998 9.76758 19.6465 8.53711ZM10.3594 14.7773V10.0312L14.5195 12.4043L10.3594 14.7773Z"
}));
const YouTubeDuo = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("rect", {
  x: "8",
  y: "9",
  width: "9",
  height: "7",
  fill: neutral(0)
}), /* @__PURE__ */ React.createElement("path", {
  d: "M19.6465 8.53711C19.4707 7.83398 18.9141 7.27734 18.2402 7.10156C16.9805 6.75 12 6.75 12 6.75C12 6.75 6.99023 6.75 5.73047 7.10156C5.05664 7.27734 4.5 7.83398 4.32422 8.53711C3.97266 9.76758 3.97266 12.4043 3.97266 12.4043C3.97266 12.4043 3.97266 15.0117 4.32422 16.2715C4.5 16.9746 5.05664 17.502 5.73047 17.6777C6.99023 18 12 18 12 18C12 18 16.9805 18 18.2402 17.6777C18.9141 17.502 19.4707 16.9746 19.6465 16.2715C19.998 15.0117 19.998 12.4043 19.998 12.4043C19.998 12.4043 19.998 9.76758 19.6465 8.53711ZM10.3594 14.7773V10.0312L14.5195 12.4043L10.3594 14.7773Z"
}));
const Facebook = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M15.4863 13.3125L15.8965 10.6172H13.2891V8.85938C13.2891 8.09766 13.6406 7.39453 14.8125 7.39453H16.0137V5.08008C16.0137 5.08008 14.9297 4.875 13.9043 4.875C11.7656 4.875 10.3594 6.19336 10.3594 8.53711V10.6172H7.95703V13.3125H10.3594V19.875H13.2891V13.3125H15.4863Z"
}));
const FacebookCircle = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.2656 12.375C19.2656 8.36133 16.0137 5.10938 12 5.10938C7.98633 5.10938 4.73438 8.36133 4.73438 12.375C4.73438 16.0078 7.37109 19.0254 10.8574 19.5527V14.4844H9.01172V12.375H10.8574V10.793C10.8574 8.97656 11.9414 7.95117 13.582 7.95117C14.4023 7.95117 15.2227 8.09766 15.2227 8.09766V9.88477H14.3145C13.4062 9.88477 13.1133 10.4414 13.1133 11.0273V12.375H15.1348L14.8125 14.4844H13.1133V19.5527C16.5996 19.0254 19.2656 16.0078 19.2656 12.375Z"
}));
const Twitch = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M16.9551 8.92188H15.8125V12.1445H16.9551V8.92188ZM13.8496 8.89258H12.707V12.1152H13.8496V8.89258ZM9.01562 5.875L6.20312 8.57031V18.209H9.60156V20.875L12.4141 18.209H14.6699L19.7676 13.375V5.875H9.01562ZM18.6543 12.8477L16.3691 14.9863H14.1133L12.1504 16.8613V14.9863H9.60156V6.95898H18.6543V12.8477Z"
}));
const TwitchDuo = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19 6.5H9L8.8125 17.5H13.5L19 13V6.5Z",
  fill: neutral(0)
}), /* @__PURE__ */ React.createElement("path", {
  d: "M16.9551 8.92188H15.8125V12.1445H16.9551V8.92188ZM13.8496 8.89258H12.707V12.1152H13.8496V8.89258ZM9.01562 5.875L6.20312 8.57031V18.209H9.60156V20.875L12.4141 18.209H14.6699L19.7676 13.375V5.875H9.01562ZM18.6543 12.8477L16.3691 14.9863H14.1133L12.1504 16.8613V14.9863H9.60156V6.95898H18.6543V12.8477Z"
}));
const Twitter = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M20.6681 7.98749C20.6806 8.16248 20.6806 8.33751 20.6806 8.5125C20.6806 13.85 16.6197 20 9.1976 20C6.91098 20 4.78681 19.3375 3 18.1875C3.32489 18.225 3.63723 18.2375 3.97462 18.2375C5.86136 18.2375 7.59821 17.6 8.98518 16.5125C7.21086 16.475 5.72393 15.3125 5.21162 13.7125C5.46155 13.75 5.71143 13.775 5.97386 13.775C6.33621 13.775 6.69859 13.725 7.03594 13.6375C5.18666 13.2625 3.79966 11.6375 3.79966 9.67499V9.62501C4.33693 9.92501 4.96174 10.1125 5.62393 10.1375C4.53685 9.41247 3.82466 8.17498 3.82466 6.77497C3.82466 6.02499 4.02454 5.33749 4.37443 4.73748C6.36117 7.18748 9.34753 8.78745 12.6962 8.96248C12.6337 8.66248 12.5962 8.35001 12.5962 8.03751C12.5962 5.81248 14.3955 4 16.6322 4C17.7942 4 18.8438 4.4875 19.581 5.275C20.4931 5.10001 21.3678 4.76249 22.1425 4.3C21.8426 5.23752 21.2054 6.02502 20.3682 6.52499C21.1804 6.43753 21.9676 6.21248 22.6923 5.90001C22.1426 6.69998 21.4553 7.41245 20.6681 7.98749Z"
}));
const LinkedIn = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.2 3H4.8C3.81 3 3.009 3.81 3.009 4.8L3 19.2C3 20.19 3.81 21 4.8 21H19.2C20.19 21 21 20.19 21 19.2V4.8C21 3.81 20.19 3 19.2 3ZM8.4 18.3H5.7V10.2H8.4V18.3ZM7.05 8.679C6.15 8.679 5.421 7.95 5.421 7.05C5.421 6.15 6.15 5.421 7.05 5.421C7.95 5.421 8.679 6.15 8.679 7.05C8.679 7.95 7.95 8.679 7.05 8.679ZM18.3 18.3H15.6V13.53C15.6 12.783 14.997 12.18 14.25 12.18C13.503 12.18 12.9 12.783 12.9 13.53V18.3H10.2V10.2H12.9V11.28C13.368 10.524 14.331 10.02 15.15 10.02C16.887 10.02 18.3 11.433 18.3 13.17V18.3Z"
}));
const Lightstream = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0.144 0 27.712 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M16.0369 12.1232L14 15.6518L11.5642 11.4335L6.27356 10.6176L14 24L20.4627 12.805L16.0369 12.1232Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M9.74033 8.27418L7.37317 4.17409H20.6268L19.0921 6.83194L24.3827 6.01602L27.8558 0H0.144165L5.31453 8.95665L9.74033 8.27418Z"
}));
const LightstreamWithText = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 3000 524"
}, /* @__PURE__ */ React.createElement("polygon", {
  points: "330.56 263.5 299.73 316.91 262.86 253.06 182.78 240.71 299.73 443.27 397.55 273.82 330.56 263.5"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "235.25 205.24 199.42 143.18 400.03 143.18 376.8 183.41 456.88 171.06 509.45 80 90 80 168.26 215.57 235.25 205.24"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M646.32,345.72h94.91v13.73H630V167.26h16.36Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M846.24,359.45H830V167.26h16.23Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1091.16,336.61q-8.45,12-26.46,18.74t-40.33,6.73q-22.57,0-40.13-10.82t-27.19-30.62q-9.64-19.8-9.77-45.41V250.95q0-40,20.2-63.16t54.25-23.17q29.69,0,47.78,15.11T1091,221.38h-16.24q-3.56-21.18-17.23-32.11t-35.7-10.92q-26.92,0-42.64,19.15t-15.71,54v22.72q0,21.93,7.46,38.77t21.38,26.09q13.92,9.25,32,9.25,21,0,36-6.6,9.76-4.36,14.52-10.16V282h-51.61V268.24h67.85Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1333.71,359.45h-16.37V278.11H1207.53v81.33h-16.23V167.26h16.23v97.12h109.81V167.26h16.37Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1563.2,181h-65.87V359.45H1481.1V181h-65.73V167.26H1563.2Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1990.75,181h-65.87V359.45h-16.23V181h-65.73V167.26h147.83Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M2147.65,279.33h-55.84v80.12h-16.36V167.26h62.43q30.75,0,48,14.9t17.29,41.66a52,52,0,0,1-10.83,32.56q-10.82,14.11-29,19.51l48,81.83v1.72h-17.29Zm-55.84-13.73h49.76q20.45,0,32.86-11.63t12.41-30.14q0-20.36-12.93-31.59T2137.61,181h-45.8Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M2407.62,278.11h-89.88v67.61h103.35v13.73H2301.5V167.26h118.92V181H2317.73v83.39h89.88Z"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "2892.79 183.67 2892.79 183.67 2816.23 326.97 2724.06 154.45 2724.06 189.54 2724.06 359.75 2739.67 359.75 2739.67 218.3 2816.26 359.42 2892.79 218.32 2892.79 359.75 2908.4 359.75 2908.4 189.54 2908.4 154.45 2892.79 183.67"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "2649.77 359.45 2569.47 154.54 2569.47 154.53 2569.46 154.53 2569.46 154.53 2569.46 154.54 2489.16 359.45 2506.19 359.45 2569.46 194.32 2632.74 359.45 2649.77 359.45"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1764.57,287q-6.73-10.56-20.06-18.15a131.55,131.55,0,0,0-21.47-9.18l-7.64,13.49q19.65,6.61,28.32,13.77,11.22,9.3,11.22,25.28,0,16.37-13.6,26.26t-36,9.9c-11.35,0-21.05-1.94-29.35-5.51l-7,12.33a94,94,0,0,0,36.33,6.91q29.7,0,47.85-13.73t18.15-36.43Q1771.3,297.55,1764.57,287Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1659.11,250.93c7.28,5.25,18,10.18,32.13,14.79l7.72-13.38q-21-6.41-31.29-14.49Q1655.95,228.61,1656,214q0-15.83,13-25.66t35-9.83c13.12,0,23.78,3.19,32.26,9.21l7.23-12.51c-1.71-1-3.43-2.1-5.3-3q-15.09-7.38-34.18-7.38-28.19,0-46.31,13.76t-18.11,35.77Q1639.62,237,1659.11,250.93Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1744.34,268.78a129.23,129.23,0,0,0-21.68-9.32l-7.79,13.49c13.28,4.44,22.87,9.06,28.68,13.88q11.2,9.29,11.2,25.23,0,16.33-13.57,26.21t-36,9.88c-11.8,0-21.85-2-30.34-5.91l-7.08,12.26.2.1a93.63,93.63,0,0,0,37.22,7.25q29.64,0,47.75-13.7t18.11-36.36q0-14.36-6.72-24.9T1744.34,268.78Z"
}));
var IconMap = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  YouTube,
  YouTubeDuo,
  Facebook,
  FacebookCircle,
  Twitch,
  TwitchDuo,
  Twitter,
  LinkedIn,
  Lightstream,
  LightstreamWithText
}, Symbol.toStringTag, { value: "Module" }));
const nudge = (props) => {
  if (!(props.nudgeUp || props.nudgeDown || props.nudgeRight || props.nudgeLeft))
    return;
  return {
    position: "relative",
    top: props.nudgeDown,
    left: props.nudgeRight,
    right: props.nudgeLeft,
    bottom: props.nudgeUp
  };
};
const SVGWrapper = ({
  children,
  width,
  height,
  color: color2,
  colorWeight = 0,
  marginLeft,
  marginTop,
  marginRight,
  marginBottom,
  className,
  ...props
}) => {
  if (color2) {
    Color[color2](colorWeight);
  }
  return /* @__PURE__ */ React.createElement("div", {
    className,
    style: {
      ...nudge(props),
      display: "flex",
      justifyContent: "center",
      flexBasis: width || "auto",
      flexShrink: 0,
      width,
      height: height || width && "fit-content",
      marginLeft,
      marginTop,
      marginBottom,
      marginRight
    }
  }, children);
};
const Icon = ({
  name: name2,
  ...props
}) => {
  return /* @__PURE__ */ React.createElement(SVGWrapper, {
    ...props
  }, IconMap[name2]);
};
const dragImageSvg = `
  <svg height="75" width="120" viewBox="0 0 120 75" xmlns="http://www.w3.org/2000/svg" style="">
    <rect width="120" height="75" rx="3" style="
      opacity: 0.4;
      stroke: white;
      stroke-width: 3px;
      stroke-opacity: 0.7;
    "/>
  </svg>`;
let dragImage;
const loadDragImage = () => {
  if (dragImage)
    return dragImage;
  dragImage = new Image();
  dragImage.src = URL.createObjectURL(new Blob([dragImageSvg], {
    type: "image/svg+xml"
  }));
  return dragImage;
};
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: null
    };
  }
  componentDidCatch(error, info) {
    log$1.warn(error, info);
  }
  static getDerivedStateFromError() {
    return {
      error: true
    };
  }
  render() {
    if (this.state.error)
      return null;
    return this.props.children;
  }
}
const onDrop = async (data2, e2) => {
  e2.preventDefault();
  e2.stopPropagation();
  const {
    dropNodeId,
    dropType,
    project
  } = data2;
  const dragNodeId = e2.dataTransfer.getData("text/plain");
  log$1.debug("Compositor: Dropping", {
    dropType,
    dragNodeId,
    dropNodeId
  });
  if (dropNodeId === dragNodeId)
    return;
  const [dragNode, dropNode, dragParent, dropParent] = await Promise.all([project.compositor.get(dragNodeId), project.compositor.get(dropNodeId), project.compositor.getParent(dragNodeId), project.compositor.getParent(dropNodeId)]);
  if (dropType === "layout") {
    if (dragParent.id === dropNodeId)
      return;
    return CoreContext.Command.moveNode({
      projectId: project.id,
      nodeId: dragNode.id,
      parentId: dropNode.id
    });
  } else {
    if (dragParent.id !== (dropParent == null ? void 0 : dropParent.id)) {
      return CoreContext.Command.swapNodes({
        projectId: project.id,
        nodeAId: dragNode.id,
        nodeBId: dropNode.id
      });
    }
  }
  const childIds = dragParent.children.map((x) => x.id);
  return CoreContext.Command.reorderNodes({
    projectId: project.id,
    parentId: dragParent.id,
    childIds: swapItems(dragNode.id, dropNode.id, childIds)
  });
};
let foundDropTarget = false;
const ElementTree = (props) => {
  var _a2, _b, _c;
  const isDragging = useRef(false);
  const interactiveRef = useRef();
  const transformRef = useRef();
  const rootRef = useRef();
  const {
    project,
    interactive = true,
    onElementDoubleClick,
    checkIsDragTarget,
    checkIsDropTarget
  } = useContext(CompositorContext);
  const {
    nodeId
  } = props;
  const node = project.compositor.get(nodeId);
  if (!node)
    return null;
  const element = CoreContext.compositor.getElement(node);
  const layout = node.props.layout || "Row";
  const isDragTarget = interactive && checkIsDragTarget(node);
  const isDropTarget = interactive && checkIsDropTarget(node);
  let layoutDragHandlers = isDropTarget ? {
    onDrop: (e2) => {
      foundDropTarget = true;
      return onDrop({
        dropType: "layout",
        dropNodeId: node.id,
        project
      }, e2);
    },
    onDragOver: (e2) => {
      var _a3;
      e2.preventDefault();
      e2.stopPropagation();
      (_a3 = rootRef.current) == null ? void 0 : _a3.toggleAttribute("data-layout-drop-target-active", true);
    },
    onDragLeave: (e2) => {
      var _a3;
      e2.preventDefault();
      e2.stopPropagation();
      (_a3 = rootRef.current) == null ? void 0 : _a3.toggleAttribute("data-layout-drop-target-active", false);
    }
  } : {};
  let transformDragHandlers = isDragTarget ? {
    draggable: true,
    ondrop: (e2) => {
      foundDropTarget = true;
      return onDrop({
        dropType: "transform",
        dropNodeId: node.id,
        project
      }, e2);
    },
    ondragstart: (e2) => {
      var _a3;
      isDragging.current = true;
      wrapperEl.toggleAttribute("data-dragging", true);
      log$1.debug("Compositor: Dragging", node.id);
      foundDropTarget = false;
      e2.dataTransfer.setData("text/plain", node.id);
      e2.dataTransfer.dropEffect = "move";
      e2.dataTransfer.setDragImage(dragImage, 10, 10);
      (_a3 = rootRef.current) == null ? void 0 : _a3.toggleAttribute("data-drag-target-active", true);
      window.__dragging = true;
    },
    ondragend: (e2) => {
      var _a3;
      isDragging.current = false;
      if (!foundDropTarget) {
        log$1.info("Compositor: No drop target - deleting node", node);
        CoreContext.Command.deleteNode({
          nodeId: node.id
        });
      }
      wrapperEl.toggleAttribute("data-dragging", true);
      log$1.debug("Compositor: DragEnd", e2);
      (_a3 = rootRef.current) == null ? void 0 : _a3.toggleAttribute("data-drag-target-active", false);
      wrapperEl.querySelectorAll("[data-item]").forEach((x) => {
        x.toggleAttribute("data-drag-target-active", false);
        x.toggleAttribute("data-layout-drop-target-active", false);
        x.toggleAttribute("data-transform-drop-target-active", false);
      });
      window.__dragging = false;
    },
    ondragover: (e2) => {
      var _a3;
      e2.preventDefault();
      e2.stopPropagation();
      if (isDragging.current)
        return;
      (_a3 = rootRef.current) == null ? void 0 : _a3.toggleAttribute("data-transform-drop-target-active", true);
    },
    ondragleave: (e2) => {
      var _a3;
      e2.preventDefault();
      e2.stopPropagation();
      (_a3 = rootRef.current) == null ? void 0 : _a3.toggleAttribute("data-transform-drop-target-active", false);
    }
  } : {};
  useEffect(() => {
    if (transformRef.current && element) {
      transformRef.current.appendChild(element.root);
      Object.assign(transformRef.current.style, {
        width: "100%",
        height: "100%",
        position: "relative",
        overflow: "hidden"
      });
      Object.assign(element.root.style, {
        pointerEvents: isDragTarget ? "all" : "none",
        width: "100%",
        height: "100%",
        position: "relative",
        ...node.props.style || {}
      });
    }
  }, [transformRef.current, element]);
  useEffect(() => {
    const onDoubleClick = isDragTarget ? () => onElementDoubleClick(node) : () => {
    };
    if (interactiveRef.current) {
      Object.assign(interactiveRef.current, transformDragHandlers);
      Object.assign(interactiveRef.current.style, {
        pointerEvents: isDragTarget ? "all" : "none"
      });
      interactiveRef.current.addEventListener("dblclick", onDoubleClick);
    }
    return () => {
      var _a3;
      (_a3 = interactiveRef.current) == null ? void 0 : _a3.removeEventListener("dblclick", onDoubleClick);
    };
  }, [interactiveRef.current]);
  const layoutProps = {
    layout,
    ...(_a2 = node.props.layoutProps) != null ? _a2 : {}
  };
  return /* @__PURE__ */ React.createElement("div", {
    ref: rootRef,
    "data-id": node.id + "-x",
    "data-item": true,
    ...isDragTarget && {
      "data-drag-target": true
    },
    ...isDropTarget && {
      "data-drop-target": true
    },
    ...layoutDragHandlers,
    style: {
      position: "relative",
      width: ((_b = node.props.size) == null ? void 0 : _b.x) || "100%",
      height: ((_c = node.props.size) == null ? void 0 : _c.y) || "100%",
      pointerEvents: "none"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    className: "interactive-overlay",
    ref: interactiveRef,
    style: {
      height: "100%",
      width: "100%",
      position: "absolute",
      zIndex: 2
    }
  }), /* @__PURE__ */ React.createElement("div", {
    className: "item-element",
    style: {
      display: "flex",
      flex: "0 0 auto",
      justifyContent: "center",
      width: "100%",
      height: "100%"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    ref: transformRef
  }), /* @__PURE__ */ React.createElement(ErrorBoundary, null, /* @__PURE__ */ React.createElement("ls-layout", {
    "data-id": node.id + "-x",
    props: JSON.stringify(layoutProps),
    layout
  }, node.children.map((x) => /* @__PURE__ */ React.createElement(ElementTree, {
    key: x.id,
    nodeId: x.id
  }))))));
};
const Root = (props) => {
  const {
    project
  } = useContext(CompositorContext);
  const [tree, setTree] = useState(null);
  useEffect(() => {
    setTree(project.compositor.renderTree());
    return CoreContext.onInternal("NodeChanged", () => {
      setTree(project.compositor.renderTree());
    });
  }, []);
  useEffect(() => {
    const root2 = project.compositor.getRoot();
    const {
      x: rootWidth
    } = root2.props.size;
    const updateCSS = () => {
      var _a2, _b, _c, _d, _e, _f;
      const {
        bannerStyle = BannerStyle.DEFAULT,
        primaryColor = "#ABABAB",
        showNameBanners
      } = (_a2 = project.props) != null ? _a2 : {};
      const logoPosition = (_f = (_e = (_b = project.props) == null ? void 0 : _b.logoPosition) != null ? _e : (_d = (_c = project.props) == null ? void 0 : _c.logo) == null ? void 0 : _d.logoPosition) != null ? _f : LogoPosition.TopRight;
      if (!bannerStyle || !primaryColor || !logoPosition)
        return;
      const CSS = themes[bannerStyle](primaryColor, showNameBanners, rootWidth / 1920);
      const logoCSS = themes[logoPosition](rootWidth / 1920);
      props.setStyle(`${CSS} ${logoCSS}` || "");
    };
    updateCSS();
    return CoreContext.onInternal("ProjectChanged", updateCSS);
  }, [project]);
  if (!tree)
    return null;
  return /* @__PURE__ */ React.createElement("div", {
    ...{
      onDrop: (e2) => {
        foundDropTarget = true;
        e2.preventDefault();
      },
      onDragOver: (e2) => {
        e2.preventDefault();
      },
      onDragLeave: (e2) => {
        e2.preventDefault();
      }
    },
    style: {
      userSelect: "none",
      width: `${tree.props.size.x + PADDING * 2}px`,
      height: `${tree.props.size.y + PADDING * 2}px`,
      margin: PADDING + "px"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    style: {
      width: "100%",
      height: "100%",
      overflow: "hidden"
    }
  }, /* @__PURE__ */ React.createElement(ElementTree, {
    nodeId: tree.id
  })));
};
let wrapperEl;
let customStyleEl;
const PADDING = 0;
const render$1 = (settings) => {
  const {
    containerEl,
    projectId,
    dragAndDrop = false,
    dblClickShowcase = dragAndDrop,
    checkDragTarget = scenelessProjectDragCheck,
    checkDropTarget = scenelessProjectDropCheck
  } = settings;
  const project = getProject(projectId);
  CoreContext.clients.LayoutApi().subscribeToLayout(project.layoutApi.layoutId);
  loadDragImage();
  const onElementDoubleClick = settings.onElementDoubleClick || dblClickShowcase && scenelessProjectDoubleClick(project);
  if (!containerEl || !project)
    return;
  if (!containerEl.shadowRoot) {
    containerEl.attachShadow({
      mode: "open"
    });
    customStyleEl = document.createElement("style");
    const baseStyleEl = document.createElement("style");
    baseStyleEl.textContent = getStyle();
    wrapperEl = document.createElement("div");
    wrapperEl.id = "compositor-root";
    Object.assign(wrapperEl.style, {
      width: "100%",
      height: "100%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transformOrigin: "center"
    });
    containerEl.shadowRoot.appendChild(baseStyleEl);
    containerEl.shadowRoot.appendChild(customStyleEl);
    containerEl.shadowRoot.appendChild(wrapperEl);
    const resizeObserver2 = new ResizeObserver((entries) => {
      setScale();
    });
    resizeObserver2.observe(containerEl);
  }
  const root2 = project.compositor.getRoot();
  const {
    x: rootWidth,
    y: rootHeight
  } = root2.props.size;
  const setScale = () => {
    let {
      width,
      height
    } = containerEl.getBoundingClientRect();
    const containerRatio = width / height;
    const compositorRatio = rootWidth / rootHeight;
    let scale;
    if (width && height) {
      if (compositorRatio > containerRatio) {
        scale = width / (rootWidth + PADDING * 2);
      } else {
        scale = height / (rootHeight + PADDING * 2);
      }
    } else {
      scale = 1;
    }
    wrapperEl.style.willChange = `transform`;
    wrapperEl.style.transform = `scale(${scale}) translateZ(0)`;
    window.__scale = scale;
    render2();
  };
  const render2 = () => {
    ReactDOM.render(/* @__PURE__ */ React.createElement(CompositorProvider, {
      project,
      interactive: dragAndDrop,
      onElementDoubleClick,
      checkIsDropTarget: checkDropTarget,
      checkIsDragTarget: checkDragTarget
    }, /* @__PURE__ */ React.createElement(Root, {
      setStyle: (CSS) => {
        customStyleEl.textContent = CSS;
      }
    })), wrapperEl);
  };
  setScale();
};
const scenelessProjectDragCheck = (node) => {
  return node.props.name === "Participant" || node.props.sourceType === "RoomParticipant";
};
const scenelessProjectDropCheck = (node) => {
  return node.props.name === "Content";
};
const scenelessProjectDoubleClick = (project) => (node) => {
  var _a2;
  const content = project.compositor.nodes.find((x) => x.props.name === "Content");
  if (content) {
    const showcase = (_a2 = content.props.layoutProps) == null ? void 0 : _a2.showcase;
    CoreContext.Command.updateNode({
      nodeId: content.id,
      props: {
        layoutProps: {
          ...content.props.layoutProps,
          showcase: showcase === node.id ? null : node.id
        }
      }
    });
  }
};
const CompositorContext = React.createContext({
  interactive: false,
  project: null,
  checkIsDragTarget: () => false,
  checkIsDropTarget: () => false,
  onElementDoubleClick: () => {
  }
});
const CompositorProvider = ({
  children,
  ...props
}) => {
  return /* @__PURE__ */ React.createElement(CompositorContext.Provider, {
    value: {
      ...props
    }
  }, children);
};
const getStyle = () => `
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Arial';
}

video {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.NameBanner {
  top: 100%;
  transform: translateY(-100%);
  left: 0;
  height: 30px;
  background: linear-gradient(90deg, rgba(0, 0, 0, 0.5) 50%, rgba(0, 0, 0, 0) 100%);
  padding: 0px 0px 0px 10px;
  color: rgba(255, 255, 255, 0.9);
  font-weight: bold;
  line-height: 30px;
  width: 100%;
  font-size: 28px;
  position: absolute;
}

ls-layout[layout="Presentation"][props*="\\"cover\\"\\:true"] > :first-child .NameBanner {
  top: 0% !important;
  transform: translateY(0%) !important;
}

[layout="Layered"] > [data-item] {
  transform: scale(1.003) !important;
}
[layout="Layered"] > [data-item]:nth-child(2) {
  transform: scale(1.0015) !important;
}
[layout="Layered"] > [data-item]:nth-child(1) {
  transform: scale(1) !important;
}

.logo {
  position: absolute !important;
}

#compositor-root[data-dragging] {}

[data-drag-target] {}
[data-drag-target]:hover > .interactive-overlay {
  box-shadow: 0 0 0 3px inset rgba(255, 255, 255, 0.5);
  cursor: grab;
}
[data-drop-target] {}
[data-drop-target]:hover {}
[data-drag-target][data-drag-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset rgba(255, 255, 255, 0.2);
}
[data-drag-target][data-drag-target-active] > .item-element {
  opacity: 0.8;
}
[data-layout-drop-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset yellow;
}
[data-transform-drop-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset white;
}
`;
var LogoPosition = /* @__PURE__ */ ((LogoPosition2) => {
  LogoPosition2["TopLeft"] = "top-left";
  LogoPosition2["TopRight"] = "top-right";
  LogoPosition2["BottomLeft"] = "bottom-left";
  LogoPosition2["BottomRight"] = "bottom-right";
  return LogoPosition2;
})(LogoPosition || {});
var BannerStyle = /* @__PURE__ */ ((BannerStyle2) => {
  BannerStyle2["DEFAULT"] = "default";
  BannerStyle2["MINIMAL"] = "minimal";
  BannerStyle2["BUBBLE"] = "bubble";
  return BannerStyle2;
})(BannerStyle || {});
var PlatformType = /* @__PURE__ */ ((PlatformType2) => {
  PlatformType2["TWITCH"] = "twitch";
  PlatformType2["YOUTUBE"] = "youtube";
  return PlatformType2;
})(PlatformType || {});
const themes = {
  ["top-left"]: (scalar = 1280 / 1920) => {
    return `
      .wrapper {
       top:0;
       left:0;
    }`;
  },
  ["top-right"]: (scalar = 1280 / 1920) => {
    return `
      .wrapper {
       top:0;
       right:0;
    }`;
  },
  ["bottom-left"]: (scalar = 1280 / 1920) => {
    return `
      .wrapper {
       bottom:0;
       left:0;
    }`;
  },
  ["bottom-right"]: (scalar = 1280 / 1920) => {
    return `
      .wrapper {
       bottom:0;
       right:0;
    }`;
  },
  ["default"]: (primaryColor = "#ABABAB", showNameBanners = true, scalar = 1280 / 1920) => {
    const textColor = color(primaryColor).lightness() < 0.6 ? "#FFF" : "#000";
    const chatBadgeBackgroundColor = color(primaryColor).lightness() < 0.6 ? "#FFF" : "#000";
    const chatBadgeTextColor = color(primaryColor).lightness() < 0.6 ? "#000" : "#FFF";
    const scale = (px) => px * scalar + "px";
    return `
      .ChatOverlay {
        background: ${primaryColor} !important;
        margin-bottom: ${scale(40)} !important;
        transition: 300ms ease all;
        left: 0;

        /* Default Size 4 */
        font-size: ${scale(44)} !important;
        padding: ${scale(40)} ${scale(100)} !important;
        border-radius: ${scale(20)} !important;
      }
      
      .ChatOverlay-badge-icon {
          width:${scale(32)};
          height: ${scale(32)};
          fill: currentcolor;
          color: ${chatBadgeTextColor};
      }

       .ChatOverlay-badge-container {
          background-color:${chatBadgeBackgroundColor};
          display:flex;
          flex-direction:row;
          padding: ${scale(6)} ${scale(12)} ${scale(6)} ${scale(6)};
          border-radius: ${scale(10)};
          align-items: center;
          border-bottom-left-radius: 0px !important;
          position: relative;
          border: none;
          cursor: pointer;
       }
      
       .ChatOverlay-badge-username {
          color:${chatBadgeTextColor};
          padding:${scale(6)};
          font-size:${scale(18)};
          font-weight:700;
          text-transform: capitalize; 
       }
       
       .ChatOverlay-badge-container::before {
          content:"";
          width:15px;
          height:15px;
          background-color:${chatBadgeBackgroundColor};
          position: absolute;
          bottom:-14px;
          left:0;
          clip-path:polygon(0 100%, 12% 87%, 26% 73%, 45% 53%, 59% 40%, 71% 28%, 85% 14%, 100% 0, 0 0);
        }
       

       .ChatOverlay-avatar {
          height: ${scale(120)};
          width: ${scale(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }

      .Banner, .NameBanner, .ChatOverlay {
        background: ${primaryColor} !important;
        margin-bottom: ${scale(40)} !important;
        transition: 300ms ease all;
        left: 0;

        /* Default Size 4 */
        font-size: ${scale(44)} !important;
        padding: ${scale(40)} ${scale(100)} !important;
        border-top-right-radius: ${scale(20)} !important;
        border-bottom-right-radius: ${scale(20)} !important;
      }

      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${textColor} !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
      }

      .NameBanner {
        transform-origin: 0 100%;
        margin: 0 !important;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${showNameBanners && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      .NameBanner[data-size="4"] {
        padding: ${scale(40)} ${scale(100)} !important;
        font-size: ${scale(44)} !important;
        border-top-right-radius: ${scale(20)} !important;
        border-bottom-right-radius: ${scale(20)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${scale(12)} ${scale(30)} !important;
        font-size: ${scale(44)} !important;
        border-top-right-radius: ${scale(20)} !important;
        border-bottom-right-radius: ${scale(20)} !important;
      }
      .NameBanner[data-size="2"] {
        padding: ${scale(12)} ${scale(20)} !important;
        font-size: ${scale(28)} !important;
        border-top-right-radius: ${scale(16)} !important;
        border-bottom-right-radius: ${scale(16)} !important;
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${scale(8)} ${scale(8)} !important;
        font-size: ${scale(20)} !important;
        border-top-right-radius: ${scale(8)} !important;
        border-bottom-right-radius: ${scale(8)} !important;
      }
      .NameBanner[data-size="0"] {
        opacity: 0;
        transform: translateX(-100%);
      }
    `;
  },
  ["minimal"]: (primaryColor = "#ABABAB", showNameBanners = true, scalar = 1280 / 1920) => {
    const textColor = "white";
    const chatBadgeBackgroundColor = "#fff";
    const chatBadgeTextColor = "#000";
    const scale = (px) => px * scalar + "px";
    return `

      .ChatOverlay-badge-icon {
          width:${scale(32)};
          height: ${scale(32)};
          fill: currentcolor;
          color: ${chatBadgeTextColor};
      }

       .ChatOverlay-badge-container {
          background-color:${chatBadgeBackgroundColor};
          display:flex;
          flex-direction:row;
          padding: ${scale(6)} ${scale(12)} ${scale(6)} ${scale(6)};
          align-items: center;
          position: relative;
          border: none;
          cursor: pointer;
       }

       .ChatOverlay-badge-username {
          color:${chatBadgeTextColor};
          padding:${scale(6)};
          font-size:${scale(18)};
          font-weight:700;
          text-transform: capitalize; 
       }

       .ChatOverlay-avatar {
          height: ${scale(120)};
          width: ${scale(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }


    .Banner, .NameBanner, .ChatOverlay {
        background: ${color(primaryColor).fade(color(primaryColor).alpha() * 0.7).toString()} !important;
        padding: ${scale(40)} ${scale(40)} ${scale(40)} ${scale(60)} !important;
        position: relative !important;
        margin-bottom: ${scale(40)} !important;
        transition: 300ms ease all;
        font-size: ${scale(34)} !important;
        left: 0;
      }

      .Banner:before, .NameBanner:before, .ChatOverlay:before {
        z-index: 1;
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.6);
        transition: 300ms ease all;
        opacity: ${color(primaryColor).alpha()};
      }
      .Banner:after, .NameBanner:after, .ChatOverlay:after {
        z-index: 1;
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        transition: 300ms ease all;
        width: ${scale(20)};
        background: ${color(primaryColor)};
        opacity: ${color(primaryColor).alpha()};
      }
      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${textColor} !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
        position: relative;
        z-index: 2;
      }
      .Banner-header {
        font-size: ${scale(90)};
        position: relative;
        z-index: 2;
      }
      .NameBanner {
        transform-origin: 0 100%;
        margin: 0 !important;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${showNameBanners && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      .NameBanner[data-size="4"] {
        padding: ${scale(40)} ${scale(40)} ${scale(40)} ${scale(40 + 20)} !important;
        font-size: ${scale(34)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${scale(16)} ${scale(40)} ${scale(16)} ${scale(40 + 20)} !important;
        font-size: ${scale(34)} !important;
      }
      .NameBanner[data-size="2"] {
        padding: ${scale(12)} ${scale(24)} ${scale(12)} ${scale(24 + 20)} !important;
        font-size: ${scale(24)} !important;
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${scale(12)} ${scale(16)} ${scale(12)} ${scale(16 + 20)} !important;
        font-size: ${scale(18)} !important;
      }
      .NameBanner[data-size="0"] {
        opacity: 0 !important;
        transform: translateX(-100%);
      }
    `;
  },
  ["bubble"]: (primaryColor = "#ABABAB", showNameBanners = true, scalar = 1280 / 1920) => {
    const textColor = color(primaryColor).lightness() < 0.6 ? "#FFF" : "#000";
    const chatBadgeBackgroundColor = color(primaryColor).lightness() < 0.6 ? "#FFF" : "#000";
    const chatBadgeTextColor = color(primaryColor).lightness() < 0.6 ? "#000" : "#FFF";
    const scale = (px) => px * scalar + "px";
    return `
      .ChatOverlay-badge-icon {
          width:${scale(32)};
          height: ${scale(32)};
          fill: currentcolor;
          color: ${chatBadgeTextColor};
      }


       .ChatOverlay-badge-container {
          background-color:${chatBadgeBackgroundColor};
          display:flex;
          flex-direction:row;
          padding: ${scale(6)} ${scale(12)} ${scale(6)} ${scale(6)};
          align-items: center;
          z-index: 1;
          border: none;
          cursor: pointer;
          top: 0;
          margin-bottom: 2px;
          margin-left: -${scale(30)};
          border-radius: 30px;
       }

       .ChatOverlay-badge-username {
          color:${chatBadgeTextColor};
          padding:${scale(6)};
          font-size:${scale(18)};
          font-weight:700;
          text-transform: capitalize; 
       }

       .ChatOverlayAvatar-container {
          height: ${scale(120)};
          width: ${scale(120)};
          top: 0;
       }
       .ChatOverlay-avatar {
          height: ${scale(120)};
          width: ${scale(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }


      .Banner, .ChatOverlay {
        transform: translateX(-50%);
        left: 50%;
        margin-bottom: ${scale(40)} !important;
      }

      .Banner, .NameBanner, .ChatOverlay {
        background: ${color(primaryColor)} !important;
        color: ${textColor} !important;
        border-radius: 500px !important;
        transition: 300ms ease all;

        /* Default Style */
        border: 4px solid ${textColor} !important;
        padding: ${scale(40)} ${scale(80)} !important;
        font-size: ${scale(40)} !important;
      }
      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${textColor} !important;
        text-align: center !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
      }
      .NameBanner {
        transform-origin: 0% 100%;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${showNameBanners && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      ls-layout[layout="Presentation"][props*="\\"cover\\"\\:true"] > :first-child .NameBanner {
        top: 0% !important;
        transform: translateY(0%) !important;
        margin: ${scale(20)} ${scale(20)};
      }


      .NameBanner[data-size="4"] {
        padding: ${scale(40)} ${scale(80)} ${scale(40)} ${scale(80)} !important;
        font-size: ${scale(40)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${scale(12)} ${scale(30)} ${scale(12)} ${scale(30)} !important;
        font-size: ${scale(40)} !important;
        margin: -${scale(20)} ${scale(20)};
      }
      .NameBanner[data-size="2"] {
        padding: ${scale(12)} ${scale(30)} ${scale(12)} ${scale(30)} !important;
        font-size: ${scale(26)} !important;
        margin: -${scale(8)} ${scale(8)};
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${scale(8)} ${scale(16)} ${scale(8)} ${scale(16)} !important;
        font-size: ${scale(18)} !important;
        border-width: ${scale(2)} !important;
        margin: -${scale(16)} ${scale(8)};
      }
      .NameBanner[data-size="0"] {
        opacity: 0 !important;
        transform: translateX(-100%);
      }
    `;
  }
};
var compositor$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  render: render$1,
  CompositorContext,
  LogoPosition,
  BannerStyle,
  PlatformType
}, Symbol.toStringTag, { value: "Module" }));
const iconStyles = {
  twitch: {
    icon: "Twitch"
  },
  youtube: {
    icon: "YouTube"
  },
  facebook: {
    icon: "Facebook"
  }
};
const fixLink = (link) => {
  if (!link.startsWith("http:") && !link.startsWith("https:")) {
    return `https://${link}`;
  }
  return link;
};
const ChatOverlay = {
  name: "LS-ChatOverlay",
  sourceType: "ChatOverlay",
  create({
    onUpdate,
    onEvent
  }, initialProps) {
    const root2 = document.createElement("div");
    const project = getProject(CoreContext.state.activeProjectId);
    const projectRoot = project.compositor.getRoot();
    const {
      x: rootWidth
    } = projectRoot.props.size;
    const scalar = (rootWidth != null ? rootWidth : 1280) / 1920;
    const scale = (px) => px * scalar + "px";
    let globalProps;
    const getSize = (ele, canvas) => {
      const widthAsPercentage = ele.width / canvas.width;
      const heightAsPercentage = ele.height / canvas.height;
      if (heightAsPercentage >= 0.25 && widthAsPercentage >= 0.75) {
        return 4;
      }
      if (widthAsPercentage >= 0.75) {
        return 1;
      } else if (widthAsPercentage >= 0.5) {
        return -2;
      } else if (widthAsPercentage > 0.25) {
        return -3;
      }
      return -4;
    };
    CoreContext.onInternal("ProjectChanged", () => {
      var _a2;
      const {
        bannerStyle
      } = (_a2 = project.props) != null ? _a2 : {};
      if (bannerStyle) {
        render2({
          ...globalProps,
          metadata: {
            ...globalProps.metadata,
            bannerStyle
          }
        });
      }
    });
    const ChatMessageBubbleSegment = React.memo((props) => {
      var _a2, _b, _c;
      if ((props == null ? void 0 : props.type) === "emoticon") {
        if (((_a2 = props == null ? void 0 : props.data) == null ? void 0 : _a2.type) === "direct") {
          return /* @__PURE__ */ React.createElement("img", {
            src: (_b = props == null ? void 0 : props.data) == null ? void 0 : _b.url,
            style: {
              height: scale(36)
            },
            alt: props == null ? void 0 : props.text
          });
        }
      }
      if ((props == null ? void 0 : props.type) === "link") {
        return /* @__PURE__ */ React.createElement("a", {
          style: {
            color: "#FFF",
            wordBreak: "break-all"
          },
          target: "_blank",
          rel: "noreferrer",
          href: fixLink((_c = props == null ? void 0 : props.data) == null ? void 0 : _c.url)
        }, props == null ? void 0 : props.text);
      }
      return /* @__PURE__ */ React.createElement("span", null, props == null ? void 0 : props.text);
    });
    const LetterAvatar = (props) => {
      const avatarStyle = {
        height: `${props.height}`,
        width: `${props.width}`,
        background: props.background || "transparent",
        display: "inline-block",
        verticalAlign: "middle",
        borderRadius: "50%",
        fontSize: `${props.fontSize}`
      };
      return /* @__PURE__ */ React.createElement("div", {
        style: {
          ...avatarStyle,
          position: "relative",
          marginRight: props == null ? void 0 : props.marginRight
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          left: "50%",
          position: "absolute",
          top: "50%",
          transform: "translate(-50%, -50%)"
        }
      }, props.username.substring(0, 2).toUpperCase()));
    };
    const ChatOverlay2 = (props) => {
      const {
        message,
        id,
        username,
        metadata
      } = props || {};
      const [labelSize, setLabelSize] = useState(0);
      const {
        index: index2,
        platform,
        avatar,
        bannerStyle
      } = metadata || {};
      const platformStyle = useMemo(() => iconStyles[platform], [platform]);
      const ref2 = useRef();
      useLayoutEffect(() => {
        if (!ref2.current)
          return;
        const calculate = () => {
          const rect = ref2.current;
          if (rect) {
            setLabelSize(getSize({
              width: rect.clientWidth,
              height: rect.clientHeight
            }, {
              width: project.compositor.getRoot().props.size.x,
              height: project.compositor.getRoot().props.size.y
            }));
          }
        };
        const resizeObserver2 = new ResizeObserver((entries) => {
          calculate();
        });
        calculate();
        resizeObserver2.observe(ref2.current);
        return () => {
          if (ref2 == null ? void 0 : ref2.current) {
            resizeObserver2.unobserve(ref2 == null ? void 0 : ref2.current);
          }
        };
      }, [ref2.current, project]);
      return /* @__PURE__ */ React.createElement(APIKitAnimation, {
        id: `${id}_${index2}`,
        type: "chatoverlay",
        enter: APIKitAnimationTypes.SLIDE_IN_LEFT,
        exit: APIKitAnimationTypes.SLIDE_OUT_LEFT,
        duration: 200
      }, /* @__PURE__ */ React.createElement("div", {
        className: "ChatOverlayContainer",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "flex-start",
          alignItems: "flex-end",
          marginLeft: bannerStyle !== BannerStyle.BUBBLE ? "5%" : "0px"
        }
      }, bannerStyle !== BannerStyle.BUBBLE ? /* @__PURE__ */ React.createElement("div", {
        style: {
          width: "100%",
          display: "flex"
        }
      }, avatar ? /* @__PURE__ */ React.createElement("span", {
        style: {
          marginRight: "20px"
        }
      }, /* @__PURE__ */ React.createElement("img", {
        src: avatar,
        className: "ChatOverlay-avatar"
      })) : /* @__PURE__ */ React.createElement(LetterAvatar, {
        height: scale(110),
        width: scale(120),
        background: primary(500),
        username,
        marginRight: 20,
        fontSize: scale(30)
      }), /* @__PURE__ */ React.createElement("div", {
        style: {
          width: "100%"
        }
      }, username && /* @__PURE__ */ React.createElement("button", {
        className: "ChatOverlay-badge-container"
      }, (platformStyle == null ? void 0 : platformStyle.icon) && /* @__PURE__ */ React.createElement(Icon, {
        className: "ChatOverlay-badge-icon",
        name: platformStyle == null ? void 0 : platformStyle.icon
      }), /* @__PURE__ */ React.createElement("div", {
        className: "ChatOverlay-badge-username"
      }, username)), /* @__PURE__ */ React.createElement("div", {
        className: "ChatOverlay",
        style: {
          padding: 10,
          background: "orange",
          width: "fit-content",
          height: "fit-content",
          maxWidth: "84%",
          position: "relative"
        }
      }, message && /* @__PURE__ */ React.createElement("div", {
        className: "ChatOverlay-body",
        style: {
          gap: 10,
          display: "flex",
          alignItems: "center",
          flexWrap: "wrap",
          verticalAlign: "middle"
        }
      }, message.map((part, index22) => /* @__PURE__ */ React.createElement(ChatMessageBubbleSegment, {
        key: index22,
        ...part
      })))))) : /* @__PURE__ */ React.createElement("div", {
        style: {
          width: "100%",
          display: "flex"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "ChatOverlay",
        style: {
          padding: 10,
          background: "orange",
          width: "fit-content",
          height: "fit-content",
          maxWidth: "84%",
          position: "relative"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          display: "flex",
          marginTop: `-${scale(160)}`,
          alignItems: "flex-end",
          padding: `${scale(14)} ${scale(0)} ${scale(14)} ${scale(0)}`,
          marginLeft: `${labelSize * 10}px`
        }
      }, avatar ? /* @__PURE__ */ React.createElement("div", {
        className: "ChatOverlayAvatar-container"
      }, /* @__PURE__ */ React.createElement("img", {
        src: avatar,
        className: "ChatOverlay-avatar"
      })) : /* @__PURE__ */ React.createElement("div", {
        className: "ChatOverlayAvatar-container"
      }, /* @__PURE__ */ React.createElement(LetterAvatar, {
        height: scale(120),
        width: scale(120),
        background: primary(500),
        username,
        fontSize: scale(30)
      })), username && /* @__PURE__ */ React.createElement("button", {
        className: "ChatOverlay-badge-container"
      }, (platformStyle == null ? void 0 : platformStyle.icon) && /* @__PURE__ */ React.createElement(Icon, {
        className: "ChatOverlay-badge-icon",
        name: platformStyle == null ? void 0 : platformStyle.icon
      }), /* @__PURE__ */ React.createElement("div", {
        className: "ChatOverlay-badge-username"
      }, username))), message && /* @__PURE__ */ React.createElement("div", {
        ref: ref2,
        className: "ChatOverlay-body",
        style: {
          gap: 10,
          alignItems: "center",
          flexWrap: "wrap",
          verticalAlign: "middle"
        }
      }, message.map((part, index22) => /* @__PURE__ */ React.createElement(ChatMessageBubbleSegment, {
        key: index22,
        ...part
      })))))));
    };
    const render2 = (rest) => ReactDOM.render(/* @__PURE__ */ React.createElement(ChatOverlay2, {
      ...rest
    }), root2);
    onUpdate((props) => {
      var _a2;
      const {
        bannerStyle = BannerStyle.DEFAULT
      } = (_a2 = project.props) != null ? _a2 : {};
      globalProps = {
        ...props,
        metadata: {
          ...props.metadata,
          bannerStyle
        }
      };
      render2(globalProps);
    });
    return {
      root: root2
    };
  }
};
const Background$1 = {
  name: "LS-Background",
  sourceType: "Background",
  create({
    onUpdate,
    onRemove
  }, {
    sourceProps
  }) {
    onRemove(() => {
      clearInterval(interval);
    });
    const root2 = document.createElement("div");
    const role = getProject(CoreContext.state.activeProjectId).role;
    let interval;
    const Video3 = ({
      source: source2,
      setStartAnimation
    }) => {
      var _a2, _b;
      const {
        src,
        type,
        meta,
        loop
      } = (source2 == null ? void 0 : source2.sourceProps) || {};
      const {
        id,
        sourceType
      } = source2 || {};
      const [refId, setRefId] = React.useState(null);
      const videoRef = React.useRef(null);
      console.log("Updated current time", (_a2 = videoRef == null ? void 0 : videoRef.current) == null ? void 0 : _a2.currentTime);
      const handleRect = React.useCallback((node) => {
        videoRef.current = node;
        setRefId(node ? node.id : null);
      }, []);
      const onLoadedData = React.useCallback(() => {
        if (videoRef == null ? void 0 : videoRef.current) {
          videoRef.current.play().catch(() => {
            var _a3;
            videoRef.current.muted = true;
            (_a3 = videoRef.current) == null ? void 0 : _a3.play();
          });
        }
      }, [src]);
      const onEnded = React.useCallback(() => {
        if (interval) {
          clearInterval(interval);
        }
        if (hasPermission(role, Permission.UpdateProject)) {
          trigger$1("VideoEnded", {
            id,
            category: type
          });
        }
      }, [src]);
      React.useEffect(() => {
        if (meta && (videoRef == null ? void 0 : videoRef.current) && refId) {
          if (hasPermission(role, Permission.ManageSelf)) {
            if (meta == null ? void 0 : meta.time) {
              videoRef.current.currentTime = Number(meta == null ? void 0 : meta.time);
            }
          }
        }
      }, [meta == null ? void 0 : meta.time, refId]);
      React.useEffect(() => {
        return () => {
          if (interval) {
            clearInterval(interval);
          }
        };
      }, [id]);
      React.useEffect(() => {
        if (!refId) {
          if (interval) {
            clearInterval(interval);
          }
        } else {
          if (videoRef.current) {
            videoRef.current.src = src;
            videoRef.current.play().catch(() => {
              videoRef.current.muted = true;
              videoRef.current.play();
            });
            if (hasPermission(role, Permission.UpdateProject)) {
              interval = setInterval(() => {
                if (videoRef.current.duration) {
                  const timePending = videoRef.current.duration - videoRef.current.currentTime;
                  trigger$1("VideoTimeUpdate", {
                    category: sourceType,
                    id,
                    time: Math.floor(timePending)
                  });
                }
              }, 1e3);
            }
          }
        }
      }, [refId]);
      return /* @__PURE__ */ React.createElement(React.Fragment, {
        key: id
      }, src && /* @__PURE__ */ React.createElement("video", {
        loop,
        id,
        ref: handleRect,
        style: {
          ...(_b = sourceProps == null ? void 0 : sourceProps.meta) == null ? void 0 : _b.style,
          ...meta.style
        },
        onLoadedData,
        onEnded,
        onCanPlay: () => setStartAnimation(true)
      }));
    };
    const Image3 = ({
      source: source2,
      setStartAnimation
    }) => {
      var _a2;
      const {
        src,
        meta,
        type
      } = (source2 == null ? void 0 : source2.sourceProps) || {};
      const {
        id
      } = source2 || {};
      return /* @__PURE__ */ React.createElement(React.Fragment, {
        key: id
      }, src && /* @__PURE__ */ React.createElement("img", {
        style: {
          ...(_a2 = sourceProps == null ? void 0 : sourceProps.meta) == null ? void 0 : _a2.style,
          ...meta == null ? void 0 : meta.style
        },
        src,
        onLoad: () => setStartAnimation(true)
      }));
    };
    const Background2 = ({
      source: source2
    }) => {
      const {
        type
      } = source2.sourceProps;
      const {
        id
      } = source2 || {};
      const [startAnimation, setStartAnimation] = React.useState(false);
      useEffect(() => {
        setStartAnimation(false);
      }, [id]);
      return /* @__PURE__ */ React.createElement(APIKitAnimation, {
        id,
        type: "background",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: startAnimation ? 1 : 0
        },
        className: `backgroundContainer background-transition`
      }, id && type === "image" && /* @__PURE__ */ React.createElement(Image3, {
        source: source2,
        setStartAnimation
      }), id && type === "video" && /* @__PURE__ */ React.createElement(Video3, {
        source: source2,
        setStartAnimation
      })));
    };
    const render2 = (source2) => ReactDOM.render(/* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Background2, {
      source: source2
    })), root2);
    onUpdate((props) => {
      render2({
        ...props
      });
    });
    return {
      root: root2
    };
  }
};
const SourceTriggerMap = [{
  sourceType: "Overlay",
  trigger: "OverlayMetadataUpdate"
}, {
  sourceType: "Background",
  trigger: "BackgroundMetadataUpdate"
}];
const Video2 = {
  name: "LS-Video-2",
  sourceType: "Video2",
  props: {
    id: {
      type: String,
      required: true
    }
  },
  useSource(sources2, props) {
    return sources2.find((x) => x.props.type === props.id);
  },
  create({
    onUpdate,
    onNewSource,
    onRemove
  }, initialProps) {
    onRemove(() => {
      clearInterval(interval);
    });
    const root2 = document.createElement("div");
    const room = getProjectRoom(CoreContext.state.activeProjectId);
    const role = getProject(CoreContext.state.activeProjectId).role;
    let source2;
    let interval;
    const Video3 = ({
      source: source22
    }) => {
      var _a2;
      const SourceTrigger = SourceTriggerMap.find((x) => x.sourceType === initialProps.proxySource);
      const {
        src,
        type,
        meta,
        loop
      } = (source22 == null ? void 0 : source22.value) || {};
      const {
        id
      } = source22 || {};
      const [refId, setRefId] = React.useState(null);
      const videoRef = React.useRef(null);
      const [startAnimation, setStartAnimation] = React.useState(false);
      console.log("Updated current time", (_a2 = videoRef == null ? void 0 : videoRef.current) == null ? void 0 : _a2.currentTime);
      React.useEffect(() => {
        setStartAnimation(false);
      }, [id]);
      const handleRect = React.useCallback((node) => {
        videoRef.current = node;
        setRefId(node ? node.id : null);
      }, []);
      const onLoadedData = React.useCallback(() => {
        if (videoRef == null ? void 0 : videoRef.current) {
          videoRef.current.play().catch(() => {
            var _a3;
            videoRef.current.muted = true;
            (_a3 = videoRef.current) == null ? void 0 : _a3.play();
          });
        }
      }, [src]);
      const onEnded = React.useCallback(() => {
        if (interval) {
          clearInterval(interval);
        }
        trigger$1("VideoEnded", {
          id,
          category: type
        });
      }, [src]);
      React.useEffect(() => {
        if (meta && (videoRef == null ? void 0 : videoRef.current) && refId) {
          if (hasPermission(role, Permission.ManageSelf)) {
            videoRef.current.currentTime = Number(meta == null ? void 0 : meta.time);
          }
        }
      }, [meta == null ? void 0 : meta.time, refId]);
      React.useEffect(() => {
        return () => {
          if (interval) {
            clearInterval(interval);
          }
        };
      }, [id]);
      React.useEffect(() => {
        if (!refId) {
          if (interval) {
            clearInterval(interval);
          }
        } else {
          if (videoRef.current) {
            videoRef.current.src = src;
            if (loop) {
              videoRef.current.loop = Boolean(loop);
            }
            videoRef.current.play().catch(() => {
              videoRef.current.muted = true;
              videoRef.current.play();
            });
            interval = setInterval(() => {
              if (videoRef.current.duration) {
                const timePending = videoRef.current.duration - videoRef.current.currentTime;
                trigger$1("VideoTimeUpdate", {
                  category: type,
                  id,
                  time: Math.floor(timePending)
                });
              }
            }, 1e3);
            return room == null ? void 0 : room.onData((event2, senderId) => {
              var _a3, _b;
              if ((_a3 = videoRef == null ? void 0 : videoRef.current) == null ? void 0 : _a3.currentTime) {
                if (event2.type === "UserJoined" && hasPermission(role, Permission.ManageGuests)) {
                  triggerInternal$1(SourceTrigger.trigger, {
                    projectId: CoreContext.state.activeProjectId,
                    role,
                    sourceId: refId,
                    doTrigger: true,
                    metadata: {
                      time: Math.floor((_b = videoRef == null ? void 0 : videoRef.current) == null ? void 0 : _b.currentTime) || 0,
                      owner: room == null ? void 0 : room.participantId,
                      guest: senderId
                    }
                  });
                }
              }
            });
          }
        }
      }, [refId]);
      return /* @__PURE__ */ React.createElement(APIKitAnimation, {
        id,
        type: "video",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: startAnimation ? 1 : 0,
          width: "100%",
          height: "100%"
        },
        className: `video-transition`
      }, src && /* @__PURE__ */ React.createElement("video", {
        id,
        ref: handleRect,
        style: initialProps.style,
        ...initialProps.props,
        onLoadedData,
        onEnded,
        onCanPlayThrough: () => setStartAnimation(true)
      })));
    };
    const render2 = () => ReactDOM.render(/* @__PURE__ */ React.createElement(Video3, {
      source: source2
    }), root2);
    onUpdate(() => {
      render2();
    });
    onNewSource((_source) => {
      source2 = _source;
      render2();
    });
    return {
      root: root2
    };
  }
};
const Image2 = {
  name: "LS-Image-2",
  sourceType: "Image2",
  props: {
    id: {
      type: String,
      required: true
    }
  },
  useSource(sources2, props) {
    return sources2.find((x) => x.props.type === props.id);
  },
  create({
    onUpdate,
    onNewSource
  }, initialProps) {
    const root2 = document.createElement("div");
    let source2;
    const Image3 = ({
      source: source22
    }) => {
      const {
        src,
        meta
      } = (source22 == null ? void 0 : source22.value) || {};
      const {
        id
      } = source22 || {};
      const [startAnimation, setStartAnimation] = React.useState(false);
      React.useEffect(() => {
        setStartAnimation(false);
      }, [id]);
      return /* @__PURE__ */ React.createElement(APIKitAnimation, {
        id,
        type: "image",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: startAnimation ? 1 : 0,
          width: "100%",
          height: "100%"
        },
        className: `image-transition`
      }, src && /* @__PURE__ */ React.createElement("img", {
        style: {
          ...initialProps == null ? void 0 : initialProps.style,
          ...meta == null ? void 0 : meta.style
        },
        src,
        onLoad: () => setStartAnimation(true)
      })));
    };
    const render2 = () => ReactDOM.render(/* @__PURE__ */ React.createElement(Image3, {
      source: source2
    }), root2);
    onUpdate(() => {
      render2();
    });
    onNewSource((_source) => {
      source2 = _source;
      render2();
    });
    return {
      root: root2
    };
  }
};
var Transforms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RoomParticipant: RoomParticipant$1,
  Square,
  Image: Image$1,
  Element,
  Video,
  Banner: Banner$1,
  Logo: Logo$1,
  Overlay,
  ChatOverlay,
  Background: Background$1,
  Video2,
  Image2
}, Symbol.toStringTag, { value: "Module" }));
/*! (c) Andrea Giammarchi - ISC */
var self$1 = {};
try {
  self$1.WeakMap = WeakMap;
} catch (WeakMap2) {
  self$1.WeakMap = function(id, Object2) {
    var dP = Object2.defineProperty;
    var hOP = Object2.hasOwnProperty;
    var proto = WeakMap3.prototype;
    proto.delete = function(key) {
      return this.has(key) && delete key[this._];
    };
    proto.get = function(key) {
      return this.has(key) ? key[this._] : void 0;
    };
    proto.has = function(key) {
      return hOP.call(key, this._);
    };
    proto.set = function(key, value) {
      dP(key, this._, { configurable: true, value });
      return this;
    };
    return WeakMap3;
    function WeakMap3(iterable) {
      dP(this, "_", { value: "_@ungap/weakmap" + id++ });
      if (iterable)
        iterable.forEach(add2, this);
    }
    function add2(pair) {
      this.set(pair[0], pair[1]);
    }
  }(Math.random(), Object);
}
var WeakMap$1 = self$1.WeakMap;
/*! (c) Andrea Giammarchi - ISC */
var UID = "-" + Math.random().toFixed(6) + "%";
var UID_IE = false;
try {
  if (!function(template, content, tabindex) {
    return content in template && (template.innerHTML = "<p " + tabindex + '="' + UID + '"></p>', template[content].childNodes[0].getAttribute(tabindex) == UID);
  }(document.createElement("template"), "content", "tabindex")) {
    UID = "_dt: " + UID.slice(1, -1) + ";";
    UID_IE = true;
  }
} catch (meh) {
}
var UIDC = "<!--" + UID + "-->";
var COMMENT_NODE = 8;
var ELEMENT_NODE$1 = 1;
var TEXT_NODE = 3;
var SHOULD_USE_TEXT_CONTENT = /^(?:plaintext|script|style|textarea|title|xmp)$/i;
var VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;
/*! (c) Andrea Giammarchi - ISC */
function domsanitizer(template) {
  return template.join(UIDC).replace(selfClosing, fullClosing).replace(attrSeeker, attrReplacer);
}
var spaces = " \\f\\n\\r\\t";
var almostEverything = "[^" + spaces + `\\/>"'=]+`;
var attrName = "[" + spaces + "]+" + almostEverything;
var tagName = "<([A-Za-z]+[A-Za-z0-9:._-]*)((?:";
var attrPartials = `(?:\\s*=\\s*(?:'[^']*?'|"[^"]*?"|<[^>]*?>|` + almostEverything.replace("\\/", "") + "))?)";
var attrSeeker = new RegExp(tagName + attrName + attrPartials + "+)([" + spaces + "]*/?>)", "g");
var selfClosing = new RegExp(tagName + attrName + attrPartials + "*)([" + spaces + "]*/>)", "g");
var findAttributes = new RegExp("(" + attrName + `\\s*=\\s*)(['"]?)` + UIDC + "\\2", "gi");
function attrReplacer($0, $1, $2, $3) {
  return "<" + $1 + $2.replace(findAttributes, replaceAttributes) + $3;
}
function replaceAttributes($0, $1, $2) {
  return $1 + ($2 || '"') + UID + ($2 || '"');
}
function fullClosing($0, $1, $2) {
  return VOID_ELEMENTS.test($1) ? $0 : "<" + $1 + $2 + "></" + $1 + ">";
}
const { isArray } = Array;
const { indexOf, slice } = [];
var umap = (_) => ({
  get: (key) => _.get(key),
  set: (key, value) => (_.set(key, value), value)
});
const ELEMENT_NODE = 1;
const nodeType = 111;
const remove = ({ firstChild, lastChild }) => {
  const range = document.createRange();
  range.setStartAfter(firstChild);
  range.setEndAfter(lastChild);
  range.deleteContents();
  return firstChild;
};
const diffable = (node, operation) => node.nodeType === nodeType ? 1 / operation < 0 ? operation ? remove(node) : node.lastChild : operation ? node.valueOf() : node.firstChild : node;
const persistent = (fragment) => {
  const { childNodes } = fragment;
  const { length: length2 } = childNodes;
  if (length2 < 2)
    return length2 ? childNodes[0] : fragment;
  const nodes = slice.call(childNodes, 0);
  const firstChild = nodes[0];
  const lastChild = nodes[length2 - 1];
  return {
    ELEMENT_NODE,
    nodeType,
    firstChild,
    lastChild,
    valueOf() {
      if (childNodes.length !== length2) {
        let i2 = 0;
        while (i2 < length2)
          fragment.appendChild(nodes[i2++]);
      }
      return fragment;
    }
  };
};
/*! (c) Andrea Giammarchi - ISC */
var createContent = function(document2) {
  var FRAGMENT = "fragment";
  var TEMPLATE = "template";
  var HAS_CONTENT = "content" in create7(TEMPLATE);
  var createHTML = HAS_CONTENT ? function(html2) {
    var template = create7(TEMPLATE);
    template.innerHTML = html2;
    return template.content;
  } : function(html2) {
    var content = create7(FRAGMENT);
    var template = create7(TEMPLATE);
    var childNodes = null;
    if (/^[^\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html2)) {
      var selector = RegExp.$1;
      template.innerHTML = "<table>" + html2 + "</table>";
      childNodes = template.querySelectorAll(selector);
    } else {
      template.innerHTML = html2;
      childNodes = template.childNodes;
    }
    append(content, childNodes);
    return content;
  };
  return function createContent2(markup, type) {
    return (type === "svg" ? createSVG : createHTML)(markup);
  };
  function append(root2, childNodes) {
    var length2 = childNodes.length;
    while (length2--)
      root2.appendChild(childNodes[0]);
  }
  function create7(element) {
    return element === FRAGMENT ? document2.createDocumentFragment() : document2.createElementNS("http://www.w3.org/1999/xhtml", element);
  }
  function createSVG(svg2) {
    var content = create7(FRAGMENT);
    var template = create7("div");
    template.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg">' + svg2 + "</svg>";
    append(content, template.firstChild.childNodes);
    return content;
  }
}(document);
var udomdiff = (parentNode, a, b, get2, before) => {
  const bLength = b.length;
  let aEnd = a.length;
  let bEnd = bLength;
  let aStart = 0;
  let bStart = 0;
  let map2 = null;
  while (aStart < aEnd || bStart < bEnd) {
    if (aEnd === aStart) {
      const node = bEnd < bLength ? bStart ? get2(b[bStart - 1], -0).nextSibling : get2(b[bEnd - bStart], 0) : before;
      while (bStart < bEnd)
        parentNode.insertBefore(get2(b[bStart++], 1), node);
    } else if (bEnd === bStart) {
      while (aStart < aEnd) {
        if (!map2 || !map2.has(a[aStart]))
          parentNode.removeChild(get2(a[aStart], -1));
        aStart++;
      }
    } else if (a[aStart] === b[bStart]) {
      aStart++;
      bStart++;
    } else if (a[aEnd - 1] === b[bEnd - 1]) {
      aEnd--;
      bEnd--;
    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
      const node = get2(a[--aEnd], -1).nextSibling;
      parentNode.insertBefore(get2(b[bStart++], 1), get2(a[aStart++], -1).nextSibling);
      parentNode.insertBefore(get2(b[--bEnd], 1), node);
      a[aEnd] = b[bEnd];
    } else {
      if (!map2) {
        map2 = /* @__PURE__ */ new Map();
        let i2 = bStart;
        while (i2 < bEnd)
          map2.set(b[i2], i2++);
      }
      if (map2.has(a[aStart])) {
        const index2 = map2.get(a[aStart]);
        if (bStart < index2 && index2 < bEnd) {
          let i2 = aStart;
          let sequence = 1;
          while (++i2 < aEnd && i2 < bEnd && map2.get(a[i2]) === index2 + sequence)
            sequence++;
          if (sequence > index2 - bStart) {
            const node = get2(a[aStart], 0);
            while (bStart < index2)
              parentNode.insertBefore(get2(b[bStart++], 1), node);
          } else {
            parentNode.replaceChild(get2(b[bStart++], 1), get2(a[aStart++], -1));
          }
        } else
          aStart++;
      } else
        parentNode.removeChild(get2(a[aStart++], -1));
    }
  }
  return b;
};
/*! (c) Andrea Giammarchi - ISC */
var importNode = function(document2, appendChild, cloneNode, createTextNode, importNode2) {
  var native = importNode2 in document2;
  var fragment = document2.createDocumentFragment();
  fragment[appendChild](document2[createTextNode]("g"));
  fragment[appendChild](document2[createTextNode](""));
  var content = native ? document2[importNode2](fragment, true) : fragment[cloneNode](true);
  return content.childNodes.length < 2 ? function importNode3(node, deep) {
    var clone = node[cloneNode]();
    for (var childNodes = node.childNodes || [], length2 = childNodes.length, i2 = 0; deep && i2 < length2; i2++) {
      clone[appendChild](importNode3(childNodes[i2], deep));
    }
    return clone;
  } : native ? document2[importNode2] : function(node, deep) {
    return node[cloneNode](!!deep);
  };
}(document, "appendChild", "cloneNode", "createTextNode", "importNode");
var trim = "".trim || function() {
  return String(this).replace(/^\s+|\s+/g, "");
};
var normalizeAttributes = UID_IE ? function(attributes, parts) {
  var html2 = parts.join(" ");
  return parts.slice.call(attributes, 0).sort(function(left, right) {
    return html2.indexOf(left.name) <= html2.indexOf(right.name) ? -1 : 1;
  });
} : function(attributes, parts) {
  return parts.slice.call(attributes, 0);
};
function find(node, path) {
  var length2 = path.length;
  var i2 = 0;
  while (i2 < length2)
    node = node.childNodes[path[i2++]];
  return node;
}
function parse(node, holes, parts, path) {
  var childNodes = node.childNodes;
  var length2 = childNodes.length;
  var i2 = 0;
  while (i2 < length2) {
    var child = childNodes[i2];
    switch (child.nodeType) {
      case ELEMENT_NODE$1:
        var childPath = path.concat(i2);
        parseAttributes(child, holes, parts, childPath);
        parse(child, holes, parts, childPath);
        break;
      case COMMENT_NODE:
        var textContent = child.textContent;
        if (textContent === UID) {
          parts.shift();
          holes.push(SHOULD_USE_TEXT_CONTENT.test(node.nodeName) ? Text(node, path) : Any(child, path.concat(i2)));
        } else {
          switch (textContent.slice(0, 2)) {
            case "/*":
              if (textContent.slice(-2) !== "*/")
                break;
            case "\u{1F47B}":
              node.removeChild(child);
              i2--;
              length2--;
          }
        }
        break;
      case TEXT_NODE:
        if (SHOULD_USE_TEXT_CONTENT.test(node.nodeName) && trim.call(child.textContent) === UIDC) {
          parts.shift();
          holes.push(Text(node, path));
        }
        break;
    }
    i2++;
  }
}
function parseAttributes(node, holes, parts, path) {
  var attributes = node.attributes;
  var cache2 = [];
  var remove2 = [];
  var array = normalizeAttributes(attributes, parts);
  var length2 = array.length;
  var i2 = 0;
  while (i2 < length2) {
    var attribute2 = array[i2++];
    var direct = attribute2.value === UID;
    var sparse;
    if (direct || 1 < (sparse = attribute2.value.split(UIDC)).length) {
      var name2 = attribute2.name;
      if (cache2.indexOf(name2) < 0) {
        cache2.push(name2);
        var realName = parts.shift().replace(direct ? /^(?:|[\S\s]*?\s)(\S+?)\s*=\s*('|")?$/ : new RegExp("^(?:|[\\S\\s]*?\\s)(" + name2 + `)\\s*=\\s*('|")[\\S\\s]*`, "i"), "$1");
        var value = attributes[realName] || attributes[realName.toLowerCase()];
        if (direct)
          holes.push(Attr(value, path, realName, null));
        else {
          var skip4 = sparse.length - 2;
          while (skip4--)
            parts.shift();
          holes.push(Attr(value, path, realName, sparse));
        }
      }
      remove2.push(attribute2);
    }
  }
  length2 = remove2.length;
  i2 = 0;
  var cleanValue = 0 < length2 && UID_IE && !("ownerSVGElement" in node);
  while (i2 < length2) {
    var attr = remove2[i2++];
    if (cleanValue)
      attr.value = "";
    node.removeAttribute(attr.name);
  }
  var nodeName = node.nodeName;
  if (/^script$/i.test(nodeName)) {
    var script = document.createElement(nodeName);
    length2 = attributes.length;
    i2 = 0;
    while (i2 < length2)
      script.setAttributeNode(attributes[i2++].cloneNode(true));
    script.textContent = node.textContent;
    node.parentNode.replaceChild(script, node);
  }
}
function Any(node, path) {
  return {
    type: "any",
    node,
    path
  };
}
function Attr(node, path, name2, sparse) {
  return {
    type: "attr",
    node,
    path,
    name: name2,
    sparse
  };
}
function Text(node, path) {
  return {
    type: "text",
    node,
    path
  };
}
var parsed = umap(new WeakMap$1());
function createInfo(options, template) {
  var markup = (options.convert || domsanitizer)(template);
  var transform = options.transform;
  if (transform)
    markup = transform(markup);
  var content = createContent(markup, options.type);
  cleanContent(content);
  var holes = [];
  parse(content, holes, template.slice(0), []);
  return {
    content,
    updates: function(content2) {
      var updates = [];
      var len = holes.length;
      var i2 = 0;
      var off2 = 0;
      while (i2 < len) {
        var info = holes[i2++];
        var node = find(content2, info.path);
        switch (info.type) {
          case "any":
            updates.push({ fn: options.any(node, []), sparse: false });
            break;
          case "attr":
            var sparse = info.sparse;
            var fn = options.attribute(node, info.name, info.node);
            if (sparse === null)
              updates.push({ fn, sparse: false });
            else {
              off2 += sparse.length - 2;
              updates.push({ fn, sparse: true, values: sparse });
            }
            break;
          case "text":
            updates.push({ fn: options.text(node), sparse: false });
            node.textContent = "";
            break;
        }
      }
      len += off2;
      return function() {
        var length2 = arguments.length;
        if (len !== length2 - 1) {
          throw new Error(length2 - 1 + " values instead of " + len + "\n" + template.join("${value}"));
        }
        var i3 = 1;
        var off3 = 1;
        while (i3 < length2) {
          var update = updates[i3 - off3];
          if (update.sparse) {
            var values2 = update.values;
            var value = values2[0];
            var j = 1;
            var l = values2.length;
            off3 += l - 2;
            while (j < l)
              value += arguments[i3++] + values2[j++];
            update.fn(value);
          } else
            update.fn(arguments[i3++]);
        }
        return content2;
      };
    }
  };
}
function createDetails(options, template) {
  var info = parsed.get(template) || parsed.set(template, createInfo(options, template));
  return info.updates(importNode.call(document, info.content, true));
}
var empty = [];
function domtagger(options) {
  var previous = empty;
  var updates = cleanContent;
  return function(template) {
    if (previous !== template)
      updates = createDetails(options, previous = template);
    return updates.apply(null, arguments);
  };
}
function cleanContent(fragment) {
  var childNodes = fragment.childNodes;
  var i2 = childNodes.length;
  while (i2--) {
    var child = childNodes[i2];
    if (child.nodeType !== 1 && trim.call(child.textContent).length === 0) {
      fragment.removeChild(child);
    }
  }
}
/*! (c) Andrea Giammarchi - ISC */
var hyperStyle = function() {
  var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
  var hyphen = /([^A-Z])([A-Z]+)/g;
  return function hyperStyle2(node, original) {
    return "ownerSVGElement" in node ? svg2(node, original) : update(node.style, false);
  };
  function ized($0, $1, $2) {
    return $1 + "-" + $2.toLowerCase();
  }
  function svg2(node, original) {
    var style;
    if (original)
      style = original.cloneNode(true);
    else {
      node.setAttribute("style", "--hyper:style;");
      style = node.getAttributeNode("style");
    }
    style.value = "";
    node.setAttributeNode(style);
    return update(style, true);
  }
  function toStyle(object) {
    var key, css = [];
    for (key in object)
      css.push(key.replace(hyphen, ized), ":", object[key], ";");
    return css.join("");
  }
  function update(style, isSVG) {
    var oldType, oldValue;
    return function(newValue) {
      var info, key, styleValue, value;
      switch (typeof newValue) {
        case "object":
          if (newValue) {
            if (oldType === "object") {
              if (!isSVG) {
                if (oldValue !== newValue) {
                  for (key in oldValue) {
                    if (!(key in newValue)) {
                      style[key] = "";
                    }
                  }
                }
              }
            } else {
              if (isSVG)
                style.value = "";
              else
                style.cssText = "";
            }
            info = isSVG ? {} : style;
            for (key in newValue) {
              value = newValue[key];
              styleValue = typeof value === "number" && !IS_NON_DIMENSIONAL.test(key) ? value + "px" : value;
              if (!isSVG && /^--/.test(key))
                info.setProperty(key, styleValue);
              else
                info[key] = styleValue;
            }
            oldType = "object";
            if (isSVG)
              style.value = toStyle(oldValue = info);
            else
              oldValue = newValue;
            break;
          }
        default:
          if (oldValue != newValue) {
            oldType = "string";
            oldValue = newValue;
            if (isSVG)
              style.value = newValue || "";
            else
              style.cssText = newValue || "";
          }
          break;
      }
    };
  }
}();
const aria = (node) => (values2) => {
  for (const key in values2) {
    const name2 = key === "role" ? key : `aria-${key}`;
    const value = values2[key];
    if (value == null)
      node.removeAttribute(name2);
    else
      node.setAttribute(name2, value);
  }
};
const attribute = (node, name2) => {
  let oldValue, orphan = true;
  const attributeNode = document.createAttributeNS(null, name2);
  return (newValue) => {
    if (oldValue !== newValue) {
      oldValue = newValue;
      if (oldValue == null) {
        if (!orphan) {
          node.removeAttributeNode(attributeNode);
          orphan = true;
        }
      } else {
        attributeNode.value = newValue;
        if (orphan) {
          node.setAttributeNodeNS(attributeNode);
          orphan = false;
        }
      }
    }
  };
};
const boolean = (node, key, oldValue) => (newValue) => {
  if (oldValue !== !!newValue) {
    if (oldValue = !!newValue)
      node.setAttribute(key, "");
    else
      node.removeAttribute(key);
  }
};
const data = ({ dataset }) => (values2) => {
  for (const key in values2) {
    const value = values2[key];
    if (value == null)
      delete dataset[key];
    else
      dataset[key] = value;
  }
};
const event = (node, name2) => {
  let oldValue, type = name2.slice(2);
  if (!(name2 in node) && name2.toLowerCase() in node)
    type = type.toLowerCase();
  return (newValue) => {
    const info = isArray(newValue) ? newValue : [newValue, false];
    if (oldValue !== info[0]) {
      if (oldValue)
        node.removeEventListener(type, oldValue, info[1]);
      if (oldValue = info[0])
        node.addEventListener(type, oldValue, info[1]);
    }
  };
};
const ref = (node) => (value) => {
  if (typeof value === "function")
    value(node);
  else
    value.current = node;
};
const setter = (node, key) => key === "dataset" ? data(node) : (value) => {
  node[key] = value;
};
const hyperProperty = (node, name2) => {
  let oldValue;
  return (newValue) => {
    if (oldValue !== newValue) {
      oldValue = newValue;
      if (node[name2] !== newValue) {
        if (newValue == null) {
          node[name2] = "";
          node.removeAttribute(name2);
        } else
          node[name2] = newValue;
      }
    }
  };
};
const readOnly = /^(?:form|list)$/i;
const text = (node, text2) => node.ownerDocument.createTextNode(text2);
function Tagger(type) {
  this.type = type;
  return domtagger(this);
}
Tagger.prototype = {
  attribute(node, name2, original) {
    const isSVG = this.type === "svg";
    switch (name2) {
      case "class":
        if (isSVG)
          return attribute(node, name2);
        name2 = "className";
      case "props":
        return setter(node, name2);
      case "aria":
        return aria(node);
      case "style":
        return hyperStyle(node, original, isSVG);
      case "ref":
        return ref(node);
      case ".dataset":
        return data(node);
      default:
        if (name2.slice(0, 1) === ".")
          return setter(node, name2.slice(1));
        if (name2.slice(0, 1) === "?")
          return boolean(node, name2.slice(1));
        if (name2.slice(0, 2) === "on")
          return event(node, name2);
        if (name2 in node && !(isSVG || readOnly.test(name2)))
          return hyperProperty(node, name2);
        return attribute(node, name2);
    }
  },
  any(node, childNodes) {
    const { type } = this;
    let fastPath = false;
    let oldValue;
    const anyContent = (value) => {
      switch (typeof value) {
        case "string":
        case "number":
        case "boolean":
          if (fastPath) {
            if (oldValue !== value) {
              oldValue = value;
              childNodes[0].textContent = value;
            }
          } else {
            fastPath = true;
            oldValue = value;
            childNodes = udomdiff(node.parentNode, childNodes, [text(node, value)], diffable, node);
          }
          break;
        case "function":
          anyContent(value(node));
          break;
        case "object":
        case "undefined":
          if (value == null) {
            fastPath = false;
            childNodes = udomdiff(node.parentNode, childNodes, [], diffable, node);
            break;
          }
        default:
          fastPath = false;
          oldValue = value;
          if (isArray(value)) {
            if (value.length === 0) {
              if (childNodes.length) {
                childNodes = udomdiff(node.parentNode, childNodes, [], diffable, node);
              }
            } else {
              switch (typeof value[0]) {
                case "string":
                case "number":
                case "boolean":
                  anyContent(String(value));
                  break;
                case "function":
                  anyContent(value.map(invoke, node));
                  break;
                case "object":
                  if (isArray(value[0])) {
                    value = value.concat.apply([], value);
                  }
                default:
                  childNodes = udomdiff(node.parentNode, childNodes, value, diffable, node);
                  break;
              }
            }
          } else if ("ELEMENT_NODE" in value) {
            childNodes = udomdiff(node.parentNode, childNodes, value.nodeType === 11 ? slice.call(value.childNodes) : [value], diffable, node);
          } else if ("text" in value) {
            anyContent(String(value.text));
          } else if ("any" in value) {
            anyContent(value.any);
          } else if ("html" in value) {
            childNodes = udomdiff(node.parentNode, childNodes, slice.call(createContent([].concat(value.html).join(""), type).childNodes), diffable, node);
          } else if ("length" in value) {
            anyContent(slice.call(value));
          }
          break;
      }
    };
    return anyContent;
  },
  text(node) {
    let oldValue;
    const textContent = (value) => {
      if (oldValue !== value) {
        oldValue = value;
        const type = typeof value;
        if (type === "object" && value) {
          if ("text" in value) {
            textContent(String(value.text));
          } else if ("any" in value) {
            textContent(value.any);
          } else if ("html" in value) {
            textContent([].concat(value.html).join(""));
          } else if ("length" in value) {
            textContent(slice.call(value).join(""));
          }
        } else if (type === "function") {
          textContent(value(node));
        } else {
          node.textContent = value == null ? "" : value;
        }
      }
    };
    return textContent;
  }
};
function invoke(callback) {
  return callback(this);
}
const { create: create$1, freeze, keys } = Object;
Tagger.prototype;
const cache = umap(new WeakMap$1());
const createRender = (Tagger2) => ({
  html: outer("html", Tagger2),
  svg: outer("svg", Tagger2),
  render(where, what) {
    const hole = typeof what === "function" ? what() : what;
    const info = cache.get(where) || cache.set(where, createCache());
    const wire = hole instanceof LighterHole ? unroll(Tagger2, info, hole) : hole;
    if (wire !== info.wire) {
      info.wire = wire;
      where.textContent = "";
      where.appendChild(wire.valueOf());
    }
    return where;
  }
});
const createCache = () => ({ stack: [], entry: null, wire: null });
const outer = (type, Tagger2) => {
  const cache2 = umap(new WeakMap$1());
  const fixed = (info) => function() {
    return unroll(Tagger2, info, hole.apply(null, arguments));
  };
  hole.for = (ref2, id) => {
    const memo = cache2.get(ref2) || cache2.set(ref2, create$1(null));
    return memo[id] || (memo[id] = fixed(createCache()));
  };
  hole.node = function() {
    return unroll(Tagger2, createCache(), hole.apply(null, arguments)).valueOf();
  };
  return hole;
  function hole() {
    return new LighterHole(type, tta.apply(null, arguments));
  }
};
const unroll = (Tagger2, info, { type, template, values: values2 }) => {
  const { length: length2 } = values2;
  unrollValues(Tagger2, info, values2, length2);
  let { entry } = info;
  if (!entry || (entry.template !== template || entry.type !== type)) {
    const tag = new Tagger2(type);
    info.entry = entry = {
      type,
      template,
      tag,
      wire: persistent(tag(template, ...values2))
    };
  } else
    entry.tag(template, ...values2);
  return entry.wire;
};
const unrollValues = (Tagger2, { stack }, values2, length2) => {
  for (let i2 = 0; i2 < length2; i2++) {
    const hole = values2[i2];
    if (hole instanceof Hole)
      values2[i2] = unroll(Tagger2, stack[i2] || (stack[i2] = createCache()), hole);
    else if (isArray(hole))
      unrollValues(Tagger2, stack[i2] || (stack[i2] = createCache()), hole, hole.length);
    else
      stack[i2] = null;
  }
  if (length2 < stack.length)
    stack.splice(length2);
};
freeze(LighterHole);
function LighterHole(type, args) {
  this.type = type;
  this.template = args.shift();
  this.values = args;
}
const Hole = LighterHole;
const { render, html, svg } = createRender(Tagger);
function tta() {
  let out = [], i2 = 0, { length: length2 } = arguments;
  while (i2 < length2)
    out.push(arguments[i2++]);
  return out;
}
const Free = {
  name: "Free",
  layout: ({
    props,
    children,
    size
  }) => {
    return children.reduce((acc, x) => {
      const {
        size: size2 = {
          x: "100%",
          y: "100%"
        },
        position = {
          x: 0,
          y: 0
        },
        opacity = 1
      } = x.props;
      return {
        ...acc,
        [x.id]: {
          position: {
            x: position.x,
            y: position.y
          },
          size: {
            x: size2.x,
            y: size2.y
          },
          opacity
        }
      };
    }, {});
  }
};
const Column = {
  name: "Column",
  layout: ({
    props = {},
    children,
    size
  }) => {
    let {
      justify = "center",
      align = "center",
      cover = false,
      margin = {},
      dimensions = 16 / 9,
      reverse = false
    } = props;
    const defaultMargin = cover ? 0 : Math.min(size.y / 6, 12);
    margin = {
      left: defaultMargin,
      right: defaultMargin,
      top: defaultMargin,
      bottom: defaultMargin,
      between: defaultMargin,
      ...margin
    };
    const innerHeight = size.y - margin.top - margin.bottom;
    const innerWidth = size.x - margin.left - margin.right;
    const totalMarginBetween = margin.between * ((children.length || 1) - 1);
    const itemWidth = Math.min(innerWidth, (innerHeight - totalMarginBetween) / (children.length || 1) * dimensions);
    const itemHeight = itemWidth / dimensions;
    return html.node`
      <div style=${{
      height: "100%",
      width: cover ? size.x + "px" : "auto",
      display: "flex",
      flexDirection: reverse ? "column-reverse" : "column",
      justifyContent: justify,
      alignItems: align,
      paddingLeft: margin.left + "px",
      paddingTop: margin.top + "px",
      paddingBottom: margin.bottom + "px",
      paddingRight: margin.right + "px"
    }}>
      ${children.map((x, i2) => html.node`<div data-node-id=${x.id} .data=${{
      entryTransition: {
        delay: 400 + i2 * 100,
        offset: {
          x: 0,
          y: "100%"
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0
      },
      borderRadius: cover ? 0 : 5
    }} style=${{
      display: "flex",
      width: cover ? "100%" : itemWidth + "px",
      height: cover ? itemHeight + "px" : "auto",
      aspectRatio: dimensions,
      marginBottom: i2 === children.length - 1 ? 0 : margin.between + "px",
      flexGrow: 0,
      flexShrink: 1,
      flexBasis: itemHeight + "px"
    }}></div>`)}
      </div>
    `;
  }
};
const Row = {
  name: "Row",
  layout: ({
    props = {},
    children,
    size
  }) => {
    let {
      justify = "center",
      align = "center",
      cover = false,
      margin = {},
      dimensions,
      maxWidth = 1,
      reverse = false
    } = props;
    const defaultMargin = cover ? 0 : Math.min(size.y / 6, 12);
    margin = {
      left: defaultMargin,
      right: defaultMargin,
      top: defaultMargin,
      bottom: defaultMargin,
      between: defaultMargin,
      ...margin
    };
    const innerHeight = size.y - margin.top - margin.bottom;
    const innerWidth = size.x - margin.left - margin.right;
    const totalMarginBetween = margin.between * ((children.length || 1) - 1);
    let itemHeight = innerHeight;
    let itemWidth = Math.min((innerWidth - totalMarginBetween) / (children.length || 1), dimensions ? innerHeight * dimensions : innerWidth, maxWidth * size.x);
    if (dimensions) {
      itemHeight = itemWidth / dimensions;
    }
    return html.node`
      <div style=${{
      height: cover ? size.y + "px" : "auto",
      width: "100%",
      display: "flex",
      flexDirection: reverse ? "row-reverse" : "row",
      justifyContent: justify,
      alignItems: align,
      paddingLeft: margin.left + "px",
      paddingTop: margin.top + "px",
      paddingBottom: margin.bottom + "px",
      paddingRight: margin.right + "px"
    }}>
          ${children.map((x, i2) => html.node`<div data-node-id=${x.id} .data=${{
      entryTransition: {
        delay: 400 + i2 * 100,
        offset: {
          x: 0,
          y: "100%"
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0
      },
      borderRadius: cover ? 0 : 5
    }} style=${{
      display: "flex",
      height: cover ? "100%" : itemHeight + "px",
      width: itemWidth + "px",
      marginRight: i2 === children.length - 1 ? 0 : margin.between + "px",
      flexGrow: 0,
      flexShrink: 1,
      flexBasis: itemWidth + "px"
    }}></div>`)}
      </div>
    `;
  }
};
const toMatrix = (arr, width) => {
  return arr.reduce((rows, key, index2) => (index2 % width == 0 ? rows.push([index2]) : rows[rows.length - 1].push(index2)) && rows, []);
};
const Grid = {
  name: "Grid",
  layout: ({
    props = {},
    children,
    size
  }) => {
    let {
      dimensions,
      numPerRow,
      margin,
      cover = false,
      maxWidth,
      between
    } = props;
    const defaultMargin = children.length === 0 || cover ? 0 : between || Math.min(size.y / children.length / 10, 30);
    margin = margin != null ? margin : defaultMargin;
    const isTall = size.x < size.y;
    between = typeof between === "number" ? between : margin;
    let rows = [];
    if (numPerRow) {
      rows = toMatrix(children, numPerRow);
    } else {
      rows = isTall ? getTallGrid(children.length) : getWideGrid(children.length);
    }
    const rowHeight = (size.y - (margin * 2 + between * (rows.length - 1))) / rows.length;
    const rowWidth = size.x - margin * 2;
    return html.node`
    <div style=${{
      display: "flex",
      width: "100%",
      height: "100%",
      flexDirection: "column",
      justifyContent: "center",
      padding: margin + "px",
      gap: between + "px",
      flexGrow: 0
    }}>${rows.map((row, i2) => Row.layout({
      props: {
        justify: "center",
        dimensions,
        cover,
        maxWidth: maxWidth || 1 / (rows[0].length || 1),
        margin: {
          top: 0,
          right: 0,
          left: 0,
          bottom: 0,
          between
        }
      },
      children: row.map((index2) => children[index2]),
      size: {
        y: rowHeight,
        x: rowWidth
      }
    }))}</div>`;
  }
};
const Presentation = {
  name: "Presentation",
  layout: ({
    props = {},
    children,
    size
  }) => {
    let {
      margin,
      cover = false,
      barWidth = 0.2,
      barPosition = "side",
      presentationDimensions = 16 / 9,
      viewerDimensions = 16 / 9,
      justifyViewers = "center",
      useGrid = false,
      reverse = false
    } = props;
    const barWidthPx = barPosition === "side" ? size.x * barWidth : size.y * barWidth;
    const presentation = children[0];
    const viewers = children.filter((x) => x !== presentation);
    const defaultMargin = children.length <= 1 ? 0 : Math.min(size.x / 80, 30);
    margin = margin != null ? margin : defaultMargin;
    if (!presentation)
      return Grid.layout({
        props,
        children,
        size
      });
    const hasSidebar = children[1];
    const mainSize = {
      ...size
    };
    if (hasSidebar) {
      if (barPosition === "side") {
        mainSize.x = size.x - barWidthPx;
        mainSize.y = mainSize.x / presentationDimensions;
      } else {
        mainSize.y = size.y - barWidthPx;
        mainSize.x = mainSize.y * presentationDimensions;
      }
    }
    let Bar, barProps = {};
    if (useGrid) {
      Bar = Grid.layout;
      barProps = {
        cover,
        ...cover ? {
          maxWidth: 1
        } : {
          margin
        }
      };
    } else {
      Bar = barPosition === "side" ? Column.layout : Row.layout;
      barProps = {
        margin: {
          top: margin,
          left: margin,
          bottom: margin,
          right: margin,
          between: margin
        },
        dimensions: viewerDimensions,
        justify: justifyViewers,
        align: "flex-end"
      };
    }
    const barDirection = barPosition === "side" ? reverse ? "left" : "right" : reverse ? "top" : "bottom";
    return html.node`
      <div style=${{
      display: "flex",
      flexDirection: (barPosition === "side" ? "row" : "column") + (reverse ? "-reverse" : ""),
      justifyContent: "space-around",
      alignItems: "center",
      position: "relative",
      padding: cover ? 0 : margin,
      [`padding-${barDirection}`]: 0
    }}>
        ${children[0] && html.node`<div style=${{
      width: mainSize.x,
      height: mainSize.y,
      display: "flex",
      flexGrow: 1
    }}>
            <div data-node-id=${presentation.id} .data=${{
      dimensions: presentationDimensions,
      borderRadius: cover ? 0 : 5,
      entryTransition: {
        delay: 0,
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.5,
          y: 0.5
        },
        opacity: 0
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 2,
          y: 2
        },
        opacity: 0
      }
    }} style=${{
      width: "100%",
      height: "100%",
      ...cover ? {
        position: "absolute",
        top: 0,
        left: 0,
        width: useGrid && hasSidebar ? 100 - barWidth * 100 + "%" : "100%",
        height: "100%"
      } : {}
    }} />
          </div>`}
        ${html.node`<div style=${{
      ...barPosition === "side" ? {
        maxWidth: barWidth * 100 + "%",
        height: "100%"
      } : {
        maxHeight: barWidth * 100 + "%",
        width: "100%"
      }
    }}>${hasSidebar && Bar({
      props: barProps,
      children: viewers,
      size: barPosition === "side" ? {
        x: barWidthPx,
        y: size.y
      } : {
        x: size.x,
        y: barWidthPx
      }
    })}</div>`}
      </div>
    `;
  }
};
const Layered = {
  name: "Layered",
  layout: ({
    props = {},
    children,
    size
  }) => {
    return html.node`<div style=${{
      width: "100%",
      height: "100%",
      position: "relative"
    }}>
      ${children.map((x, i2) => html.node`<div data-node-id=${x.id} .data=${{
      zIndex: i2 + 1
    }} style=${{
      position: "absolute",
      inset: `0px`
    }}></div>`)}
    </div>`;
  }
};
const getWideGrid = (numChildren = 0) => {
  switch (numChildren) {
    case 0: {
      return [[]];
    }
    case 1: {
      return [[0]];
    }
    case 2: {
      return [[0, 1]];
    }
    case 3: {
      return [[0, 1], [2]];
    }
    case 4: {
      return [[0, 1], [2, 3]];
    }
    case 5: {
      return [[0, 1, 2], [3, 4]];
    }
    case 6: {
      return [[0, 1, 2], [3, 4, 5]];
    }
    case 7: {
      return [[0, 1, 2], [3, 4, 5], [6]];
    }
    case 8: {
      return [[0, 1, 2], [3, 4, 5], [6, 7]];
    }
  }
  const arr = Array(numChildren).fill(null).map((x, i2) => i2);
  return toMatrix(arr, Math.round(Math.sqrt(numChildren)));
};
const getTallGrid = (numChildren = 0) => {
  switch (numChildren) {
    case 0: {
      return [[]];
    }
    case 1: {
      return [[0]];
    }
    case 2: {
      return [[0], [1]];
    }
    case 3: {
      return [[0, 1], [2]];
    }
    case 4: {
      return [[0, 1], [2, 3]];
    }
    case 5: {
      return [[0, 1], [2, 3], [4]];
    }
    case 6: {
      return [[0, 1], [2, 3], [4, 5]];
    }
    case 7: {
      return [[0, 1], [2, 3], [4, 5], [6]];
    }
    case 8: {
      return [[0, 1], [2, 3], [4, 5], [6, 7]];
    }
  }
  const arr = Array(numChildren).fill(null).map((x, i2) => i2);
  return toMatrix(arr, Math.ceil(Math.sqrt(arr.length)) - 1);
};
var Layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Free,
  Column,
  Row,
  Grid,
  Presentation,
  Layered
}, Symbol.toStringTag, { value: "Module" }));
const deviceWatchers = /* @__PURE__ */ new Set();
const updateMediaStreamTracks = (srcObject, tracks) => {
  const existing = {
    audio: srcObject.getAudioTracks()[0],
    video: srcObject.getVideoTracks()[0]
  };
  if (existing.audio !== tracks.audio) {
    if (existing.audio) {
      srcObject.removeTrack(existing.audio);
    }
    if (tracks.audio) {
      srcObject.addTrack(tracks.audio);
    }
  }
  if (existing.video !== tracks.video) {
    if (existing.video) {
      srcObject.removeTrack(existing.video);
    }
    if (tracks.video) {
      srcObject.addTrack(tracks.video);
    }
  }
};
const getDevicePermissions = async () => {
  const permissions2 = {
    audio: true,
    video: true
  };
  return Promise.all([navigator.mediaDevices.getUserMedia({
    video: true
  }).then((src) => {
    src.getTracks().forEach((x) => x.stop());
  }).catch((e2) => {
    if (e2.name === "NotAllowedError") {
      permissions2.video = false;
    }
  }), navigator.mediaDevices.getUserMedia({
    audio: true
  }).then((src) => {
    src.getTracks().forEach((x) => x.stop());
  }).catch((e2) => {
    if (e2.name === "NotAllowedError") {
      permissions2.audio = false;
    }
  })]).then(() => permissions2);
};
const ensureDevicePermissions = async () => {
  return getDevicePermissions();
};
const watchDevices = (cb) => {
  if (deviceWatchers.size === 0) {
    navigator.mediaDevices.addEventListener("devicechange", reportDevices);
  }
  deviceWatchers.add(cb);
  reportDevices().catch(() => {
  });
  return () => {
    deviceWatchers.delete(cb);
    if (deviceWatchers.size === 0) {
      navigator.mediaDevices.removeEventListener("devicechange", reportDevices);
    }
  };
};
const getUserMedia = async (...args) => {
  const media = await navigator.mediaDevices.getUserMedia(...args);
  reportDevices();
  return media;
};
const deviceWithDefaultLabel = (x, label) => ({
  deviceId: x.deviceId,
  groupId: x.groupId,
  kind: x.kind,
  label: x.label || label
});
const reportDevices = async () => {
  const devices = await navigator.mediaDevices.enumerateDevices();
  const webcams = devices.filter((x) => x.kind === "videoinput").map((x, i2) => deviceWithDefaultLabel(x, "Camera " + (i2 + 1)));
  const microphones = devices.filter((x) => x.kind === "audioinput").map((x, i2) => deviceWithDefaultLabel(x, "Microphone " + (i2 + 1)));
  const speakers = devices.filter((x) => x.kind === "audiooutput").map((x, i2) => deviceWithDefaultLabel(x, "Speaker " + (i2 + 1)));
  deviceWatchers.forEach((cb) => cb({
    webcams,
    microphones,
    speakers
  }));
};
var webrtc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  updateMediaStreamTracks,
  getDevicePermissions,
  ensureDevicePermissions,
  watchDevices,
  getUserMedia
}, Symbol.toStringTag, { value: "Module" }));
const RoomParticipant = {
  type: "RoomParticipant",
  valueType: MediaStream,
  props: {
    id: {},
    type: {},
    videoEnabled: {},
    audioEnabled: {}
  },
  init({
    addSource,
    removeSource,
    updateSource,
    getSource
  }) {
    CoreContext.on("RoomJoined", ({
      room
    }) => {
      let listeners2 = {};
      let previousTracks = [];
      let previousParticipants = [];
      let participantStreams = {};
      const updateParticipants = () => {
        previousTracks.filter((p) => (p == null ? void 0 : p.type) === "camera" && (p == null ? void 0 : p.isExternal) === true).forEach((track) => {
          var _a2, _b, _c;
          if (track.type === "camera") {
            const srcObject = participantStreams[track.id];
            const participant = room.getParticipant(track.participantId);
            const webcamTrack = room.getTrack(track.id);
            const source2 = getSource(track == null ? void 0 : track.id);
            if (source2) {
              const microphoneTrack = room.getTrack((_a2 = participant == null ? void 0 : participant.meta[track.id]) == null ? void 0 : _a2.microphone);
              updateMediaStreamTracks(srcObject, {
                video: webcamTrack == null ? void 0 : webcamTrack.mediaStreamTrack,
                audio: microphoneTrack == null ? void 0 : microphoneTrack.mediaStreamTrack
              });
              updateSource(track.id, {
                videoEnabled: Boolean(webcamTrack && !webcamTrack.isMuted),
                audioEnabled: Boolean(microphoneTrack && !microphoneTrack.isMuted),
                displayName: ((_b = participant == null ? void 0 : participant.meta[track.id]) == null ? void 0 : _b.displayName) || "External Track",
                mirrored: (_c = participant == null ? void 0 : participant.meta[track.id]) == null ? void 0 : _c.isMirrored,
                microphone: microphoneTrack,
                external: track == null ? void 0 : track.isExternal
              });
            }
          }
        });
        previousParticipants.forEach((x) => {
          var _a2;
          const srcObject = participantStreams[x.id];
          const srcObjectScreenshare = participantStreams[x.id + "-screen"];
          const webcamId = x.trackIds.find((trackId) => {
            const track = room.getTrack(trackId);
            return (track == null ? void 0 : track.type) === "camera" && !(track == null ? void 0 : track.isExternal);
          });
          const microphoneId = x.trackIds.find((x2) => {
            const track = room.getTrack(x2);
            return (track == null ? void 0 : track.type) === "microphone" && !(track == null ? void 0 : track.isExternal);
          });
          const screenshareId = x.trackIds.find((x2) => {
            const track = room.getTrack(x2);
            return (track == null ? void 0 : track.type) === "screen_share";
          });
          const webcamTrack = room.getTrack(webcamId);
          const microphoneTrack = room.getTrack(microphoneId);
          const screenshareTrack = room.getTrack(screenshareId);
          updateMediaStreamTracks(srcObject, {
            video: webcamTrack == null ? void 0 : webcamTrack.mediaStreamTrack,
            audio: microphoneTrack == null ? void 0 : microphoneTrack.mediaStreamTrack
          });
          updateMediaStreamTracks(srcObjectScreenshare, {
            video: screenshareTrack == null ? void 0 : screenshareTrack.mediaStreamTrack
          });
          updateSource(x.id, {
            videoEnabled: Boolean(webcamTrack && !webcamTrack.isMuted),
            audioEnabled: Boolean(microphoneTrack && !microphoneTrack.isMuted),
            displayName: x.displayName,
            mirrored: (_a2 = x == null ? void 0 : x.meta) == null ? void 0 : _a2.isMirrored,
            external: webcamTrack == null ? void 0 : webcamTrack.isExternal
          });
          updateSource(x.id + "-screen", {
            videoEnabled: Boolean(screenshareTrack && !screenshareTrack.isMuted),
            displayName: x.meta.screenDisplayName || `${x.displayName}'s Screen`
          });
        });
      };
      room.useTracks((tracks) => {
        const newTracks = tracks.filter((track) => !previousTracks.some((x) => x.id === track.id) && Boolean(track == null ? void 0 : track.mediaStreamTrack));
        const removedTracks = previousTracks.filter((track) => !tracks.some((x) => x.id === track.id));
        previousTracks = tracks.filter((t2) => Boolean(t2 == null ? void 0 : t2.mediaStreamTrack));
        newTracks.forEach((x) => {
          const srcObject = new MediaStream([]);
          participantStreams[x.id] = srcObject;
          const {
            id,
            participantId,
            type,
            mediaStreamTrack
          } = room.getTrack(x.id);
          if (mediaStreamTrack) {
            addSource({
              id,
              isActive: true,
              value: srcObject,
              props: {
                id,
                trackId: id,
                participantId,
                isMuted: x.isMuted,
                type
              }
            });
          }
        });
        removedTracks.forEach((x) => {
          var _a2;
          removeSource(x.id);
          (_a2 = listeners2[x.id]) == null ? void 0 : _a2.call(listeners2);
        });
        updateParticipants();
      });
      room.useParticipants((participants) => {
        const newParticipants = participants.filter((participant) => !previousParticipants.some((x) => x.id === participant.id));
        const removedParticipants = previousParticipants.filter((participant) => !participants.some((x) => x.id === participant.id));
        previousParticipants = participants;
        newParticipants.forEach((x) => {
          var _a2;
          const {
            id
          } = x;
          const srcObject = new MediaStream([]);
          const screenSrcObject = new MediaStream([]);
          participantStreams[id] = srcObject;
          participantStreams[id + "-screen"] = screenSrcObject;
          addSource({
            id,
            isActive: true,
            value: srcObject,
            props: {
              id,
              type: "camera",
              displayName: x.displayName || x.id,
              audioEnabled: false,
              videoEnabled: false,
              mirrored: (_a2 = x == null ? void 0 : x.meta) == null ? void 0 : _a2.isMirrored
            }
          });
          addSource({
            id: id + "-screen",
            isActive: true,
            value: screenSrcObject,
            props: {
              id,
              type: "screen",
              displayName: x.displayName || x.id,
              audioEnabled: false,
              videoEnabled: false
            }
          });
        });
        updateParticipants();
        removedParticipants.forEach((x) => {
          var _a2;
          removeSource(x.id);
          (_a2 = listeners2[x.id]) == null ? void 0 : _a2.call(listeners2);
        });
      });
    });
  }
};
const Banner = {
  type: "Banner",
  valueType: Object,
  props: {},
  init({
    addSource,
    removeSource,
    updateSource,
    getSource,
    modifySourceValue
  }) {
    let previousBanners = [];
    const update = (banners = []) => {
      const newBanners = banners.filter((banner) => !previousBanners.some((x) => x.id === banner.id));
      const removedBanners = previousBanners.filter((banner) => !banners.some((x) => x.id === banner.id));
      const changedBanners = banners.filter((banner) => {
        const existing = previousBanners.find((x) => x.id === banner.id);
        return !fastDeepEqual(banner, existing);
      });
      newBanners.forEach((x) => addSource({
        id: x.id,
        value: {
          headerText: x.props.headerText,
          bodyText: x.props.bodyText
        },
        props: x.props
      }));
      removedBanners.forEach((x) => removeSource(x.id));
      changedBanners.forEach((x) => {
        updateSource(x.id, x.props);
        modifySourceValue(x.id, (value) => {
          value.headerText = x.props.headerText;
          value.bodyText = x.props.bodyText;
        });
      });
      previousBanners = banners;
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId
    }) => {
      var _a2, _b;
      previousBanners = [];
      if (!projectId)
        return;
      const project = getProject(projectId);
      update((_b = (_a2 = project.props) == null ? void 0 : _a2.banners) != null ? _b : []);
    });
    CoreContext.on("ProjectChanged", ({
      project
    }) => {
      var _a2, _b;
      update((_b = (_a2 = project.props) == null ? void 0 : _a2.banners) != null ? _b : []);
    });
  }
};
const Overlays = {
  type: "Overlay",
  valueType: Object,
  props: {},
  init({
    addSource,
    removeSource,
    updateSource,
    getSource,
    modifySourceValue
  }) {
    let previousOverlays = [];
    const update = (overlays = []) => {
      const newOverlays = overlays.filter((overlay) => !previousOverlays.some((x) => x.id === overlay.id));
      const removedOverlays = previousOverlays.filter((overlay) => !overlays.some((x) => x.id === overlay.id));
      const changedOverlays = overlays.filter((overlay) => {
        const existing = previousOverlays.find((x) => x.id === overlay.id);
        return !fastDeepEqual(overlay, existing);
      });
      newOverlays.forEach((x) => addSource({
        id: x.id,
        value: {
          ...x.props
        },
        props: x.props
      }));
      removedOverlays.forEach((x) => removeSource(x.id));
      changedOverlays.forEach((x) => {
        updateSource(x.id, x.props);
        modifySourceValue(x.id, (value) => {
          Object.keys(x.props).forEach((key) => {
            value[key] = x.props[key];
          });
        });
      });
      previousOverlays = JSON.parse(JSON.stringify(overlays));
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId
    }) => {
      previousOverlays = [];
      if (!projectId)
        return;
      const project = getProject(projectId);
      update(project.props.overlays);
    });
    CoreContext.on("ProjectChanged", ({
      project
    }) => {
      update(project.props.overlays);
    });
  }
};
const Background = {
  type: "Background",
  valueType: Object,
  props: {},
  init({
    addSource,
    removeSource,
    updateSource,
    getSource,
    modifySourceValue
  }) {
    let previousBackground;
    const update = (background) => {
      if (!background)
        return;
      const newBackground = (previousBackground == null ? void 0 : previousBackground.id) !== (background == null ? void 0 : background.id) ? background : null;
      const changedBackground = !fastDeepEqual(background, previousBackground) ? background : null;
      if (newBackground) {
        addSource({
          id: newBackground == null ? void 0 : newBackground.id,
          value: {
            ...newBackground == null ? void 0 : newBackground.props
          },
          props: newBackground == null ? void 0 : newBackground.props
        });
        removeSource(previousBackground == null ? void 0 : previousBackground.id);
      }
      if (changedBackground) {
        updateSource(changedBackground == null ? void 0 : changedBackground.id, changedBackground == null ? void 0 : changedBackground.props);
        modifySourceValue(changedBackground == null ? void 0 : changedBackground.id, (value) => {
          Object.keys(changedBackground == null ? void 0 : changedBackground.props).forEach((key) => {
            value[key] = changedBackground == null ? void 0 : changedBackground.props[key];
          });
        });
      }
      previousBackground = JSON.parse(JSON.stringify(background));
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId
    }) => {
      previousBackground = null;
      if (!projectId)
        return;
      const project = getProject(projectId);
      update(project.props.background);
    });
    CoreContext.on("ProjectChanged", ({
      project
    }) => {
      update(project.props.background);
    });
  }
};
const Logo = {
  type: "Logo",
  valueType: Object,
  props: {},
  init({
    addSource,
    removeSource,
    updateSource,
    getSource,
    modifySourceValue
  }) {
    let previousLogo;
    const update = (logo) => {
      if (!logo) {
        if (previousLogo) {
          removeSource(previousLogo == null ? void 0 : previousLogo.id);
          previousLogo = null;
        }
        return;
      }
      const newLogo = (previousLogo == null ? void 0 : previousLogo.id) !== (logo == null ? void 0 : logo.id) ? logo : null;
      const changedLogo = !fastDeepEqual(logo, previousLogo) ? logo : null;
      if (newLogo) {
        addSource({
          id: newLogo == null ? void 0 : newLogo.id,
          value: {
            ...newLogo == null ? void 0 : newLogo.props
          },
          props: newLogo == null ? void 0 : newLogo.props
        });
        removeSource(previousLogo == null ? void 0 : previousLogo.id);
      }
      if (changedLogo) {
        updateSource(changedLogo == null ? void 0 : changedLogo.id, changedLogo == null ? void 0 : changedLogo.props);
        modifySourceValue(changedLogo == null ? void 0 : changedLogo.id, (value) => {
          Object.keys(changedLogo == null ? void 0 : changedLogo.props).forEach((key) => {
            value[key] = changedLogo == null ? void 0 : changedLogo.props[key];
          });
        });
      }
      previousLogo = JSON.parse(JSON.stringify(logo));
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId
    }) => {
      previousLogo = null;
      if (!projectId)
        return;
      const project = getProject(projectId);
      update(project.props.logo);
    });
    CoreContext.on("ProjectChanged", ({
      project
    }) => {
      update(project.props.logo);
    });
  }
};
var Sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RoomParticipant,
  Banner,
  Overlays,
  Background,
  Logo
}, Symbol.toStringTag, { value: "Module" }));
const {
  state: state$1
} = CoreContext;
subscribeInternal(async (event2, payload) => {
  var _a2, _b, _c, _d, _e, _f;
  switch (event2) {
    case "UserChanged": {
      const {
        metadata
      } = payload;
      state$1.user.metadata = metadata || {};
      state$1.user.props = (metadata == null ? void 0 : metadata.props) || {};
      trigger$1("UserChanged", {
        user: getBaseUser()
      });
      return;
    }
    case "ActiveProjectChanged": {
      const {
        projectId
      } = payload;
      state$1.activeProjectId = projectId;
      trigger$1("ActiveProjectChanged", {
        projectId
      });
      return;
    }
    case "ProjectAdded": {
      const project = payload;
      const internalProject = await hydrateProject(project, "ROLE_HOST");
      const baseProject = toBaseProject(internalProject);
      state$1.projects = [...state$1.projects, internalProject];
      trigger$1("ProjectAdded", {
        project: baseProject
      });
      return;
    }
    case "ProjectRemoved": {
      const {
        projectId
      } = payload;
      state$1.projects = state$1.projects.filter((x) => x.id !== projectId);
      trigger$1("ProjectRemoved", {
        projectId
      });
      return;
    }
    case "ProjectChanged": {
      const {
        project,
        phase,
        broadcastId
      } = payload;
      const internalProject = getProject(project.projectId);
      if (!internalProject)
        return;
      if (phase) {
        internalProject.videoApi.phase = phase;
      }
      if (typeof broadcastId !== "undefined") {
        internalProject.videoApi.broadcastId = broadcastId;
      }
      const newLayoutId = (_a2 = project.metadata) == null ? void 0 : _a2.layoutId;
      if (newLayoutId !== internalProject.layoutApi.layoutId) {
        internalProject.layoutApi.layoutId = (_b = project.metadata) == null ? void 0 : _b.layoutId;
        internalProject.compositor = await layoutToProject(newLayoutId);
      }
      internalProject.videoApi.project = project;
      internalProject.props = (_d = (_c = project.metadata) == null ? void 0 : _c.props) != null ? _d : {};
      trigger$1("ProjectChanged", {
        project: toBaseProject(internalProject)
      });
      return;
    }
    case "DestinationAdded": {
      const {
        projectId
      } = payload;
      const internalProject = getProject(projectId);
      if (!internalProject)
        return;
      internalProject.videoApi.project.destinations.push(payload);
      trigger$1("DestinationAdded", {
        projectId,
        destination: toBaseDestination(payload)
      });
      return;
    }
    case "DestinationRemoved": {
      const {
        projectId,
        destinationId
      } = payload;
      const internalProject = getProject(projectId);
      if (!internalProject)
        return;
      internalProject.videoApi.project.destinations = internalProject.videoApi.project.destinations.filter((x) => x.destinationId !== destinationId);
      trigger$1("DestinationRemoved", {
        projectId,
        destinationId
      });
      return;
    }
    case "DestinationChanged": {
      const destination = payload;
      const {
        projectId,
        destinationId
      } = destination;
      const internalProject = getProject(projectId);
      if (!internalProject)
        return;
      const internalDestination = internalProject.videoApi.project.destinations.find((x) => x.destinationId === destinationId);
      if (!internalDestination)
        return;
      Object.assign(internalDestination, destination);
      trigger$1("DestinationChanged", {
        projectId,
        destination: toBaseDestination(internalDestination)
      });
      return;
    }
    case "SourceAdded": {
      return;
    }
    case "SourceRemoved": {
      return;
    }
    case "SourceUpdated": {
      return;
    }
    case "NodeAdded": {
      return;
    }
    case "NodeRemoved": {
      return;
    }
    case "NodeUpdated": {
      return;
    }
    case "BackgroundMetadataUpdate": {
      const {
        Command
      } = CoreContext;
      const {
        projectId,
        metadata,
        sourceId,
        doTrigger,
        role
      } = payload;
      if (role === "ROLE_HOST" || role === "ROLE_COHOST") {
        const internalProject = getProject(projectId);
        if (!internalProject)
          return;
        if (internalProject.props.background.id !== sourceId) {
          return;
        }
        let source2 = (_e = internalProject == null ? void 0 : internalProject.props) == null ? void 0 : _e.background;
        if (source2) {
          source2 = {
            ...source2,
            props: {
              ...source2.props,
              meta: {
                ...source2.props.meta,
                ...metadata
              }
            }
          };
          if (doTrigger) {
            Command.updateProjectProps({
              projectId,
              props: {
                background: source2
              }
            });
          } else {
            Command.updateProjectPropsWithoutTrigger({
              projectId,
              props: {
                background: source2
              }
            });
          }
        }
      }
      return;
    }
    case "OverlayMetadataUpdate": {
      const {
        Command
      } = CoreContext;
      const {
        projectId,
        metadata,
        sourceId,
        doTrigger,
        role
      } = payload;
      if (role === "ROLE_HOST" || role === "ROLE_COHOST") {
        const internalProject = getProject(projectId);
        if (!internalProject)
          return;
        let source2 = internalProject.props.overlays.find((x) => x.id === sourceId);
        if (source2) {
          source2 = {
            ...source2,
            props: {
              ...source2.props,
              meta: {
                ...source2.props.meta,
                ...metadata
              }
            }
          };
          const overlayIndex = internalProject.props.overlays.findIndex((x) => x.id === sourceId);
          if (overlayIndex > -1) {
            const shallowOverlays = JSON.parse(JSON.stringify((_f = internalProject == null ? void 0 : internalProject.props) == null ? void 0 : _f.overlays));
            shallowOverlays.splice(overlayIndex, 1, source2);
            if (doTrigger) {
              Command.updateProjectProps({
                projectId,
                props: {
                  overlays: shallowOverlays
                }
              });
            } else {
              Command.updateProjectPropsWithoutTrigger({
                projectId,
                props: {
                  overlays: shallowOverlays
                }
              });
            }
          }
        }
      }
      return;
    }
  }
});
subscribeInternal(() => log$1.debug({
  nextState: {
    ...state$1
  }
}));
const {
  state
} = CoreContext;
const updateUserProps = async (payload) => {
  const collection = getUser();
  if (!collection)
    return;
  const props = {
    ...collection.props,
    ...payload.props
  };
  const response = await CoreContext.clients.LiveApi().collection.updateCollection({
    collectionId: collection.id,
    updateMask: ["metadata"],
    metadata: {
      ...collection.metadata,
      props
    }
  });
  await triggerInternal$1("UserChanged", response.collection);
  return;
};
const createProject$1 = async (payload = {}) => {
  const {
    props = {},
    size,
    settings = {}
  } = payload;
  const response = await CoreContext.Request.createProject({
    settings,
    props,
    size
  });
  await triggerInternal$1("ProjectAdded", response.project);
  const internalProject = await hydrateProject(response.project, "ROLE_HOST");
  return toBaseProject(internalProject);
};
const recreateLayout = async (payload) => {
  const {
    projectId,
    props = {}
  } = payload;
  const collectionId = getUser().id;
  const response = await CoreContext.clients.LiveApi().project.getProject({
    collectionId,
    projectId,
    status: true
  });
  if ([ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING, ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STARTING].includes(response.status.phase)) {
    return;
  }
  const metadata = response.project.metadata || {};
  const {
    layoutId
  } = metadata;
  const {
    video
  } = response.project.rendering;
  const {
    type
  } = response.project.metadata.props || {};
  const layout = await CoreContext.Request.createLayout({
    collectionId,
    projectId,
    type: type || "sceneless",
    settings: {},
    size: {
      x: video.width,
      y: video.height
    }
  });
  const updateResponse = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId,
    projectId,
    updateMask: ["metadata"],
    metadata: {
      ...metadata,
      layoutId: layout.id
    }
  });
  CoreContext.log.debug("New layout assigned to project:", {
    layout
  });
  await triggerInternal$1("ProjectChanged", {
    project: updateResponse.project
  });
  await CoreContext.clients.LayoutApi().layout.deleteLayout({
    layoutId
  });
  CoreContext.log.debug("Previous layout deleted:", {
    layoutId
  });
  const internalProject = await hydrateProject(updateResponse.project, "ROLE_HOST");
  await internalProject.compositor.update(internalProject.compositor.getRoot().id, props);
  return {
    project: toBaseProject(internalProject),
    internalProject
  };
};
const deleteProject$1 = async (payload) => {
  const {
    projectId
  } = payload;
  await CoreContext.Request.deleteProject({
    projectId
  });
  await triggerInternal$1("ProjectRemoved", {
    projectId
  });
  return;
};
const updateProjectProps = async (payload) => {
  const {
    projectId
  } = payload;
  const collectionId = getUser().id;
  const project = getProject(projectId);
  const props = {
    ...project.props,
    ...payload.props
  };
  const response = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId,
    projectId,
    updateMask: ["metadata"],
    metadata: {
      ...project.videoApi.project.metadata,
      props
    }
  });
  await triggerInternal$1("ProjectChanged", {
    project: response.project
  });
  return;
};
const updateProjectMeta = (payload) => updateProjectProps({
  projectId: payload.projectId,
  props: payload.meta
});
const updateProjectPropsWithoutTrigger = async (payload) => {
  const {
    projectId
  } = payload;
  const collectionId = getUser().id;
  const project = getProject(projectId);
  const props = {
    ...project.props,
    ...payload.props
  };
  await CoreContext.clients.LiveApi().project.updateProject({
    collectionId,
    projectId,
    updateMask: ["metadata"],
    metadata: {
      ...project.videoApi.project.metadata,
      props
    }
  });
  return;
};
const setActiveProject = async (payload) => {
  const project = state.projects.find((x) => x.id === payload.projectId);
  if (!project) {
    state.activeProjectId = null;
    triggerInternal$1("ActiveProjectChanged", {
      projectId: null
    });
    return;
  }
  const currentProject = state.projects.find((x) => x.id === state.activeProjectId);
  if (project === currentProject)
    return;
  if (currentProject) {
    Array.from(webrtcManager.rooms.keys()).map(webrtcManager.removeRoom);
    await CoreContext.clients.LayoutApi().unsubscribeFromLayout(currentProject.layoutApi.layoutId);
    await CoreContext.clients.LiveApi().unsubscribeFromProject(currentProject.videoApi.project.collectionId, currentProject.videoApi.project.projectId);
  }
  await CoreContext.clients.LayoutApi().subscribeToLayout(project.layoutApi.layoutId);
  await CoreContext.clients.LiveApi().subscribeToProject(project.videoApi.project.collectionId, project.videoApi.project.projectId);
  CoreContext.clients.LiveApi().project.getProject({
    collectionId: project.videoApi.project.collectionId,
    projectId: project.videoApi.project.projectId,
    status: true
  }).then((response) => {
    var _a2, _b;
    triggerInternal$1("ProjectChanged", {
      project: response.project,
      phase: (_a2 = response.status) == null ? void 0 : _a2.phase,
      broadcastId: (_b = response.status) == null ? void 0 : _b.broadcastId
    });
  });
  triggerInternal$1("ActiveProjectChanged", {
    projectId: project.id
  });
  return toBaseProject(project);
};
const joinRoom = async (payload) => {
  const {
    projectId,
    displayName = "Guest"
  } = payload;
  const project = state.projects.find((x) => x.id === projectId);
  let token = project.sfuToken;
  if (!token) {
    let {
      webrtcAccess
    } = await CoreContext.clients.LiveApi().authentication.createWebRtcAccessToken({
      collectionId: project.videoApi.project.collectionId,
      projectId: project.videoApi.project.projectId,
      displayName
    });
    token = webrtcAccess.accessToken;
  }
  const tokenData = o(token);
  const roomName = tokenData.video.room;
  const url = new URL(CoreContext.clients.getLiveKitServer());
  const baseUrl = url.host + url.pathname;
  const roomContext = webrtcManager.ensureRoom(baseUrl, roomName, token);
  roomContext.bindApiClient(CoreContext.clients);
  await roomContext.connect();
  project.sfuToken = token;
  project.roomId = roomName;
  const room = getRoom(roomName);
  trigger$1("RoomJoined", {
    projectId: project.id,
    room
  });
  return room;
};
const createNode = async (payload) => {
  let {
    props = {},
    parentId,
    index: index2,
    projectId = state.activeProjectId
  } = payload;
  const project = getProject(projectId);
  const nodeId = await project.compositor.insert(props, parentId, index2);
  triggerInternal$1("NodeAdded", {
    projectId,
    nodeId
  });
  triggerInternal$1("NodeChanged", {
    projectId,
    nodeId: parentId
  });
  return project.compositor.get(nodeId);
};
const deleteNode = async (payload) => {
  var _a2;
  let {
    nodeId,
    projectId = state.activeProjectId
  } = payload;
  const project = getProject(projectId);
  const parentId = (_a2 = project.compositor.getParent(nodeId)) == null ? void 0 : _a2.id;
  project.compositor.remove(nodeId);
  triggerInternal$1("NodeRemoved", {
    projectId,
    nodeId
  });
  triggerInternal$1("NodeChanged", {
    projectId,
    nodeId: parentId
  });
};
const updateNode = async (payload) => {
  let {
    nodeId,
    props = {},
    projectId = state.activeProjectId
  } = payload;
  const project = getProject(projectId);
  delete props.type;
  delete props.sourceType;
  project.compositor.update(nodeId, props);
  triggerInternal$1("NodeChanged", {
    projectId,
    nodeId
  });
  return project.compositor.get(nodeId);
};
const setNodeLayout = async (payload) => {
  let {
    nodeId,
    layout,
    projectId = state.activeProjectId,
    layoutProps = {}
  } = payload;
  const project = getProject(projectId);
  project.compositor.update(nodeId, {
    layout,
    layoutProps
  });
  triggerInternal$1("NodeChanged", {
    projectId,
    nodeId
  });
};
const moveNode = async (payload) => {
  const {
    nodeId,
    parentId,
    projectId = state.activeProjectId,
    index: index2
  } = payload;
  const project = getProject(projectId);
  project.compositor.move(nodeId, parentId, index2);
  triggerInternal$1("NodeChanged", {
    projectId,
    nodeId
  });
};
const swapNodes = async (payload) => {
  var _a2, _b;
  const {
    nodeAId,
    nodeBId,
    projectId = state.activeProjectId
  } = payload;
  const project = getProject(projectId);
  const parentAId = (_a2 = project.compositor.getParent(nodeAId)) == null ? void 0 : _a2.id;
  const parentBId = (_b = project.compositor.getParent(nodeBId)) == null ? void 0 : _b.id;
  project.compositor.swap(nodeAId, nodeBId);
  triggerInternal$1("NodeChanged", {
    projectId,
    nodeId: parentAId
  });
  triggerInternal$1("NodeChanged", {
    projectId,
    nodeId: parentBId
  });
};
const reorderNodes = async (payload) => {
  const {
    parentId,
    childIds,
    projectId = state.activeProjectId
  } = payload;
  const project = getProject(projectId);
  project.compositor.reorder(parentId, childIds);
  triggerInternal$1("NodeChanged", {
    projectId,
    nodeId: parentId
  });
};
const startBroadcast = async (payload) => {
  const {
    projectId = state.activeProjectId
  } = payload;
  const project = getProject(projectId);
  await CoreContext.clients.LiveApi().project.startProjectBroadcast({
    collectionId: project.videoApi.project.collectionId,
    projectId: project.videoApi.project.projectId
  });
};
const stopBroadcast = async (payload) => {
  const {
    projectId = state.activeProjectId
  } = payload;
  const project = getProject(projectId);
  await CoreContext.clients.LiveApi().project.stopProjectBroadcast({
    collectionId: project.videoApi.project.collectionId,
    projectId: project.videoApi.project.projectId
  });
};
const addDestination = async (payload) => {
  var _a2;
  const {
    rtmpUrl,
    rtmpKey,
    enabled,
    projectId = state.activeProjectId,
    metadata = {},
    props = {}
  } = payload;
  const project = getProject(projectId);
  const address = {
    rtmpPush: {
      key: rtmpKey,
      url: rtmpUrl
    }
  };
  const response = await ((_a2 = CoreContext.clients.LiveApi().destination) == null ? void 0 : _a2.createDestination({
    collectionId: project.videoApi.project.collectionId,
    projectId: project.videoApi.project.projectId,
    address,
    enabled,
    metadata: {
      props: {
        ...metadata,
        ...props
      }
    }
  }));
  await triggerInternal$1("DestinationAdded", response.destination);
  return toBaseDestination(response.destination);
};
const removeDestination = async (payload) => {
  var _a2;
  const {
    destinationId,
    projectId = state.activeProjectId
  } = payload;
  const project = getProject(projectId);
  await ((_a2 = CoreContext.clients.LiveApi().destination) == null ? void 0 : _a2.deleteDestination({
    collectionId: project.videoApi.project.collectionId,
    projectId: project.videoApi.project.projectId,
    destinationId
  }));
  await triggerInternal$1("DestinationRemoved", {
    projectId,
    destinationId
  });
  return;
};
const updateDestination = async (payload) => {
  var _a2;
  const {
    rtmpUrl,
    rtmpKey,
    destinationId,
    projectId = state.activeProjectId
  } = payload;
  const project = getProject(projectId);
  const rtmpPush = {
    key: rtmpKey,
    url: rtmpUrl
  };
  const response = await ((_a2 = CoreContext.clients.LiveApi().destination) == null ? void 0 : _a2.updateDestination({
    collectionId: project.videoApi.project.collectionId,
    projectId: project.videoApi.project.projectId,
    destinationId,
    updateMask: ["address.rtmpPush"],
    address: {
      rtmpPush
    }
  }));
  await triggerInternal$1("DestinationChanged", response.destination);
  return;
};
const updateDestinationProps = async (payload) => {
  var _a2, _b;
  const {
    projectId = state.activeProjectId,
    destinationId,
    props = {}
  } = payload;
  const project = getProject(projectId);
  const destination = project.videoApi.project.destinations.find((x) => x.destinationId === destinationId);
  if (!destination)
    return;
  const response = await ((_b = CoreContext.clients.LiveApi().destination) == null ? void 0 : _b.updateDestination({
    collectionId: project.videoApi.project.collectionId,
    projectId: project.videoApi.project.projectId,
    destinationId,
    updateMask: ["metadata"],
    metadata: {
      ...destination.metadata || {},
      props: {
        ...((_a2 = destination.metadata) == null ? void 0 : _a2.props) || {},
        ...props
      }
    }
  }));
  await triggerInternal$1("DestinationChanged", response.destination);
  return;
};
const updateDestinationMeta = (payload) => updateDestinationProps({
  projectId: payload.projectId,
  destinationId: payload.destinationId,
  props: payload.metadata
});
const setDestinationEnabled = async (payload) => {
  var _a2;
  const {
    enabled,
    destinationId,
    projectId = state.activeProjectId
  } = payload;
  const project = getProject(projectId);
  const destination = project.videoApi.project.destinations.find((x) => destinationId === x.destinationId);
  if (destination.enabled === enabled)
    return;
  const response = await ((_a2 = CoreContext.clients.LiveApi().destination) == null ? void 0 : _a2.updateDestination({
    collectionId: project.videoApi.project.collectionId,
    projectId: project.videoApi.project.projectId,
    destinationId,
    updateMask: ["enabled"],
    enabled
  }));
  await triggerInternal$1("DestinationChanged", response.destination);
  const event2 = enabled ? "DestinationEnabled" : "DestinationDisabled";
  trigger$1(event2, {
    projectId,
    destinationId
  });
  return;
};
const setDestination = async (payload) => {
  var _a2, _b;
  const {
    rtmpUrl,
    rtmpKey,
    projectId = state.activeProjectId
  } = payload;
  const project = getProject(projectId);
  const rtmpPush = {
    key: rtmpKey,
    url: rtmpUrl
  };
  const enabled = true;
  if (project.videoApi.project.destinations.length > 0) {
    const response = await ((_a2 = CoreContext.clients.LiveApi().destination) == null ? void 0 : _a2.updateDestination({
      collectionId: project.videoApi.project.collectionId,
      projectId: project.videoApi.project.projectId,
      destinationId: project.videoApi.project.destinations[0].destinationId,
      updateMask: ["address.rtmpPush"],
      address: {
        rtmpPush
      }
    }));
    await triggerInternal$1("DestinationChanged", response.destination);
  } else {
    const response = await ((_b = CoreContext.clients.LiveApi().destination) == null ? void 0 : _b.createDestination({
      collectionId: project.videoApi.project.collectionId,
      projectId: project.videoApi.project.projectId,
      address: {
        rtmpPush
      },
      enabled
    }));
    await triggerInternal$1("DestinationAdded", response.destination);
  }
  trigger$1("DestinationSet", {
    projectId,
    rtmpUrl,
    rtmpKey
  });
  return;
};
var commands$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  updateUserProps,
  createProject: createProject$1,
  recreateLayout,
  deleteProject: deleteProject$1,
  updateProjectProps,
  updateProjectMeta,
  updateProjectPropsWithoutTrigger,
  setActiveProject,
  joinRoom,
  createNode,
  deleteNode,
  updateNode,
  setNodeLayout,
  moveNode,
  swapNodes,
  reorderNodes,
  startBroadcast,
  stopBroadcast,
  addDestination,
  removeDestination,
  updateDestination,
  updateDestinationProps,
  updateDestinationMeta,
  setDestinationEnabled,
  setDestination
}, Symbol.toStringTag, { value: "Module" }));
const useActiveProjectRoom$1 = () => {
  const [room, setRoom] = useState(null);
  useEffect(() => useActiveProjectRoom(setRoom), []);
  return room;
};
const useDevices = () => {
  const [devices, setDevices] = useState({
    webcams: [],
    microphones: [],
    speakers: []
  });
  useEffect(() => {
    return watchDevices(setDevices);
  }, []);
  return devices;
};
const StudioContext = React.createContext({
  studio: null,
  project: null,
  room: null,
  webcamId: null,
  microphoneId: null,
  setStudio: () => {
  },
  setProject: () => {
  },
  setRoom: () => {
  },
  setWebcamId: () => {
  },
  setMicrophoneId: () => {
  },
  projectCommands: {}
});
const useStudio = () => useContext(StudioContext);
let stored = {
  webcamId: null,
  microphoneId: null
};
try {
  stored.webcamId = localStorage == null ? void 0 : localStorage.getItem("__LS_webcam");
  stored.microphoneId = localStorage == null ? void 0 : localStorage.getItem("__LS_microphone");
} catch {
}
const StudioProvider = ({
  children
}) => {
  const [room, setRoom] = useState();
  const [project, setProject] = useState();
  const [studio, setStudio] = useState();
  const [webcamId, setWebcamId] = useState(stored.webcamId);
  const [microphoneId, setMicrophoneId] = useState(stored.microphoneId);
  const projectCommands = useMemo(() => project ? commands(project) : null, [project]);
  useEffect(() => {
    if (!project)
      return;
  }, [project]);
  useEffect(() => {
    if (!room)
      return;
    if (webcamId) {
      room.setCamera({
        deviceId: webcamId
      }).catch((e2) => {
        console.warn(e2);
      });
    }
    if (microphoneId) {
      room.setMicrophone({
        deviceId: microphoneId
      }).catch((e2) => {
        console.warn(e2);
      });
    }
  }, [room, webcamId, microphoneId]);
  return /* @__PURE__ */ React.createElement(StudioContext.Provider, {
    value: {
      studio,
      project,
      room,
      webcamId,
      microphoneId,
      setStudio,
      setProject,
      setRoom,
      setWebcamId: (id) => {
        try {
          localStorage == null ? void 0 : localStorage.setItem("__LS_webcam", id);
        } catch (e2) {
        }
        setWebcamId(id);
      },
      setMicrophoneId: (id) => {
        try {
          localStorage == null ? void 0 : localStorage.setItem("__LS_microphone", id);
        } catch (e2) {
        }
        setMicrophoneId(id);
      },
      projectCommands
    }
  }, children);
};
var react = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useActiveProjectRoom: useActiveProjectRoom$1,
  useDevices,
  StudioContext,
  useStudio,
  StudioProvider
}, Symbol.toStringTag, { value: "Module" }));
const ForegroundLayers = [{
  name: "ImageIframeOverlayContainer",
  id: "fg-image-iframe",
  layout: "Free"
}, {
  name: "BannerContainer",
  id: "fg-banners",
  layout: "Column",
  layoutProps: {
    cover: true
  }
}, {
  name: "VideoOverlayContainer",
  id: "fg-video",
  layout: "Free"
}, {
  name: "LogoContainer",
  layout: "Free",
  id: "logo"
}];
const defaultStyles = {
  custom: {
    display: "block"
  },
  video: {
    height: "100%",
    width: "100%"
  },
  image: {
    height: "100%",
    width: "100%"
  },
  logo: {
    objectFit: "contain",
    position: "unset"
  }
};
const validateEachChildren = (children, allowedSourceTypes) => {
  let isValid = true;
  children.forEach((child) => {
    var _a2, _b;
    if (((_a2 = child.props) == null ? void 0 : _a2.sourceType) && !allowedSourceTypes.includes((_b = child.props) == null ? void 0 : _b.sourceType)) {
      isValid = false;
    } else {
      if (child.children.length > 0) {
        isValid = isValid && validateEachChildren(child.children, allowedSourceTypes);
      }
    }
  });
  return isValid;
};
const addingCache = {
  camera: /* @__PURE__ */ new Set(),
  screen: /* @__PURE__ */ new Set()
};
const commands = (_project) => {
  var _a2, _b, _c, _d;
  const projectId = _project.id;
  const root2 = _project.scene.getRoot();
  const {
    Command
  } = CoreContext;
  const background = root2.children.find((x) => x.props.id === "bg");
  const content = root2.children.find((x) => x.props.id === "content");
  const foreground = root2.children.find((x) => x.props.id === "foreground");
  let foregroundImageIframeContainer = (_a2 = foreground == null ? void 0 : foreground.children) == null ? void 0 : _a2.find((x) => x.props.id === "fg-image-iframe");
  let foregroundLogoContainer = (_b = foreground == null ? void 0 : foreground.children) == null ? void 0 : _b.find((x) => x.props.id === "logo");
  let foregroundVideoContainer = (_c = foreground == null ? void 0 : foreground.children) == null ? void 0 : _c.find((x) => x.props.id === "fg-video");
  const coreProject = getProject(_project.id);
  let bannerContainer = (_d = foreground == null ? void 0 : foreground.children) == null ? void 0 : _d.find((x) => x.props.id === "fg-banners");
  const ensureRootLayersProps = async () => {
    var _a3, _b2;
    if (((_a3 = background == null ? void 0 : background.props) == null ? void 0 : _a3.layout) !== "Layered") {
      await coreProject.compositor.update(background.id, {
        name: "Background",
        id: "bg",
        layout: "Layered"
      });
    }
    if (((_b2 = foreground == null ? void 0 : foreground.props) == null ? void 0 : _b2.layout) !== "Layered") {
      await coreProject.compositor.update(foreground.id, {
        id: "foreground",
        name: "Overlays",
        layout: "Layered"
      });
    }
  };
  const ensureBackgroundChildLayersProps = async () => {
    if (!validateEachChildren(background.children, ["Background"])) {
      background.children.forEach(async (child) => {
        await CoreContext.Command.deleteNode({
          nodeId: child.id
        });
      });
    }
  };
  const ensureForegroundContainers = async () => {
    const ensureBannerContainer = async () => {
      var _a3;
      if (!bannerContainer) {
        const nodeId = await coreProject.compositor.insert({
          name: "BannerContainer",
          id: "fg-banners",
          layout: "Column",
          layoutProps: {
            cover: true
          }
        }, foreground.id);
        bannerContainer = (_a3 = foreground == null ? void 0 : foreground.children) == null ? void 0 : _a3.find((x) => x.id === nodeId);
        return nodeId;
      } else {
        return bannerContainer.id;
      }
    };
    const ensureForegroundImageAndIframeContainer = async () => {
      var _a3;
      if (!foregroundImageIframeContainer) {
        const nodeId = await coreProject.compositor.insert({
          name: "ImageIframeOverlay",
          id: "fg-image-iframe",
          layout: "Free"
        }, foreground.id);
        foregroundImageIframeContainer = (_a3 = foreground == null ? void 0 : foreground.children) == null ? void 0 : _a3.find((x) => x.id === nodeId);
        return nodeId;
      } else {
        return foregroundImageIframeContainer.id;
      }
    };
    const ensureForegroundVideoContainer = async () => {
      var _a3;
      if (!foregroundVideoContainer) {
        const nodeId = await coreProject.compositor.insert({
          name: "VideoOverlay",
          id: "fg-video",
          layout: "Free"
        }, foreground.id);
        foregroundVideoContainer = (_a3 = foreground == null ? void 0 : foreground.children) == null ? void 0 : _a3.find((x) => x.id === nodeId);
        return nodeId;
      } else {
        return foregroundVideoContainer.id;
      }
    };
    const ensureForegroundLogoContainer = async () => {
      var _a3;
      if (!foregroundLogoContainer) {
        const nodeId = await coreProject.compositor.insert({
          name: "Logo",
          layout: "Free",
          sourceType: "Logo",
          id: "logo",
          style: {
            width: "100%",
            height: "100%",
            objectFit: "contain",
            position: "unset"
          }
        }, foreground.id);
        foregroundLogoContainer = (_a3 = foreground == null ? void 0 : foreground.children) == null ? void 0 : _a3.find((x) => x.id === nodeId);
        return nodeId;
      } else {
        return foregroundLogoContainer.id;
      }
    };
    try {
      const baseForegroundLayers = await Promise.all([ensureBannerContainer(), ensureForegroundImageAndIframeContainer(), ensureForegroundVideoContainer(), ensureForegroundLogoContainer()]);
      await coreProject.compositor.reorder(foreground.id, baseForegroundLayers);
    } catch (e2) {
    }
  };
  const commands2 = {
    getBackground() {
      return background;
    },
    getContent() {
      return content;
    },
    getForeground() {
      return foreground;
    },
    getLayout() {
      return content.props.layout;
    },
    getBanners() {
      var _a3;
      return ((_a3 = getProject(_project.id).props) == null ? void 0 : _a3.banners) || [];
    },
    getOverlays() {
      return getProject(_project.id).props.overlays || [];
    },
    getParticipants() {
      return content.children.filter((node) => {
        if (node.props.sourceType !== "RoomParticipant")
          return false;
        return true;
      });
    },
    getLogo() {
      var _a3, _b2;
      return (_b2 = (_a3 = foregroundLogoContainer == null ? void 0 : foregroundLogoContainer.children[0]) == null ? void 0 : _a3.props) == null ? void 0 : _b2.id;
    },
    async removeLogo() {
      const [existingLogoNode, ...excessLogoNode] = (foregroundLogoContainer == null ? void 0 : foregroundLogoContainer.children) || [];
      excessLogoNode.forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
      if (existingLogoNode) {
        await CoreContext.Command.deleteNode({
          nodeId: existingLogoNode.id
        });
      }
    },
    getImageOverlay() {
      var _a3, _b2;
      const foregroundImage = (_a3 = foregroundImageIframeContainer == null ? void 0 : foregroundImageIframeContainer.children) == null ? void 0 : _a3.find((x) => {
        var _a4, _b3;
        return ((_b3 = (_a4 = x == null ? void 0 : x.props) == null ? void 0 : _a4.sourceProps) == null ? void 0 : _b3.type) === "image";
      });
      return (_b2 = foregroundImage == null ? void 0 : foregroundImage.props) == null ? void 0 : _b2.id;
    },
    getVideoOverlay() {
      var _a3, _b2;
      const foregroundVideo = (_a3 = foregroundVideoContainer == null ? void 0 : foregroundVideoContainer.children) == null ? void 0 : _a3.find((x) => {
        var _a4, _b3;
        return ((_b3 = (_a4 = x == null ? void 0 : x.props) == null ? void 0 : _a4.sourceProps) == null ? void 0 : _b3.type) === "video";
      });
      return (_b2 = foregroundVideo == null ? void 0 : foregroundVideo.props) == null ? void 0 : _b2.id;
    },
    autoPlayBackgroundVideo(attributes = {
      muted: true,
      autoplay: true
    }) {
      const backgroundVideo = background.children.find((x) => x.props.id === "bg-video");
      if (!backgroundVideo) {
        return;
      }
      CoreContext.Command.updateNode({
        nodeId: backgroundVideo.id,
        props: {
          ...backgroundVideo.props,
          attributes: {
            ...backgroundVideo.props.attributes,
            ...attributes
          }
        }
      });
    },
    autoPlayVideoOverlay(overlayId, attributes = {
      muted: true,
      autoplay: true
    }) {
      var _a3;
      const overlay = (_a3 = foregroundVideoContainer == null ? void 0 : foregroundVideoContainer.children) == null ? void 0 : _a3.find((x) => {
        var _a4, _b2;
        return ((_b2 = (_a4 = x.props) == null ? void 0 : _a4.sourceProps) == null ? void 0 : _b2.id) === overlayId;
      });
      if (!overlay) {
        return;
      }
      if (overlay.props.sourceProps.type === "video") {
        CoreContext.Command.updateNode({
          nodeId: overlay.id,
          props: {
            ...overlay.props,
            attributes: {
              ...overlay.props.attributes,
              ...attributes
            }
          }
        });
      }
    },
    getBackgroundMedia() {
      var _a3, _b2;
      const backgroundChild = background.children.filter((x) => x);
      return (_b2 = (_a3 = backgroundChild[0]) == null ? void 0 : _a3.props) == null ? void 0 : _b2.id;
    },
    getBackgroundImage() {
      var _a3;
      const backgroundChild = background.children.find((x) => {
        var _a4, _b2;
        return ((_b2 = (_a4 = x.props) == null ? void 0 : _a4.sourceProps) == null ? void 0 : _b2.type) === "image";
      });
      return (_a3 = backgroundChild == null ? void 0 : backgroundChild.props) == null ? void 0 : _a3.id;
    },
    getBackgroundVideo() {
      var _a3;
      const backgroundChild = background.children.find((x) => {
        var _a4, _b2;
        return ((_b2 = (_a4 = x.props) == null ? void 0 : _a4.sourceProps) == null ? void 0 : _b2.type) === "video";
      });
      return (_a3 = backgroundChild == null ? void 0 : backgroundChild.props) == null ? void 0 : _a3.id;
    },
    async addLogo(id, props) {
      const [existingLogoNode, ...excessLogoNodes] = (foregroundLogoContainer == null ? void 0 : foregroundLogoContainer.children) || [];
      excessLogoNodes.forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
      if (!existingLogoNode) {
        await CoreContext.Command.createNode({
          parentId: foregroundLogoContainer == null ? void 0 : foregroundLogoContainer.id,
          props: {
            sourceType: "Logo",
            id,
            sourceProps: {
              ...props,
              meta: {
                style: {
                  ...defaultStyles["logo"]
                },
                ...props.meta
              }
            }
          }
        });
      } else {
        await CoreContext.Command.updateNode({
          nodeId: existingLogoNode.id,
          props: {
            sourceType: "Logo",
            id,
            sourceProps: {
              ...props,
              meta: {
                style: {
                  ...defaultStyles["logo"]
                },
                ...props.meta
              }
            }
          }
        });
      }
    },
    addBanner(props = {}) {
      var _a3;
      const meta = props.meta || {};
      const banner = {
        id: generateId(),
        props: {
          ...props,
          meta
        }
      };
      const existingBanners = ((_a3 = getProject(projectId).props) == null ? void 0 : _a3.banners) || [];
      return Command.updateProjectProps({
        projectId,
        props: {
          banners: [...existingBanners, banner]
        }
      });
    },
    editBanner(id, props = {}) {
      const existingBanners = commands2.getBanners();
      const banners = existingBanners.map((x) => {
        if (x.id !== id)
          return x;
        return {
          ...x,
          props
        };
      });
      return Command.updateProjectProps({
        projectId,
        props: {
          banners
        }
      });
    },
    removeBanner(id) {
      var _a3;
      const existingBanners = commands2.getBanners();
      (_a3 = bannerContainer == null ? void 0 : bannerContainer.children) == null ? void 0 : _a3.forEach((x) => {
        if (x.props.bannerId !== id)
          return;
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
      return Command.updateProjectProps({
        projectId,
        props: {
          banners: existingBanners.filter((x) => x.id !== id)
        }
      });
    },
    async setActiveBanner(id) {
      var _a3, _b2;
      const [nodeTocheckForChildren, ...{}] = (bannerContainer == null ? void 0 : bannerContainer.children) || [];
      if (((_b2 = (_a3 = nodeTocheckForChildren == null ? void 0 : nodeTocheckForChildren.props) == null ? void 0 : _a3.sourceType) == null ? void 0 : _b2.toLowerCase()) === "chatoverlay") {
        await CoreContext.Command.deleteNode({
          nodeId: nodeTocheckForChildren.id
        });
      }
      const [existingBannerNode, ...excessBannerNodes] = (bannerContainer == null ? void 0 : bannerContainer.children) || [];
      excessBannerNodes.forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
      if (!existingBannerNode) {
        return CoreContext.Command.createNode({
          parentId: bannerContainer == null ? void 0 : bannerContainer.id,
          props: {
            sourceType: "Banner",
            bannerId: id
          }
        });
      } else {
        CoreContext.Command.updateNode({
          nodeId: existingBannerNode.id,
          props: {
            sourceType: "Banner",
            bannerId: id
          }
        });
      }
    },
    getActiveBanner() {
      var _a3, _b2, _c2, _d2;
      return (_d2 = (_c2 = (_b2 = (_a3 = bannerContainer.children) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.props) == null ? void 0 : _c2.bannerId) != null ? _d2 : null;
    },
    async addChatOverlay(id, options) {
      var _a3, _b2;
      const [nodeTocheckForChildren, ...{}] = (bannerContainer == null ? void 0 : bannerContainer.children) || [];
      if (((_b2 = (_a3 = nodeTocheckForChildren == null ? void 0 : nodeTocheckForChildren.props) == null ? void 0 : _a3.sourceType) == null ? void 0 : _b2.toLowerCase()) === "banner") {
        await CoreContext.Command.deleteNode({
          nodeId: nodeTocheckForChildren.id
        });
      }
      const [existingBannerNode, ...excessBannerNodes] = (bannerContainer == null ? void 0 : bannerContainer.children) || [];
      excessBannerNodes.forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
      if (!existingBannerNode) {
        await CoreContext.Command.createNode({
          parentId: bannerContainer == null ? void 0 : bannerContainer.id,
          props: {
            sourceType: "ChatOverlay",
            chatOverlayId: id,
            id,
            ...options
          }
        });
      } else {
        await CoreContext.Command.updateNode({
          nodeId: existingBannerNode.id,
          props: {
            sourceType: "ChatOverlay",
            chatOverlayId: id,
            id,
            ...options
          }
        });
      }
    },
    async removeChatOverlay(id) {
      var _a3;
      (_a3 = bannerContainer == null ? void 0 : bannerContainer.children) == null ? void 0 : _a3.forEach(async (x) => {
        if (x.props.chatOverlayId !== id)
          return;
        await CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
    },
    getChatOverlay() {
      var _a3, _b2, _c2, _d2, _e;
      return ((_c2 = (_b2 = (_a3 = bannerContainer.children) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.props) == null ? void 0 : _c2.chatOverlayId) ? ((_e = (_d2 = bannerContainer.children) == null ? void 0 : _d2[0]) == null ? void 0 : _e.props) || null : null;
    },
    getCustomOverlay() {
      var _a3, _b2;
      const foregroundCustom = (_a3 = foregroundImageIframeContainer == null ? void 0 : foregroundImageIframeContainer.children) == null ? void 0 : _a3.find((x) => {
        var _a4, _b3;
        return ((_b3 = (_a4 = x == null ? void 0 : x.props) == null ? void 0 : _a4.sourceProps) == null ? void 0 : _b3.type) === "custom";
      });
      return (_b2 = foregroundCustom == null ? void 0 : foregroundCustom.props) == null ? void 0 : _b2.id;
    },
    async addImageOverlay(id, props) {
      const [existingForegroundNode, ...excessForegroundNode] = (foregroundImageIframeContainer == null ? void 0 : foregroundImageIframeContainer.children) || [];
      excessForegroundNode.forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
      const extendedDefaultStyles = {
        ...defaultStyles["image"],
        ...(foregroundVideoContainer == null ? void 0 : foregroundVideoContainer.children.length) && {
          opacity: 0
        }
      };
      if (!existingForegroundNode) {
        await CoreContext.Command.createNode({
          parentId: foregroundImageIframeContainer == null ? void 0 : foregroundImageIframeContainer.id,
          props: {
            sourceType: "Overlay",
            id,
            sourceProps: {
              ...props,
              type: "image",
              meta: {
                style: {
                  ...extendedDefaultStyles
                }
              }
            }
          }
        });
      } else {
        await CoreContext.Command.updateNode({
          nodeId: existingForegroundNode == null ? void 0 : existingForegroundNode.id,
          props: {
            sourceType: "Overlay",
            id,
            sourceProps: {
              ...props,
              type: "image",
              meta: {
                style: {
                  ...extendedDefaultStyles
                }
              }
            }
          }
        });
      }
    },
    async addVideoOverlay(id, props) {
      const [existingForegroundNode, ...excessForegroundNode] = (foregroundVideoContainer == null ? void 0 : foregroundVideoContainer.children) || [];
      excessForegroundNode.forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
      foregroundImageIframeContainer.children.forEach(({
        id: id2,
        props: localProps
      }) => {
        var _a3, _b2;
        if (((_b2 = (_a3 = localProps.sourceProps.meta) == null ? void 0 : _a3.style) == null ? void 0 : _b2.opacity) !== 0) {
          const type = localProps.sourceProps.type;
          const extendedDefaultStyles = {
            ...defaultStyles[type],
            opacity: 0
          };
          CoreContext.Command.updateNode({
            nodeId: id2,
            props: {
              ...localProps,
              sourceProps: {
                ...localProps.sourceProps,
                meta: {
                  style: {
                    ...extendedDefaultStyles
                  }
                }
              }
            }
          });
        }
      });
      if (!existingForegroundNode) {
        await CoreContext.Command.createNode({
          parentId: foregroundVideoContainer == null ? void 0 : foregroundVideoContainer.id,
          props: {
            sourceType: "Overlay",
            id,
            sourceProps: {
              ...props,
              type: "video",
              meta: {
                style: {
                  ...defaultStyles["video"]
                },
                ...props.meta
              }
            }
          }
        });
      } else {
        await CoreContext.Command.updateNode({
          nodeId: existingForegroundNode == null ? void 0 : existingForegroundNode.id,
          props: {
            sourceType: "Overlay",
            id,
            sourceProps: {
              ...props,
              type: "video",
              meta: {
                style: {
                  ...defaultStyles["video"]
                },
                ...props.meta
              }
            }
          }
        });
      }
    },
    async updateVideoOverlayProps(id, props) {
      var _a3, _b2;
      const existingForegroundNode = ((_a3 = foregroundVideoContainer == null ? void 0 : foregroundVideoContainer.children) == null ? void 0 : _a3.find((x) => {
        var _a4;
        return ((_a4 = x == null ? void 0 : x.props) == null ? void 0 : _a4.id) === id;
      })) || null;
      if (!existingForegroundNode) {
        return;
      }
      await CoreContext.Command.updateNode({
        nodeId: existingForegroundNode == null ? void 0 : existingForegroundNode.id,
        props: {
          sourceType: "Overlay",
          id,
          sourceProps: {
            ...(_b2 = existingForegroundNode == null ? void 0 : existingForegroundNode.props) == null ? void 0 : _b2.sourceProps,
            ...props,
            meta: {
              style: {
                ...defaultStyles["video"]
              },
              ...props.meta
            }
          }
        }
      });
    },
    async addCustomOverlay(id, props) {
      const [existingForegroundNode, ...excessForegroundNode] = (foregroundImageIframeContainer == null ? void 0 : foregroundImageIframeContainer.children) || [];
      excessForegroundNode.forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
      const extendedDefaultStyles = {
        ...defaultStyles["custom"],
        ...(foregroundVideoContainer == null ? void 0 : foregroundVideoContainer.children.length) && {
          opacity: 0
        }
      };
      if (!existingForegroundNode) {
        await CoreContext.Command.createNode({
          parentId: foregroundImageIframeContainer == null ? void 0 : foregroundImageIframeContainer.id,
          props: {
            sourceType: "Overlay",
            id,
            sourceProps: {
              ...props,
              type: "custom",
              meta: {
                style: {
                  ...extendedDefaultStyles
                }
              }
            }
          }
        });
      } else {
        await CoreContext.Command.updateNode({
          nodeId: existingForegroundNode == null ? void 0 : existingForegroundNode.id,
          props: {
            sourceType: "Overlay",
            id,
            sourceProps: {
              ...props,
              type: "custom",
              meta: {
                style: {
                  ...extendedDefaultStyles
                }
              }
            }
          }
        });
      }
    },
    async removeCustomOverlay() {
      var _a3, _b2;
      const [existingForegroundNode, ...excessForegroundNode] = (foregroundImageIframeContainer == null ? void 0 : foregroundImageIframeContainer.children) || [];
      excessForegroundNode.forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
      if (existingForegroundNode) {
        if (((_b2 = (_a3 = existingForegroundNode == null ? void 0 : existingForegroundNode.props) == null ? void 0 : _a3.sourceProps) == null ? void 0 : _b2.type) === "custom") {
          await CoreContext.Command.deleteNode({
            nodeId: existingForegroundNode.id
          });
        }
      }
    },
    async removeImageOverlay() {
      var _a3, _b2;
      const [existingForegroundNode, ...excessForegroundNode] = (foregroundImageIframeContainer == null ? void 0 : foregroundImageIframeContainer.children) || [];
      excessForegroundNode.forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
      if (existingForegroundNode) {
        if (((_b2 = (_a3 = existingForegroundNode == null ? void 0 : existingForegroundNode.props) == null ? void 0 : _a3.sourceProps) == null ? void 0 : _b2.type) === "image") {
          await CoreContext.Command.deleteNode({
            nodeId: existingForegroundNode.id
          });
        }
      }
    },
    async removeVideoOverlay() {
      const [existingForegroundNode, ...excessForegroundNode] = (foregroundVideoContainer == null ? void 0 : foregroundVideoContainer.children) || [];
      excessForegroundNode.forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
      if (existingForegroundNode) {
        await CoreContext.Command.deleteNode({
          nodeId: existingForegroundNode.id
        });
      }
      foregroundImageIframeContainer == null ? void 0 : foregroundImageIframeContainer.children.forEach(({
        id,
        props
      }) => {
        var _a3, _b2;
        if (((_b2 = (_a3 = props.sourceProps.meta) == null ? void 0 : _a3.style) == null ? void 0 : _b2.opacity) === 0) {
          const type = props.sourceProps.type;
          const extendedDefaultStyles = {
            ...defaultStyles[type],
            opacity: 1
          };
          CoreContext.Command.updateNode({
            nodeId: id,
            props: {
              ...props,
              sourceProps: {
                ...props.sourceProps,
                meta: {
                  style: {
                    ...extendedDefaultStyles
                  }
                }
              }
            }
          });
        }
      });
    },
    setLayout(layout, layoutProps = {}) {
      const showcase = content.props.layoutProps.showcase;
      Command.setNodeLayout({
        nodeId: content.id,
        layout,
        layoutProps: {
          showcase,
          ...layoutProps
        }
      });
    },
    async setBackgroundImage(id, props) {
      const [existingBackgroundNode, ...excessBackgroundNode] = (background == null ? void 0 : background.children) || [];
      excessBackgroundNode.forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
      if (!existingBackgroundNode) {
        await CoreContext.Command.createNode({
          parentId: background == null ? void 0 : background.id,
          props: {
            id,
            sourceType: "Background",
            sourceProps: {
              ...props,
              type: "image",
              meta: {
                style: {
                  ...defaultStyles["image"]
                },
                ...props == null ? void 0 : props.meta
              }
            }
          }
        });
      } else {
        await CoreContext.Command.updateNode({
          nodeId: existingBackgroundNode.id,
          props: {
            id,
            sourceType: "Background",
            sourceProps: {
              ...props,
              type: "image",
              meta: {
                style: {
                  ...defaultStyles["image"]
                },
                ...props == null ? void 0 : props.meta
              }
            }
          }
        });
      }
    },
    async setBackgroundVideo(id, props) {
      const [existingBackgroundNode, ...excessBackgroundNode] = (background == null ? void 0 : background.children) || [];
      excessBackgroundNode.forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
      if (!existingBackgroundNode) {
        await CoreContext.Command.createNode({
          parentId: background == null ? void 0 : background.id,
          props: {
            id,
            sourceType: "Background",
            sourceProps: {
              ...props,
              type: "video",
              meta: {
                style: {
                  ...defaultStyles["video"]
                },
                ...props == null ? void 0 : props.meta
              }
            }
          }
        });
      } else {
        await CoreContext.Command.updateNode({
          nodeId: existingBackgroundNode.id,
          props: {
            id,
            sourceType: "Background",
            sourceProps: {
              ...props,
              type: "video",
              meta: {
                style: {
                  ...defaultStyles["video"]
                },
                ...props == null ? void 0 : props.meta
              }
            }
          }
        });
      }
    },
    async updateBackgroundVideoProps(id, props) {
      var _a3, _b2;
      const existingBackgroundNode = ((_a3 = background == null ? void 0 : background.children) == null ? void 0 : _a3.find((x) => {
        var _a4;
        return ((_a4 = x == null ? void 0 : x.props) == null ? void 0 : _a4.id) === id;
      })) || null;
      if (!existingBackgroundNode) {
        return;
      }
      await CoreContext.Command.updateNode({
        nodeId: existingBackgroundNode == null ? void 0 : existingBackgroundNode.id,
        props: {
          sourceType: "Background",
          id,
          sourceProps: {
            ...(_b2 = existingBackgroundNode == null ? void 0 : existingBackgroundNode.props) == null ? void 0 : _b2.sourceProps,
            ...props,
            meta: {
              style: {
                ...defaultStyles["video"]
              },
              ...props.meta
            }
          }
        }
      });
    },
    async removeBackgroundImage() {
      const [existingBackgroundNode, ...excessBackgroundNode] = (background == null ? void 0 : background.children) || [];
      excessBackgroundNode.forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
      if (existingBackgroundNode) {
        if (existingBackgroundNode.props.sourceProps.type === "image") {
          await CoreContext.Command.deleteNode({
            nodeId: existingBackgroundNode.id
          });
        }
      }
    },
    async removeBackgroundVideo() {
      const [existingBackgroundNode, ...excessBackgroundNode] = (background == null ? void 0 : background.children) || [];
      excessBackgroundNode.forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
      if (existingBackgroundNode) {
        if (existingBackgroundNode.props.sourceProps.type === "video") {
          await CoreContext.Command.deleteNode({
            nodeId: existingBackgroundNode.id
          });
        }
      }
    },
    useLayerState(sourceType, cb) {
      const shallowRoot = cloneDeep(root2);
      let layerNode = findAll(shallowRoot, (x) => x.props.sourceType === sourceType);
      const sendState = () => {
        cb((layerNode == null ? void 0 : layerNode.map((l) => l.props)) || {});
      };
      const layerChangeListener = CoreContext.onInternal("NodeChanged", (payload) => {
        const changedLayer = layerNode == null ? void 0 : layerNode.find((l) => l.id === payload.nodeId);
        if ((layerNode == null ? void 0 : layerNode.length) && !changedLayer)
          return;
        const previousLayerNode = layerNode;
        const shallowRoot2 = cloneDeep(root2);
        layerNode = findAll(shallowRoot2, (x) => {
          var _a3;
          return ((_a3 = x == null ? void 0 : x.props) == null ? void 0 : _a3.sourceType) === sourceType;
        });
        if (!fastDeepEqual(previousLayerNode, layerNode)) {
          sendState();
        }
      });
      const layerAddListener = CoreContext.onInternal("NodeAdded", (payload) => {
        var _a3;
        const existingLayer = layerNode == null ? void 0 : layerNode.find((l) => l.id === payload.nodeId);
        if (existingLayer)
          return;
        const shallowRoot2 = cloneDeep(root2);
        layerNode = findAll(shallowRoot2, (x) => {
          var _a4;
          return ((_a4 = x == null ? void 0 : x.props) == null ? void 0 : _a4.sourceType) === sourceType;
        });
        const addedLayer = layerNode == null ? void 0 : layerNode.find((l) => l.id === payload.nodeId);
        if (((_a3 = addedLayer == null ? void 0 : addedLayer.props) == null ? void 0 : _a3.sourceType) === sourceType) {
          sendState();
        }
      });
      const layerRemoveListener = CoreContext.onInternal("NodeRemoved", (payload) => {
        var _a3;
        const removedLayer = layerNode == null ? void 0 : layerNode.find((l) => l.id === payload.nodeId);
        if (!removedLayer)
          return;
        layerNode = layerNode == null ? void 0 : layerNode.filter((l) => l.id !== payload.nodeId);
        if (((_a3 = removedLayer == null ? void 0 : removedLayer.props) == null ? void 0 : _a3.sourceType) === sourceType) {
          sendState();
        }
      });
      sendState();
      return () => {
        layerChangeListener();
        layerAddListener();
        layerRemoveListener();
      };
    },
    setShowcase(participantId, type = "camera") {
      var _a3;
      const node = commands2.getParticipantNode(participantId, type);
      return CoreContext.Command.updateNode({
        nodeId: content.id,
        props: {
          layoutProps: {
            ...content.props.layoutProps,
            showcase: (_a3 = node == null ? void 0 : node.id) != null ? _a3 : null
          }
        }
      });
    },
    useShowcase(cb) {
      const sendState = () => {
        const nodeId = content.props.layoutProps.showcase;
        const node = content.children.find((x) => x.id === nodeId);
        if (!node)
          return cb({
            participantId: null,
            type: null
          });
        const {
          sourceProps
        } = node.props;
        return cb({
          participantId: sourceProps.id,
          type: sourceProps.type
        });
      };
      sendState();
      return CoreContext.onInternal("NodeChanged", (payload) => {
        if (payload.nodeId !== content.id)
          return;
        sendState();
      });
    },
    async addParticipantTrack(trackId, props = {
      isMuted: true,
      isHidden: false,
      volume: 0
    }, type = "camera") {
      if (addingCache[type].has(trackId))
        return;
      const {
        isMuted = false,
        isHidden = false,
        volume = 1
      } = props;
      const existing = content.children.find((x) => {
        var _a3, _b2;
        return ((_a3 = x.props.sourceProps) == null ? void 0 : _a3.id) === trackId && ((_b2 = x.props.sourceProps) == null ? void 0 : _b2.type) === type;
      });
      if (existing)
        return;
      addingCache[type].add(trackId);
      const currentFirst = content.children[0];
      let index2 = content.children.length;
      if (type === "screen" && (currentFirst == null ? void 0 : currentFirst.props.sourceProps.type) !== "screen") {
        index2 = 0;
      }
      await CoreContext.Command.createNode({
        props: {
          name: "Participant",
          sourceType: "RoomParticipant",
          sourceProps: {
            type,
            id: trackId
          },
          volume,
          isMuted,
          isHidden
        },
        parentId: content.id,
        index: index2
      }).finally(() => {
        addingCache[type].delete(trackId);
      });
    },
    removeParticipantTrack(trackId, type = "camera") {
      content.children.filter((x) => {
        var _a3, _b2;
        return ((_a3 = x.props.sourceProps) == null ? void 0 : _a3.id) === trackId && ((_b2 = x.props.sourceProps) == null ? void 0 : _b2.type) === type && x.props.sourceType === "RoomParticipant";
      }).forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
    },
    async addParticipant(participantId, props = {}, type = "camera") {
      if (addingCache[type].has(participantId))
        return;
      const {
        isMuted = false,
        isHidden = false,
        volume = 1
      } = props;
      const existing = content.children.find((x) => {
        var _a3, _b2;
        return ((_a3 = x.props.sourceProps) == null ? void 0 : _a3.id) === participantId && ((_b2 = x.props.sourceProps) == null ? void 0 : _b2.type) === type;
      });
      if (existing)
        return;
      addingCache[type].add(participantId);
      const currentFirst = content.children[0];
      let index2 = content.children.length;
      if (type === "screen" && (currentFirst == null ? void 0 : currentFirst.props.sourceProps.type) !== "screen") {
        index2 = 0;
      }
      await CoreContext.Command.createNode({
        props: {
          name: "Participant",
          sourceType: "RoomParticipant",
          sourceProps: {
            type,
            id: participantId
          },
          volume,
          isMuted,
          isHidden
        },
        parentId: content.id,
        index: index2
      }).finally(() => {
        addingCache[type].delete(participantId);
      });
    },
    addParticipantScreenshare(participantId, props = {}) {
      return commands2.addParticipant(participantId, props, "screen");
    },
    removeParticipant(participantId, type = "camera") {
      content.children.filter((x) => {
        var _a3, _b2;
        return ((_a3 = x.props.sourceProps) == null ? void 0 : _a3.id) === participantId && ((_b2 = x.props.sourceProps) == null ? void 0 : _b2.type) === type && x.props.sourceType === "RoomParticipant";
      }).forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
    },
    removeParticipantScreenshare(participantId) {
      return commands2.removeParticipant(participantId, "screen");
    },
    getParticipantNode(id, type = "camera") {
      return content.children.find((x) => {
        var _a3, _b2;
        return ((_a3 = x.props.sourceProps) == null ? void 0 : _a3.id) === id && ((_b2 = x.props.sourceProps) == null ? void 0 : _b2.type) === type;
      });
    },
    getParticipantState(participantId, type = "camera") {
      var _a3;
      return (_a3 = commands2.getParticipantNode(participantId, type)) == null ? void 0 : _a3.props;
    },
    useParticipantState(participantId, cb, type = "camera") {
      let participantNode = commands2.getParticipantNode(participantId, type);
      const sendState = () => {
        cb(participantNode == null ? void 0 : participantNode.props);
      };
      const childListener = CoreContext.onInternal("NodeChanged", (payload) => {
        if (payload.nodeId !== content.id)
          return;
        const previous = participantNode;
        participantNode = commands2.getParticipantNode(participantId, type);
        if (previous !== participantNode) {
          sendState();
        }
      });
      const participantListener = CoreContext.onInternal("NodeChanged", (payload) => {
        if (!participantNode || payload.nodeId !== participantNode.id)
          return;
        sendState();
      });
      sendState();
      return () => {
        childListener();
        participantListener();
      };
    },
    setParticipantVolume(participantId, volume) {
      const node = commands2.getParticipantNode(participantId);
      if (!node)
        return;
      CoreContext.Command.updateNode({
        nodeId: node.id,
        props: {
          volume
        }
      });
    },
    setParticipantMuted(participantId, isMuted) {
      const node = commands2.getParticipantNode(participantId);
      if (!node)
        return;
      CoreContext.Command.updateNode({
        nodeId: node.id,
        props: {
          isMuted
        }
      });
    },
    setParticipantHidden(participantId, isHidden) {
      const node = commands2.getParticipantNode(participantId);
      if (!node)
        return;
      CoreContext.Command.updateNode({
        nodeId: node.id,
        props: {
          isHidden
        }
      });
    },
    pruneParticipants() {
      const room = getProjectRoom(projectId);
      if (!room)
        return;
      content.children.filter((node) => {
        var _a3, _b2, _c2;
        if (node.props.sourceType !== "RoomParticipant")
          return false;
        const nodeSourceType = (_a3 = node.props.sourceProps) == null ? void 0 : _a3.type;
        const nodeParticipant = room.getParticipant((_b2 = node.props.sourceProps) == null ? void 0 : _b2.id);
        const nodeParticipantTrack = room.getTrack((_c2 = node.props.sourceProps) == null ? void 0 : _c2.id);
        if (!nodeParticipant && !nodeParticipantTrack)
          return true;
        if (nodeSourceType === "camera")
          return false;
        const participantTracks = nodeParticipant.trackIds.map((x) => room.getTrack(x)).filter(Boolean);
        const hasAvailableTrack = participantTracks.some((track) => {
          const sourceType = track.type === Track.Source.Camera || track.type === Track.Source.Microphone ? "camera" : "screen";
          return sourceType === nodeSourceType;
        });
        return !hasAvailableTrack;
      }).forEach((x) => {
        CoreContext.Command.deleteNode({
          nodeId: x.id
        });
      });
    },
    getProp(prop) {
      return getProject(_project.id).props[prop];
    },
    setProp(prop, val) {
      return Command.updateProjectProps({
        projectId,
        props: {
          [prop]: val
        }
      });
    },
    useProp(prop, cb) {
      return CoreContext.on("ProjectChanged", (payload) => {
        if (projectId === payload.project.id) {
          cb(payload.project.props[prop]);
        }
      });
    }
  };
  const ensureValid = async () => {
    await ensureRootLayersProps();
    await ensureBackgroundChildLayersProps();
    await ensureForegroundContainers();
  };
  ensureValid();
  return commands2;
};
const create = async (settings = {}, props = {}, size) => {
  return CoreContext.Command.createProject({
    settings,
    props,
    size
  });
};
const createCompositor = async (layoutId, size, settings) => {
  const {
    layout,
    layoutProps = {}
  } = settings;
  const project = await CoreContext.compositor.createProject({
    props: {
      name: "Root",
      type: "sceneless-project",
      sourceType: "Element",
      layout: "Layered",
      size,
      isRoot: true,
      tagName: "div",
      version: "beta",
      fields: {
        style: {
          background: "black"
        }
      }
    }
  }, layoutId);
  const root2 = project.getRoot();
  const baseLayers = await Promise.all([project.insert({
    name: "Background",
    id: "bg",
    layout: "Layered"
  }, root2.id), project.insert({
    id: "content",
    name: "Content",
    layout,
    layoutProps
  }, root2.id), project.insert({
    id: "foreground",
    name: "Overlays",
    layout: "Layered"
  }, root2.id)]);
  await project.reorder(root2.id, baseLayers);
  const foreground = root2.children.find((x) => x.props.id === "foreground");
  const foregroundLayerPromises = ForegroundLayers.map((layer) => project.insert(layer, foreground.id));
  const baseForegroundLayers = await Promise.all(foregroundLayerPromises);
  await project.reorder(foreground.id, baseForegroundLayers);
  return project;
};
var scenelessProject = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  commands,
  create,
  createCompositor
}, Symbol.toStringTag, { value: "Module" }));
const useActiveProjectRoom = (cb) => {
  const project = getProject(CoreContext.state.activeProjectId);
  cb(project ? getRoom(project.roomId) : null);
  return CoreContext.on("RoomJoined", () => {
    const project2 = getProject(CoreContext.state.activeProjectId);
    cb(project2 ? getRoom(project2.roomId) : null);
  });
};
var callbacks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useActiveProjectRoom
}, Symbol.toStringTag, { value: "Module" }));
var index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  React: react,
  ScenelessProject: scenelessProject,
  Callback: callbacks,
  Room: webrtc,
  Compositor: compositor$1
}, Symbol.toStringTag, { value: "Module" }));
const runFilters = (node, filters = []) => {
  return filters.reduce((node2, filter2) => filter2(node2), node);
};
var transforms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  runFilters
}, Symbol.toStringTag, { value: "Module" }));
const createDefault = () => {
  return {
    root: document.createElement("div")
  };
};
const init$2 = (settings = {}, compositor2, sourceManager) => {
  const transforms2 = {};
  const defaultTransforms = settings.defaultTransforms || {};
  const registerTransform = (declaration) => {
    asArray(declaration).forEach((x) => {
      transforms2[x.name] = x;
    });
  };
  const nodeElementIndex = {};
  const elementSourceIndex = {};
  const elementSourceTypeIndex = {};
  const getElementsBySourceType = (type) => {
    return elementSourceTypeIndex[type] || [];
  };
  const getElementsBySource = (sourceId) => {
    return elementSourceIndex[sourceId] || [];
  };
  const getElementByNodeId = (name2) => {
    return nodeElementIndex[name2];
  };
  const getTransformByName = (name2) => {
    return transforms2[name2];
  };
  compositor2.on("SourceChanged", (source2) => {
    const elements = getElementsBySource(source2.id);
    elements.forEach((element) => {
      const node = compositor2.getNode(element.nodeId);
      element._onUpdateHandlers.forEach((x) => x(node.props || {}));
    });
  });
  compositor2.on("AvailableSourcesChanged", ({
    type,
    sources: sources2
  }) => {
    const elements = getElementsBySourceType(type);
    elements.forEach((x) => {
      updateSourceForNode(x.nodeId);
    });
  });
  const updateSourceForNode = (nodeId) => {
    var _a2, _b, _c;
    const element = getElementByNodeId(nodeId);
    if (!element)
      return;
    const transform = getTransformByName(element.transformName);
    if (!transform.useSource)
      return;
    const node = compositor2.getNode(nodeId);
    const elementSourceType = element.proxySource ? element.proxySource : element.sourceType;
    const sources2 = sourceManager.getSources(elementSourceType);
    const source2 = transform.useSource(sources2, node.props);
    const previousValue = element.sourceValue;
    const newValue = source2 == null ? void 0 : source2.value;
    if (element.source !== source2) {
      if (elementSourceIndex[(_a2 = element.source) == null ? void 0 : _a2.id]) {
        elementSourceIndex[(_b = element.source) == null ? void 0 : _b.id] = elementSourceIndex[(_c = element.source) == null ? void 0 : _c.id].filter((x) => x.nodeId !== nodeId);
      }
      elementSourceIndex[source2 == null ? void 0 : source2.id] = [...elementSourceIndex[source2 == null ? void 0 : source2.id] || [], element];
    }
    element.source = source2;
    element.sourceValue = newValue;
    if (!Object.is(previousValue, newValue)) {
      element._onNewSourceHandlers.forEach((x) => x(source2));
    }
  };
  const renderTree = (node) => {
    const element = getElement(node);
    const filters = [];
    const result = runFilters(node, filters);
    updateSourceForNode(node.id);
    element == null ? void 0 : element._onUpdateHandlers.forEach((x) => x(node.props || {}));
    return {
      ...result,
      children: result.children.map(renderTree)
    };
  };
  const getElement = (node) => {
    if (nodeElementIndex[node.id])
      return nodeElementIndex[node.id];
    const {
      props = {}
    } = node;
    const {
      sourceType,
      proxySource
    } = props;
    if (!sourceType)
      return null;
    let transformName = defaultTransforms[sourceType];
    let transform;
    if (transformName) {
      transform = transforms2[transformName];
    } else {
      transform = Object.values(transforms2).find((x) => x.sourceType === sourceType);
    }
    if (!transform) {
      throw new Error("Could not find matching transform for sourceType: " + sourceType);
    }
    const _onNewSourceHandlers = [];
    const _onUpdateHandlers = [];
    const _onRemoveHandlers = [];
    const _disposables = [];
    const create7 = transform.create || createDefault;
    const result = {
      ...create7({
        onEvent: (event2, cb, ...args) => {
          const dispose = compositor2.on(event2, cb, ...args);
          _disposables.push(dispose);
          return dispose;
        },
        onNewSource: (cb) => _onNewSourceHandlers.push(cb),
        onUpdate: (cb) => _onUpdateHandlers.push(cb),
        onRemove: (cb) => _onRemoveHandlers.push(cb)
      }, node.props),
      proxySource,
      sourceType,
      nodeId: node.id,
      transformName: transform.name,
      _onNewSourceHandlers,
      _onUpdateHandlers,
      _disposables
    };
    nodeElementIndex[node.id] = result;
    const elementSourceType = proxySource ? proxySource : sourceType;
    elementSourceTypeIndex[elementSourceType] = [...elementSourceTypeIndex[elementSourceType] || [], result];
    if (transform.useSource) {
      updateSourceForNode(node.id);
    }
    const listeners2 = [compositor2.on("NodeRemoved", ({
      nodeId
    }) => {
      if (nodeId === node.id) {
        const node2 = compositor2.getNode(nodeId);
        const {
          sourceType: sourceType2 = "Element"
        } = node2.props;
        listeners2.forEach((x) => x == null ? void 0 : x());
        _disposables.forEach((x) => x == null ? void 0 : x());
        _onRemoveHandlers.forEach((x) => x == null ? void 0 : x());
        delete nodeElementIndex[node2.id];
        const elementSourceType2 = proxySource ? proxySource : sourceType2;
        elementSourceTypeIndex[elementSourceType2] = elementSourceTypeIndex[elementSourceType2].filter((x) => x !== nodeElementIndex[node2.id]);
      }
    })];
    return result;
  };
  return {
    transforms: transforms2,
    nodeElementIndex,
    elementSourceTypeIndex,
    registerTransform,
    getElementsBySourceType,
    getElementByNodeId,
    getTransformByName,
    updateSourceForNode,
    renderTree,
    getElement
  };
};
const TRANSITION_DURATION = 300;
const findLayoutUp = (start2, comparator, failedAttempts = 0) => {
  const MAX_FAILED_TRAVERSAL_DEPTH = 4;
  const parent2 = start2.parentElement;
  if (parent2 instanceof Layout) {
    failedAttempts = 0;
    if (!comparator)
      return parent2;
    if (comparator(parent2))
      return parent2;
  }
  if (parent2) {
    if (failedAttempts > MAX_FAILED_TRAVERSAL_DEPTH)
      return null;
    return findLayoutUp(parent2, comparator, failedAttempts + 1);
  }
  return null;
};
const TRANSITION_FIELDS = "opacity, transform, width, height, left, right, top, bottom, inset";
const layoutIndex = {};
const parentIdIndex = {};
const childIndex = {};
let rootLayout;
let _cid = 1;
const ignoredAttributes = ["style", "id", "className"];
let tickOps = {};
const tick = () => {
  nextTick = null;
  if (window.__dragging) {
    nextTick = nextTick || requestAnimationFrame(tick);
    return;
  }
  const inserted = /* @__PURE__ */ new Set();
  const removed = /* @__PURE__ */ new Set();
  const removeFinished = /* @__PURE__ */ new Set();
  Object.entries(tickOps).forEach(([layoutId, ops]) => {
    ops.forEach(([type, layoutId2, childId]) => {
      switch (type) {
        case "childInserted": {
          if (removed.has(childId)) {
            removed.delete(childId);
          } else {
            inserted.add(childId);
          }
          break;
        }
        case "childRemoved": {
          if (inserted.has(childId)) {
            inserted.delete(childId);
          } else {
            removed.add(childId);
          }
          break;
        }
        case "childRemoveFinished": {
          removeFinished.add(childId);
          break;
        }
      }
    });
  });
  try {
    removed.forEach((x) => {
      var _a2, _b, _c;
      const el = childIndex[x];
      const childList = Array.from(((_a2 = el.parentEl) == null ? void 0 : _a2.children) || []);
      if (el.nextSiblingEl && childList.includes(el.nextSiblingEl)) {
        (_b = el.parentEl) == null ? void 0 : _b.insertBefore(el, el.nextSiblingEl);
      } else {
        el.nextSiblingEl = null;
        (_c = el.parentEl) == null ? void 0 : _c.append(el);
      }
      el.runRemove();
    });
    removeFinished.forEach((x) => {
      const el = childIndex[x];
      if (el.removed) {
        if (el.previousSiblingEl) {
          el.previousSiblingEl.nextSiblingEl = el.nextSiblingEl;
        }
        if (el.nextSiblingEl) {
          el.nextSiblingEl.previousSiblingEl = el.previousSiblingEl;
        }
        return;
      }
    });
    const scale = window.__scale;
    Object.entries(tickOps).forEach(([layoutId, ops]) => {
      const layoutEl = layoutIndex[layoutId];
      const rect = layoutEl.getBoundingClientRect();
      const size = {
        x: rect.width / scale,
        y: rect.height / scale
      };
      layoutEl.updatePositions({
        size,
        inserted,
        removed
      });
    });
  } catch (e2) {
    log$1.warn("Failed to run Layout ops", e2);
  }
  tickOps = {};
};
let nextTick;
const queueOp = (op) => {
  const [_, nodeId] = op;
  const nodeOps = tickOps[nodeId] || [];
  tickOps[nodeId] = [...nodeOps, op];
  nextTick = nextTick || requestAnimationFrame(tick);
};
class Layout extends HTMLElement {
  constructor() {
    super();
    this.isFirst = true;
    this.isUpdating = false;
    this.cid = ++_cid;
  }
  log(...args) {
    var _a2;
    log$1.debug(...args, {
      id: this.dataset.id,
      parent: (_a2 = this.parentLayout) == null ? void 0 : _a2.dataset.id
    }, this);
  }
  connectedCallback() {
    var _a2;
    this.parentEl = this.parentElement;
    this.parentLayout = findLayoutUp(this);
    this.slotEl = this.closest(`[data-layout-child]`);
    Array.from(this.children).forEach((x) => this.initializeChild(x));
    if (!rootLayout)
      rootLayout = this;
    layoutIndex[this.dataset.id] = this;
    parentIdIndex[this.dataset.id] = (_a2 = this.parentLayout) == null ? void 0 : _a2.id;
    Object.assign(this.style, {
      width: "100%",
      height: "100%",
      position: "absolute",
      top: "0px",
      left: "0px",
      pointerEvents: "none",
      boxSizing: "border-box"
    });
    if (this.mutationObserver)
      this.mutationObserver.disconnect();
    this.mutationObserver = new MutationObserver((mutations) => {
      if (!this.isConnected)
        return;
      mutations.forEach((x) => {
        if (x.type === "attributes" && !ignoredAttributes.includes(x.attributeName)) {
          queueOp(["attributesChanged", this.dataset.id]);
        } else if (x.type === "childList") {
          x.addedNodes.forEach((child) => {
            const inMemory = childIndex[child.dataset.id];
            if (child.removed)
              return;
            if (!inMemory) {
              this.initializeChild(child);
            } else if (inMemory !== child) {
              this.initializeChild(child);
              child.setAttribute("style", inMemory.getAttribute("style"));
              child.data = inMemory.data;
            }
            queueOp(["childInserted", this.dataset.id, child.dataset.id]);
          });
          x.removedNodes.forEach((child) => {
            if (child.removed)
              return;
            queueOp(["childRemoved", this.dataset.id, child.dataset.id]);
          });
        }
      });
    });
    this.mutationObserver.observe(this, {
      childList: true,
      attributes: true
    });
    if (!this.latestSize) {
      queueOp(["attributesChanged", this.dataset.id]);
    }
  }
  disconnectedCallback() {
  }
  adoptedCallback() {
  }
  updatePositions(options) {
    if (this.isUpdating)
      return;
    this.isUpdating = true;
    const {
      size,
      inserted = /* @__PURE__ */ new Set(),
      removed = /* @__PURE__ */ new Set()
    } = options;
    this.nodes = Array.from(this.children || []).filter((x) => !x.removed).map((x, i2) => {
      const props2 = getElementAttributes(x);
      return {
        id: x.dataset.id,
        props: props2,
        children: []
      };
    });
    const props = JSON.parse(this.getAttribute("props") || "{}");
    this.latestSize = size;
    const layoutArgs = {
      id: this.dataset.id,
      props,
      children: this.nodes,
      size
    };
    let positions = layoutChildren(layoutArgs);
    Promise.all(Object.entries(positions).map(async ([id, childPosition]) => {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      let childEl = childIndex[id] || this.querySelector(`[data-layout-child][data-id="${id}"]`);
      const data2 = {
        ...childEl.data,
        ...childPosition
      };
      childEl.data = data2;
      const {
        size: size2,
        position,
        zIndex = 1,
        opacity = 1,
        borderRadius = 0,
        entryTransition = {},
        exitTransition = {}
      } = data2;
      if (childEl) {
        if (childEl.removed)
          return;
        if (exitTransition)
          childEl.data.exitTransition = exitTransition;
        if (entryTransition)
          childEl.data.entryTransition = entryTransition;
        childEl.data.size = size2;
        childEl.data.position = position;
        const scale = window.__scale;
        const parentPosition = this.getBoundingClientRect();
        const parentWidth = parentPosition.width / scale;
        const childRight = parentWidth - sizeToNum(position.x, parentWidth) - sizeToNum(size2.x, parentWidth);
        const parentHeight = parentPosition.height / scale;
        const childBottom = parentHeight - sizeToNum(position.y, parentHeight) - sizeToNum(size2.y, parentHeight);
        Object.assign(childEl.style, {
          position: "absolute",
          transformOrigin: "50% 50%",
          transitionDuration: "0ms",
          transitionDelay: "0ms",
          transform: `translate3d(0, 0, 0) scaleX(1) scaleY(1)`,
          visibility: "visible",
          boxSizing: "border-box",
          overflow: "hidden",
          borderRadius: borderRadius + "px",
          width: "auto",
          height: "auto"
        });
        let delay2 = "0ms";
        let duration = this.isFirst ? asDuration(0) : asDuration(TRANSITION_DURATION);
        const withEntry = inserted.has(id);
        if (withEntry) {
          Object.assign(childEl.style, {
            transitionProperty: TRANSITION_FIELDS,
            transitionDuration: "0ms",
            transitionTimingFunction: (_a2 = entryTransition.timingFn) != null ? _a2 : "ease",
            transform: `translate3d(calc(${asSize((_c = (_b = entryTransition.offset) == null ? void 0 : _b.x) != null ? _c : 0)}), calc(${asSize((_e = (_d = entryTransition.offset) == null ? void 0 : _d.y) != null ? _e : 0)}), 0) scaleX(${(_g = (_f = entryTransition.scale) == null ? void 0 : _f.x) != null ? _g : 1}) scaleY(${(_i = (_h = entryTransition.scale) == null ? void 0 : _h.y) != null ? _i : 1})`,
            opacity: (_j = entryTransition.opacity) != null ? _j : opacity,
            left: asSize(position.x) || 0,
            right: asSize(childRight) || 0,
            top: asSize(position.y) || 0,
            bottom: asSize(childBottom) || 0
          });
          delay2 = asDuration((_k = entryTransition.delay) != null ? _k : 0);
        } else if (childEl.data.rootOffset) {
          const rootPosition = rootLayout.getBoundingClientRect();
          const parentPosition2 = this.getBoundingClientRect();
          const parentOffset = {
            x: parentPosition2.x / scale - rootPosition.x / scale,
            y: parentPosition2.y / scale - rootPosition.y / scale
          };
          const parentRight = parentOffset.x + parentPosition2.width / scale;
          const childRight2 = childEl.data.rootOffset.x + Number(childEl.data.size.x);
          const parentBottom = parentOffset.y + parentPosition2.height / scale;
          const childBottom2 = childEl.data.rootOffset.y + Number(childEl.data.size.y);
          ({
            x: childEl.data.rootOffset.x - parentOffset.x,
            y: childEl.data.rootOffset.y - parentOffset.y,
            right: parentRight - childRight2,
            bottom: parentBottom - childBottom2
          });
        }
        childEl.addEventListener("transitionstart", () => {
          childEl.style.zIndex = String(zIndex + 1);
        });
        await new Promise((resolve) => window.setTimeout(resolve));
        Object.assign(childEl.style, {
          transitionProperty: TRANSITION_FIELDS,
          transitionDuration: duration,
          transitionDelay: delay2,
          transform: `translate3d(0, 0, 0) scaleX(1) scaleY(1)`,
          opacity,
          left: asSize(position.x) || 0,
          top: asSize(position.y) || 0,
          width: parentWidth ? "auto" : size2.x,
          right: parentWidth ? asSize(childRight) || 0 : "auto",
          height: parentHeight ? "auto" : size2.y,
          bottom: parentHeight ? asSize(childBottom) || 0 : "auto",
          zIndex
        });
        const updateRootOffset = () => {
          const rootPosition = rootLayout.getBoundingClientRect();
          const globalPosition = childEl.getBoundingClientRect();
          childEl.data.rootOffset = {
            x: globalPosition.x / scale - rootPosition.x / scale,
            y: globalPosition.y / scale - rootPosition.y / scale
          };
        };
        updateRootOffset();
        childEl.addEventListener("transitionend", () => {
          childEl.style.zIndex = String(zIndex);
          updateRootOffset();
        });
      }
    })).then(() => {
      this.isUpdating = false;
    });
    this.isFirst = false;
    Array.from(this.querySelectorAll("ls-layout")).forEach((x) => {
      if (!positions[x.dataset.id])
        return;
      const childSize = positions[x.dataset.id].size;
      x.updatePositions({
        size: {
          x: sizeToNum(childSize.x, size.x),
          y: sizeToNum(childSize.y, size.y)
        }
      });
    });
  }
  initializeChild(childEl) {
    var _a2;
    if (!((_a2 = childEl.dataset) == null ? void 0 : _a2.id))
      return log$1.warn("Layout: Child requires `data-id` at the time it is added to a Layout");
    childEl._remove = childEl.remove;
    childEl.remove = () => {
      this.removeChild(childEl);
    };
    if (!childEl.mutationObserver) {
      childEl.mutationObserver = new MutationObserver((mutations) => {
        mutations.forEach((x) => {
          if (x.type === "attributes") {
            if (x.attributeName === "style")
              return;
            queueOp(["childAttributesChanged", this.dataset.id, childEl.dataset.id]);
          }
        });
      });
      childEl.mutationObserver.observe(childEl, {
        childList: true,
        attributes: true
      });
    }
    const data2 = {
      entryTransition: {
        delay: 0,
        opacity: 0,
        scale: {
          x: 1,
          y: 1
        },
        offset: {
          x: 0,
          y: 0
        }
      },
      exitTransition: {
        delay: 0,
        opacity: 0,
        scale: {
          x: 1,
          y: 1
        },
        offset: {
          x: 0,
          y: 0
        }
      },
      position: {
        x: 0,
        y: 0
      },
      size: {
        x: 0,
        y: 0
      },
      opacity: 0,
      fit: "cover",
      borderRadius: 0,
      zIndex: 1
    };
    childEl.data = data2;
    childEl.parentEl = childEl.parentElement;
    childEl.nextSiblingEl = childEl.nextSibling;
    childEl.previousSiblingEl = childEl.previousSibling;
    if (childEl.previousSiblingEl) {
      childEl.previousSiblingEl.nextSiblingEl = childEl;
    }
    childEl.toggleAttribute("data-layout-child", true);
    childIndex[childEl.dataset.id] = childEl;
    childEl.runRemove = async () => {
      var _a3, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      childEl.removed = true;
      const duration = TRANSITION_DURATION;
      await new Promise((resolve) => window.setTimeout(resolve));
      Object.assign(childEl.style, {
        zIndex: 0,
        transitionDelay: asDuration(0),
        transitionDuration: asDuration(duration),
        transitionProperty: TRANSITION_FIELDS,
        transitionTimingFunction: (_a3 = data2.exitTransition.timingFn) != null ? _a3 : "ease",
        transform: `translate3d(calc(${asSize((_c = (_b = data2.exitTransition.offset) == null ? void 0 : _b.x) != null ? _c : 0)}), calc( ${asSize((_e = (_d = data2.exitTransition.offset) == null ? void 0 : _d.y) != null ? _e : 0)}), 0) scaleX(${(_g = (_f = data2.exitTransition.scale) == null ? void 0 : _f.x) != null ? _g : 1}) scaleY(${(_i = (_h = data2.exitTransition.scale) == null ? void 0 : _h.y) != null ? _i : 1})`,
        opacity: (_j = data2.exitTransition.opacity) != null ? _j : 0
      });
      childEl.removed = true;
      childEl.transition = new Promise((resolve) => {
        const onFinished = () => {
          childEl.transition = null;
          childEl._remove();
          queueOp(["childRemoveFinished", this.dataset.id, childEl.dataset.id]);
          clearTimeout(timeout2);
          resolve();
        };
        const timeout2 = window.setTimeout(onFinished, parseInt(String(duration)) + 600);
        childEl.addEventListener("transitionend", onFinished, {
          once: true
        });
      });
      return childEl.transition;
    };
  }
}
const ensureLayoutContainer = (size) => {
  const existing = document.getElementById("__ls-layout-container");
  if (existing) {
    Object.assign(existing.style, {
      width: size.x + "px",
      height: size.y + "px"
    });
    return existing;
  }
  const container = document.createElement("div");
  container.id = "__ls-layout-container";
  Object.assign(container.style, {
    position: "fixed",
    visibility: "hidden",
    top: 0 + "px",
    left: 0 + "px",
    zIndex: -1,
    width: size.x + "px",
    height: size.y + "px"
  });
  document.body.append(container);
  return container;
};
const layoutChildren = ({
  id,
  props = {},
  children,
  size
}) => {
  const layoutArgs = {
    props,
    children,
    size
  };
  const result = htmlLayouts[props.layout] ? htmlLayouts[props.layout].layout(layoutArgs) : htmlLayouts.Free.layout(layoutArgs);
  if (!(result instanceof HTMLElement)) {
    return result;
  }
  const domChildren = Array.from(result.querySelectorAll("[data-node-id]"));
  const wrapper = document.createElement("div");
  wrapper.style.height = result.style.height = size.y + "px";
  wrapper.style.width = result.style.width = size.x + "px";
  wrapper.style.position = "absolute";
  wrapper.style.top = "0px";
  wrapper.style.left = "0px";
  wrapper.style.boxSizing = "border-box";
  wrapper.setAttribute("data-wrapper-id", id);
  wrapper.append(result);
  const layoutContainer = ensureLayoutContainer(size);
  const previousDom = layoutContainer.querySelector(`[data-wrapper-id="${id}"]`);
  if (previousDom) {
    previousDom.replaceWith(wrapper);
  } else {
    layoutContainer.append(wrapper);
  }
  const parentRect = result.getBoundingClientRect();
  const positions = {};
  domChildren.forEach((el) => {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    const id2 = el.dataset.nodeId;
    if (!id2)
      return;
    const opacity = Number((_a2 = el.dataset.opacity) != null ? _a2 : el.style.opacity || 1);
    const rect = el.getBoundingClientRect();
    let newPosition = {
      position: {
        x: rect.x - parentRect.x + "px",
        y: rect.y - parentRect.y + "px"
      },
      size: {
        x: rect.width + "px",
        y: rect.height + "px"
      },
      opacity,
      zIndex: (_b = el.data) == null ? void 0 : _b.zIndex,
      entryTransition: (_d = (_c = el.data) == null ? void 0 : _c.entryTransition) != null ? _d : {},
      exitTransition: (_f = (_e = el.data) == null ? void 0 : _e.exitTransition) != null ? _f : {},
      borderRadius: (_h = (_g = el.data) == null ? void 0 : _g.borderRadius) != null ? _h : 0
    };
    if (`${props.showcase}-x` === id2) {
      newPosition.position = {
        x: parentRect.x + "px",
        y: parentRect.y + "px"
      };
      newPosition.size = {
        x: parentRect.width + "px",
        y: parentRect.height + "px"
      };
      newPosition.zIndex = 10;
    }
    positions[id2] = newPosition;
    positionIndex[el.dataset.nodeId] = newPosition;
  });
  return positions;
};
const positionIndex = {};
const htmlLayouts = {};
const registerLayout = (declaration) => {
  asArray(declaration).forEach((x) => {
    htmlLayouts[x.name] = x;
  });
};
const sourceTypes = {};
const init$1 = (settings = {}, compositor2) => {
  const sourceIndex = {};
  const sourceTypeIndex = {};
  const handleSourceChanged = (source2) => {
    compositor2.triggerEvent("SourceChanged", source2);
  };
  const handleSourcesChanged = (type) => {
    compositor2.triggerEvent("AvailableSourcesChanged", {
      type,
      sources: sourceTypeIndex[type]
    });
  };
  const registerSource = (declaration) => {
    asArray(declaration).forEach((x) => {
      var _a2;
      const _ensureEditPermission = (sourceId) => {
        const source2 = sourceIndex[sourceId];
        if (!source2)
          return;
        if (source2.type === x.type)
          return;
        throw new Error(`Attempted to modify source of type ${source2.type} from ${x.type}`);
      };
      (_a2 = x.init) == null ? void 0 : _a2.call(x, {
        getSource: (id) => sourceManager.getSource(id),
        removeSource: (id) => {
          _ensureEditPermission(id);
          return sourceManager.removeSource(id);
        },
        setSourceActive: (id, isActive) => {
          _ensureEditPermission(id);
          return sourceManager.setSourceActive(id, isActive);
        },
        updateSource: (id, props) => {
          _ensureEditPermission(id);
          return sourceManager.updateSource(id, props);
        },
        modifySourceValue(id, cb) {
          _ensureEditPermission(id);
          return sourceManager.modifySourceValue(id, cb);
        },
        addSource: (source2) => sourceManager.addSource(x.type, source2)
      });
      sourceTypes[x.type] = x;
    });
  };
  const sourceManager = {
    sourceIndex,
    sourceTypeIndex,
    registerSource,
    getSource: (id) => {
      return sourceIndex[id];
    },
    getSources: (type) => {
      return sourceTypeIndex[type] || [];
    },
    useSource: (id, cb) => {
      cb(sourceIndex[id]);
      return compositor2.on("SourceChanged", (payload) => {
        if (payload.id !== id)
          return;
        cb(payload);
      });
    },
    useSources: (type, cb) => {
      cb(sourceTypeIndex[type] || []);
      return compositor2.on("AvailableSourcesChanged", (payload) => {
        if (payload.type !== type)
          return;
        cb(payload.sources);
      });
    },
    addSource: (type, source2) => {
      if (!source2.id)
        throw new Error('Cannot add source without field "id"');
      if (sourceIndex[source2.id])
        return;
      if (!source2.value)
        throw new Error('Cannot add source with an empty field "value"');
      const sourceDeclaration = sourceTypes[type];
      if (!sourceDeclaration)
        throw new Error("Could not find definition for source type: " + type);
      const {
        id,
        value = null,
        props = {},
        isActive = true
      } = source2;
      sourceIndex[id] = {
        id,
        type,
        props,
        value,
        isActive
      };
      sourceTypeIndex[type] = [...sourceTypeIndex[type] || [], sourceIndex[id]];
      handleSourceChanged(sourceIndex[id]);
      handleSourcesChanged(type);
    },
    removeSource: (id) => {
      const source2 = sourceIndex[id];
      if (!source2)
        return;
      delete sourceIndex[id];
      sourceTypeIndex[source2.type] = sourceTypeIndex[source2.type].filter((x) => x.id !== id);
      handleSourcesChanged(source2.type);
    },
    updateSource: (id, props) => {
      const source2 = sourceIndex[id];
      source2.props = {
        ...source2.props,
        ...props
      };
      handleSourceChanged(source2);
      handleSourcesChanged(source2.type);
    },
    modifySourceValue: async (id, cb) => {
      const source2 = sourceIndex[id];
      await cb(source2.value);
      handleSourceChanged(source2);
    },
    setSourceActive: (id, isActive = true) => {
      const source2 = sourceIndex[id];
      source2.isActive = isActive;
      handleSourcesChanged(source2.type);
    }
  };
  return sourceManager;
};
var sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  sourceTypes,
  init: init$1
}, Symbol.toStringTag, { value: "Module" }));
var layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
const {
  forEachDown,
  insertAt,
  toDataNode,
  pull,
  replaceItem
} = Logic;
let compositor;
const start = (settings) => {
  if (compositor)
    return compositor;
  const {
    dbAdapter,
    transformSettings = {},
    sourceSettings = {}
  } = settings;
  const projectDbMap = {};
  const projectIndex = {};
  try {
    customElements.define("ls-layout", Layout);
  } catch (e2) {
    log$1.warn(e2);
  }
  const projectIdIndex = {};
  const parentIdIndex2 = {};
  const nodeIndex = {};
  let currentSubId2 = 0;
  const subscribers2 = /* @__PURE__ */ new Map();
  const subscribe2 = (cb, nodeId) => {
    if (typeof cb !== "function")
      return;
    const id = ++currentSubId2;
    subscribers2.set(id, cb);
    cb.nodeId = nodeId;
    return () => {
      subscribers2.delete(id);
    };
  };
  const on3 = (event2, cb, nodeId) => {
    return subscribe2((_event, payload) => {
      if (_event !== event2)
        return;
      cb(payload);
    }, nodeId);
  };
  const triggerEvent = (event2, payload) => {
    subscribers2.forEach((handler) => {
      if (handler.nodeId) {
        if ((payload == null ? void 0 : payload.nodeId) && (payload == null ? void 0 : payload.nodeId) === handler.nodeId) {
          handler(event2, payload);
        }
      } else {
        handler(event2, payload);
      }
    });
  };
  const compositorBase = {
    projects: projectIndex,
    subscribe: subscribe2,
    on: on3,
    triggerEvent,
    getProject: (id) => projectIndex[id],
    getNodeProject: (id) => projectIndex[projectIdIndex[id]],
    getNodeParent: (id) => nodeIndex[parentIdIndex2[id]],
    getNode: (id) => nodeIndex[id],
    createProject: async (root2 = {}, projectId) => {
      const {
        id,
        props = {},
        children = []
      } = root2;
      const nodeId = await dbAdapter(projectId, {
        get: () => null,
        getParent: () => null
      }).insert(props);
      const node = {
        id: nodeId,
        props,
        children
      };
      forEachDown(root2, (node2) => {
      });
      nodeIndex[nodeId] = node;
      return compositor.loadProject(node, projectId);
    },
    loadProject: (root2, id) => {
      if (!root2)
        return;
      id = id || root2.id;
      if (projectIndex[id])
        return projectIndex[id];
      forEachDown(root2, (node, parent2) => {
        nodeIndex[node.id] = node;
        parentIdIndex2[node.id] = parent2 == null ? void 0 : parent2.id;
        projectIdIndex[node.id] = id;
      });
      const dbApi = {
        insert: async (node, parentId, index2 = 0) => {
          if (node.id && nodeIndex[node.id])
            return nodeIndex[node.id];
          if (!node.children) {
            node.children = [];
          }
          if (!node.props) {
            node.props = {};
          }
          if (parentId) {
            const parent2 = nodeIndex[parentId];
            if (!parent2) {
              throw "Parent node not found with ID";
            }
            parent2.children = insertAt(index2, node, parent2.children || []);
            parentIdIndex2[node.id] = parentId;
          }
          nodeIndex[node.id] = node;
          projectIdIndex[node.id] = id;
          return node.id;
        },
        update: async (id2, props = {}, childIds) => {
          const current = nodeIndex[id2];
          if (childIds) {
            const children = childIds.map((x) => {
              const node = nodeIndex[x];
              parentIdIndex2[node.id] = id2;
              return node;
            });
            current.children = children;
          }
          current.props = {
            ...current.props,
            ...props
          };
        },
        remove: async (id2) => {
          const parent2 = nodeIndex[parentIdIndex2[id2]];
          if (parent2) {
            parent2.children = parent2.children.filter((x) => x.id !== id2);
          }
          const self2 = nodeIndex[id2];
          forEachDown(self2, (node) => {
            if (nodeIndex[node.id]) {
              nodeIndex[node.id]._deleted = true;
            }
            triggerEvent("NodeRemoved", {
              projectId: project.id,
              nodeId: node.id
            });
          });
        }
      };
      const project = {
        id,
        getRoot: () => root2,
        get(id2) {
          return nodeIndex[id2];
        },
        getParent(id2) {
          return nodeIndex[parentIdIndex2[id2]];
        },
        renderTree() {
          return transformManager.renderTree(root2);
        },
        local: dbApi,
        insert: async (props = {}, parentId, index2 = 0) => {
          const id2 = await projectDb.insert(props, parentId, index2);
          const node = {
            id: id2,
            props,
            children: []
          };
          return dbApi.insert(node, parentId, index2);
        },
        update: async (id2, props) => {
          await dbApi.update(id2, props);
          return projectDb.update(id2, props);
        },
        remove: async (id2) => {
          await dbApi.remove(id2);
          const parent2 = nodeIndex[parentIdIndex2[id2]];
          const children = parent2.children.filter((x) => x.id !== id2);
          return projectDb.batch([["delete", {
            id: id2
          }], ["update", {
            ...parent2,
            children
          }]]);
        },
        reorder: async (parentId, childIds) => {
          const parent2 = nodeIndex[parentId];
          parent2.children = childIds.map((x) => parent2.children.find((y) => y.id === x));
          return projectDb.batch([["update", parent2]]);
        },
        move: async (id2, newParentId, index2 = 0) => {
          const node = nodeIndex[id2];
          const prevParent = nodeIndex[parentIdIndex2[id2]];
          const newParent = nodeIndex[newParentId];
          prevParent.children = pull(prevParent.children, node);
          newParent.children = insertAt(index2, node, newParent.children);
          projectDb.batch([["update", newParent], ["update", prevParent]]);
          parentIdIndex2[id2] = newParentId;
          return;
        },
        swap: async (idA, idB) => {
          const nodeA = nodeIndex[idA];
          const nodeB = nodeIndex[idB];
          const parentA = nodeIndex[parentIdIndex2[idA]];
          const parentB = nodeIndex[parentIdIndex2[idB]];
          parentA.children = replaceItem((node) => node.id === idA, nodeB, parentA.children);
          parentB.children = replaceItem((node) => node.id === idB, nodeA, parentB.children);
          parentIdIndex2[idA] = parentB.id;
          parentIdIndex2[idB] = parentA.id;
          projectDb.batch([["update", parentA], ["update", parentB]]);
          return;
        }
      };
      Object.defineProperty(project, "nodes", {
        get() {
          return Object.values(nodeIndex).filter((x) => projectIdIndex[x.id] === project.id);
        }
      });
      const projectDb = projectDbMap[id] || dbAdapter(id, {
        get: (id2) => toDataNode(project.get(id2)),
        getParent: (id2) => toDataNode(project.getParent(id2))
      });
      projectDbMap[id] = projectDb;
      projectIndex[id] = project;
      return project;
    }
  };
  const sourceManager = init$1(sourceSettings, compositorBase);
  const transformManager = init$2(transformSettings, compositorBase, sourceManager);
  compositor = {
    registerLayout,
    registerTransform: transformManager.registerTransform,
    registerSource: sourceManager.registerSource,
    getElement: transformManager.getElement,
    getSource: sourceManager.getSource,
    getSources: sourceManager.getSources,
    useSource: sourceManager.useSource,
    useSources: sourceManager.useSources,
    ...compositorBase
  };
  return compositor;
};
var index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Transform: transforms,
  Layout: layouts,
  Source: sources,
  start
}, Symbol.toStringTag, { value: "Module" }));
const createProject = async (request3) => {
  const collectionId = getUser().id;
  const type = request3.type || "sceneless";
  const size = request3.size || {
    x: 1280,
    y: 720
  };
  const settings = request3.settings || {};
  let createProjectResponse = await CoreContext.clients.LiveApi().project.createProject({
    collectionId,
    rendering: {
      video: {
        width: size.x,
        height: size.y,
        framerate: 30
      }
    },
    composition: {
      studioSdk: {
        version: CoreContext.rendererVersion
      }
    },
    metadata: {},
    webrtc: {
      hosted: {}
    }
  });
  const layout = await createLayout({
    projectId: createProjectResponse.project.projectId,
    collectionId: createProjectResponse.project.collectionId,
    settings,
    size,
    type
  });
  const {
    displayName
  } = getAccessTokenData();
  const metadata = {
    type,
    layoutId: layout.id,
    hostDisplayName: displayName,
    props: request3.props || {}
  };
  let projectResponse = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId,
    projectId: createProjectResponse.project.projectId,
    updateMask: ["metadata"],
    metadata
  });
  createProjectResponse.project = projectResponse.project;
  createProjectResponse.project.metadata = metadata;
  return createProjectResponse;
};
const deleteProject = async (request3) => {
  const {
    projectId
  } = request3;
  const project = getProject(projectId);
  const collectionId = getUser().id;
  await Promise.all([CoreContext.clients.LiveApi().project.deleteProject({
    collectionId,
    projectId
  }), CoreContext.clients.LayoutApi().layout.deleteLayout({
    layoutId: project.layoutApi.layoutId
  })]);
};
const loadUser = async (size) => {
  var _a2;
  const collections = await loadCollections();
  let collection;
  const {
    displayName,
    serviceUserId
  } = getAccessTokenData();
  if (collections.length === 0) {
    const response = await CoreContext.clients.LiveApi().collection.createCollection({
      metadata: {
        serviceUserId,
        displayName,
        props: {}
      }
    });
    collection = response.collection;
  } else {
    collection = collections[0];
  }
  await CoreContext.clients.LiveApi().subscribeToCollection(collection.collectionId);
  const projects = await Promise.all(collection.projects.filter((p) => {
    var _a3;
    return Boolean((_a3 = p.metadata) == null ? void 0 : _a3.layoutId);
  }).map((project) => hydrateProject(project, "ROLE_HOST", size)));
  return {
    user: {
      id: collection.collectionId,
      metadata: collection.metadata,
      props: ((_a2 = collection.metadata) == null ? void 0 : _a2.props) || {},
      name: displayName
    },
    projects,
    sources: collection.sources
  };
};
const loadCollections = async () => {
  let result = await CoreContext.clients.LiveApi().collection.getCollections({});
  return result.collections;
};
const createLayout = async (request3) => {
  const {
    settings,
    size,
    type,
    projectId,
    collectionId
  } = request3;
  const layout = await CoreContext.clients.LayoutApi().layout.createLayout({
    layout: {
      projectId,
      collectionId
    }
  });
  if (type === "sceneless") {
    await createCompositor(layout.id, size, settings);
  } else {
    await CoreContext.compositor.createProject({
      props: {
        name: "Root",
        layout: "Free",
        ...settings,
        isRoot: true,
        size
      }
    }, layout.id);
  }
  return layout;
};
var requests = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createProject,
  deleteProject,
  loadUser,
  loadCollections,
  createLayout
}, Symbol.toStringTag, { value: "Module" }));
const BroadcastPhase = lib$2.LiveApiModel.ProjectBroadcastPhase;
const {
  trigger,
  triggerInternal
} = CoreContext;
const EventType = lib$2.LiveApiModel.EventType;
const EventSubType = lib$2.LiveApiModel.EventSubType;
const init = async (settings = {}) => {
  const env = settings.env || "prod";
  const logLevel = settings.logLevel || "Warn";
  const livekitLogger2 = log$1.getLogger("livekit");
  livekitLogger2.setLevel(logLevel);
  log$1.setLevel(logLevel);
  log$1.info("Initializing Studio SDK...");
  const {
    layouts: layouts2 = [],
    transforms: transforms2 = [],
    sources: sources2 = [],
    defaultTransforms = {},
    useLatestRenderer = false,
    guestToken
  } = settings;
  const client = new lib$2.ApiStream({
    sdkVersion: CoreContext.version,
    env,
    logLevel
  });
  const conf = config$1();
  const compositor2 = start({
    dbAdapter: compositorAdapter,
    transformSettings: {
      defaultTransforms: {
        ...defaultTransforms,
        ...conf.defaults.transforms
      }
    }
  });
  CoreContext.config = conf;
  CoreContext.clients = client;
  CoreContext.compositor = compositor2;
  CoreContext.logLevel = logLevel;
  CoreContext.Request = await Promise.resolve().then(function() {
    return requests;
  });
  CoreContext.Command = await Promise.resolve().then(function() {
    return commands$1;
  });
  CoreContext.rendererVersion = useLatestRenderer ? "latest-v2" : CoreContext.version;
  window.__StudioKit = {
    ...CoreContext
  };
  if (compositor2) {
    compositor2.registerSource([...Object.values(Sources), ...sources2]);
    compositor2.registerTransform([...Object.values(Transforms), ...transforms2]);
    compositor2.registerLayout([...Object.values(Layouts), ...layouts2]);
  }
  const guestProject = await client.load(guestToken);
  let initialProject;
  if (guestProject) {
    await client.LiveApi().project.getProject({
      ...guestProject
    }).then((resp) => hydrateProject(resp.project, guestProject.role)).then(async (project) => {
      setAppState({
        user: {
          id: guestProject.collectionId,
          props: {},
          name: null,
          metadata: {}
        },
        sources: [],
        projects: [project],
        activeProjectId: null
      });
      project.isInitial = true;
      initialProject = await CoreContext.Command.setActiveProject({
        projectId: project.id
      });
    });
  }
  client.LiveApi().on(EventType.EVENT_TYPE_COLLECTION, (event2, type) => {
    log$1.info("Received: Collection event", type, event2);
    switch (type) {
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        triggerInternal("UserChanged", event2.update.collection);
        return;
      }
    }
  });
  client.LiveApi().on(EventType.EVENT_TYPE_DESTINATION, (event2, type) => {
    log$1.info("Received: Destination event", type, event2);
    switch (type) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        const {
          destination
        } = event2.create;
        triggerInternal("DestinationAdded", destination);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        const {
          destination
        } = event2.update;
        triggerInternal("DestinationChanged", destination);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("DestinationRemoved", event2.delete);
        return;
      }
    }
  });
  client.LiveApi().on(EventType.EVENT_TYPE_SOURCE, (event2, type) => {
    log$1.info("Received: Source event", type, event2);
    switch (type) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        triggerInternal("SourceAdded", event2.create.source);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        triggerInternal("SourceChanged", event2.update.source);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("SourceRemoved", event2.delete.sourceId);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_ADD: {
        triggerInternal("ProjectSourceAdded", {
          projectId: event2.add.projectId,
          source: event2.add.source
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_REMOVE: {
        triggerInternal("ProjectSourceRemoved", {
          projectId: event2.add.projectId,
          sourceId: event2.add.sourceId
        });
        return;
      }
    }
  });
  client.LiveApi().on(EventType.EVENT_TYPE_PROJECT, (event2, type) => {
    var _a2;
    log$1.info("Received: Project event", type, event2);
    switch (type) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        const project = event2.create.project;
        if (getProject(project.projectId))
          return;
        triggerInternal("ProjectAdded", project);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        const {
          projectId,
          updateMask,
          project
        } = event2.update;
        const existingProject = getProject(project.projectId);
        if (!existingProject)
          return;
        if (updateMask.includes("metadata")) {
          trigger("ProjectMetaUpdated", {
            projectId,
            meta: project.metadata
          });
        }
        triggerInternal("ProjectChanged", {
          project,
          phase: existingProject.videoApi.phase
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("ProjectRemoved", {
          projectId: event2.delete.projectId
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_STATE: {
        const project = getProject((_a2 = event2.state) == null ? void 0 : _a2.projectId);
        if (!project)
          return;
        let broadcastId = event2.state.broadcastId;
        if (event2.state.error) {
          trigger("BroadcastError", {
            projectId: project.id,
            broadcastId: event2.state.broadcastId,
            error: event2.state.error
          });
        }
        if (event2.state.phase) {
          const phase = event2.state.phase;
          if (phase === BroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING) {
            trigger("BroadcastStarted", {
              projectId: project.id,
              broadcastId: event2.state.broadcastId
            });
          } else if (phase === BroadcastPhase.PROJECT_BROADCAST_PHASE_STOPPED) {
            broadcastId = null;
            trigger("BroadcastStopped", {
              projectId: project.id,
              broadcastId: event2.state.broadcastId
            });
          }
        }
        triggerInternal("ProjectChanged", {
          project: project.videoApi.project,
          phase: event2.state.phase,
          broadcastId
        });
        return;
      }
    }
  });
  client.LayoutApi().on(lib$2.LayoutApiModel.EventType.EVENT_TYPE_LAYER, (layer, type) => {
    var _a2;
    if (type === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_CREATE) {
      log$1.debug("Received: Node Insert", layer.create);
      const {
        connectionId: connectionId2,
        layoutId
      } = layer.create.requestMetadata;
      if (CoreContext.connectionId === connectionId2)
        return;
      const node = layerToNode(layer.create);
      const project = getProjectByLayoutId(layoutId);
      const nodes = [node, ...project.compositor.nodes.map(toDataNode$1)];
      const tree = toSceneTree(nodes, node.id);
      project.compositor.local.insert(tree);
      triggerInternal("NodeAdded", {
        projectId: project.id,
        nodeId: node.id
      });
    } else if (type === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_UPDATE) {
      log$1.debug("Received: Node Update", layer.update);
      const {
        connectionId: connectionId2,
        layoutId,
        updateVersions = {}
      } = ((_a2 = layer.update) == null ? void 0 : _a2.requestMetadata) || {};
      if (CoreContext.connectionId === connectionId2)
        return;
      const node = layerToNode(layer.update);
      const latestUpdateId = latestUpdateVersion[node.id] || 0;
      if (latestUpdateId > updateVersions[node.id]) {
        return log$1.info("Ignoring node update - updateID is less than latest.");
      }
      latestUpdateVersion[node.id] = updateVersions[node.id];
      const project = getProjectByLayoutId(layoutId);
      project.compositor.local.update(layer.update.id, node.props, node.childIds);
      triggerInternal("NodeChanged", {
        projectId: project.id,
        nodeId: node.id
      });
    } else if (type === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_DELETE) {
      log$1.debug("Received: Node Delete", layer.delete);
      const {
        connectionId: connectionId2,
        layoutId
      } = layer.delete.requestMetadata;
      if (CoreContext.connectionId === connectionId2)
        return;
      const project = getProjectByLayoutId(layoutId);
      project.compositor.local.remove(layer.delete.id);
      triggerInternal("NodeRemoved", {
        projectId: project.id,
        nodeId: layer.delete.id
      });
    } else if (type === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_BATCH) {
      log$1.debug("Received: Node Batch Update", layer.batch);
      const {
        connectionId: connectionId2,
        layoutId,
        updateVersions = {}
      } = layer.batch.requestMetadata;
      if (CoreContext.connectionId === connectionId2)
        return;
      const project = getProjectByLayoutId(layoutId);
      layer.batch.layers.forEach((batch) => {
        try {
          const [type2, args] = Object.entries(batch)[0];
          if (type2 === "create") {
            const node = layerToNode(args);
            project.compositor.local.insert(node);
            triggerInternal("NodeAdded", {
              projectId: project.id,
              nodeId: node.id
            });
          } else if (type2 === "update") {
            const node = layerToNode(args);
            const latestUpdateId = latestUpdateVersion[node.id] || 0;
            if (latestUpdateId > updateVersions[node.id]) {
              return log$1.info("Ignoring node update - updateID is less than latest.");
            }
            latestUpdateVersion[node.id] = updateVersions[node.id];
            project.compositor.local.update(node.id, node.props, node.childIds);
            triggerInternal("NodeChanged", {
              projectId: project.id,
              nodeId: node.id
            });
          } else if (type2 === "delete") {
            project.compositor.local.remove(args.id);
            triggerInternal("NodeRemoved", {
              projectId: project.id,
              nodeId: args.id
            });
          }
        } catch (e2) {
          log$1.warn("Error handling batch item", e2, {
            item: batch
          });
        }
      });
      if (project)
        triggerInternal("NodeChanged", {
          projectId: project.id,
          nodeId: project.compositor.getRoot().id
        });
    }
  });
  const createGuestToken = (options = {}, url) => {
    const {
      displayName,
      role,
      maxDuration = CoreContext.config.defaults.guestTokenDuration,
      projectId = CoreContext.state.activeProjectId
    } = options;
    const project = getProject(projectId);
    const token = displayName ? {
      direct: {
        displayName
      }
    } : {
      exchange: {
        maxDuration
      }
    };
    return client.LiveApi().authentication.createGuestAccessToken({
      projectId,
      token,
      url,
      collectionId: project.videoApi.project.collectionId,
      maxDuration,
      role: role || lib$2.LiveApiModel.Role.ROLE_GUEST
    });
  };
  return {
    ...omit$1(CoreContext, ["clients", "config", "connectionId", "Request", "state", "trigger"]),
    createDemoToken: async () => {
      console.warn("createDemoToken() is currently unavailable.");
      return "";
    },
    createPreviewLink: async (request3 = {}) => {
      const {
        maxDuration,
        projectId = CoreContext.state.activeProjectId
      } = request3;
      const project = getProject(projectId);
      const url = project.videoApi.project.composition.studioSdk.rendererUrl;
      let response = await client.LiveApi().authentication.createGuestAccessToken({
        projectId,
        token: {
          direct: {
            displayName: "Preview"
          }
        },
        url,
        collectionId: project.videoApi.project.collectionId,
        maxDuration: maxDuration || CoreContext.config.defaults.previewTokenDuration,
        role: lib$2.LiveApiModel.Role.ROLE_VIEWER
      });
      return response.url;
    },
    createGuestLink: async (baseUrl, options = {}) => {
      const response = await createGuestToken(options, baseUrl);
      return response.url;
    },
    createGuestToken: async (options = {}) => {
      const response = await createGuestToken(options);
      return response.accessToken;
    },
    initialProject,
    load,
    render: render$1
  };
};
const load = async (accessToken, size) => {
  let user = getBaseUser();
  if (user) {
    log$1.info("Attempted to load user again - returning existing user");
    return user;
  }
  if (!accessToken) {
    log$1.warn("Access token required for load()");
    return;
  }
  log$1.info("Loading user...");
  const client = CoreContext.clients;
  await client.load(accessToken);
  const result = await CoreContext.Request.loadUser(size);
  setAppState({
    user: result.user,
    sources: result.sources,
    projects: result.projects,
    activeProjectId: null
  });
  user = getBaseUser();
  trigger("UserLoaded", user);
  return user;
};
export { commands$1 as Command, index as Compositor, context as Context, events$1 as Events, index$1 as Helpers, requests as Request, index$2 as Room, types$1 as SDK, init };
//# sourceMappingURL=index.es.js.map
